---
layout: post
title: 记录工作遇到的坑
date: 2016-09-24 16:30:44
categories: 技术 
tags: 
- spring
- curl
---

昨天晚上12.30才进的家门，回来之后还远程合了个代码打了个包，发布restAPI新版本之用。这一周的主要工作就是在做一个web服务器，是一个集群的中间件。因为着急发布新版本，所以昨晚加班到12点多...

主要实现了几个接口，实现了ssl双向验证功能。其实ssl双向验证的功能主要是了解ssl原理之后如何配置的问题。期间还学习了session和cookie的原理。ssl与cookie、session单开一篇进行总结。这篇日志记录一下这周工作中遇到的一些坑，不一定是技术上的，但是遇到这些小问题还是耽误了一些时间。这篇日志也会持续更新，把以后遇到的坑都总结到这里来。

希望以后遇到类似的情况能够迅速找到原因将其解决，同时也希望能帮助到可能会看到这篇文章的人。

## Spring项目通过export方法打包为jar的问题

在前面的日志中已经有[专门的一篇](http://yukai.space/2016/09/19/Spring%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAjar/)来总结这个问题:**当通过export方式打包Spring项目时，一定要记得勾选Add Directory Entries这个选项，否则spring无法正确扫描到controller，发生404**

## 使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常

假如你的项目中有一个类似下面的controller来接收一个请求：

```java
@GET
@RequestMapping("web/{groupName}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public void getWorkerAddress(HttpServletRequest request, HttpServletResponse response,
		@PathVariable String groupName) {
		doSomething...
}		

```

当你的项目运行时你发起一个`http://ip:port/web/groupName1`这样的请求，那么很有可能服务器会报这样一个异常：**java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.**

大概的意思就是参数名称信息没有在类文件中找到。若是浏览器为客户端，浏览器的页面是这样的：

{% asset_img error.png error %}

解决这个异常的方法有两种：

**1.在@PathVariable注解后面加上参数名，比如：@PathVariable("groupName")**

**2.编译时将debug信息勾选进去：**

{% asset_img compiler.png compiler %}

编译时把上图绿色框中的单选框勾选，就不会报异常。原因在于Local variable属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量名称和描述符之间的映射关系。

顺便了解一下上面四个选项的作用：

{% asset_img gengeration.png compiler %}

图片截取自：[Eclipse用户手册](http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-compiler.htm)

其实就是java工程编译时的一些选项。当我们在debug时遇到问题，比如断点打不上，source not found等等或许修改这些选项可以得到解决。

参考一篇文章：[java编译时生成调试信息选项详解（javac -g）](http://daimojingdeyu.iteye.com/blog/679030)

## Windows环境下使用Curl，要使用双引号包裹内容

web服务器是通过curl来测试的。之前自己也没用过这个所谓的命令行浏览器工具。在机器上装好curl之后，把测试那边提供的脚本拿过来，由于脚本是linux环境下的，做了一点修改之后(其实就是直接换成.bat啦)就直接跑了。脚本内容类似这样：

```
curl -X POST -H 'content-type: application/json' -d @del.txt https://localhost:8899/web/rest/data/load/topictarget  -k -b cookie.txt>delresult.txt
```

但是实际测试的过程中，发现收到的post的数据为null，确定了不是服务器的问题之后，感觉应该是curl使用的问题。查了一些资料，是说post的数据要使用双引号包裹，而不是单引号。由于是从del.txt中提取post的数据，所以不存在这个问题。后来将content-type: application/json 的单引号换成双引号之后，问题解决。

**所以：Windows环境下使用Curl，要使用双引号包裹需要加引号的内容，而不是单引号**

## Spring项目运行过程中，@Autowired注解的变量为null的问题

2016/09/09 更新

这两天开发了一个公众账号来做一些简单的记账工作。后台服务器是用springboot搭建的，测试过程中遇到了这么个情况:

在运行时服务器报了空指针NullPointerException异常，debug看了一下，发现是一个使用了@Autowired注解的变量没有被初始化。但是按理来说使用了@Autowired注解某个变量后spring会自动为我们实例化这个变量的啊！谷歌了一下，找到了一个类似的情况：[Why is my Spring @Autowired field null?](http://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null).

下面模拟一下问题出现的场景(代码来自上面的链接)：

```java
@Controller
public class MileageFeeController {    
    @RequestMapping("/mileage/{miles}")
    @ResponseBody
    public float mileageFee(@PathVariable int miles) {
        MileageFeeCalculator calc = new MileageFeeCalculator();
        return calc.mileageCharge(miles);
    }
}

@Service
public class MileageFeeCalculator {

    @Autowired
    private MileageRateService rateService; // <--- should be autowired, is null

    public float mileageCharge(final int miles) {
        return (miles * rateService.ratePerMile()); // <--- throws NPE
    }
}

@Service
public class MileageFeeCalculator {

    @Autowired
    private MileageRateService rateService; // <--- should be autowired, is null

    public float mileageCharge(final int miles) {
        return (miles * rateService.ratePerMile()); // <--- throws NPE
    }
}
```

访问MileageFeeController时报错：

```
java.lang.NullPointerException: null
    at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13)
    at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14)
```

可以看到，变量rateService是个空值。导致空指针异常...

原因就在于MileageFeeController.mileageFee中使用了new这种方式实例化了MileageFeeCalculator对象，该对象中的rateService为空，我们使用new这种方式实例化对象时，无法通过spring的@Autowired注解自动实例化对象中的属性。解决的方法就是实例化对象时应该通知spring，使其能够自动配置。

我采用了上述链接中的第三种方法，解决了问题：

```java
@Component
public class ApplicationContextHolder implements ApplicationContextAware {
    private static ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;   
    }

    public static ApplicationContext getContext() {
        return context;
    }
}

@Controller
public class MileageFeeController {    
    @RequestMapping("/mileage/{miles}")
    @ResponseBody
    public float mileageFee(@PathVariable int miles) {
        MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);
        return calc.mileageCharge(miles);
    }
}
```

发生这些问题的原因还是在于对框架的不熟悉，内部原理不甚明了。有机会真得研究研究spring的源码~~

## @RestController与@Controller

2016/10/24 更新

Springboot 使用 Thymeleaf 模板 打算给公众号加一点地图功能，按照[这个教程](https://hellokoding.com/spring-boot-hello-world-example-with-thymeleaf/)在springboot项目中配置Thymeleaf，但是每次都没有正确返回html页面，反而是返回了这个html的名称。试了几次才发现自己用错了@RestController这个注解...Controller代码如下：

```java
@RestController
@RequestMapping("/wechat")
public class MapController {
    @RequestMapping("/map/showRestaurant")
    public String showRestaurant(@RequestParam(value = "location_x", required = true) String location_x,
            @RequestParam(value = "location_y", required = true) String location_y,
            @RequestParam(value = "label", required = true) String label, Model model) {
        model.addAttribute("locationx", location_x);
        model.addAttribute("locationy", location_y);
        model.addAttribute("label",label);
        return "hello";
    }
}

```
问题原因就在于上面的@RestController这个注解，将其替换为@Controller便解决了。
 
根本原因在于@RestController与@Controller[这两个注解之间的区别](http://stackoverflow.com/questions/25242321/difference-between-spring-controller-and-restcontroller-annotation)

## Linux下可靠的启动webservice

2016/12/14 更新

今天线上webservice发现了一个问题，技服把出现的问题描述和日志发给了我，需要解决一下。最终确定不是代码的问题，而是linux下启动程序的方式引发的一个错误。虽然简单，却很容易被疏忽导致问题的发生，值得记录下来。
情况是这样的，每次springboot程序会不定时自动停止，观察log发现，每次挂掉之前都会打印一行log,大致意思是，代码中调用的系统程序tail退出了。查看代码时发现确实在tail程序退出时会打印这么一行日志，但却是正常表现，程序运行在一个死循环当中，随后就会重启tail这个程序。循环当中也做了相应的异常捕获，按道理来说webservice不应该挂掉。初步怀疑多次启动tail导致内存泄漏以至于程序退出。由于代码中没有对内存泄漏这种error类型的异常捕获和记录到日志，从日志中无法判断是否发生了内存泄漏。代码中实现了Throwable级别异常的捕获，并记录异常信息到日志，再次抛出该异常。
打包，发送给技服到测试机上去跑。一会之后，又挂了。观察新的Log，竟然与之前的没什么区别，并没有什么新的异常信息输出。也就是说，压根没有异常从代码中抛出。很有可能是程序被认为关闭或被系统干掉了。但是之前询问技服，对方否定了这种情况。
这就怪了。继续观察日志，此时，发现这么一行：`Unregistering JMX-exposed beans on shutdown`.确实是springboot退出时打印的信息。google之，大部分的答案是没有添加依赖`spring-boot-starter-web`所导致springboot无法启动。与现在的情况不符，当前情况是启动正常，运行时突然挂掉。
再次询问技服是否kill掉了运行webservice的进程。技服否认，说该程序时运行在后台的，继续询问如何运行在后台，回答是： `java -jar MyApplication.jar & `
果然，使用这种方式运行在后台的程序，当ssh断掉或关闭bash窗口后，程序依然会被系统干掉，父进程都被干掉了，子进程也一并干掉了...
正确的启动方式应为：`nohup java -jar MyApplication.jar &`

```
nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。

该命令的一般形式为：nohup command &

使用nohup命令提交作业

如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：

nohup command > myout.file 2>&1 &

在上面的例子中，输出被重定向到myout.file文件中。
```
该问题虽然不是很难解决，但是很容易被忽略。故在此记录。

## 持续更新中....








