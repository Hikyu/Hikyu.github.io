---
layout: post
title: 组合模式的妙用
date: 2017-09-16 09:40:41
categories:
- 技术
- 编程
tags: 
- java
- 设计模式
---

## 组合模式定义

{% asset_img component.jpg component %}

- Component 是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component
子部件。

- Leaf 在组合中表示叶子结点对象，叶子结点没有子结点。

- Composite 定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除

<!-- more -->

组合模式让多用于优化处理递归或分级数据结构，比如文件系统：文件系统由目录和文件组成。每个目录都可以装内容。目录的内容可以是文件，也可以是目录。按照这种方式，计算机的文件系统就是以递归结构来组织的。描述这样的数据结构，可以使用组合模式。

## 实践

### 需求

项目中有这样一个需求：上传一个zip格式的文件，服务器程序解压缩该文件，并生成json格式的文件层级描述，对于每个文件要求在json对象中包含该文件MD5、sha1、文件名以及大小。比如：

```
{
  "children": [
    {
      "children": [
        {
          "md5": "xxxxxxxxxxxx",
          "sha1": "xxxxxxxxxxxxx",
          "size": 1024,
          "path": "123.txt"
        },
        {
          "md5": "xxxxxxxxxxxx",
          "sha1": "xxxxxxxxxxxxx",
          "size": 1024,
          "path": "456.txt"
        }
      ],
      "path": "yukai"
    },
    {
      "children": [
        {
          "children": [
            {
              "md5": "xxxxxxxxxxxx",
              "sha1": "xxxxxxxxxx",
              "size": 1024,
              "path": "123.txt"
            }
          ],
          "path": "book"
        }
      ],
      "path": "zhanglei"
    }
  ],
  "path": "we.zip"
}
```
表示：
```
we.zip
  |
  |----zhanglei
  |       |
  |       |----book
  |              |
  |              |----123.txt
  |----yukai
  |      |
         |----123.txt
         |
         |----456.txt
```

### 实现

1. 根据上面提到组合模式的定义，实现文件的层级描述：

```java
public abstract class Component {
	private String path;
	public Component(String path) {
		this.path = path;
	}
	public abstract void add(Component component);
	
	public String getPath() {
		return path;
	}

	public void setPath(String path) {
		this.path = path;
	}
}

public class Composite extends Component{
	private List<Component> children;
	
	public Composite(String path) {
		super(path);
		children = new ArrayList<>();
	}

	@Override
	public void add(Component component) {
		children.add(component);
	}

}

public class Leaf extends Component {
	public Leaf(String path) {
		super(path);
	}

	private String md5;
	private String sha1;
	private long size;

	@Override
	public void add(Component component) {
		return;
	}

	public String getMd5() {
		return md5;
	}

	public void setMd5(String md5) {
		this.md5 = md5;
	}

	public String getSha1() {
		return sha1;
	}

	public void setSha1(String sha1) {
		this.sha1 = sha1;
	}

	public long getSize() {
		return size;
	}

	public void setSize(long l) {
		this.size = l;
	}

}

```
2. 写一个简单的测试类测试我们的实现：

```java
@Test
public void testComponent() {
	Composite root = new Composite("we.zip");
	Composite component1 = new Composite("yukai");
	Leaf leaf1 = new Leaf("123.txt");
	leaf1.setMd5("xxxxxxxxxxx");
	leaf1.setSha1("xxxxxxxxxxxxx");
	leaf1.setSize(1024);
	component1.add(leaf1);
	Leaf leaf2 = new Leaf("456.txt");
	leaf1.setMd5("xxxxxxxxxxx");
	leaf1.setSha1("xxxxxxxxxxxxx");
	leaf1.setSize(1024);
	Composite component2 = new Composite("zhanglei");
	Component component3 = new Composite("book");
	Leaf leaf = new Leaf("123.txt");
	leaf.setMd5("xxxxxxxx");
	leaf.setSha1("xxxxxxx");
	leaf.setSize(1024);
	component3.add(leaf);
	component2.add(component3);
	root.add(component1);
	root.add(component2);
	Gson gson = new Gson();
	String json = gson.toJson(root);
	System.out.println(json);
}
```
输出的结果正好是我们上面提到的json串。

3. 递归遍历文件目录，生成json树

上面的数据结构可以满足我们对生成的json树的格式要求，接下来便是遍历文件目录，生成组合模式中的结构，代码很简单：

```java
public void walk(Path parentPath, Component parent) throws IOException {
	File file = parentPath.toFile();
	File[] list = file.listFiles();
	if (list == null) {
		return;
	}
	Composite composite;
	Leaf leaf;
	for (File f : list) {
        String currentName = f.getName();
		if (f.isDirectory()) {
			composite = new Composite(currentName);
			parent.add(composite);
			walk(f.toPath(), composite);
		} else {
			leaf = new Leaf(currentName);
			leaf.setSize(f.length());
			leaf.setMd5(FileProvider.md5Hex(f));
			leaf.setSha1(FileProvider.sha1Hex(f));
			parent.add(leaf);
		}
	}
}
```
上面的代码使用递归的方式，遍历文件目录，生成目录结构。我们可以这样使用它：

```java
String zipFile = ".../..../..../abc.zip";
File file = new File(zipFile);
Composite root = new Composite(file.getName());
walkDirectory(file.toPath(), root);
Gson gson = new Gson();
String json = gson.toJson(root);
System.out.println(json);
```

通过上面的代码，看似复杂的生成文件json树的需求就被轻易的解决了，看起来真的很优雅！

have a nice day~~~
