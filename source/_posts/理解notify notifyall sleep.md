layout: post
title: 理解notify notifyall sleep
date: 2016-08-31 21:27:09
categories: 编程
tags:
- java
- 多线程 
---

今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。

## 从线程状态说起

一般的操作系统中，线程的状态大概有这么几个：

1. 执行：线程获得cpu，程序正在执行

2. 就绪：线程已经准备好运行，只要获得cpu，便立即执行

3. 阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度

4. 挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。

5. 激活：把一个挂起的线程激活

着重理解一下几个关键状态的转换：

活动就绪-->静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。

活动阻塞-->静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。

注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。

画个图理解一下：

{% asset_img 线程状态.png %}

线程创建和终止状态不再讨论。

<!-- more -->

## wait

wait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。

当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。

调用wait方法，相当于上图中**执行->活动阻塞->静止阻塞**的过程。同时，wait方法释放了对象的锁，然后阻塞，挂起，等待被唤醒。

## notify

当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒(挂起)的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒(激活),这个过程相当于上图中**静止阻塞->活动阻塞**的过程。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。

此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图**活动阻塞->活动就绪**的过程。此时线程等待调度执行。

需要注意的是，notify不恰当使用很有可能造成死锁问题。

## notifyAll

当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒(挂起)的线程(调用了A的wait方法的线程)唤醒(激活)。这些线程会开始竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。

## sleep

与以上三个关键字不同的是，sleep方法是Thread中的方法。

当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。调用sleep的目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;

调用线程Y的sleep(1000)sleep方法，相当于上图中**执行->静止就绪状态**。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。

## synchronized

当程序执行遇到synchronized关键字的时候，若此时锁被占用，则线程被阻塞。相当于上图中**执行->活动阻塞**过程。

PS：上述的几个状态跟java中描述的Thread.state并不尽相同。而且底层真正的运行情况(OS的线程状态)是否是跟以上描述相同也有待考究。但是我理解的这几个关键字对外的表现应该与上述描述是一样的。

参考知乎上的一个提问：[java sleep和wait的区别的疑惑?](https://www.zhihu.com/question/23328075)

## 使用场景

Object.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？

在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。

例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。