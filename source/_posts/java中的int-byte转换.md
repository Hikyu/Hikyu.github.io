---
layout: post
title:  "java中的int-byte转换"
categories:
- 技术
- 编程
tags: 
- java
date:   2016-11-24 22:48:55
---

## 前言

好久没有动博客了，看了下，将近两个月了吧。最近的两个月里面变懒了，没有了记录的动力。。。最近好像也没啥收获，惭愧。之前电脑中病毒之后(cryptolcker)，还好没有神马重要的东西，索性把硬盘重新格式化一遍，重做了系统。保留一套windows（实在受不了win10的自动更新了...）,又装了一套opensuse的系统。希望可以坚持学点linux。

这段时间没有怎么看书，说一下读书情况。《重构》这本还是没有看完，读了大半。《深入理解jvm虚拟机》这本算是大致上浏览了一遍，发现确实是一本挺好的java书籍，日后还需多加翻阅理解。《大话设计模式》也是浏览了一遍，其中比较常见的模式有时候也可以用到，需要的时候再看吧。双十一买了一本《java并发编程实战》，看了大半，似懂非懂，但也是有收获的。不得不吐槽一下该书的翻译，实在是不敢恭维，但是想想自己的英语水平，目前还是忍了。。

必须要振作起精神来了，总觉得自己每天无所事事呢。接下来的计划.....还是把并发编程这块看完吧，虽然没有什么实战的机会，总比不看强。要多写总结了，不然看了跟不看差不多。异常、反射、动态代理、注解等等这些也要学习然后做一个记录。网络、io、并发这三块，并发还在看，也要做好记录，然后网络这部分把大学课本重读一遍，至于io不知道有什么好的书籍，放到最后规划学习把。

嗯，又想起来最近还写了一个自动打卡的程序，增加了短信通知的功能。总觉得有些不诚信的感觉呢，但是没有迟到早退过呀，好玩罢了。读了webmagic的core部分的源码，感觉理解起来轻松许多。记得大学那会看这个的时候还是一头雾水，结果现在两个小时就把代码搞清楚了（主要是代码量也不大拉）。嗯，说明自己还是在进步的麻，哈哈哈。下载了junit的源码都没有看过，有空研究把。

终于要进入正题了。这次的记录很短很简单，是关于java中int和byte之间的转换的。虽然简单，但是以前就是拿来即用，没有搞清楚其中的原理，在byte这块就很纠结（只能说基础比较差），今天来学习一下。

--------------------------------------------------

## 正文

java中:

byte: 1字节    int: 4字节

```java
int i = -123
byte x = (byte)i; //-123
```
ps：([]代表几进制，()代表前面的内容重复几次)

ps:

-123[2] = 11111111(3)10000101

int 强转为 byte，直接截取低8位即10000101

java把byte当做有符号处理，故此时x=-123

```java
int j = (int)x; //-123
```
ps:

byte强转为int，高24位补1(自动扩展)

此时，j[2]=11111111(3)11101010

即，j=-123

负数似乎没有问题...

--------------------------------------------------
```java
int i = 234;
byte x = (byte)i; //-22
```
ps:

234[2] = 00000000(3)11101010

int 强转为 byte，直接截取低8位即11101010

java把byte当做有符号处理，故此时x=-22

```java
int j = (int)x; //-22
```
ps:

byte强转为int，高24位补1（自动扩展）

此时，j[2]=11111111(3)11101010

即，j=-22

可见，byte单纯的强转为int是行不通的。(注意，示例中int强转为一个byte,如果int值超过255,发生数据丢失，正确的int转为4字节byte方法见下文)

--------------------------------------------------
```java
int i = 234;
byte x = (byte)i; //-22
int j = x & 0xFF; //j=234
```
ps:

x & 0xFF = 00000000(3)11101010

即，j=234

可见0xFF的作用...

--------------------------------------------------

- http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/

byte short char 他们三者在计算时，首先会转换为int类型,故下面几个表达式进行|运算时，是int类型之间的|运算，存在自动扩展(移位操作也会出现这种情况,即int转byte的时候),不进行& 0xFF的运算，则有可能造成第一种情况的出现。

- java字节序

java为大端字节序（bigendian）：高字节数据存放在低地址处，低字节数据存放在高地址处。

0x01020304

故b[0]=0x01,b[1]=0x02,b[2]=0x03,b[3]=0x04

```java
//byte 数组与 int 的相互转换  
public static int byteArrayToInt(byte[] b) {  
    return   b[3] & 0xFF |  
            (b[2] & 0xFF) << 8 |  
            (b[1] & 0xFF) << 16 |  
            (b[0] & 0xFF) << 24;  
}  
  
public static byte[] intToByteArray(int a) {  
    return new byte[] {  
        (byte) ((a >> 24) & 0xFF),  
        (byte) ((a >> 16) & 0xFF),     
        (byte) ((a >> 8) & 0xFF),     
        (byte) (a & 0xFF)  
    };  
}  
```
