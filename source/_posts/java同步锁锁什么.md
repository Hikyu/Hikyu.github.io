---
layout: post
title:  "java同步锁锁什么"
date:   2015-12-17 14:10:55
categories: 
- 技术
- 编程
tags: 
- java
- 多线程
---

在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：
情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;
ThreadTest中的成员变量 j 被赋值为 i 
在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;
在synchronized块中，我改变了这个 j 的值。代码大概是这样的：

```					   
Integer j;
ThreadTest(Integer i){
		j=i;
}
public void run() {
		synchronized(j){
		  j++;
		}
}

```

<!-- more -->

1. 一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。

2. 另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。

苦逼了。结果不对
后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，
即 void test(Object  i){
		i.dosomething()......
   }
函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。
这样就解释了出错的 原因：
Integer 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。
所以 

对于 1. 

当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望

对于 2. 

使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步
							
上面的情况也证明了，**synchronized 锁的是内存 ，而不是指向内存的引用**。
							
这样的情况也说明了另外一种情况的问题，那就是**在函数中给实参分配内存,实际在函数体外是得不到这个对象的**。
							
解决的办法：
放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，
各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。