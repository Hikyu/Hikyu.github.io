<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>webservice相关 | YuKai&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="上周最后三天去北京培训了Hadoop，了解了一些目前流行的分布式组件。在谈到这些组件的交互过程中，经常会提到RPC，webservice等关键词，所以简单了解了一下这些关键词的含义~

WebServicewebservice，拆开来看就是 web（网络）和service（服务），先了解一下什么是服务：
计算机的后台进程提供了某种功能，我们把提供了这种功能的进程称为守护进程（Daemon），提供">
<meta property="og:type" content="article">
<meta property="og:title" content="webservice相关">
<meta property="og:url" content="http://yukai.space/2017/03/15/webservice相关/index.html">
<meta property="og:site_name" content="YuKai's blog">
<meta property="og:description" content="上周最后三天去北京培训了Hadoop，了解了一些目前流行的分布式组件。在谈到这些组件的交互过程中，经常会提到RPC，webservice等关键词，所以简单了解了一下这些关键词的含义~

WebServicewebservice，拆开来看就是 web（网络）和service（服务），先了解一下什么是服务：
计算机的后台进程提供了某种功能，我们把提供了这种功能的进程称为守护进程（Daemon），提供">
<meta property="og:updated_time" content="2018-05-02T13:31:52.173Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="webservice相关">
<meta name="twitter:description" content="上周最后三天去北京培训了Hadoop，了解了一些目前流行的分布式组件。在谈到这些组件的交互过程中，经常会提到RPC，webservice等关键词，所以简单了解了一下这些关键词的含义~

WebServicewebservice，拆开来看就是 web（网络）和service（服务），先了解一下什么是服务：
计算机的后台进程提供了某种功能，我们把提供了这种功能的进程称为守护进程（Daemon），提供">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yukai.space"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/tools">工具</a>
        
          <a class="main-nav-link" href="/page">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">YuKai&#39;s blog</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-webservice相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/15/webservice相关/" class="article-date">
  <time datetime="2017-03-15T03:22:45.000Z" itemprop="datePublished">2017-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>►<a class="article-category-link" href="/categories/技术/编程/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      webservice相关
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <blockquote>
<p>上周最后三天去北京培训了Hadoop，了解了一些目前流行的分布式组件。在谈到这些组件的交互过程中，经常会提到RPC，webservice等关键词，所以简单了解了一下这些关键词的含义~</p>
</blockquote>
<h2 id="WebService"><a href="#WebService" class="headerlink" title="WebService"></a><a href="https://zh.wikipedia.org/wiki/Web_services" target="_blank" rel="external">WebService</a></h2><p>webservice，拆开来看就是 web（网络）和service（服务），先了解一下什么是服务：</p>
<p>计算机的后台进程提供了某种功能，我们把提供了这种功能的进程称为守护进程（Daemon），提供的功能称为服务。比如，我们启动了数据库，数据库进程就会一直运行在后台监听连接数据库的动作，这种监听连接的功能就是一种服务。</p>
<p>服务分为本地服务和网络服务。使用同一台机器上提供的服务就是本地服务，通过网络连接到另一台计算机使用它提供的服务就是网络服务。</p>
<p>所以，webservice 就是通过网络使用了其他服务器提供的某种功能或获取了某些资源。</p>
<p>这样一来，webservice就很常见了。比如我们做了一个显示天气情况的app，使用了百度地图提供的定位功能，使用了其他服务商提供的天气数据，这些都属于webservice。</p>
<p>webservice可以包含以下几个实现：</p>
<p>RPC：面向过程</p>
<p>RMI：面向对象</p>
<p>REST：面向资源</p>
<p><a href="http://www.java2blog.com/2013/03/web-service-tutorial.html" target="_blank" rel="external">Web Service tutorial</a></p>
<a id="more"></a>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a><a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8" target="_blank" rel="external">RPC</a></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。<br>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。<br>如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。</p>
</blockquote>
<p>上面的解释摘自维基百科</p>
<p>RPC属于webservice的一种，就是在一个进程中调用另一个进程中的服务。就像调用本地方法一样调用远程服务器的方法。</p>
<p>RPC有很多实现，包括XML-RPC、JSON-RPC、JAX-RPC等等。</p>
<p>一次RPC调用过程就是向服务器发送一个过程调用的方法和参数，得到服务器返回的方法执行结果。RPC的本质就是一次远程调用，但更强调透明调用。RPC是跨语言的。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>以<a href="http://www.jsonrpc.org" target="_blank" rel="external">Json-Rpc</a> 为例，看一下RPC是如何工作的：</p>
<p>使用java中的json-rpc实现<a href="https://github.com/briandilley/jsonrpc4j" target="_blank" rel="external">jsonrpc4j</a>：（也有其他语言的实现）</p>
<p>Create your service interface:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package com.mycompany;</div><div class="line">public interface UserService &#123;</div><div class="line">    User createUser(String userName, String firstName, String password);</div><div class="line">    User createUser(String userName, String password);</div><div class="line">    User findUserByUserName(String userName);</div><div class="line">    int getUserCount();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Implement it:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.mycompany;</div><div class="line">public class UserServiceImpl</div><div class="line">    implements UserService &#123;</div><div class="line"></div><div class="line">    public User createUser(String userName, String firstName, String password) &#123;</div><div class="line">        User user = new User();</div><div class="line">        user.setUserName(userName);</div><div class="line">        user.setFirstName(firstName);</div><div class="line">        user.setPassword(password);</div><div class="line">        database.saveUser(user)</div><div class="line">        return user;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public User createUser(String userName, String password) &#123;</div><div class="line">        return this.createUser(userName, null, password);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public User findUserByUserName(String userName) &#123;</div><div class="line">        return database.findUserByUserName(userName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getUserCount() &#123;</div><div class="line">        return database.getUserCount();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Server<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class UserServiceServlet</div><div class="line">    extends HttpServlet &#123;</div><div class="line"></div><div class="line">    private UserService userService;</div><div class="line">    private JsonRpcServer jsonRpcServer;</div><div class="line"></div><div class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) &#123;</div><div class="line">        jsonRpcServer.handle(req, resp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void init(ServletConfig config) &#123;</div><div class="line">        //this.userService = ...</div><div class="line">        this.jsonRpcServer = new JsonRpcServer(this.userService, UserService.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Client<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">JsonRpcHttpClient client = new JsonRpcHttpClient(</div><div class="line">    new URL(&quot;http://example.com/UserService.json&quot;));</div><div class="line"></div><div class="line">UserService userService = ProxyUtil.createClientProxy(</div><div class="line">    getClass().getClassLoader(),</div><div class="line">    UserService.class,</div><div class="line">    client);</div><div class="line"></div><div class="line">User user = userService.createUser(&quot;bob&quot;, &quot;the builder&quot;);</div></pre></td></tr></table></figure></p>
<p>上面的例子只是最简单的访问方式，在分布式环境中，RPC还涉及到服务寻址，负载均衡等等问题。</p>
<p>更加详细的RPC介绍，可以参考<a href="http://blog.brucefeng.info/post/what-is-rpc" target="_blank" rel="external">RPC 是什么</a></p>
<h3 id="为什么是RPC"><a href="#为什么是RPC" class="headerlink" title="为什么是RPC"></a>为什么是RPC</h3><p>在网上查看RPC资料的时候，就想到一个问题，既然RPC这么复杂，为什么不使用HTTP接口调用的方式来进行网络通信呢？以前做一些小demo的时候使用HttpClient就完全OK了。</p>
<p>看到一个很有意思的讨论：<a href="https://www.oschina.net/question/271044_2155059" target="_blank" rel="external">为什么需要RPC，而不是简单的HTTP接口</a></p>
<p>RPC调用简单，适用于业务逻辑比较复杂的情况，比如分布式环境当中。RPC强调透明调用,也利于解耦。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><a href="https://github.com/i1see1you/QiuRPC" target="_blank" rel="external">QiuRPC</a>：一个通用的网络RPC框架</p>
<p><a href="http://blog.jobbole.com/92290/" target="_blank" rel="external">你应该知道的 RPC 原理</a></p>
<h2 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a><a href="https://zh.wikipedia.org/wiki/SOAP" target="_blank" rel="external">SOAP</a></h2><p>XML-RPC只能使用有限的数据类型种类和一些简单的数据结构。于是就出现了SOAP(Simple Object Access Protocol)。</p>
<p>SOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。</p>
<p>事实上SOAP数据使用XML数据格式，定义了一整套复杂的标签，以描述调用的远程过程、参数、返回值和出错信息等等。而且随着需要的增长，又不得增加协议以支持安全性，这使SOAP变得异常庞大，背离了简单的初衷。另一方面，各个服务器都可以基于这个协议推出自己的API，即使它们提供的服务及其相似，定义的API也不尽相同，这又导致了WSDL的诞生。</p>
<p>WSDL (Web Service Description Language) 也遵循XML格式，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，简言之，服务发现。</p>
<p>现在，使用Web Service的过程变成，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。</p>
<p><a href="http://stackoverflow.com/questions/15948927/working-soap-client-example" target="_blank" rel="external">Working Soap client example</a></p>
<p><a href="https://docs.oracle.com/cd/E19340-01/820-6767/aeqfx/index.html" target="_blank" rel="external">SOAP Messaging Models and Examples</a></p>
<p>通过soap demo体会soap与rpc的区别</p>
<h2 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a><a href="https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8" target="_blank" rel="external">RMI</a></h2><p>RMI其实也属于RPC的一种，是面向对象的。RMI只能在java里玩，不支持跨语言。与RPC不同的是，RMI可以返回java对象以及基本的数据类型，RPC不允许返回对象，RPC服务的信息由外部数据表示。RMI的优势在于依靠Java序列化机制，对开发人员屏蔽了数据编排和解排的细节，要做的事情非常少。</p>
<p>用代码说话：</p>
<p>RMI采用的是典型的客户端-服务器端架构。首先需要定义的是服务器端的远程接口，这一步是设计好服务器端需要提供什么样的服务。对远程接口的要求很简单，只需要继承自RMI中的Remote接口即可。Remote和Serializable一样，也是标记接口。远程接口中的方法需要抛出RemoteException。定义好远程接口之后，实现该接口即可。如下面的Calculator是一个简单的远程接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Calculator extends Remote &#123;</div><div class="line">    String calculate(String expr) throws RemoteException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现了远程接口的类的实例称为远程对象。创建出远程对象之后，需要把它注册到一个注册表之中。这是为了客户端能够找到该远程对象并调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class CalculatorServer implements Calculator &#123;</div><div class="line">    public String calculate(String expr) throws RemoteException &#123;</div><div class="line">        return expr;</div><div class="line">    &#125;</div><div class="line">    public void start() throws RemoteException, AlreadyBoundException &#123;</div><div class="line">        Calculator stub = (Calculator) UnicastRemoteObject.exportObject(this, 0);</div><div class="line">        Registry registry = LocateRegistry.getRegistry();</div><div class="line">        registry.rebind(&quot;Calculator&quot;, stub);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CalculatorServer是远程对象的Java类。在它的start方法中通过UnicastRemoteObject的exportObject把当前对象暴露出来，使得它可以接收来自客户端的调用请求。再通过Registry的rebind方法进行注册，使得客户端可以查找到。</p>
<p>客户端的实现就是首先从注册表中查找到远程接口的实现对象，再调用相应的方法即可。实际的调用虽然是在服务器端完成的，但是在客户端看来，这个接口中的方法就好像是在当前JVM中一样。这就是RMI的强大之处。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class CalculatorClient &#123;</div><div class="line">    public void calculate(String expr) &#123;</div><div class="line">        try &#123;</div><div class="line">            Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;);</div><div class="line">            Calculator calculator = (Calculator) registry.lookup(&quot;Calculator&quot;);</div><div class="line">            String result = calculator.calculate(expr);</div><div class="line">            System.out.println(result);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在运行的时候，需要首先通过rmiregistry命令来启动RMI中用到的注册表服务器。</p>
<p>为了通过Java的序列化机制来进行传输，远程接口中的方法的参数和返回值，要么是Java的基本类型，要么是远程对象，要么是实现了 Serializable接口的Java类。当客户端通过RMI注册表找到一个远程接口的时候，所得到的其实是远程接口的一个动态代理对象。当客户端调用其中的方法的时候，方法的参数对象会在序列化之后，传输到服务器端。服务器端接收到之后，进行反序列化得到参数对象。并使用这些参数对象，在服务器端调用实际的方法。调用的返回值Java对象经过序列化之后，再发送回客户端。客户端再经过反序列化之后得到Java对象，返回给调用者。这中间的序列化过程对于使用者来说是透明的，由动态代理对象自动完成。除了序列化之外，RMI还使用了动态类加载技术。当需要进行反序列化的时候，如果该对象的类定义在当前JVM中没有找到，RMI会尝试从远端下载所需的类文件定义。可以在RMI程序启动的时候，通过JVM参数java.rmi.server.codebase来指定动态下载Java类文件的URL。  </p>
<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a><a href="https://zh.wikipedia.org/wiki/REST" target="_blank" rel="external">REST</a></h2><p>REST只是一种软件架构的风格，而不是一种协议或者其他。</p>
<p>REST基于HTTP协议，一般使用JSON传输数据。REST是面向资源的，资源由URI来表示。</p>
<p>以下解释参考自<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">理解RESTful架构</a></p>
<hr>
<p>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p>
<p>资源（Resources）</p>
<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>
<p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>
<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p>
<p>表现层（Representation）</p>
<p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p>
<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>
<p>状态转化（State Transfer）</p>
<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
<p>综述</p>
<p>综合上面的解释，我们总结一下什么是RESTful架构：<br>（1）每一个URI代表一种资源；<br>（2）客户端和服务器之间，传递这种资源的某种表现层；<br>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<hr>
<p>参考<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful API 设计指南</a>设计Rest API</p>
<p>github的API设计就是REST风格的。</p>
<p>网上关于REST和PRC的争论有很多,总的来说有以下几个：</p>
<p>安全性上：SOAP安全性高于REST</p>
<p>成熟度上：SOAP在成熟度上优于REST</p>
<p>效率和易用性上：REST更胜一筹</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.jobbole.com/92290/" target="_blank" rel="external">你应该知道的 RPC 原理</a></p>
<p><a href="http://blog.brucefeng.info/post/what-is-rpc" target="_blank" rel="external">RPC 是什么</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2009/08/what_is_web_service.html" target="_blank" rel="external">Web service是什么？</a></p>
<p><a href="http://www.infoq.com/cn/articles/cf-java-object-serialization-rmi" target="_blank" rel="external">Java深度历险（十）——Java对象序列化与RMI</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yukai.space/2017/03/15/webservice相关/" data-id="cjhw3qekg007zw3xcqgsfhw8y" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>

    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2017/03/19/I-O总结/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          java I/O总结
        
      </div>
    </a>
  
  
    <a href="/2017/03/04/linux分区/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">linux分区</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
           <div id="gitment_comments"></div>
    
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#WebService"><span class="toc-number">1.</span> <span class="toc-text">WebService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC"><span class="toc-number">2.</span> <span class="toc-text">RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-number">2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用"><span class="toc-number">2.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么是RPC"><span class="toc-number">2.3.</span> <span class="toc-text">为什么是RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-number">2.4.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SOAP"><span class="toc-number">3.</span> <span class="toc-text">SOAP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI"><span class="toc-number">4.</span> <span class="toc-text">RMI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#REST"><span class="toc-number">5.</span> <span class="toc-text">REST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 于凯&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;debiaoyu@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/tools" class="mobile-nav-link">工具</a>
  
    <a href="/page" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script> 
  <script>
  var gitment = new Gitment({
    // id: '页面 ID', // 可选。默认为 location.href
    owner: 'Hikyu',
    repo: 'Hikyu.github.io',
    oauth: {
    client_id: '61886569157db60efa97',
    client_secret: '6475bb7c8faaf44ff2e12c272a46505a0eecf46f',
    }
  })
  gitment.render(document.getElementById("gitment_comments"))
</script>


<!-- author:forvoid end -->

<!-- author:forvoid end -->



 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>