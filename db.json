{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/pacman/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/author.jpg","path":"img/author.jpg","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/xiaoxin.ico","path":"img/xiaoxin.ico","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/xiaoxin.png","path":"img/xiaoxin.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/js/jquery-2.1.0.min.js","path":"js/jquery-2.1.0.min.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/xiaoxin.jpg","path":"img/xiaoxin.jpg","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"75913de577e6e2674855228ebb98f985574fdca1","modified":1480516369901},{"_id":"source/page/index.md","hash":"aae446d1d6ef6bf243f854eb58fcc717d36615a4","modified":1485009049284},{"_id":"source/_posts/Ant的使用.md","hash":"ad6ab972acbe476c585db9f8a89cc97fd38f05cd","modified":1480516369901},{"_id":"source/_posts/Eclipse编码问题终极解决方案.md","hash":"b81e4d14525e6bfa71fdc73ab5063af5183b9caa","modified":1480516369901},{"_id":"source/_posts/Java集合框架学习总结.md","hash":"b2f0e5b0f86ace849a277b685434c97c5b6d63cb","modified":1480516369905},{"_id":"source/_posts/Spring项目打包为jar.md","hash":"d2d06daa86fc823a5aedf7aed418d66955ea01e6","modified":1480516369905},{"_id":"source/_posts/Vps使用笔记.md","hash":"02ac30321a9feaf0a14594ee756445919b423770","modified":1486477570540},{"_id":"themes/pacman/_config.yml","hash":"faa5b9a5a4f51f269aa37be6a09b40995a30aebd","modified":1480516369933},{"_id":"themes/pacman/LICENSE","hash":"0138565d68df6e5536667ad445232981ea808aec","modified":1480516369933},{"_id":"source/_posts/java_Tips.md","hash":"16c88dafce04df5ab7fa02456033c8a9f1668fc4","modified":1480516369905},{"_id":"source/_posts/java中的equals与hashcode.md","hash":"77cc119bc5c8f8e37574a4b424437f6e87c9ea3c","modified":1480516369905},{"_id":"source/_posts/java中的int/byte互转.md","hash":"1e03e7c37002ccb9593f1dbcf155af18e7784981","modified":1480516369905},{"_id":"source/_posts/java中的枚举.md","hash":"d484013f17b93148d2e615b7cac3d7082fcf6291","modified":1480516369909},{"_id":"source/_posts/java中的类型转换.md","hash":"c020fc75944a55f877a133e7edecf7553926217b","modified":1480516369909},{"_id":"source/_posts/java中的编码问题.md","hash":"20fc99083e25783d9edec744120624058b972663","modified":1480516369909},{"_id":"source/_posts/java中的路径.md","hash":"eccfb3497679845512dd40e677f84cb6d19a5908","modified":1485008682188},{"_id":"themes/pacman/README.md","hash":"d7efa5614e13f8fc7db5e9030e4cc2b27c2df171","modified":1480516369933},{"_id":"source/_posts/java异常的学习.md","hash":"e846ab9535298dd85ae2d99ceedf983edf5e9fb7","modified":1481727968071},{"_id":"source/_posts/java泛型学习.md","hash":"5c2373436e63c9b045106ff58da2c1ec1b960b26","modified":1480516369909},{"_id":"source/_posts/java线程中断总结.md","hash":"897e778ee0e6b13158eeb4a4d855ec95e8f05f2b","modified":1481805965233},{"_id":"source/_posts/java远程调试学习.md","hash":"215ba7fb19c1f21e248fac737de3f4e2b1e7c76e","modified":1481196351169},{"_id":"source/_posts/junit使用.md","hash":"4c06f84517b5918b4257ad5993f6c8d4b423b85a","modified":1480516369909},{"_id":"source/_posts/notify问题.md","hash":"62c8a233c9d484fd9dafa3c29ec999581b29d313","modified":1480516369909},{"_id":"source/_posts/markdown.md","hash":"a7d4f052cd3802f3a1ebbabf91bfa47129bcf79c","modified":1480516369909},{"_id":"source/_posts/sphinx安装问题.md","hash":"65e54c0c48d1ebd0eff1277e657e6faa14fd2526","modified":1480516369909},{"_id":"source/_posts/ssl总结.md","hash":"202833382b04ec912a5b5469bbfec0feb8908bfc","modified":1480516369909},{"_id":"source/_posts/synchronized的一些用法.md","hash":"304192e87d0f57d71808ebee2ad334412f50aaac","modified":1480516369909},{"_id":"source/_posts/一些计划.md","hash":"d382a597742dbfb3b039b7db2caf5352a8b32ad1","modified":1480516369909},{"_id":"source/_posts/为什么是final.md","hash":"026e6818b24f856bcfc45abeeedef83b51a01a81","modified":1480516369909},{"_id":"source/_posts/他可是科比·布莱恩特!.md","hash":"928198fb521d3f19425ed374d55b68e0c020c50c","modified":1480516369909},{"_id":"source/_posts/代码格式.md","hash":"097926e9a86497f17b0a13a7d73e12227c6d3c97","modified":1480516369913},{"_id":"source/_posts/关于加密的一点总结.md","hash":"1cf22a4128ae294794a1044fae63db9e3e8e1317","modified":1480516369913},{"_id":"source/_posts/ant编译java工程jdk路径的设置.md","hash":"cead1fd3259cf027e655cad04ddc051dba143e54","modified":1480516369905},{"_id":"source/_posts/java中的ThreadLocal.md","hash":"1111a383a4f0cf8dac77742bef59ab9f4e2eb899","modified":1480516369905},{"_id":"source/_posts/java同步锁锁什么.md","hash":"68a5cc79e9ebfad12392ca7ab1f1b6e65712b181","modified":1480516369909},{"_id":"source/_posts/关于抽象类和接口.md","hash":"fc655dc5bce1978904d31c3c89490b4fafc51210","modified":1480516369913},{"_id":"source/_posts/常用快捷键总结.md","hash":"70cd5116a478ce7c1c57efc1dcc35ea78bd4771f","modified":1480516369913},{"_id":"source/_posts/理解java内存模型.md","hash":"d91a2d1daa94f07322ce9f4ed37ce4c5d3cff725","modified":1480516369917},{"_id":"source/_posts/理解notify notifyall sleep.md","hash":"469f165b53e2a9ed3e66aa568a2874487c662f67","modified":1480516369921},{"_id":"themes/pacman/languages/default.yml","hash":"7e9594aa9551cd4841905b4b4d4fcabc2b40e447","modified":1480516369933},{"_id":"source/_posts/记录这周工作遇到的坑.md","hash":"ed63eb9875e7fdc0adf389172aa957b1f9bbd0a9","modified":1481722018080},{"_id":"themes/pacman/languages/zh-CN.yml","hash":"991b90926686c0d10731a8f4ea61b96c3f087531","modified":1480516369933},{"_id":"themes/pacman/languages/zh-TW.yml","hash":"48b652fa2eb73f9f7cd512472d0cb20057152aea","modified":1480516369933},{"_id":"themes/pacman/layout/index.ejs","hash":"774f7e89d05e9a9b43970a873d5100ad5c9d21ba","modified":1480516369933},{"_id":"themes/pacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1480516369933},{"_id":"themes/pacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1480516369933},{"_id":"themes/pacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1480516369933},{"_id":"themes/pacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1480516369933},{"_id":"themes/pacman/layout/layout.ejs","hash":"87b543229bec7e77cc0ec68cfdd11f2f33df4a1b","modified":1480516369933},{"_id":"themes/pacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1480516369933},{"_id":"themes/pacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1480516369933},{"_id":"source/_posts/毕业了.md","hash":"581ef7d10cf5eb71884b3d13588df23c658d1b35","modified":1480516369913},{"_id":"source/_posts/Eclipse编码问题终极解决方案/2.png","hash":"4dd8a8d179e898c803a879fec14afb855a34b23d","modified":1480516369901},{"_id":"source/_posts/Eclipse编码问题终极解决方案/5.png","hash":"7fc75d3a44bebd24c9df7ad7e7d49d70de611325","modified":1480516369901},{"_id":"source/_posts/Java集合框架学习总结/collection.png","hash":"9644281b68a057f4db9b162c45ac4c076c7c5651","modified":1480516369905},{"_id":"source/_posts/Spring项目打包为jar/2.png","hash":"7ff532cc98f22996c89a2a590954c113e2de486f","modified":1480516369905},{"_id":"source/_posts/Spring项目打包为jar/3.png","hash":"a6c93e41c454ca4d89a2c5153ff74ac3c9eec04a","modified":1480516369905},{"_id":"source/_posts/Spring项目打包为jar/4.png","hash":"644dca24dfefc583f2b222e967962d2de68452bb","modified":1480516369905},{"_id":"source/_posts/Spring项目打包为jar/5.png","hash":"7c9911eab320a22ef1a310dfb15a8996aa37de2b","modified":1480516369905},{"_id":"source/_posts/java中的equals与hashcode/entry.png","hash":"c6c32336b30c74d2e825684e590fc8bb15af2dc1","modified":1480516369905},{"_id":"source/_posts/java中的编码问题/reader.png","hash":"4cf16c765f0952a9134bc5097270d3a6b2679f76","modified":1480516369909},{"_id":"source/_posts/java中的编码问题/utf8.png","hash":"f4a2eb95b15e12d6957c07099fafd42d9b6c035e","modified":1480516369909},{"_id":"source/_posts/java中的编码问题/writer.png","hash":"3ac4dcf3e18dc011372297be5069f387fef0e9f9","modified":1480516369909},{"_id":"source/_posts/java异常的学习/java.png","hash":"1f36e7cffb24b7771a60661d3d7301b9ca8c8f87","modified":1481727571695},{"_id":"source/_posts/java泛型学习/easybill.jpg","hash":"4090b7f4d3fb71aa1213a4ac8ef44e1d11dd8818","modified":1480516369909},{"_id":"source/_posts/java远程调试学习/jdpa.png","hash":"d0fc92e1d6b23a66eb753304c6ca06df2f91357d","modified":1481120550000},{"_id":"source/_posts/java远程调试学习/setting.png","hash":"5cdc18528edb9e01c731b8c4c5057467670ea59e","modified":1481196804145},{"_id":"source/_posts/Eclipse编码问题终极解决方案/4.png","hash":"5ef56fc1e37d46da093fbf0b94273b45eb3cb8bd","modified":1480516369901},{"_id":"source/_posts/Eclipse编码问题终极解决方案/3.png","hash":"d62218e89ab63a0c4a05ebfd35192b7f3c031588","modified":1480516369901},{"_id":"source/_posts/ssl总结/zhufubao1.png","hash":"31d3700c1b34205b3527e551806815a179012710","modified":1480516369909},{"_id":"source/_posts/ssl总结/zhifubao.png","hash":"861fb5b3e7686cab022872e16f93eee43f2f657c","modified":1480516369909},{"_id":"source/_posts/ssl总结/zhufubao2.png","hash":"670fb52cc2d6a871af24621ff34613d80f47213a","modified":1480516369909},{"_id":"source/_posts/关于加密的一点总结/md5.png","hash":"5830f21212d5da0f37cb94dd97fc8db37dcdf033","modified":1480516369913},{"_id":"source/_posts/理解java内存模型/volatile.png","hash":"66e532f81e9747722754733ee0361d3e28bf3ce1","modified":1480516369917},{"_id":"source/_posts/理解java内存模型/内存模型.png","hash":"9afbd38d84a83cd56288172cc45fc627867113c2","modified":1480516369917},{"_id":"source/_posts/记录这周工作遇到的坑/error.png","hash":"016f7b6c6d5ef72cc405baa5777bf2077d178931","modified":1480516369921},{"_id":"source/_posts/理解notify notifyall sleep/线程状态.png","hash":"0716019dc5c338a2b07197e0cd5f593d4dedc504","modified":1480516369921},{"_id":"source/_posts/记录这周工作遇到的坑/compiler.png","hash":"9ac5d2d7f2e76b216a82cf9eaea2034857c18127","modified":1480516369921},{"_id":"source/_posts/记录这周工作遇到的坑/gengeration.png","hash":"acd8916c32713eb373fed19198b000b0516080e6","modified":1480516369921},{"_id":"themes/pacman/layout/_partial/archive.ejs","hash":"a1ada891cbacf49b397cfa7dd921bdd0ae545a4e","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/article.ejs","hash":"38837fc6a1a799e83b8a75db642b0daf1ff81828","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/after_footer.ejs","hash":"af5d700c7e22e364216535142bc0adc798fac22f","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/footer.ejs","hash":"86bf52b852d45895a1fa24eb5e45dd2f40d5fb47","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/google_analytics.ejs","hash":"b6871f67c87c87acb5295ce4fb673b16a7296a01","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/head.ejs","hash":"f21fc1b1c16498610a44a552d23059d338f34d2a","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/search.ejs","hash":"aed90406246cc43f60dda8cd6558e9eccee342a4","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/sidebar.ejs","hash":"b5aeaab660a18b7a4da568f015e61260eb478916","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/header.ejs","hash":"515074e0e1449259cfb668217b21224f6e0adde5","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1480516369933},{"_id":"themes/pacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1480516369933},{"_id":"themes/pacman/layout/_widget/links.ejs","hash":"3635a1a407fde93a3be58178b85f51ceb8b87f15","modified":1480516369933},{"_id":"themes/pacman/layout/_widget/tag.ejs","hash":"cc97db230f727c27519298166ad904358811fb53","modified":1480516369933},{"_id":"themes/pacman/layout/_widget/category.ejs","hash":"9b4cc6be18aa6c5da4cf45913d5be83fc33081db","modified":1480516369933},{"_id":"themes/pacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1480516369933},{"_id":"themes/pacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1480516369933},{"_id":"themes/pacman/source/css/style.styl","hash":"b096cc43460e68004bbef41229f67420b5816637","modified":1480516369937},{"_id":"themes/pacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1480516369937},{"_id":"themes/pacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1480516369937},{"_id":"themes/pacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1480516369937},{"_id":"themes/pacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1480516369937},{"_id":"themes/pacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1480516369937},{"_id":"themes/pacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1480516369937},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1480516369937},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1480516369937},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1480516369937},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1480516369941},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1480516369941},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1480516369941},{"_id":"themes/pacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1480516369941},{"_id":"themes/pacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1480516369941},{"_id":"themes/pacman/source/img/author.jpg","hash":"cf5161efc731fc892ab04b77c2369c7fdad21d87","modified":1480516369941},{"_id":"themes/pacman/source/img/logo.svg","hash":"0eb0ae32d95c6f0b14adb9ab491775dcd1da3af3","modified":1480516369941},{"_id":"themes/pacman/source/img/xiaoxin.ico","hash":"82778e9316d3d1d366442a8f5d0468dda013d983","modified":1480516369941},{"_id":"themes/pacman/source/img/xiaoxin.png","hash":"479898e56ba23fdc6c68a611939316ad58f6e78c","modified":1480516369945},{"_id":"source/_posts/Eclipse编码问题终极解决方案/6.png","hash":"b27b88bd85eb9e2dac3cc7164678ca203c3ff9c7","modified":1480516369901},{"_id":"source/_posts/Eclipse编码问题终极解决方案/7.png","hash":"1558afd4f271658241ff3a5189ee10bf7f5ebbf2","modified":1480516369905},{"_id":"source/_posts/Spring项目打包为jar/1.png","hash":"925c9162dc357b505520543c5c47d3dd11dc840a","modified":1480516369905},{"_id":"source/_posts/java远程调试学习/remote.png","hash":"31329d2e3f6c04d6d13be67437e7a4322c31a061","modified":1481196634637},{"_id":"source/_posts/Eclipse编码问题终极解决方案/1.png","hash":"6ed1e52158e7dbce544e72af037ede46b38f1600","modified":1480516369901},{"_id":"source/_posts/他可是科比·布莱恩特!/kobe.jpg","hash":"5e2e8343a4fba076d7475cc6cda941d21176be44","modified":1480516369913},{"_id":"source/_posts/毕业了/graduation5.jpg","hash":"976ff6965b27f578d365ae139db1c8d5c298d757","modified":1480516369917},{"_id":"source/_posts/毕业了/graduation6.jpg","hash":"4f36689e7db00afd3f2bc3b4c33480e9d1f1a99c","modified":1480516369917},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1480516369941},{"_id":"themes/pacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1480516369941},{"_id":"source/_posts/ssl总结/sslprocess.jpg","hash":"449b6c730fb7f7452592972d8748cf6bbe942de8","modified":1480516369909},{"_id":"themes/pacman/layout/_partial/post/article.ejs","hash":"ec5e8f66886dedf35b9a5746d11fe0dc4a7ab68f","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/post/footer.ejs","hash":"5b6e1fd8c9708d865f2b97e0a644f4f8f5c35fe9","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/post/catetags.ejs","hash":"f6b107078094333b6567d4a97700f559159675e1","modified":1480516369933},{"_id":"themes/pacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1480516369941},{"_id":"themes/pacman/layout/_partial/post/comment.ejs","hash":"5c0afcd1fd1d7b4e8335f76bc181b8e72ffed38e","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/post/gallery.ejs","hash":"7ca5b1db9439be61a8b77f6f7d857b56fdf1517f","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/post/header.ejs","hash":"73aa8a410cc80277930acaec23003c30eeac6d79","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/post/jiathis.ejs","hash":"adc047d2bbd031092df86f3be2866ea9c3b5f3c9","modified":1480516369933},{"_id":"themes/pacman/layout/_partial/post/pagination.ejs","hash":"dd9563aaa7094c7082a16e6c9cbc24b33aaef87c","modified":1480516369933},{"_id":"themes/pacman/source/css/_partial/aside.styl","hash":"8fb8c2172883913b404f8e49e181103317486ecc","modified":1480516369933},{"_id":"themes/pacman/source/css/_partial/article.styl","hash":"82d7621920e221b7e52dfdb74cbcec718d0cc666","modified":1480516369933},{"_id":"themes/pacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1480516369937},{"_id":"themes/pacman/source/css/_partial/footer.styl","hash":"77c2e6251cea1f3970646f6fbe5d557ed4f98586","modified":1480516369937},{"_id":"themes/pacman/source/css/_partial/gallery.styl","hash":"a544a58fdb4c8dd8274159323abd1e38cb03215e","modified":1480516369937},{"_id":"themes/pacman/source/css/_partial/header.styl","hash":"d27d0057b86dc61a1ab8a9037ee43dfcc43766b3","modified":1480516369937},{"_id":"themes/pacman/source/css/_partial/helper.styl","hash":"52d4ee51b7087c2c2a7e7ded6f63270165d9de89","modified":1480516369937},{"_id":"themes/pacman/source/css/_partial/index.styl","hash":"0d219fc6fb76c0d4ffd1dc2a119969d78a157285","modified":1480516369937},{"_id":"themes/pacman/source/css/_base/code.styl","hash":"330209ebaebe69308e131fada85b9b619c85fbd9","modified":1480516369933},{"_id":"themes/pacman/source/css/_base/font.styl","hash":"75f264bc742888dbe192e8d19eda70705d13c709","modified":1480516369933},{"_id":"themes/pacman/source/css/_base/public.styl","hash":"29deec49b60533cc4196175345eaa4b2d611a97e","modified":1480516369933},{"_id":"themes/pacman/source/css/_base/variable.styl","hash":"d227693a63c267245a54448340c49cd566244b87","modified":1480516369933},{"_id":"themes/pacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1480516369937},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1480516369937},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1480516369937},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1480516369937},{"_id":"themes/pacman/source/js/jquery-2.1.0.min.js","hash":"98884258cbdb0d939fa2c5e74fc7ac9e56d8170f","modified":1480516369945},{"_id":"themes/pacman/source/img/xiaoxin.jpg","hash":"2ee983f8da1be448bd89e8fe0b7c093606bf9788","modified":1480516369945},{"_id":"source/_posts/毕业了/graduation3.jpg","hash":"54cffe443f66930659fe9d0a6ee12154ce8d5c28","modified":1480516369913},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1480516369937},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1480516369937},{"_id":"themes/pacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1480516369941},{"_id":"source/_posts/毕业了/graduation2.jpg","hash":"ccffa377b02496a0f2437578d7f6d35b879373a5","modified":1480516369913},{"_id":"source/_posts/毕业了/graduation8.jpg","hash":"ab88166275c1a01036fe3680407dfff9f52c3434","modified":1480516369917},{"_id":"source/_posts/毕业了/graduation1.jpg","hash":"55cd28acab408b9a81fd6877a47e24d20749e20c","modified":1480516369913},{"_id":"source/_posts/毕业了/graduation7.jpg","hash":"4ef31ad176f81cde92dff0958cfc0b70d789e754","modified":1480516369917},{"_id":"source/_posts/毕业了/graduation4.jpg","hash":"e84c1f0a512f1aba02163ba3a8cf39460b9cb28b","modified":1480516369917},{"_id":"public/page/index.html","hash":"4aad0463902e4827d9ee247e46dfc6b8ddb1dfd6","modified":1486477731599},{"_id":"public/2016/06/30/毕业了/index.html","hash":"1348b50215634dc2cabda3f979276ad17723d3e7","modified":1486477731650},{"_id":"public/2016/04/14/他可是科比·布莱恩特!/index.html","hash":"4f0faaf8702dd1fa7a5df979ee4469d0754d75b5","modified":1486477731652},{"_id":"public/2016/04/12/junit使用/index.html","hash":"990c31e25a49ae0a7277a5a5c63734eb7ec0c681","modified":1486477731652},{"_id":"public/archives/index.html","hash":"12d2ab4890b6340eecae672d1e2f07cc809a91fd","modified":1486477731652},{"_id":"public/archives/page/2/index.html","hash":"02a01ac376ca9903c36af87688f4830b448b79a9","modified":1486477731652},{"_id":"public/archives/page/3/index.html","hash":"60f525482bc468189240d915801408a21f427e73","modified":1486477731652},{"_id":"public/archives/page/4/index.html","hash":"c8445bf9f93c69de32f85c21482afb45780bceff","modified":1487030235281},{"_id":"public/archives/2015/index.html","hash":"c0c7e3567992f7bc06ed231c48b3d678007ecd03","modified":1486477731652},{"_id":"public/archives/2015/12/index.html","hash":"7c270d43e7601e8670adf4aec17d1e2dba59e251","modified":1486477731652},{"_id":"public/archives/2016/index.html","hash":"d5ceb776b22ac3ec76a40876684ebdeef3f905a8","modified":1486477731652},{"_id":"public/archives/2016/page/2/index.html","hash":"4365f3385b401b07fa7d32d9045b6421ddf55106","modified":1486477731652},{"_id":"public/archives/2016/page/3/index.html","hash":"6cbac60224bd4420552a74d783c65b3a08deb6f0","modified":1487030235281},{"_id":"public/archives/2016/page/4/index.html","hash":"3032b2dc9f367cc0af9dd9d4b4f8a63d37082e6b","modified":1487030235281},{"_id":"public/archives/2016/03/index.html","hash":"0b20420c4415a7f29879b3dc6094aa7c46ede5dd","modified":1486477731653},{"_id":"public/archives/2016/04/index.html","hash":"d7847cb0583c52a04faa171e8d7f5c5719903c0b","modified":1486477731653},{"_id":"public/archives/2016/06/index.html","hash":"7ac351b641114985c01c2c5b08b9749097bf91eb","modified":1486477731653},{"_id":"public/archives/2016/07/index.html","hash":"0ec880df763da355726d528c30effa700f812fdc","modified":1486477731653},{"_id":"public/archives/2016/08/index.html","hash":"0babe9e98759c4d9242d3b90133ac39aaa053bdd","modified":1487030235281},{"_id":"public/archives/2016/09/index.html","hash":"f243913eb8d056d63b1c93636a7526cd201af152","modified":1487030235281},{"_id":"public/archives/2016/10/index.html","hash":"8f283141e80ce832f94002fd14f4e525e349e3b9","modified":1487030235281},{"_id":"public/archives/2016/11/index.html","hash":"eac3deacf8041e032ac505811b4a0019365cce80","modified":1487030235281},{"_id":"public/archives/2016/12/index.html","hash":"1f1e6ac4c2e2d40374c42a8fe79a29acc5718209","modified":1487030235281},{"_id":"public/page/3/index.html","hash":"ed4fcfb8e71d98eb759c3a24cfce3c003c7c7e92","modified":1486477731653},{"_id":"public/page/4/index.html","hash":"e688a06053590b5196d98bb9fe45f8ecf0b47ccf","modified":1487030235280},{"_id":"public/tags/java/index.html","hash":"efe49b3dfda111f7fe169c90be3d5abef80ab58f","modified":1486477731653},{"_id":"public/tags/java/page/2/index.html","hash":"bd45c2275c43d53a47dc5822c81ac730b7631a4f","modified":1486477731653},{"_id":"public/tags/java/page/3/index.html","hash":"8cad798275a7b7c645b946297000589d327d8c5f","modified":1487030235280},{"_id":"public/tags/ant/index.html","hash":"19f7e3813a2fb64cd70d4db54712620189e4aa88","modified":1486477731654},{"_id":"public/tags/Eclipse/index.html","hash":"4e2cf2f6bdee72b612e3f59e3a8c5f2c2621173b","modified":1487030235280},{"_id":"public/tags/源码/index.html","hash":"256060f14765f13df4f8308b2d85c3bbbab71ad7","modified":1487030235280},{"_id":"public/tags/服务器/index.html","hash":"fcdd7839846f2d603821fa5ad1d3b7b48fd16569","modified":1487030235280},{"_id":"public/tags/spring/index.html","hash":"21ee7093135f4f4ec140b8300b0d1fde2aa58e25","modified":1487030235281},{"_id":"public/tags/编码/index.html","hash":"83b6cb7e8a8165975bc625c29f63257f10670206","modified":1486477731654},{"_id":"public/tags/junit/index.html","hash":"489aeaf8d7e7103df01e3ac6bd45df699a587661","modified":1486477731654},{"_id":"public/tags/测试/index.html","hash":"bd4a2305515b98f3d2e6d507708a501c79e94f98","modified":1486477731654},{"_id":"public/tags/调试/index.html","hash":"ab2e1152e7b1b5c62850fa0ad99c50f7cb293bb5","modified":1487030235281},{"_id":"public/tags/多线程/index.html","hash":"bd316b0bb66dd96b1d128a1ad9a0dff1b6d55653","modified":1486477731654},{"_id":"public/tags/markdown/index.html","hash":"d2063e412367ceddac3334f035ef5e0003983785","modified":1486477731654},{"_id":"public/tags/python/index.html","hash":"19d4c5c6b0146bba16446e38cb1f30c21f123b33","modified":1486477731654},{"_id":"public/tags/加密/index.html","hash":"28791d51c48a7143aa46ce350de343c3362869e5","modified":1487030235281},{"_id":"public/tags/快捷键/index.html","hash":"6608cb2af73745e7db500bf5a578a494acc3e4d0","modified":1486477731654},{"_id":"public/tags/curl/index.html","hash":"eaf6322d80abfd02634f86910a40dcab10919607","modified":1487030235281},{"_id":"public/categories/工具/index.html","hash":"b214a4cb8b5b96c6b14b06193ce7ca767de2383d","modified":1486477731655},{"_id":"public/categories/编程/index.html","hash":"5c58f0291aebc7b285576c3eeea1fa82fde851a9","modified":1486477731655},{"_id":"public/categories/编程/page/2/index.html","hash":"4f442062900492656977bd0d4c953bbb8738ffd3","modified":1486477731655},{"_id":"public/categories/技术/index.html","hash":"137f50670ccfba0177329ad38961a2476b1148cb","modified":1487030235279},{"_id":"public/categories/java/index.html","hash":"6e71bd6b3678d21b4b95c5e07f932e8c480f238e","modified":1487030235280},{"_id":"public/categories/生活/index.html","hash":"0a24d6a1b7f803e19ab4ab587c83c8eb4bfbeb67","modified":1486477731655},{"_id":"public/2016/12/13/java异常的学习/index.html","hash":"b57fb216c725ba170e8d4098ae882b94a7c4ae9a","modified":1487030235282},{"_id":"public/2016/12/07/java远程调试学习/index.html","hash":"5d4ce248747678a617a36b6b3acfca49bd1ce0e9","modified":1487030235282},{"_id":"public/2016/12/04/java中的路径/index.html","hash":"fc86fdd7bfb56a05bdc4103b593cecbfc0de40de","modified":1487030235282},{"_id":"public/2016/11/24/java中的int/byte互转/index.html","hash":"b63cff51941f2b063c1745a51b2562d5c2e4005b","modified":1487030235282},{"_id":"public/2016/10/10/java泛型学习/index.html","hash":"1bcfff9a495206ee2df524a3b7cffd4c4a0fefca","modified":1487030235282},{"_id":"public/2016/09/25/ssl总结/index.html","hash":"34547b18b6a805a56c7d7176367069de91bc6405","modified":1487030235282},{"_id":"public/2016/09/24/记录这周工作遇到的坑/index.html","hash":"5804933533f52cb500eae581aa10ce0950ccba0c","modified":1487030235282},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/index.html","hash":"8609aad6ba442bd8f685b42bdb4a2929bcb6b6b5","modified":1487030235282},{"_id":"public/2016/09/19/Spring项目打包为jar/index.html","hash":"67ff137f5c1027d25613a5954530f4c1fa301976","modified":1487030235282},{"_id":"public/2016/09/10/理解java内存模型/index.html","hash":"dda19a71839a8bf72e3669a0290f214f757249a9","modified":1487030235282},{"_id":"public/2016/08/31/理解notify notifyall sleep/index.html","hash":"61f8a961911d0526a9ee460c29430ba5483dc2a2","modified":1487030235282},{"_id":"public/2016/08/22/关于加密的一点总结/index.html","hash":"1309361483919b1e2f1d508f3c6ed5909aed82f1","modified":1487030235282},{"_id":"public/2016/08/16/Java集合框架学习总结/index.html","hash":"207fcea96d63d4dedc72e7b97ad0cfdcd69cc447","modified":1487030235282},{"_id":"public/2016/08/16/synchronized的一些用法/index.html","hash":"6cb664262fddba498a67dbd7cf976f50ac434c72","modified":1487030235283},{"_id":"public/2016/08/15/一些计划/index.html","hash":"9ca936cd4f9c117d6ae2e3422e1189196f40fb9d","modified":1487030235283},{"_id":"public/2016/07/31/为什么是final/index.html","hash":"76a57442901c5e8921a01f6f0e31f4b145652aeb","modified":1486477731656},{"_id":"public/2016/07/24/java_Tips/index.html","hash":"7cf4806d5e9fdfbda5ce00ac5b9340b03dace700","modified":1486477731656},{"_id":"public/2016/07/18/Ant的使用/index.html","hash":"1c82ad8e14185f381b9d12db558490da407607c5","modified":1486477731656},{"_id":"public/2016/06/30/java中的枚举/index.html","hash":"fa40ecdbdc8cf7481e6a6a3d3af6b237aebefea4","modified":1486477731656},{"_id":"public/2016/06/21/java中的ThreadLocal/index.html","hash":"6e17d6734c63810e6121945f494c0411a5de82e3","modified":1486477731656},{"_id":"public/2016/04/28/java中的equals与hashcode/index.html","hash":"b9b38a452e44257da8573b327a23bcc5d725e12a","modified":1486477731656},{"_id":"public/2016/04/28/java中的类型转换/index.html","hash":"b9ef93861288099018a31d2ce63a5dce0f19d8f1","modified":1486477731657},{"_id":"public/2016/04/25/ant编译java工程jdk路径的设置/index.html","hash":"845d61ea5c6c389afefff4808abd0354f38b54bd","modified":1486477731657},{"_id":"public/2016/04/20/java中的编码问题/index.html","hash":"9d754385c91ee7f35842178d9e52dde3ce51ab5a","modified":1486477731657},{"_id":"public/2016/04/15/关于抽象类和接口/index.html","hash":"46a24ee9cbabbdc2b1cc3f1e480431ba82071b38","modified":1486477731657},{"_id":"public/2016/03/30/sphinx安装问题/index.html","hash":"4d4f2379d6b00eebed95bfc37603b79940d92d4b","modified":1486477731657},{"_id":"public/2016/03/29/代码格式/index.html","hash":"3787aec925fddeaef3990078943224215a5715ea","modified":1486477731657},{"_id":"public/2016/03/22/常用快捷键总结/index.html","hash":"df2b7df192a78235a210871f1acb692ae975c57d","modified":1486477731657},{"_id":"public/2016/03/03/markdown/index.html","hash":"6b209a5906d5522673d08c10806e6e5accd85666","modified":1486477731657},{"_id":"public/2015/12/21/notify问题/index.html","hash":"1708945b46f6c5d26f8e6cd8c888d10490880939","modified":1486477731657},{"_id":"public/2015/12/17/java同步锁锁什么/index.html","hash":"da09c9cb1bbe9e75a59fd227eaa21c916207667d","modified":1486477731657},{"_id":"public/index.html","hash":"0fc163c0574aad1ddbeea28af8ae63b133f05375","modified":1486477731657},{"_id":"public/page/2/index.html","hash":"a0fa2daf8c542c6151f24a8321b36bd417b8214b","modified":1486477731657},{"_id":"public/archives/2017/index.html","hash":"01d00b1a8165cd49f5bdb659ddc0bef5e0b9d83f","modified":1487030235281},{"_id":"public/archives/2017/02/index.html","hash":"fa2307cb28891f1cc5d11460fd5067a3d593febb","modified":1487030235281},{"_id":"public/tags/linux/index.html","hash":"c83773cce59f1038e8643979eaee0905c0ea473b","modified":1487030235281},{"_id":"public/2017/02/07/Vps使用笔记/index.html","hash":"deed85788f1941f8b6671d084fca82baaa7fd467","modified":1487030235281},{"_id":"public/CNAME","hash":"75913de577e6e2674855228ebb98f985574fdca1","modified":1486477731698},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1486477731698},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1486477731698},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1486477731698},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1486477731699},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1486477731699},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1486477731699},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1486477731699},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1486477731699},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1486477731699},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1486477731699},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1486477731699},{"_id":"public/img/author.jpg","hash":"cf5161efc731fc892ab04b77c2369c7fdad21d87","modified":1486477731699},{"_id":"public/img/logo.svg","hash":"0eb0ae32d95c6f0b14adb9ab491775dcd1da3af3","modified":1486477731699},{"_id":"public/img/xiaoxin.ico","hash":"82778e9316d3d1d366442a8f5d0468dda013d983","modified":1486477731699},{"_id":"public/img/xiaoxin.png","hash":"479898e56ba23fdc6c68a611939316ad58f6e78c","modified":1486477731699},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1486477731699},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1486477731699},{"_id":"public/2016/08/16/Java集合框架学习总结/collection.png","hash":"9644281b68a057f4db9b162c45ac4c076c7c5651","modified":1487030235294},{"_id":"public/2016/04/28/java中的equals与hashcode/entry.png","hash":"c6c32336b30c74d2e825684e590fc8bb15af2dc1","modified":1486477731700},{"_id":"public/2016/10/10/java泛型学习/easybill.jpg","hash":"4090b7f4d3fb71aa1213a4ac8ef44e1d11dd8818","modified":1487030235294},{"_id":"public/2016/12/13/java异常的学习/java.png","hash":"1f36e7cffb24b7771a60661d3d7301b9ca8c8f87","modified":1487030235294},{"_id":"public/2016/08/22/关于加密的一点总结/md5.png","hash":"5830f21212d5da0f37cb94dd97fc8db37dcdf033","modified":1487030235294},{"_id":"public/2016/08/31/理解notify notifyall sleep/线程状态.png","hash":"0716019dc5c338a2b07197e0cd5f593d4dedc504","modified":1487030235294},{"_id":"public/2016/09/10/理解java内存模型/volatile.png","hash":"66e532f81e9747722754733ee0361d3e28bf3ce1","modified":1487030235294},{"_id":"public/2016/09/10/理解java内存模型/内存模型.png","hash":"9afbd38d84a83cd56288172cc45fc627867113c2","modified":1487030235294},{"_id":"public/2016/04/20/java中的编码问题/reader.png","hash":"4cf16c765f0952a9134bc5097270d3a6b2679f76","modified":1486477731701},{"_id":"public/2016/04/20/java中的编码问题/utf8.png","hash":"f4a2eb95b15e12d6957c07099fafd42d9b6c035e","modified":1486477731701},{"_id":"public/2016/04/20/java中的编码问题/writer.png","hash":"3ac4dcf3e18dc011372297be5069f387fef0e9f9","modified":1486477731701},{"_id":"public/2016/12/07/java远程调试学习/jdpa.png","hash":"d0fc92e1d6b23a66eb753304c6ca06df2f91357d","modified":1487030235294},{"_id":"public/2016/12/07/java远程调试学习/setting.png","hash":"5cdc18528edb9e01c731b8c4c5057467670ea59e","modified":1487030235294},{"_id":"public/2016/09/24/记录这周工作遇到的坑/compiler.png","hash":"9ac5d2d7f2e76b216a82cf9eaea2034857c18127","modified":1487030235294},{"_id":"public/2016/09/24/记录这周工作遇到的坑/error.png","hash":"016f7b6c6d5ef72cc405baa5777bf2077d178931","modified":1487030235294},{"_id":"public/2016/09/24/记录这周工作遇到的坑/gengeration.png","hash":"acd8916c32713eb373fed19198b000b0516080e6","modified":1487030235294},{"_id":"public/2016/09/25/ssl总结/zhifubao.png","hash":"861fb5b3e7686cab022872e16f93eee43f2f657c","modified":1487030235295},{"_id":"public/2016/09/25/ssl总结/zhufubao1.png","hash":"31d3700c1b34205b3527e551806815a179012710","modified":1487030235295},{"_id":"public/2016/09/25/ssl总结/zhufubao2.png","hash":"670fb52cc2d6a871af24621ff34613d80f47213a","modified":1487030235295},{"_id":"public/2016/09/19/Spring项目打包为jar/2.png","hash":"7ff532cc98f22996c89a2a590954c113e2de486f","modified":1487030235295},{"_id":"public/2016/09/19/Spring项目打包为jar/3.png","hash":"a6c93e41c454ca4d89a2c5153ff74ac3c9eec04a","modified":1487030235295},{"_id":"public/2016/09/19/Spring项目打包为jar/4.png","hash":"644dca24dfefc583f2b222e967962d2de68452bb","modified":1487030235295},{"_id":"public/2016/09/19/Spring项目打包为jar/5.png","hash":"7c9911eab320a22ef1a310dfb15a8996aa37de2b","modified":1487030235295},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/2.png","hash":"4dd8a8d179e898c803a879fec14afb855a34b23d","modified":1487030235296},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/3.png","hash":"d62218e89ab63a0c4a05ebfd35192b7f3c031588","modified":1487030235298},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/4.png","hash":"5ef56fc1e37d46da093fbf0b94273b45eb3cb8bd","modified":1487030235298},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/5.png","hash":"7fc75d3a44bebd24c9df7ad7e7d49d70de611325","modified":1487030235299},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1486477733138},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1486477733149},{"_id":"public/img/xiaoxin.jpg","hash":"2ee983f8da1be448bd89e8fe0b7c093606bf9788","modified":1486477733153},{"_id":"public/2016/04/14/他可是科比·布莱恩特!/kobe.jpg","hash":"5e2e8343a4fba076d7475cc6cda941d21176be44","modified":1486477733153},{"_id":"public/2016/12/07/java远程调试学习/remote.png","hash":"31329d2e3f6c04d6d13be67437e7a4322c31a061","modified":1487030235305},{"_id":"public/2016/09/19/Spring项目打包为jar/1.png","hash":"925c9162dc357b505520543c5c47d3dd11dc840a","modified":1487030235305},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/1.png","hash":"6ed1e52158e7dbce544e72af037ede46b38f1600","modified":1487030235305},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/6.png","hash":"b27b88bd85eb9e2dac3cc7164678ca203c3ff9c7","modified":1487030235305},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/7.png","hash":"1558afd4f271658241ff3a5189ee10bf7f5ebbf2","modified":1487030235306},{"_id":"public/2016/06/30/毕业了/graduation5.jpg","hash":"976ff6965b27f578d365ae139db1c8d5c298d757","modified":1486477733155},{"_id":"public/2016/06/30/毕业了/graduation6.jpg","hash":"4f36689e7db00afd3f2bc3b4c33480e9d1f1a99c","modified":1486477733155},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1486477733165},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1486477733165},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1486477733165},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1486477733165},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1486477733165},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1486477733165},{"_id":"public/css/style.css","hash":"e3e1ec9060ce2fa8cae11c2e113dd1b45cfed017","modified":1486477733165},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1486477733165},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1486477733166},{"_id":"public/js/jquery-2.1.0.min.js","hash":"98884258cbdb0d939fa2c5e74fc7ac9e56d8170f","modified":1486477733166},{"_id":"public/2016/09/25/ssl总结/sslprocess.jpg","hash":"449b6c730fb7f7452592972d8748cf6bbe942de8","modified":1487030235311},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1486477733168},{"_id":"public/2016/06/30/毕业了/graduation3.jpg","hash":"54cffe443f66930659fe9d0a6ee12154ce8d5c28","modified":1486477733168},{"_id":"public/2016/06/30/毕业了/graduation2.jpg","hash":"ccffa377b02496a0f2437578d7f6d35b879373a5","modified":1486477733172},{"_id":"public/2016/06/30/毕业了/graduation8.jpg","hash":"ab88166275c1a01036fe3680407dfff9f52c3434","modified":1486477733172},{"_id":"public/2016/06/30/毕业了/graduation1.jpg","hash":"55cd28acab408b9a81fd6877a47e24d20749e20c","modified":1486477733174},{"_id":"public/2016/06/30/毕业了/graduation7.jpg","hash":"4ef31ad176f81cde92dff0958cfc0b70d789e754","modified":1486477733175},{"_id":"public/2016/06/30/毕业了/graduation4.jpg","hash":"e84c1f0a512f1aba02163ba3a8cf39460b9cb28b","modified":1486477733178}],"Category":[{"name":"工具","_id":"ciyvmgj3i0004digc622avmvb"},{"name":"编程","_id":"ciyvmgj48000ddigcgs043grk"},{"name":"技术","_id":"ciyvmgj4g000ldigcroaveipd"},{"name":"java","_id":"ciyvmgj540019digco6lcphan"},{"name":"生活","_id":"ciyvmgj5y0021digcqdem8tgp"}],"Data":[],"Page":[{"layout":"page","title":"README","comments":0,"_content":"{% codeblock lang:java %}\n name: \"于凯\"\n university: \"中国民航大学\"\n hometown: \"山西晋中\"\n dream: \"两亩地一头牛，老婆孩子热炕头\"\n{% endcodeblock %}\n\n本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。也有生活中的一些总结。\n\n# 博客基础\n\n[Hexo](https://hexo.io/)一款轻量级的静态博客框架\n[Pacman](https://github.com/A-limon/pacman)扁平化、响应式Hexo主题\n[Markdown](https://www.gitbook.com/book/noahsoft/-makedown/details)一款轻量级的标记语言\n\n# 技能栈\n\nJava\n\nGit\n\n设计模式\n\nLinux\n\n# 书单\n\n《重构 改善既有代码的设计》  人民邮电出版社\n\n《深入理解JVM虚拟机》  机械工业出版社\n\n《大话设计模式》  清华大学出版社  \n\n《Java 并发编程实战》 机械工业出版社\n\n《鸟哥的Linux私房菜》 人民邮电出版社\n \n《大型网站技术架构》 电子工业出版社\n\n","source":"page/index.md","raw":"layout: page\ntitle: README\ncomments: false\n---\n{% codeblock lang:java %}\n name: \"于凯\"\n university: \"中国民航大学\"\n hometown: \"山西晋中\"\n dream: \"两亩地一头牛，老婆孩子热炕头\"\n{% endcodeblock %}\n\n本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。也有生活中的一些总结。\n\n# 博客基础\n\n[Hexo](https://hexo.io/)一款轻量级的静态博客框架\n[Pacman](https://github.com/A-limon/pacman)扁平化、响应式Hexo主题\n[Markdown](https://www.gitbook.com/book/noahsoft/-makedown/details)一款轻量级的标记语言\n\n# 技能栈\n\nJava\n\nGit\n\n设计模式\n\nLinux\n\n# 书单\n\n《重构 改善既有代码的设计》  人民邮电出版社\n\n《深入理解JVM虚拟机》  机械工业出版社\n\n《大话设计模式》  清华大学出版社  \n\n《Java 并发编程实战》 机械工业出版社\n\n《鸟哥的Linux私房菜》 人民邮电出版社\n \n《大型网站技术架构》 电子工业出版社\n\n","date":"2017-01-21T14:30:49.432Z","updated":"2017-01-21T14:30:49.284Z","path":"page/index.html","_id":"ciyvmgj350001digcc7t3u5qz","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">name: <span class=\"string\">\"于凯\"</span></div><div class=\"line\">university: <span class=\"string\">\"中国民航大学\"</span></div><div class=\"line\">hometown: <span class=\"string\">\"山西晋中\"</span></div><div class=\"line\">dream: <span class=\"string\">\"两亩地一头牛，老婆孩子热炕头\"</span></div></pre></td></tr></table></figure>\n<p>本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。也有生活中的一些总结。</p>\n<h1 id=\"博客基础\"><a href=\"#博客基础\" class=\"headerlink\" title=\"博客基础\"></a>博客基础</h1><p><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>一款轻量级的静态博客框架<br><a href=\"https://github.com/A-limon/pacman\" target=\"_blank\" rel=\"external\">Pacman</a>扁平化、响应式Hexo主题<br><a href=\"https://www.gitbook.com/book/noahsoft/-makedown/details\" target=\"_blank\" rel=\"external\">Markdown</a>一款轻量级的标记语言</p>\n<h1 id=\"技能栈\"><a href=\"#技能栈\" class=\"headerlink\" title=\"技能栈\"></a>技能栈</h1><p>Java</p>\n<p>Git</p>\n<p>设计模式</p>\n<p>Linux</p>\n<h1 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h1><p>《重构 改善既有代码的设计》  人民邮电出版社</p>\n<p>《深入理解JVM虚拟机》  机械工业出版社</p>\n<p>《大话设计模式》  清华大学出版社  </p>\n<p>《Java 并发编程实战》 机械工业出版社</p>\n<p>《鸟哥的Linux私房菜》 人民邮电出版社</p>\n<p>《大型网站技术架构》 电子工业出版社</p>\n","excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">name: <span class=\"string\">\"于凯\"</span></div><div class=\"line\">university: <span class=\"string\">\"中国民航大学\"</span></div><div class=\"line\">hometown: <span class=\"string\">\"山西晋中\"</span></div><div class=\"line\">dream: <span class=\"string\">\"两亩地一头牛，老婆孩子热炕头\"</span></div></pre></td></tr></table></figure>\n<p>本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。也有生活中的一些总结。</p>\n<h1 id=\"博客基础\"><a href=\"#博客基础\" class=\"headerlink\" title=\"博客基础\"></a>博客基础</h1><p><a href=\"https://hexo.io/\">Hexo</a>一款轻量级的静态博客框架<br><a href=\"https://github.com/A-limon/pacman\">Pacman</a>扁平化、响应式Hexo主题<br><a href=\"https://www.gitbook.com/book/noahsoft/-makedown/details\">Markdown</a>一款轻量级的标记语言</p>\n<h1 id=\"技能栈\"><a href=\"#技能栈\" class=\"headerlink\" title=\"技能栈\"></a>技能栈</h1><p>Java</p>\n<p>Git</p>\n<p>设计模式</p>\n<p>Linux</p>\n<h1 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h1><p>《重构 改善既有代码的设计》  人民邮电出版社</p>\n<p>《深入理解JVM虚拟机》  机械工业出版社</p>\n<p>《大话设计模式》  清华大学出版社  </p>\n<p>《Java 并发编程实战》 机械工业出版社</p>\n<p>《鸟哥的Linux私房菜》 人民邮电出版社</p>\n<p>《大型网站技术架构》 电子工业出版社</p>\n"}],"Post":[{"layout":"post","date":"2016-07-18T04:48:55.000Z","title":"ANT的使用","_content":"\n>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和[Ant](http://ant.apache.org/)打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。\n\n## 教程\n\nAnt是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。\n\n[Ant Tutorial](http://www.tutorialspoint.com/ant/index.htm)\n\n[Ant 实践](http://www.uml.org.cn/j2ee/j2ee091302.htm#content)\n\n另外附上Ant常用命令：\n\n[Overview of Apache Ant Tasks](https://ant.apache.org/manual/tasksoverview.html)\n\n## 实践\n\n下面是自己写的build.xml。存在这里，以后用到可以参考。\n\n下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。\n\n- **build.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n    Oscar XcluseterHibernate Ant build file\n-->\n<project name=\"OSCAR-XCLUSETER-HIBERNATE\" default=\"usage\" basedir=\".\">\n\t<target name=\"build\" depends=\"clean\" />\n\n\t<target name=\"init\" description=\"default init\">\n\t\t<property file=\"build.properties\" />\n\n\t\t<!-- Project Properties -->\n\t\t<property name=\"project\" value=\"oscarXcluseterHibernate3\" />\n\t\t<property name=\"name\" value=\"OSCAR HIBERNATE\" />\n\t\t<tstamp>\n\t\t\t<format property=\"year\" pattern=\"yyyy\" locale=\"zh_CN\" />\n\t\t\t<format property=\"builddate\" pattern=\"yyMMdd\" locale=\"zh_CN\" />\n\t\t</tstamp>\n\t\t<property name=\"version\" value=\"${version.major}.${version.minor}.${version.revision}${version.suffix}\" />\n\t\t<property name=\"version.number\" value=\"${version.major}.${version.minor}.${version.revision}\" />\n\t\t<property name=\"version.major.minor\" value=\"${version.major}.${version.minor}\" />\n\n\t\t<property name=\"final.name\" value=\"${project}\" />\n\t\t<property name=\"vesrion.build\" value=\"build${builddate} ${version.subbuild} ${version.buildID} for ALL \" />\n\n\t\t<!-- Build Defaults -->\n\t\t<property name=\"src.dir\" value=\"${basedir}/src\" />\n\t\t<property name=\"lib.dir\" value=\"${basedir}/lib\" />\n\t\t<property name=\"build.home\" value=\"${basedir}\" />\n\t\t<property name=\"build.src\" value=\"${basedir}/build\" />\n\t\t<property name=\"build.dest\" value=\"${basedir}/antClasses\" />\n\t\t<property name=\"build.release\" value=\"${basedir}/release\" />\n\t\t<property name=\"build.tmp\" value=\"${basedir}/tmp\" />\n\n\t\t<!-- JAR artifacts -->\n\t\t<property name=\"hiberante3.jar\" value=\"${lib.dir}/hibernate3.jar\" />\n\n\t\t<!-- Version info filter set -->\n\t\t<tstamp>\n\t\t\t<format property=\"DSTAMP\" pattern=\"yyyyMMdd\" locale=\"zh_CN\" />\n\t\t\t<format property=\"TSTAMP\" pattern=\"hhmm\" />\n\t\t</tstamp>\n\t\t<filterset id=\"version.filters\">\n\t\t\t<filter token=\"VERSION_NUMBER\" value=\"${version.number}\" />\n\t\t\t<filter token=\"BUNDLE_NAME\" value=\"${vesrion.name}\" />\n\t\t\t<filter token=\"BUNDLE_VERSION\" value=\"${version}${DSTAMP}${TSTAMP}\" />\n\t\t\t<filter token=\"BUILD_VERSION\" value=\"${vesrion.build}\" />\n\t\t</filterset>\n\t\t<path id=\"classpath\">\n\t\t\t<pathelement location=\"${hiberante3.jar}\" />\n\t\t</path>\n\t</target>\n\n\t<target name=\"usage\" depends=\"init\">\n\t\t<echo message=\"${name} Build file\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" available targets are:\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"   package  --> generates oscarXcluseterHibernate file\" />\n\t\t<echo message=\"   build    --> compiles the source code\" />\n\t\t<echo message=\"   clean    --> cleans up the directory\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" See the comments inside the build.xml file for more details.\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"\" />\n\t</target>\n\n\t<!-- Just build -->\n\t<target name=\"compile-prepare\" depends=\"init\" description=\"Prepare for compile\">\n\n\t\t<!-- create directories -->\n\t\t<mkdir dir=\"${build.src}\" />\n\t\t<mkdir dir=\"${build.dest}\" />\n\n\t\t<!-- copy src files -->\n\t\t<copy todir=\"${build.src}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${src.dir}\">\n\t\t\t\t<exclude name=\"**/*.MF\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"compile\" depends=\"compile-prepare\" description=\"compile the project\">\n\n\t\t<!-- Compiles the source directory  -->\n\t\t<javac srcdir=\"${build.src}\" \n\t\t\tdestdir=\"${build.dest}\" \n\t\t\tdebug=\"${build.debug}\" \n\t\t\tdeprecation=\"${build.deprecation}\" \n\t\t\tsource=\"${build.source}\" \n\t\t\ttarget=\"${build.target}\" \n\t\t\tcompiler=\"${build.compiler}\" \n\t\t\toptimize=\"${build.optimize}\" \n\t\t\tincludes=\"**/*.java\" \n\t\t\texcludes=\"**/CVS/**,**/.svn/**\" \n\t\t\tencoding=\"GB18030\"\n\t\t\tincludeantruntime=\"false\"\n\t\t\texecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"\n\t\t\tfork=\"yes\">\n\t\t\t<classpath refid=\"classpath\" />\n\t\t</javac>\n\n\t\t<!-- copy src files exclude java file-->\n\t\t<copy todir=\"${build.dest}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${build.src}\">\n\t\t\t\t<exclude name=\"**/*.java\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"build-manifests\" depends=\"init,compile-prepare\">\n\t\t<!-- Filtering tokens for JAR manifests-->\n\t\t<filter token=\"source.jdk\" value=\"${build.source}\" />\n\t\t<filter token=\"target.jdk\" value=\"${build.target}\" />\n\t\t<mkdir dir=\"${build.tmp}\" />\n\t\t<copy todir=\"${build.tmp}\" overwrite=\"yes\" filtering=\"yes\" encoding=\"GB18030\">\n\t\t\t<filterset refid=\"version.filters\" />\n\t\t\t<fileset dir=\"src/META-INF\" includes=\"MANIFEST.MF\" />\n\t\t</copy>\n\t</target>\n\n\t<target name=\"package\" depends=\"compile,build-manifests\" description=\"create jar file\">\n\t\t<mkdir dir=\"${build.release}\" />\n\t\t<jar jarfile=\"${build.release}/${final.name}.jar\" manifest=\"${build.tmp}/MANIFEST.MF\" basedir=\"${build.dest}\" includes=\"**\" />\n\t</target>\n\n\t<target name=\"clean\" depends=\"package\">\n\t\t<delete dir=\"${build.src}\" />\n\t\t<delete dir=\"${build.dest}\" />\n\t\t<delete dir=\"${build.tmp}\" />\n\t</target>\n</project>\n\n```\n\n- **build.properties**\n\n```java\n\n# -----------------------------------------------------------------------------\n# build.properties\n#\n# This is an example \"build.properties\" file, used to customize building \n# OSCAR-JDBC for your local environment.  It defines the location of all external\n# modules that OSCAR-JDBC depends on.\n# -----------------------------------------------------------------------------\n\n# ----- Version Control Flags -----\nvesrion.name=Main\nversion.major=1\nversion.minor=0\nversion.revision=0\nversion.suffix=x\nversion.subbuild=001\nversion.buildID=00000000\n\nbuild.source=1.5\nbuild.target=1.5\nbuild.debug=false\nbuild.optimize=true\nbuild.compiler=javac1.5\n\n```","source":"_posts/Ant的使用.md","raw":"---\nlayout: post\ndate:   2016-07-18 12:48:55\ntitle:  \"ANT的使用\"\ncategories: 工具\ntags: \n- java\n- ant\n---\n\n>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和[Ant](http://ant.apache.org/)打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。\n\n## 教程\n\nAnt是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。\n\n[Ant Tutorial](http://www.tutorialspoint.com/ant/index.htm)\n\n[Ant 实践](http://www.uml.org.cn/j2ee/j2ee091302.htm#content)\n\n另外附上Ant常用命令：\n\n[Overview of Apache Ant Tasks](https://ant.apache.org/manual/tasksoverview.html)\n\n## 实践\n\n下面是自己写的build.xml。存在这里，以后用到可以参考。\n\n下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。\n\n- **build.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n    Oscar XcluseterHibernate Ant build file\n-->\n<project name=\"OSCAR-XCLUSETER-HIBERNATE\" default=\"usage\" basedir=\".\">\n\t<target name=\"build\" depends=\"clean\" />\n\n\t<target name=\"init\" description=\"default init\">\n\t\t<property file=\"build.properties\" />\n\n\t\t<!-- Project Properties -->\n\t\t<property name=\"project\" value=\"oscarXcluseterHibernate3\" />\n\t\t<property name=\"name\" value=\"OSCAR HIBERNATE\" />\n\t\t<tstamp>\n\t\t\t<format property=\"year\" pattern=\"yyyy\" locale=\"zh_CN\" />\n\t\t\t<format property=\"builddate\" pattern=\"yyMMdd\" locale=\"zh_CN\" />\n\t\t</tstamp>\n\t\t<property name=\"version\" value=\"${version.major}.${version.minor}.${version.revision}${version.suffix}\" />\n\t\t<property name=\"version.number\" value=\"${version.major}.${version.minor}.${version.revision}\" />\n\t\t<property name=\"version.major.minor\" value=\"${version.major}.${version.minor}\" />\n\n\t\t<property name=\"final.name\" value=\"${project}\" />\n\t\t<property name=\"vesrion.build\" value=\"build${builddate} ${version.subbuild} ${version.buildID} for ALL \" />\n\n\t\t<!-- Build Defaults -->\n\t\t<property name=\"src.dir\" value=\"${basedir}/src\" />\n\t\t<property name=\"lib.dir\" value=\"${basedir}/lib\" />\n\t\t<property name=\"build.home\" value=\"${basedir}\" />\n\t\t<property name=\"build.src\" value=\"${basedir}/build\" />\n\t\t<property name=\"build.dest\" value=\"${basedir}/antClasses\" />\n\t\t<property name=\"build.release\" value=\"${basedir}/release\" />\n\t\t<property name=\"build.tmp\" value=\"${basedir}/tmp\" />\n\n\t\t<!-- JAR artifacts -->\n\t\t<property name=\"hiberante3.jar\" value=\"${lib.dir}/hibernate3.jar\" />\n\n\t\t<!-- Version info filter set -->\n\t\t<tstamp>\n\t\t\t<format property=\"DSTAMP\" pattern=\"yyyyMMdd\" locale=\"zh_CN\" />\n\t\t\t<format property=\"TSTAMP\" pattern=\"hhmm\" />\n\t\t</tstamp>\n\t\t<filterset id=\"version.filters\">\n\t\t\t<filter token=\"VERSION_NUMBER\" value=\"${version.number}\" />\n\t\t\t<filter token=\"BUNDLE_NAME\" value=\"${vesrion.name}\" />\n\t\t\t<filter token=\"BUNDLE_VERSION\" value=\"${version}${DSTAMP}${TSTAMP}\" />\n\t\t\t<filter token=\"BUILD_VERSION\" value=\"${vesrion.build}\" />\n\t\t</filterset>\n\t\t<path id=\"classpath\">\n\t\t\t<pathelement location=\"${hiberante3.jar}\" />\n\t\t</path>\n\t</target>\n\n\t<target name=\"usage\" depends=\"init\">\n\t\t<echo message=\"${name} Build file\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" available targets are:\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"   package  --> generates oscarXcluseterHibernate file\" />\n\t\t<echo message=\"   build    --> compiles the source code\" />\n\t\t<echo message=\"   clean    --> cleans up the directory\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" See the comments inside the build.xml file for more details.\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"\" />\n\t</target>\n\n\t<!-- Just build -->\n\t<target name=\"compile-prepare\" depends=\"init\" description=\"Prepare for compile\">\n\n\t\t<!-- create directories -->\n\t\t<mkdir dir=\"${build.src}\" />\n\t\t<mkdir dir=\"${build.dest}\" />\n\n\t\t<!-- copy src files -->\n\t\t<copy todir=\"${build.src}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${src.dir}\">\n\t\t\t\t<exclude name=\"**/*.MF\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"compile\" depends=\"compile-prepare\" description=\"compile the project\">\n\n\t\t<!-- Compiles the source directory  -->\n\t\t<javac srcdir=\"${build.src}\" \n\t\t\tdestdir=\"${build.dest}\" \n\t\t\tdebug=\"${build.debug}\" \n\t\t\tdeprecation=\"${build.deprecation}\" \n\t\t\tsource=\"${build.source}\" \n\t\t\ttarget=\"${build.target}\" \n\t\t\tcompiler=\"${build.compiler}\" \n\t\t\toptimize=\"${build.optimize}\" \n\t\t\tincludes=\"**/*.java\" \n\t\t\texcludes=\"**/CVS/**,**/.svn/**\" \n\t\t\tencoding=\"GB18030\"\n\t\t\tincludeantruntime=\"false\"\n\t\t\texecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"\n\t\t\tfork=\"yes\">\n\t\t\t<classpath refid=\"classpath\" />\n\t\t</javac>\n\n\t\t<!-- copy src files exclude java file-->\n\t\t<copy todir=\"${build.dest}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${build.src}\">\n\t\t\t\t<exclude name=\"**/*.java\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"build-manifests\" depends=\"init,compile-prepare\">\n\t\t<!-- Filtering tokens for JAR manifests-->\n\t\t<filter token=\"source.jdk\" value=\"${build.source}\" />\n\t\t<filter token=\"target.jdk\" value=\"${build.target}\" />\n\t\t<mkdir dir=\"${build.tmp}\" />\n\t\t<copy todir=\"${build.tmp}\" overwrite=\"yes\" filtering=\"yes\" encoding=\"GB18030\">\n\t\t\t<filterset refid=\"version.filters\" />\n\t\t\t<fileset dir=\"src/META-INF\" includes=\"MANIFEST.MF\" />\n\t\t</copy>\n\t</target>\n\n\t<target name=\"package\" depends=\"compile,build-manifests\" description=\"create jar file\">\n\t\t<mkdir dir=\"${build.release}\" />\n\t\t<jar jarfile=\"${build.release}/${final.name}.jar\" manifest=\"${build.tmp}/MANIFEST.MF\" basedir=\"${build.dest}\" includes=\"**\" />\n\t</target>\n\n\t<target name=\"clean\" depends=\"package\">\n\t\t<delete dir=\"${build.src}\" />\n\t\t<delete dir=\"${build.dest}\" />\n\t\t<delete dir=\"${build.tmp}\" />\n\t</target>\n</project>\n\n```\n\n- **build.properties**\n\n```java\n\n# -----------------------------------------------------------------------------\n# build.properties\n#\n# This is an example \"build.properties\" file, used to customize building \n# OSCAR-JDBC for your local environment.  It defines the location of all external\n# modules that OSCAR-JDBC depends on.\n# -----------------------------------------------------------------------------\n\n# ----- Version Control Flags -----\nvesrion.name=Main\nversion.major=1\nversion.minor=0\nversion.revision=0\nversion.suffix=x\nversion.subbuild=001\nversion.buildID=00000000\n\nbuild.source=1.5\nbuild.target=1.5\nbuild.debug=false\nbuild.optimize=true\nbuild.compiler=javac1.5\n\n```","slug":"Ant的使用","published":1,"updated":"2016-11-30T14:32:49.901Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj2z0000digcvw4mxujf","content":"<blockquote>\n<p>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和<a href=\"http://ant.apache.org/\" target=\"_blank\" rel=\"external\">Ant</a>打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。</p>\n</blockquote>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><p>Ant是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。</p>\n<p><a href=\"http://www.tutorialspoint.com/ant/index.htm\" target=\"_blank\" rel=\"external\">Ant Tutorial</a></p>\n<p><a href=\"http://www.uml.org.cn/j2ee/j2ee091302.htm#content\" target=\"_blank\" rel=\"external\">Ant 实践</a></p>\n<p>另外附上Ant常用命令：</p>\n<p><a href=\"https://ant.apache.org/manual/tasksoverview.html\" target=\"_blank\" rel=\"external\">Overview of Apache Ant Tasks</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>下面是自己写的build.xml。存在这里，以后用到可以参考。</p>\n<p>下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。</p>\n<ul>\n<li><strong>build.xml</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"comment\">&lt;!--</span></div><div class=\"line\">    Oscar XcluseterHibernate Ant build file</div><div class=\"line\">--&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">name</span>=<span class=\"string\">\"OSCAR-XCLUSETER-HIBERNATE\"</span> <span class=\"attr\">default</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\".\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"clean\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"default init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">file</span>=<span class=\"string\">\"build.properties\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Project Properties --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"project\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"oscarXcluseterHibernate3\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"OSCAR HIBERNATE\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"year\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyy\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"builddate\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;$&#123;version.suffix&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.number\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.major.minor\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"final.name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;project&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"vesrion.build\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"build$&#123;builddate&#125; $&#123;version.subbuild&#125; $&#123;version.buildID&#125; for ALL \"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Build Defaults --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"src.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/src\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lib.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/lib\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.home\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.src\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/build\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.dest\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/antClasses\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.release\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/release\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.tmp\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/tmp\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- JAR artifacts --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hiberante3.jar\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;lib.dir&#125;/hibernate3.jar\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Version info filter set --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"DSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"TSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"hhmm\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">id</span>=<span class=\"string\">\"version.filters\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"VERSION_NUMBER\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.number&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_NAME\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.name&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version&#125;$&#123;DSTAMP&#125;$&#123;TSTAMP&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUILD_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.build&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">filterset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"classpath\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">pathelement</span> <span class=\"attr\">location</span>=<span class=\"string\">\"$&#123;hiberante3.jar&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"$&#123;name&#125; Build file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" available targets are:\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   package  --&gt; generates oscarXcluseterHibernate file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   build    --&gt; compiles the source code\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   clean    --&gt; cleans up the directory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" See the comments inside the build.xml file for more details.\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- Just build --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"Prepare for compile\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- create directories --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;src.dir&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"compile the project\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Compiles the source directory  --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">javac</span> <span class=\"attr\">srcdir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> </span></div><div class=\"line\">\t\t\t<span class=\"attr\">destdir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">debug</span>=<span class=\"string\">\"$&#123;build.debug&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">deprecation</span>=<span class=\"string\">\"$&#123;build.deprecation&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">source</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">target</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">compiler</span>=<span class=\"string\">\"$&#123;build.compiler&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">optimize</span>=<span class=\"string\">\"$&#123;build.optimize&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">includes</span>=<span class=\"string\">\"**/*.java\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">excludes</span>=<span class=\"string\">\"**/CVS/**,**/.svn/**\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">includeantruntime</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">executable</span>=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">fork</span>=<span class=\"string\">\"yes\"</span>&gt;</div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">classpath</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"classpath\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">javac</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files exclude java file--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.java\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build-manifests\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init,compile-prepare\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Filtering tokens for JAR manifests--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"source.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"target.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">filtering</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"version.filters\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"src/META-INF\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"MANIFEST.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"package\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile,build-manifests\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"create jar file\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.release&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">jar</span> <span class=\"attr\">jarfile</span>=<span class=\"string\">\"$&#123;build.release&#125;/$&#123;final.name&#125;.jar\"</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"$&#123;build.tmp&#125;/MANIFEST.MF\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"**\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"clean\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"package\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li><strong>build.properties</strong></li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"># build.properties</div><div class=\"line\">#</div><div class=\"line\"># This is an example \"build.properties\" file, used to customize building </div><div class=\"line\"># OSCAR-JDBC for your local environment.  It defines the location of all external</div><div class=\"line\"># modules that OSCAR-JDBC depends on.</div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\"># ----- Version Control Flags -----</div><div class=\"line\">vesrion.name=Main</div><div class=\"line\">version.major=1</div><div class=\"line\">version.minor=0</div><div class=\"line\">version.revision=0</div><div class=\"line\">version.suffix=x</div><div class=\"line\">version.subbuild=001</div><div class=\"line\">version.buildID=00000000</div><div class=\"line\"></div><div class=\"line\">build.source=1.5</div><div class=\"line\">build.target=1.5</div><div class=\"line\">build.debug=false</div><div class=\"line\">build.optimize=true</div><div class=\"line\">build.compiler=javac1.5</div></pre></td></tr></table></figure>","excerpt":"","more":"<blockquote>\n<p>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和<a href=\"http://ant.apache.org/\">Ant</a>打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。</p>\n</blockquote>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><p>Ant是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。</p>\n<p><a href=\"http://www.tutorialspoint.com/ant/index.htm\">Ant Tutorial</a></p>\n<p><a href=\"http://www.uml.org.cn/j2ee/j2ee091302.htm#content\">Ant 实践</a></p>\n<p>另外附上Ant常用命令：</p>\n<p><a href=\"https://ant.apache.org/manual/tasksoverview.html\">Overview of Apache Ant Tasks</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>下面是自己写的build.xml。存在这里，以后用到可以参考。</p>\n<p>下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。</p>\n<ul>\n<li><strong>build.xml</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"comment\">&lt;!--</div><div class=\"line\">    Oscar XcluseterHibernate Ant build file</div><div class=\"line\">--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">name</span>=<span class=\"string\">\"OSCAR-XCLUSETER-HIBERNATE\"</span> <span class=\"attr\">default</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\".\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"clean\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"default init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">file</span>=<span class=\"string\">\"build.properties\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Project Properties --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"project\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"oscarXcluseterHibernate3\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"OSCAR HIBERNATE\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"year\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyy\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"builddate\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;$&#123;version.suffix&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.number\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.major.minor\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"final.name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;project&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"vesrion.build\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"build$&#123;builddate&#125; $&#123;version.subbuild&#125; $&#123;version.buildID&#125; for ALL \"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Build Defaults --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"src.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/src\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lib.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/lib\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.home\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.src\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/build\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.dest\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/antClasses\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.release\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/release\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.tmp\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/tmp\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- JAR artifacts --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hiberante3.jar\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;lib.dir&#125;/hibernate3.jar\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Version info filter set --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"DSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"TSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"hhmm\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">id</span>=<span class=\"string\">\"version.filters\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"VERSION_NUMBER\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.number&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_NAME\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.name&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version&#125;$&#123;DSTAMP&#125;$&#123;TSTAMP&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUILD_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.build&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">filterset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"classpath\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">pathelement</span> <span class=\"attr\">location</span>=<span class=\"string\">\"$&#123;hiberante3.jar&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"$&#123;name&#125; Build file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" available targets are:\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   package  --&gt; generates oscarXcluseterHibernate file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   build    --&gt; compiles the source code\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   clean    --&gt; cleans up the directory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" See the comments inside the build.xml file for more details.\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- Just build --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"Prepare for compile\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- create directories --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;src.dir&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"compile the project\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Compiles the source directory  --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">javac</span> <span class=\"attr\">srcdir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">destdir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">debug</span>=<span class=\"string\">\"$&#123;build.debug&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">deprecation</span>=<span class=\"string\">\"$&#123;build.deprecation&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">source</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">target</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">compiler</span>=<span class=\"string\">\"$&#123;build.compiler&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">optimize</span>=<span class=\"string\">\"$&#123;build.optimize&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">includes</span>=<span class=\"string\">\"**/*.java\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">excludes</span>=<span class=\"string\">\"**/CVS/**,**/.svn/**\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">includeantruntime</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">executable</span>=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">fork</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">classpath</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"classpath\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">javac</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files exclude java file--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.java\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build-manifests\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init,compile-prepare\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Filtering tokens for JAR manifests--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"source.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"target.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">filtering</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"version.filters\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"src/META-INF\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"MANIFEST.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"package\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile,build-manifests\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"create jar file\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.release&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">jar</span> <span class=\"attr\">jarfile</span>=<span class=\"string\">\"$&#123;build.release&#125;/$&#123;final.name&#125;.jar\"</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"$&#123;build.tmp&#125;/MANIFEST.MF\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"**\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"clean\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"package\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li><strong>build.properties</strong></li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"># build.properties</div><div class=\"line\">#</div><div class=\"line\"># This is an example \"build.properties\" file, used to customize building </div><div class=\"line\"># OSCAR-JDBC for your local environment.  It defines the location of all external</div><div class=\"line\"># modules that OSCAR-JDBC depends on.</div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\"># ----- Version Control Flags -----</div><div class=\"line\">vesrion.name=Main</div><div class=\"line\">version.major=1</div><div class=\"line\">version.minor=0</div><div class=\"line\">version.revision=0</div><div class=\"line\">version.suffix=x</div><div class=\"line\">version.subbuild=001</div><div class=\"line\">version.buildID=00000000</div><div class=\"line\"></div><div class=\"line\">build.source=1.5</div><div class=\"line\">build.target=1.5</div><div class=\"line\">build.debug=false</div><div class=\"line\">build.optimize=true</div><div class=\"line\">build.compiler=javac1.5</div></pre></td></tr></table></figure>"},{"layout":"post","title":"Eclipse乱码问题终极解决方案","date":"2016-09-20T13:57:08.000Z","_content":"\n今天在Eclipse中导入一个新项目的时候，出现了乱码问题。研究一番...\n\n显示乱码的根本原因在于：**文件本身的编码和编辑器打开和编辑文件使用的编码不一致**。当编辑器以不同于文件的编码去解码该文件的时候，就会导致读出来乱码。大部分情况下英文显示正常是因为大部分编码都兼容ASCII，中文则会显示乱码。\n\n## 编辑器显示乱码问题\n\n在Eclipse中，设置编辑器显示和编辑文件所采用编码的方法有四种：\n\n1.Windows->Preference->General->Workspace ：修改整个工作空间\n\n{% asset_img 1.png 全局修改 %}\n\n2.右键Project->Properties->Resource ：修改某个工程\n\n{% asset_img 2.png 工程修改 %}\n\n3.右键文件->Properties ：修改某个文件\n\n{% asset_img 3.png 文件修改 %}\n\n4.Windows->Preference->General->Content types->Default encoding :全局修改某种类型的文件\n\n{% asset_img 4.png 全局文件修改 %}\n\n其中，3的优先级最高。也就是说某个文件被编辑器以哪种编码读取最终是由3中的Text file encoding决定的。一般情况下，如果我们不在3中显示指定编码(选择Other那一项)，Eclipse都会默认使用Default那一项的编码。那么，这个Default的编码又是如何决定的呢？\n\n{% asset_img 5.png 文件修改 %}\n\n注意上图中圈起来的部分：这部分表示了Default采用哪种编码是如何决定的。\n\n可能会出现三种情况：\n\n1.determined from content: xxx \n\n2.determined from content type: xxx\n\n3.inherit from container \n\n其中：\n\n1表示文件内容本身指定了编码，比如下图。\n\n{% asset_img 6.png 文件修改 %}\n\nEncoding Bit Order Mark，简写为BOM，表明文件本身指定了采用哪种编码方式。编辑器会优先采用这种编码。\n\n2表示采用了针对该文件类型的全局修改，也就是上面提到的第4种设置方式。\n\n3表示继承了上一级指定的编码，这个继承关系就是我们在上面提到的：修改某个文件->修改文件所属的工程->修改整个工作空间。->表示继承于。\n\n上面这3种情况的优先级：1>2>3 。也就是说如果文件本身表明了编码方式，Eclipse优先采用这种编码解码文件。若没有指定，Eclipse会查看该文件类型是否在上面的第4种方式设置中指定了编码，如有则采用该编码。如没有指定，则从下往上搜索继承关系链中指定的编码。（继承关系链：文件->工程->工作空间）\n\n通过上面的分析明白了Eclipse 编辑器选择显示文件所采用编码的原理，相信再次遇到编辑器中的乱码问题都可以找到合适的解决方案。上面的分析不仅仅适用于java文件，同样适用于xml等其他类型文件的乱码问题。\n\n另外一定要注意：**如果通过上面4中方式的某一种修改影响了某个文件的编码，则当你再次编辑完保存该文件时，则采用此时该文件在Eclipse中指定的编码方式保存到本地。**\n\n以上的对乱码问题的分析都是基于通过修改Eclipse编辑器显示文件内容采用的编码，使其与文件本身的编码一致的方式来解决的。还有另一种思路是反过来，修改文件编码与Eclipse显示文件内容所采用的编码一致来解决乱码问题。可以使用文件编码批量转换工具进行批量转换，比如UltraCodingSwitch等。\n\n## Console显示乱码问题\n\n右键要运行的类->Run As->Run Configuratios\n\n{% asset_img 6.png Console编码 %}\n\n可修改上图中Other中的编码来指定显示打印内容的编码。\n\n## 总结\n\n通过以上分析知道了如何在Eclipse中解决乱码的问题。其实文章一开始就说了，显示乱码的根本原因在于：**文件本身的编码和编辑器打开文件使用的编码不一致**。明白了这一点，就算在其他编辑器或编译器中或者任何能够显示文本内容的遇到乱码的情况都能够找到问题的根源，从而解决乱码问题。\n\n至于文件本身的编码，可以通过一定的手段去改变。如通过记事本等工具修改编码后另存为等方式。\n\nJava中输出一段内容到文件可以通过指定流的编码来指定输出字符的编码。\n\n以上","source":"_posts/Eclipse编码问题终极解决方案.md","raw":"---\nlayout: post\ntitle: Eclipse乱码问题终极解决方案\ndate: 2016-09-20 21:57:08\ncategories: 工具\ntags: \n- Eclipse\n---\n\n今天在Eclipse中导入一个新项目的时候，出现了乱码问题。研究一番...\n\n显示乱码的根本原因在于：**文件本身的编码和编辑器打开和编辑文件使用的编码不一致**。当编辑器以不同于文件的编码去解码该文件的时候，就会导致读出来乱码。大部分情况下英文显示正常是因为大部分编码都兼容ASCII，中文则会显示乱码。\n\n## 编辑器显示乱码问题\n\n在Eclipse中，设置编辑器显示和编辑文件所采用编码的方法有四种：\n\n1.Windows->Preference->General->Workspace ：修改整个工作空间\n\n{% asset_img 1.png 全局修改 %}\n\n2.右键Project->Properties->Resource ：修改某个工程\n\n{% asset_img 2.png 工程修改 %}\n\n3.右键文件->Properties ：修改某个文件\n\n{% asset_img 3.png 文件修改 %}\n\n4.Windows->Preference->General->Content types->Default encoding :全局修改某种类型的文件\n\n{% asset_img 4.png 全局文件修改 %}\n\n其中，3的优先级最高。也就是说某个文件被编辑器以哪种编码读取最终是由3中的Text file encoding决定的。一般情况下，如果我们不在3中显示指定编码(选择Other那一项)，Eclipse都会默认使用Default那一项的编码。那么，这个Default的编码又是如何决定的呢？\n\n{% asset_img 5.png 文件修改 %}\n\n注意上图中圈起来的部分：这部分表示了Default采用哪种编码是如何决定的。\n\n可能会出现三种情况：\n\n1.determined from content: xxx \n\n2.determined from content type: xxx\n\n3.inherit from container \n\n其中：\n\n1表示文件内容本身指定了编码，比如下图。\n\n{% asset_img 6.png 文件修改 %}\n\nEncoding Bit Order Mark，简写为BOM，表明文件本身指定了采用哪种编码方式。编辑器会优先采用这种编码。\n\n2表示采用了针对该文件类型的全局修改，也就是上面提到的第4种设置方式。\n\n3表示继承了上一级指定的编码，这个继承关系就是我们在上面提到的：修改某个文件->修改文件所属的工程->修改整个工作空间。->表示继承于。\n\n上面这3种情况的优先级：1>2>3 。也就是说如果文件本身表明了编码方式，Eclipse优先采用这种编码解码文件。若没有指定，Eclipse会查看该文件类型是否在上面的第4种方式设置中指定了编码，如有则采用该编码。如没有指定，则从下往上搜索继承关系链中指定的编码。（继承关系链：文件->工程->工作空间）\n\n通过上面的分析明白了Eclipse 编辑器选择显示文件所采用编码的原理，相信再次遇到编辑器中的乱码问题都可以找到合适的解决方案。上面的分析不仅仅适用于java文件，同样适用于xml等其他类型文件的乱码问题。\n\n另外一定要注意：**如果通过上面4中方式的某一种修改影响了某个文件的编码，则当你再次编辑完保存该文件时，则采用此时该文件在Eclipse中指定的编码方式保存到本地。**\n\n以上的对乱码问题的分析都是基于通过修改Eclipse编辑器显示文件内容采用的编码，使其与文件本身的编码一致的方式来解决的。还有另一种思路是反过来，修改文件编码与Eclipse显示文件内容所采用的编码一致来解决乱码问题。可以使用文件编码批量转换工具进行批量转换，比如UltraCodingSwitch等。\n\n## Console显示乱码问题\n\n右键要运行的类->Run As->Run Configuratios\n\n{% asset_img 6.png Console编码 %}\n\n可修改上图中Other中的编码来指定显示打印内容的编码。\n\n## 总结\n\n通过以上分析知道了如何在Eclipse中解决乱码的问题。其实文章一开始就说了，显示乱码的根本原因在于：**文件本身的编码和编辑器打开文件使用的编码不一致**。明白了这一点，就算在其他编辑器或编译器中或者任何能够显示文本内容的遇到乱码的情况都能够找到问题的根源，从而解决乱码问题。\n\n至于文件本身的编码，可以通过一定的手段去改变。如通过记事本等工具修改编码后另存为等方式。\n\nJava中输出一段内容到文件可以通过指定流的编码来指定输出字符的编码。\n\n以上","slug":"Eclipse编码问题终极解决方案","published":1,"updated":"2016-11-30T14:32:49.901Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj3a0002digc269r50s4","content":"<p>今天在Eclipse中导入一个新项目的时候，出现了乱码问题。研究一番…</p>\n<p>显示乱码的根本原因在于：<strong>文件本身的编码和编辑器打开和编辑文件使用的编码不一致</strong>。当编辑器以不同于文件的编码去解码该文件的时候，就会导致读出来乱码。大部分情况下英文显示正常是因为大部分编码都兼容ASCII，中文则会显示乱码。</p>\n<h2 id=\"编辑器显示乱码问题\"><a href=\"#编辑器显示乱码问题\" class=\"headerlink\" title=\"编辑器显示乱码问题\"></a>编辑器显示乱码问题</h2><p>在Eclipse中，设置编辑器显示和编辑文件所采用编码的方法有四种：</p>\n<p>1.Windows-&gt;Preference-&gt;General-&gt;Workspace ：修改整个工作空间</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/1.png\" alt=\"全局修改\" title=\"全局修改\">\n<p>2.右键Project-&gt;Properties-&gt;Resource ：修改某个工程</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/2.png\" alt=\"工程修改\" title=\"工程修改\">\n<p>3.右键文件-&gt;Properties ：修改某个文件</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/3.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>4.Windows-&gt;Preference-&gt;General-&gt;Content types-&gt;Default encoding :全局修改某种类型的文件</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/4.png\" alt=\"全局文件修改\" title=\"全局文件修改\">\n<p>其中，3的优先级最高。也就是说某个文件被编辑器以哪种编码读取最终是由3中的Text file encoding决定的。一般情况下，如果我们不在3中显示指定编码(选择Other那一项)，Eclipse都会默认使用Default那一项的编码。那么，这个Default的编码又是如何决定的呢？</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/5.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>注意上图中圈起来的部分：这部分表示了Default采用哪种编码是如何决定的。</p>\n<p>可能会出现三种情况：</p>\n<p>1.determined from content: xxx </p>\n<p>2.determined from content type: xxx</p>\n<p>3.inherit from container </p>\n<p>其中：</p>\n<p>1表示文件内容本身指定了编码，比如下图。</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/6.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>Encoding Bit Order Mark，简写为BOM，表明文件本身指定了采用哪种编码方式。编辑器会优先采用这种编码。</p>\n<p>2表示采用了针对该文件类型的全局修改，也就是上面提到的第4种设置方式。</p>\n<p>3表示继承了上一级指定的编码，这个继承关系就是我们在上面提到的：修改某个文件-&gt;修改文件所属的工程-&gt;修改整个工作空间。-&gt;表示继承于。</p>\n<p>上面这3种情况的优先级：1&gt;2&gt;3 。也就是说如果文件本身表明了编码方式，Eclipse优先采用这种编码解码文件。若没有指定，Eclipse会查看该文件类型是否在上面的第4种方式设置中指定了编码，如有则采用该编码。如没有指定，则从下往上搜索继承关系链中指定的编码。（继承关系链：文件-&gt;工程-&gt;工作空间）</p>\n<p>通过上面的分析明白了Eclipse 编辑器选择显示文件所采用编码的原理，相信再次遇到编辑器中的乱码问题都可以找到合适的解决方案。上面的分析不仅仅适用于java文件，同样适用于xml等其他类型文件的乱码问题。</p>\n<p>另外一定要注意：<strong>如果通过上面4中方式的某一种修改影响了某个文件的编码，则当你再次编辑完保存该文件时，则采用此时该文件在Eclipse中指定的编码方式保存到本地。</strong></p>\n<p>以上的对乱码问题的分析都是基于通过修改Eclipse编辑器显示文件内容采用的编码，使其与文件本身的编码一致的方式来解决的。还有另一种思路是反过来，修改文件编码与Eclipse显示文件内容所采用的编码一致来解决乱码问题。可以使用文件编码批量转换工具进行批量转换，比如UltraCodingSwitch等。</p>\n<h2 id=\"Console显示乱码问题\"><a href=\"#Console显示乱码问题\" class=\"headerlink\" title=\"Console显示乱码问题\"></a>Console显示乱码问题</h2><p>右键要运行的类-&gt;Run As-&gt;Run Configuratios</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/6.png\" alt=\"Console编码\" title=\"Console编码\">\n<p>可修改上图中Other中的编码来指定显示打印内容的编码。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过以上分析知道了如何在Eclipse中解决乱码的问题。其实文章一开始就说了，显示乱码的根本原因在于：<strong>文件本身的编码和编辑器打开文件使用的编码不一致</strong>。明白了这一点，就算在其他编辑器或编译器中或者任何能够显示文本内容的遇到乱码的情况都能够找到问题的根源，从而解决乱码问题。</p>\n<p>至于文件本身的编码，可以通过一定的手段去改变。如通过记事本等工具修改编码后另存为等方式。</p>\n<p>Java中输出一段内容到文件可以通过指定流的编码来指定输出字符的编码。</p>\n<p>以上</p>\n","excerpt":"","more":"<p>今天在Eclipse中导入一个新项目的时候，出现了乱码问题。研究一番…</p>\n<p>显示乱码的根本原因在于：<strong>文件本身的编码和编辑器打开和编辑文件使用的编码不一致</strong>。当编辑器以不同于文件的编码去解码该文件的时候，就会导致读出来乱码。大部分情况下英文显示正常是因为大部分编码都兼容ASCII，中文则会显示乱码。</p>\n<h2 id=\"编辑器显示乱码问题\"><a href=\"#编辑器显示乱码问题\" class=\"headerlink\" title=\"编辑器显示乱码问题\"></a>编辑器显示乱码问题</h2><p>在Eclipse中，设置编辑器显示和编辑文件所采用编码的方法有四种：</p>\n<p>1.Windows-&gt;Preference-&gt;General-&gt;Workspace ：修改整个工作空间</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/1.png\" alt=\"全局修改\" title=\"全局修改\">\n<p>2.右键Project-&gt;Properties-&gt;Resource ：修改某个工程</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/2.png\" alt=\"工程修改\" title=\"工程修改\">\n<p>3.右键文件-&gt;Properties ：修改某个文件</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/3.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>4.Windows-&gt;Preference-&gt;General-&gt;Content types-&gt;Default encoding :全局修改某种类型的文件</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/4.png\" alt=\"全局文件修改\" title=\"全局文件修改\">\n<p>其中，3的优先级最高。也就是说某个文件被编辑器以哪种编码读取最终是由3中的Text file encoding决定的。一般情况下，如果我们不在3中显示指定编码(选择Other那一项)，Eclipse都会默认使用Default那一项的编码。那么，这个Default的编码又是如何决定的呢？</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/5.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>注意上图中圈起来的部分：这部分表示了Default采用哪种编码是如何决定的。</p>\n<p>可能会出现三种情况：</p>\n<p>1.determined from content: xxx </p>\n<p>2.determined from content type: xxx</p>\n<p>3.inherit from container </p>\n<p>其中：</p>\n<p>1表示文件内容本身指定了编码，比如下图。</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/6.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>Encoding Bit Order Mark，简写为BOM，表明文件本身指定了采用哪种编码方式。编辑器会优先采用这种编码。</p>\n<p>2表示采用了针对该文件类型的全局修改，也就是上面提到的第4种设置方式。</p>\n<p>3表示继承了上一级指定的编码，这个继承关系就是我们在上面提到的：修改某个文件-&gt;修改文件所属的工程-&gt;修改整个工作空间。-&gt;表示继承于。</p>\n<p>上面这3种情况的优先级：1&gt;2&gt;3 。也就是说如果文件本身表明了编码方式，Eclipse优先采用这种编码解码文件。若没有指定，Eclipse会查看该文件类型是否在上面的第4种方式设置中指定了编码，如有则采用该编码。如没有指定，则从下往上搜索继承关系链中指定的编码。（继承关系链：文件-&gt;工程-&gt;工作空间）</p>\n<p>通过上面的分析明白了Eclipse 编辑器选择显示文件所采用编码的原理，相信再次遇到编辑器中的乱码问题都可以找到合适的解决方案。上面的分析不仅仅适用于java文件，同样适用于xml等其他类型文件的乱码问题。</p>\n<p>另外一定要注意：<strong>如果通过上面4中方式的某一种修改影响了某个文件的编码，则当你再次编辑完保存该文件时，则采用此时该文件在Eclipse中指定的编码方式保存到本地。</strong></p>\n<p>以上的对乱码问题的分析都是基于通过修改Eclipse编辑器显示文件内容采用的编码，使其与文件本身的编码一致的方式来解决的。还有另一种思路是反过来，修改文件编码与Eclipse显示文件内容所采用的编码一致来解决乱码问题。可以使用文件编码批量转换工具进行批量转换，比如UltraCodingSwitch等。</p>\n<h2 id=\"Console显示乱码问题\"><a href=\"#Console显示乱码问题\" class=\"headerlink\" title=\"Console显示乱码问题\"></a>Console显示乱码问题</h2><p>右键要运行的类-&gt;Run As-&gt;Run Configuratios</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/6.png\" alt=\"Console编码\" title=\"Console编码\">\n<p>可修改上图中Other中的编码来指定显示打印内容的编码。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过以上分析知道了如何在Eclipse中解决乱码的问题。其实文章一开始就说了，显示乱码的根本原因在于：<strong>文件本身的编码和编辑器打开文件使用的编码不一致</strong>。明白了这一点，就算在其他编辑器或编译器中或者任何能够显示文本内容的遇到乱码的情况都能够找到问题的根源，从而解决乱码问题。</p>\n<p>至于文件本身的编码，可以通过一定的手段去改变。如通过记事本等工具修改编码后另存为等方式。</p>\n<p>Java中输出一段内容到文件可以通过指定流的编码来指定输出字符的编码。</p>\n<p>以上</p>\n"},{"layout":"post","title":"Java集合框架学习总结","date":"2016-08-16T14:50:16.000Z","_content":"\n看Jdk的源码有大概一个月时间了，中间零零散散算是把[Java的集合](https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html)看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：[Java IO](https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description)\n\n## 框架\n\n{% asset_img collection.png 集合框架 %}\n\n上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。\n\n通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。\n\n## List\n\n### Iterator\n\n在总结List之前，先看一下Iterable这个接口,它只包含一个方法:\n\n```java\nIterator<T> iterator();\n```\n\n这个方法返回一个[Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。\n\n### [Collection](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)\n\nCollection 提供了集合的一些基本操作,Collection 接口提供的主要方法：\n\n```\nboolean add(Object o) 添加对象到集合；\nboolean remove(Object o) 删除指定的对象；\nint size() 返回当前集合中元素的数量；\nboolean contains(Object o) 查找集合中是否有指定的对象；\nboolean isEmpty() 判断集合是否为空；\nIterator iterator() 返回一个迭代器；\nboolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；\nboolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；\nvoid clear() 删除集合中所有元素；\nvoid removeAll(Collection c) 从集合中删除 C 集合中也有的元素；\nvoid retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。\n```\n没发现有什么好说的。\n\n### [List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)\n\nList\n\n\n\n","source":"_posts/Java集合框架学习总结.md","raw":"layout: post\ntitle: Java集合框架学习总结\ndate: 2016-08-16 22:50:16\ncategories: 编程 \ntags: \n- java\n- 源码\n---\n\n看Jdk的源码有大概一个月时间了，中间零零散散算是把[Java的集合](https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html)看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：[Java IO](https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description)\n\n## 框架\n\n{% asset_img collection.png 集合框架 %}\n\n上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。\n\n通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。\n\n## List\n\n### Iterator\n\n在总结List之前，先看一下Iterable这个接口,它只包含一个方法:\n\n```java\nIterator<T> iterator();\n```\n\n这个方法返回一个[Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。\n\n### [Collection](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)\n\nCollection 提供了集合的一些基本操作,Collection 接口提供的主要方法：\n\n```\nboolean add(Object o) 添加对象到集合；\nboolean remove(Object o) 删除指定的对象；\nint size() 返回当前集合中元素的数量；\nboolean contains(Object o) 查找集合中是否有指定的对象；\nboolean isEmpty() 判断集合是否为空；\nIterator iterator() 返回一个迭代器；\nboolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；\nboolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；\nvoid clear() 删除集合中所有元素；\nvoid removeAll(Collection c) 从集合中删除 C 集合中也有的元素；\nvoid retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。\n```\n没发现有什么好说的。\n\n### [List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)\n\nList\n\n\n\n","slug":"Java集合框架学习总结","published":1,"updated":"2016-11-30T14:32:49.905Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj3j0005digcz3cp0ws2","content":"<p>看Jdk的源码有大概一个月时间了，中间零零散散算是把<a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html\" target=\"_blank\" rel=\"external\">Java的集合</a>看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description\" target=\"_blank\" rel=\"external\">Java IO</a></p>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><img src=\"/2016/08/16/Java集合框架学习总结/collection.png\" alt=\"集合框架\" title=\"集合框架\">\n<p>上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。</p>\n<p>通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。</p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h3><p>在总结List之前，先看一下Iterable这个接口,它只包含一个方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Iterator&lt;T&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</div></pre></td></tr></table></figure>\n<p>这个方法返回一个<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\" target=\"_blank\" rel=\"external\">Iterator</a>，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。</p>\n<h3 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html\" target=\"_blank\" rel=\"external\">Collection</a></h3><p>Collection 提供了集合的一些基本操作,Collection 接口提供的主要方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean add(Object o) 添加对象到集合；</div><div class=\"line\">boolean remove(Object o) 删除指定的对象；</div><div class=\"line\">int size() 返回当前集合中元素的数量；</div><div class=\"line\">boolean contains(Object o) 查找集合中是否有指定的对象；</div><div class=\"line\">boolean isEmpty() 判断集合是否为空；</div><div class=\"line\">Iterator iterator() 返回一个迭代器；</div><div class=\"line\">boolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；</div><div class=\"line\">boolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；</div><div class=\"line\">void clear() 删除集合中所有元素；</div><div class=\"line\">void removeAll(Collection c) 从集合中删除 C 集合中也有的元素；</div><div class=\"line\">void retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。</div></pre></td></tr></table></figure>\n<p>没发现有什么好说的。</p>\n<h3 id=\"List-1\"><a href=\"#List-1\" class=\"headerlink\" title=\"List\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/List.html\" target=\"_blank\" rel=\"external\">List</a></h3><p>List</p>\n","excerpt":"","more":"<p>看Jdk的源码有大概一个月时间了，中间零零散散算是把<a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html\">Java的集合</a>看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description\">Java IO</a></p>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><img src=\"/2016/08/16/Java集合框架学习总结/collection.png\" alt=\"集合框架\" title=\"集合框架\">\n<p>上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。</p>\n<p>通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。</p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h3><p>在总结List之前，先看一下Iterable这个接口,它只包含一个方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Iterator&lt;T&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</div></pre></td></tr></table></figure>\n<p>这个方法返回一个<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\">Iterator</a>，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。</p>\n<h3 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html\">Collection</a></h3><p>Collection 提供了集合的一些基本操作,Collection 接口提供的主要方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean add(Object o) 添加对象到集合；</div><div class=\"line\">boolean remove(Object o) 删除指定的对象；</div><div class=\"line\">int size() 返回当前集合中元素的数量；</div><div class=\"line\">boolean contains(Object o) 查找集合中是否有指定的对象；</div><div class=\"line\">boolean isEmpty() 判断集合是否为空；</div><div class=\"line\">Iterator iterator() 返回一个迭代器；</div><div class=\"line\">boolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；</div><div class=\"line\">boolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；</div><div class=\"line\">void clear() 删除集合中所有元素；</div><div class=\"line\">void removeAll(Collection c) 从集合中删除 C 集合中也有的元素；</div><div class=\"line\">void retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。</div></pre></td></tr></table></figure>\n<p>没发现有什么好说的。</p>\n<h3 id=\"List-1\"><a href=\"#List-1\" class=\"headerlink\" title=\"List\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/List.html\">List</a></h3><p>List</p>\n"},{"layout":"post","title":"记一次苦逼经历--关于spring项目打包为jar运行","date":"2016-09-19T13:41:48.000Z","_content":"\n上周二刚从外包那里接手了一个的项目，主要是实现了一个web服务器，客户端可以以http请求的方式通过该服务器获取一些数据库的信息，技术上主要是使用了SpringBoot和REST API。周三就来新的需求了，实现一个接口，大概看了下代码，感觉soeasy(虽然之前从没有接触过springboot和spring，说来惭愧。不过这也说明了使用框架的好处，可以快速上手)。\n\n中秋假期结束之后把这个接口弄完了。Eclipse里面跑起来完全没有问题。自信心爆棚。该服务器要求以jar包的方式运行，那就打个包吧。结果苦逼的经历开始了。\n\n由于项目没有使用任何工具构建，没有maven，也没有Gradle。想着就凑合着用Eclipse里面自带的export导出jar包的功能吧。于是:右键工程，选择export。然后java->JAR file\n\n{% asset_img 1.png export %}\n\njar包打好了。把依赖什么的都放到jar所在的同一个目录，紧接着使用 java -cp interfaceService.jar;lib/* com.XXX.Application  执行。\n\n服务器跑起来了。nice\n\n浏览器输入URL，回车，出现了这样的画面：\n\n{% asset_img 2.png 404 %}\n\nwhat? 404?赶紧看看服务器打印的日志，发现dispatcherServlet初始化完之后就没有其他动作了，也没有报错信息。跟在eclipse中正常执行的情况对比了一下，eclipse在打印完这几句Log之后就开始进入controller方法了。\n\n{% asset_img 3.png log %}\n\n初步怀疑是找不到对应的controller。\n\n输入关键字：springboot jar 和404页面的提示，谷歌之。\n\n找出来一堆答案，基本都是说没有正确添加注解那一类的意思。回头看看代码，该加注解的地方都加了。而且eclipse里跑着没问题啊，说明不是注解的问题。\n\n感觉应该是打包的问题。把没用的.classpath等文件都排除，重新打包。再次执行，结果一样。\n\n把lib和properties文件都打到包里，执行，还是没用。\n\n{% asset_img 4.png export %}\n\n然后，上图这几个勾选框吸引了我的目光，查了一下这几个框勾选之后的作用，感觉跟这个关系不大，但是也都选上试了一下，失败。\n\n接着又以各种姿势谷歌了一遍，毫无结果。此刻心情比较郁闷，上网刷会微博吧，有点晕...\n\n接下来重新振作精神，再打一次包。\n\n抱着随便试试的心情，把下面的的框也选上了。\n\n{% asset_img 5.png export %}\n\n结果，这次竟然成功了！服务器返回了正确的结果。激动...原来就因为Add Directory Entries这个单选框没勾选就浪费了我两个多小时！\n\n然后各种姿势测了一下，没问题了。\n\nAdd Directory Entries谷歌之。神了，出现了很多与我这个情况一样的描述和解决办法。看来还是有人掉过坑啊！\n\n浏览了一下大家的分析，结果就是：**当使用export方式打jar包来运行spring项目时，一定要记得把Add Directory Entries这个单选框勾选上！否则会扫描不到指定的controller**\n\n原因也很简单：当勾选Add Directory Entries这个选项时，生成的jar会添加文件夹信息。spring就可以扫描到相关的包信息。具体的解释看这篇文章：[spring 扫描包不起作用](http://www.voidcn.com/blog/wangjun5159/article/p-6159159.html)\n\n其实这次遇到的问题也不算是技术上的问题，但前前后后也花了将近三个小时才解决。有三点认识：\n\n1.搜索技巧很重要，如果早一点能用spring、扫描包等关键字去搜索的话，问题早已经解决了。\n\n2.打包尽量用构建工具，避免重复劳动还不易出错。Gradle使用学习中...\n\n3.应该从问题的根源上想才会得到解决方法。比如，如果知道了spring获取controller的实现方式，或许能更快解决这个问题。(spring真的是一点都不懂，需要学习)\n\n以上\n\n\n\n","source":"_posts/Spring项目打包为jar.md","raw":"layout: post\ntitle: 记一次苦逼经历--关于spring项目打包为jar运行\ndate: 2016-09-19 21:41:48\ncategories: 技术\ntags: \n- 服务器\n- spring\n---\n\n上周二刚从外包那里接手了一个的项目，主要是实现了一个web服务器，客户端可以以http请求的方式通过该服务器获取一些数据库的信息，技术上主要是使用了SpringBoot和REST API。周三就来新的需求了，实现一个接口，大概看了下代码，感觉soeasy(虽然之前从没有接触过springboot和spring，说来惭愧。不过这也说明了使用框架的好处，可以快速上手)。\n\n中秋假期结束之后把这个接口弄完了。Eclipse里面跑起来完全没有问题。自信心爆棚。该服务器要求以jar包的方式运行，那就打个包吧。结果苦逼的经历开始了。\n\n由于项目没有使用任何工具构建，没有maven，也没有Gradle。想着就凑合着用Eclipse里面自带的export导出jar包的功能吧。于是:右键工程，选择export。然后java->JAR file\n\n{% asset_img 1.png export %}\n\njar包打好了。把依赖什么的都放到jar所在的同一个目录，紧接着使用 java -cp interfaceService.jar;lib/* com.XXX.Application  执行。\n\n服务器跑起来了。nice\n\n浏览器输入URL，回车，出现了这样的画面：\n\n{% asset_img 2.png 404 %}\n\nwhat? 404?赶紧看看服务器打印的日志，发现dispatcherServlet初始化完之后就没有其他动作了，也没有报错信息。跟在eclipse中正常执行的情况对比了一下，eclipse在打印完这几句Log之后就开始进入controller方法了。\n\n{% asset_img 3.png log %}\n\n初步怀疑是找不到对应的controller。\n\n输入关键字：springboot jar 和404页面的提示，谷歌之。\n\n找出来一堆答案，基本都是说没有正确添加注解那一类的意思。回头看看代码，该加注解的地方都加了。而且eclipse里跑着没问题啊，说明不是注解的问题。\n\n感觉应该是打包的问题。把没用的.classpath等文件都排除，重新打包。再次执行，结果一样。\n\n把lib和properties文件都打到包里，执行，还是没用。\n\n{% asset_img 4.png export %}\n\n然后，上图这几个勾选框吸引了我的目光，查了一下这几个框勾选之后的作用，感觉跟这个关系不大，但是也都选上试了一下，失败。\n\n接着又以各种姿势谷歌了一遍，毫无结果。此刻心情比较郁闷，上网刷会微博吧，有点晕...\n\n接下来重新振作精神，再打一次包。\n\n抱着随便试试的心情，把下面的的框也选上了。\n\n{% asset_img 5.png export %}\n\n结果，这次竟然成功了！服务器返回了正确的结果。激动...原来就因为Add Directory Entries这个单选框没勾选就浪费了我两个多小时！\n\n然后各种姿势测了一下，没问题了。\n\nAdd Directory Entries谷歌之。神了，出现了很多与我这个情况一样的描述和解决办法。看来还是有人掉过坑啊！\n\n浏览了一下大家的分析，结果就是：**当使用export方式打jar包来运行spring项目时，一定要记得把Add Directory Entries这个单选框勾选上！否则会扫描不到指定的controller**\n\n原因也很简单：当勾选Add Directory Entries这个选项时，生成的jar会添加文件夹信息。spring就可以扫描到相关的包信息。具体的解释看这篇文章：[spring 扫描包不起作用](http://www.voidcn.com/blog/wangjun5159/article/p-6159159.html)\n\n其实这次遇到的问题也不算是技术上的问题，但前前后后也花了将近三个小时才解决。有三点认识：\n\n1.搜索技巧很重要，如果早一点能用spring、扫描包等关键字去搜索的话，问题早已经解决了。\n\n2.打包尽量用构建工具，避免重复劳动还不易出错。Gradle使用学习中...\n\n3.应该从问题的根源上想才会得到解决方法。比如，如果知道了spring获取controller的实现方式，或许能更快解决这个问题。(spring真的是一点都不懂，需要学习)\n\n以上\n\n\n\n","slug":"Spring项目打包为jar","published":1,"updated":"2016-11-30T14:32:49.905Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj3n0006digc4veqaa4s","content":"<p>上周二刚从外包那里接手了一个的项目，主要是实现了一个web服务器，客户端可以以http请求的方式通过该服务器获取一些数据库的信息，技术上主要是使用了SpringBoot和REST API。周三就来新的需求了，实现一个接口，大概看了下代码，感觉soeasy(虽然之前从没有接触过springboot和spring，说来惭愧。不过这也说明了使用框架的好处，可以快速上手)。</p>\n<p>中秋假期结束之后把这个接口弄完了。Eclipse里面跑起来完全没有问题。自信心爆棚。该服务器要求以jar包的方式运行，那就打个包吧。结果苦逼的经历开始了。</p>\n<p>由于项目没有使用任何工具构建，没有maven，也没有Gradle。想着就凑合着用Eclipse里面自带的export导出jar包的功能吧。于是:右键工程，选择export。然后java-&gt;JAR file</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/1.png\" alt=\"export\" title=\"export\">\n<p>jar包打好了。把依赖什么的都放到jar所在的同一个目录，紧接着使用 java -cp interfaceService.jar;lib/* com.XXX.Application  执行。</p>\n<p>服务器跑起来了。nice</p>\n<p>浏览器输入URL，回车，出现了这样的画面：</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/2.png\" alt=\"404\" title=\"404\">\n<p>what? 404?赶紧看看服务器打印的日志，发现dispatcherServlet初始化完之后就没有其他动作了，也没有报错信息。跟在eclipse中正常执行的情况对比了一下，eclipse在打印完这几句Log之后就开始进入controller方法了。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/3.png\" alt=\"log\" title=\"log\">\n<p>初步怀疑是找不到对应的controller。</p>\n<p>输入关键字：springboot jar 和404页面的提示，谷歌之。</p>\n<p>找出来一堆答案，基本都是说没有正确添加注解那一类的意思。回头看看代码，该加注解的地方都加了。而且eclipse里跑着没问题啊，说明不是注解的问题。</p>\n<p>感觉应该是打包的问题。把没用的.classpath等文件都排除，重新打包。再次执行，结果一样。</p>\n<p>把lib和properties文件都打到包里，执行，还是没用。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/4.png\" alt=\"export\" title=\"export\">\n<p>然后，上图这几个勾选框吸引了我的目光，查了一下这几个框勾选之后的作用，感觉跟这个关系不大，但是也都选上试了一下，失败。</p>\n<p>接着又以各种姿势谷歌了一遍，毫无结果。此刻心情比较郁闷，上网刷会微博吧，有点晕…</p>\n<p>接下来重新振作精神，再打一次包。</p>\n<p>抱着随便试试的心情，把下面的的框也选上了。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/5.png\" alt=\"export\" title=\"export\">\n<p>结果，这次竟然成功了！服务器返回了正确的结果。激动…原来就因为Add Directory Entries这个单选框没勾选就浪费了我两个多小时！</p>\n<p>然后各种姿势测了一下，没问题了。</p>\n<p>Add Directory Entries谷歌之。神了，出现了很多与我这个情况一样的描述和解决办法。看来还是有人掉过坑啊！</p>\n<p>浏览了一下大家的分析，结果就是：<strong>当使用export方式打jar包来运行spring项目时，一定要记得把Add Directory Entries这个单选框勾选上！否则会扫描不到指定的controller</strong></p>\n<p>原因也很简单：当勾选Add Directory Entries这个选项时，生成的jar会添加文件夹信息。spring就可以扫描到相关的包信息。具体的解释看这篇文章：<a href=\"http://www.voidcn.com/blog/wangjun5159/article/p-6159159.html\" target=\"_blank\" rel=\"external\">spring 扫描包不起作用</a></p>\n<p>其实这次遇到的问题也不算是技术上的问题，但前前后后也花了将近三个小时才解决。有三点认识：</p>\n<p>1.搜索技巧很重要，如果早一点能用spring、扫描包等关键字去搜索的话，问题早已经解决了。</p>\n<p>2.打包尽量用构建工具，避免重复劳动还不易出错。Gradle使用学习中…</p>\n<p>3.应该从问题的根源上想才会得到解决方法。比如，如果知道了spring获取controller的实现方式，或许能更快解决这个问题。(spring真的是一点都不懂，需要学习)</p>\n<p>以上</p>\n","excerpt":"","more":"<p>上周二刚从外包那里接手了一个的项目，主要是实现了一个web服务器，客户端可以以http请求的方式通过该服务器获取一些数据库的信息，技术上主要是使用了SpringBoot和REST API。周三就来新的需求了，实现一个接口，大概看了下代码，感觉soeasy(虽然之前从没有接触过springboot和spring，说来惭愧。不过这也说明了使用框架的好处，可以快速上手)。</p>\n<p>中秋假期结束之后把这个接口弄完了。Eclipse里面跑起来完全没有问题。自信心爆棚。该服务器要求以jar包的方式运行，那就打个包吧。结果苦逼的经历开始了。</p>\n<p>由于项目没有使用任何工具构建，没有maven，也没有Gradle。想着就凑合着用Eclipse里面自带的export导出jar包的功能吧。于是:右键工程，选择export。然后java-&gt;JAR file</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/1.png\" alt=\"export\" title=\"export\">\n<p>jar包打好了。把依赖什么的都放到jar所在的同一个目录，紧接着使用 java -cp interfaceService.jar;lib/* com.XXX.Application  执行。</p>\n<p>服务器跑起来了。nice</p>\n<p>浏览器输入URL，回车，出现了这样的画面：</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/2.png\" alt=\"404\" title=\"404\">\n<p>what? 404?赶紧看看服务器打印的日志，发现dispatcherServlet初始化完之后就没有其他动作了，也没有报错信息。跟在eclipse中正常执行的情况对比了一下，eclipse在打印完这几句Log之后就开始进入controller方法了。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/3.png\" alt=\"log\" title=\"log\">\n<p>初步怀疑是找不到对应的controller。</p>\n<p>输入关键字：springboot jar 和404页面的提示，谷歌之。</p>\n<p>找出来一堆答案，基本都是说没有正确添加注解那一类的意思。回头看看代码，该加注解的地方都加了。而且eclipse里跑着没问题啊，说明不是注解的问题。</p>\n<p>感觉应该是打包的问题。把没用的.classpath等文件都排除，重新打包。再次执行，结果一样。</p>\n<p>把lib和properties文件都打到包里，执行，还是没用。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/4.png\" alt=\"export\" title=\"export\">\n<p>然后，上图这几个勾选框吸引了我的目光，查了一下这几个框勾选之后的作用，感觉跟这个关系不大，但是也都选上试了一下，失败。</p>\n<p>接着又以各种姿势谷歌了一遍，毫无结果。此刻心情比较郁闷，上网刷会微博吧，有点晕…</p>\n<p>接下来重新振作精神，再打一次包。</p>\n<p>抱着随便试试的心情，把下面的的框也选上了。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/5.png\" alt=\"export\" title=\"export\">\n<p>结果，这次竟然成功了！服务器返回了正确的结果。激动…原来就因为Add Directory Entries这个单选框没勾选就浪费了我两个多小时！</p>\n<p>然后各种姿势测了一下，没问题了。</p>\n<p>Add Directory Entries谷歌之。神了，出现了很多与我这个情况一样的描述和解决办法。看来还是有人掉过坑啊！</p>\n<p>浏览了一下大家的分析，结果就是：<strong>当使用export方式打jar包来运行spring项目时，一定要记得把Add Directory Entries这个单选框勾选上！否则会扫描不到指定的controller</strong></p>\n<p>原因也很简单：当勾选Add Directory Entries这个选项时，生成的jar会添加文件夹信息。spring就可以扫描到相关的包信息。具体的解释看这篇文章：<a href=\"http://www.voidcn.com/blog/wangjun5159/article/p-6159159.html\">spring 扫描包不起作用</a></p>\n<p>其实这次遇到的问题也不算是技术上的问题，但前前后后也花了将近三个小时才解决。有三点认识：</p>\n<p>1.搜索技巧很重要，如果早一点能用spring、扫描包等关键字去搜索的话，问题早已经解决了。</p>\n<p>2.打包尽量用构建工具，避免重复劳动还不易出错。Gradle使用学习中…</p>\n<p>3.应该从问题的根源上想才会得到解决方法。比如，如果知道了spring获取controller的实现方式，或许能更快解决这个问题。(spring真的是一点都不懂，需要学习)</p>\n<p>以上</p>\n"},{"layout":"post","title":"Vps使用笔记","date":"2017-02-07T13:34:16.000Z","_content":"> 今天折腾了一天，总算是把翻墙的梯子搭起来了，租了国外的vps，然后在上面搭建了shadowsocks服务，手机和电脑就可以使用shadowsocks客户端的方式科学上网了。\n> Shadowsocks 是一个由很多人参与的开源项目，感谢shadowsocks作者[@clowwindy](https://github.com/clowwindy/shadowsocks).关于shadowssocks和vpn等等翻墙方式的区别,不再一一赘述，本文只是记录梯子搭建的过程\n\n## 购买VPS\n\nVPS的概念我也不是特别清楚，就把他当成主机好了，类似于阿里云等等。\n\n购买之后，会分配给你root账户密码，你就拥有了一台国外机房的主机。\n\nVPS 可以参考 [有哪些便宜稳定，速度也不错的Linux VPS 推荐？](https://www.zhihu.com/question/20800554),我买了Vultr 日本机房的vps,充了5美刀先试试。具体的购买方法自行谷歌\n\n## 搭建shadowsocks服务\n\n### 升级内核\n\n我选择了Centos7的Linux发型版本作为操作系统。\n\n使用MobaXterm(或者是其他ssh工具)连接到分配给你的主机(root密码购买成功时会给出),\n\n首先升级一下内核：wget -O- https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh | bash\n\n完成之后，重启：\n\nreboot\n\n重新登录，查看内核版本：\n\nuname -r\n\n不出意外已经更新到了最新版本。接着执行：\n\nsysctl -a|grep congestion_control\n\n如果输出选项包含：net.ipv4.tcp_congestion_control = bbr 表示安装成功，否则需要手动开启bbr模式：\n\n```\necho \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\necho \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\nsysctl -p\nsysctl\nnet.ipv4.tcp_available_congestion_control\n```\n\n再次查看：\n\nsysctl -a|grep congestion_control\n\n### 搭建服务\n\n搭建服务可以选择使用别人写好的现成的脚本，也可以自己搭建，下面介绍这两种方法：\n\n#### 使用现成脚本\n\n执行以下命令：\n\n```wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n\n首先会提示你输入密码和端口，然后开始安装。安装完成后代表shadowsocks服务已经开启了。此时可以使用shadowsocks客户端去连接这个服务器了。\n\n脚本可用的命令：\n\n启动：/etc/init.d/shadowsocks start\n\n停止：/etc/init.d/shadowsocks stop\n\n重启：/etc/init.d/shadowsocks restart\n\n状态：/etc/init.d/shadowsocks status\n\n卸载：./shadowsocks.sh uninstall\n\n支持多用户的方法：修改配置文件:/etc/shadowsocks.json\n\n```\n{    \n    \"server\":\"0.0.0.0\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{\n         \"8989\":\"password0\",\n         \"9001\":\"password1\",\n         \"9002\":\"password2\",\n         \"9003\":\"password3\",\n         \"9004\":\"password4\"\n    },\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}```\n\n#### 自行搭建\n\n首先安装shadowsocks服务：\n\n```\nyum install python-setuptools && easy_install pip\npip install shadowsocks\n```\n\n显示 “Successfully installed shadowsocks-2.6.10″。意味着Shadowsocks已经成功安装。\n\n接着，创建一个Shadowsocks配置文件。输入以下命令：\n\nvi /etc/shadowsocks.json\n\n然后在该文件中输入：\n\n```\n{\n    \"server\":\"your_server_ip\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"auooo.com\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n上面各项配置的含义已经很明显了，除了server(vps的ip)、server_port和password之外，其他默认即可。保存该文件。执行：\n\nssserver -c /etc/shadowsocks.json -d start\n\n服务就启动了，如果想要关闭，执行：\n\nssserver -c /etc/shadowsocks.json -d stop\n\n支持多用户的方法与上面的类似\n\n#### 端口问题\n\n有时候服务正常启动了，但是发现客户端还是没有办法翻墙。这时要注意检查vps开放的端口：\n\nCentos升级到7之后，使用firewalld代替了原来的iptables作为防火墙。\n\n启动：systemctl start  firewalld\n\n重启：firewall-cmd --reload\n\n查看状态：systemctl status firewalld 或者 firewall-cmd --state  \n\n查看开放的端口：firewall-cmd --list-ports\n\n增加开放端口：firewall-cmd --add-port=9001/tcp --permanent   (重启生效)\n\n9001：要开放的端口\n\ntcp：协议\n\n--permanent：永久生效，没有此参数重启后失效其他命令自行查找\n\n## 锐速加速\n\n[锐速破解版linux一键自动安装包（8月7日更新）](https://www.91yun.org/archives/683)\n\n文章开头的更新内核使用bbr加速或者锐速加速都可以，没试过哪种方式效果更好一些\n\n## vps使用ssh密钥登录\n\n使用ssh root账户和密码登录的方式是vps一开始会给出的登录主机的方式，这种方式比较简单，但是容易被别人暴力破解登录密码，控制我们的主机。\n\n所以，应该使用ssh密钥登录的方式来增强安全性。\n\n### 修改root密码\n\n第一步应该先把默认的root密码修改为自己的密码，最好复杂一点。\n\n确保自己记住了这个密码。\n\npasswd\n\n### 创建用户\n\n可以先创建一个非root用户：\n\n```\nuseradd yukai\n```\n\n创建账户密码：\n\n```\npasswd yukai \n```\n\n给予账户sudo权限：\n\n```\nvisudo\n```\n\n在 root ALL=(ALL)  ALL 下新增一行：\n\nyukai ALL=(ALL)  ALL\n\n切换到yukai这个账户：\n\nsu - yukai \n\n### 创建密钥\n\n```\nssh-keygen -t rsa\n```\n\n在 /home/yukai 下生成了一个隐藏目录：.ssh, 执行：\n\n```\ncd ~/.sshcat id_rsa.pub >> authorized_keys\nchmod 600 authorized_keys\n```\n\n将 id_rsa文件下载下来保存到本地(使用MobaXterm等工具)\n\n### 使用密钥认证登录\n\n打开MobaXterm工具，新建一个session，选择ssh，在Advanced SSH settings选项中选择 use private keygen复选框，并把上一步下载好的id_rsa选择进来。\n\n以用户yukai登录，提示输入密钥文件的密码，输入生成密钥时所填的密码，如果能够登录，则设置正确了\n\n### 禁用root用户登录和密码登录\n\n确保自己记住了root密码，并且上一步密钥认证方式登录成功。\n\n```\nsudo vi /etc/ssh/sshd_config\n```\n找到以下几项，进行如下设置：\n\n```\nRSAAuthentication yes\nPubkeyAuthentication yes\nPermitRootLogin no\nPasswordAuthentication no\n```\n\n重启ssh服务：\n\n```\nservice sshd restart\n```\n\n### 多台主机管理\n\n可以将生成的密钥文件authorized_keys保存到多个主机的相同位置：~/.ssh\n\n然后进行上面的配置。此时就可以使用一份私钥文件id_rsa登录多个主机了。\n\n## ss多用户管理\n\n前端使用ss-panel，后台使用shadowsocks-manyuser\n\n教程参见：\n\n[可能是最好的 ss-panel 部署教程](https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/)\n\n[ShadowSocks多用户管理系统搭建（moeSS+manyuser）](https://blog.linuxeye.com/426.html)\n\n## 在Linux上使用shadowsocks服务翻墙\n\n### 开启shadowsocks客户端\n\n确认安装了shadowsocks服务并从配置好的shadowsocks服务器端获得配置文件: /etc/shadowsocks/config.json\n\n```\n{\n        \"server\":\"remote-shadowsocks-server-ip-addr\",\n        \"server_port\":443,\n        \"local_address\":\"127.0.0.1\",\n        \"local_port\":1080,\n        \"password\":\"your-passwd\",\n        \"timeout\":300,\n        \"method\":\"aes-256-cfb\",\n        \"fast_open\":false,\n        \"workers\":1\n}\n```\n在config.json所在目录下运行sslocal即可：\n\nsslocal -c /etc/shadowsocks/config.json\n\n也可以手动指定参数运行：\n\nsslocal -s 服务器地址 -p 服务器端口 -l 本地端端口 -k 密码 -m 加密方法\n\n### 使用chrome代理\n\n在chrome应用商店中查找 Proxy SwitchyOmega,并安装该扩展\n\n新建情景模式，代理协议选择SOCKS5，代理服务器选择 127.0.0.1， 代理端口选择上一步中的local_port,即1080\n\n启用该扩展程序，此时可顺利使用google了 \n\n## 附录\n\n### 安装vim\n\nvim编辑器需要安装三个包：\n\n```\nvim-enhanced-7.0.109-7.el5\nvim-minimal-7.0.109-7.el5\nvim-common-7.0.109-7.el5\n```\n\n输入  `rpm -qa|grep vim` 这个命令，如何vim已经正确安装，则会显示上面三个包的名称\n\n如果缺少了其中某个，比如说： vim-enhanced这个包少了，执行：`yum -y install vim-enhanced` 命令，它会自动下载安装\n\n如果上面三个包一个都没有显示，则直接输入命令：\n\n```\nyum -y install vim*\n```\n\n### 安装net-tools\n\n```\nyum install net-tools\n```\n\n### 更改文件所有者\n\nchown -R www.www ./    将本路径下所有文件所有者改为www组的www\n\n## 参考\n\n[Shadowsocks Python版一键安装脚本](https://teddysun.com/342.html)\n\n[使用 Shadowsocks 自建翻墙服务器，实现全平台 100% 翻墙无障碍](https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/)\n\n[http://shadowsocks.org/](http://shadowsocks.org/en/download/clients.html)\n\n[shadowsocks（影梭）不完全指南](http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/)\n","source":"_posts/Vps使用笔记.md","raw":"---\nlayout: post\ntitle: Vps使用笔记\ndate: 2017-02-07 21:34:16\ncategories: 工具\ntags: linux\n---\n> 今天折腾了一天，总算是把翻墙的梯子搭起来了，租了国外的vps，然后在上面搭建了shadowsocks服务，手机和电脑就可以使用shadowsocks客户端的方式科学上网了。\n> Shadowsocks 是一个由很多人参与的开源项目，感谢shadowsocks作者[@clowwindy](https://github.com/clowwindy/shadowsocks).关于shadowssocks和vpn等等翻墙方式的区别,不再一一赘述，本文只是记录梯子搭建的过程\n\n## 购买VPS\n\nVPS的概念我也不是特别清楚，就把他当成主机好了，类似于阿里云等等。\n\n购买之后，会分配给你root账户密码，你就拥有了一台国外机房的主机。\n\nVPS 可以参考 [有哪些便宜稳定，速度也不错的Linux VPS 推荐？](https://www.zhihu.com/question/20800554),我买了Vultr 日本机房的vps,充了5美刀先试试。具体的购买方法自行谷歌\n\n## 搭建shadowsocks服务\n\n### 升级内核\n\n我选择了Centos7的Linux发型版本作为操作系统。\n\n使用MobaXterm(或者是其他ssh工具)连接到分配给你的主机(root密码购买成功时会给出),\n\n首先升级一下内核：wget -O- https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh | bash\n\n完成之后，重启：\n\nreboot\n\n重新登录，查看内核版本：\n\nuname -r\n\n不出意外已经更新到了最新版本。接着执行：\n\nsysctl -a|grep congestion_control\n\n如果输出选项包含：net.ipv4.tcp_congestion_control = bbr 表示安装成功，否则需要手动开启bbr模式：\n\n```\necho \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\necho \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\nsysctl -p\nsysctl\nnet.ipv4.tcp_available_congestion_control\n```\n\n再次查看：\n\nsysctl -a|grep congestion_control\n\n### 搭建服务\n\n搭建服务可以选择使用别人写好的现成的脚本，也可以自己搭建，下面介绍这两种方法：\n\n#### 使用现成脚本\n\n执行以下命令：\n\n```wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n\n首先会提示你输入密码和端口，然后开始安装。安装完成后代表shadowsocks服务已经开启了。此时可以使用shadowsocks客户端去连接这个服务器了。\n\n脚本可用的命令：\n\n启动：/etc/init.d/shadowsocks start\n\n停止：/etc/init.d/shadowsocks stop\n\n重启：/etc/init.d/shadowsocks restart\n\n状态：/etc/init.d/shadowsocks status\n\n卸载：./shadowsocks.sh uninstall\n\n支持多用户的方法：修改配置文件:/etc/shadowsocks.json\n\n```\n{    \n    \"server\":\"0.0.0.0\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{\n         \"8989\":\"password0\",\n         \"9001\":\"password1\",\n         \"9002\":\"password2\",\n         \"9003\":\"password3\",\n         \"9004\":\"password4\"\n    },\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}```\n\n#### 自行搭建\n\n首先安装shadowsocks服务：\n\n```\nyum install python-setuptools && easy_install pip\npip install shadowsocks\n```\n\n显示 “Successfully installed shadowsocks-2.6.10″。意味着Shadowsocks已经成功安装。\n\n接着，创建一个Shadowsocks配置文件。输入以下命令：\n\nvi /etc/shadowsocks.json\n\n然后在该文件中输入：\n\n```\n{\n    \"server\":\"your_server_ip\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"auooo.com\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n上面各项配置的含义已经很明显了，除了server(vps的ip)、server_port和password之外，其他默认即可。保存该文件。执行：\n\nssserver -c /etc/shadowsocks.json -d start\n\n服务就启动了，如果想要关闭，执行：\n\nssserver -c /etc/shadowsocks.json -d stop\n\n支持多用户的方法与上面的类似\n\n#### 端口问题\n\n有时候服务正常启动了，但是发现客户端还是没有办法翻墙。这时要注意检查vps开放的端口：\n\nCentos升级到7之后，使用firewalld代替了原来的iptables作为防火墙。\n\n启动：systemctl start  firewalld\n\n重启：firewall-cmd --reload\n\n查看状态：systemctl status firewalld 或者 firewall-cmd --state  \n\n查看开放的端口：firewall-cmd --list-ports\n\n增加开放端口：firewall-cmd --add-port=9001/tcp --permanent   (重启生效)\n\n9001：要开放的端口\n\ntcp：协议\n\n--permanent：永久生效，没有此参数重启后失效其他命令自行查找\n\n## 锐速加速\n\n[锐速破解版linux一键自动安装包（8月7日更新）](https://www.91yun.org/archives/683)\n\n文章开头的更新内核使用bbr加速或者锐速加速都可以，没试过哪种方式效果更好一些\n\n## vps使用ssh密钥登录\n\n使用ssh root账户和密码登录的方式是vps一开始会给出的登录主机的方式，这种方式比较简单，但是容易被别人暴力破解登录密码，控制我们的主机。\n\n所以，应该使用ssh密钥登录的方式来增强安全性。\n\n### 修改root密码\n\n第一步应该先把默认的root密码修改为自己的密码，最好复杂一点。\n\n确保自己记住了这个密码。\n\npasswd\n\n### 创建用户\n\n可以先创建一个非root用户：\n\n```\nuseradd yukai\n```\n\n创建账户密码：\n\n```\npasswd yukai \n```\n\n给予账户sudo权限：\n\n```\nvisudo\n```\n\n在 root ALL=(ALL)  ALL 下新增一行：\n\nyukai ALL=(ALL)  ALL\n\n切换到yukai这个账户：\n\nsu - yukai \n\n### 创建密钥\n\n```\nssh-keygen -t rsa\n```\n\n在 /home/yukai 下生成了一个隐藏目录：.ssh, 执行：\n\n```\ncd ~/.sshcat id_rsa.pub >> authorized_keys\nchmod 600 authorized_keys\n```\n\n将 id_rsa文件下载下来保存到本地(使用MobaXterm等工具)\n\n### 使用密钥认证登录\n\n打开MobaXterm工具，新建一个session，选择ssh，在Advanced SSH settings选项中选择 use private keygen复选框，并把上一步下载好的id_rsa选择进来。\n\n以用户yukai登录，提示输入密钥文件的密码，输入生成密钥时所填的密码，如果能够登录，则设置正确了\n\n### 禁用root用户登录和密码登录\n\n确保自己记住了root密码，并且上一步密钥认证方式登录成功。\n\n```\nsudo vi /etc/ssh/sshd_config\n```\n找到以下几项，进行如下设置：\n\n```\nRSAAuthentication yes\nPubkeyAuthentication yes\nPermitRootLogin no\nPasswordAuthentication no\n```\n\n重启ssh服务：\n\n```\nservice sshd restart\n```\n\n### 多台主机管理\n\n可以将生成的密钥文件authorized_keys保存到多个主机的相同位置：~/.ssh\n\n然后进行上面的配置。此时就可以使用一份私钥文件id_rsa登录多个主机了。\n\n## ss多用户管理\n\n前端使用ss-panel，后台使用shadowsocks-manyuser\n\n教程参见：\n\n[可能是最好的 ss-panel 部署教程](https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/)\n\n[ShadowSocks多用户管理系统搭建（moeSS+manyuser）](https://blog.linuxeye.com/426.html)\n\n## 在Linux上使用shadowsocks服务翻墙\n\n### 开启shadowsocks客户端\n\n确认安装了shadowsocks服务并从配置好的shadowsocks服务器端获得配置文件: /etc/shadowsocks/config.json\n\n```\n{\n        \"server\":\"remote-shadowsocks-server-ip-addr\",\n        \"server_port\":443,\n        \"local_address\":\"127.0.0.1\",\n        \"local_port\":1080,\n        \"password\":\"your-passwd\",\n        \"timeout\":300,\n        \"method\":\"aes-256-cfb\",\n        \"fast_open\":false,\n        \"workers\":1\n}\n```\n在config.json所在目录下运行sslocal即可：\n\nsslocal -c /etc/shadowsocks/config.json\n\n也可以手动指定参数运行：\n\nsslocal -s 服务器地址 -p 服务器端口 -l 本地端端口 -k 密码 -m 加密方法\n\n### 使用chrome代理\n\n在chrome应用商店中查找 Proxy SwitchyOmega,并安装该扩展\n\n新建情景模式，代理协议选择SOCKS5，代理服务器选择 127.0.0.1， 代理端口选择上一步中的local_port,即1080\n\n启用该扩展程序，此时可顺利使用google了 \n\n## 附录\n\n### 安装vim\n\nvim编辑器需要安装三个包：\n\n```\nvim-enhanced-7.0.109-7.el5\nvim-minimal-7.0.109-7.el5\nvim-common-7.0.109-7.el5\n```\n\n输入  `rpm -qa|grep vim` 这个命令，如何vim已经正确安装，则会显示上面三个包的名称\n\n如果缺少了其中某个，比如说： vim-enhanced这个包少了，执行：`yum -y install vim-enhanced` 命令，它会自动下载安装\n\n如果上面三个包一个都没有显示，则直接输入命令：\n\n```\nyum -y install vim*\n```\n\n### 安装net-tools\n\n```\nyum install net-tools\n```\n\n### 更改文件所有者\n\nchown -R www.www ./    将本路径下所有文件所有者改为www组的www\n\n## 参考\n\n[Shadowsocks Python版一键安装脚本](https://teddysun.com/342.html)\n\n[使用 Shadowsocks 自建翻墙服务器，实现全平台 100% 翻墙无障碍](https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/)\n\n[http://shadowsocks.org/](http://shadowsocks.org/en/download/clients.html)\n\n[shadowsocks（影梭）不完全指南](http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/)\n","slug":"Vps使用笔记","published":1,"updated":"2017-02-07T14:26:10.540Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj3z0008digcuz928vlu","content":"<blockquote>\n<p>今天折腾了一天，总算是把翻墙的梯子搭起来了，租了国外的vps，然后在上面搭建了shadowsocks服务，手机和电脑就可以使用shadowsocks客户端的方式科学上网了。<br>Shadowsocks 是一个由很多人参与的开源项目，感谢shadowsocks作者<a href=\"https://github.com/clowwindy/shadowsocks\" target=\"_blank\" rel=\"external\">@clowwindy</a>.关于shadowssocks和vpn等等翻墙方式的区别,不再一一赘述，本文只是记录梯子搭建的过程</p>\n</blockquote>\n<h2 id=\"购买VPS\"><a href=\"#购买VPS\" class=\"headerlink\" title=\"购买VPS\"></a>购买VPS</h2><p>VPS的概念我也不是特别清楚，就把他当成主机好了，类似于阿里云等等。</p>\n<p>购买之后，会分配给你root账户密码，你就拥有了一台国外机房的主机。</p>\n<p>VPS 可以参考 <a href=\"https://www.zhihu.com/question/20800554\" target=\"_blank\" rel=\"external\">有哪些便宜稳定，速度也不错的Linux VPS 推荐？</a>,我买了Vultr 日本机房的vps,充了5美刀先试试。具体的购买方法自行谷歌</p>\n<h2 id=\"搭建shadowsocks服务\"><a href=\"#搭建shadowsocks服务\" class=\"headerlink\" title=\"搭建shadowsocks服务\"></a>搭建shadowsocks服务</h2><h3 id=\"升级内核\"><a href=\"#升级内核\" class=\"headerlink\" title=\"升级内核\"></a>升级内核</h3><p>我选择了Centos7的Linux发型版本作为操作系统。</p>\n<p>使用MobaXterm(或者是其他ssh工具)连接到分配给你的主机(root密码购买成功时会给出),</p>\n<p>首先升级一下内核：wget -O- <a href=\"https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh\" target=\"_blank\" rel=\"external\">https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh</a> | bash</p>\n<p>完成之后，重启：</p>\n<p>reboot</p>\n<p>重新登录，查看内核版本：</p>\n<p>uname -r</p>\n<p>不出意外已经更新到了最新版本。接着执行：</p>\n<p>sysctl -a|grep congestion_control</p>\n<p>如果输出选项包含：net.ipv4.tcp_congestion_control = bbr 表示安装成功，否则需要手动开启bbr模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">sysctl -p</div><div class=\"line\">sysctl</div><div class=\"line\">net.ipv4.tcp_available_congestion_control</div></pre></td></tr></table></figure>\n<p>再次查看：</p>\n<p>sysctl -a|grep congestion_control</p>\n<h3 id=\"搭建服务\"><a href=\"#搭建服务\" class=\"headerlink\" title=\"搭建服务\"></a>搭建服务</h3><p>搭建服务可以选择使用别人写好的现成的脚本，也可以自己搭建，下面介绍这两种方法：</p>\n<h4 id=\"使用现成脚本\"><a href=\"#使用现成脚本\" class=\"headerlink\" title=\"使用现成脚本\"></a>使用现成脚本</h4><p>执行以下命令：</p>\n<figure class=\"highlight plain\"><figcaption><span>--no-check-certificate</span><a href=\"https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\" target=\"_blank\" rel=\"external\">link</a></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x shadowsocks.sh</div><div class=\"line\">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</div></pre></td></tr></table></figure>\n<p>首先会提示你输入密码和端口，然后开始安装。安装完成后代表shadowsocks服务已经开启了。此时可以使用shadowsocks客户端去连接这个服务器了。</p>\n<p>脚本可用的命令：</p>\n<p>启动：/etc/init.d/shadowsocks start</p>\n<p>停止：/etc/init.d/shadowsocks stop</p>\n<p>重启：/etc/init.d/shadowsocks restart</p>\n<p>状态：/etc/init.d/shadowsocks status</p>\n<p>卸载：./shadowsocks.sh uninstall</p>\n<p>支持多用户的方法：修改配置文件:/etc/shadowsocks.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;    </div><div class=\"line\">    &quot;server&quot;:&quot;0.0.0.0&quot;,</div><div class=\"line\">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;port_password&quot;:&#123;</div><div class=\"line\">         &quot;8989&quot;:&quot;password0&quot;,</div><div class=\"line\">         &quot;9001&quot;:&quot;password1&quot;,</div><div class=\"line\">         &quot;9002&quot;:&quot;password2&quot;,</div><div class=\"line\">         &quot;9003&quot;:&quot;password3&quot;,</div><div class=\"line\">         &quot;9004&quot;:&quot;password4&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"自行搭建\"><a href=\"#自行搭建\" class=\"headerlink\" title=\"自行搭建\"></a>自行搭建</h4><p>首先安装shadowsocks服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</div><div class=\"line\">pip install shadowsocks</div></pre></td></tr></table></figure>\n<p>显示 “Successfully installed shadowsocks-2.6.10″。意味着Shadowsocks已经成功安装。</p>\n<p>接着，创建一个Shadowsocks配置文件。输入以下命令：</p>\n<p>vi /etc/shadowsocks.json</p>\n<p>然后在该文件中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;server&quot;:&quot;your_server_ip&quot;,</div><div class=\"line\">    &quot;server_port&quot;:8388,</div><div class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;password&quot;:&quot;auooo.com&quot;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面各项配置的含义已经很明显了，除了server(vps的ip)、server_port和password之外，其他默认即可。保存该文件。执行：</p>\n<p>ssserver -c /etc/shadowsocks.json -d start</p>\n<p>服务就启动了，如果想要关闭，执行：</p>\n<p>ssserver -c /etc/shadowsocks.json -d stop</p>\n<p>支持多用户的方法与上面的类似</p>\n<h4 id=\"端口问题\"><a href=\"#端口问题\" class=\"headerlink\" title=\"端口问题\"></a>端口问题</h4><p>有时候服务正常启动了，但是发现客户端还是没有办法翻墙。这时要注意检查vps开放的端口：</p>\n<p>Centos升级到7之后，使用firewalld代替了原来的iptables作为防火墙。</p>\n<p>启动：systemctl start  firewalld</p>\n<p>重启：firewall-cmd –reload</p>\n<p>查看状态：systemctl status firewalld 或者 firewall-cmd –state  </p>\n<p>查看开放的端口：firewall-cmd –list-ports</p>\n<p>增加开放端口：firewall-cmd –add-port=9001/tcp –permanent   (重启生效)</p>\n<p>9001：要开放的端口</p>\n<p>tcp：协议</p>\n<p>–permanent：永久生效，没有此参数重启后失效其他命令自行查找</p>\n<h2 id=\"锐速加速\"><a href=\"#锐速加速\" class=\"headerlink\" title=\"锐速加速\"></a>锐速加速</h2><p><a href=\"https://www.91yun.org/archives/683\" target=\"_blank\" rel=\"external\">锐速破解版linux一键自动安装包（8月7日更新）</a></p>\n<p>文章开头的更新内核使用bbr加速或者锐速加速都可以，没试过哪种方式效果更好一些</p>\n<h2 id=\"vps使用ssh密钥登录\"><a href=\"#vps使用ssh密钥登录\" class=\"headerlink\" title=\"vps使用ssh密钥登录\"></a>vps使用ssh密钥登录</h2><p>使用ssh root账户和密码登录的方式是vps一开始会给出的登录主机的方式，这种方式比较简单，但是容易被别人暴力破解登录密码，控制我们的主机。</p>\n<p>所以，应该使用ssh密钥登录的方式来增强安全性。</p>\n<h3 id=\"修改root密码\"><a href=\"#修改root密码\" class=\"headerlink\" title=\"修改root密码\"></a>修改root密码</h3><p>第一步应该先把默认的root密码修改为自己的密码，最好复杂一点。</p>\n<p>确保自己记住了这个密码。</p>\n<p>passwd</p>\n<h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><p>可以先创建一个非root用户：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">useradd yukai</div></pre></td></tr></table></figure>\n<p>创建账户密码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">passwd yukai</div></pre></td></tr></table></figure>\n<p>给予账户sudo权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">visudo</div></pre></td></tr></table></figure>\n<p>在 root ALL=(ALL)  ALL 下新增一行：</p>\n<p>yukai ALL=(ALL)  ALL</p>\n<p>切换到yukai这个账户：</p>\n<p>su - yukai </p>\n<h3 id=\"创建密钥\"><a href=\"#创建密钥\" class=\"headerlink\" title=\"创建密钥\"></a>创建密钥</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen -t rsa</div></pre></td></tr></table></figure>\n<p>在 /home/yukai 下生成了一个隐藏目录：.ssh, 执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~/.sshcat id_rsa.pub &gt;&gt; authorized_keys</div><div class=\"line\">chmod 600 authorized_keys</div></pre></td></tr></table></figure>\n<p>将 id_rsa文件下载下来保存到本地(使用MobaXterm等工具)</p>\n<h3 id=\"使用密钥认证登录\"><a href=\"#使用密钥认证登录\" class=\"headerlink\" title=\"使用密钥认证登录\"></a>使用密钥认证登录</h3><p>打开MobaXterm工具，新建一个session，选择ssh，在Advanced SSH settings选项中选择 use private keygen复选框，并把上一步下载好的id_rsa选择进来。</p>\n<p>以用户yukai登录，提示输入密钥文件的密码，输入生成密钥时所填的密码，如果能够登录，则设置正确了</p>\n<h3 id=\"禁用root用户登录和密码登录\"><a href=\"#禁用root用户登录和密码登录\" class=\"headerlink\" title=\"禁用root用户登录和密码登录\"></a>禁用root用户登录和密码登录</h3><p>确保自己记住了root密码，并且上一步密钥认证方式登录成功。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo vi /etc/ssh/sshd_config</div></pre></td></tr></table></figure>\n<p>找到以下几项，进行如下设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">RSAAuthentication yes</div><div class=\"line\">PubkeyAuthentication yes</div><div class=\"line\">PermitRootLogin no</div><div class=\"line\">PasswordAuthentication no</div></pre></td></tr></table></figure>\n<p>重启ssh服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service sshd restart</div></pre></td></tr></table></figure>\n<h3 id=\"多台主机管理\"><a href=\"#多台主机管理\" class=\"headerlink\" title=\"多台主机管理\"></a>多台主机管理</h3><p>可以将生成的密钥文件authorized_keys保存到多个主机的相同位置：~/.ssh</p>\n<p>然后进行上面的配置。此时就可以使用一份私钥文件id_rsa登录多个主机了。</p>\n<h2 id=\"ss多用户管理\"><a href=\"#ss多用户管理\" class=\"headerlink\" title=\"ss多用户管理\"></a>ss多用户管理</h2><p>前端使用ss-panel，后台使用shadowsocks-manyuser</p>\n<p>教程参见：</p>\n<p><a href=\"https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/\" target=\"_blank\" rel=\"external\">可能是最好的 ss-panel 部署教程</a></p>\n<p><a href=\"https://blog.linuxeye.com/426.html\" target=\"_blank\" rel=\"external\">ShadowSocks多用户管理系统搭建（moeSS+manyuser）</a></p>\n<h2 id=\"在Linux上使用shadowsocks服务翻墙\"><a href=\"#在Linux上使用shadowsocks服务翻墙\" class=\"headerlink\" title=\"在Linux上使用shadowsocks服务翻墙\"></a>在Linux上使用shadowsocks服务翻墙</h2><h3 id=\"开启shadowsocks客户端\"><a href=\"#开启shadowsocks客户端\" class=\"headerlink\" title=\"开启shadowsocks客户端\"></a>开启shadowsocks客户端</h3><p>确认安装了shadowsocks服务并从配置好的shadowsocks服务器端获得配置文件: /etc/shadowsocks/config.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">        &quot;server&quot;:&quot;remote-shadowsocks-server-ip-addr&quot;,</div><div class=\"line\">        &quot;server_port&quot;:443,</div><div class=\"line\">        &quot;local_address&quot;:&quot;127.0.0.1&quot;,</div><div class=\"line\">        &quot;local_port&quot;:1080,</div><div class=\"line\">        &quot;password&quot;:&quot;your-passwd&quot;,</div><div class=\"line\">        &quot;timeout&quot;:300,</div><div class=\"line\">        &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">        &quot;fast_open&quot;:false,</div><div class=\"line\">        &quot;workers&quot;:1</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在config.json所在目录下运行sslocal即可：</p>\n<p>sslocal -c /etc/shadowsocks/config.json</p>\n<p>也可以手动指定参数运行：</p>\n<p>sslocal -s 服务器地址 -p 服务器端口 -l 本地端端口 -k 密码 -m 加密方法</p>\n<h3 id=\"使用chrome代理\"><a href=\"#使用chrome代理\" class=\"headerlink\" title=\"使用chrome代理\"></a>使用chrome代理</h3><p>在chrome应用商店中查找 Proxy SwitchyOmega,并安装该扩展</p>\n<p>新建情景模式，代理协议选择SOCKS5，代理服务器选择 127.0.0.1， 代理端口选择上一步中的local_port,即1080</p>\n<p>启用该扩展程序，此时可顺利使用google了 </p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"安装vim\"><a href=\"#安装vim\" class=\"headerlink\" title=\"安装vim\"></a>安装vim</h3><p>vim编辑器需要安装三个包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim-enhanced-7.0.109-7.el5</div><div class=\"line\">vim-minimal-7.0.109-7.el5</div><div class=\"line\">vim-common-7.0.109-7.el5</div></pre></td></tr></table></figure>\n<p>输入  <code>rpm -qa|grep vim</code> 这个命令，如何vim已经正确安装，则会显示上面三个包的名称</p>\n<p>如果缺少了其中某个，比如说： vim-enhanced这个包少了，执行：<code>yum -y install vim-enhanced</code> 命令，它会自动下载安装</p>\n<p>如果上面三个包一个都没有显示，则直接输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum -y install vim*</div></pre></td></tr></table></figure>\n<h3 id=\"安装net-tools\"><a href=\"#安装net-tools\" class=\"headerlink\" title=\"安装net-tools\"></a>安装net-tools</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install net-tools</div></pre></td></tr></table></figure>\n<h3 id=\"更改文件所有者\"><a href=\"#更改文件所有者\" class=\"headerlink\" title=\"更改文件所有者\"></a>更改文件所有者</h3><p>chown -R www.www ./    将本路径下所有文件所有者改为www组的www</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://teddysun.com/342.html\" target=\"_blank\" rel=\"external\">Shadowsocks Python版一键安装脚本</a></p>\n<p><a href=\"https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/\" target=\"_blank\" rel=\"external\">使用 Shadowsocks 自建翻墙服务器，实现全平台 100% 翻墙无障碍</a></p>\n<p><a href=\"http://shadowsocks.org/en/download/clients.html\" target=\"_blank\" rel=\"external\">http://shadowsocks.org/</a></p>\n<p><a href=\"http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/\" target=\"_blank\" rel=\"external\">shadowsocks（影梭）不完全指南</a></p>\n","excerpt":"","more":"<blockquote>\n<p>今天折腾了一天，总算是把翻墙的梯子搭起来了，租了国外的vps，然后在上面搭建了shadowsocks服务，手机和电脑就可以使用shadowsocks客户端的方式科学上网了。<br>Shadowsocks 是一个由很多人参与的开源项目，感谢shadowsocks作者<a href=\"https://github.com/clowwindy/shadowsocks\">@clowwindy</a>.关于shadowssocks和vpn等等翻墙方式的区别,不再一一赘述，本文只是记录梯子搭建的过程</p>\n</blockquote>\n<h2 id=\"购买VPS\"><a href=\"#购买VPS\" class=\"headerlink\" title=\"购买VPS\"></a>购买VPS</h2><p>VPS的概念我也不是特别清楚，就把他当成主机好了，类似于阿里云等等。</p>\n<p>购买之后，会分配给你root账户密码，你就拥有了一台国外机房的主机。</p>\n<p>VPS 可以参考 <a href=\"https://www.zhihu.com/question/20800554\">有哪些便宜稳定，速度也不错的Linux VPS 推荐？</a>,我买了Vultr 日本机房的vps,充了5美刀先试试。具体的购买方法自行谷歌</p>\n<h2 id=\"搭建shadowsocks服务\"><a href=\"#搭建shadowsocks服务\" class=\"headerlink\" title=\"搭建shadowsocks服务\"></a>搭建shadowsocks服务</h2><h3 id=\"升级内核\"><a href=\"#升级内核\" class=\"headerlink\" title=\"升级内核\"></a>升级内核</h3><p>我选择了Centos7的Linux发型版本作为操作系统。</p>\n<p>使用MobaXterm(或者是其他ssh工具)连接到分配给你的主机(root密码购买成功时会给出),</p>\n<p>首先升级一下内核：wget -O- <a href=\"https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh\">https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh</a> | bash</p>\n<p>完成之后，重启：</p>\n<p>reboot</p>\n<p>重新登录，查看内核版本：</p>\n<p>uname -r</p>\n<p>不出意外已经更新到了最新版本。接着执行：</p>\n<p>sysctl -a|grep congestion_control</p>\n<p>如果输出选项包含：net.ipv4.tcp_congestion_control = bbr 表示安装成功，否则需要手动开启bbr模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">sysctl -p</div><div class=\"line\">sysctl</div><div class=\"line\">net.ipv4.tcp_available_congestion_control</div></pre></td></tr></table></figure>\n<p>再次查看：</p>\n<p>sysctl -a|grep congestion_control</p>\n<h3 id=\"搭建服务\"><a href=\"#搭建服务\" class=\"headerlink\" title=\"搭建服务\"></a>搭建服务</h3><p>搭建服务可以选择使用别人写好的现成的脚本，也可以自己搭建，下面介绍这两种方法：</p>\n<h4 id=\"使用现成脚本\"><a href=\"#使用现成脚本\" class=\"headerlink\" title=\"使用现成脚本\"></a>使用现成脚本</h4><p>执行以下命令：</p>\n<figure class=\"highlight plain\"><figcaption><span>--no-check-certificate</span><a href=\"https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\">link</a></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x shadowsocks.sh</div><div class=\"line\">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</div></pre></td></tr></table></figure>\n<p>首先会提示你输入密码和端口，然后开始安装。安装完成后代表shadowsocks服务已经开启了。此时可以使用shadowsocks客户端去连接这个服务器了。</p>\n<p>脚本可用的命令：</p>\n<p>启动：/etc/init.d/shadowsocks start</p>\n<p>停止：/etc/init.d/shadowsocks stop</p>\n<p>重启：/etc/init.d/shadowsocks restart</p>\n<p>状态：/etc/init.d/shadowsocks status</p>\n<p>卸载：./shadowsocks.sh uninstall</p>\n<p>支持多用户的方法：修改配置文件:/etc/shadowsocks.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;    </div><div class=\"line\">    &quot;server&quot;:&quot;0.0.0.0&quot;,</div><div class=\"line\">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;port_password&quot;:&#123;</div><div class=\"line\">         &quot;8989&quot;:&quot;password0&quot;,</div><div class=\"line\">         &quot;9001&quot;:&quot;password1&quot;,</div><div class=\"line\">         &quot;9002&quot;:&quot;password2&quot;,</div><div class=\"line\">         &quot;9003&quot;:&quot;password3&quot;,</div><div class=\"line\">         &quot;9004&quot;:&quot;password4&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"自行搭建\"><a href=\"#自行搭建\" class=\"headerlink\" title=\"自行搭建\"></a>自行搭建</h4><p>首先安装shadowsocks服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</div><div class=\"line\">pip install shadowsocks</div></pre></td></tr></table></figure>\n<p>显示 “Successfully installed shadowsocks-2.6.10″。意味着Shadowsocks已经成功安装。</p>\n<p>接着，创建一个Shadowsocks配置文件。输入以下命令：</p>\n<p>vi /etc/shadowsocks.json</p>\n<p>然后在该文件中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;server&quot;:&quot;your_server_ip&quot;,</div><div class=\"line\">    &quot;server_port&quot;:8388,</div><div class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;password&quot;:&quot;auooo.com&quot;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面各项配置的含义已经很明显了，除了server(vps的ip)、server_port和password之外，其他默认即可。保存该文件。执行：</p>\n<p>ssserver -c /etc/shadowsocks.json -d start</p>\n<p>服务就启动了，如果想要关闭，执行：</p>\n<p>ssserver -c /etc/shadowsocks.json -d stop</p>\n<p>支持多用户的方法与上面的类似</p>\n<h4 id=\"端口问题\"><a href=\"#端口问题\" class=\"headerlink\" title=\"端口问题\"></a>端口问题</h4><p>有时候服务正常启动了，但是发现客户端还是没有办法翻墙。这时要注意检查vps开放的端口：</p>\n<p>Centos升级到7之后，使用firewalld代替了原来的iptables作为防火墙。</p>\n<p>启动：systemctl start  firewalld</p>\n<p>重启：firewall-cmd –reload</p>\n<p>查看状态：systemctl status firewalld 或者 firewall-cmd –state  </p>\n<p>查看开放的端口：firewall-cmd –list-ports</p>\n<p>增加开放端口：firewall-cmd –add-port=9001/tcp –permanent   (重启生效)</p>\n<p>9001：要开放的端口</p>\n<p>tcp：协议</p>\n<p>–permanent：永久生效，没有此参数重启后失效其他命令自行查找</p>\n<h2 id=\"锐速加速\"><a href=\"#锐速加速\" class=\"headerlink\" title=\"锐速加速\"></a>锐速加速</h2><p><a href=\"https://www.91yun.org/archives/683\">锐速破解版linux一键自动安装包（8月7日更新）</a></p>\n<p>文章开头的更新内核使用bbr加速或者锐速加速都可以，没试过哪种方式效果更好一些</p>\n<h2 id=\"vps使用ssh密钥登录\"><a href=\"#vps使用ssh密钥登录\" class=\"headerlink\" title=\"vps使用ssh密钥登录\"></a>vps使用ssh密钥登录</h2><p>使用ssh root账户和密码登录的方式是vps一开始会给出的登录主机的方式，这种方式比较简单，但是容易被别人暴力破解登录密码，控制我们的主机。</p>\n<p>所以，应该使用ssh密钥登录的方式来增强安全性。</p>\n<h3 id=\"修改root密码\"><a href=\"#修改root密码\" class=\"headerlink\" title=\"修改root密码\"></a>修改root密码</h3><p>第一步应该先把默认的root密码修改为自己的密码，最好复杂一点。</p>\n<p>确保自己记住了这个密码。</p>\n<p>passwd</p>\n<h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><p>可以先创建一个非root用户：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">useradd yukai</div></pre></td></tr></table></figure>\n<p>创建账户密码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">passwd yukai</div></pre></td></tr></table></figure>\n<p>给予账户sudo权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">visudo</div></pre></td></tr></table></figure>\n<p>在 root ALL=(ALL)  ALL 下新增一行：</p>\n<p>yukai ALL=(ALL)  ALL</p>\n<p>切换到yukai这个账户：</p>\n<p>su - yukai </p>\n<h3 id=\"创建密钥\"><a href=\"#创建密钥\" class=\"headerlink\" title=\"创建密钥\"></a>创建密钥</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen -t rsa</div></pre></td></tr></table></figure>\n<p>在 /home/yukai 下生成了一个隐藏目录：.ssh, 执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~/.sshcat id_rsa.pub &gt;&gt; authorized_keys</div><div class=\"line\">chmod 600 authorized_keys</div></pre></td></tr></table></figure>\n<p>将 id_rsa文件下载下来保存到本地(使用MobaXterm等工具)</p>\n<h3 id=\"使用密钥认证登录\"><a href=\"#使用密钥认证登录\" class=\"headerlink\" title=\"使用密钥认证登录\"></a>使用密钥认证登录</h3><p>打开MobaXterm工具，新建一个session，选择ssh，在Advanced SSH settings选项中选择 use private keygen复选框，并把上一步下载好的id_rsa选择进来。</p>\n<p>以用户yukai登录，提示输入密钥文件的密码，输入生成密钥时所填的密码，如果能够登录，则设置正确了</p>\n<h3 id=\"禁用root用户登录和密码登录\"><a href=\"#禁用root用户登录和密码登录\" class=\"headerlink\" title=\"禁用root用户登录和密码登录\"></a>禁用root用户登录和密码登录</h3><p>确保自己记住了root密码，并且上一步密钥认证方式登录成功。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo vi /etc/ssh/sshd_config</div></pre></td></tr></table></figure>\n<p>找到以下几项，进行如下设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">RSAAuthentication yes</div><div class=\"line\">PubkeyAuthentication yes</div><div class=\"line\">PermitRootLogin no</div><div class=\"line\">PasswordAuthentication no</div></pre></td></tr></table></figure>\n<p>重启ssh服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service sshd restart</div></pre></td></tr></table></figure>\n<h3 id=\"多台主机管理\"><a href=\"#多台主机管理\" class=\"headerlink\" title=\"多台主机管理\"></a>多台主机管理</h3><p>可以将生成的密钥文件authorized_keys保存到多个主机的相同位置：~/.ssh</p>\n<p>然后进行上面的配置。此时就可以使用一份私钥文件id_rsa登录多个主机了。</p>\n<h2 id=\"ss多用户管理\"><a href=\"#ss多用户管理\" class=\"headerlink\" title=\"ss多用户管理\"></a>ss多用户管理</h2><p>前端使用ss-panel，后台使用shadowsocks-manyuser</p>\n<p>教程参见：</p>\n<p><a href=\"https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/\">可能是最好的 ss-panel 部署教程</a></p>\n<p><a href=\"https://blog.linuxeye.com/426.html\">ShadowSocks多用户管理系统搭建（moeSS+manyuser）</a></p>\n<h2 id=\"在Linux上使用shadowsocks服务翻墙\"><a href=\"#在Linux上使用shadowsocks服务翻墙\" class=\"headerlink\" title=\"在Linux上使用shadowsocks服务翻墙\"></a>在Linux上使用shadowsocks服务翻墙</h2><h3 id=\"开启shadowsocks客户端\"><a href=\"#开启shadowsocks客户端\" class=\"headerlink\" title=\"开启shadowsocks客户端\"></a>开启shadowsocks客户端</h3><p>确认安装了shadowsocks服务并从配置好的shadowsocks服务器端获得配置文件: /etc/shadowsocks/config.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">        &quot;server&quot;:&quot;remote-shadowsocks-server-ip-addr&quot;,</div><div class=\"line\">        &quot;server_port&quot;:443,</div><div class=\"line\">        &quot;local_address&quot;:&quot;127.0.0.1&quot;,</div><div class=\"line\">        &quot;local_port&quot;:1080,</div><div class=\"line\">        &quot;password&quot;:&quot;your-passwd&quot;,</div><div class=\"line\">        &quot;timeout&quot;:300,</div><div class=\"line\">        &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">        &quot;fast_open&quot;:false,</div><div class=\"line\">        &quot;workers&quot;:1</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在config.json所在目录下运行sslocal即可：</p>\n<p>sslocal -c /etc/shadowsocks/config.json</p>\n<p>也可以手动指定参数运行：</p>\n<p>sslocal -s 服务器地址 -p 服务器端口 -l 本地端端口 -k 密码 -m 加密方法</p>\n<h3 id=\"使用chrome代理\"><a href=\"#使用chrome代理\" class=\"headerlink\" title=\"使用chrome代理\"></a>使用chrome代理</h3><p>在chrome应用商店中查找 Proxy SwitchyOmega,并安装该扩展</p>\n<p>新建情景模式，代理协议选择SOCKS5，代理服务器选择 127.0.0.1， 代理端口选择上一步中的local_port,即1080</p>\n<p>启用该扩展程序，此时可顺利使用google了 </p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"安装vim\"><a href=\"#安装vim\" class=\"headerlink\" title=\"安装vim\"></a>安装vim</h3><p>vim编辑器需要安装三个包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim-enhanced-7.0.109-7.el5</div><div class=\"line\">vim-minimal-7.0.109-7.el5</div><div class=\"line\">vim-common-7.0.109-7.el5</div></pre></td></tr></table></figure>\n<p>输入  <code>rpm -qa|grep vim</code> 这个命令，如何vim已经正确安装，则会显示上面三个包的名称</p>\n<p>如果缺少了其中某个，比如说： vim-enhanced这个包少了，执行：<code>yum -y install vim-enhanced</code> 命令，它会自动下载安装</p>\n<p>如果上面三个包一个都没有显示，则直接输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum -y install vim*</div></pre></td></tr></table></figure>\n<h3 id=\"安装net-tools\"><a href=\"#安装net-tools\" class=\"headerlink\" title=\"安装net-tools\"></a>安装net-tools</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install net-tools</div></pre></td></tr></table></figure>\n<h3 id=\"更改文件所有者\"><a href=\"#更改文件所有者\" class=\"headerlink\" title=\"更改文件所有者\"></a>更改文件所有者</h3><p>chown -R www.www ./    将本路径下所有文件所有者改为www组的www</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://teddysun.com/342.html\">Shadowsocks Python版一键安装脚本</a></p>\n<p><a href=\"https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/\">使用 Shadowsocks 自建翻墙服务器，实现全平台 100% 翻墙无障碍</a></p>\n<p><a href=\"http://shadowsocks.org/en/download/clients.html\">http://shadowsocks.org/</a></p>\n<p><a href=\"http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/\">shadowsocks（影梭）不完全指南</a></p>\n"},{"layout":"post","title":"java编程技巧","date":"2016-07-24T04:48:55.000Z","_content":"\n>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~\n\n **1**. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层\n\n **2**. if语句中,判断条件尽量不要使用if(!...)的形式，这样只会使代码更加难以理解\n\n **3**. 循环内不要不断创建对象引用，而应该：\n\n```java\n     Object obj = null;\n     for (int i = 0; i <= count; i++) { \n      obj = new Object(); \n     }\n```\n\n **4**. 不要在循环条件中重复计算变量，比如：\n\n```java\n    for (int i = 0; i <= obj.size(); i++){...}\n```\n\n **5**. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字\n\n **6**. 尽量采用懒加载的策略，即在需要的时候才创建,例如：\n\n```java\n    String str = \"aaa\";\n    if (i == 1) { \n       list.add(str);\n    }\n```\n\n建议替换为：\n\n```java\n\n\tif (i == 1) { \n     String str = \"aaa\"; list.add(str);\n   }\n```\n\n\n **7**. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码\n\n **8**. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能\n\n **9**. 使用&& ,\\|\\| 操作符时，将首先需要满足的条件置于操作符之前。因为&& 和 \\|\\| 具有短路性。另外，体会if(e. key==k\\|\\|k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用\\|\\|将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）\n\n **10**. 尽量用for each语句代替for循环\n\n **11**. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。\n\n **12**. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。\n       \n```java\n    if(\"hello\".equals(variable)){...}\n```\n\n **13**. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：\n\n```java\n    if(string.indexof(character) != -1){...}`\n```\n\n应改为：\n\n```java\n    if(string.indexof(character) >0 ){...}\n```\n\n **14**. 避免意外的赋值，比如：\n \n```java\n    if(variable == 5){...}`\n```\n\n应改为：\n\n```java\n    if(5 == variable){...}\n```\n\n避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出`if(variable = 5)`这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~\n\n **15**. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：\n\n```java\n\tif(array.length > 0){...}\n```\n\n应改为：\n\n```java\n\tif(array != null && array.length > 0){...}\n```\n\n\n **16**. 确保只有一个退出点。比如：\n\n```java\n    private boolean isEligible(int age){\n\n    \tif(age > 18) {\n\n    \t\treturn true;\n\n    \t} else {\n\n            return false;\n    \t}\n\n    }\n```\n\n应改为：\n\n```java\n    private boolean isEligible(int age){\n    \tboolean result;\n\n    \tif(age > 18) {\n\n    \t\tresult = true;\n\n    \t} else {\n\n            result = false;\n    \t}\n\n    \treturn result;\n    }\n```\n\n **17**. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。\n\n```java\n \tprivate boolean isEligible(final int age){...}\n```\n\n **18**. 把多个if语句组合成单一if语句。比如：\n\n```java\n\tif(age > 18){\n\t\tif(!man){...}\n\t}\n```\n\n应改为：\n\n```java\n\tif(age > 18 && !man){...}\n```\n\n **19**.  尽量不返回null\n\n null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。\n\n **20**. if嵌套不超过三层。\n\n **21**. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)\n\n实现RandomAccess接口的代表类：ArrayList\n未实现RandomAccess接口的代表类：LinkedList\n\n\n\n","source":"_posts/java_Tips.md","raw":"---\nlayout: post\ntitle: \"java编程技巧\"\ncategories: 编程\ntags: \n- java\ndate:   2016-7-24 12:48:55\n---\n\n>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~\n\n **1**. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层\n\n **2**. if语句中,判断条件尽量不要使用if(!...)的形式，这样只会使代码更加难以理解\n\n **3**. 循环内不要不断创建对象引用，而应该：\n\n```java\n     Object obj = null;\n     for (int i = 0; i <= count; i++) { \n      obj = new Object(); \n     }\n```\n\n **4**. 不要在循环条件中重复计算变量，比如：\n\n```java\n    for (int i = 0; i <= obj.size(); i++){...}\n```\n\n **5**. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字\n\n **6**. 尽量采用懒加载的策略，即在需要的时候才创建,例如：\n\n```java\n    String str = \"aaa\";\n    if (i == 1) { \n       list.add(str);\n    }\n```\n\n建议替换为：\n\n```java\n\n\tif (i == 1) { \n     String str = \"aaa\"; list.add(str);\n   }\n```\n\n\n **7**. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码\n\n **8**. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能\n\n **9**. 使用&& ,\\|\\| 操作符时，将首先需要满足的条件置于操作符之前。因为&& 和 \\|\\| 具有短路性。另外，体会if(e. key==k\\|\\|k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用\\|\\|将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）\n\n **10**. 尽量用for each语句代替for循环\n\n **11**. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。\n\n **12**. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。\n       \n```java\n    if(\"hello\".equals(variable)){...}\n```\n\n **13**. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：\n\n```java\n    if(string.indexof(character) != -1){...}`\n```\n\n应改为：\n\n```java\n    if(string.indexof(character) >0 ){...}\n```\n\n **14**. 避免意外的赋值，比如：\n \n```java\n    if(variable == 5){...}`\n```\n\n应改为：\n\n```java\n    if(5 == variable){...}\n```\n\n避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出`if(variable = 5)`这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~\n\n **15**. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：\n\n```java\n\tif(array.length > 0){...}\n```\n\n应改为：\n\n```java\n\tif(array != null && array.length > 0){...}\n```\n\n\n **16**. 确保只有一个退出点。比如：\n\n```java\n    private boolean isEligible(int age){\n\n    \tif(age > 18) {\n\n    \t\treturn true;\n\n    \t} else {\n\n            return false;\n    \t}\n\n    }\n```\n\n应改为：\n\n```java\n    private boolean isEligible(int age){\n    \tboolean result;\n\n    \tif(age > 18) {\n\n    \t\tresult = true;\n\n    \t} else {\n\n            result = false;\n    \t}\n\n    \treturn result;\n    }\n```\n\n **17**. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。\n\n```java\n \tprivate boolean isEligible(final int age){...}\n```\n\n **18**. 把多个if语句组合成单一if语句。比如：\n\n```java\n\tif(age > 18){\n\t\tif(!man){...}\n\t}\n```\n\n应改为：\n\n```java\n\tif(age > 18 && !man){...}\n```\n\n **19**.  尽量不返回null\n\n null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。\n\n **20**. if嵌套不超过三层。\n\n **21**. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)\n\n实现RandomAccess接口的代表类：ArrayList\n未实现RandomAccess接口的代表类：LinkedList\n\n\n\n","slug":"java_Tips","published":1,"updated":"2016-11-30T14:32:49.905Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj42000adigctiwrc790","content":"<blockquote>\n<p>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~</p>\n</blockquote>\n<p> <strong>1</strong>. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层</p>\n<p> <strong>2</strong>. if语句中,判断条件尽量不要使用if(!…)的形式，这样只会使代码更加难以理解</p>\n<p> <strong>3</strong>. 循环内不要不断创建对象引用，而应该：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= count; i++) &#123; </div><div class=\"line\"> obj = <span class=\"keyword\">new</span> Object(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>4</strong>. 不要在循环条件中重复计算变量，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= obj.size(); i++)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>5</strong>. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字</p>\n<p> <strong>6</strong>. 尽量采用懒加载的策略，即在需要的时候才创建,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str = <span class=\"string\">\"aaa\"</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">   list.add(str);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>建议替换为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">    String str = <span class=\"string\">\"aaa\"</span>; list.add(str);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p> <strong>7</strong>. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码</p>\n<p> <strong>8</strong>. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能</p>\n<p> <strong>9</strong>. 使用&amp;&amp; ,|| 操作符时，将首先需要满足的条件置于操作符之前。因为&amp;&amp; 和 || 具有短路性。另外，体会if(e. key==k||k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用||将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）</p>\n<p> <strong>10</strong>. 尽量用for each语句代替for循环</p>\n<p> <strong>11</strong>. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。</p>\n<p> <strong>12</strong>. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">\"hello\"</span>.equals(variable))&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>13</strong>. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) != -<span class=\"number\">1</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) &gt;<span class=\"number\">0</span> )&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>14</strong>. 避免意外的赋值，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(variable == <span class=\"number\">5</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">5</span> == variable)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出<code>if(variable = 5)</code>这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~</p>\n<p> <strong>15</strong>. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array != <span class=\"keyword\">null</span> &amp;&amp; array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>16</strong>. 确保只有一个退出点。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">boolean</span> result;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tresult = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        result = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>17</strong>. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>18</strong>. 把多个if语句组合成单一if语句。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>)&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(!man)&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span> &amp;&amp; !man)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>19</strong>.  尽量不返回null</p>\n<p> null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。</p>\n<p> <strong>20</strong>. if嵌套不超过三层。</p>\n<p> <strong>21</strong>. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)</p>\n<p>实现RandomAccess接口的代表类：ArrayList<br>未实现RandomAccess接口的代表类：LinkedList</p>\n","excerpt":"","more":"<blockquote>\n<p>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~</p>\n</blockquote>\n<p> <strong>1</strong>. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层</p>\n<p> <strong>2</strong>. if语句中,判断条件尽量不要使用if(!…)的形式，这样只会使代码更加难以理解</p>\n<p> <strong>3</strong>. 循环内不要不断创建对象引用，而应该：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= count; i++) &#123; </div><div class=\"line\"> obj = <span class=\"keyword\">new</span> Object(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>4</strong>. 不要在循环条件中重复计算变量，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= obj.size(); i++)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>5</strong>. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字</p>\n<p> <strong>6</strong>. 尽量采用懒加载的策略，即在需要的时候才创建,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str = <span class=\"string\">\"aaa\"</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">   list.add(str);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>建议替换为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">    String str = <span class=\"string\">\"aaa\"</span>; list.add(str);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p> <strong>7</strong>. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码</p>\n<p> <strong>8</strong>. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能</p>\n<p> <strong>9</strong>. 使用&amp;&amp; ,|| 操作符时，将首先需要满足的条件置于操作符之前。因为&amp;&amp; 和 || 具有短路性。另外，体会if(e. key==k||k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用||将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）</p>\n<p> <strong>10</strong>. 尽量用for each语句代替for循环</p>\n<p> <strong>11</strong>. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。</p>\n<p> <strong>12</strong>. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">\"hello\"</span>.equals(variable))&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>13</strong>. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) != -<span class=\"number\">1</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) &gt;<span class=\"number\">0</span> )&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>14</strong>. 避免意外的赋值，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(variable == <span class=\"number\">5</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">5</span> == variable)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出<code>if(variable = 5)</code>这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~</p>\n<p> <strong>15</strong>. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array != <span class=\"keyword\">null</span> &amp;&amp; array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>16</strong>. 确保只有一个退出点。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">boolean</span> result;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tresult = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        result = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>17</strong>. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>18</strong>. 把多个if语句组合成单一if语句。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>)&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(!man)&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span> &amp;&amp; !man)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>19</strong>.  尽量不返回null</p>\n<p> null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。</p>\n<p> <strong>20</strong>. if嵌套不超过三层。</p>\n<p> <strong>21</strong>. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)</p>\n<p>实现RandomAccess接口的代表类：ArrayList<br>未实现RandomAccess接口的代表类：LinkedList</p>\n"},{"layout":"post","title":"通过HashMap认识equals与hashcode","date":"2016-04-28T04:48:55.000Z","_content":"\n>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。\n\n## 什么是hashcode,hashcode的作用是什么\n\nhashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。\n\n理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，根据hashcode可以找到记录的位置。\n\n按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。\n\nhashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。\n\n注：以下代码均来自jdk1.7\n\nString中hashCode()方法的实现：\n\n```java\npublic int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            char val[] = value;\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n}\n```\n\n## 什么是equals(Object obj)方法\n\nequals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：\n\n```java\npublic boolean equals(Object obj) {\n        return (this == obj);\n}\n```\n\n也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。\n\n这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。\n\nString中equals(Object obj)方法的实现：\n\n```java\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String) anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                            return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n}\n```\n\n## 在java中hashcode方法与equals方法的作用\n\n首先看一下HashMap中的put方法：\n\n```java\npublic V put(K key, V value) {\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n        if (key == null)\n            return putForNullKey(value);\n        int hash = hash(key);//得到hash值\n        int i = indexFor(hash, table.length);//找到槽\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n\n        modCount++;\n        addEntry(hash, key, value, i);\n        return null;\n    }\n\n```\n\n我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。\n\n首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：\n\n```java\nfinal int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n可以看到，这个方法里调用了key本身的hashCode方法，得到了key的hashcode，然后对该hashcode进行了一些移位操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，通过他可以找到记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？\n\n其实这样做的目的是为下面的函数做准备的，我们看接下来要执行的代码：\n\n`int i = indexFor(hash, table.length);`找到所谓的槽，也就是记录存在的位置。\n\n```\n/**\n  * Returns index for hash code h.\n  */\nstatic int indexFor(int h, int length) {\n     // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";\n    return h & (length-1);\n}\n```\n可以看到，indexFor(int h, int length)如何通过hashcode得到记录的位置。indexFor方法内部是一个取模运算，h是我们通过上面的hash方法得到的，length是散列表的长度。HashMap中的散列表是一个数组，通过取模运算能保证indexFor方法的返回值(记录的位置)一定在这个数组内，没有超过其长度。因为h往往是一个很大的数字(int可以表示40亿这么大的数字)，而散列表的初始长度是可以由我们指定的(默认是16),另一方面，就算给他这么大的数组，内存也是放不下的。所以取模运算是必须的。经过取模运算得到的才是真正的槽值。\n\n回到上一个问题，**为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？而不是直接使用key的hashcode的**？\n\n想明白这个问题，参考[JDK 源码中 HashMap 的 hash 方法原理是什么？](https://www.zhihu.com/question/20733617)。我们上面也说了这样做的目的是为indexFor方法做准备的，总的来说就是为了让取模运算不会出现一种极端情况：**大量的不同的h经过取模后返回同样的槽值**。这样会带来严重的性能问题，也就是严重的冲突情况导致性能下降。关于冲突，看下文。\n\n要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。\n\n散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？\n\n比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？也就是说，无限多的元素通过散列函数映射到有穷集合上，一定会产生冲突。这也是我们理解hashcode的一个重要的点：**不同的对象(equals返回false)可以有相同的hashcode**。\n\n那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：\n\n{% asset_img entry.png 冲突 %}\n\n其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3....为散列表的索引位置。\n\n接下来的代码  `for (Entry<K,V> e = table[i]; e != null; e = e.next)`就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：`addEntry(hash, key, value, i);`.\n\n那么，怎么判断两个关键码在逻辑上是否相同呢？\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`\n\n可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：·`e.hash == hash `。为什么要加这样的判断？回头看看indexFor方法，经过取模运算后，不同的hashcode可以被散列在同一个槽中。通过这句代码可以将那些因为取模运算散列到同一个槽里的不同对象排除。\n\n我们知道**不同的对象(equals返回false)可以有相同的hashcode**。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：**相同的对象(equals返回true)hashcode一定相等**。\n\n`e.hash == hash && ((k = e.key) == key`：这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断**关键码是否相等**，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。\n\n`key.equals(k)`：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`这句代码中其实包含了一种短路思想，\\|\\| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。\n\n至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。\n\n## 总结\n\n通过上面的分析，我们知道了hashcode与equals的几个关键：\n\n#### 1.**不同的对象(equals返回false)可以有相同的hashcode**\n\n#### 2.**相同的对象(equals返回true)hashcode一定相等**\n\n#### 3.**若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义**（对1、2的遵守）\n\n[关于如何重写equals方法与hashCode方法](http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java)\n\n## equals与==\n\n\"==\" 比较的是两个对象的内存地址，是物理意义上的相等\n\nequals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等\n\n两个对象进行比较：\n\n**== 返回true，则equals一定返回true**；\n\n**equals返回true，== 不一定返回true**。\n\n\n\n\n\n\n\n","source":"_posts/java中的equals与hashcode.md","raw":"---\nlayout: post\ntitle:  \"通过HashMap认识equals与hashcode\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-28 12:48:55\n---\n\n>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。\n\n## 什么是hashcode,hashcode的作用是什么\n\nhashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。\n\n理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，根据hashcode可以找到记录的位置。\n\n按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。\n\nhashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。\n\n注：以下代码均来自jdk1.7\n\nString中hashCode()方法的实现：\n\n```java\npublic int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            char val[] = value;\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n}\n```\n\n## 什么是equals(Object obj)方法\n\nequals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：\n\n```java\npublic boolean equals(Object obj) {\n        return (this == obj);\n}\n```\n\n也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。\n\n这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。\n\nString中equals(Object obj)方法的实现：\n\n```java\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String) anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                            return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n}\n```\n\n## 在java中hashcode方法与equals方法的作用\n\n首先看一下HashMap中的put方法：\n\n```java\npublic V put(K key, V value) {\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n        if (key == null)\n            return putForNullKey(value);\n        int hash = hash(key);//得到hash值\n        int i = indexFor(hash, table.length);//找到槽\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n\n        modCount++;\n        addEntry(hash, key, value, i);\n        return null;\n    }\n\n```\n\n我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。\n\n首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：\n\n```java\nfinal int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n可以看到，这个方法里调用了key本身的hashCode方法，得到了key的hashcode，然后对该hashcode进行了一些移位操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，通过他可以找到记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？\n\n其实这样做的目的是为下面的函数做准备的，我们看接下来要执行的代码：\n\n`int i = indexFor(hash, table.length);`找到所谓的槽，也就是记录存在的位置。\n\n```\n/**\n  * Returns index for hash code h.\n  */\nstatic int indexFor(int h, int length) {\n     // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";\n    return h & (length-1);\n}\n```\n可以看到，indexFor(int h, int length)如何通过hashcode得到记录的位置。indexFor方法内部是一个取模运算，h是我们通过上面的hash方法得到的，length是散列表的长度。HashMap中的散列表是一个数组，通过取模运算能保证indexFor方法的返回值(记录的位置)一定在这个数组内，没有超过其长度。因为h往往是一个很大的数字(int可以表示40亿这么大的数字)，而散列表的初始长度是可以由我们指定的(默认是16),另一方面，就算给他这么大的数组，内存也是放不下的。所以取模运算是必须的。经过取模运算得到的才是真正的槽值。\n\n回到上一个问题，**为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？而不是直接使用key的hashcode的**？\n\n想明白这个问题，参考[JDK 源码中 HashMap 的 hash 方法原理是什么？](https://www.zhihu.com/question/20733617)。我们上面也说了这样做的目的是为indexFor方法做准备的，总的来说就是为了让取模运算不会出现一种极端情况：**大量的不同的h经过取模后返回同样的槽值**。这样会带来严重的性能问题，也就是严重的冲突情况导致性能下降。关于冲突，看下文。\n\n要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。\n\n散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？\n\n比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？也就是说，无限多的元素通过散列函数映射到有穷集合上，一定会产生冲突。这也是我们理解hashcode的一个重要的点：**不同的对象(equals返回false)可以有相同的hashcode**。\n\n那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：\n\n{% asset_img entry.png 冲突 %}\n\n其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3....为散列表的索引位置。\n\n接下来的代码  `for (Entry<K,V> e = table[i]; e != null; e = e.next)`就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：`addEntry(hash, key, value, i);`.\n\n那么，怎么判断两个关键码在逻辑上是否相同呢？\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`\n\n可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：·`e.hash == hash `。为什么要加这样的判断？回头看看indexFor方法，经过取模运算后，不同的hashcode可以被散列在同一个槽中。通过这句代码可以将那些因为取模运算散列到同一个槽里的不同对象排除。\n\n我们知道**不同的对象(equals返回false)可以有相同的hashcode**。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：**相同的对象(equals返回true)hashcode一定相等**。\n\n`e.hash == hash && ((k = e.key) == key`：这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断**关键码是否相等**，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。\n\n`key.equals(k)`：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`这句代码中其实包含了一种短路思想，\\|\\| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。\n\n至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。\n\n## 总结\n\n通过上面的分析，我们知道了hashcode与equals的几个关键：\n\n#### 1.**不同的对象(equals返回false)可以有相同的hashcode**\n\n#### 2.**相同的对象(equals返回true)hashcode一定相等**\n\n#### 3.**若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义**（对1、2的遵守）\n\n[关于如何重写equals方法与hashCode方法](http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java)\n\n## equals与==\n\n\"==\" 比较的是两个对象的内存地址，是物理意义上的相等\n\nequals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等\n\n两个对象进行比较：\n\n**== 返回true，则equals一定返回true**；\n\n**equals返回true，== 不一定返回true**。\n\n\n\n\n\n\n\n","slug":"java中的equals与hashcode","published":1,"updated":"2016-11-30T14:32:49.905Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj46000cdigcaoyuu06j","content":"<blockquote>\n<p>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。</p>\n</blockquote>\n<h2 id=\"什么是hashcode-hashcode的作用是什么\"><a href=\"#什么是hashcode-hashcode的作用是什么\" class=\"headerlink\" title=\"什么是hashcode,hashcode的作用是什么\"></a>什么是hashcode,hashcode的作用是什么</h2><p>hashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。</p>\n<p>理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，根据hashcode可以找到记录的位置。</p>\n<p>按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。</p>\n<p>hashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。</p>\n<p>注：以下代码均来自jdk1.7</p>\n<p>String中hashCode()方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hash;</div><div class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">char</span> val[] = value;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</div><div class=\"line\">                h = <span class=\"number\">31</span> * h + val[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            hash = h;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> h;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"什么是equals-Object-obj-方法\"><a href=\"#什么是equals-Object-obj-方法\" class=\"headerlink\" title=\"什么是equals(Object obj)方法\"></a>什么是equals(Object obj)方法</h2><p>equals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。</p>\n<p>这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。</p>\n<p>String中equals(Object obj)方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            String anotherString = (String) anObject;</div><div class=\"line\">            <span class=\"keyword\">int</span> n = value.length;</div><div class=\"line\">            <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> v1[] = value;</div><div class=\"line\">                <span class=\"keyword\">char</span> v2[] = anotherString.value;</div><div class=\"line\">                <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (v1[i] != v2[i])</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                    i++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"在java中hashcode方法与equals方法的作用\"><a href=\"#在java中hashcode方法与equals方法的作用\" class=\"headerlink\" title=\"在java中hashcode方法与equals方法的作用\"></a>在java中hashcode方法与equals方法的作用</h2><p>首先看一下HashMap中的put方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</div><div class=\"line\">            inflateTable(threshold);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> putForNullKey(value);</div><div class=\"line\">        <span class=\"keyword\">int</span> hash = hash(key);<span class=\"comment\">//得到hash值</span></div><div class=\"line\">        <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//找到槽</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\">            Object k;</div><div class=\"line\">            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class=\"line\">                V oldValue = e.value;</div><div class=\"line\">                e.value = value;</div><div class=\"line\">                e.recordAccess(<span class=\"keyword\">this</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        modCount++;</div><div class=\"line\">        addEntry(hash, key, value, i);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。</p>\n<p>首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hashSeed;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != h &amp;&amp; k <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        h ^= k.hashCode();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></div><div class=\"line\">        <span class=\"comment\">// constant multiples at each bit position have a bounded</span></div><div class=\"line\">        <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></div><div class=\"line\">        h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这个方法里调用了key本身的hashCode方法，得到了key的hashcode，然后对该hashcode进行了一些移位操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，通过他可以找到记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？</p>\n<p>其实这样做的目的是为下面的函数做准备的，我们看接下来要执行的代码：</p>\n<p><code>int i = indexFor(hash, table.length);</code>找到所谓的槽，也就是记录存在的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">  * Returns index for hash code h.</div><div class=\"line\">  */</div><div class=\"line\">static int indexFor(int h, int length) &#123;</div><div class=\"line\">     // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</div><div class=\"line\">    return h &amp; (length-1);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，indexFor(int h, int length)如何通过hashcode得到记录的位置。indexFor方法内部是一个取模运算，h是我们通过上面的hash方法得到的，length是散列表的长度。HashMap中的散列表是一个数组，通过取模运算能保证indexFor方法的返回值(记录的位置)一定在这个数组内，没有超过其长度。因为h往往是一个很大的数字(int可以表示40亿这么大的数字)，而散列表的初始长度是可以由我们指定的(默认是16),另一方面，就算给他这么大的数组，内存也是放不下的。所以取模运算是必须的。经过取模运算得到的才是真正的槽值。</p>\n<p>回到上一个问题，<strong>为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？而不是直接使用key的hashcode的</strong>？</p>\n<p>想明白这个问题，参考<a href=\"https://www.zhihu.com/question/20733617\" target=\"_blank\" rel=\"external\">JDK 源码中 HashMap 的 hash 方法原理是什么？</a>。我们上面也说了这样做的目的是为indexFor方法做准备的，总的来说就是为了让取模运算不会出现一种极端情况：<strong>大量的不同的h经过取模后返回同样的槽值</strong>。这样会带来严重的性能问题，也就是严重的冲突情况导致性能下降。关于冲突，看下文。</p>\n<p>要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。</p>\n<p>散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？</p>\n<p>比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？也就是说，无限多的元素通过散列函数映射到有穷集合上，一定会产生冲突。这也是我们理解hashcode的一个重要的点：<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。</p>\n<p>那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：</p>\n<img src=\"/2016/04/28/java中的equals与hashcode/entry.png\" alt=\"冲突\" title=\"冲突\">\n<p>其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3….为散列表的索引位置。</p>\n<p>接下来的代码  <code>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next)</code>就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：<code>addEntry(hash, key, value, i);</code>.</p>\n<p>那么，怎么判断两个关键码在逻辑上是否相同呢？</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code></p>\n<p>可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：·<code>e.hash == hash</code>。为什么要加这样的判断？回头看看indexFor方法，经过取模运算后，不同的hashcode可以被散列在同一个槽中。通过这句代码可以将那些因为取模运算散列到同一个槽里的不同对象排除。</p>\n<p>我们知道<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：<strong>相同的对象(equals返回true)hashcode一定相等</strong>。</p>\n<p><code>e.hash == hash &amp;&amp; ((k = e.key) == key</code>：这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断<strong>关键码是否相等</strong>，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。</p>\n<p><code>key.equals(k)</code>：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>这句代码中其实包含了一种短路思想，|| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。</p>\n<p>至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面的分析，我们知道了hashcode与equals的几个关键：</p>\n<h4 id=\"1-不同的对象-equals返回false-可以有相同的hashcode\"><a href=\"#1-不同的对象-equals返回false-可以有相同的hashcode\" class=\"headerlink\" title=\"1.不同的对象(equals返回false)可以有相同的hashcode\"></a>1.<strong>不同的对象(equals返回false)可以有相同的hashcode</strong></h4><h4 id=\"2-相同的对象-equals返回true-hashcode一定相等\"><a href=\"#2-相同的对象-equals返回true-hashcode一定相等\" class=\"headerlink\" title=\"2.相同的对象(equals返回true)hashcode一定相等\"></a>2.<strong>相同的对象(equals返回true)hashcode一定相等</strong></h4><h4 id=\"3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"><a href=\"#3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\" class=\"headerlink\" title=\"3.若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"></a>3.<strong>若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义</strong>（对1、2的遵守）</h4><p><a href=\"http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java\" target=\"_blank\" rel=\"external\">关于如何重写equals方法与hashCode方法</a></p>\n<h2 id=\"equals与\"><a href=\"#equals与\" class=\"headerlink\" title=\"equals与==\"></a>equals与==</h2><p>“==” 比较的是两个对象的内存地址，是物理意义上的相等</p>\n<p>equals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等</p>\n<p>两个对象进行比较：</p>\n<p><strong>== 返回true，则equals一定返回true</strong>；</p>\n<p><strong>equals返回true，== 不一定返回true</strong>。</p>\n","excerpt":"","more":"<blockquote>\n<p>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。</p>\n</blockquote>\n<h2 id=\"什么是hashcode-hashcode的作用是什么\"><a href=\"#什么是hashcode-hashcode的作用是什么\" class=\"headerlink\" title=\"什么是hashcode,hashcode的作用是什么\"></a>什么是hashcode,hashcode的作用是什么</h2><p>hashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。</p>\n<p>理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，根据hashcode可以找到记录的位置。</p>\n<p>按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。</p>\n<p>hashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。</p>\n<p>注：以下代码均来自jdk1.7</p>\n<p>String中hashCode()方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hash;</div><div class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">char</span> val[] = value;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</div><div class=\"line\">                h = <span class=\"number\">31</span> * h + val[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            hash = h;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> h;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"什么是equals-Object-obj-方法\"><a href=\"#什么是equals-Object-obj-方法\" class=\"headerlink\" title=\"什么是equals(Object obj)方法\"></a>什么是equals(Object obj)方法</h2><p>equals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。</p>\n<p>这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。</p>\n<p>String中equals(Object obj)方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            String anotherString = (String) anObject;</div><div class=\"line\">            <span class=\"keyword\">int</span> n = value.length;</div><div class=\"line\">            <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> v1[] = value;</div><div class=\"line\">                <span class=\"keyword\">char</span> v2[] = anotherString.value;</div><div class=\"line\">                <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (v1[i] != v2[i])</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                    i++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"在java中hashcode方法与equals方法的作用\"><a href=\"#在java中hashcode方法与equals方法的作用\" class=\"headerlink\" title=\"在java中hashcode方法与equals方法的作用\"></a>在java中hashcode方法与equals方法的作用</h2><p>首先看一下HashMap中的put方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</div><div class=\"line\">            inflateTable(threshold);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> putForNullKey(value);</div><div class=\"line\">        <span class=\"keyword\">int</span> hash = hash(key);<span class=\"comment\">//得到hash值</span></div><div class=\"line\">        <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//找到槽</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\">            Object k;</div><div class=\"line\">            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class=\"line\">                V oldValue = e.value;</div><div class=\"line\">                e.value = value;</div><div class=\"line\">                e.recordAccess(<span class=\"keyword\">this</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        modCount++;</div><div class=\"line\">        addEntry(hash, key, value, i);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。</p>\n<p>首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hashSeed;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != h &amp;&amp; k <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        h ^= k.hashCode();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></div><div class=\"line\">        <span class=\"comment\">// constant multiples at each bit position have a bounded</span></div><div class=\"line\">        <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></div><div class=\"line\">        h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这个方法里调用了key本身的hashCode方法，得到了key的hashcode，然后对该hashcode进行了一些移位操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，通过他可以找到记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？</p>\n<p>其实这样做的目的是为下面的函数做准备的，我们看接下来要执行的代码：</p>\n<p><code>int i = indexFor(hash, table.length);</code>找到所谓的槽，也就是记录存在的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">  * Returns index for hash code h.</div><div class=\"line\">  */</div><div class=\"line\">static int indexFor(int h, int length) &#123;</div><div class=\"line\">     // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</div><div class=\"line\">    return h &amp; (length-1);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，indexFor(int h, int length)如何通过hashcode得到记录的位置。indexFor方法内部是一个取模运算，h是我们通过上面的hash方法得到的，length是散列表的长度。HashMap中的散列表是一个数组，通过取模运算能保证indexFor方法的返回值(记录的位置)一定在这个数组内，没有超过其长度。因为h往往是一个很大的数字(int可以表示40亿这么大的数字)，而散列表的初始长度是可以由我们指定的(默认是16),另一方面，就算给他这么大的数组，内存也是放不下的。所以取模运算是必须的。经过取模运算得到的才是真正的槽值。</p>\n<p>回到上一个问题，<strong>为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？而不是直接使用key的hashcode的</strong>？</p>\n<p>想明白这个问题，参考<a href=\"https://www.zhihu.com/question/20733617\">JDK 源码中 HashMap 的 hash 方法原理是什么？</a>。我们上面也说了这样做的目的是为indexFor方法做准备的，总的来说就是为了让取模运算不会出现一种极端情况：<strong>大量的不同的h经过取模后返回同样的槽值</strong>。这样会带来严重的性能问题，也就是严重的冲突情况导致性能下降。关于冲突，看下文。</p>\n<p>要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。</p>\n<p>散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？</p>\n<p>比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？也就是说，无限多的元素通过散列函数映射到有穷集合上，一定会产生冲突。这也是我们理解hashcode的一个重要的点：<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。</p>\n<p>那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：</p>\n<img src=\"/2016/04/28/java中的equals与hashcode/entry.png\" alt=\"冲突\" title=\"冲突\">\n<p>其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3….为散列表的索引位置。</p>\n<p>接下来的代码  <code>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next)</code>就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：<code>addEntry(hash, key, value, i);</code>.</p>\n<p>那么，怎么判断两个关键码在逻辑上是否相同呢？</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code></p>\n<p>可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：·<code>e.hash == hash</code>。为什么要加这样的判断？回头看看indexFor方法，经过取模运算后，不同的hashcode可以被散列在同一个槽中。通过这句代码可以将那些因为取模运算散列到同一个槽里的不同对象排除。</p>\n<p>我们知道<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：<strong>相同的对象(equals返回true)hashcode一定相等</strong>。</p>\n<p><code>e.hash == hash &amp;&amp; ((k = e.key) == key</code>：这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断<strong>关键码是否相等</strong>，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。</p>\n<p><code>key.equals(k)</code>：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>这句代码中其实包含了一种短路思想，|| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。</p>\n<p>至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面的分析，我们知道了hashcode与equals的几个关键：</p>\n<h4 id=\"1-不同的对象-equals返回false-可以有相同的hashcode\"><a href=\"#1-不同的对象-equals返回false-可以有相同的hashcode\" class=\"headerlink\" title=\"1.不同的对象(equals返回false)可以有相同的hashcode\"></a>1.<strong>不同的对象(equals返回false)可以有相同的hashcode</strong></h4><h4 id=\"2-相同的对象-equals返回true-hashcode一定相等\"><a href=\"#2-相同的对象-equals返回true-hashcode一定相等\" class=\"headerlink\" title=\"2.相同的对象(equals返回true)hashcode一定相等\"></a>2.<strong>相同的对象(equals返回true)hashcode一定相等</strong></h4><h4 id=\"3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"><a href=\"#3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\" class=\"headerlink\" title=\"3.若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"></a>3.<strong>若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义</strong>（对1、2的遵守）</h4><p><a href=\"http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java\">关于如何重写equals方法与hashCode方法</a></p>\n<h2 id=\"equals与\"><a href=\"#equals与\" class=\"headerlink\" title=\"equals与==\"></a>equals与==</h2><p>“==” 比较的是两个对象的内存地址，是物理意义上的相等</p>\n<p>equals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等</p>\n<p>两个对象进行比较：</p>\n<p><strong>== 返回true，则equals一定返回true</strong>；</p>\n<p><strong>equals返回true，== 不一定返回true</strong>。</p>\n"},{"layout":"post","title":"java 中的int/byte转换","date":"2016-11-24T14:48:55.000Z","_content":"\n## 前言\n\n好久没有动博客了，看了下，将近两个月了吧。最近的两个月里面变懒了，没有了记录的动力。。。最近好像也没啥收获，惭愧。之前电脑中病毒之后(cryptolcker)，还好没有神马重要的东西，索性把硬盘重新格式化一遍，重做了系统。保留一套windows（实在受不了win10的自动更新了...）,又装了一套opensuse的系统。希望可以坚持学点linux。\n\n这段时间没有怎么看书，说一下读书情况。《重构》这本还是没有看完，读了大半。《深入理解jvm虚拟机》这本算是大致上浏览了一遍，发现确实是一本挺好的java书籍，日后还需多加翻阅理解。《大话设计模式》也是浏览了一遍，其中比较常见的模式有时候也可以用到，需要的时候再看吧。双十一买了一本《java并发编程实战》，看了大半，似懂非懂，但也是有收获的。不得不吐槽一下该书的翻译，实在是不敢恭维，但是想想自己的英语水平，目前还是忍了。。\n\n必须要振作起精神来了，总觉得自己每天无所事事呢。接下来的计划.....还是把并发编程这块看完吧，虽然没有什么实战的机会，总比不看强。要多写总结了，不然看了跟不看差不多。异常、反射、动态代理、注解等等这些也要学习然后做一个记录。网络、io、并发这三块，并发还在看，也要做好记录，然后网络这部分把大学课本重读一遍，至于io不知道有什么好的书籍，放到最后规划学习把。\n\n嗯，又想起来最近还写了一个自动打卡的程序，增加了短信通知的功能。总觉得有些不诚信的感觉呢，但是没有迟到早退过呀，好玩罢了。读了webmagic的core部分的源码，感觉理解起来轻松许多。记得大学那会看这个的时候还是一头雾水，结果现在两个小时就把代码搞清楚了（主要是代码量也不大拉）。嗯，说明自己还是在进步的麻，哈哈哈。下载了junit的源码都没有看过，有空研究把。\n\n终于要进入正题了。这次的记录很短很简单，是关于java中int和byte之间的转换的。虽然简单，但是以前就是拿来即用，没有搞清楚其中的原理，在byte这块就很纠结（只能说基础比较差），今天来学习一下。\n\n--------------------------------------------------\n\n## 正文\n\njava中:\n\nbyte: 1字节    int: 4字节\n\n```java\nint i = -123\nbyte x = (byte)i; //-123\n```\nps：([]代表几进制，()代表前面的内容重复几次)\n\nps:\n\n-123[2] = 11111111(3)10000101\n\nint 强转为 byte，直接截取低8位即10000101\n\njava把byte当做有符号处理，故此时x=-123\n\n```java\nint j = (int)x; //-123\n```\nps:\n\nbyte强转为int，高24位补1(自动扩展)\n\n此时，j[2]=11111111(3)11101010\n\n即，j=-123\n\n负数似乎没有问题...\n\n--------------------------------------------------\n```java\nint i = 234;\nbyte x = (byte)i; //-22\n```\nps:\n\n234[2] = 00000000(3)11101010\n\nint 强转为 byte，直接截取低8位即11101010\n\njava把byte当做有符号处理，故此时x=-22\n\n```java\nint j = (int)x; //-22\n```\nps:\n\nbyte强转为int，高24位补1（自动扩展）\n\n此时，j[2]=11111111(3)11101010\n\n即，j=-22\n\n可见，byte单纯的强转为int是行不通的。(注意，示例中int强转为一个byte,如果int值超过255,发生数据丢失，正确的int转为4字节byte方法见下文)\n\n--------------------------------------------------\n```java\nint i = 234;\nbyte x = (byte)i; //-22\nint j = x & 0xFF; //j=234\n```\nps:\n\nx & 0xFF = 00000000(3)11101010\n\n即，j=234\n\n可见0xFF的作用...\n\n--------------------------------------------------\n\n- http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/\n\nbyte short char 他们三者在计算时，首先会转换为int类型,故下面几个表达式进行|运算时，是int类型之间的|运算，存在自动扩展(移位操作也会出现这种情况,即int转byte的时候),不进行& 0xFF的运算，则有可能造成第一种情况的出现。\n\n- java字节序\n\njava为大端字节序（bigendian）：高字节数据存放在低地址处，低字节数据存放在高地址处。\n\n0x01020304\n\n故b[0]=0x01,b[1]=0x02,b[2]=0x03,b[3]=0x04\n\n```java\n//byte 数组与 int 的相互转换  \npublic static int byteArrayToInt(byte[] b) {  \n    return   b[3] & 0xFF |  \n            (b[2] & 0xFF) << 8 |  \n            (b[1] & 0xFF) << 16 |  \n            (b[0] & 0xFF) << 24;  \n}  \n  \npublic static byte[] intToByteArray(int a) {  \n    return new byte[] {  \n        (byte) ((a >> 24) & 0xFF),  \n        (byte) ((a >> 16) & 0xFF),     \n        (byte) ((a >> 8) & 0xFF),     \n        (byte) (a & 0xFF)  \n    };  \n}  \n```\n","source":"_posts/java中的int\\byte互转.md","raw":"---\nlayout: post\ntitle:  \"java 中的int/byte转换\"\ncategories: 编程\ntags: \n- java\ndate:   2016-11-24 22:48:55\n---\n\n## 前言\n\n好久没有动博客了，看了下，将近两个月了吧。最近的两个月里面变懒了，没有了记录的动力。。。最近好像也没啥收获，惭愧。之前电脑中病毒之后(cryptolcker)，还好没有神马重要的东西，索性把硬盘重新格式化一遍，重做了系统。保留一套windows（实在受不了win10的自动更新了...）,又装了一套opensuse的系统。希望可以坚持学点linux。\n\n这段时间没有怎么看书，说一下读书情况。《重构》这本还是没有看完，读了大半。《深入理解jvm虚拟机》这本算是大致上浏览了一遍，发现确实是一本挺好的java书籍，日后还需多加翻阅理解。《大话设计模式》也是浏览了一遍，其中比较常见的模式有时候也可以用到，需要的时候再看吧。双十一买了一本《java并发编程实战》，看了大半，似懂非懂，但也是有收获的。不得不吐槽一下该书的翻译，实在是不敢恭维，但是想想自己的英语水平，目前还是忍了。。\n\n必须要振作起精神来了，总觉得自己每天无所事事呢。接下来的计划.....还是把并发编程这块看完吧，虽然没有什么实战的机会，总比不看强。要多写总结了，不然看了跟不看差不多。异常、反射、动态代理、注解等等这些也要学习然后做一个记录。网络、io、并发这三块，并发还在看，也要做好记录，然后网络这部分把大学课本重读一遍，至于io不知道有什么好的书籍，放到最后规划学习把。\n\n嗯，又想起来最近还写了一个自动打卡的程序，增加了短信通知的功能。总觉得有些不诚信的感觉呢，但是没有迟到早退过呀，好玩罢了。读了webmagic的core部分的源码，感觉理解起来轻松许多。记得大学那会看这个的时候还是一头雾水，结果现在两个小时就把代码搞清楚了（主要是代码量也不大拉）。嗯，说明自己还是在进步的麻，哈哈哈。下载了junit的源码都没有看过，有空研究把。\n\n终于要进入正题了。这次的记录很短很简单，是关于java中int和byte之间的转换的。虽然简单，但是以前就是拿来即用，没有搞清楚其中的原理，在byte这块就很纠结（只能说基础比较差），今天来学习一下。\n\n--------------------------------------------------\n\n## 正文\n\njava中:\n\nbyte: 1字节    int: 4字节\n\n```java\nint i = -123\nbyte x = (byte)i; //-123\n```\nps：([]代表几进制，()代表前面的内容重复几次)\n\nps:\n\n-123[2] = 11111111(3)10000101\n\nint 强转为 byte，直接截取低8位即10000101\n\njava把byte当做有符号处理，故此时x=-123\n\n```java\nint j = (int)x; //-123\n```\nps:\n\nbyte强转为int，高24位补1(自动扩展)\n\n此时，j[2]=11111111(3)11101010\n\n即，j=-123\n\n负数似乎没有问题...\n\n--------------------------------------------------\n```java\nint i = 234;\nbyte x = (byte)i; //-22\n```\nps:\n\n234[2] = 00000000(3)11101010\n\nint 强转为 byte，直接截取低8位即11101010\n\njava把byte当做有符号处理，故此时x=-22\n\n```java\nint j = (int)x; //-22\n```\nps:\n\nbyte强转为int，高24位补1（自动扩展）\n\n此时，j[2]=11111111(3)11101010\n\n即，j=-22\n\n可见，byte单纯的强转为int是行不通的。(注意，示例中int强转为一个byte,如果int值超过255,发生数据丢失，正确的int转为4字节byte方法见下文)\n\n--------------------------------------------------\n```java\nint i = 234;\nbyte x = (byte)i; //-22\nint j = x & 0xFF; //j=234\n```\nps:\n\nx & 0xFF = 00000000(3)11101010\n\n即，j=234\n\n可见0xFF的作用...\n\n--------------------------------------------------\n\n- http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/\n\nbyte short char 他们三者在计算时，首先会转换为int类型,故下面几个表达式进行|运算时，是int类型之间的|运算，存在自动扩展(移位操作也会出现这种情况,即int转byte的时候),不进行& 0xFF的运算，则有可能造成第一种情况的出现。\n\n- java字节序\n\njava为大端字节序（bigendian）：高字节数据存放在低地址处，低字节数据存放在高地址处。\n\n0x01020304\n\n故b[0]=0x01,b[1]=0x02,b[2]=0x03,b[3]=0x04\n\n```java\n//byte 数组与 int 的相互转换  \npublic static int byteArrayToInt(byte[] b) {  \n    return   b[3] & 0xFF |  \n            (b[2] & 0xFF) << 8 |  \n            (b[1] & 0xFF) << 16 |  \n            (b[0] & 0xFF) << 24;  \n}  \n  \npublic static byte[] intToByteArray(int a) {  \n    return new byte[] {  \n        (byte) ((a >> 24) & 0xFF),  \n        (byte) ((a >> 16) & 0xFF),     \n        (byte) ((a >> 8) & 0xFF),     \n        (byte) (a & 0xFF)  \n    };  \n}  \n```\n","slug":"java中的int\\byte互转","published":1,"updated":"2016-11-30T14:32:49.905Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj4a000hdigcdin43lw7","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>好久没有动博客了，看了下，将近两个月了吧。最近的两个月里面变懒了，没有了记录的动力。。。最近好像也没啥收获，惭愧。之前电脑中病毒之后(cryptolcker)，还好没有神马重要的东西，索性把硬盘重新格式化一遍，重做了系统。保留一套windows（实在受不了win10的自动更新了…）,又装了一套opensuse的系统。希望可以坚持学点linux。</p>\n<p>这段时间没有怎么看书，说一下读书情况。《重构》这本还是没有看完，读了大半。《深入理解jvm虚拟机》这本算是大致上浏览了一遍，发现确实是一本挺好的java书籍，日后还需多加翻阅理解。《大话设计模式》也是浏览了一遍，其中比较常见的模式有时候也可以用到，需要的时候再看吧。双十一买了一本《java并发编程实战》，看了大半，似懂非懂，但也是有收获的。不得不吐槽一下该书的翻译，实在是不敢恭维，但是想想自己的英语水平，目前还是忍了。。</p>\n<p>必须要振作起精神来了，总觉得自己每天无所事事呢。接下来的计划…..还是把并发编程这块看完吧，虽然没有什么实战的机会，总比不看强。要多写总结了，不然看了跟不看差不多。异常、反射、动态代理、注解等等这些也要学习然后做一个记录。网络、io、并发这三块，并发还在看，也要做好记录，然后网络这部分把大学课本重读一遍，至于io不知道有什么好的书籍，放到最后规划学习把。</p>\n<p>嗯，又想起来最近还写了一个自动打卡的程序，增加了短信通知的功能。总觉得有些不诚信的感觉呢，但是没有迟到早退过呀，好玩罢了。读了webmagic的core部分的源码，感觉理解起来轻松许多。记得大学那会看这个的时候还是一头雾水，结果现在两个小时就把代码搞清楚了（主要是代码量也不大拉）。嗯，说明自己还是在进步的麻，哈哈哈。下载了junit的源码都没有看过，有空研究把。</p>\n<p>终于要进入正题了。这次的记录很短很简单，是关于java中int和byte之间的转换的。虽然简单，但是以前就是拿来即用，没有搞清楚其中的原理，在byte这块就很纠结（只能说基础比较差），今天来学习一下。</p>\n<hr>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>java中:</p>\n<p>byte: 1字节    int: 4字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = -<span class=\"number\">123</span></div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-123</span></div></pre></td></tr></table></figure>\n<p>ps：([]代表几进制，()代表前面的内容重复几次)</p>\n<p>ps:</p>\n<p>-123[2] = 11111111(3)10000101</p>\n<p>int 强转为 byte，直接截取低8位即10000101</p>\n<p>java把byte当做有符号处理，故此时x=-123</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j = (<span class=\"keyword\">int</span>)x; <span class=\"comment\">//-123</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>byte强转为int，高24位补1(自动扩展)</p>\n<p>此时，j[2]=11111111(3)11101010</p>\n<p>即，j=-123</p>\n<p>负数似乎没有问题…</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">234</span>;</div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-22</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>234[2] = 00000000(3)11101010</p>\n<p>int 强转为 byte，直接截取低8位即11101010</p>\n<p>java把byte当做有符号处理，故此时x=-22</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j = (<span class=\"keyword\">int</span>)x; <span class=\"comment\">//-22</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>byte强转为int，高24位补1（自动扩展）</p>\n<p>此时，j[2]=11111111(3)11101010</p>\n<p>即，j=-22</p>\n<p>可见，byte单纯的强转为int是行不通的。(注意，示例中int强转为一个byte,如果int值超过255,发生数据丢失，正确的int转为4字节byte方法见下文)</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">234</span>;</div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-22</span></div><div class=\"line\"><span class=\"keyword\">int</span> j = x &amp; <span class=\"number\">0xFF</span>; <span class=\"comment\">//j=234</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>x &amp; 0xFF = 00000000(3)11101010</p>\n<p>即，j=234</p>\n<p>可见0xFF的作用…</p>\n<hr>\n<ul>\n<li><a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/\">http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</a></li>\n</ul>\n<p>byte short char 他们三者在计算时，首先会转换为int类型,故下面几个表达式进行|运算时，是int类型之间的|运算，存在自动扩展(移位操作也会出现这种情况,即int转byte的时候),不进行&amp; 0xFF的运算，则有可能造成第一种情况的出现。</p>\n<ul>\n<li>java字节序</li>\n</ul>\n<p>java为大端字节序（bigendian）：高字节数据存放在低地址处，低字节数据存放在高地址处。</p>\n<p>0x01020304</p>\n<p>故b[0]=0x01,b[1]=0x02,b[2]=0x03,b[3]=0x04</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//byte 数组与 int 的相互转换  </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">byteArrayToInt</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span>   b[<span class=\"number\">3</span>] &amp; <span class=\"number\">0xFF</span> |  </div><div class=\"line\">            (b[<span class=\"number\">2</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">8</span> |  </div><div class=\"line\">            (b[<span class=\"number\">1</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">16</span> |  </div><div class=\"line\">            (b[<span class=\"number\">0</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">24</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] intToByteArray(<span class=\"keyword\">int</span> a) &#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[] &#123;  </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">24</span>) &amp; <span class=\"number\">0xFF</span>),  </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>),     </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xFF</span>),     </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) (a &amp; <span class=\"number\">0xFF</span>)  </div><div class=\"line\">    &#125;;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>好久没有动博客了，看了下，将近两个月了吧。最近的两个月里面变懒了，没有了记录的动力。。。最近好像也没啥收获，惭愧。之前电脑中病毒之后(cryptolcker)，还好没有神马重要的东西，索性把硬盘重新格式化一遍，重做了系统。保留一套windows（实在受不了win10的自动更新了…）,又装了一套opensuse的系统。希望可以坚持学点linux。</p>\n<p>这段时间没有怎么看书，说一下读书情况。《重构》这本还是没有看完，读了大半。《深入理解jvm虚拟机》这本算是大致上浏览了一遍，发现确实是一本挺好的java书籍，日后还需多加翻阅理解。《大话设计模式》也是浏览了一遍，其中比较常见的模式有时候也可以用到，需要的时候再看吧。双十一买了一本《java并发编程实战》，看了大半，似懂非懂，但也是有收获的。不得不吐槽一下该书的翻译，实在是不敢恭维，但是想想自己的英语水平，目前还是忍了。。</p>\n<p>必须要振作起精神来了，总觉得自己每天无所事事呢。接下来的计划…..还是把并发编程这块看完吧，虽然没有什么实战的机会，总比不看强。要多写总结了，不然看了跟不看差不多。异常、反射、动态代理、注解等等这些也要学习然后做一个记录。网络、io、并发这三块，并发还在看，也要做好记录，然后网络这部分把大学课本重读一遍，至于io不知道有什么好的书籍，放到最后规划学习把。</p>\n<p>嗯，又想起来最近还写了一个自动打卡的程序，增加了短信通知的功能。总觉得有些不诚信的感觉呢，但是没有迟到早退过呀，好玩罢了。读了webmagic的core部分的源码，感觉理解起来轻松许多。记得大学那会看这个的时候还是一头雾水，结果现在两个小时就把代码搞清楚了（主要是代码量也不大拉）。嗯，说明自己还是在进步的麻，哈哈哈。下载了junit的源码都没有看过，有空研究把。</p>\n<p>终于要进入正题了。这次的记录很短很简单，是关于java中int和byte之间的转换的。虽然简单，但是以前就是拿来即用，没有搞清楚其中的原理，在byte这块就很纠结（只能说基础比较差），今天来学习一下。</p>\n<hr>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>java中:</p>\n<p>byte: 1字节    int: 4字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = -<span class=\"number\">123</span></div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-123</span></div></pre></td></tr></table></figure>\n<p>ps：([]代表几进制，()代表前面的内容重复几次)</p>\n<p>ps:</p>\n<p>-123[2] = 11111111(3)10000101</p>\n<p>int 强转为 byte，直接截取低8位即10000101</p>\n<p>java把byte当做有符号处理，故此时x=-123</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j = (<span class=\"keyword\">int</span>)x; <span class=\"comment\">//-123</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>byte强转为int，高24位补1(自动扩展)</p>\n<p>此时，j[2]=11111111(3)11101010</p>\n<p>即，j=-123</p>\n<p>负数似乎没有问题…</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">234</span>;</div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-22</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>234[2] = 00000000(3)11101010</p>\n<p>int 强转为 byte，直接截取低8位即11101010</p>\n<p>java把byte当做有符号处理，故此时x=-22</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j = (<span class=\"keyword\">int</span>)x; <span class=\"comment\">//-22</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>byte强转为int，高24位补1（自动扩展）</p>\n<p>此时，j[2]=11111111(3)11101010</p>\n<p>即，j=-22</p>\n<p>可见，byte单纯的强转为int是行不通的。(注意，示例中int强转为一个byte,如果int值超过255,发生数据丢失，正确的int转为4字节byte方法见下文)</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">234</span>;</div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-22</span></div><div class=\"line\"><span class=\"keyword\">int</span> j = x &amp; <span class=\"number\">0xFF</span>; <span class=\"comment\">//j=234</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>x &amp; 0xFF = 00000000(3)11101010</p>\n<p>即，j=234</p>\n<p>可见0xFF的作用…</p>\n<hr>\n<ul>\n<li><a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/\">http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</a></li>\n</ul>\n<p>byte short char 他们三者在计算时，首先会转换为int类型,故下面几个表达式进行|运算时，是int类型之间的|运算，存在自动扩展(移位操作也会出现这种情况,即int转byte的时候),不进行&amp; 0xFF的运算，则有可能造成第一种情况的出现。</p>\n<ul>\n<li>java字节序</li>\n</ul>\n<p>java为大端字节序（bigendian）：高字节数据存放在低地址处，低字节数据存放在高地址处。</p>\n<p>0x01020304</p>\n<p>故b[0]=0x01,b[1]=0x02,b[2]=0x03,b[3]=0x04</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//byte 数组与 int 的相互转换  </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">byteArrayToInt</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span>   b[<span class=\"number\">3</span>] &amp; <span class=\"number\">0xFF</span> |  </div><div class=\"line\">            (b[<span class=\"number\">2</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">8</span> |  </div><div class=\"line\">            (b[<span class=\"number\">1</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">16</span> |  </div><div class=\"line\">            (b[<span class=\"number\">0</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">24</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] intToByteArray(<span class=\"keyword\">int</span> a) &#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[] &#123;  </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">24</span>) &amp; <span class=\"number\">0xFF</span>),  </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>),     </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xFF</span>),     </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) (a &amp; <span class=\"number\">0xFF</span>)  </div><div class=\"line\">    &#125;;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"java中的枚举","date":"2016-06-30T04:48:55.000Z","_content":"\n> 已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。\n\nJava中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。\n  \n## 使用场景：\n\n每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。\n\n## 与 public static final 的常量定义方式进行比较：\n\n在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：\n\n```java\npublic class State {\n\tpublic static final int Normal = 0;//正常\n\tpublic static final int Update = 1;//已更新\n\tpublic static final int Delete = 2;//已删除\n}\n```\n\n使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：\n\n```java\npublic void doSomething(int state){\n\tswitch(state){\n\t\tcase State.Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Update:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n1. 在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。\n\n2. 另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。\n\n3. 因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。\n\n那如果换成枚举常量呢？\n\n```java\npublic enum State {\n\tNormal,Update,Delete\n}\n```\n\n类型安全检查：\n\n```java\npublic void doSomething(State state){\n\tswitch(state){\n\t\tcase Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase Update:\n\t\t  ...\n\t\t  break;\n\t\tcase Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。\n\n另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。\n\n## 枚举类型的使用\n\n- **常量**：\n\n```java\npublic enum State{\n\tNormal,Update,Delete\n}\n```\n\n遍历枚举常量：\n\n```java\n   for(State state:State.values()){\n   \t\tSystem.out.println(state);\n   }\n```\n\n- **自定义属性、方法**：\n\n```java\npublic enum State{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }    \n}\n\npublic void test(){\n\tfor (State state : State.values()) {\n\t    //输出：正常:0 已更新:1 已删除:2\n\t\tSystem.out.println(state);\n\t}\n}\n```\n\n实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。\n其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。\n\n因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。\n\n- **实现接口**\n\n```java\npublic interface HandleState{\n\tvoid printState();\n}\n\npublic enum State implements HandleState{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }  \n\n    public void printState() {\n\t\tSystem.out.println(this);\n\t}\n}\n```\n\n可以看到，枚举和一般的类一样都可以实现接口。\n\n- **Enum 相关工具类**\n\nJDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。\n\n## 参考\n\n[java enum的用法详解[转]](https://hacpai.com/article/1437056657634)\n\n[Java 语言中Enum类型的使用介绍](https://www.ibm.com/developerworks/cn/java/j-lo-enum/)","source":"_posts/java中的枚举.md","raw":"---\nlayout: post\ntitle:  \"java中的枚举\"\ncategories: 编程\ntags: \n- java\ndate:   2016-06-30 12:48:55\n---\n\n> 已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。\n\nJava中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。\n  \n## 使用场景：\n\n每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。\n\n## 与 public static final 的常量定义方式进行比较：\n\n在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：\n\n```java\npublic class State {\n\tpublic static final int Normal = 0;//正常\n\tpublic static final int Update = 1;//已更新\n\tpublic static final int Delete = 2;//已删除\n}\n```\n\n使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：\n\n```java\npublic void doSomething(int state){\n\tswitch(state){\n\t\tcase State.Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Update:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n1. 在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。\n\n2. 另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。\n\n3. 因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。\n\n那如果换成枚举常量呢？\n\n```java\npublic enum State {\n\tNormal,Update,Delete\n}\n```\n\n类型安全检查：\n\n```java\npublic void doSomething(State state){\n\tswitch(state){\n\t\tcase Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase Update:\n\t\t  ...\n\t\t  break;\n\t\tcase Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。\n\n另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。\n\n## 枚举类型的使用\n\n- **常量**：\n\n```java\npublic enum State{\n\tNormal,Update,Delete\n}\n```\n\n遍历枚举常量：\n\n```java\n   for(State state:State.values()){\n   \t\tSystem.out.println(state);\n   }\n```\n\n- **自定义属性、方法**：\n\n```java\npublic enum State{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }    \n}\n\npublic void test(){\n\tfor (State state : State.values()) {\n\t    //输出：正常:0 已更新:1 已删除:2\n\t\tSystem.out.println(state);\n\t}\n}\n```\n\n实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。\n其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。\n\n因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。\n\n- **实现接口**\n\n```java\npublic interface HandleState{\n\tvoid printState();\n}\n\npublic enum State implements HandleState{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }  \n\n    public void printState() {\n\t\tSystem.out.println(this);\n\t}\n}\n```\n\n可以看到，枚举和一般的类一样都可以实现接口。\n\n- **Enum 相关工具类**\n\nJDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。\n\n## 参考\n\n[java enum的用法详解[转]](https://hacpai.com/article/1437056657634)\n\n[Java 语言中Enum类型的使用介绍](https://www.ibm.com/developerworks/cn/java/j-lo-enum/)","slug":"java中的枚举","published":1,"updated":"2016-11-30T14:32:49.909Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj4e000kdigc1ehh7z07","content":"<blockquote>\n<p>已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。</p>\n</blockquote>\n<p>Java中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。</p>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><p>每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。</p>\n<h2 id=\"与-public-static-final-的常量定义方式进行比较：\"><a href=\"#与-public-static-final-的常量定义方式进行比较：\" class=\"headerlink\" title=\"与 public static final 的常量定义方式进行比较：\"></a>与 public static final 的常量定义方式进行比较：</h2><p>在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">State</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Normal = <span class=\"number\">0</span>;<span class=\"comment\">//正常</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Update = <span class=\"number\">1</span>;<span class=\"comment\">//已更新</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Delete = <span class=\"number\">2</span>;<span class=\"comment\">//已删除</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。</p>\n</li>\n<li><p>另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。</p>\n</li>\n<li><p>因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。</p>\n</li>\n</ol>\n<p>那如果换成枚举常量呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类型安全检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(State state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。</p>\n<p>另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。</p>\n<h2 id=\"枚举类型的使用\"><a href=\"#枚举类型的使用\" class=\"headerlink\" title=\"枚举类型的使用\"></a>枚举类型的使用</h2><ul>\n<li><strong>常量</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遍历枚举常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(State state:State.values())&#123;</div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>自定义属性、方法</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (State state : State.values()) &#123;</div><div class=\"line\">\t    <span class=\"comment\">//输出：正常:0 已更新:1 已删除:2</span></div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。<br>其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(“正常”,0),Update(“已更新”,1),Delete(“已删除”,2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。</p>\n<p>因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。</p>\n<ul>\n<li><strong>实现接口</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandleState</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State implements HandleState&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，枚举和一般的类一样都可以实现接口。</p>\n<ul>\n<li><strong>Enum 相关工具类</strong></li>\n</ul>\n<p>JDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://hacpai.com/article/1437056657634\" target=\"_blank\" rel=\"external\">java enum的用法详解[转]</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-enum/\" target=\"_blank\" rel=\"external\">Java 语言中Enum类型的使用介绍</a></p>\n","excerpt":"","more":"<blockquote>\n<p>已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。</p>\n</blockquote>\n<p>Java中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。</p>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><p>每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。</p>\n<h2 id=\"与-public-static-final-的常量定义方式进行比较：\"><a href=\"#与-public-static-final-的常量定义方式进行比较：\" class=\"headerlink\" title=\"与 public static final 的常量定义方式进行比较：\"></a>与 public static final 的常量定义方式进行比较：</h2><p>在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">State</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Normal = <span class=\"number\">0</span>;<span class=\"comment\">//正常</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Update = <span class=\"number\">1</span>;<span class=\"comment\">//已更新</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Delete = <span class=\"number\">2</span>;<span class=\"comment\">//已删除</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。</p>\n</li>\n<li><p>另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。</p>\n</li>\n<li><p>因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。</p>\n</li>\n</ol>\n<p>那如果换成枚举常量呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类型安全检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(State state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。</p>\n<p>另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。</p>\n<h2 id=\"枚举类型的使用\"><a href=\"#枚举类型的使用\" class=\"headerlink\" title=\"枚举类型的使用\"></a>枚举类型的使用</h2><ul>\n<li><strong>常量</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遍历枚举常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(State state:State.values())&#123;</div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>自定义属性、方法</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (State state : State.values()) &#123;</div><div class=\"line\">\t    <span class=\"comment\">//输出：正常:0 已更新:1 已删除:2</span></div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。<br>其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(“正常”,0),Update(“已更新”,1),Delete(“已删除”,2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。</p>\n<p>因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。</p>\n<ul>\n<li><strong>实现接口</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandleState</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State implements HandleState&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，枚举和一般的类一样都可以实现接口。</p>\n<ul>\n<li><strong>Enum 相关工具类</strong></li>\n</ul>\n<p>JDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://hacpai.com/article/1437056657634\">java enum的用法详解[转]</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-enum/\">Java 语言中Enum类型的使用介绍</a></p>\n"},{"layout":"post","title":"java中的类型转换","date":"2016-04-28T04:48:55.000Z","_content":"\n>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：\n\n## **基本类型**\n\n- **基本类型优先级**\n\n首先来看java中的基本类型有哪些：\n\nbyte：byte数据类型是一个8位有符号二进制补码整数。\n\nshort：short数据类型为16位有符号二进制补码整数。\n\nint：int数据类型是一个32位有符号二进制补码整数\n\nlong: long数据类型是一个64位二进制补码整数\n\nfloat: float数据类型是单精度、32位、符合IEEE 754标准的浮点数\n\nboolean: boolean数据类型只有两个可能的值：true和false\n\ndouble: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；\n\nchar: char数据类型是一个16位的Unicode字符\n\n基本类型优先级由低到高排序：\n\n(byte short char) int long float double\n\n其中，byte short char 平级\n\n- **转换规则**\n\n1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算\n\n3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。\n\n2.byte short char 他们三者在计算时，首先会转换为int类型\n\n3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。\n\n4.boolean不能与其他类型转换\n\n\n## **类类型**\n\n类类型之间的转换有以下几个规则：\n\n1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。\n\n2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。\n\n3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。\n  \n说的比较拗口，用代码来解释吧。\n\n```java\npublic class Test {\n\n    class Father {}\n\t\n    class Son extends Father{}\n\t\n    class Daughter extends Father {}\n\n    @org.junit.Test\n    public void test(){\n        Father fatherApp;\n        Son sonApp;\n        Daughter daughterApp;\n        Father fatherIns=new Father();\n        Son sonIns=new Son();\n        Daughter daughterIns=new Daughter();\n\t\t\n        //目标类型为父类，源类型为子类，自动转换\n        fatherApp=sonIns;   \n        //源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。\n        sonApp=(Son) fatherIns;\n        //源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        \n        sonApp=(Son) fatherApp;\n        //目标类型与源类型不存在父子关系，编译无法通过\n        daughterApp=sonIns;  \n\t\t\n    }\t\n}\n```\n\n\n\n## **参考**\n\n[Java 7之基础类型第1篇 - Java数据类型](http://blog.csdn.net/mazhimazh/article/details/16799925)\n\n[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)\n\n[ Java中的类型转换](http://blog.csdn.net/darxin/article/details/5163043)\n","source":"_posts/java中的类型转换.md","raw":"---\nlayout: post\ntitle:  \"java中的类型转换\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-28 12:48:55\n---\n\n>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：\n\n## **基本类型**\n\n- **基本类型优先级**\n\n首先来看java中的基本类型有哪些：\n\nbyte：byte数据类型是一个8位有符号二进制补码整数。\n\nshort：short数据类型为16位有符号二进制补码整数。\n\nint：int数据类型是一个32位有符号二进制补码整数\n\nlong: long数据类型是一个64位二进制补码整数\n\nfloat: float数据类型是单精度、32位、符合IEEE 754标准的浮点数\n\nboolean: boolean数据类型只有两个可能的值：true和false\n\ndouble: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；\n\nchar: char数据类型是一个16位的Unicode字符\n\n基本类型优先级由低到高排序：\n\n(byte short char) int long float double\n\n其中，byte short char 平级\n\n- **转换规则**\n\n1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算\n\n3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。\n\n2.byte short char 他们三者在计算时，首先会转换为int类型\n\n3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。\n\n4.boolean不能与其他类型转换\n\n\n## **类类型**\n\n类类型之间的转换有以下几个规则：\n\n1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。\n\n2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。\n\n3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。\n  \n说的比较拗口，用代码来解释吧。\n\n```java\npublic class Test {\n\n    class Father {}\n\t\n    class Son extends Father{}\n\t\n    class Daughter extends Father {}\n\n    @org.junit.Test\n    public void test(){\n        Father fatherApp;\n        Son sonApp;\n        Daughter daughterApp;\n        Father fatherIns=new Father();\n        Son sonIns=new Son();\n        Daughter daughterIns=new Daughter();\n\t\t\n        //目标类型为父类，源类型为子类，自动转换\n        fatherApp=sonIns;   \n        //源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。\n        sonApp=(Son) fatherIns;\n        //源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        \n        sonApp=(Son) fatherApp;\n        //目标类型与源类型不存在父子关系，编译无法通过\n        daughterApp=sonIns;  \n\t\t\n    }\t\n}\n```\n\n\n\n## **参考**\n\n[Java 7之基础类型第1篇 - Java数据类型](http://blog.csdn.net/mazhimazh/article/details/16799925)\n\n[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)\n\n[ Java中的类型转换](http://blog.csdn.net/darxin/article/details/5163043)\n","slug":"java中的类型转换","published":1,"updated":"2016-11-30T14:32:49.909Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj4h000odigc81qrv5if","content":"<blockquote>\n<p>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：</p>\n</blockquote>\n<h2 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a><strong>基本类型</strong></h2><ul>\n<li><strong>基本类型优先级</strong></li>\n</ul>\n<p>首先来看java中的基本类型有哪些：</p>\n<p>byte：byte数据类型是一个8位有符号二进制补码整数。</p>\n<p>short：short数据类型为16位有符号二进制补码整数。</p>\n<p>int：int数据类型是一个32位有符号二进制补码整数</p>\n<p>long: long数据类型是一个64位二进制补码整数</p>\n<p>float: float数据类型是单精度、32位、符合IEEE 754标准的浮点数</p>\n<p>boolean: boolean数据类型只有两个可能的值：true和false</p>\n<p>double: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</p>\n<p>char: char数据类型是一个16位的Unicode字符</p>\n<p>基本类型优先级由低到高排序：</p>\n<p>(byte short char) int long float double</p>\n<p>其中，byte short char 平级</p>\n<ul>\n<li><strong>转换规则</strong></li>\n</ul>\n<p>1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算</p>\n<p>3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。</p>\n<p>2.byte short char 他们三者在计算时，首先会转换为int类型</p>\n<p>3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。</p>\n<p>4.boolean不能与其他类型转换</p>\n<h2 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a><strong>类类型</strong></h2><p>类类型之间的转换有以下几个规则：</p>\n<p>1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。</p>\n<p>2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。</p>\n<p>3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。</p>\n<p>说的比较拗口，用代码来解释吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@org</span>.junit.<span class=\"function\">Test</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span>&#123;</div><div class=\"line\">        Father fatherApp;</div><div class=\"line\">        Son sonApp;</div><div class=\"line\">        Daughter daughterApp;</div><div class=\"line\">        Father fatherIns=<span class=\"keyword\">new</span> Father();</div><div class=\"line\">        Son sonIns=<span class=\"keyword\">new</span> Son();</div><div class=\"line\">        Daughter daughterIns=<span class=\"keyword\">new</span> Daughter();</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\">//目标类型为父类，源类型为子类，自动转换</span></div><div class=\"line\">        fatherApp=sonIns;   </div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。</span></div><div class=\"line\">        sonApp=(Son) fatherIns;</div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        </span></div><div class=\"line\">        sonApp=(Son) fatherApp;</div><div class=\"line\">        <span class=\"comment\">//目标类型与源类型不存在父子关系，编译无法通过</span></div><div class=\"line\">        daughterApp=sonIns;  </div><div class=\"line\">\t\t</div><div class=\"line\">    &#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://blog.csdn.net/mazhimazh/article/details/16799925\" target=\"_blank\" rel=\"external\">Java 7之基础类型第1篇 - Java数据类型</a></p>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\" target=\"_blank\" rel=\"external\">The Java™ Tutorials</a></p>\n<p><a href=\"http://blog.csdn.net/darxin/article/details/5163043\" target=\"_blank\" rel=\"external\"> Java中的类型转换</a></p>\n","excerpt":"","more":"<blockquote>\n<p>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：</p>\n</blockquote>\n<h2 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a><strong>基本类型</strong></h2><ul>\n<li><strong>基本类型优先级</strong></li>\n</ul>\n<p>首先来看java中的基本类型有哪些：</p>\n<p>byte：byte数据类型是一个8位有符号二进制补码整数。</p>\n<p>short：short数据类型为16位有符号二进制补码整数。</p>\n<p>int：int数据类型是一个32位有符号二进制补码整数</p>\n<p>long: long数据类型是一个64位二进制补码整数</p>\n<p>float: float数据类型是单精度、32位、符合IEEE 754标准的浮点数</p>\n<p>boolean: boolean数据类型只有两个可能的值：true和false</p>\n<p>double: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</p>\n<p>char: char数据类型是一个16位的Unicode字符</p>\n<p>基本类型优先级由低到高排序：</p>\n<p>(byte short char) int long float double</p>\n<p>其中，byte short char 平级</p>\n<ul>\n<li><strong>转换规则</strong></li>\n</ul>\n<p>1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算</p>\n<p>3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。</p>\n<p>2.byte short char 他们三者在计算时，首先会转换为int类型</p>\n<p>3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。</p>\n<p>4.boolean不能与其他类型转换</p>\n<h2 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a><strong>类类型</strong></h2><p>类类型之间的转换有以下几个规则：</p>\n<p>1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。</p>\n<p>2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。</p>\n<p>3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。</p>\n<p>说的比较拗口，用代码来解释吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@org</span>.junit.<span class=\"function\">Test</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        Father fatherApp;</div><div class=\"line\">        Son sonApp;</div><div class=\"line\">        Daughter daughterApp;</div><div class=\"line\">        Father fatherIns=<span class=\"keyword\">new</span> Father();</div><div class=\"line\">        Son sonIns=<span class=\"keyword\">new</span> Son();</div><div class=\"line\">        Daughter daughterIns=<span class=\"keyword\">new</span> Daughter();</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\">//目标类型为父类，源类型为子类，自动转换</span></div><div class=\"line\">        fatherApp=sonIns;   </div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。</span></div><div class=\"line\">        sonApp=(Son) fatherIns;</div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        </span></div><div class=\"line\">        sonApp=(Son) fatherApp;</div><div class=\"line\">        <span class=\"comment\">//目标类型与源类型不存在父子关系，编译无法通过</span></div><div class=\"line\">        daughterApp=sonIns;  </div><div class=\"line\">\t\t</div><div class=\"line\">    &#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://blog.csdn.net/mazhimazh/article/details/16799925\">Java 7之基础类型第1篇 - Java数据类型</a></p>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\">The Java™ Tutorials</a></p>\n<p><a href=\"http://blog.csdn.net/darxin/article/details/5163043\"> Java中的类型转换</a></p>\n"},{"layout":"post","title":"java中的编码问题","date":"2016-04-20T04:48:55.000Z","_content":"\n>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。\n\n2016/9/11 更新：今天在网上看到一篇讲解有关编码的文章 [Java中字符编码和字符串所占字节数](http://blog.csdn.net/zklth/article/details/7016886),个人认为作者写的十分清晰明了。把文章中的例子看懂的话再遇到乱码的情况解决起来应该不难！\n\n## 编码\n什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。\n\n- #### **[Ascii编码](http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&fromid=99077&type=syn)**\n\n标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。\n\n- #### **[GB2312](http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&fromid=483170&type=syn)**\n\nGB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。\n\n- #### **[UTF-8](http://baike.baidu.com/view/25412.htm)**\n\n事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是[Unicode编码](http://baike.baidu.com/item/unicode)\n事实上，Unicode也是一套字符集。\n\n**字符集**简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字\"严\"。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？\n\n这是因为：\n\n比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n\n**字符编码**就是用来解决以上所说的如何存储字符对应二进制编码问题的。\n\nUTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8的编码规则很简单，只有两条： \n\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 \n\n2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n\n下面以utf-8为例，看下编码的过程。\n\n{% asset_img utf8.png utf-8 %}\n\n根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。\n\n以汉字”严”为例，演示如何实现UTF-8编码。\n\n已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。\n\n还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。\n\n## java 中的编码\n\n- #### **class文件与内存中的编码**\n\n{% asset_img javaencode.jpg %}\n\n上图说明了java编码转换的过程\n\n首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。\n\njava程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。\n\n**总结**:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。\n\n- #### **InputStreamReader与OutputStreamWriter**\n\n{% asset_img reader.png %}\n{% asset_img writer.png %}\n\nReader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。\n\n写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。\n\n```java\n String file = \"c:/stream.txt\"; \n String charset = \"UTF-8\"; \n // 写字符换转成字节流\n FileOutputStream outputStream = new FileOutputStream(file); \n OutputStreamWriter writer = new OutputStreamWriter( \n outputStream, charset); \n try { \n    writer.write(\"这是要保存的中文字符\"); \n } finally { \n    writer.close(); \n } \n // 读取字节转换成字符\n FileInputStream inputStream = new FileInputStream(file); \n InputStreamReader reader = new InputStreamReader( \n inputStream, charset); \n StringBuffer buffer = new StringBuffer(); \n char[] buf = new char[64]; \n int count = 0; \n try { \n    while ((count = reader.read(buf)) != -1) { \n        buffer.append(buf, 0, count); \n    } \n } finally { \n    reader.close(); \n }\n```\n\n- #### **String与byte[]**\n\n利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。\n\n```java\nString str=\"中\";  \n// 将内存中的str(utf-16)转换为系统默认编码的字节数组\nbyte[] bytes1 = str.getBytes();  \n// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 \nbyte[] bytes2 = str.getBytes(\"ISO-8859-1\");\n// 正常显示中    \nSystem.out.println(new String(bytes1));  \n// 输出\"?\"      \nSystem.out.println(new String(bytes2));      \n```\n\n利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。\n\n```java\n// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”\nbyte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31};  \n// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符\nString str1 = new String(bytes);                      \n// 将bytes按照ISO-8859-1解码，产生Unicode字符\nString str2= new String(bytes,\"ISO-8859-1\");          \n// 中1  将Unicode字符转换为GBK编码输出\nSystem.out.println(str1);                             \n\n/*\n *在ISO-8859-1编码方式中没有对应0xD6和0xD0\n *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”\n *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。\n */ \nSystem.out.println(str2);    // ??1                             \n```\n\n- #### **CharSet**\n\n从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。\n\n```java\nCharset charset = Charset.forName(\"UTF-8\");   \nByteBuffer byteBuffer = charset.encode(string);   \nCharBuffer charBuffer = charset.decode(byteBuffer); \n```\n\n## 延伸 byte\n\n字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。\n\n无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。\n\n有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.\n\n## 参考\n\n[十分钟搞清字符集和字符编码](http://cenalulu.github.io/linux/character-encoding/)\n\n[字符编码笔记：ASCII，Unicode和UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n[java编码转换过程](http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html)\n\n[Java 7之基础 - 编码与解码](http://blog.csdn.net/mazhimazh/article/details/19327421)\n\n[深入分析 Java 中的中文编码问题](https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/)","source":"_posts/java中的编码问题.md","raw":"---\nlayout: post\ntitle:  \"java中的编码问题\"\ncategories: 编程\ntags: \n- java\n- 编码\ndate:   2016-04-20 12:48:55\n---\n\n>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。\n\n2016/9/11 更新：今天在网上看到一篇讲解有关编码的文章 [Java中字符编码和字符串所占字节数](http://blog.csdn.net/zklth/article/details/7016886),个人认为作者写的十分清晰明了。把文章中的例子看懂的话再遇到乱码的情况解决起来应该不难！\n\n## 编码\n什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。\n\n- #### **[Ascii编码](http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&fromid=99077&type=syn)**\n\n标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。\n\n- #### **[GB2312](http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&fromid=483170&type=syn)**\n\nGB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。\n\n- #### **[UTF-8](http://baike.baidu.com/view/25412.htm)**\n\n事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是[Unicode编码](http://baike.baidu.com/item/unicode)\n事实上，Unicode也是一套字符集。\n\n**字符集**简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字\"严\"。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？\n\n这是因为：\n\n比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n\n**字符编码**就是用来解决以上所说的如何存储字符对应二进制编码问题的。\n\nUTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8的编码规则很简单，只有两条： \n\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 \n\n2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n\n下面以utf-8为例，看下编码的过程。\n\n{% asset_img utf8.png utf-8 %}\n\n根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。\n\n以汉字”严”为例，演示如何实现UTF-8编码。\n\n已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。\n\n还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。\n\n## java 中的编码\n\n- #### **class文件与内存中的编码**\n\n{% asset_img javaencode.jpg %}\n\n上图说明了java编码转换的过程\n\n首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。\n\njava程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。\n\n**总结**:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。\n\n- #### **InputStreamReader与OutputStreamWriter**\n\n{% asset_img reader.png %}\n{% asset_img writer.png %}\n\nReader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。\n\n写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。\n\n```java\n String file = \"c:/stream.txt\"; \n String charset = \"UTF-8\"; \n // 写字符换转成字节流\n FileOutputStream outputStream = new FileOutputStream(file); \n OutputStreamWriter writer = new OutputStreamWriter( \n outputStream, charset); \n try { \n    writer.write(\"这是要保存的中文字符\"); \n } finally { \n    writer.close(); \n } \n // 读取字节转换成字符\n FileInputStream inputStream = new FileInputStream(file); \n InputStreamReader reader = new InputStreamReader( \n inputStream, charset); \n StringBuffer buffer = new StringBuffer(); \n char[] buf = new char[64]; \n int count = 0; \n try { \n    while ((count = reader.read(buf)) != -1) { \n        buffer.append(buf, 0, count); \n    } \n } finally { \n    reader.close(); \n }\n```\n\n- #### **String与byte[]**\n\n利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。\n\n```java\nString str=\"中\";  \n// 将内存中的str(utf-16)转换为系统默认编码的字节数组\nbyte[] bytes1 = str.getBytes();  \n// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 \nbyte[] bytes2 = str.getBytes(\"ISO-8859-1\");\n// 正常显示中    \nSystem.out.println(new String(bytes1));  \n// 输出\"?\"      \nSystem.out.println(new String(bytes2));      \n```\n\n利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。\n\n```java\n// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”\nbyte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31};  \n// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符\nString str1 = new String(bytes);                      \n// 将bytes按照ISO-8859-1解码，产生Unicode字符\nString str2= new String(bytes,\"ISO-8859-1\");          \n// 中1  将Unicode字符转换为GBK编码输出\nSystem.out.println(str1);                             \n\n/*\n *在ISO-8859-1编码方式中没有对应0xD6和0xD0\n *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”\n *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。\n */ \nSystem.out.println(str2);    // ??1                             \n```\n\n- #### **CharSet**\n\n从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。\n\n```java\nCharset charset = Charset.forName(\"UTF-8\");   \nByteBuffer byteBuffer = charset.encode(string);   \nCharBuffer charBuffer = charset.decode(byteBuffer); \n```\n\n## 延伸 byte\n\n字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。\n\n无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。\n\n有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.\n\n## 参考\n\n[十分钟搞清字符集和字符编码](http://cenalulu.github.io/linux/character-encoding/)\n\n[字符编码笔记：ASCII，Unicode和UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n[java编码转换过程](http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html)\n\n[Java 7之基础 - 编码与解码](http://blog.csdn.net/mazhimazh/article/details/19327421)\n\n[深入分析 Java 中的中文编码问题](https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/)","slug":"java中的编码问题","published":1,"updated":"2016-11-30T14:32:49.909Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj4m000rdigczzakbd58","content":"<blockquote>\n<p>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。</p>\n</blockquote>\n<p>2016/9/11 更新：今天在网上看到一篇讲解有关编码的文章 <a href=\"http://blog.csdn.net/zklth/article/details/7016886\" target=\"_blank\" rel=\"external\">Java中字符编码和字符串所占字节数</a>,个人认为作者写的十分清晰明了。把文章中的例子看懂的话再遇到乱码的情况解决起来应该不难！</p>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。</p>\n<ul>\n<li><h4 id=\"Ascii编码\"><a href=\"#Ascii编码\" class=\"headerlink\" title=\"Ascii编码\"></a><strong><a href=\"http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&amp;fromid=99077&amp;type=syn\" target=\"_blank\" rel=\"external\">Ascii编码</a></strong></h4></li>\n</ul>\n<p>标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。</p>\n<ul>\n<li><h4 id=\"GB2312\"><a href=\"#GB2312\" class=\"headerlink\" title=\"GB2312\"></a><strong><a href=\"http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&amp;fromid=483170&amp;type=syn\" target=\"_blank\" rel=\"external\">GB2312</a></strong></h4></li>\n</ul>\n<p>GB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p>\n<ul>\n<li><h4 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a><strong><a href=\"http://baike.baidu.com/view/25412.htm\" target=\"_blank\" rel=\"external\">UTF-8</a></strong></h4></li>\n</ul>\n<p>事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是<a href=\"http://baike.baidu.com/item/unicode\" target=\"_blank\" rel=\"external\">Unicode编码</a><br>事实上，Unicode也是一套字符集。</p>\n<p><strong>字符集</strong>简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？</p>\n<p>这是因为：</p>\n<p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。<br>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>\n<p><strong>字符编码</strong>就是用来解决以上所说的如何存储字符对应二进制编码问题的。</p>\n<p>UTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<p>UTF-8的编码规则很简单，只有两条： </p>\n<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </p>\n<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>\n<p>下面以utf-8为例，看下编码的过程。</p>\n<img src=\"/2016/04/20/java中的编码问题/utf8.png\" alt=\"utf-8\" title=\"utf-8\">\n<p>根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。</p>\n<p>以汉字”严”为例，演示如何实现UTF-8编码。</p>\n<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。</p>\n<p>还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。</p>\n<h2 id=\"java-中的编码\"><a href=\"#java-中的编码\" class=\"headerlink\" title=\"java 中的编码\"></a>java 中的编码</h2><ul>\n<li><h4 id=\"class文件与内存中的编码\"><a href=\"#class文件与内存中的编码\" class=\"headerlink\" title=\"class文件与内存中的编码\"></a><strong>class文件与内存中的编码</strong></h4></li>\n</ul>\n\n<p>上图说明了java编码转换的过程</p>\n<p>首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。</p>\n<p>java程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。</p>\n<p><strong>总结</strong>:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。</p>\n<ul>\n<li><h4 id=\"InputStreamReader与OutputStreamWriter\"><a href=\"#InputStreamReader与OutputStreamWriter\" class=\"headerlink\" title=\"InputStreamReader与OutputStreamWriter\"></a><strong>InputStreamReader与OutputStreamWriter</strong></h4></li>\n</ul>\n<img src=\"/2016/04/20/java中的编码问题/reader.png\" alt=\"reader.png\" title=\"\">\n<img src=\"/2016/04/20/java中的编码问题/writer.png\" alt=\"writer.png\" title=\"\">\n<p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。</p>\n<p>写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">String file = <span class=\"string\">\"c:/stream.txt\"</span>; </div><div class=\"line\">String charset = <span class=\"string\">\"UTF-8\"</span>; </div><div class=\"line\"><span class=\"comment\">// 写字符换转成字节流</span></div><div class=\"line\">FileOutputStream outputStream = <span class=\"keyword\">new</span> FileOutputStream(file); </div><div class=\"line\">OutputStreamWriter writer = <span class=\"keyword\">new</span> OutputStreamWriter( </div><div class=\"line\">outputStream, charset); </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   writer.write(<span class=\"string\">\"这是要保存的中文字符\"</span>); </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   writer.close(); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"comment\">// 读取字节转换成字符</span></div><div class=\"line\">FileInputStream inputStream = <span class=\"keyword\">new</span> FileInputStream(file); </div><div class=\"line\">InputStreamReader reader = <span class=\"keyword\">new</span> InputStreamReader( </div><div class=\"line\">inputStream, charset); </div><div class=\"line\">StringBuffer buffer = <span class=\"keyword\">new</span> StringBuffer(); </div><div class=\"line\"><span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>]; </div><div class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   <span class=\"keyword\">while</span> ((count = reader.read(buf)) != -<span class=\"number\">1</span>) &#123; </div><div class=\"line\">       buffer.append(buf, <span class=\"number\">0</span>, count); </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   reader.close(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"String与byte\"><a href=\"#String与byte\" class=\"headerlink\" title=\"String与byte[]\"></a><strong>String与byte[]</strong></h4></li>\n</ul>\n<p>利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"string\">\"中\"</span>;  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为系统默认编码的字节数组</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = str.getBytes();  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 </span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = str.getBytes(<span class=\"string\">\"ISO-8859-1\"</span>);</div><div class=\"line\"><span class=\"comment\">// 正常显示中    </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes1));  </div><div class=\"line\"><span class=\"comment\">// 输出\"?\"      </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes2));</div></pre></td></tr></table></figure>\n<p>利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes = &#123;(<span class=\"keyword\">byte</span>)<span class=\"number\">0xD6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0xD0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0x31</span>&#125;;  </div><div class=\"line\"><span class=\"comment\">// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符</span></div><div class=\"line\">String str1 = <span class=\"keyword\">new</span> String(bytes);                      </div><div class=\"line\"><span class=\"comment\">// 将bytes按照ISO-8859-1解码，产生Unicode字符</span></div><div class=\"line\">String str2= <span class=\"keyword\">new</span> String(bytes,<span class=\"string\">\"ISO-8859-1\"</span>);          </div><div class=\"line\"><span class=\"comment\">// 中1  将Unicode字符转换为GBK编码输出</span></div><div class=\"line\">System.out.println(str1);                             </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> *在ISO-8859-1编码方式中没有对应0xD6和0xD0</div><div class=\"line\"> *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”</div><div class=\"line\"> *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。</div><div class=\"line\"> */ </div><div class=\"line\">System.out.println(str2);    <span class=\"comment\">// ??1</span></div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"CharSet\"><a href=\"#CharSet\" class=\"headerlink\" title=\"CharSet\"></a><strong>CharSet</strong></h4></li>\n</ul>\n<p>从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(<span class=\"string\">\"UTF-8\"</span>);   </div><div class=\"line\">ByteBuffer byteBuffer = charset.encode(string);   </div><div class=\"line\">CharBuffer charBuffer = charset.decode(byteBuffer);</div></pre></td></tr></table></figure>\n<h2 id=\"延伸-byte\"><a href=\"#延伸-byte\" class=\"headerlink\" title=\"延伸 byte\"></a>延伸 byte</h2><p>字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。</p>\n<p>无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。</p>\n<p>有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://cenalulu.github.io/linux/character-encoding/\" target=\"_blank\" rel=\"external\">十分钟搞清字符集和字符编码</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\" target=\"_blank\" rel=\"external\">字符编码笔记：ASCII，Unicode和UTF-8</a></p>\n<p><a href=\"http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html\" target=\"_blank\" rel=\"external\">java编码转换过程</a></p>\n<p><a href=\"http://blog.csdn.net/mazhimazh/article/details/19327421\" target=\"_blank\" rel=\"external\">Java 7之基础 - 编码与解码</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/\" target=\"_blank\" rel=\"external\">深入分析 Java 中的中文编码问题</a></p>\n","excerpt":"","more":"<blockquote>\n<p>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。</p>\n</blockquote>\n<p>2016/9/11 更新：今天在网上看到一篇讲解有关编码的文章 <a href=\"http://blog.csdn.net/zklth/article/details/7016886\">Java中字符编码和字符串所占字节数</a>,个人认为作者写的十分清晰明了。把文章中的例子看懂的话再遇到乱码的情况解决起来应该不难！</p>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。</p>\n<ul>\n<li><h4 id=\"Ascii编码\"><a href=\"#Ascii编码\" class=\"headerlink\" title=\"Ascii编码\"></a><strong><a href=\"http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&amp;fromid=99077&amp;type=syn\">Ascii编码</a></strong></h4></li>\n</ul>\n<p>标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。</p>\n<ul>\n<li><h4 id=\"GB2312\"><a href=\"#GB2312\" class=\"headerlink\" title=\"GB2312\"></a><strong><a href=\"http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&amp;fromid=483170&amp;type=syn\">GB2312</a></strong></h4></li>\n</ul>\n<p>GB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p>\n<ul>\n<li><h4 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a><strong><a href=\"http://baike.baidu.com/view/25412.htm\">UTF-8</a></strong></h4></li>\n</ul>\n<p>事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是<a href=\"http://baike.baidu.com/item/unicode\">Unicode编码</a><br>事实上，Unicode也是一套字符集。</p>\n<p><strong>字符集</strong>简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？</p>\n<p>这是因为：</p>\n<p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。<br>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>\n<p><strong>字符编码</strong>就是用来解决以上所说的如何存储字符对应二进制编码问题的。</p>\n<p>UTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<p>UTF-8的编码规则很简单，只有两条： </p>\n<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </p>\n<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>\n<p>下面以utf-8为例，看下编码的过程。</p>\n<img src=\"/2016/04/20/java中的编码问题/utf8.png\" alt=\"utf-8\" title=\"utf-8\">\n<p>根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。</p>\n<p>以汉字”严”为例，演示如何实现UTF-8编码。</p>\n<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。</p>\n<p>还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。</p>\n<h2 id=\"java-中的编码\"><a href=\"#java-中的编码\" class=\"headerlink\" title=\"java 中的编码\"></a>java 中的编码</h2><ul>\n<li><h4 id=\"class文件与内存中的编码\"><a href=\"#class文件与内存中的编码\" class=\"headerlink\" title=\"class文件与内存中的编码\"></a><strong>class文件与内存中的编码</strong></h4></li>\n</ul>\n\n<p>上图说明了java编码转换的过程</p>\n<p>首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。</p>\n<p>java程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。</p>\n<p><strong>总结</strong>:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。</p>\n<ul>\n<li><h4 id=\"InputStreamReader与OutputStreamWriter\"><a href=\"#InputStreamReader与OutputStreamWriter\" class=\"headerlink\" title=\"InputStreamReader与OutputStreamWriter\"></a><strong>InputStreamReader与OutputStreamWriter</strong></h4></li>\n</ul>\n<img src=\"/2016/04/20/java中的编码问题/reader.png\" alt=\"reader.png\" title=\"\">\n<img src=\"/2016/04/20/java中的编码问题/writer.png\" alt=\"writer.png\" title=\"\">\n<p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。</p>\n<p>写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">String file = <span class=\"string\">\"c:/stream.txt\"</span>; </div><div class=\"line\">String charset = <span class=\"string\">\"UTF-8\"</span>; </div><div class=\"line\"><span class=\"comment\">// 写字符换转成字节流</span></div><div class=\"line\">FileOutputStream outputStream = <span class=\"keyword\">new</span> FileOutputStream(file); </div><div class=\"line\">OutputStreamWriter writer = <span class=\"keyword\">new</span> OutputStreamWriter( </div><div class=\"line\">outputStream, charset); </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   writer.write(<span class=\"string\">\"这是要保存的中文字符\"</span>); </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   writer.close(); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"comment\">// 读取字节转换成字符</span></div><div class=\"line\">FileInputStream inputStream = <span class=\"keyword\">new</span> FileInputStream(file); </div><div class=\"line\">InputStreamReader reader = <span class=\"keyword\">new</span> InputStreamReader( </div><div class=\"line\">inputStream, charset); </div><div class=\"line\">StringBuffer buffer = <span class=\"keyword\">new</span> StringBuffer(); </div><div class=\"line\"><span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>]; </div><div class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   <span class=\"keyword\">while</span> ((count = reader.read(buf)) != -<span class=\"number\">1</span>) &#123; </div><div class=\"line\">       buffer.append(buf, <span class=\"number\">0</span>, count); </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   reader.close(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"String与byte\"><a href=\"#String与byte\" class=\"headerlink\" title=\"String与byte[]\"></a><strong>String与byte[]</strong></h4></li>\n</ul>\n<p>利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"string\">\"中\"</span>;  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为系统默认编码的字节数组</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = str.getBytes();  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 </span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = str.getBytes(<span class=\"string\">\"ISO-8859-1\"</span>);</div><div class=\"line\"><span class=\"comment\">// 正常显示中    </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes1));  </div><div class=\"line\"><span class=\"comment\">// 输出\"?\"      </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes2));</div></pre></td></tr></table></figure>\n<p>利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes = &#123;(<span class=\"keyword\">byte</span>)<span class=\"number\">0xD6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0xD0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0x31</span>&#125;;  </div><div class=\"line\"><span class=\"comment\">// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符</span></div><div class=\"line\">String str1 = <span class=\"keyword\">new</span> String(bytes);                      </div><div class=\"line\"><span class=\"comment\">// 将bytes按照ISO-8859-1解码，产生Unicode字符</span></div><div class=\"line\">String str2= <span class=\"keyword\">new</span> String(bytes,<span class=\"string\">\"ISO-8859-1\"</span>);          </div><div class=\"line\"><span class=\"comment\">// 中1  将Unicode字符转换为GBK编码输出</span></div><div class=\"line\">System.out.println(str1);                             </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\"> *在ISO-8859-1编码方式中没有对应0xD6和0xD0</div><div class=\"line\"> *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”</div><div class=\"line\"> *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。</div><div class=\"line\"> */</span> </div><div class=\"line\">System.out.println(str2);    <span class=\"comment\">// ??1</span></div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"CharSet\"><a href=\"#CharSet\" class=\"headerlink\" title=\"CharSet\"></a><strong>CharSet</strong></h4></li>\n</ul>\n<p>从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(<span class=\"string\">\"UTF-8\"</span>);   </div><div class=\"line\">ByteBuffer byteBuffer = charset.encode(string);   </div><div class=\"line\">CharBuffer charBuffer = charset.decode(byteBuffer);</div></pre></td></tr></table></figure>\n<h2 id=\"延伸-byte\"><a href=\"#延伸-byte\" class=\"headerlink\" title=\"延伸 byte\"></a>延伸 byte</h2><p>字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。</p>\n<p>无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。</p>\n<p>有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://cenalulu.github.io/linux/character-encoding/\">十分钟搞清字符集和字符编码</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\">字符编码笔记：ASCII，Unicode和UTF-8</a></p>\n<p><a href=\"http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html\">java编码转换过程</a></p>\n<p><a href=\"http://blog.csdn.net/mazhimazh/article/details/19327421\">Java 7之基础 - 编码与解码</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/\">深入分析 Java 中的中文编码问题</a></p>\n"},{"layout":"post","title":"java中的路径","date":"2016-12-04T11:03:00.000Z","_content":"\n>每次写java代码的时候，免不了需要加载一些外部资源，比如配置文件等等。每当需要读取这些文件时，都是去网上谷歌，写过就忘。于是今天来总结一些java中有关路径的一些用法。\n\n## 绝对路径\n\n无论是在linux还是windows中，路径都分为绝对路径和相对路径两种。\n\n绝对路径就是系统中唯一能够定位资源的某个URI，即完整的描述文件的路径就是绝对路径。比如：\n\nlinux中的绝对路径：/home/yukai/test.txt\n\nwindows中的绝对路径：E:\\yukai\\test.txt\n\n绝对路径都是以根目录起始的。\n\n## 相对路径\n\n相对路径即目标文件相对与某个基准目录的路径。比如:\n\n存在文件： \n\nA: /home/yukai/test.txt \n\nB: /home/yukai/test1.txt \n\nC: /home/yukai/test/test.txt\n\n那么：\n\n若基准目录为A, B的路径表示为\"test1.txt\"\n\n若基准目录为B, C的路径表示为\"test/test.txt\"\n\n若基准目录为C, B的路径表示为\"../test1.txt\"\n\n另外，“./”表示当前目录，“../”表示上级目录\n\n## java io定位文件资源\n\n那么，我们在java中如何读取某个文件？上代码：\n\n```\n// 目录结构\nsrc\n |\n |--test\n |   |\n |   |--PathTest.java \n |\nresource\n |\n |--data.txt\n```\n\n```java\npublic class PathTest {\n\n\tpublic static String  dataFilePath = \"resource/data.txty\";\n\t\n\tpublic static String getUserDir() {\n\t\t//打印运行程序的目录，即启动java程序的目录\n\t\tString userDir = System.getProperty(\"user.dir\");\n\t\tSystem.out.println(\"运行java的工作目录 System.getProperty(\\\"user.dir\\\")： \" + userDir);\n\t\treturn userDir;\n\t}\n\t\n\tpublic static void testDataPath1() {\n\t\tString msg = \">> Path = System.getProperty(\\\"user.dir\\\") + \\\"resource/data.txt\\\"\";\n\t\tString userDir = getUserDir();\n\t\t//等同于 \"resource/data.txt\"\n\t\tString filePath = userDir + System.getProperty(\"file.separator\") + dataFilePath;\n\t\tprintFileContent(filePath ,msg);\n\t}\n\t\n\tpublic static void testDataPath2() {\n\t\tString msg = \"Path = \\\"resource/data.txt\\\"\";\n\t\tString filePath = dataFilePath;\n\t\tprintFileContent(filePath, msg);\n\t}\n\t\n\tpublic static void testDataPath3() {\n\t\tString msg = \"Path = \\\"./resource/data.txt\\\"\";\n\t\tString filePath = \"./resource/data.txt\";\n\t\tprintFileContent(filePath, msg);\n\t}\n\t\n\tprivate static void printFileContent(String filePath, String msg) {\n\t\tSystem.out.println(\"****************************\");\n\t\tSystem.out.println(msg);\n\t\tFile file = new File(filePath);\n\t\tInputStream stream;\n\t\ttry {\n\t\t\tstream = new FileInputStream(file);\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\t\tString line = null;\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tSystem.out.println(\"****************************\");\n\t\t} \n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttestDataPath1();\n\t\ttestDataPath2();\n\t\ttestDataPath3();\n\t}\n\n}\n```\n其中`testDataPath2`、`testDataPath1`、`testDataPath3`这三个方法的效果是一样的。\n\n`System.getProperty(\"user.dir\")`这个方法获取了当前的工作目录，也就是启动jvm的目录。例如：\n\nps: 更多关于System.getProperty()的介绍：[System Properties](http://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html)\n\n你的java程序位于：/home/yukai/code/test.jar \n\n若你在目录/home/yukai下使用命令 `java -cp code/test.jar test.PathTest` 启动java程序时，目录/home/yukai就是你的工作目录。\n\n在`testDataPath2`当中，直接使用\"resource/data.txty\"来作为文件读取路径时，java会默认为基准目录为当前的工作目录，\"resource/data.txty\"此时就是相对于这个基准目录的路径。\n也就是说，java会把工作目录与\"resource/data.txty\"拼接起来，作为一个绝对路径去读取文件，也就是`testDataPath1`中的例子。\n\n有Eclipse中启动你的java工程的目录就是工程根目录，工程根目录也就是工作目录，如果你读取文件的方式类似于`testDataPath2`的话，他会在工程根目录下找你的文件。\n有时候我们会遇到，在Eclipse中读取文件没有问题，但是打成jar包之后运行(像上面运行jar包的例子)就会报找不到文件的错误。那么此时就要检查你的当前工作目录下(/home/yukai)是否有这些文件的存在了。\n\n## File.getPath & File.getAbsolutePath & File.getCanonicalPath\n\n```java\npublic static void testGetPath() {\n\t\tFile file = new File(\"./resource/data.txt\");\n\t\tSystem.out.println(\"File.getPath(): \" + file.getPath());\n\t\tSystem.out.println(\"File.getAbsolutePath(): \"+ file.getAbsolutePath());\n\t\ttry {\n\t\t\tSystem.out.println(\"File.getCanonicalPath(): \" + file.getCanonicalPath());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n上述代码运行结果：\n\n```\nFile.getPath(): ./resource/data.txt\nFile.getAbsolutePath(): /home/yukai/workspace/test/./resource/data.txt\nFile.getCanonicalPath(): /home/yukai/workspace/test/resource/data.txt\n```\n摘抄一段[stackoverflow](http://stackoverflow.com/questions/1099300/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath)上的答案:\n\n```\ngetPath() gets the path string that the File object was constructed with, and it may be relative current directory.\n\ngetAbsolutePath() gets the path string after resolving it against the current directory if it's relative, resulting in a fully qualified path.\n\ngetCanonicalPath() gets the path string after resolving any relative path against current directory, and removes any relative pathing (. and ..), and any file system links to return a path which the file system considers the canonical means to reference the file system object to which it points.\n```\n\n## 读取classpath下的文件\n\n```java\npublic static void getClassPath() {\n\t\tSystem.out.println(\"PathTest.class.getResource(\\\"/\\\"): \" + PathTest.class.getResource(\"/\"));\n\t\tSystem.out.println(\"PathTest.class.getResource(\\\"\\\"): \" + PathTest.class.getResource(\"\"));\n\t\t\n\t\tSystem.out.println(\"PathTest.class.getClassLoader().getResource(\\\"/\\\"): \" + PathTest.class.getClassLoader().getResource(\"/\"));\n\t\tSystem.out.println(\"PathTest.class.getClassLoader().getResource(\\\"\\\"): \" + PathTest.class.getClassLoader().getResource(\"\"));\n}\n```\n\n运行结果(Eclipse)：\n\n```\n//以“/”开头，表示相对于package根目录\nPathTest.class.getResource(\"/\"): file:/home/yukai/workspace/test/bin/\n//不以“/”开头，表示相对于class文件所在目录\nPathTest.class.getResource(\"\"): file:/home/yukai/workspace/test/bin/test/\n//\nPathTest.class.getClassLoader().getResource(\"/\"): null\n//getClassLoader().getResource(\"\")不以“/”开头，相对于package根目录\nPathTest.class.getClassLoader().getResource(\"\"): file:/home/yukai/workspace/test/bin/\n```\n## 获取jar包路径\n\njava开发中常常需要取得程序生成的jar包所在的路径，比如生成一些log文件的时候，需要把该程序生成的log放到jar包的的同级目录下。\n此时，我们需要知道jar包所在的位置，注意，不是启动jvm实例的位置。\n\n```\nURL url = Config.class.getProtectionDomain().getCodeSource().getLocation();\nString path = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null).getPath(); \nif (path != null) {   \n   if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {      \n          path = path.substring(0, path.length() - 1);    \n   }    \n   if (path.endsWith(\".jar\")) {        \n          int index = path.lastIndexOf(\"/\");\n          if (index != -1) {           \n                path = path.substring(0, index);\n          }\n          defultLogPath = path + File.separator + \"log\";\n   } else { \n       defultLogPath = path + File.separator + \"..\" + File.separator + \"log\" ;\n   }\n}\n```\n\n## Path.java\n\njdk1.7之后，新增了一个类File,位于java.nio.file下，该类提供了一些路径的操作。\n\n具体的使用不一一介绍，用到时可查找oracle的官方手册，已经写的很详细了：[Path Operations](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html)\n","source":"_posts/java中的路径.md","raw":"---\nlayout: post\ntitle: \"java中的路径\"\ncategories: java\ndate: 2016-12-04 19:03:00\n---\n\n>每次写java代码的时候，免不了需要加载一些外部资源，比如配置文件等等。每当需要读取这些文件时，都是去网上谷歌，写过就忘。于是今天来总结一些java中有关路径的一些用法。\n\n## 绝对路径\n\n无论是在linux还是windows中，路径都分为绝对路径和相对路径两种。\n\n绝对路径就是系统中唯一能够定位资源的某个URI，即完整的描述文件的路径就是绝对路径。比如：\n\nlinux中的绝对路径：/home/yukai/test.txt\n\nwindows中的绝对路径：E:\\yukai\\test.txt\n\n绝对路径都是以根目录起始的。\n\n## 相对路径\n\n相对路径即目标文件相对与某个基准目录的路径。比如:\n\n存在文件： \n\nA: /home/yukai/test.txt \n\nB: /home/yukai/test1.txt \n\nC: /home/yukai/test/test.txt\n\n那么：\n\n若基准目录为A, B的路径表示为\"test1.txt\"\n\n若基准目录为B, C的路径表示为\"test/test.txt\"\n\n若基准目录为C, B的路径表示为\"../test1.txt\"\n\n另外，“./”表示当前目录，“../”表示上级目录\n\n## java io定位文件资源\n\n那么，我们在java中如何读取某个文件？上代码：\n\n```\n// 目录结构\nsrc\n |\n |--test\n |   |\n |   |--PathTest.java \n |\nresource\n |\n |--data.txt\n```\n\n```java\npublic class PathTest {\n\n\tpublic static String  dataFilePath = \"resource/data.txty\";\n\t\n\tpublic static String getUserDir() {\n\t\t//打印运行程序的目录，即启动java程序的目录\n\t\tString userDir = System.getProperty(\"user.dir\");\n\t\tSystem.out.println(\"运行java的工作目录 System.getProperty(\\\"user.dir\\\")： \" + userDir);\n\t\treturn userDir;\n\t}\n\t\n\tpublic static void testDataPath1() {\n\t\tString msg = \">> Path = System.getProperty(\\\"user.dir\\\") + \\\"resource/data.txt\\\"\";\n\t\tString userDir = getUserDir();\n\t\t//等同于 \"resource/data.txt\"\n\t\tString filePath = userDir + System.getProperty(\"file.separator\") + dataFilePath;\n\t\tprintFileContent(filePath ,msg);\n\t}\n\t\n\tpublic static void testDataPath2() {\n\t\tString msg = \"Path = \\\"resource/data.txt\\\"\";\n\t\tString filePath = dataFilePath;\n\t\tprintFileContent(filePath, msg);\n\t}\n\t\n\tpublic static void testDataPath3() {\n\t\tString msg = \"Path = \\\"./resource/data.txt\\\"\";\n\t\tString filePath = \"./resource/data.txt\";\n\t\tprintFileContent(filePath, msg);\n\t}\n\t\n\tprivate static void printFileContent(String filePath, String msg) {\n\t\tSystem.out.println(\"****************************\");\n\t\tSystem.out.println(msg);\n\t\tFile file = new File(filePath);\n\t\tInputStream stream;\n\t\ttry {\n\t\t\tstream = new FileInputStream(file);\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\t\tString line = null;\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tSystem.out.println(\"****************************\");\n\t\t} \n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttestDataPath1();\n\t\ttestDataPath2();\n\t\ttestDataPath3();\n\t}\n\n}\n```\n其中`testDataPath2`、`testDataPath1`、`testDataPath3`这三个方法的效果是一样的。\n\n`System.getProperty(\"user.dir\")`这个方法获取了当前的工作目录，也就是启动jvm的目录。例如：\n\nps: 更多关于System.getProperty()的介绍：[System Properties](http://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html)\n\n你的java程序位于：/home/yukai/code/test.jar \n\n若你在目录/home/yukai下使用命令 `java -cp code/test.jar test.PathTest` 启动java程序时，目录/home/yukai就是你的工作目录。\n\n在`testDataPath2`当中，直接使用\"resource/data.txty\"来作为文件读取路径时，java会默认为基准目录为当前的工作目录，\"resource/data.txty\"此时就是相对于这个基准目录的路径。\n也就是说，java会把工作目录与\"resource/data.txty\"拼接起来，作为一个绝对路径去读取文件，也就是`testDataPath1`中的例子。\n\n有Eclipse中启动你的java工程的目录就是工程根目录，工程根目录也就是工作目录，如果你读取文件的方式类似于`testDataPath2`的话，他会在工程根目录下找你的文件。\n有时候我们会遇到，在Eclipse中读取文件没有问题，但是打成jar包之后运行(像上面运行jar包的例子)就会报找不到文件的错误。那么此时就要检查你的当前工作目录下(/home/yukai)是否有这些文件的存在了。\n\n## File.getPath & File.getAbsolutePath & File.getCanonicalPath\n\n```java\npublic static void testGetPath() {\n\t\tFile file = new File(\"./resource/data.txt\");\n\t\tSystem.out.println(\"File.getPath(): \" + file.getPath());\n\t\tSystem.out.println(\"File.getAbsolutePath(): \"+ file.getAbsolutePath());\n\t\ttry {\n\t\t\tSystem.out.println(\"File.getCanonicalPath(): \" + file.getCanonicalPath());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n上述代码运行结果：\n\n```\nFile.getPath(): ./resource/data.txt\nFile.getAbsolutePath(): /home/yukai/workspace/test/./resource/data.txt\nFile.getCanonicalPath(): /home/yukai/workspace/test/resource/data.txt\n```\n摘抄一段[stackoverflow](http://stackoverflow.com/questions/1099300/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath)上的答案:\n\n```\ngetPath() gets the path string that the File object was constructed with, and it may be relative current directory.\n\ngetAbsolutePath() gets the path string after resolving it against the current directory if it's relative, resulting in a fully qualified path.\n\ngetCanonicalPath() gets the path string after resolving any relative path against current directory, and removes any relative pathing (. and ..), and any file system links to return a path which the file system considers the canonical means to reference the file system object to which it points.\n```\n\n## 读取classpath下的文件\n\n```java\npublic static void getClassPath() {\n\t\tSystem.out.println(\"PathTest.class.getResource(\\\"/\\\"): \" + PathTest.class.getResource(\"/\"));\n\t\tSystem.out.println(\"PathTest.class.getResource(\\\"\\\"): \" + PathTest.class.getResource(\"\"));\n\t\t\n\t\tSystem.out.println(\"PathTest.class.getClassLoader().getResource(\\\"/\\\"): \" + PathTest.class.getClassLoader().getResource(\"/\"));\n\t\tSystem.out.println(\"PathTest.class.getClassLoader().getResource(\\\"\\\"): \" + PathTest.class.getClassLoader().getResource(\"\"));\n}\n```\n\n运行结果(Eclipse)：\n\n```\n//以“/”开头，表示相对于package根目录\nPathTest.class.getResource(\"/\"): file:/home/yukai/workspace/test/bin/\n//不以“/”开头，表示相对于class文件所在目录\nPathTest.class.getResource(\"\"): file:/home/yukai/workspace/test/bin/test/\n//\nPathTest.class.getClassLoader().getResource(\"/\"): null\n//getClassLoader().getResource(\"\")不以“/”开头，相对于package根目录\nPathTest.class.getClassLoader().getResource(\"\"): file:/home/yukai/workspace/test/bin/\n```\n## 获取jar包路径\n\njava开发中常常需要取得程序生成的jar包所在的路径，比如生成一些log文件的时候，需要把该程序生成的log放到jar包的的同级目录下。\n此时，我们需要知道jar包所在的位置，注意，不是启动jvm实例的位置。\n\n```\nURL url = Config.class.getProtectionDomain().getCodeSource().getLocation();\nString path = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null).getPath(); \nif (path != null) {   \n   if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {      \n          path = path.substring(0, path.length() - 1);    \n   }    \n   if (path.endsWith(\".jar\")) {        \n          int index = path.lastIndexOf(\"/\");\n          if (index != -1) {           \n                path = path.substring(0, index);\n          }\n          defultLogPath = path + File.separator + \"log\";\n   } else { \n       defultLogPath = path + File.separator + \"..\" + File.separator + \"log\" ;\n   }\n}\n```\n\n## Path.java\n\njdk1.7之后，新增了一个类File,位于java.nio.file下，该类提供了一些路径的操作。\n\n具体的使用不一一介绍，用到时可查找oracle的官方手册，已经写的很详细了：[Path Operations](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html)\n","slug":"java中的路径","published":1,"updated":"2017-01-21T14:24:42.188Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj4p000wdigcuecrp6cj","content":"<blockquote>\n<p>每次写java代码的时候，免不了需要加载一些外部资源，比如配置文件等等。每当需要读取这些文件时，都是去网上谷歌，写过就忘。于是今天来总结一些java中有关路径的一些用法。</p>\n</blockquote>\n<h2 id=\"绝对路径\"><a href=\"#绝对路径\" class=\"headerlink\" title=\"绝对路径\"></a>绝对路径</h2><p>无论是在linux还是windows中，路径都分为绝对路径和相对路径两种。</p>\n<p>绝对路径就是系统中唯一能够定位资源的某个URI，即完整的描述文件的路径就是绝对路径。比如：</p>\n<p>linux中的绝对路径：/home/yukai/test.txt</p>\n<p>windows中的绝对路径：E:\\yukai\\test.txt</p>\n<p>绝对路径都是以根目录起始的。</p>\n<h2 id=\"相对路径\"><a href=\"#相对路径\" class=\"headerlink\" title=\"相对路径\"></a>相对路径</h2><p>相对路径即目标文件相对与某个基准目录的路径。比如:</p>\n<p>存在文件： </p>\n<p>A: /home/yukai/test.txt </p>\n<p>B: /home/yukai/test1.txt </p>\n<p>C: /home/yukai/test/test.txt</p>\n<p>那么：</p>\n<p>若基准目录为A, B的路径表示为”test1.txt”</p>\n<p>若基准目录为B, C的路径表示为”test/test.txt”</p>\n<p>若基准目录为C, B的路径表示为”../test1.txt”</p>\n<p>另外，“./”表示当前目录，“../”表示上级目录</p>\n<h2 id=\"java-io定位文件资源\"><a href=\"#java-io定位文件资源\" class=\"headerlink\" title=\"java io定位文件资源\"></a>java io定位文件资源</h2><p>那么，我们在java中如何读取某个文件？上代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 目录结构</div><div class=\"line\">src</div><div class=\"line\"> |</div><div class=\"line\"> |--test</div><div class=\"line\"> |   |</div><div class=\"line\"> |   |--PathTest.java </div><div class=\"line\"> |</div><div class=\"line\">resource</div><div class=\"line\"> |</div><div class=\"line\"> |--data.txt</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PathTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String  dataFilePath = <span class=\"string\">\"resource/data.txty\"</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getUserDir</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//打印运行程序的目录，即启动java程序的目录</span></div><div class=\"line\">\t\tString userDir = System.getProperty(<span class=\"string\">\"user.dir\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行java的工作目录 System.getProperty(\\\"user.dir\\\")： \"</span> + userDir);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> userDir;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"&gt;&gt; Path = System.getProperty(\\\"user.dir\\\") + \\\"resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString userDir = getUserDir();</div><div class=\"line\">\t\t<span class=\"comment\">//等同于 \"resource/data.txt\"</span></div><div class=\"line\">\t\tString filePath = userDir + System.getProperty(<span class=\"string\">\"file.separator\"</span>) + dataFilePath;</div><div class=\"line\">\t\tprintFileContent(filePath ,msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"Path = \\\"resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString filePath = dataFilePath;</div><div class=\"line\">\t\tprintFileContent(filePath, msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath3</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"Path = \\\"./resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString filePath = <span class=\"string\">\"./resource/data.txt\"</span>;</div><div class=\"line\">\t\tprintFileContent(filePath, msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printFileContent</span><span class=\"params\">(String filePath, String msg)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"****************************\"</span>);</div><div class=\"line\">\t\tSystem.out.println(msg);</div><div class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(filePath);</div><div class=\"line\">\t\tInputStream stream;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tstream = <span class=\"keyword\">new</span> FileInputStream(file);</div><div class=\"line\">\t\t\tBufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(stream));</div><div class=\"line\">\t\t\tString line = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> ((line = reader.readLine()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"****************************\"</span>);</div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\ttestDataPath1();</div><div class=\"line\">\t\ttestDataPath2();</div><div class=\"line\">\t\ttestDataPath3();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中<code>testDataPath2</code>、<code>testDataPath1</code>、<code>testDataPath3</code>这三个方法的效果是一样的。</p>\n<p><code>System.getProperty(&quot;user.dir&quot;)</code>这个方法获取了当前的工作目录，也就是启动jvm的目录。例如：</p>\n<p>ps: 更多关于System.getProperty()的介绍：<a href=\"http://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html\" target=\"_blank\" rel=\"external\">System Properties</a></p>\n<p>你的java程序位于：/home/yukai/code/test.jar </p>\n<p>若你在目录/home/yukai下使用命令 <code>java -cp code/test.jar test.PathTest</code> 启动java程序时，目录/home/yukai就是你的工作目录。</p>\n<p>在<code>testDataPath2</code>当中，直接使用”resource/data.txty”来作为文件读取路径时，java会默认为基准目录为当前的工作目录，”resource/data.txty”此时就是相对于这个基准目录的路径。<br>也就是说，java会把工作目录与”resource/data.txty”拼接起来，作为一个绝对路径去读取文件，也就是<code>testDataPath1</code>中的例子。</p>\n<p>有Eclipse中启动你的java工程的目录就是工程根目录，工程根目录也就是工作目录，如果你读取文件的方式类似于<code>testDataPath2</code>的话，他会在工程根目录下找你的文件。<br>有时候我们会遇到，在Eclipse中读取文件没有问题，但是打成jar包之后运行(像上面运行jar包的例子)就会报找不到文件的错误。那么此时就要检查你的当前工作目录下(/home/yukai)是否有这些文件的存在了。</p>\n<h2 id=\"File-getPath-amp-File-getAbsolutePath-amp-File-getCanonicalPath\"><a href=\"#File-getPath-amp-File-getAbsolutePath-amp-File-getCanonicalPath\" class=\"headerlink\" title=\"File.getPath &amp; File.getAbsolutePath &amp; File.getCanonicalPath\"></a>File.getPath &amp; File.getAbsolutePath &amp; File.getCanonicalPath</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGetPath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"./resource/data.txt\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"File.getPath(): \"</span> + file.getPath());</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"File.getAbsolutePath(): \"</span>+ file.getAbsolutePath());</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"File.getCanonicalPath(): \"</span> + file.getCanonicalPath());</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">File.getPath(): ./resource/data.txt</div><div class=\"line\">File.getAbsolutePath(): /home/yukai/workspace/test/./resource/data.txt</div><div class=\"line\">File.getCanonicalPath(): /home/yukai/workspace/test/resource/data.txt</div></pre></td></tr></table></figure>\n<p>摘抄一段<a href=\"http://stackoverflow.com/questions/1099300/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath\" target=\"_blank\" rel=\"external\">stackoverflow</a>上的答案:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">getPath() gets the path string that the File object was constructed with, and it may be relative current directory.</div><div class=\"line\"></div><div class=\"line\">getAbsolutePath() gets the path string after resolving it against the current directory if it&apos;s relative, resulting in a fully qualified path.</div><div class=\"line\"></div><div class=\"line\">getCanonicalPath() gets the path string after resolving any relative path against current directory, and removes any relative pathing (. and ..), and any file system links to return a path which the file system considers the canonical means to reference the file system object to which it points.</div></pre></td></tr></table></figure>\n<h2 id=\"读取classpath下的文件\"><a href=\"#读取classpath下的文件\" class=\"headerlink\" title=\"读取classpath下的文件\"></a>读取classpath下的文件</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getClassPath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getResource(\\\"/\\\"): \"</span> + PathTest.class.getResource(<span class=\"string\">\"/\"</span>));</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getResource(\\\"\\\"): \"</span> + PathTest.class.getResource(<span class=\"string\">\"\"</span>));</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getClassLoader().getResource(\\\"/\\\"): \"</span> + PathTest.class.getClassLoader().getResource(<span class=\"string\">\"/\"</span>));</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getClassLoader().getResource(\\\"\\\"): \"</span> + PathTest.class.getClassLoader().getResource(<span class=\"string\">\"\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果(Eclipse)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以“/”开头，表示相对于package根目录</div><div class=\"line\">PathTest.class.getResource(&quot;/&quot;): file:/home/yukai/workspace/test/bin/</div><div class=\"line\">//不以“/”开头，表示相对于class文件所在目录</div><div class=\"line\">PathTest.class.getResource(&quot;&quot;): file:/home/yukai/workspace/test/bin/test/</div><div class=\"line\">//</div><div class=\"line\">PathTest.class.getClassLoader().getResource(&quot;/&quot;): null</div><div class=\"line\">//getClassLoader().getResource(&quot;&quot;)不以“/”开头，相对于package根目录</div><div class=\"line\">PathTest.class.getClassLoader().getResource(&quot;&quot;): file:/home/yukai/workspace/test/bin/</div></pre></td></tr></table></figure>\n<h2 id=\"获取jar包路径\"><a href=\"#获取jar包路径\" class=\"headerlink\" title=\"获取jar包路径\"></a>获取jar包路径</h2><p>java开发中常常需要取得程序生成的jar包所在的路径，比如生成一些log文件的时候，需要把该程序生成的log放到jar包的的同级目录下。<br>此时，我们需要知道jar包所在的位置，注意，不是启动jvm实例的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">URL url = Config.class.getProtectionDomain().getCodeSource().getLocation();</div><div class=\"line\">String path = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null).getPath(); </div><div class=\"line\">if (path != null) &#123;   </div><div class=\"line\">   if (path.endsWith(&quot;/&quot;) || path.endsWith(&quot;\\\\&quot;)) &#123;      </div><div class=\"line\">          path = path.substring(0, path.length() - 1);    </div><div class=\"line\">   &#125;    </div><div class=\"line\">   if (path.endsWith(&quot;.jar&quot;)) &#123;        </div><div class=\"line\">          int index = path.lastIndexOf(&quot;/&quot;);</div><div class=\"line\">          if (index != -1) &#123;           </div><div class=\"line\">                path = path.substring(0, index);</div><div class=\"line\">          &#125;</div><div class=\"line\">          defultLogPath = path + File.separator + &quot;log&quot;;</div><div class=\"line\">   &#125; else &#123; </div><div class=\"line\">       defultLogPath = path + File.separator + &quot;..&quot; + File.separator + &quot;log&quot; ;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Path-java\"><a href=\"#Path-java\" class=\"headerlink\" title=\"Path.java\"></a>Path.java</h2><p>jdk1.7之后，新增了一个类File,位于java.nio.file下，该类提供了一些路径的操作。</p>\n<p>具体的使用不一一介绍，用到时可查找oracle的官方手册，已经写的很详细了：<a href=\"https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html\" target=\"_blank\" rel=\"external\">Path Operations</a></p>\n","excerpt":"","more":"<blockquote>\n<p>每次写java代码的时候，免不了需要加载一些外部资源，比如配置文件等等。每当需要读取这些文件时，都是去网上谷歌，写过就忘。于是今天来总结一些java中有关路径的一些用法。</p>\n</blockquote>\n<h2 id=\"绝对路径\"><a href=\"#绝对路径\" class=\"headerlink\" title=\"绝对路径\"></a>绝对路径</h2><p>无论是在linux还是windows中，路径都分为绝对路径和相对路径两种。</p>\n<p>绝对路径就是系统中唯一能够定位资源的某个URI，即完整的描述文件的路径就是绝对路径。比如：</p>\n<p>linux中的绝对路径：/home/yukai/test.txt</p>\n<p>windows中的绝对路径：E:\\yukai\\test.txt</p>\n<p>绝对路径都是以根目录起始的。</p>\n<h2 id=\"相对路径\"><a href=\"#相对路径\" class=\"headerlink\" title=\"相对路径\"></a>相对路径</h2><p>相对路径即目标文件相对与某个基准目录的路径。比如:</p>\n<p>存在文件： </p>\n<p>A: /home/yukai/test.txt </p>\n<p>B: /home/yukai/test1.txt </p>\n<p>C: /home/yukai/test/test.txt</p>\n<p>那么：</p>\n<p>若基准目录为A, B的路径表示为”test1.txt”</p>\n<p>若基准目录为B, C的路径表示为”test/test.txt”</p>\n<p>若基准目录为C, B的路径表示为”../test1.txt”</p>\n<p>另外，“./”表示当前目录，“../”表示上级目录</p>\n<h2 id=\"java-io定位文件资源\"><a href=\"#java-io定位文件资源\" class=\"headerlink\" title=\"java io定位文件资源\"></a>java io定位文件资源</h2><p>那么，我们在java中如何读取某个文件？上代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 目录结构</div><div class=\"line\">src</div><div class=\"line\"> |</div><div class=\"line\"> |--test</div><div class=\"line\"> |   |</div><div class=\"line\"> |   |--PathTest.java </div><div class=\"line\"> |</div><div class=\"line\">resource</div><div class=\"line\"> |</div><div class=\"line\"> |--data.txt</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PathTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String  dataFilePath = <span class=\"string\">\"resource/data.txty\"</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getUserDir</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//打印运行程序的目录，即启动java程序的目录</span></div><div class=\"line\">\t\tString userDir = System.getProperty(<span class=\"string\">\"user.dir\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行java的工作目录 System.getProperty(\\\"user.dir\\\")： \"</span> + userDir);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> userDir;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"&gt;&gt; Path = System.getProperty(\\\"user.dir\\\") + \\\"resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString userDir = getUserDir();</div><div class=\"line\">\t\t<span class=\"comment\">//等同于 \"resource/data.txt\"</span></div><div class=\"line\">\t\tString filePath = userDir + System.getProperty(<span class=\"string\">\"file.separator\"</span>) + dataFilePath;</div><div class=\"line\">\t\tprintFileContent(filePath ,msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"Path = \\\"resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString filePath = dataFilePath;</div><div class=\"line\">\t\tprintFileContent(filePath, msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath3</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"Path = \\\"./resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString filePath = <span class=\"string\">\"./resource/data.txt\"</span>;</div><div class=\"line\">\t\tprintFileContent(filePath, msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printFileContent</span><span class=\"params\">(String filePath, String msg)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"****************************\"</span>);</div><div class=\"line\">\t\tSystem.out.println(msg);</div><div class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(filePath);</div><div class=\"line\">\t\tInputStream stream;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tstream = <span class=\"keyword\">new</span> FileInputStream(file);</div><div class=\"line\">\t\t\tBufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(stream));</div><div class=\"line\">\t\t\tString line = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> ((line = reader.readLine()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"****************************\"</span>);</div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\ttestDataPath1();</div><div class=\"line\">\t\ttestDataPath2();</div><div class=\"line\">\t\ttestDataPath3();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中<code>testDataPath2</code>、<code>testDataPath1</code>、<code>testDataPath3</code>这三个方法的效果是一样的。</p>\n<p><code>System.getProperty(&quot;user.dir&quot;)</code>这个方法获取了当前的工作目录，也就是启动jvm的目录。例如：</p>\n<p>ps: 更多关于System.getProperty()的介绍：<a href=\"http://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html\">System Properties</a></p>\n<p>你的java程序位于：/home/yukai/code/test.jar </p>\n<p>若你在目录/home/yukai下使用命令 <code>java -cp code/test.jar test.PathTest</code> 启动java程序时，目录/home/yukai就是你的工作目录。</p>\n<p>在<code>testDataPath2</code>当中，直接使用”resource/data.txty”来作为文件读取路径时，java会默认为基准目录为当前的工作目录，”resource/data.txty”此时就是相对于这个基准目录的路径。<br>也就是说，java会把工作目录与”resource/data.txty”拼接起来，作为一个绝对路径去读取文件，也就是<code>testDataPath1</code>中的例子。</p>\n<p>有Eclipse中启动你的java工程的目录就是工程根目录，工程根目录也就是工作目录，如果你读取文件的方式类似于<code>testDataPath2</code>的话，他会在工程根目录下找你的文件。<br>有时候我们会遇到，在Eclipse中读取文件没有问题，但是打成jar包之后运行(像上面运行jar包的例子)就会报找不到文件的错误。那么此时就要检查你的当前工作目录下(/home/yukai)是否有这些文件的存在了。</p>\n<h2 id=\"File-getPath-amp-File-getAbsolutePath-amp-File-getCanonicalPath\"><a href=\"#File-getPath-amp-File-getAbsolutePath-amp-File-getCanonicalPath\" class=\"headerlink\" title=\"File.getPath &amp; File.getAbsolutePath &amp; File.getCanonicalPath\"></a>File.getPath &amp; File.getAbsolutePath &amp; File.getCanonicalPath</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGetPath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"./resource/data.txt\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"File.getPath(): \"</span> + file.getPath());</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"File.getAbsolutePath(): \"</span>+ file.getAbsolutePath());</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"File.getCanonicalPath(): \"</span> + file.getCanonicalPath());</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">File.getPath(): ./resource/data.txt</div><div class=\"line\">File.getAbsolutePath(): /home/yukai/workspace/test/./resource/data.txt</div><div class=\"line\">File.getCanonicalPath(): /home/yukai/workspace/test/resource/data.txt</div></pre></td></tr></table></figure>\n<p>摘抄一段<a href=\"http://stackoverflow.com/questions/1099300/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath\">stackoverflow</a>上的答案:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">getPath() gets the path string that the File object was constructed with, and it may be relative current directory.</div><div class=\"line\"></div><div class=\"line\">getAbsolutePath() gets the path string after resolving it against the current directory if it&apos;s relative, resulting in a fully qualified path.</div><div class=\"line\"></div><div class=\"line\">getCanonicalPath() gets the path string after resolving any relative path against current directory, and removes any relative pathing (. and ..), and any file system links to return a path which the file system considers the canonical means to reference the file system object to which it points.</div></pre></td></tr></table></figure>\n<h2 id=\"读取classpath下的文件\"><a href=\"#读取classpath下的文件\" class=\"headerlink\" title=\"读取classpath下的文件\"></a>读取classpath下的文件</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getClassPath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getResource(\\\"/\\\"): \"</span> + PathTest.class.getResource(<span class=\"string\">\"/\"</span>));</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getResource(\\\"\\\"): \"</span> + PathTest.class.getResource(<span class=\"string\">\"\"</span>));</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getClassLoader().getResource(\\\"/\\\"): \"</span> + PathTest.class.getClassLoader().getResource(<span class=\"string\">\"/\"</span>));</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getClassLoader().getResource(\\\"\\\"): \"</span> + PathTest.class.getClassLoader().getResource(<span class=\"string\">\"\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果(Eclipse)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以“/”开头，表示相对于package根目录</div><div class=\"line\">PathTest.class.getResource(&quot;/&quot;): file:/home/yukai/workspace/test/bin/</div><div class=\"line\">//不以“/”开头，表示相对于class文件所在目录</div><div class=\"line\">PathTest.class.getResource(&quot;&quot;): file:/home/yukai/workspace/test/bin/test/</div><div class=\"line\">//</div><div class=\"line\">PathTest.class.getClassLoader().getResource(&quot;/&quot;): null</div><div class=\"line\">//getClassLoader().getResource(&quot;&quot;)不以“/”开头，相对于package根目录</div><div class=\"line\">PathTest.class.getClassLoader().getResource(&quot;&quot;): file:/home/yukai/workspace/test/bin/</div></pre></td></tr></table></figure>\n<h2 id=\"获取jar包路径\"><a href=\"#获取jar包路径\" class=\"headerlink\" title=\"获取jar包路径\"></a>获取jar包路径</h2><p>java开发中常常需要取得程序生成的jar包所在的路径，比如生成一些log文件的时候，需要把该程序生成的log放到jar包的的同级目录下。<br>此时，我们需要知道jar包所在的位置，注意，不是启动jvm实例的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">URL url = Config.class.getProtectionDomain().getCodeSource().getLocation();</div><div class=\"line\">String path = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null).getPath(); </div><div class=\"line\">if (path != null) &#123;   </div><div class=\"line\">   if (path.endsWith(&quot;/&quot;) || path.endsWith(&quot;\\\\&quot;)) &#123;      </div><div class=\"line\">          path = path.substring(0, path.length() - 1);    </div><div class=\"line\">   &#125;    </div><div class=\"line\">   if (path.endsWith(&quot;.jar&quot;)) &#123;        </div><div class=\"line\">          int index = path.lastIndexOf(&quot;/&quot;);</div><div class=\"line\">          if (index != -1) &#123;           </div><div class=\"line\">                path = path.substring(0, index);</div><div class=\"line\">          &#125;</div><div class=\"line\">          defultLogPath = path + File.separator + &quot;log&quot;;</div><div class=\"line\">   &#125; else &#123; </div><div class=\"line\">       defultLogPath = path + File.separator + &quot;..&quot; + File.separator + &quot;log&quot; ;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Path-java\"><a href=\"#Path-java\" class=\"headerlink\" title=\"Path.java\"></a>Path.java</h2><p>jdk1.7之后，新增了一个类File,位于java.nio.file下，该类提供了一些路径的操作。</p>\n<p>具体的使用不一一介绍，用到时可查找oracle的官方手册，已经写的很详细了：<a href=\"https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html\">Path Operations</a></p>\n"},{"layout":"post","title":"java异常的学习","date":"2016-12-13T13:46:52.000Z","_content":"\n>最近的写代码的过程中，遇到很多异常的处理，以前上大学的时候写代码，遇到异常直接给个try catch了事，只是停留在看懂异常能够找出异常抛出点的水平。真正写代码的时候，不了解java的异常机制给自己编程带来很多不便，基础知识很重要！学习之～～\n\n## 异常分类\n\n{% asset_img java.png java异常体系 %}\n\njava异常中的异常大体上可分为两类：Error 与 Exception，他们都继承自Throwable\n\n### Error：\n\nError表示一些无法恢复的错误，会导致应用程序中断。比如我们喜闻乐见的OutOfMemoryError(内存溢出)， StackOverflowError(堆栈溢出)等，就是一种Error类型的异常。面对这种类型的异常在我们的应用程序中一般是无法挽救的，将直接导致程序错误退出。因此我们在代码中一般不必去特别关心这种类型的异常。\n\n[Error类型的异常及其子类](https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html)\n\n### Exception:\n\nException是一般常见的异常，我们的应用程序可以处理这些异常，比如NullPointerException、IndexOutOfBoundsException等等。发生这些异常时，可以选择通过捕获这些异常进行处理，使程序可以继续往下执行。\n\nException又可以分为CheckException(检测型异常)与UncheckException(非检测型异常)。\n\n在Exception的子类当中，非检测型异常为RuntimeException及其子类，剩下的异常则为检测型异常。\n\n#### 检测型异常\n\n所谓检测型异常，表示其接受编译器的检测，比如\n\n```\npublic void readFile(String filePath){\n        //编译无法通过\n\t\tFile file = new File(filePath);\n\t\tFileReader fileReader = new FileReader(file);//FileNotFoundException\n\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\tString line = null;\n\t\twhile ((line = bReader.readLine()) != null) {//IOException\n\t\t\tSystem.out.println(line);\n\t\t}\n}\n```\n编译上述代码，编译器会报错，编译无法通过。\n如果是用Eclipse等ide去写这段代码，ide通常就会告诉你这段代码有错误。原因是上述代码会抛出检测型异常IOException。有以下两种修复错误的方法：\n\n```\n//第一种\npublic void readFile(String filePath) throws IOException{\n\t\tFile file = new File(filePath);\n\t\tFileReader fileReader = new FileReader(file);\n\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\tString line = null;\n\t\twhile ((line = bReader.readLine()) != null) {\n\t\t\tSystem.out.println(line);\n\t\t}\n}\n//第二种\npublic void readFile(String filePath) {\n\t\tFile file = new File(filePath);\n\t\ttry {\n\t\t\tFileReader fileReader = new FileReader(file);\n\t\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\t\tString line = null;\n\t\t\twhile ((line = bReader.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t// TODO: handle exception\n\t\t}\n}\n```\n\n第一种方式通过声明throws关键字将该异常继续向上抛出，这种方式下，该方法就抛出了检测型异常，他的调用者就会遇到一样的问题，调用者可以选择使用这种方式继续向调用链上层抛出，或者采用第二种方式处理异常。\n\n第二种方式通过将抛出异常的代码使用try..catch块包裹起来，处理该异常。这种方式下他的调用者无需再次处理该异常。\n\n上面这种类型的异常就是检测型异常，我们必须显示的去处理他，代表的有SQLException、IOException等等。\n\n#### 非检测型异常\n\n与检测型异常相对的，编译阶段不会检测这种类型的异常，当代码中有这种类型的异常抛出时，我们不需要像上面那样显示的处理他，比如：\n\n```\npublic void test() {\n        //编译可以通过\n\t\tthrow new NullPointerException();\n}\n```\n通过throw关键字抛出了一个NullPointerException异常，该异常是RunTimeException的子类，是一个非检测类型的异常。这种类型的异常一般是由程序逻辑错误引起的，比如空指针或者数组越界等等。\n\n对于非检测类型的异常，我们也可以去使用try..catch捕获他，从而进行一些处理。如果我们没有捕获处理这个异常，系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，**这个线程也就退出了**。如果是主程序抛出的异常，**那么这整个程序也就退出了**。\n\nError实际上也是一种非检测型异常。\n\n## 异常处理\n\n### 关键字\n\n了解了异常的分类，我们就可以愉快的处理异常了。记得上大学的时候写的代码，由于不理解java的异常机制，每当遇到检测型异常时，ide会要求在代码中处理这种情况。于是简单的try..catch解决，并在catch块中 e.printStackTrace()，就解决了IDE的报警问题。现在想来，这种代码如果运行在生产环境中，将会多么可怕。\n\n通过上面的总结，我们已经了解了四个关键字：try catch throw throws.\n\nthrow表示将要抛出一个异常，后面跟一个Throwable的实例，throws置于函数的声明当中，表示该函数将会抛出何种类型的异常。\n\ntry catch 一般配合使用，还有一个关键字finally,也是与try catch 配合使用的。有这三种使用方式：\n\ntry..catch  try..finally try..catch..finally\n\ncatch 可以有多个，try只能有一个，finally可选。\n\nfinally用于保证一些资源的释放，因为一般情况下，finally中的语句总会在方法返回之前得到执行。\n\n### try catch finally执行顺序\n\ntry catch finally的执行顺序为 try->catch->finally。\n\n有多个catch时，按照catch块的先后顺序进行匹配，一旦一个异常与一个catch块匹配，则不会再与后面的catch块进行匹配。\n因此，如果我们使用多个catch块捕获异常时，如果多个catch块捕获的异常具有继承关系，注意把继承链中低层次(也就是子类)的放在前面，把继承链中高层次的(也就是父类)放在后面。\n这样做的目的很简单，就是尽量使异常被适合的catch所捕获，这样处理起来比较明确。\n\nfinally块中的代码一般是在try与catch内的控制转移语句执行之前执行的，用来做一些资源释放的操作。控制转移语句包括：return、throw、break 和 continue。\n\n关于finally块的详细解析，参考[关于 Java 中 finally 语句块的深度辨析](https://www.ibm.com/developerworks/cn/java/j-lo-finally/)\n\n另外有一点需要注意：不要在finally中return，因为finally中的return会覆盖已有的返回值，比如try或者catch中的返回值。比如：\n\n```\npublic class TestException {\n    public static void main(String[] args) {\n        String str = new TestException().readFile();\n        System.out.println(str);\n    }\n \n    public String readFile() {\n        try {\n            FileInputStream inputStream = new FileInputStream(\"D:/test.txt\");\n            int ch = inputStream.read();\n            return \"try\";\n        } catch (FileNotFoundException e) {\n            System.out.println(\"file not found\");\n            return \"FileNotFoundException\";\n        }catch (IOException e) {\n            System.out.println(\"io exception\");\n            return \"IOException\";\n        }finally{\n            System.out.println(\"finally block\");\n            //return \"finally\";\n        }\n    }\n}\n```\nD:/test.txt 并不存在，执行结果为:file not found    finally block   FileNotFoundException\n去掉finally中的注释，执行结果为：file not found    finally block   finally\n\n\n## 一些建议\n\n了解了异常机制的基本原理，不一定能够很好的处理异常。当我们遇到异常需要处理的时候，需要遵循几个原则，才能写出更好的代码：\n\n### 不要使用空的catch块\n\n正如前面所说，上学的时候遇到异常时，直接try..catch了事，只是简单地e.printStackTrace(),把堆栈打印出来了。这样可能对定位异常比较有帮助，但是对异常的处理却没有帮助，既没有处理异常，上层代码也无法得知异常的抛出，\n程序会继续运行，有可能出现无法预料的结果。当然，如果程序的逻辑容忍异常可以不用处理，那么可以不处理异常，简单的输出到日志记录即可。处理还需视实际情况而定。\n\n### 在能够处理异常的地方处理异常\n\n换句话说，就是在高层代码中处理异常。尽量将异常抛给上层调用者，由上层调用者统一进行处理。这样会使得程序流程比较清晰。\n\n### 日志打印\n\n只在必要的地方打印日志，如只在异常发生的地方输出日志，然后将异常抛到上层。这样比较容易定位异常，避免每次向上抛出异常时都打印日志，反复打印同一个异常会使得日志变得混乱\n\n### 检测异常与非检测异常的选择\n\n为可恢复的条件使用检查型异常，为编程错误使用运行时异常\n\n在web项目中，我们经常把代码层次分为controller，service,dao等几层。在dao层中一搬会抛出SQLException,这就使得他的调用者必须显示的捕获该异常或者继续抛出。这样提高了代码的耦合性，污染了上层代码。\n在比如接口的声明当中，我们为方法声明了一个检测型异常，那么他的所有实现类都必须作出同样的声明，即使实现类不会抛出异常。而且，所有的调用者都必须显示的捕获异常或者抛出异常，异常就会扩散开来，会使代码变得混乱。\n所以我们应该正确的选择检测型异常和非检测型异常。个人认为，检测型异常的意义就在于提醒用户进行处理，比如一些资源的释放等等。如果该异常出现的很普遍，需要提醒调用者进行处理，那么就是用检测型异常，否则，就使用非检测型异常。\n\n对于已经抛出的检测型异常，我们可以进行封装处理，比如对于第一种情况，污染上层代码的问题：\n\n```\n//处理前\npublic Data getDataById(Long id) throw SQLException {\n //根据 ID 查询数据库\n}\n\n//处理后\npublic Data getDataById(Long id) {\n     try{\n            //根据 ID 查询数据库\n     }catch(SQLException e){\n            //利用非检测异常封装检测异常，降低层次耦合\n            throw new RuntimeException(SQLErrorCode, e);\n     }finally{\n            //关闭连接，清理资源\n     }\n}\n\n```\n我们将一个检测型异常封装成了非检测型异常向上抛出。\n\n### 不要使用Exception捕捉所有潜在的异常\n\n针对具体的异常进行处理，而不是使用Exception捕获所有的异常。这样不利于异常情况的处理，并且如果再次向上抛出时可能会丢书原有的异常信息。 \n\n### 抛出与抽象相适应的异常\n\n换句话说，一个方法所抛出的异常应该在一个抽象层次上定义，该抽象层次与该方法做什么相一致，而不一定与方法的底层实现细节相一致。例如，一个从文件、数据库或者 JNDI 装载资源的方法在不能找到资源时，应该抛出某种 ResourceNotFound 异常（通常使用异常链来保存隐含的原因），而不是更底层的 IOException 、 SQLException 或者 NamingException 。\n\n我们有时候在捕获一个异常后抛出另一个封装后的异常信息，并且希望将原始的异常信息也保持起来，\nthrow抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？\n在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。\n\n### 多线程中的异常\n\n在java多线程程序中，所有线程都不允许抛出未捕获的检测型异常（比如sleep时的InterruptedException),\n也就是说各个线程需要自己把自己的检测型处理掉。\n这一点是通过java.lang.Runnable.run()方法声明(因为此方法声明上没有throw exception部分)进行了约束。\n但是线程依然有可能抛出非检测型异常，当此类异常跑抛出时，线程就会终结，\n而对于主线程和其他线程完全不受影响，且完全感知不到某个线程抛出的异常(也是说完全无法catch到这个异常)。\n\n如果我们不考虑线程内可能出现的异常而导致线程的终结，那么就有可能造成意想不到的后果。如果是使用线程池的话，就有可能导致线程泄漏，这样的错误可能难以察觉，\n最终导致程序挂掉或者内存溢出等等意想不到的问题，但是往往不好追踪问题出现的原因。\n[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章很好的展示了一个多线程发生异常后产生的一系列后果。\n\n对于线程可以自己处理的异常，比较好解决。我们可以在线程内部捕获异常，作一些处理，防止线程退出。比如，[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章中的一个示例：\n\n```\nprivate class SaferPoolWorker extends Thread {\n    public void run() {\n        IncomingResponse ir;\n        while (true) {\n            ir = (IncomingResponse) queue.getNext();\n            PlugIn plugIn = findPlugIn(ir.getResponseId());\n            if (plugIn != null) {\n        try {\n                    plugIn.handleMessage(ir.getResponse());\n                }\n                catch (RuntimeException e) {\n                    // Take some sort of action; \n                    // - log the exception and move on\n                    // - log the exception and restart the worker thread\n                    // - log the exception and unload the offending plug-in\n                }\n            }\n            else\n                log(\"Unknown plug-in for response \" + ir.getResponseId());\n        }\n    }\n}\n```\n但是，当子线程发生异常时，我们需要父线程或者主线程可以感知子线程的异常，也就是得到子线程产生的异常，然后做一些处理。[Java线程池异常处理最佳实践](http://blog.onlycatch.com/post/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)这篇文章给出了很好的总结，\n摘抄其总结如下：\n```\n处理线程池中的异常有两种思路： \n1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池 \n2）由线程池统一处理\n对于execute方法提交的线程，有两种处理方式 \n1）自定义线程池并实现afterExecute方法 \n2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。\n对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。\n```\n\n## 其他\n\n还发现了一个比较有趣的异常处理情况，虽然可能很少碰到，但是碰到了可以参考作者的思路。\n\n[技巧：当不能抛出异常时](https://www.ibm.com/developerworks/cn/java/j-ce/)这篇文章介绍了一种不是很常见的情况：即不能处理，也不能抛出异常(包括非检测型异常)时怎么办？\n\n## 参考\n\n[Java 异常处理的误区和经验总结](http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/)\n\n[Java异常处理和设计](http://www.importnew.com/18994.html)\n\n[Java 理论与实践: 关于异常的争论](https://www.ibm.com/developerworks/cn/java/j-jtp05254/)\n\n","source":"_posts/java异常的学习.md","raw":"---\nlayout: post\ntitle: java异常的学习\ndate: 2016-12-13 21:46:52\ntags: java\n---\n\n>最近的写代码的过程中，遇到很多异常的处理，以前上大学的时候写代码，遇到异常直接给个try catch了事，只是停留在看懂异常能够找出异常抛出点的水平。真正写代码的时候，不了解java的异常机制给自己编程带来很多不便，基础知识很重要！学习之～～\n\n## 异常分类\n\n{% asset_img java.png java异常体系 %}\n\njava异常中的异常大体上可分为两类：Error 与 Exception，他们都继承自Throwable\n\n### Error：\n\nError表示一些无法恢复的错误，会导致应用程序中断。比如我们喜闻乐见的OutOfMemoryError(内存溢出)， StackOverflowError(堆栈溢出)等，就是一种Error类型的异常。面对这种类型的异常在我们的应用程序中一般是无法挽救的，将直接导致程序错误退出。因此我们在代码中一般不必去特别关心这种类型的异常。\n\n[Error类型的异常及其子类](https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html)\n\n### Exception:\n\nException是一般常见的异常，我们的应用程序可以处理这些异常，比如NullPointerException、IndexOutOfBoundsException等等。发生这些异常时，可以选择通过捕获这些异常进行处理，使程序可以继续往下执行。\n\nException又可以分为CheckException(检测型异常)与UncheckException(非检测型异常)。\n\n在Exception的子类当中，非检测型异常为RuntimeException及其子类，剩下的异常则为检测型异常。\n\n#### 检测型异常\n\n所谓检测型异常，表示其接受编译器的检测，比如\n\n```\npublic void readFile(String filePath){\n        //编译无法通过\n\t\tFile file = new File(filePath);\n\t\tFileReader fileReader = new FileReader(file);//FileNotFoundException\n\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\tString line = null;\n\t\twhile ((line = bReader.readLine()) != null) {//IOException\n\t\t\tSystem.out.println(line);\n\t\t}\n}\n```\n编译上述代码，编译器会报错，编译无法通过。\n如果是用Eclipse等ide去写这段代码，ide通常就会告诉你这段代码有错误。原因是上述代码会抛出检测型异常IOException。有以下两种修复错误的方法：\n\n```\n//第一种\npublic void readFile(String filePath) throws IOException{\n\t\tFile file = new File(filePath);\n\t\tFileReader fileReader = new FileReader(file);\n\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\tString line = null;\n\t\twhile ((line = bReader.readLine()) != null) {\n\t\t\tSystem.out.println(line);\n\t\t}\n}\n//第二种\npublic void readFile(String filePath) {\n\t\tFile file = new File(filePath);\n\t\ttry {\n\t\t\tFileReader fileReader = new FileReader(file);\n\t\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\t\tString line = null;\n\t\t\twhile ((line = bReader.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t// TODO: handle exception\n\t\t}\n}\n```\n\n第一种方式通过声明throws关键字将该异常继续向上抛出，这种方式下，该方法就抛出了检测型异常，他的调用者就会遇到一样的问题，调用者可以选择使用这种方式继续向调用链上层抛出，或者采用第二种方式处理异常。\n\n第二种方式通过将抛出异常的代码使用try..catch块包裹起来，处理该异常。这种方式下他的调用者无需再次处理该异常。\n\n上面这种类型的异常就是检测型异常，我们必须显示的去处理他，代表的有SQLException、IOException等等。\n\n#### 非检测型异常\n\n与检测型异常相对的，编译阶段不会检测这种类型的异常，当代码中有这种类型的异常抛出时，我们不需要像上面那样显示的处理他，比如：\n\n```\npublic void test() {\n        //编译可以通过\n\t\tthrow new NullPointerException();\n}\n```\n通过throw关键字抛出了一个NullPointerException异常，该异常是RunTimeException的子类，是一个非检测类型的异常。这种类型的异常一般是由程序逻辑错误引起的，比如空指针或者数组越界等等。\n\n对于非检测类型的异常，我们也可以去使用try..catch捕获他，从而进行一些处理。如果我们没有捕获处理这个异常，系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，**这个线程也就退出了**。如果是主程序抛出的异常，**那么这整个程序也就退出了**。\n\nError实际上也是一种非检测型异常。\n\n## 异常处理\n\n### 关键字\n\n了解了异常的分类，我们就可以愉快的处理异常了。记得上大学的时候写的代码，由于不理解java的异常机制，每当遇到检测型异常时，ide会要求在代码中处理这种情况。于是简单的try..catch解决，并在catch块中 e.printStackTrace()，就解决了IDE的报警问题。现在想来，这种代码如果运行在生产环境中，将会多么可怕。\n\n通过上面的总结，我们已经了解了四个关键字：try catch throw throws.\n\nthrow表示将要抛出一个异常，后面跟一个Throwable的实例，throws置于函数的声明当中，表示该函数将会抛出何种类型的异常。\n\ntry catch 一般配合使用，还有一个关键字finally,也是与try catch 配合使用的。有这三种使用方式：\n\ntry..catch  try..finally try..catch..finally\n\ncatch 可以有多个，try只能有一个，finally可选。\n\nfinally用于保证一些资源的释放，因为一般情况下，finally中的语句总会在方法返回之前得到执行。\n\n### try catch finally执行顺序\n\ntry catch finally的执行顺序为 try->catch->finally。\n\n有多个catch时，按照catch块的先后顺序进行匹配，一旦一个异常与一个catch块匹配，则不会再与后面的catch块进行匹配。\n因此，如果我们使用多个catch块捕获异常时，如果多个catch块捕获的异常具有继承关系，注意把继承链中低层次(也就是子类)的放在前面，把继承链中高层次的(也就是父类)放在后面。\n这样做的目的很简单，就是尽量使异常被适合的catch所捕获，这样处理起来比较明确。\n\nfinally块中的代码一般是在try与catch内的控制转移语句执行之前执行的，用来做一些资源释放的操作。控制转移语句包括：return、throw、break 和 continue。\n\n关于finally块的详细解析，参考[关于 Java 中 finally 语句块的深度辨析](https://www.ibm.com/developerworks/cn/java/j-lo-finally/)\n\n另外有一点需要注意：不要在finally中return，因为finally中的return会覆盖已有的返回值，比如try或者catch中的返回值。比如：\n\n```\npublic class TestException {\n    public static void main(String[] args) {\n        String str = new TestException().readFile();\n        System.out.println(str);\n    }\n \n    public String readFile() {\n        try {\n            FileInputStream inputStream = new FileInputStream(\"D:/test.txt\");\n            int ch = inputStream.read();\n            return \"try\";\n        } catch (FileNotFoundException e) {\n            System.out.println(\"file not found\");\n            return \"FileNotFoundException\";\n        }catch (IOException e) {\n            System.out.println(\"io exception\");\n            return \"IOException\";\n        }finally{\n            System.out.println(\"finally block\");\n            //return \"finally\";\n        }\n    }\n}\n```\nD:/test.txt 并不存在，执行结果为:file not found    finally block   FileNotFoundException\n去掉finally中的注释，执行结果为：file not found    finally block   finally\n\n\n## 一些建议\n\n了解了异常机制的基本原理，不一定能够很好的处理异常。当我们遇到异常需要处理的时候，需要遵循几个原则，才能写出更好的代码：\n\n### 不要使用空的catch块\n\n正如前面所说，上学的时候遇到异常时，直接try..catch了事，只是简单地e.printStackTrace(),把堆栈打印出来了。这样可能对定位异常比较有帮助，但是对异常的处理却没有帮助，既没有处理异常，上层代码也无法得知异常的抛出，\n程序会继续运行，有可能出现无法预料的结果。当然，如果程序的逻辑容忍异常可以不用处理，那么可以不处理异常，简单的输出到日志记录即可。处理还需视实际情况而定。\n\n### 在能够处理异常的地方处理异常\n\n换句话说，就是在高层代码中处理异常。尽量将异常抛给上层调用者，由上层调用者统一进行处理。这样会使得程序流程比较清晰。\n\n### 日志打印\n\n只在必要的地方打印日志，如只在异常发生的地方输出日志，然后将异常抛到上层。这样比较容易定位异常，避免每次向上抛出异常时都打印日志，反复打印同一个异常会使得日志变得混乱\n\n### 检测异常与非检测异常的选择\n\n为可恢复的条件使用检查型异常，为编程错误使用运行时异常\n\n在web项目中，我们经常把代码层次分为controller，service,dao等几层。在dao层中一搬会抛出SQLException,这就使得他的调用者必须显示的捕获该异常或者继续抛出。这样提高了代码的耦合性，污染了上层代码。\n在比如接口的声明当中，我们为方法声明了一个检测型异常，那么他的所有实现类都必须作出同样的声明，即使实现类不会抛出异常。而且，所有的调用者都必须显示的捕获异常或者抛出异常，异常就会扩散开来，会使代码变得混乱。\n所以我们应该正确的选择检测型异常和非检测型异常。个人认为，检测型异常的意义就在于提醒用户进行处理，比如一些资源的释放等等。如果该异常出现的很普遍，需要提醒调用者进行处理，那么就是用检测型异常，否则，就使用非检测型异常。\n\n对于已经抛出的检测型异常，我们可以进行封装处理，比如对于第一种情况，污染上层代码的问题：\n\n```\n//处理前\npublic Data getDataById(Long id) throw SQLException {\n //根据 ID 查询数据库\n}\n\n//处理后\npublic Data getDataById(Long id) {\n     try{\n            //根据 ID 查询数据库\n     }catch(SQLException e){\n            //利用非检测异常封装检测异常，降低层次耦合\n            throw new RuntimeException(SQLErrorCode, e);\n     }finally{\n            //关闭连接，清理资源\n     }\n}\n\n```\n我们将一个检测型异常封装成了非检测型异常向上抛出。\n\n### 不要使用Exception捕捉所有潜在的异常\n\n针对具体的异常进行处理，而不是使用Exception捕获所有的异常。这样不利于异常情况的处理，并且如果再次向上抛出时可能会丢书原有的异常信息。 \n\n### 抛出与抽象相适应的异常\n\n换句话说，一个方法所抛出的异常应该在一个抽象层次上定义，该抽象层次与该方法做什么相一致，而不一定与方法的底层实现细节相一致。例如，一个从文件、数据库或者 JNDI 装载资源的方法在不能找到资源时，应该抛出某种 ResourceNotFound 异常（通常使用异常链来保存隐含的原因），而不是更底层的 IOException 、 SQLException 或者 NamingException 。\n\n我们有时候在捕获一个异常后抛出另一个封装后的异常信息，并且希望将原始的异常信息也保持起来，\nthrow抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？\n在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。\n\n### 多线程中的异常\n\n在java多线程程序中，所有线程都不允许抛出未捕获的检测型异常（比如sleep时的InterruptedException),\n也就是说各个线程需要自己把自己的检测型处理掉。\n这一点是通过java.lang.Runnable.run()方法声明(因为此方法声明上没有throw exception部分)进行了约束。\n但是线程依然有可能抛出非检测型异常，当此类异常跑抛出时，线程就会终结，\n而对于主线程和其他线程完全不受影响，且完全感知不到某个线程抛出的异常(也是说完全无法catch到这个异常)。\n\n如果我们不考虑线程内可能出现的异常而导致线程的终结，那么就有可能造成意想不到的后果。如果是使用线程池的话，就有可能导致线程泄漏，这样的错误可能难以察觉，\n最终导致程序挂掉或者内存溢出等等意想不到的问题，但是往往不好追踪问题出现的原因。\n[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章很好的展示了一个多线程发生异常后产生的一系列后果。\n\n对于线程可以自己处理的异常，比较好解决。我们可以在线程内部捕获异常，作一些处理，防止线程退出。比如，[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章中的一个示例：\n\n```\nprivate class SaferPoolWorker extends Thread {\n    public void run() {\n        IncomingResponse ir;\n        while (true) {\n            ir = (IncomingResponse) queue.getNext();\n            PlugIn plugIn = findPlugIn(ir.getResponseId());\n            if (plugIn != null) {\n        try {\n                    plugIn.handleMessage(ir.getResponse());\n                }\n                catch (RuntimeException e) {\n                    // Take some sort of action; \n                    // - log the exception and move on\n                    // - log the exception and restart the worker thread\n                    // - log the exception and unload the offending plug-in\n                }\n            }\n            else\n                log(\"Unknown plug-in for response \" + ir.getResponseId());\n        }\n    }\n}\n```\n但是，当子线程发生异常时，我们需要父线程或者主线程可以感知子线程的异常，也就是得到子线程产生的异常，然后做一些处理。[Java线程池异常处理最佳实践](http://blog.onlycatch.com/post/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)这篇文章给出了很好的总结，\n摘抄其总结如下：\n```\n处理线程池中的异常有两种思路： \n1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池 \n2）由线程池统一处理\n对于execute方法提交的线程，有两种处理方式 \n1）自定义线程池并实现afterExecute方法 \n2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。\n对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。\n```\n\n## 其他\n\n还发现了一个比较有趣的异常处理情况，虽然可能很少碰到，但是碰到了可以参考作者的思路。\n\n[技巧：当不能抛出异常时](https://www.ibm.com/developerworks/cn/java/j-ce/)这篇文章介绍了一种不是很常见的情况：即不能处理，也不能抛出异常(包括非检测型异常)时怎么办？\n\n## 参考\n\n[Java 异常处理的误区和经验总结](http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/)\n\n[Java异常处理和设计](http://www.importnew.com/18994.html)\n\n[Java 理论与实践: 关于异常的争论](https://www.ibm.com/developerworks/cn/java/j-jtp05254/)\n\n","slug":"java异常的学习","published":1,"updated":"2016-12-14T15:06:08.071Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj4s000zdigcjh46qmzy","content":"<blockquote>\n<p>最近的写代码的过程中，遇到很多异常的处理，以前上大学的时候写代码，遇到异常直接给个try catch了事，只是停留在看懂异常能够找出异常抛出点的水平。真正写代码的时候，不了解java的异常机制给自己编程带来很多不便，基础知识很重要！学习之～～</p>\n</blockquote>\n<h2 id=\"异常分类\"><a href=\"#异常分类\" class=\"headerlink\" title=\"异常分类\"></a>异常分类</h2><img src=\"/2016/12/13/java异常的学习/java.png\" alt=\"java异常体系\" title=\"java异常体系\">\n<p>java异常中的异常大体上可分为两类：Error 与 Exception，他们都继承自Throwable</p>\n<h3 id=\"Error：\"><a href=\"#Error：\" class=\"headerlink\" title=\"Error：\"></a>Error：</h3><p>Error表示一些无法恢复的错误，会导致应用程序中断。比如我们喜闻乐见的OutOfMemoryError(内存溢出)， StackOverflowError(堆栈溢出)等，就是一种Error类型的异常。面对这种类型的异常在我们的应用程序中一般是无法挽救的，将直接导致程序错误退出。因此我们在代码中一般不必去特别关心这种类型的异常。</p>\n<p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html\" target=\"_blank\" rel=\"external\">Error类型的异常及其子类</a></p>\n<h3 id=\"Exception\"><a href=\"#Exception\" class=\"headerlink\" title=\"Exception:\"></a>Exception:</h3><p>Exception是一般常见的异常，我们的应用程序可以处理这些异常，比如NullPointerException、IndexOutOfBoundsException等等。发生这些异常时，可以选择通过捕获这些异常进行处理，使程序可以继续往下执行。</p>\n<p>Exception又可以分为CheckException(检测型异常)与UncheckException(非检测型异常)。</p>\n<p>在Exception的子类当中，非检测型异常为RuntimeException及其子类，剩下的异常则为检测型异常。</p>\n<h4 id=\"检测型异常\"><a href=\"#检测型异常\" class=\"headerlink\" title=\"检测型异常\"></a>检测型异常</h4><p>所谓检测型异常，表示其接受编译器的检测，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void readFile(String filePath)&#123;</div><div class=\"line\">        //编译无法通过</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\tFileReader fileReader = new FileReader(file);//FileNotFoundException</div><div class=\"line\">\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\tString line = null;</div><div class=\"line\">\t\twhile ((line = bReader.readLine()) != null) &#123;//IOException</div><div class=\"line\">\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>编译上述代码，编译器会报错，编译无法通过。<br>如果是用Eclipse等ide去写这段代码，ide通常就会告诉你这段代码有错误。原因是上述代码会抛出检测型异常IOException。有以下两种修复错误的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//第一种</div><div class=\"line\">public void readFile(String filePath) throws IOException&#123;</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\tFileReader fileReader = new FileReader(file);</div><div class=\"line\">\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\tString line = null;</div><div class=\"line\">\t\twhile ((line = bReader.readLine()) != null) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//第二种</div><div class=\"line\">public void readFile(String filePath) &#123;</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tFileReader fileReader = new FileReader(file);</div><div class=\"line\">\t\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\t\tString line = null;</div><div class=\"line\">\t\t\twhile ((line = bReader.readLine()) != null) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; catch (IOException e) &#123;</div><div class=\"line\">\t\t\t// TODO: handle exception</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一种方式通过声明throws关键字将该异常继续向上抛出，这种方式下，该方法就抛出了检测型异常，他的调用者就会遇到一样的问题，调用者可以选择使用这种方式继续向调用链上层抛出，或者采用第二种方式处理异常。</p>\n<p>第二种方式通过将抛出异常的代码使用try..catch块包裹起来，处理该异常。这种方式下他的调用者无需再次处理该异常。</p>\n<p>上面这种类型的异常就是检测型异常，我们必须显示的去处理他，代表的有SQLException、IOException等等。</p>\n<h4 id=\"非检测型异常\"><a href=\"#非检测型异常\" class=\"headerlink\" title=\"非检测型异常\"></a>非检测型异常</h4><p>与检测型异常相对的，编译阶段不会检测这种类型的异常，当代码中有这种类型的异常抛出时，我们不需要像上面那样显示的处理他，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void test() &#123;</div><div class=\"line\">        //编译可以通过</div><div class=\"line\">\t\tthrow new NullPointerException();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过throw关键字抛出了一个NullPointerException异常，该异常是RunTimeException的子类，是一个非检测类型的异常。这种类型的异常一般是由程序逻辑错误引起的，比如空指针或者数组越界等等。</p>\n<p>对于非检测类型的异常，我们也可以去使用try..catch捕获他，从而进行一些处理。如果我们没有捕获处理这个异常，系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，<strong>这个线程也就退出了</strong>。如果是主程序抛出的异常，<strong>那么这整个程序也就退出了</strong>。</p>\n<p>Error实际上也是一种非检测型异常。</p>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><p>了解了异常的分类，我们就可以愉快的处理异常了。记得上大学的时候写的代码，由于不理解java的异常机制，每当遇到检测型异常时，ide会要求在代码中处理这种情况。于是简单的try..catch解决，并在catch块中 e.printStackTrace()，就解决了IDE的报警问题。现在想来，这种代码如果运行在生产环境中，将会多么可怕。</p>\n<p>通过上面的总结，我们已经了解了四个关键字：try catch throw throws.</p>\n<p>throw表示将要抛出一个异常，后面跟一个Throwable的实例，throws置于函数的声明当中，表示该函数将会抛出何种类型的异常。</p>\n<p>try catch 一般配合使用，还有一个关键字finally,也是与try catch 配合使用的。有这三种使用方式：</p>\n<p>try..catch  try..finally try..catch..finally</p>\n<p>catch 可以有多个，try只能有一个，finally可选。</p>\n<p>finally用于保证一些资源的释放，因为一般情况下，finally中的语句总会在方法返回之前得到执行。</p>\n<h3 id=\"try-catch-finally执行顺序\"><a href=\"#try-catch-finally执行顺序\" class=\"headerlink\" title=\"try catch finally执行顺序\"></a>try catch finally执行顺序</h3><p>try catch finally的执行顺序为 try-&gt;catch-&gt;finally。</p>\n<p>有多个catch时，按照catch块的先后顺序进行匹配，一旦一个异常与一个catch块匹配，则不会再与后面的catch块进行匹配。<br>因此，如果我们使用多个catch块捕获异常时，如果多个catch块捕获的异常具有继承关系，注意把继承链中低层次(也就是子类)的放在前面，把继承链中高层次的(也就是父类)放在后面。<br>这样做的目的很简单，就是尽量使异常被适合的catch所捕获，这样处理起来比较明确。</p>\n<p>finally块中的代码一般是在try与catch内的控制转移语句执行之前执行的，用来做一些资源释放的操作。控制转移语句包括：return、throw、break 和 continue。</p>\n<p>关于finally块的详细解析，参考<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-finally/\" target=\"_blank\" rel=\"external\">关于 Java 中 finally 语句块的深度辨析</a></p>\n<p>另外有一点需要注意：不要在finally中return，因为finally中的return会覆盖已有的返回值，比如try或者catch中的返回值。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TestException &#123;</div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        String str = new TestException().readFile();</div><div class=\"line\">        System.out.println(str);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    public String readFile() &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            FileInputStream inputStream = new FileInputStream(&quot;D:/test.txt&quot;);</div><div class=\"line\">            int ch = inputStream.read();</div><div class=\"line\">            return &quot;try&quot;;</div><div class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</div><div class=\"line\">            System.out.println(&quot;file not found&quot;);</div><div class=\"line\">            return &quot;FileNotFoundException&quot;;</div><div class=\"line\">        &#125;catch (IOException e) &#123;</div><div class=\"line\">            System.out.println(&quot;io exception&quot;);</div><div class=\"line\">            return &quot;IOException&quot;;</div><div class=\"line\">        &#125;finally&#123;</div><div class=\"line\">            System.out.println(&quot;finally block&quot;);</div><div class=\"line\">            //return &quot;finally&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>D:/test.txt 并不存在，执行结果为:file not found    finally block   FileNotFoundException<br>去掉finally中的注释，执行结果为：file not found    finally block   finally</p>\n<h2 id=\"一些建议\"><a href=\"#一些建议\" class=\"headerlink\" title=\"一些建议\"></a>一些建议</h2><p>了解了异常机制的基本原理，不一定能够很好的处理异常。当我们遇到异常需要处理的时候，需要遵循几个原则，才能写出更好的代码：</p>\n<h3 id=\"不要使用空的catch块\"><a href=\"#不要使用空的catch块\" class=\"headerlink\" title=\"不要使用空的catch块\"></a>不要使用空的catch块</h3><p>正如前面所说，上学的时候遇到异常时，直接try..catch了事，只是简单地e.printStackTrace(),把堆栈打印出来了。这样可能对定位异常比较有帮助，但是对异常的处理却没有帮助，既没有处理异常，上层代码也无法得知异常的抛出，<br>程序会继续运行，有可能出现无法预料的结果。当然，如果程序的逻辑容忍异常可以不用处理，那么可以不处理异常，简单的输出到日志记录即可。处理还需视实际情况而定。</p>\n<h3 id=\"在能够处理异常的地方处理异常\"><a href=\"#在能够处理异常的地方处理异常\" class=\"headerlink\" title=\"在能够处理异常的地方处理异常\"></a>在能够处理异常的地方处理异常</h3><p>换句话说，就是在高层代码中处理异常。尽量将异常抛给上层调用者，由上层调用者统一进行处理。这样会使得程序流程比较清晰。</p>\n<h3 id=\"日志打印\"><a href=\"#日志打印\" class=\"headerlink\" title=\"日志打印\"></a>日志打印</h3><p>只在必要的地方打印日志，如只在异常发生的地方输出日志，然后将异常抛到上层。这样比较容易定位异常，避免每次向上抛出异常时都打印日志，反复打印同一个异常会使得日志变得混乱</p>\n<h3 id=\"检测异常与非检测异常的选择\"><a href=\"#检测异常与非检测异常的选择\" class=\"headerlink\" title=\"检测异常与非检测异常的选择\"></a>检测异常与非检测异常的选择</h3><p>为可恢复的条件使用检查型异常，为编程错误使用运行时异常</p>\n<p>在web项目中，我们经常把代码层次分为controller，service,dao等几层。在dao层中一搬会抛出SQLException,这就使得他的调用者必须显示的捕获该异常或者继续抛出。这样提高了代码的耦合性，污染了上层代码。<br>在比如接口的声明当中，我们为方法声明了一个检测型异常，那么他的所有实现类都必须作出同样的声明，即使实现类不会抛出异常。而且，所有的调用者都必须显示的捕获异常或者抛出异常，异常就会扩散开来，会使代码变得混乱。<br>所以我们应该正确的选择检测型异常和非检测型异常。个人认为，检测型异常的意义就在于提醒用户进行处理，比如一些资源的释放等等。如果该异常出现的很普遍，需要提醒调用者进行处理，那么就是用检测型异常，否则，就使用非检测型异常。</p>\n<p>对于已经抛出的检测型异常，我们可以进行封装处理，比如对于第一种情况，污染上层代码的问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//处理前</div><div class=\"line\">public Data getDataById(Long id) throw SQLException &#123;</div><div class=\"line\"> //根据 ID 查询数据库</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//处理后</div><div class=\"line\">public Data getDataById(Long id) &#123;</div><div class=\"line\">     try&#123;</div><div class=\"line\">            //根据 ID 查询数据库</div><div class=\"line\">     &#125;catch(SQLException e)&#123;</div><div class=\"line\">            //利用非检测异常封装检测异常，降低层次耦合</div><div class=\"line\">            throw new RuntimeException(SQLErrorCode, e);</div><div class=\"line\">     &#125;finally&#123;</div><div class=\"line\">            //关闭连接，清理资源</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们将一个检测型异常封装成了非检测型异常向上抛出。</p>\n<h3 id=\"不要使用Exception捕捉所有潜在的异常\"><a href=\"#不要使用Exception捕捉所有潜在的异常\" class=\"headerlink\" title=\"不要使用Exception捕捉所有潜在的异常\"></a>不要使用Exception捕捉所有潜在的异常</h3><p>针对具体的异常进行处理，而不是使用Exception捕获所有的异常。这样不利于异常情况的处理，并且如果再次向上抛出时可能会丢书原有的异常信息。 </p>\n<h3 id=\"抛出与抽象相适应的异常\"><a href=\"#抛出与抽象相适应的异常\" class=\"headerlink\" title=\"抛出与抽象相适应的异常\"></a>抛出与抽象相适应的异常</h3><p>换句话说，一个方法所抛出的异常应该在一个抽象层次上定义，该抽象层次与该方法做什么相一致，而不一定与方法的底层实现细节相一致。例如，一个从文件、数据库或者 JNDI 装载资源的方法在不能找到资源时，应该抛出某种 ResourceNotFound 异常（通常使用异常链来保存隐含的原因），而不是更底层的 IOException 、 SQLException 或者 NamingException 。</p>\n<p>我们有时候在捕获一个异常后抛出另一个封装后的异常信息，并且希望将原始的异常信息也保持起来，<br>throw抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？<br>在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。</p>\n<h3 id=\"多线程中的异常\"><a href=\"#多线程中的异常\" class=\"headerlink\" title=\"多线程中的异常\"></a>多线程中的异常</h3><p>在java多线程程序中，所有线程都不允许抛出未捕获的检测型异常（比如sleep时的InterruptedException),<br>也就是说各个线程需要自己把自己的检测型处理掉。<br>这一点是通过java.lang.Runnable.run()方法声明(因为此方法声明上没有throw exception部分)进行了约束。<br>但是线程依然有可能抛出非检测型异常，当此类异常跑抛出时，线程就会终结，<br>而对于主线程和其他线程完全不受影响，且完全感知不到某个线程抛出的异常(也是说完全无法catch到这个异常)。</p>\n<p>如果我们不考虑线程内可能出现的异常而导致线程的终结，那么就有可能造成意想不到的后果。如果是使用线程池的话，就有可能导致线程泄漏，这样的错误可能难以察觉，<br>最终导致程序挂掉或者内存溢出等等意想不到的问题，但是往往不好追踪问题出现的原因。<br><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\" target=\"_blank\" rel=\"external\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章很好的展示了一个多线程发生异常后产生的一系列后果。</p>\n<p>对于线程可以自己处理的异常，比较好解决。我们可以在线程内部捕获异常，作一些处理，防止线程退出。比如，<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\" target=\"_blank\" rel=\"external\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章中的一个示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">private class SaferPoolWorker extends Thread &#123;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        IncomingResponse ir;</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\">            ir = (IncomingResponse) queue.getNext();</div><div class=\"line\">            PlugIn plugIn = findPlugIn(ir.getResponseId());</div><div class=\"line\">            if (plugIn != null) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">                    plugIn.handleMessage(ir.getResponse());</div><div class=\"line\">                &#125;</div><div class=\"line\">                catch (RuntimeException e) &#123;</div><div class=\"line\">                    // Take some sort of action; </div><div class=\"line\">                    // - log the exception and move on</div><div class=\"line\">                    // - log the exception and restart the worker thread</div><div class=\"line\">                    // - log the exception and unload the offending plug-in</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            else</div><div class=\"line\">                log(&quot;Unknown plug-in for response &quot; + ir.getResponseId());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是，当子线程发生异常时，我们需要父线程或者主线程可以感知子线程的异常，也就是得到子线程产生的异常，然后做一些处理。<a href=\"http://blog.onlycatch.com/post/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\" target=\"_blank\" rel=\"external\">Java线程池异常处理最佳实践</a>这篇文章给出了很好的总结，<br>摘抄其总结如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">处理线程池中的异常有两种思路： </div><div class=\"line\">1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池 </div><div class=\"line\">2）由线程池统一处理</div><div class=\"line\">对于execute方法提交的线程，有两种处理方式 </div><div class=\"line\">1）自定义线程池并实现afterExecute方法 </div><div class=\"line\">2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。</div><div class=\"line\">对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。</div></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>还发现了一个比较有趣的异常处理情况，虽然可能很少碰到，但是碰到了可以参考作者的思路。</p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-ce/\" target=\"_blank\" rel=\"external\">技巧：当不能抛出异常时</a>这篇文章介绍了一种不是很常见的情况：即不能处理，也不能抛出异常(包括非检测型异常)时怎么办？</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/\" target=\"_blank\" rel=\"external\">Java 异常处理的误区和经验总结</a></p>\n<p><a href=\"http://www.importnew.com/18994.html\" target=\"_blank\" rel=\"external\">Java异常处理和设计</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp05254/\" target=\"_blank\" rel=\"external\">Java 理论与实践: 关于异常的争论</a></p>\n","excerpt":"","more":"<blockquote>\n<p>最近的写代码的过程中，遇到很多异常的处理，以前上大学的时候写代码，遇到异常直接给个try catch了事，只是停留在看懂异常能够找出异常抛出点的水平。真正写代码的时候，不了解java的异常机制给自己编程带来很多不便，基础知识很重要！学习之～～</p>\n</blockquote>\n<h2 id=\"异常分类\"><a href=\"#异常分类\" class=\"headerlink\" title=\"异常分类\"></a>异常分类</h2><img src=\"/2016/12/13/java异常的学习/java.png\" alt=\"java异常体系\" title=\"java异常体系\">\n<p>java异常中的异常大体上可分为两类：Error 与 Exception，他们都继承自Throwable</p>\n<h3 id=\"Error：\"><a href=\"#Error：\" class=\"headerlink\" title=\"Error：\"></a>Error：</h3><p>Error表示一些无法恢复的错误，会导致应用程序中断。比如我们喜闻乐见的OutOfMemoryError(内存溢出)， StackOverflowError(堆栈溢出)等，就是一种Error类型的异常。面对这种类型的异常在我们的应用程序中一般是无法挽救的，将直接导致程序错误退出。因此我们在代码中一般不必去特别关心这种类型的异常。</p>\n<p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html\">Error类型的异常及其子类</a></p>\n<h3 id=\"Exception\"><a href=\"#Exception\" class=\"headerlink\" title=\"Exception:\"></a>Exception:</h3><p>Exception是一般常见的异常，我们的应用程序可以处理这些异常，比如NullPointerException、IndexOutOfBoundsException等等。发生这些异常时，可以选择通过捕获这些异常进行处理，使程序可以继续往下执行。</p>\n<p>Exception又可以分为CheckException(检测型异常)与UncheckException(非检测型异常)。</p>\n<p>在Exception的子类当中，非检测型异常为RuntimeException及其子类，剩下的异常则为检测型异常。</p>\n<h4 id=\"检测型异常\"><a href=\"#检测型异常\" class=\"headerlink\" title=\"检测型异常\"></a>检测型异常</h4><p>所谓检测型异常，表示其接受编译器的检测，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void readFile(String filePath)&#123;</div><div class=\"line\">        //编译无法通过</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\tFileReader fileReader = new FileReader(file);//FileNotFoundException</div><div class=\"line\">\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\tString line = null;</div><div class=\"line\">\t\twhile ((line = bReader.readLine()) != null) &#123;//IOException</div><div class=\"line\">\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>编译上述代码，编译器会报错，编译无法通过。<br>如果是用Eclipse等ide去写这段代码，ide通常就会告诉你这段代码有错误。原因是上述代码会抛出检测型异常IOException。有以下两种修复错误的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//第一种</div><div class=\"line\">public void readFile(String filePath) throws IOException&#123;</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\tFileReader fileReader = new FileReader(file);</div><div class=\"line\">\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\tString line = null;</div><div class=\"line\">\t\twhile ((line = bReader.readLine()) != null) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//第二种</div><div class=\"line\">public void readFile(String filePath) &#123;</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tFileReader fileReader = new FileReader(file);</div><div class=\"line\">\t\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\t\tString line = null;</div><div class=\"line\">\t\t\twhile ((line = bReader.readLine()) != null) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; catch (IOException e) &#123;</div><div class=\"line\">\t\t\t// TODO: handle exception</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一种方式通过声明throws关键字将该异常继续向上抛出，这种方式下，该方法就抛出了检测型异常，他的调用者就会遇到一样的问题，调用者可以选择使用这种方式继续向调用链上层抛出，或者采用第二种方式处理异常。</p>\n<p>第二种方式通过将抛出异常的代码使用try..catch块包裹起来，处理该异常。这种方式下他的调用者无需再次处理该异常。</p>\n<p>上面这种类型的异常就是检测型异常，我们必须显示的去处理他，代表的有SQLException、IOException等等。</p>\n<h4 id=\"非检测型异常\"><a href=\"#非检测型异常\" class=\"headerlink\" title=\"非检测型异常\"></a>非检测型异常</h4><p>与检测型异常相对的，编译阶段不会检测这种类型的异常，当代码中有这种类型的异常抛出时，我们不需要像上面那样显示的处理他，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void test() &#123;</div><div class=\"line\">        //编译可以通过</div><div class=\"line\">\t\tthrow new NullPointerException();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过throw关键字抛出了一个NullPointerException异常，该异常是RunTimeException的子类，是一个非检测类型的异常。这种类型的异常一般是由程序逻辑错误引起的，比如空指针或者数组越界等等。</p>\n<p>对于非检测类型的异常，我们也可以去使用try..catch捕获他，从而进行一些处理。如果我们没有捕获处理这个异常，系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，<strong>这个线程也就退出了</strong>。如果是主程序抛出的异常，<strong>那么这整个程序也就退出了</strong>。</p>\n<p>Error实际上也是一种非检测型异常。</p>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><p>了解了异常的分类，我们就可以愉快的处理异常了。记得上大学的时候写的代码，由于不理解java的异常机制，每当遇到检测型异常时，ide会要求在代码中处理这种情况。于是简单的try..catch解决，并在catch块中 e.printStackTrace()，就解决了IDE的报警问题。现在想来，这种代码如果运行在生产环境中，将会多么可怕。</p>\n<p>通过上面的总结，我们已经了解了四个关键字：try catch throw throws.</p>\n<p>throw表示将要抛出一个异常，后面跟一个Throwable的实例，throws置于函数的声明当中，表示该函数将会抛出何种类型的异常。</p>\n<p>try catch 一般配合使用，还有一个关键字finally,也是与try catch 配合使用的。有这三种使用方式：</p>\n<p>try..catch  try..finally try..catch..finally</p>\n<p>catch 可以有多个，try只能有一个，finally可选。</p>\n<p>finally用于保证一些资源的释放，因为一般情况下，finally中的语句总会在方法返回之前得到执行。</p>\n<h3 id=\"try-catch-finally执行顺序\"><a href=\"#try-catch-finally执行顺序\" class=\"headerlink\" title=\"try catch finally执行顺序\"></a>try catch finally执行顺序</h3><p>try catch finally的执行顺序为 try-&gt;catch-&gt;finally。</p>\n<p>有多个catch时，按照catch块的先后顺序进行匹配，一旦一个异常与一个catch块匹配，则不会再与后面的catch块进行匹配。<br>因此，如果我们使用多个catch块捕获异常时，如果多个catch块捕获的异常具有继承关系，注意把继承链中低层次(也就是子类)的放在前面，把继承链中高层次的(也就是父类)放在后面。<br>这样做的目的很简单，就是尽量使异常被适合的catch所捕获，这样处理起来比较明确。</p>\n<p>finally块中的代码一般是在try与catch内的控制转移语句执行之前执行的，用来做一些资源释放的操作。控制转移语句包括：return、throw、break 和 continue。</p>\n<p>关于finally块的详细解析，参考<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-finally/\">关于 Java 中 finally 语句块的深度辨析</a></p>\n<p>另外有一点需要注意：不要在finally中return，因为finally中的return会覆盖已有的返回值，比如try或者catch中的返回值。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TestException &#123;</div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        String str = new TestException().readFile();</div><div class=\"line\">        System.out.println(str);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    public String readFile() &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            FileInputStream inputStream = new FileInputStream(&quot;D:/test.txt&quot;);</div><div class=\"line\">            int ch = inputStream.read();</div><div class=\"line\">            return &quot;try&quot;;</div><div class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</div><div class=\"line\">            System.out.println(&quot;file not found&quot;);</div><div class=\"line\">            return &quot;FileNotFoundException&quot;;</div><div class=\"line\">        &#125;catch (IOException e) &#123;</div><div class=\"line\">            System.out.println(&quot;io exception&quot;);</div><div class=\"line\">            return &quot;IOException&quot;;</div><div class=\"line\">        &#125;finally&#123;</div><div class=\"line\">            System.out.println(&quot;finally block&quot;);</div><div class=\"line\">            //return &quot;finally&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>D:/test.txt 并不存在，执行结果为:file not found    finally block   FileNotFoundException<br>去掉finally中的注释，执行结果为：file not found    finally block   finally</p>\n<h2 id=\"一些建议\"><a href=\"#一些建议\" class=\"headerlink\" title=\"一些建议\"></a>一些建议</h2><p>了解了异常机制的基本原理，不一定能够很好的处理异常。当我们遇到异常需要处理的时候，需要遵循几个原则，才能写出更好的代码：</p>\n<h3 id=\"不要使用空的catch块\"><a href=\"#不要使用空的catch块\" class=\"headerlink\" title=\"不要使用空的catch块\"></a>不要使用空的catch块</h3><p>正如前面所说，上学的时候遇到异常时，直接try..catch了事，只是简单地e.printStackTrace(),把堆栈打印出来了。这样可能对定位异常比较有帮助，但是对异常的处理却没有帮助，既没有处理异常，上层代码也无法得知异常的抛出，<br>程序会继续运行，有可能出现无法预料的结果。当然，如果程序的逻辑容忍异常可以不用处理，那么可以不处理异常，简单的输出到日志记录即可。处理还需视实际情况而定。</p>\n<h3 id=\"在能够处理异常的地方处理异常\"><a href=\"#在能够处理异常的地方处理异常\" class=\"headerlink\" title=\"在能够处理异常的地方处理异常\"></a>在能够处理异常的地方处理异常</h3><p>换句话说，就是在高层代码中处理异常。尽量将异常抛给上层调用者，由上层调用者统一进行处理。这样会使得程序流程比较清晰。</p>\n<h3 id=\"日志打印\"><a href=\"#日志打印\" class=\"headerlink\" title=\"日志打印\"></a>日志打印</h3><p>只在必要的地方打印日志，如只在异常发生的地方输出日志，然后将异常抛到上层。这样比较容易定位异常，避免每次向上抛出异常时都打印日志，反复打印同一个异常会使得日志变得混乱</p>\n<h3 id=\"检测异常与非检测异常的选择\"><a href=\"#检测异常与非检测异常的选择\" class=\"headerlink\" title=\"检测异常与非检测异常的选择\"></a>检测异常与非检测异常的选择</h3><p>为可恢复的条件使用检查型异常，为编程错误使用运行时异常</p>\n<p>在web项目中，我们经常把代码层次分为controller，service,dao等几层。在dao层中一搬会抛出SQLException,这就使得他的调用者必须显示的捕获该异常或者继续抛出。这样提高了代码的耦合性，污染了上层代码。<br>在比如接口的声明当中，我们为方法声明了一个检测型异常，那么他的所有实现类都必须作出同样的声明，即使实现类不会抛出异常。而且，所有的调用者都必须显示的捕获异常或者抛出异常，异常就会扩散开来，会使代码变得混乱。<br>所以我们应该正确的选择检测型异常和非检测型异常。个人认为，检测型异常的意义就在于提醒用户进行处理，比如一些资源的释放等等。如果该异常出现的很普遍，需要提醒调用者进行处理，那么就是用检测型异常，否则，就使用非检测型异常。</p>\n<p>对于已经抛出的检测型异常，我们可以进行封装处理，比如对于第一种情况，污染上层代码的问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//处理前</div><div class=\"line\">public Data getDataById(Long id) throw SQLException &#123;</div><div class=\"line\"> //根据 ID 查询数据库</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//处理后</div><div class=\"line\">public Data getDataById(Long id) &#123;</div><div class=\"line\">     try&#123;</div><div class=\"line\">            //根据 ID 查询数据库</div><div class=\"line\">     &#125;catch(SQLException e)&#123;</div><div class=\"line\">            //利用非检测异常封装检测异常，降低层次耦合</div><div class=\"line\">            throw new RuntimeException(SQLErrorCode, e);</div><div class=\"line\">     &#125;finally&#123;</div><div class=\"line\">            //关闭连接，清理资源</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们将一个检测型异常封装成了非检测型异常向上抛出。</p>\n<h3 id=\"不要使用Exception捕捉所有潜在的异常\"><a href=\"#不要使用Exception捕捉所有潜在的异常\" class=\"headerlink\" title=\"不要使用Exception捕捉所有潜在的异常\"></a>不要使用Exception捕捉所有潜在的异常</h3><p>针对具体的异常进行处理，而不是使用Exception捕获所有的异常。这样不利于异常情况的处理，并且如果再次向上抛出时可能会丢书原有的异常信息。 </p>\n<h3 id=\"抛出与抽象相适应的异常\"><a href=\"#抛出与抽象相适应的异常\" class=\"headerlink\" title=\"抛出与抽象相适应的异常\"></a>抛出与抽象相适应的异常</h3><p>换句话说，一个方法所抛出的异常应该在一个抽象层次上定义，该抽象层次与该方法做什么相一致，而不一定与方法的底层实现细节相一致。例如，一个从文件、数据库或者 JNDI 装载资源的方法在不能找到资源时，应该抛出某种 ResourceNotFound 异常（通常使用异常链来保存隐含的原因），而不是更底层的 IOException 、 SQLException 或者 NamingException 。</p>\n<p>我们有时候在捕获一个异常后抛出另一个封装后的异常信息，并且希望将原始的异常信息也保持起来，<br>throw抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？<br>在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。</p>\n<h3 id=\"多线程中的异常\"><a href=\"#多线程中的异常\" class=\"headerlink\" title=\"多线程中的异常\"></a>多线程中的异常</h3><p>在java多线程程序中，所有线程都不允许抛出未捕获的检测型异常（比如sleep时的InterruptedException),<br>也就是说各个线程需要自己把自己的检测型处理掉。<br>这一点是通过java.lang.Runnable.run()方法声明(因为此方法声明上没有throw exception部分)进行了约束。<br>但是线程依然有可能抛出非检测型异常，当此类异常跑抛出时，线程就会终结，<br>而对于主线程和其他线程完全不受影响，且完全感知不到某个线程抛出的异常(也是说完全无法catch到这个异常)。</p>\n<p>如果我们不考虑线程内可能出现的异常而导致线程的终结，那么就有可能造成意想不到的后果。如果是使用线程池的话，就有可能导致线程泄漏，这样的错误可能难以察觉，<br>最终导致程序挂掉或者内存溢出等等意想不到的问题，但是往往不好追踪问题出现的原因。<br><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章很好的展示了一个多线程发生异常后产生的一系列后果。</p>\n<p>对于线程可以自己处理的异常，比较好解决。我们可以在线程内部捕获异常，作一些处理，防止线程退出。比如，<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章中的一个示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">private class SaferPoolWorker extends Thread &#123;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        IncomingResponse ir;</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\">            ir = (IncomingResponse) queue.getNext();</div><div class=\"line\">            PlugIn plugIn = findPlugIn(ir.getResponseId());</div><div class=\"line\">            if (plugIn != null) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">                    plugIn.handleMessage(ir.getResponse());</div><div class=\"line\">                &#125;</div><div class=\"line\">                catch (RuntimeException e) &#123;</div><div class=\"line\">                    // Take some sort of action; </div><div class=\"line\">                    // - log the exception and move on</div><div class=\"line\">                    // - log the exception and restart the worker thread</div><div class=\"line\">                    // - log the exception and unload the offending plug-in</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            else</div><div class=\"line\">                log(&quot;Unknown plug-in for response &quot; + ir.getResponseId());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是，当子线程发生异常时，我们需要父线程或者主线程可以感知子线程的异常，也就是得到子线程产生的异常，然后做一些处理。<a href=\"http://blog.onlycatch.com/post/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">Java线程池异常处理最佳实践</a>这篇文章给出了很好的总结，<br>摘抄其总结如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">处理线程池中的异常有两种思路： </div><div class=\"line\">1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池 </div><div class=\"line\">2）由线程池统一处理</div><div class=\"line\">对于execute方法提交的线程，有两种处理方式 </div><div class=\"line\">1）自定义线程池并实现afterExecute方法 </div><div class=\"line\">2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。</div><div class=\"line\">对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。</div></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>还发现了一个比较有趣的异常处理情况，虽然可能很少碰到，但是碰到了可以参考作者的思路。</p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-ce/\">技巧：当不能抛出异常时</a>这篇文章介绍了一种不是很常见的情况：即不能处理，也不能抛出异常(包括非检测型异常)时怎么办？</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/\">Java 异常处理的误区和经验总结</a></p>\n<p><a href=\"http://www.importnew.com/18994.html\">Java异常处理和设计</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp05254/\">Java 理论与实践: 关于异常的争论</a></p>\n"},{"layout":"post","title":"java泛型学习","date":"2016-10-10T12:05:03.000Z","_content":"\n有一段时间没有更新博客了，过了国庆之后，好像变得更懒了~~前两天开发了一个用于记账的公众号，功能很简单，就是普通的增删查改...由于是个人开发者，无法进行公众号的认证，所以没什么高级的接口权限，只能搞的简陋一点了...下一步计划再丰富丰富，目前想到了这几个功能：配合有道或者金山词霸的Api进行中英互译（API怎么用，可不可以用目前还不清楚），配合微博的Api接口整点微博热门什么的，配合豆瓣的Api接口做一个电影或者书籍查询的功能等等....公众号的服务器代码目前还部署在自己的电脑上，用nat123做了一下公网ip的映射，接下来考虑是不是要换成云服务器更为妥当....\n\n公众号在这里：\n\n{% asset_img easybill.jpg EasyBill %}\n\n目前，公众号已经开源：[WechatSubscriptionNumber](https://github.com/Hikyu/WechatSubscriptionNumber)\n\n好了，言归正传。今天学习了java的泛型知识，不总结一下老是觉得跟没学一样...\n\n## 泛型的好处\n\n使用泛型的好处我觉得有两点：1：类型安全  2：减少类型强转\n\n下面通过一个例子说明:\n\n假设有一个Test类，通用的实现是:\n\n```java\nclass Test {\n\tprivate Object o;\n\n\tpublic Test(Object o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic Object getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(Object o) {\n\t\tthis.o = o;\n\t}\n}\n```\n我们可以这样使用它：\n\n```java\npublic static void main(String[] args) {\n\tTest test = new Test(new Integer(1));\n\t//编译时不报错\n\t//运行时报  java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\n\tString o = (String) test.getObject();\n}\n```\n\n看一个使用泛型的例子：\n\n```java\nclass Test<T> {\n\tprivate T o;\n\n\tpublic Test(T o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic T getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(T o) {\n\t\tthis.o = o;\n\t}\n}\n\npublic static void main(String[] args) {\n\tTest1<Integer> test = new Test1<Integer>(new Integer(1));\n\t//编译时报错，无法通过编译\n\t//String o = test.getObject();\n\n\t//正常运行\n\tInteger o = test.getObject();\n}\n```\n从上面的对比中能够看出两点：\n\n1.使用泛型之后在编译时报错而非运行时，减少了出错的几率；\n\n2.使用泛型之后编译器不再要求强转\n\n## 定义泛型\n\n泛型的机制能够在定义类、接口、方法时把类型参数化，也就是类似于方法的形参一样，把类型当做参数使用。\n\n泛型参数部分使用`<>`包裹起来，比如`<T>`，T声明了一种类型，习惯上，这个类型参数使用单个大写字母来表示，指示所定义的参数类型。有如下惯例：\n\nE：表示元素\n\nT：表示类型\n\nK：表示键\n\nV：表示值\n\nN：表示数字\n\n### 定义泛型类\n\n上面的例子就是一个很好的演示\n\n```java\nclass Test<T> {\n\tprivate T o;\n\n\tpublic Test(T o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic T getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(T o) {\n\t\tthis.o = o;\n\t}\n}\n```\n\n使用泛型定义类之后，泛型参数 T 可以运用到该类中：可以声明成员变量类型、可以声明成员函数返回值类型、可以声明成员函数参数类型。\n\n要注意：泛型参数T不能用于声明静态变量，同时也不能用于new一个对象比如：T o = new T();\n\n下面的类型擦除会说到原因。\n\n### 定义泛型接口\n\n```java\ninterface Test<T> {\n\tpublic T test(T t);\n}\n```\n使用泛型定义接口之后，泛型参数 T 可以运用到该接口中：可以声明接口函数返回值类型、可以声明接口函数参数类型。\n\n\n### 定义泛型方法\n\n可以单独给方法使用泛型，而不是泛化整个类：\n\n```java\npublic static <T> T getT(T t){\n\treturn t;\n}\n```\n使用泛型定义方法后，泛型参数 T 可以声明该方法的返回值类型、可以声明该方法的参数类型。\n\n要注意，定义方法所用的泛型参数需要在修饰符之后添加。\n\n### 定义多个泛型参数\n\n以接口为例：\n\n```java\ninterface Test<T, S> {\n\tpublic T testT(T t);\n\tpublic S testS(S s);\n}\n\npublic static void main(String[] args) {\n    //编译时报错\n\t//getT(\"s\");\n}\n```\n多个泛型参数在尖括号中使用逗号隔开。类的泛化与方法的泛化类似。\n\n### 泛型参数的界限\n\n定义泛型参数界限有这样两种意义：\n\n1.有时候我们希望限定这个泛型参数的类型为某个类的子类或者超类；\n\n2.上面的例子中可以看到，我们定义了泛型参数，向方法中传入某种类型，这种类型是未知的，因此我们无法使用这种类型定义的变量，不能够调用它的方法。\n\n```java\npublic static <T extends Number> Integer getT(T t) {\n\treturn  new Integer(t.intValue());\n}\n```\n上面例子中，`<T extends A>`表示T是A或A的子类，他限定了传入泛型方法参数的类型必须为A或A的子类，同时，在方法体中我们也可以使用t这个实参就像使用A的实例一样，调用Number具有的public方法。\n\n除了`<T extends A>`限定T是A或A的子类外，还可以使用`<T super A> `这种方式来限定T是A或A的超类。\n\nA可以是某个类或者接口。\n\n除此以外，还可以为泛型参数限定多个限制范围，如`<T extends A & B & C>`，限定范围中最多只能有一个类(某个类只能有一个父类~~)，并且他必须是限定列表中的第一个。\n\n```java\nClass A { // }\ninterface B { // }\ninterface C { // }\n\n//正确\nclass D <T extends A & B & C> { // }\n//编译时报错\nclass D <T extends A & B & C> { // }\n```\n\n### 泛型的继承\n\n看一下jdk中List的泛型继承例子：\n\n```java\npublic interface List<E> extends Collection<E>{//...}\n```\n`List<String>` 就是 `Collection<String>` 的子类。\n\n假如定义自己的接口：\n\n```java\ninterface MyList<E,P> extends List<E> {\n  void setPay(E e,P p);\n  //...\n}\n```\n\n`MyList<String,String>`、`MyList<String,Integer>`、`MyList<String,Exception>`都是`List<String>`的子类。\n\n## 使用泛型\n\n上面的例子中已经列举了一些使用泛化类或者泛化函数的例子，但是还有一些问题需要指出：\n\n1.泛型参数只接受引用类型，不适用于基本类型\n\n比如：\n\n```java\nclass Test<T> {}\n\npublic static void main(String[] args) {\n    //无法通过编译，不接受int类型的泛化参数\n\t//Test<int> test = new Test();\n}\n```\n\n而我们使用泛化函数时：\n\n```java\npublic static void main(String[] args) {\n\tgetT(1);\n}\npublic static <T> void getT(T t) {\n}\n```\n是没有问题的，通过查看生成的字节码，发现getT(1)这个方法的字节码中1被自动装箱为Integer类型。\n\n2.通配符的使用\n\n考虑下面的情况：\n\n```java\nclass Test<T> {}\npublic static void getT(Test<Number> t) {\n}\n\npublic static void main(String[] args) {\n\tTest<Double> test = new Test();\n\t//编译时报错\n\t//getT(test);\n}\n```\n报错的原因很好理解，虽然Double是Number的子类，但Test<Double>并不是Test<Number>的子类，故类型检查无法通过。这一点一定要明白。\n\n那么如果我们确实想要传入一个Test<Double>类型的形参呢？可以使用通配符：\n\n```java\nclass Test<T> {}\npublic static void main(String[] args) {\n\t\tTest<Double> test = new Test();\n\t\t//正常运行\n\t\tgetT(test);\n}\npublic static void getT(Test<? extends Number> t) {\n}\n```\n`Test<? extends Number>`扩展了形参的类型，可以是`Test<Double>`、`Test<Integer>`等，尖括号中的类型必须是Number或继承于Number。同样的，通配符也适用于super，如`Test<? super A>`。\n\n如果类型参数中既没有extends 关键字，也没有super关键字，只有一个?，代表无限定通配符。\n\n`Test<?>`与`Test<Object>`并不相同，无论T是什么类型，`Test<T>` 是 `Test<?>`的子类，但是，`Test<T>` 不是 `Test<Object>` 的子类，想想上面的例子。\n\n通常在两种情况下会使用无限定通配符：\n\n1. 如果正在编写一个方法，可以使用Object类中提供的功能来实现\n\n2. 代码实现的功能与类型参数无关，比如List.clear()与List.size()方法，还有经常使用的`Class<?>`方法，其实现的功能都与类型参数无关。\n\n一般情况下，通配符`<? extends Number>`只是出现在使用泛型的时候，而不是定义泛型的时候，就像上面的例子那样。而`<T extends Number>`这种形式出现在定义泛型的时候，而不是使用泛型的时候，不要搞混了。\n\n结合泛型的继承和通配符的使用，理解一下泛型的类型系统，也就是泛型类的继承关系：\n\n以下内容来自：[Java深度历险（五）——Java泛型](http://www.infoq.com/cn/articles/cf-java-generics)\n\n***\n引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 `List<String>`和`List<Object>`这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：\n\n相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即`List<String>`是`Collection<String>` 的子类型，`List<String>`可以替换`Collection<String>`。这种情况也适用于带有上下界的类型声明。\n当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对`Collection<? extends Number>`来说，其子类型可以在Collection这个维度上展开，即`List<? extends Number>`和`Set<? extends Number>`等；也可以在Number这个层次上展开，即`Collection<Double>`和 `Collection<Integer>`等。如此循环下去，`ArrayList<Long>`和 `HashSet<Double>`等也都算是`Collection<? extends Number>`的子类型。\n如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。\n***\n\n关于通配符的理解可以参考[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)\n\n\n## 类型擦除\n\n类型擦除发生在编译阶段，对于运行期的JVM来说，`List<int>`与`List<String>`就是同一个类，因为在编译结束之后，生成的字节码文件中，他们都是List类型。\n\n1.java编译器会在编译前进行类型检查\n\njava编译器承担了所有泛型的类型安全检查工作。\n\n2.类型擦除后保留的原始类型\n\n原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。\n\n3.自动类型转换\n\n因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？\n\n比如：\n\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        ArrayList<Date> list=new ArrayList<Date>();  \n        list.add(new Date());  \n        Date myDate=list.get(0);  \n    }\n}  \n```\n`Date myDate=list.get(0);`这里我们并没有对其返回值进行强转就可以直接获取Date类型的返回值。原因在于在字节码当中，有checkcast这么一个操作帮助我们进行了强转，这是java自动进行的。\n\n更多的关于类型擦除的知识，参考[ java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题](http://blog.csdn.net/lonelyroamer/article/details/7868820)\n\n\n## 实践\n\n最近在重构公众号服务器的过程中，用到了泛型编程的知识。\n\n```java\npublic interface BaseServiceContext<T extends ReqBaseMessage, R> {\n\tpublic void selectService(T reqMeg);\n\n\tpublic R executeRequest();\n}\n```\n上面是一个选择service的上下文接口，接收到用户请求后通过这个接口选择对应的service并且执行service。这个接口相当于一个工厂和策略模式的结合体。下面是这个接口的一种实现：\n\n```java\n//请求为文本类型，返回string类型的处理结果\npublic class TextServiceContext implements BaseServiceContext<ReqTextMessage,String> {\n\n\t@Override\n\tpublic void selectService(ReqTextMessage reqMeg) {\n\t\t//.....\n\t}\n\n\t@Override\n\tpublic String executeRequest() {\n\t\t//.....\n\t}\n}\n```\n可以看到，BaseServiceContext<ReqTextMessage,String>限定了selectService方法的参数类型和executeRequest方法的返回值类型，使其能够灵活的支持各种类型的参数和返回值。\n\n看一下在没有学习泛型之前，这个接口是怎么实现的：\n\n```java\npublic interface BaseServiceContext {\n\tpublic void selectService(ReqBaseMessage reqMeg);\n\n\tpublic Object executeRequest();\n}\n\npublic class TextServiceContext implements BaseServiceContext {\n\n\t@Override\n\tpublic void selectService(ReqBaseMessage reqMeg) {\n\t\t//根据业务逻辑对reqMeg进行强转，需要程序员自己判断\n\t\t//很有可能强转失败\n\t}\n\n\t@Override\n\tpublic Object executeRequest() {\n\t\t//返回类型为object，在调用方法的外部强转为需要的类型\n\t\t//很有可能强转失败\n\t}\n}\n```\n可以看到没有使用泛型接口的情况下，类型不安全且增大了强转失败的风险。同时也需要程序员根据业务逻辑去判断该强转成什么类型。使用泛型接口之后就没有了这些问题，只需要在使用接口时声明好他的泛型参数就o了。\n\n上面只是我在开发过程中体会到泛型的一个好处，类似的例子还有很多。\n\n## 注意事项\n\n\n\n## 参考\n\n[java 泛型编程（一）](http://peiquan.blog.51cto.com/7518552/1302898)\n\n[泛型：工作原理及其重要性](http://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html)\n\n[Java深度历险（五）——Java泛型](http://www.infoq.com/cn/articles/cf-java-generics)\n\n[java泛型详解](http://blog.csdn.net/u012152619/article/details/47253811)\n\n[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)\n\n","source":"_posts/java泛型学习.md","raw":"---\nlayout: post\ntitle: java泛型学习\ndate: 2016-10-10 20:05:03\ncategories: 编程 \ntags:\n- java\n---\n\n有一段时间没有更新博客了，过了国庆之后，好像变得更懒了~~前两天开发了一个用于记账的公众号，功能很简单，就是普通的增删查改...由于是个人开发者，无法进行公众号的认证，所以没什么高级的接口权限，只能搞的简陋一点了...下一步计划再丰富丰富，目前想到了这几个功能：配合有道或者金山词霸的Api进行中英互译（API怎么用，可不可以用目前还不清楚），配合微博的Api接口整点微博热门什么的，配合豆瓣的Api接口做一个电影或者书籍查询的功能等等....公众号的服务器代码目前还部署在自己的电脑上，用nat123做了一下公网ip的映射，接下来考虑是不是要换成云服务器更为妥当....\n\n公众号在这里：\n\n{% asset_img easybill.jpg EasyBill %}\n\n目前，公众号已经开源：[WechatSubscriptionNumber](https://github.com/Hikyu/WechatSubscriptionNumber)\n\n好了，言归正传。今天学习了java的泛型知识，不总结一下老是觉得跟没学一样...\n\n## 泛型的好处\n\n使用泛型的好处我觉得有两点：1：类型安全  2：减少类型强转\n\n下面通过一个例子说明:\n\n假设有一个Test类，通用的实现是:\n\n```java\nclass Test {\n\tprivate Object o;\n\n\tpublic Test(Object o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic Object getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(Object o) {\n\t\tthis.o = o;\n\t}\n}\n```\n我们可以这样使用它：\n\n```java\npublic static void main(String[] args) {\n\tTest test = new Test(new Integer(1));\n\t//编译时不报错\n\t//运行时报  java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\n\tString o = (String) test.getObject();\n}\n```\n\n看一个使用泛型的例子：\n\n```java\nclass Test<T> {\n\tprivate T o;\n\n\tpublic Test(T o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic T getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(T o) {\n\t\tthis.o = o;\n\t}\n}\n\npublic static void main(String[] args) {\n\tTest1<Integer> test = new Test1<Integer>(new Integer(1));\n\t//编译时报错，无法通过编译\n\t//String o = test.getObject();\n\n\t//正常运行\n\tInteger o = test.getObject();\n}\n```\n从上面的对比中能够看出两点：\n\n1.使用泛型之后在编译时报错而非运行时，减少了出错的几率；\n\n2.使用泛型之后编译器不再要求强转\n\n## 定义泛型\n\n泛型的机制能够在定义类、接口、方法时把类型参数化，也就是类似于方法的形参一样，把类型当做参数使用。\n\n泛型参数部分使用`<>`包裹起来，比如`<T>`，T声明了一种类型，习惯上，这个类型参数使用单个大写字母来表示，指示所定义的参数类型。有如下惯例：\n\nE：表示元素\n\nT：表示类型\n\nK：表示键\n\nV：表示值\n\nN：表示数字\n\n### 定义泛型类\n\n上面的例子就是一个很好的演示\n\n```java\nclass Test<T> {\n\tprivate T o;\n\n\tpublic Test(T o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic T getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(T o) {\n\t\tthis.o = o;\n\t}\n}\n```\n\n使用泛型定义类之后，泛型参数 T 可以运用到该类中：可以声明成员变量类型、可以声明成员函数返回值类型、可以声明成员函数参数类型。\n\n要注意：泛型参数T不能用于声明静态变量，同时也不能用于new一个对象比如：T o = new T();\n\n下面的类型擦除会说到原因。\n\n### 定义泛型接口\n\n```java\ninterface Test<T> {\n\tpublic T test(T t);\n}\n```\n使用泛型定义接口之后，泛型参数 T 可以运用到该接口中：可以声明接口函数返回值类型、可以声明接口函数参数类型。\n\n\n### 定义泛型方法\n\n可以单独给方法使用泛型，而不是泛化整个类：\n\n```java\npublic static <T> T getT(T t){\n\treturn t;\n}\n```\n使用泛型定义方法后，泛型参数 T 可以声明该方法的返回值类型、可以声明该方法的参数类型。\n\n要注意，定义方法所用的泛型参数需要在修饰符之后添加。\n\n### 定义多个泛型参数\n\n以接口为例：\n\n```java\ninterface Test<T, S> {\n\tpublic T testT(T t);\n\tpublic S testS(S s);\n}\n\npublic static void main(String[] args) {\n    //编译时报错\n\t//getT(\"s\");\n}\n```\n多个泛型参数在尖括号中使用逗号隔开。类的泛化与方法的泛化类似。\n\n### 泛型参数的界限\n\n定义泛型参数界限有这样两种意义：\n\n1.有时候我们希望限定这个泛型参数的类型为某个类的子类或者超类；\n\n2.上面的例子中可以看到，我们定义了泛型参数，向方法中传入某种类型，这种类型是未知的，因此我们无法使用这种类型定义的变量，不能够调用它的方法。\n\n```java\npublic static <T extends Number> Integer getT(T t) {\n\treturn  new Integer(t.intValue());\n}\n```\n上面例子中，`<T extends A>`表示T是A或A的子类，他限定了传入泛型方法参数的类型必须为A或A的子类，同时，在方法体中我们也可以使用t这个实参就像使用A的实例一样，调用Number具有的public方法。\n\n除了`<T extends A>`限定T是A或A的子类外，还可以使用`<T super A> `这种方式来限定T是A或A的超类。\n\nA可以是某个类或者接口。\n\n除此以外，还可以为泛型参数限定多个限制范围，如`<T extends A & B & C>`，限定范围中最多只能有一个类(某个类只能有一个父类~~)，并且他必须是限定列表中的第一个。\n\n```java\nClass A { // }\ninterface B { // }\ninterface C { // }\n\n//正确\nclass D <T extends A & B & C> { // }\n//编译时报错\nclass D <T extends A & B & C> { // }\n```\n\n### 泛型的继承\n\n看一下jdk中List的泛型继承例子：\n\n```java\npublic interface List<E> extends Collection<E>{//...}\n```\n`List<String>` 就是 `Collection<String>` 的子类。\n\n假如定义自己的接口：\n\n```java\ninterface MyList<E,P> extends List<E> {\n  void setPay(E e,P p);\n  //...\n}\n```\n\n`MyList<String,String>`、`MyList<String,Integer>`、`MyList<String,Exception>`都是`List<String>`的子类。\n\n## 使用泛型\n\n上面的例子中已经列举了一些使用泛化类或者泛化函数的例子，但是还有一些问题需要指出：\n\n1.泛型参数只接受引用类型，不适用于基本类型\n\n比如：\n\n```java\nclass Test<T> {}\n\npublic static void main(String[] args) {\n    //无法通过编译，不接受int类型的泛化参数\n\t//Test<int> test = new Test();\n}\n```\n\n而我们使用泛化函数时：\n\n```java\npublic static void main(String[] args) {\n\tgetT(1);\n}\npublic static <T> void getT(T t) {\n}\n```\n是没有问题的，通过查看生成的字节码，发现getT(1)这个方法的字节码中1被自动装箱为Integer类型。\n\n2.通配符的使用\n\n考虑下面的情况：\n\n```java\nclass Test<T> {}\npublic static void getT(Test<Number> t) {\n}\n\npublic static void main(String[] args) {\n\tTest<Double> test = new Test();\n\t//编译时报错\n\t//getT(test);\n}\n```\n报错的原因很好理解，虽然Double是Number的子类，但Test<Double>并不是Test<Number>的子类，故类型检查无法通过。这一点一定要明白。\n\n那么如果我们确实想要传入一个Test<Double>类型的形参呢？可以使用通配符：\n\n```java\nclass Test<T> {}\npublic static void main(String[] args) {\n\t\tTest<Double> test = new Test();\n\t\t//正常运行\n\t\tgetT(test);\n}\npublic static void getT(Test<? extends Number> t) {\n}\n```\n`Test<? extends Number>`扩展了形参的类型，可以是`Test<Double>`、`Test<Integer>`等，尖括号中的类型必须是Number或继承于Number。同样的，通配符也适用于super，如`Test<? super A>`。\n\n如果类型参数中既没有extends 关键字，也没有super关键字，只有一个?，代表无限定通配符。\n\n`Test<?>`与`Test<Object>`并不相同，无论T是什么类型，`Test<T>` 是 `Test<?>`的子类，但是，`Test<T>` 不是 `Test<Object>` 的子类，想想上面的例子。\n\n通常在两种情况下会使用无限定通配符：\n\n1. 如果正在编写一个方法，可以使用Object类中提供的功能来实现\n\n2. 代码实现的功能与类型参数无关，比如List.clear()与List.size()方法，还有经常使用的`Class<?>`方法，其实现的功能都与类型参数无关。\n\n一般情况下，通配符`<? extends Number>`只是出现在使用泛型的时候，而不是定义泛型的时候，就像上面的例子那样。而`<T extends Number>`这种形式出现在定义泛型的时候，而不是使用泛型的时候，不要搞混了。\n\n结合泛型的继承和通配符的使用，理解一下泛型的类型系统，也就是泛型类的继承关系：\n\n以下内容来自：[Java深度历险（五）——Java泛型](http://www.infoq.com/cn/articles/cf-java-generics)\n\n***\n引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 `List<String>`和`List<Object>`这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：\n\n相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即`List<String>`是`Collection<String>` 的子类型，`List<String>`可以替换`Collection<String>`。这种情况也适用于带有上下界的类型声明。\n当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对`Collection<? extends Number>`来说，其子类型可以在Collection这个维度上展开，即`List<? extends Number>`和`Set<? extends Number>`等；也可以在Number这个层次上展开，即`Collection<Double>`和 `Collection<Integer>`等。如此循环下去，`ArrayList<Long>`和 `HashSet<Double>`等也都算是`Collection<? extends Number>`的子类型。\n如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。\n***\n\n关于通配符的理解可以参考[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)\n\n\n## 类型擦除\n\n类型擦除发生在编译阶段，对于运行期的JVM来说，`List<int>`与`List<String>`就是同一个类，因为在编译结束之后，生成的字节码文件中，他们都是List类型。\n\n1.java编译器会在编译前进行类型检查\n\njava编译器承担了所有泛型的类型安全检查工作。\n\n2.类型擦除后保留的原始类型\n\n原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。\n\n3.自动类型转换\n\n因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？\n\n比如：\n\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        ArrayList<Date> list=new ArrayList<Date>();  \n        list.add(new Date());  \n        Date myDate=list.get(0);  \n    }\n}  \n```\n`Date myDate=list.get(0);`这里我们并没有对其返回值进行强转就可以直接获取Date类型的返回值。原因在于在字节码当中，有checkcast这么一个操作帮助我们进行了强转，这是java自动进行的。\n\n更多的关于类型擦除的知识，参考[ java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题](http://blog.csdn.net/lonelyroamer/article/details/7868820)\n\n\n## 实践\n\n最近在重构公众号服务器的过程中，用到了泛型编程的知识。\n\n```java\npublic interface BaseServiceContext<T extends ReqBaseMessage, R> {\n\tpublic void selectService(T reqMeg);\n\n\tpublic R executeRequest();\n}\n```\n上面是一个选择service的上下文接口，接收到用户请求后通过这个接口选择对应的service并且执行service。这个接口相当于一个工厂和策略模式的结合体。下面是这个接口的一种实现：\n\n```java\n//请求为文本类型，返回string类型的处理结果\npublic class TextServiceContext implements BaseServiceContext<ReqTextMessage,String> {\n\n\t@Override\n\tpublic void selectService(ReqTextMessage reqMeg) {\n\t\t//.....\n\t}\n\n\t@Override\n\tpublic String executeRequest() {\n\t\t//.....\n\t}\n}\n```\n可以看到，BaseServiceContext<ReqTextMessage,String>限定了selectService方法的参数类型和executeRequest方法的返回值类型，使其能够灵活的支持各种类型的参数和返回值。\n\n看一下在没有学习泛型之前，这个接口是怎么实现的：\n\n```java\npublic interface BaseServiceContext {\n\tpublic void selectService(ReqBaseMessage reqMeg);\n\n\tpublic Object executeRequest();\n}\n\npublic class TextServiceContext implements BaseServiceContext {\n\n\t@Override\n\tpublic void selectService(ReqBaseMessage reqMeg) {\n\t\t//根据业务逻辑对reqMeg进行强转，需要程序员自己判断\n\t\t//很有可能强转失败\n\t}\n\n\t@Override\n\tpublic Object executeRequest() {\n\t\t//返回类型为object，在调用方法的外部强转为需要的类型\n\t\t//很有可能强转失败\n\t}\n}\n```\n可以看到没有使用泛型接口的情况下，类型不安全且增大了强转失败的风险。同时也需要程序员根据业务逻辑去判断该强转成什么类型。使用泛型接口之后就没有了这些问题，只需要在使用接口时声明好他的泛型参数就o了。\n\n上面只是我在开发过程中体会到泛型的一个好处，类似的例子还有很多。\n\n## 注意事项\n\n\n\n## 参考\n\n[java 泛型编程（一）](http://peiquan.blog.51cto.com/7518552/1302898)\n\n[泛型：工作原理及其重要性](http://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html)\n\n[Java深度历险（五）——Java泛型](http://www.infoq.com/cn/articles/cf-java-generics)\n\n[java泛型详解](http://blog.csdn.net/u012152619/article/details/47253811)\n\n[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)\n\n","slug":"java泛型学习","published":1,"updated":"2016-11-30T14:32:49.909Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj4u0014digclq1drm2y","content":"<p>有一段时间没有更新博客了，过了国庆之后，好像变得更懒了~~前两天开发了一个用于记账的公众号，功能很简单，就是普通的增删查改…由于是个人开发者，无法进行公众号的认证，所以没什么高级的接口权限，只能搞的简陋一点了…下一步计划再丰富丰富，目前想到了这几个功能：配合有道或者金山词霸的Api进行中英互译（API怎么用，可不可以用目前还不清楚），配合微博的Api接口整点微博热门什么的，配合豆瓣的Api接口做一个电影或者书籍查询的功能等等….公众号的服务器代码目前还部署在自己的电脑上，用nat123做了一下公网ip的映射，接下来考虑是不是要换成云服务器更为妥当….</p>\n<p>公众号在这里：</p>\n<img src=\"/2016/10/10/java泛型学习/easybill.jpg\" alt=\"EasyBill\" title=\"EasyBill\">\n<p>目前，公众号已经开源：<a href=\"https://github.com/Hikyu/WechatSubscriptionNumber\" target=\"_blank\" rel=\"external\">WechatSubscriptionNumber</a></p>\n<p>好了，言归正传。今天学习了java的泛型知识，不总结一下老是觉得跟没学一样…</p>\n<h2 id=\"泛型的好处\"><a href=\"#泛型的好处\" class=\"headerlink\" title=\"泛型的好处\"></a>泛型的好处</h2><p>使用泛型的好处我觉得有两点：1：类型安全  2：减少类型强转</p>\n<p>下面通过一个例子说明:</p>\n<p>假设有一个Test类，通用的实现是:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Object o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以这样使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest test = <span class=\"keyword\">new</span> Test(<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div><div class=\"line\">\t<span class=\"comment\">//编译时不报错</span></div><div class=\"line\">\t<span class=\"comment\">//运行时报  java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span></div><div class=\"line\">\tString o = (String) test.getObject();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一个使用泛型的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> T o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest1&lt;Integer&gt; test = <span class=\"keyword\">new</span> Test1&lt;Integer&gt;(<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div><div class=\"line\">\t<span class=\"comment\">//编译时报错，无法通过编译</span></div><div class=\"line\">\t<span class=\"comment\">//String o = test.getObject();</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//正常运行</span></div><div class=\"line\">\tInteger o = test.getObject();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的对比中能够看出两点：</p>\n<p>1.使用泛型之后在编译时报错而非运行时，减少了出错的几率；</p>\n<p>2.使用泛型之后编译器不再要求强转</p>\n<h2 id=\"定义泛型\"><a href=\"#定义泛型\" class=\"headerlink\" title=\"定义泛型\"></a>定义泛型</h2><p>泛型的机制能够在定义类、接口、方法时把类型参数化，也就是类似于方法的形参一样，把类型当做参数使用。</p>\n<p>泛型参数部分使用<code>&lt;&gt;</code>包裹起来，比如<code>&lt;T&gt;</code>，T声明了一种类型，习惯上，这个类型参数使用单个大写字母来表示，指示所定义的参数类型。有如下惯例：</p>\n<p>E：表示元素</p>\n<p>T：表示类型</p>\n<p>K：表示键</p>\n<p>V：表示值</p>\n<p>N：表示数字</p>\n<h3 id=\"定义泛型类\"><a href=\"#定义泛型类\" class=\"headerlink\" title=\"定义泛型类\"></a>定义泛型类</h3><p>上面的例子就是一个很好的演示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> T o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义类之后，泛型参数 T 可以运用到该类中：可以声明成员变量类型、可以声明成员函数返回值类型、可以声明成员函数参数类型。</p>\n<p>要注意：泛型参数T不能用于声明静态变量，同时也不能用于new一个对象比如：T o = new T();</p>\n<p>下面的类型擦除会说到原因。</p>\n<h3 id=\"定义泛型接口\"><a href=\"#定义泛型接口\" class=\"headerlink\" title=\"定义泛型接口\"></a>定义泛型接口</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">test</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义接口之后，泛型参数 T 可以运用到该接口中：可以声明接口函数返回值类型、可以声明接口函数参数类型。</p>\n<h3 id=\"定义泛型方法\"><a href=\"#定义泛型方法\" class=\"headerlink\" title=\"定义泛型方法\"></a>定义泛型方法</h3><p>可以单独给方法使用泛型，而不是泛化整个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getT</span><span class=\"params\">(T t)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> t;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义方法后，泛型参数 T 可以声明该方法的返回值类型、可以声明该方法的参数类型。</p>\n<p>要注意，定义方法所用的泛型参数需要在修饰符之后添加。</p>\n<h3 id=\"定义多个泛型参数\"><a href=\"#定义多个泛型参数\" class=\"headerlink\" title=\"定义多个泛型参数\"></a>定义多个泛型参数</h3><p>以接口为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">S</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">testT</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> S <span class=\"title\">testS</span><span class=\"params\">(S s)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//编译时报错</span></div><div class=\"line\">\t<span class=\"comment\">//getT(\"s\");</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>多个泛型参数在尖括号中使用逗号隔开。类的泛化与方法的泛化类似。</p>\n<h3 id=\"泛型参数的界限\"><a href=\"#泛型参数的界限\" class=\"headerlink\" title=\"泛型参数的界限\"></a>泛型参数的界限</h3><p>定义泛型参数界限有这样两种意义：</p>\n<p>1.有时候我们希望限定这个泛型参数的类型为某个类的子类或者超类；</p>\n<p>2.上面的例子中可以看到，我们定义了泛型参数，向方法中传入某种类型，这种类型是未知的，因此我们无法使用这种类型定义的变量，不能够调用它的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T extends Number&gt; <span class=\"function\">Integer <span class=\"title\">getT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> Integer(t.intValue());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面例子中，<code>&lt;T extends A&gt;</code>表示T是A或A的子类，他限定了传入泛型方法参数的类型必须为A或A的子类，同时，在方法体中我们也可以使用t这个实参就像使用A的实例一样，调用Number具有的public方法。</p>\n<p>除了<code>&lt;T extends A&gt;</code>限定T是A或A的子类外，还可以使用<code>&lt;T super A&gt;</code>这种方式来限定T是A或A的超类。</p>\n<p>A可以是某个类或者接口。</p>\n<p>除此以外，还可以为泛型参数限定多个限制范围，如<code>&lt;T extends A &amp; B &amp; C&gt;</code>，限定范围中最多只能有一个类(某个类只能有一个父类~~)，并且他必须是限定列表中的第一个。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class A &#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">B</span> </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">C</span> </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//正确</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> &lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> &amp; <span class=\"title\">B</span> &amp; <span class=\"title\">C</span>&gt; </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"comment\">//编译时报错</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> &lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> &amp; <span class=\"title\">B</span> &amp; <span class=\"title\">C</span>&gt; </span>&#123; <span class=\"comment\">// &#125;</span></div></pre></td></tr></table></figure>\n<h3 id=\"泛型的继承\"><a href=\"#泛型的继承\" class=\"headerlink\" title=\"泛型的继承\"></a>泛型的继承</h3><p>看一下jdk中List的泛型继承例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;<span class=\"comment\">//...&#125;</span></div></pre></td></tr></table></figure>\n<p><code>List&lt;String&gt;</code> 就是 <code>Collection&lt;String&gt;</code> 的子类。</p>\n<p>假如定义自己的接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyList</span>&lt;<span class=\"title\">E</span>,<span class=\"title\">P</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setPay</span><span class=\"params\">(E e,P p)</span></span>;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>MyList&lt;String,String&gt;</code>、<code>MyList&lt;String,Integer&gt;</code>、<code>MyList&lt;String,Exception&gt;</code>都是<code>List&lt;String&gt;</code>的子类。</p>\n<h2 id=\"使用泛型\"><a href=\"#使用泛型\" class=\"headerlink\" title=\"使用泛型\"></a>使用泛型</h2><p>上面的例子中已经列举了一些使用泛化类或者泛化函数的例子，但是还有一些问题需要指出：</p>\n<p>1.泛型参数只接受引用类型，不适用于基本类型</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//无法通过编译，不接受int类型的泛化参数</span></div><div class=\"line\">\t<span class=\"comment\">//Test&lt;int&gt; test = new Test();</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而我们使用泛化函数时：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tgetT(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>是没有问题的，通过查看生成的字节码，发现getT(1)这个方法的字节码中1被自动装箱为Integer类型。</p>\n<p>2.通配符的使用</p>\n<p>考虑下面的情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(Test&lt;Number&gt; t)</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest&lt;Double&gt; test = <span class=\"keyword\">new</span> Test();</div><div class=\"line\">\t<span class=\"comment\">//编译时报错</span></div><div class=\"line\">\t<span class=\"comment\">//getT(test);</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>报错的原因很好理解，虽然Double是Number的子类，但Test<double>并不是Test<number>的子类，故类型检查无法通过。这一点一定要明白。</number></double></p>\n<p>那么如果我们确实想要传入一个Test<double>类型的形参呢？可以使用通配符：</double></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tTest&lt;Double&gt; test = <span class=\"keyword\">new</span> Test();</div><div class=\"line\">\t\t<span class=\"comment\">//正常运行</span></div><div class=\"line\">\t\tgetT(test);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(Test&lt;? extends Number&gt; t)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Test&lt;? extends Number&gt;</code>扩展了形参的类型，可以是<code>Test&lt;Double&gt;</code>、<code>Test&lt;Integer&gt;</code>等，尖括号中的类型必须是Number或继承于Number。同样的，通配符也适用于super，如<code>Test&lt;? super A&gt;</code>。</p>\n<p>如果类型参数中既没有extends 关键字，也没有super关键字，只有一个?，代表无限定通配符。</p>\n<p><code>Test&lt;?&gt;</code>与<code>Test&lt;Object&gt;</code>并不相同，无论T是什么类型，<code>Test&lt;T&gt;</code> 是 <code>Test&lt;?&gt;</code>的子类，但是，<code>Test&lt;T&gt;</code> 不是 <code>Test&lt;Object&gt;</code> 的子类，想想上面的例子。</p>\n<p>通常在两种情况下会使用无限定通配符：</p>\n<ol>\n<li><p>如果正在编写一个方法，可以使用Object类中提供的功能来实现</p>\n</li>\n<li><p>代码实现的功能与类型参数无关，比如List.clear()与List.size()方法，还有经常使用的<code>Class&lt;?&gt;</code>方法，其实现的功能都与类型参数无关。</p>\n</li>\n</ol>\n<p>一般情况下，通配符<code>&lt;? extends Number&gt;</code>只是出现在使用泛型的时候，而不是定义泛型的时候，就像上面的例子那样。而<code>&lt;T extends Number&gt;</code>这种形式出现在定义泛型的时候，而不是使用泛型的时候，不要搞混了。</p>\n<p>结合泛型的继承和通配符的使用，理解一下泛型的类型系统，也就是泛型类的继承关系：</p>\n<p>以下内容来自：<a href=\"http://www.infoq.com/cn/articles/cf-java-generics\" target=\"_blank\" rel=\"external\">Java深度历险（五）——Java泛型</a></p>\n<hr>\n<p>引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 <code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：</p>\n<p>相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code> 的子类型，<code>List&lt;String&gt;</code>可以替换<code>Collection&lt;String&gt;</code>。这种情况也适用于带有上下界的类型声明。<br>当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对<code>Collection&lt;? extends Number&gt;</code>来说，其子类型可以在Collection这个维度上展开，即<code>List&lt;? extends Number&gt;</code>和<code>Set&lt;? extends Number&gt;</code>等；也可以在Number这个层次上展开，即<code>Collection&lt;Double&gt;</code>和 <code>Collection&lt;Integer&gt;</code>等。如此循环下去，<code>ArrayList&lt;Long&gt;</code>和 <code>HashSet&lt;Double&gt;</code>等也都算是<code>Collection&lt;? extends Number&gt;</code>的子类型。<br>如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。</p>\n<hr>\n<p>关于通配符的理解可以参考<a href=\"https://www.zhihu.com/question/20400700\" target=\"_blank\" rel=\"external\">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></p>\n<h2 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h2><p>类型擦除发生在编译阶段，对于运行期的JVM来说，<code>List&lt;int&gt;</code>与<code>List&lt;String&gt;</code>就是同一个类，因为在编译结束之后，生成的字节码文件中，他们都是List类型。</p>\n<p>1.java编译器会在编译前进行类型检查</p>\n<p>java编译器承担了所有泛型的类型安全检查工作。</p>\n<p>2.类型擦除后保留的原始类型</p>\n<p>原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。</p>\n<p>3.自动类型转换</p>\n<p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        ArrayList&lt;Date&gt; list=<span class=\"keyword\">new</span> ArrayList&lt;Date&gt;();  </div><div class=\"line\">        list.add(<span class=\"keyword\">new</span> Date());  </div><div class=\"line\">        Date myDate=list.get(<span class=\"number\">0</span>);  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Date myDate=list.get(0);</code>这里我们并没有对其返回值进行强转就可以直接获取Date类型的返回值。原因在于在字节码当中，有checkcast这么一个操作帮助我们进行了强转，这是java自动进行的。</p>\n<p>更多的关于类型擦除的知识，参考<a href=\"http://blog.csdn.net/lonelyroamer/article/details/7868820\" target=\"_blank\" rel=\"external\"> java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>最近在重构公众号服务器的过程中，用到了泛型编程的知识。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseServiceContext</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReqBaseMessage</span>, <span class=\"title\">R</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(T reqMeg)</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> R <span class=\"title\">executeRequest</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面是一个选择service的上下文接口，接收到用户请求后通过这个接口选择对应的service并且执行service。这个接口相当于一个工厂和策略模式的结合体。下面是这个接口的一种实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//请求为文本类型，返回string类型的处理结果</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextServiceContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseServiceContext</span>&lt;<span class=\"title\">ReqTextMessage</span>,<span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqTextMessage reqMeg)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//.....</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">executeRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//.....</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，BaseServiceContext<reqtextmessage,string>限定了selectService方法的参数类型和executeRequest方法的返回值类型，使其能够灵活的支持各种类型的参数和返回值。</reqtextmessage,string></p>\n<p>看一下在没有学习泛型之前，这个接口是怎么实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseServiceContext</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqBaseMessage reqMeg)</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">executeRequest</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextServiceContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseServiceContext</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqBaseMessage reqMeg)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//根据业务逻辑对reqMeg进行强转，需要程序员自己判断</span></div><div class=\"line\">\t\t<span class=\"comment\">//很有可能强转失败</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">executeRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//返回类型为object，在调用方法的外部强转为需要的类型</span></div><div class=\"line\">\t\t<span class=\"comment\">//很有可能强转失败</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到没有使用泛型接口的情况下，类型不安全且增大了强转失败的风险。同时也需要程序员根据业务逻辑去判断该强转成什么类型。使用泛型接口之后就没有了这些问题，只需要在使用接口时声明好他的泛型参数就o了。</p>\n<p>上面只是我在开发过程中体会到泛型的一个好处，类似的例子还有很多。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://peiquan.blog.51cto.com/7518552/1302898\" target=\"_blank\" rel=\"external\">java 泛型编程（一）</a></p>\n<p><a href=\"http://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html\" target=\"_blank\" rel=\"external\">泛型：工作原理及其重要性</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/cf-java-generics\" target=\"_blank\" rel=\"external\">Java深度历险（五）——Java泛型</a></p>\n<p><a href=\"http://blog.csdn.net/u012152619/article/details/47253811\" target=\"_blank\" rel=\"external\">java泛型详解</a></p>\n<p><a href=\"https://www.zhihu.com/question/20400700\" target=\"_blank\" rel=\"external\">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></p>\n","excerpt":"","more":"<p>有一段时间没有更新博客了，过了国庆之后，好像变得更懒了~~前两天开发了一个用于记账的公众号，功能很简单，就是普通的增删查改…由于是个人开发者，无法进行公众号的认证，所以没什么高级的接口权限，只能搞的简陋一点了…下一步计划再丰富丰富，目前想到了这几个功能：配合有道或者金山词霸的Api进行中英互译（API怎么用，可不可以用目前还不清楚），配合微博的Api接口整点微博热门什么的，配合豆瓣的Api接口做一个电影或者书籍查询的功能等等….公众号的服务器代码目前还部署在自己的电脑上，用nat123做了一下公网ip的映射，接下来考虑是不是要换成云服务器更为妥当….</p>\n<p>公众号在这里：</p>\n<img src=\"/2016/10/10/java泛型学习/easybill.jpg\" alt=\"EasyBill\" title=\"EasyBill\">\n<p>目前，公众号已经开源：<a href=\"https://github.com/Hikyu/WechatSubscriptionNumber\">WechatSubscriptionNumber</a></p>\n<p>好了，言归正传。今天学习了java的泛型知识，不总结一下老是觉得跟没学一样…</p>\n<h2 id=\"泛型的好处\"><a href=\"#泛型的好处\" class=\"headerlink\" title=\"泛型的好处\"></a>泛型的好处</h2><p>使用泛型的好处我觉得有两点：1：类型安全  2：减少类型强转</p>\n<p>下面通过一个例子说明:</p>\n<p>假设有一个Test类，通用的实现是:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Object o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以这样使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest test = <span class=\"keyword\">new</span> Test(<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div><div class=\"line\">\t<span class=\"comment\">//编译时不报错</span></div><div class=\"line\">\t<span class=\"comment\">//运行时报  java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span></div><div class=\"line\">\tString o = (String) test.getObject();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一个使用泛型的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> T o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest1&lt;Integer&gt; test = <span class=\"keyword\">new</span> Test1&lt;Integer&gt;(<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div><div class=\"line\">\t<span class=\"comment\">//编译时报错，无法通过编译</span></div><div class=\"line\">\t<span class=\"comment\">//String o = test.getObject();</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//正常运行</span></div><div class=\"line\">\tInteger o = test.getObject();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的对比中能够看出两点：</p>\n<p>1.使用泛型之后在编译时报错而非运行时，减少了出错的几率；</p>\n<p>2.使用泛型之后编译器不再要求强转</p>\n<h2 id=\"定义泛型\"><a href=\"#定义泛型\" class=\"headerlink\" title=\"定义泛型\"></a>定义泛型</h2><p>泛型的机制能够在定义类、接口、方法时把类型参数化，也就是类似于方法的形参一样，把类型当做参数使用。</p>\n<p>泛型参数部分使用<code>&lt;&gt;</code>包裹起来，比如<code>&lt;T&gt;</code>，T声明了一种类型，习惯上，这个类型参数使用单个大写字母来表示，指示所定义的参数类型。有如下惯例：</p>\n<p>E：表示元素</p>\n<p>T：表示类型</p>\n<p>K：表示键</p>\n<p>V：表示值</p>\n<p>N：表示数字</p>\n<h3 id=\"定义泛型类\"><a href=\"#定义泛型类\" class=\"headerlink\" title=\"定义泛型类\"></a>定义泛型类</h3><p>上面的例子就是一个很好的演示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> T o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义类之后，泛型参数 T 可以运用到该类中：可以声明成员变量类型、可以声明成员函数返回值类型、可以声明成员函数参数类型。</p>\n<p>要注意：泛型参数T不能用于声明静态变量，同时也不能用于new一个对象比如：T o = new T();</p>\n<p>下面的类型擦除会说到原因。</p>\n<h3 id=\"定义泛型接口\"><a href=\"#定义泛型接口\" class=\"headerlink\" title=\"定义泛型接口\"></a>定义泛型接口</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">test</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义接口之后，泛型参数 T 可以运用到该接口中：可以声明接口函数返回值类型、可以声明接口函数参数类型。</p>\n<h3 id=\"定义泛型方法\"><a href=\"#定义泛型方法\" class=\"headerlink\" title=\"定义泛型方法\"></a>定义泛型方法</h3><p>可以单独给方法使用泛型，而不是泛化整个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getT</span><span class=\"params\">(T t)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> t;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义方法后，泛型参数 T 可以声明该方法的返回值类型、可以声明该方法的参数类型。</p>\n<p>要注意，定义方法所用的泛型参数需要在修饰符之后添加。</p>\n<h3 id=\"定义多个泛型参数\"><a href=\"#定义多个泛型参数\" class=\"headerlink\" title=\"定义多个泛型参数\"></a>定义多个泛型参数</h3><p>以接口为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">S</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">testT</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> S <span class=\"title\">testS</span><span class=\"params\">(S s)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//编译时报错</span></div><div class=\"line\">\t<span class=\"comment\">//getT(\"s\");</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>多个泛型参数在尖括号中使用逗号隔开。类的泛化与方法的泛化类似。</p>\n<h3 id=\"泛型参数的界限\"><a href=\"#泛型参数的界限\" class=\"headerlink\" title=\"泛型参数的界限\"></a>泛型参数的界限</h3><p>定义泛型参数界限有这样两种意义：</p>\n<p>1.有时候我们希望限定这个泛型参数的类型为某个类的子类或者超类；</p>\n<p>2.上面的例子中可以看到，我们定义了泛型参数，向方法中传入某种类型，这种类型是未知的，因此我们无法使用这种类型定义的变量，不能够调用它的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T extends Number&gt; <span class=\"function\">Integer <span class=\"title\">getT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> Integer(t.intValue());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面例子中，<code>&lt;T extends A&gt;</code>表示T是A或A的子类，他限定了传入泛型方法参数的类型必须为A或A的子类，同时，在方法体中我们也可以使用t这个实参就像使用A的实例一样，调用Number具有的public方法。</p>\n<p>除了<code>&lt;T extends A&gt;</code>限定T是A或A的子类外，还可以使用<code>&lt;T super A&gt;</code>这种方式来限定T是A或A的超类。</p>\n<p>A可以是某个类或者接口。</p>\n<p>除此以外，还可以为泛型参数限定多个限制范围，如<code>&lt;T extends A &amp; B &amp; C&gt;</code>，限定范围中最多只能有一个类(某个类只能有一个父类~~)，并且他必须是限定列表中的第一个。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class A &#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">B</span> </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">C</span> </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//正确</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> &lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> &amp; <span class=\"title\">B</span> &amp; <span class=\"title\">C</span>&gt; </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"comment\">//编译时报错</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> &lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> &amp; <span class=\"title\">B</span> &amp; <span class=\"title\">C</span>&gt; </span>&#123; <span class=\"comment\">// &#125;</span></div></pre></td></tr></table></figure>\n<h3 id=\"泛型的继承\"><a href=\"#泛型的继承\" class=\"headerlink\" title=\"泛型的继承\"></a>泛型的继承</h3><p>看一下jdk中List的泛型继承例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;<span class=\"comment\">//...&#125;</span></div></pre></td></tr></table></figure>\n<p><code>List&lt;String&gt;</code> 就是 <code>Collection&lt;String&gt;</code> 的子类。</p>\n<p>假如定义自己的接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyList</span>&lt;<span class=\"title\">E</span>,<span class=\"title\">P</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setPay</span><span class=\"params\">(E e,P p)</span></span>;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>MyList&lt;String,String&gt;</code>、<code>MyList&lt;String,Integer&gt;</code>、<code>MyList&lt;String,Exception&gt;</code>都是<code>List&lt;String&gt;</code>的子类。</p>\n<h2 id=\"使用泛型\"><a href=\"#使用泛型\" class=\"headerlink\" title=\"使用泛型\"></a>使用泛型</h2><p>上面的例子中已经列举了一些使用泛化类或者泛化函数的例子，但是还有一些问题需要指出：</p>\n<p>1.泛型参数只接受引用类型，不适用于基本类型</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//无法通过编译，不接受int类型的泛化参数</span></div><div class=\"line\">\t<span class=\"comment\">//Test&lt;int&gt; test = new Test();</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而我们使用泛化函数时：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tgetT(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>是没有问题的，通过查看生成的字节码，发现getT(1)这个方法的字节码中1被自动装箱为Integer类型。</p>\n<p>2.通配符的使用</p>\n<p>考虑下面的情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(Test&lt;Number&gt; t)</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest&lt;Double&gt; test = <span class=\"keyword\">new</span> Test();</div><div class=\"line\">\t<span class=\"comment\">//编译时报错</span></div><div class=\"line\">\t<span class=\"comment\">//getT(test);</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>报错的原因很好理解，虽然Double是Number的子类，但Test<Double>并不是Test<Number>的子类，故类型检查无法通过。这一点一定要明白。</p>\n<p>那么如果我们确实想要传入一个Test<Double>类型的形参呢？可以使用通配符：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tTest&lt;Double&gt; test = <span class=\"keyword\">new</span> Test();</div><div class=\"line\">\t\t<span class=\"comment\">//正常运行</span></div><div class=\"line\">\t\tgetT(test);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(Test&lt;? extends Number&gt; t)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Test&lt;? extends Number&gt;</code>扩展了形参的类型，可以是<code>Test&lt;Double&gt;</code>、<code>Test&lt;Integer&gt;</code>等，尖括号中的类型必须是Number或继承于Number。同样的，通配符也适用于super，如<code>Test&lt;? super A&gt;</code>。</p>\n<p>如果类型参数中既没有extends 关键字，也没有super关键字，只有一个?，代表无限定通配符。</p>\n<p><code>Test&lt;?&gt;</code>与<code>Test&lt;Object&gt;</code>并不相同，无论T是什么类型，<code>Test&lt;T&gt;</code> 是 <code>Test&lt;?&gt;</code>的子类，但是，<code>Test&lt;T&gt;</code> 不是 <code>Test&lt;Object&gt;</code> 的子类，想想上面的例子。</p>\n<p>通常在两种情况下会使用无限定通配符：</p>\n<ol>\n<li><p>如果正在编写一个方法，可以使用Object类中提供的功能来实现</p>\n</li>\n<li><p>代码实现的功能与类型参数无关，比如List.clear()与List.size()方法，还有经常使用的<code>Class&lt;?&gt;</code>方法，其实现的功能都与类型参数无关。</p>\n</li>\n</ol>\n<p>一般情况下，通配符<code>&lt;? extends Number&gt;</code>只是出现在使用泛型的时候，而不是定义泛型的时候，就像上面的例子那样。而<code>&lt;T extends Number&gt;</code>这种形式出现在定义泛型的时候，而不是使用泛型的时候，不要搞混了。</p>\n<p>结合泛型的继承和通配符的使用，理解一下泛型的类型系统，也就是泛型类的继承关系：</p>\n<p>以下内容来自：<a href=\"http://www.infoq.com/cn/articles/cf-java-generics\">Java深度历险（五）——Java泛型</a></p>\n<hr>\n<p>引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 <code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：</p>\n<p>相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code> 的子类型，<code>List&lt;String&gt;</code>可以替换<code>Collection&lt;String&gt;</code>。这种情况也适用于带有上下界的类型声明。<br>当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对<code>Collection&lt;? extends Number&gt;</code>来说，其子类型可以在Collection这个维度上展开，即<code>List&lt;? extends Number&gt;</code>和<code>Set&lt;? extends Number&gt;</code>等；也可以在Number这个层次上展开，即<code>Collection&lt;Double&gt;</code>和 <code>Collection&lt;Integer&gt;</code>等。如此循环下去，<code>ArrayList&lt;Long&gt;</code>和 <code>HashSet&lt;Double&gt;</code>等也都算是<code>Collection&lt;? extends Number&gt;</code>的子类型。<br>如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。</p>\n<hr>\n<p>关于通配符的理解可以参考<a href=\"https://www.zhihu.com/question/20400700\">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></p>\n<h2 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h2><p>类型擦除发生在编译阶段，对于运行期的JVM来说，<code>List&lt;int&gt;</code>与<code>List&lt;String&gt;</code>就是同一个类，因为在编译结束之后，生成的字节码文件中，他们都是List类型。</p>\n<p>1.java编译器会在编译前进行类型检查</p>\n<p>java编译器承担了所有泛型的类型安全检查工作。</p>\n<p>2.类型擦除后保留的原始类型</p>\n<p>原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。</p>\n<p>3.自动类型转换</p>\n<p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        ArrayList&lt;Date&gt; list=<span class=\"keyword\">new</span> ArrayList&lt;Date&gt;();  </div><div class=\"line\">        list.add(<span class=\"keyword\">new</span> Date());  </div><div class=\"line\">        Date myDate=list.get(<span class=\"number\">0</span>);  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Date myDate=list.get(0);</code>这里我们并没有对其返回值进行强转就可以直接获取Date类型的返回值。原因在于在字节码当中，有checkcast这么一个操作帮助我们进行了强转，这是java自动进行的。</p>\n<p>更多的关于类型擦除的知识，参考<a href=\"http://blog.csdn.net/lonelyroamer/article/details/7868820\"> java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>最近在重构公众号服务器的过程中，用到了泛型编程的知识。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseServiceContext</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReqBaseMessage</span>, <span class=\"title\">R</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(T reqMeg)</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> R <span class=\"title\">executeRequest</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面是一个选择service的上下文接口，接收到用户请求后通过这个接口选择对应的service并且执行service。这个接口相当于一个工厂和策略模式的结合体。下面是这个接口的一种实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//请求为文本类型，返回string类型的处理结果</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextServiceContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseServiceContext</span>&lt;<span class=\"title\">ReqTextMessage</span>,<span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqTextMessage reqMeg)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//.....</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">executeRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//.....</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，BaseServiceContext<ReqTextMessage,String>限定了selectService方法的参数类型和executeRequest方法的返回值类型，使其能够灵活的支持各种类型的参数和返回值。</p>\n<p>看一下在没有学习泛型之前，这个接口是怎么实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseServiceContext</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqBaseMessage reqMeg)</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">executeRequest</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextServiceContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseServiceContext</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqBaseMessage reqMeg)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//根据业务逻辑对reqMeg进行强转，需要程序员自己判断</span></div><div class=\"line\">\t\t<span class=\"comment\">//很有可能强转失败</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">executeRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//返回类型为object，在调用方法的外部强转为需要的类型</span></div><div class=\"line\">\t\t<span class=\"comment\">//很有可能强转失败</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到没有使用泛型接口的情况下，类型不安全且增大了强转失败的风险。同时也需要程序员根据业务逻辑去判断该强转成什么类型。使用泛型接口之后就没有了这些问题，只需要在使用接口时声明好他的泛型参数就o了。</p>\n<p>上面只是我在开发过程中体会到泛型的一个好处，类似的例子还有很多。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://peiquan.blog.51cto.com/7518552/1302898\">java 泛型编程（一）</a></p>\n<p><a href=\"http://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html\">泛型：工作原理及其重要性</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/cf-java-generics\">Java深度历险（五）——Java泛型</a></p>\n<p><a href=\"http://blog.csdn.net/u012152619/article/details/47253811\">java泛型详解</a></p>\n<p><a href=\"https://www.zhihu.com/question/20400700\">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></p>\n"},{"layout":"post","date":"2016-04-12T04:48:55.000Z","title":"Junit的使用","_content":"\n>[Junit](http://junit.org/junit4/)是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。\n\n\n\n\n\n\n\n**资料**\n\n[Unit Testing with JUnit - Tutorial](http://www.vogella.com/tutorials/JUnit/article.html)\n\n[JUnit Tutorial](http://www.tutorialspoint.com/junit/)\n\n[走进java测试利器-junit](http://developer.51cto.com/art/201103/252490.htm)\n\n","source":"_posts/junit使用.md","raw":"---\nlayout: post\ndate:   2016-04-12 12:48:55\ntitle: \"Junit的使用\"\ncategories: 工具\ntags: \n- junit\n- 测试\n---\n\n>[Junit](http://junit.org/junit4/)是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。\n\n\n\n\n\n\n\n**资料**\n\n[Unit Testing with JUnit - Tutorial](http://www.vogella.com/tutorials/JUnit/article.html)\n\n[JUnit Tutorial](http://www.tutorialspoint.com/junit/)\n\n[走进java测试利器-junit](http://developer.51cto.com/art/201103/252490.htm)\n\n","slug":"junit使用","published":1,"updated":"2016-11-30T14:32:49.909Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj510017digct04jwglg","content":"<blockquote>\n<p><a href=\"http://junit.org/junit4/\" target=\"_blank\" rel=\"external\">Junit</a>是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。</p>\n</blockquote>\n<p><strong>资料</strong></p>\n<p><a href=\"http://www.vogella.com/tutorials/JUnit/article.html\" target=\"_blank\" rel=\"external\">Unit Testing with JUnit - Tutorial</a></p>\n<p><a href=\"http://www.tutorialspoint.com/junit/\" target=\"_blank\" rel=\"external\">JUnit Tutorial</a></p>\n<p><a href=\"http://developer.51cto.com/art/201103/252490.htm\" target=\"_blank\" rel=\"external\">走进java测试利器-junit</a></p>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"http://junit.org/junit4/\">Junit</a>是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。</p>\n</blockquote>\n<p><strong>资料</strong></p>\n<p><a href=\"http://www.vogella.com/tutorials/JUnit/article.html\">Unit Testing with JUnit - Tutorial</a></p>\n<p><a href=\"http://www.tutorialspoint.com/junit/\">JUnit Tutorial</a></p>\n<p><a href=\"http://developer.51cto.com/art/201103/252490.htm\">走进java测试利器-junit</a></p>\n"},{"layout":"post","title":"java远程调试学习","date":"2016-12-07T13:55:48.000Z","_content":"\n> 集群前后台协议需要做一些修改，我负责jdbc这边的修改。按照协议内容修改完代码之后却面临一个测试的问题：修改后的后台又部署在北京，但北京并不是所有的机器都对天津这边开放，只给提供一台机器A，就是集群的服务器。\n> 这样的话,就无法创建节点的连接，测试没有办法进行。\n\n> 一开始用了最简单的办法，把打好的jar包通过远程ssh放到A上面，再通过ssh去跑用例，打印结果看看正确与否。但是这样的效率真的太低了，每做一次修改都要打包、部署、运行、分析log。于是借这个机会学习一下java程序的远程调试。以下为总结。\n\n\n## 一些概念\n\nJDPA: java平台调试架构\n\nJVMTI: JVM端调试接口\n\nJDI: java端调试接口\n\nJDWP: java调试网络协议\n\n{% asset_img jdpa.png jdpa %}\n\nJPDA 定义了一套如何开发调试工具的接口和规范。\n\nJPDA 由三个独立的模块 JVMTI、JDWP、JDI 组成。\n\n调试者通过 JDI 发送接受调试命令。\n\nJDWP 定义调试者和被调试者交流数据的格式。\n\nJVMTI 可以控制当前虚拟机运行状态。\n\n上图中的前端工具就是我们要用到的调试工具。如JDB、Eclipse等等。这些工具实现了JDI接口，通过这些工具我们可以达到在命令行或者图形界面下调试的目的。\n\n关于这部分，只是简单的了解一下概念，更多的关于JDPA的介绍：[JDPA体系](http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?search_by=%E6%B7%B1%E5%85%A5+Java+%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB)\n\n## 使用JDB进行本地调试\n\nJDB 是jdk自带的一个调试工具，用于命令行下调试java程序\n\njdb.exe就位于jdk安装目录的bin目录下，安装好jdk并设置好环境变量之后就可以愉快的使用jdb了。\n\n```\nC:\\Users\\kyu>jdb -help\n用法: jdb <options> <class> <arguments>\n\n其中, 选项包括:\n    -help             输出此消息并退出\n    -sourcepath <由 \";\" 分隔的目录>\n                      要在其中查找源文件的目录\n    -attach <address>\n                      使用标准连接器附加到指定地址处正在运行的 VM\n    -listen <address>\n                      等待正在运行的 VM 使用标准连接器在指定地址处连接\n    -listenany\n                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接\n    -launch\n                      立即启动 VM 而不是等待 'run' 命令\n    -listconnectors   列出此 VM 中的可用连接器\n    -connect <connector-name>:<name1>=<value1>,...\n                      使用所列参数值通过指定的连接器连接到目标 VM\n    -dbgtrace [flags] 输出信息供调试jdb\n    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序\n    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序\n\n转发到被调试进程的选项:\n    -v -verbose[:class|gc|jni]\n                      启用详细模式\n    -D<name>=<value>  设置系统属性\n    -classpath <由 \";\" 分隔的目录>\n                      列出要在其中查找类的目录\n    -X<option>        非标准目标 VM 选项\n\n<class> 是要开始调试的类的名称\n<arguments> 是传递到 <class> 的 main() 方法的参数\n\n要获得命令的帮助, 请在jdb提示下键入 'help'\n```\n\n上面是启动JDB的语法说明。\n\n现假设运行程序的工程目录如下：\n\n```\nJDBTest\n  |----bin(编译生成的class文件)\n  |     |----*.class\n  |----src(源文件)\n  |     |----*.java\n  |----lib(依赖的第三方jar)\n  |     |----*.jar\n```\n\n开始启动JDB调试：\n\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n\n`注意，如果有多个文件，windows下使用 \";\" 分隔每个文件或目录，Linux下使用 \":\" 分隔每个文件或目录`\n\n`-classpath` 指定了类路径，`-sourcepath` 指定了源文件的路径\n\n回车，出现如下信息：\n\n```\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n正在初始化jdb...\n> \n```\n此时，JDB调试器等待用户的输入，输入`help`，出现如下信息：\n\n```\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n正在初始化jdb...\n> help\n** 命令列表 **\nconnectors                -- 列出此 VM 中可用的连接器和传输\n\nrun [class [args]]        -- 开始执行应用程序的主类\n\nthreads [threadgroup]     -- 列出线程\nthread <thread id>        -- 设置默认线程\nsuspend [thread id(s)]    -- 挂起线程 (默认值: all)\nresume [thread id(s)]     -- 恢复线程 (默认值: all)\nwhere [<thread id> | all] -- 转储线程的堆栈\nwherei [<thread id> | all]-- 转储线程的堆栈, 以及 pc 信息\nup [n frames]             -- 上移线程的堆栈\ndown [n frames]           -- 下移线程的堆栈\nkill <thread id> <expr>   -- 终止具有给定的异常错误对象的线程\ninterrupt <thread id>     -- 中断线程\n\nprint <expr>              -- 输出表达式的值\ndump <expr>               -- 输出所有对象信息\neval <expr>               -- 对表达式求值 (与 print 相同)\nset <lvalue> = <expr>     -- 向字段/变量/数组元素分配新值\nlocals                    -- 输出当前堆栈帧中的所有本地变量\n\nclasses                   -- 列出当前已知的类\nclass <class id>          -- 显示已命名类的详细资料\nmethods <class id>        -- 列出类的方法\nfields <class id>         -- 列出类的字段\n\nthreadgroups              -- 列出线程组\nthreadgroup <name>        -- 设置当前线程组\n\nstop in <class id>.<method>[(argument_type,...)]\n                          -- 在方法中设置断点\nstop at <class id>:<line> -- 在行中设置断点\nclear <class id>.<method>[(argument_type,...)]\n                          -- 清除方法中的断点\nclear <class id>:<line>   -- 清除行中的断点\nclear                     -- 列出断点\ncatch [uncaught|caught|all] <class id>|<class pattern>\n                          -- 出现指定的异常错误时中断\nignore [uncaught|caught|all] <class id>|<class pattern>\n                          -- 对于指定的异常错误, 取消 'catch'\nwatch [access|all] <class id>.<field name>\n                          -- 监视对字段的访问/修改\nunwatch [access|all] <class id>.<field name>\n                          -- 停止监视对字段的访问/修改\ntrace [go] methods [thread]\n                          -- 跟踪方法进入和退出。\n                          -- 除非指定 'go', 否则挂起所有线程\ntrace [go] method exit | exits [thread]\n                          -- 跟踪当前方法的退出, 或者所有方法的退出\n                          -- 除非指定 'go', 否则挂起所有线程\nuntrace [methods]         -- 停止跟踪方法进入和/或退出\nstep                      -- 执行当前行\nstep up                   -- 一直执行, 直到当前方法返回到其调用方\nstepi                     -- 执行当前指令\nnext                      -- 步进一行 (步过调用)\ncont                      -- 从断点处继续执行\n\nlist [line number|method] -- 输出源代码\nuse (或 sourcepath) [source file path]\n                          -- 显示或更改源路径\nexclude [<class pattern>, ... | \"none\"]\n                          -- 对于指定的类, 不报告步骤或方法事件\nclasspath                 -- 从目标 VM 输出类路径信息\n\nmonitor <command>         -- 每次程序停止时执行命令\nmonitor                   -- 列出监视器\nunmonitor <monitor#>      -- 删除监视器\nread <filename>           -- 读取并执行命令文件\n\nlock <expr>               -- 输出对象的锁信息\nthreadlocks [thread id]   -- 输出线程的锁信息\n\npop                       -- 通过当前帧出栈, 且包含当前帧\nreenter                   -- 与 pop 相同, 但重新进入当前帧\nredefine <class id> <class file name>\n                          -- 重新定义类的代码\n\ndisablegc <expr>          -- 禁止对象的垃圾收集\nenablegc <expr>           -- 允许对象的垃圾收集\n\n!!                        -- 重复执行最后一个命令\n<n> <command>             -- 将命令重复执行 n 次\n# <command>               -- 放弃 (无操作)\nhelp (或 ?)               -- 列出命令\nversion                   -- 输出版本信息\nexit (或 quit)            -- 退出调试器\n\n<class id>: 带有程序包限定符的完整类名\n<class pattern>: 带有前导或尾随通配符 ('*') 的类名\n<thread id>: 'threads' 命令中报告的线程编号\n<expr>: Java(TM) 编程语言表达式。\n支持大多数常见语法。\n\n可以将启动命令置于 \"jdb.ini\" 或 \".jdbrc\" 中\n位于 user.home 或 user.dir 中\n>\n```\n上面的帮助信息说明了如何进行JDB调试，解释一下其中的几个：\n\nstep: -- 执行当前行 相当于Eclipse中的F5\n\nstep up: -- 一直执行, 直到当前方法返回到其调用方 相当于Eclipse中的F7\n\nnext: -- 步进一行 (步过调用) 相当于Eclipse中的F6\n\ncont: -- 从断点处继续执行 相当于Eclipse中的F8\n\n此时，继续输入：\n\n```\n> stop at test.JDBTest:7\n正在延迟断点test.JDBTest:7。\n将在加载类后设置。\n> run\n运行test.JDBTest\n设置未捕获的java.lang.Throwable\n设置延迟的未捕获的java.lang.Throwable\n>\nVM 已启动: 设置延迟的断点test.JDBTest:7\n\n断点命中: \"线程=main\", test.JDBTest.main(), 行=7 bci=0\n7               JDBTest jdbTest = new JDBTest();\n\nmain[1]\n```\nstop at test.JDBTest:7 表示在这个类文件的第7行处打一个断点\n\n接着，输入run，就开始进入调试步骤了。现在可以输入上面帮助中的语法来了解当前程序的执行情况了。一试便知\n\n`注意, 若想要在调试时能够正常输出调试信息如变量值等等，需要在编译java文件时指定 -g 参数，否则无法获得其运行时的调试信息`\n\n另外，使用list可以打印当前断点处的源代码，如果没有在启动JDB时指定源代码路径 -sourcepath ./src/ ，那么会提示没有源代码信息，无法输出。此时可以使用命令 use ./src/ 来指定源代码路径，再使用list命令时可以正常打印了。\n\n以上就是使用JDB调试本地程序的方法，具体的使用可根据实际情况参照语法说明去执行。\n\n## 使用JDB进行远程调试\n\n如果程序不是运行在本机，而是在其他机器或者现场的时候，可以使用java提供的远程调试功能。\n\n假设程序现运行在主机 192.168.101.72 这台机器上，该机器为linux环境，且只可以通过ssh作为一个普通用户连接。我们想要在自己的机器上调试运行在192.168.101.72这台机器上的程序。\n\n### 启动要调试的程序\n\n在192.168.101.72这台主机上以下面的方式启动java程序：还是以JDBTest为例\n\n`java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest`\n\n此时，命令行输出\n\n`Listening for transport dt_socket at address: 8899`\n\n并处于等待状态\n\n下面是几个参数的解释：\n\n-Xdebug 启用调试特性。 \n\n-Xrunjdwp:<sub-options> 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。下面介绍一些特定的子选项。\n从 Java V5 开始，您可以使用 -agentlib:jdwp 选项，而不是 -Xdebug 和 -Xrunjdwp。但如果连接到 V5 以前的 VM，只能选择 -Xdebug 和 -Xrunjdwp。下面简单描述 -Xrunjdwp 子选项。\n\ntransport 这里通常使用套接字传输。但是在 Windows 平台上也可以使用共享内存传输。\n\nserver 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。\n\naddress 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。\n\nsuspend 如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。\n\n### 本机连接远程程序并启动调试\n\n在本机上命令行下输入：\n\n`jdb -connect com.sun.jdi.SocketAttach:hostname=192.168.101.72,port=8899`\n\n然后就进入了调试界面，你可以像调试本机程序那样使用JDB的一些命令来调试了。当退出调试程序时，远程主机上的程序也就退出了。\n\n\n## 使用Eclipse进行远程调试\n\n可以使用Eclipse进行远程调试，就上上面使用JDB一样。\n\n### 启动要调试的程序\n\n与JDB远程调试一样，启动远程主机上的程序：\n\n`java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest`\n\n### 本机启动Eclipse进行调试\n\n首先要右键工程->java compiler\n\n{% asset_img setting.png jdpa %}\n\n上图中的几个选项最好全部打勾，否则调试时会出现无法打断点或者获取不到行号等问题(关于这几个选项的含义在之前的总结中有提到)\n\n接着，右键工程->Debug As->Run Configurations, 在出现的对话框中选择Remote Java Application, 右键->New, 出现如下界面：\n\n{% asset_img remote.png jdpa %}\n\n在Connect页中，选择对应的java 工程，Connection Type选择 Socket Attach，然后填写远程主机的ip和端口，这里应该填写192.168.101.72和8899。\n在Source页中可以添加源代码，如用到的第三方jar的源代码或者引用的工程，调试时就可以进入到这部分代码查看。在Common页可以设置编码的配置。\n\n接下来点击Debug按钮，就可以愉快的在本机调试远程程序了，就像调试本地程序那样。只不过可能有一点一点慢，不过比打Log的方式要好很多了。\n\n## 参考\n\n[使用 Eclipse 远程调试 Java 应用程序](https://www.ibm.com/developerworks/cn/opensource/os-eclipse-javadebug/)\n\n[JDB的简单使用](http://www.ibm.com/developerworks/cn/java/joy-jdb/)\n\n[深入 Java 调试体系: 第 1 部分，JPDA 体系概览 ](https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/)\n","source":"_posts/java远程调试学习.md","raw":"---\nlayout: post\ntitle: java远程调试学习\ndate: 2016-12-07 21:55:48\ncategories: java\ntags: \n- java \n- 调试\n---\n\n> 集群前后台协议需要做一些修改，我负责jdbc这边的修改。按照协议内容修改完代码之后却面临一个测试的问题：修改后的后台又部署在北京，但北京并不是所有的机器都对天津这边开放，只给提供一台机器A，就是集群的服务器。\n> 这样的话,就无法创建节点的连接，测试没有办法进行。\n\n> 一开始用了最简单的办法，把打好的jar包通过远程ssh放到A上面，再通过ssh去跑用例，打印结果看看正确与否。但是这样的效率真的太低了，每做一次修改都要打包、部署、运行、分析log。于是借这个机会学习一下java程序的远程调试。以下为总结。\n\n\n## 一些概念\n\nJDPA: java平台调试架构\n\nJVMTI: JVM端调试接口\n\nJDI: java端调试接口\n\nJDWP: java调试网络协议\n\n{% asset_img jdpa.png jdpa %}\n\nJPDA 定义了一套如何开发调试工具的接口和规范。\n\nJPDA 由三个独立的模块 JVMTI、JDWP、JDI 组成。\n\n调试者通过 JDI 发送接受调试命令。\n\nJDWP 定义调试者和被调试者交流数据的格式。\n\nJVMTI 可以控制当前虚拟机运行状态。\n\n上图中的前端工具就是我们要用到的调试工具。如JDB、Eclipse等等。这些工具实现了JDI接口，通过这些工具我们可以达到在命令行或者图形界面下调试的目的。\n\n关于这部分，只是简单的了解一下概念，更多的关于JDPA的介绍：[JDPA体系](http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?search_by=%E6%B7%B1%E5%85%A5+Java+%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB)\n\n## 使用JDB进行本地调试\n\nJDB 是jdk自带的一个调试工具，用于命令行下调试java程序\n\njdb.exe就位于jdk安装目录的bin目录下，安装好jdk并设置好环境变量之后就可以愉快的使用jdb了。\n\n```\nC:\\Users\\kyu>jdb -help\n用法: jdb <options> <class> <arguments>\n\n其中, 选项包括:\n    -help             输出此消息并退出\n    -sourcepath <由 \";\" 分隔的目录>\n                      要在其中查找源文件的目录\n    -attach <address>\n                      使用标准连接器附加到指定地址处正在运行的 VM\n    -listen <address>\n                      等待正在运行的 VM 使用标准连接器在指定地址处连接\n    -listenany\n                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接\n    -launch\n                      立即启动 VM 而不是等待 'run' 命令\n    -listconnectors   列出此 VM 中的可用连接器\n    -connect <connector-name>:<name1>=<value1>,...\n                      使用所列参数值通过指定的连接器连接到目标 VM\n    -dbgtrace [flags] 输出信息供调试jdb\n    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序\n    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序\n\n转发到被调试进程的选项:\n    -v -verbose[:class|gc|jni]\n                      启用详细模式\n    -D<name>=<value>  设置系统属性\n    -classpath <由 \";\" 分隔的目录>\n                      列出要在其中查找类的目录\n    -X<option>        非标准目标 VM 选项\n\n<class> 是要开始调试的类的名称\n<arguments> 是传递到 <class> 的 main() 方法的参数\n\n要获得命令的帮助, 请在jdb提示下键入 'help'\n```\n\n上面是启动JDB的语法说明。\n\n现假设运行程序的工程目录如下：\n\n```\nJDBTest\n  |----bin(编译生成的class文件)\n  |     |----*.class\n  |----src(源文件)\n  |     |----*.java\n  |----lib(依赖的第三方jar)\n  |     |----*.jar\n```\n\n开始启动JDB调试：\n\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n\n`注意，如果有多个文件，windows下使用 \";\" 分隔每个文件或目录，Linux下使用 \":\" 分隔每个文件或目录`\n\n`-classpath` 指定了类路径，`-sourcepath` 指定了源文件的路径\n\n回车，出现如下信息：\n\n```\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n正在初始化jdb...\n> \n```\n此时，JDB调试器等待用户的输入，输入`help`，出现如下信息：\n\n```\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n正在初始化jdb...\n> help\n** 命令列表 **\nconnectors                -- 列出此 VM 中可用的连接器和传输\n\nrun [class [args]]        -- 开始执行应用程序的主类\n\nthreads [threadgroup]     -- 列出线程\nthread <thread id>        -- 设置默认线程\nsuspend [thread id(s)]    -- 挂起线程 (默认值: all)\nresume [thread id(s)]     -- 恢复线程 (默认值: all)\nwhere [<thread id> | all] -- 转储线程的堆栈\nwherei [<thread id> | all]-- 转储线程的堆栈, 以及 pc 信息\nup [n frames]             -- 上移线程的堆栈\ndown [n frames]           -- 下移线程的堆栈\nkill <thread id> <expr>   -- 终止具有给定的异常错误对象的线程\ninterrupt <thread id>     -- 中断线程\n\nprint <expr>              -- 输出表达式的值\ndump <expr>               -- 输出所有对象信息\neval <expr>               -- 对表达式求值 (与 print 相同)\nset <lvalue> = <expr>     -- 向字段/变量/数组元素分配新值\nlocals                    -- 输出当前堆栈帧中的所有本地变量\n\nclasses                   -- 列出当前已知的类\nclass <class id>          -- 显示已命名类的详细资料\nmethods <class id>        -- 列出类的方法\nfields <class id>         -- 列出类的字段\n\nthreadgroups              -- 列出线程组\nthreadgroup <name>        -- 设置当前线程组\n\nstop in <class id>.<method>[(argument_type,...)]\n                          -- 在方法中设置断点\nstop at <class id>:<line> -- 在行中设置断点\nclear <class id>.<method>[(argument_type,...)]\n                          -- 清除方法中的断点\nclear <class id>:<line>   -- 清除行中的断点\nclear                     -- 列出断点\ncatch [uncaught|caught|all] <class id>|<class pattern>\n                          -- 出现指定的异常错误时中断\nignore [uncaught|caught|all] <class id>|<class pattern>\n                          -- 对于指定的异常错误, 取消 'catch'\nwatch [access|all] <class id>.<field name>\n                          -- 监视对字段的访问/修改\nunwatch [access|all] <class id>.<field name>\n                          -- 停止监视对字段的访问/修改\ntrace [go] methods [thread]\n                          -- 跟踪方法进入和退出。\n                          -- 除非指定 'go', 否则挂起所有线程\ntrace [go] method exit | exits [thread]\n                          -- 跟踪当前方法的退出, 或者所有方法的退出\n                          -- 除非指定 'go', 否则挂起所有线程\nuntrace [methods]         -- 停止跟踪方法进入和/或退出\nstep                      -- 执行当前行\nstep up                   -- 一直执行, 直到当前方法返回到其调用方\nstepi                     -- 执行当前指令\nnext                      -- 步进一行 (步过调用)\ncont                      -- 从断点处继续执行\n\nlist [line number|method] -- 输出源代码\nuse (或 sourcepath) [source file path]\n                          -- 显示或更改源路径\nexclude [<class pattern>, ... | \"none\"]\n                          -- 对于指定的类, 不报告步骤或方法事件\nclasspath                 -- 从目标 VM 输出类路径信息\n\nmonitor <command>         -- 每次程序停止时执行命令\nmonitor                   -- 列出监视器\nunmonitor <monitor#>      -- 删除监视器\nread <filename>           -- 读取并执行命令文件\n\nlock <expr>               -- 输出对象的锁信息\nthreadlocks [thread id]   -- 输出线程的锁信息\n\npop                       -- 通过当前帧出栈, 且包含当前帧\nreenter                   -- 与 pop 相同, 但重新进入当前帧\nredefine <class id> <class file name>\n                          -- 重新定义类的代码\n\ndisablegc <expr>          -- 禁止对象的垃圾收集\nenablegc <expr>           -- 允许对象的垃圾收集\n\n!!                        -- 重复执行最后一个命令\n<n> <command>             -- 将命令重复执行 n 次\n# <command>               -- 放弃 (无操作)\nhelp (或 ?)               -- 列出命令\nversion                   -- 输出版本信息\nexit (或 quit)            -- 退出调试器\n\n<class id>: 带有程序包限定符的完整类名\n<class pattern>: 带有前导或尾随通配符 ('*') 的类名\n<thread id>: 'threads' 命令中报告的线程编号\n<expr>: Java(TM) 编程语言表达式。\n支持大多数常见语法。\n\n可以将启动命令置于 \"jdb.ini\" 或 \".jdbrc\" 中\n位于 user.home 或 user.dir 中\n>\n```\n上面的帮助信息说明了如何进行JDB调试，解释一下其中的几个：\n\nstep: -- 执行当前行 相当于Eclipse中的F5\n\nstep up: -- 一直执行, 直到当前方法返回到其调用方 相当于Eclipse中的F7\n\nnext: -- 步进一行 (步过调用) 相当于Eclipse中的F6\n\ncont: -- 从断点处继续执行 相当于Eclipse中的F8\n\n此时，继续输入：\n\n```\n> stop at test.JDBTest:7\n正在延迟断点test.JDBTest:7。\n将在加载类后设置。\n> run\n运行test.JDBTest\n设置未捕获的java.lang.Throwable\n设置延迟的未捕获的java.lang.Throwable\n>\nVM 已启动: 设置延迟的断点test.JDBTest:7\n\n断点命中: \"线程=main\", test.JDBTest.main(), 行=7 bci=0\n7               JDBTest jdbTest = new JDBTest();\n\nmain[1]\n```\nstop at test.JDBTest:7 表示在这个类文件的第7行处打一个断点\n\n接着，输入run，就开始进入调试步骤了。现在可以输入上面帮助中的语法来了解当前程序的执行情况了。一试便知\n\n`注意, 若想要在调试时能够正常输出调试信息如变量值等等，需要在编译java文件时指定 -g 参数，否则无法获得其运行时的调试信息`\n\n另外，使用list可以打印当前断点处的源代码，如果没有在启动JDB时指定源代码路径 -sourcepath ./src/ ，那么会提示没有源代码信息，无法输出。此时可以使用命令 use ./src/ 来指定源代码路径，再使用list命令时可以正常打印了。\n\n以上就是使用JDB调试本地程序的方法，具体的使用可根据实际情况参照语法说明去执行。\n\n## 使用JDB进行远程调试\n\n如果程序不是运行在本机，而是在其他机器或者现场的时候，可以使用java提供的远程调试功能。\n\n假设程序现运行在主机 192.168.101.72 这台机器上，该机器为linux环境，且只可以通过ssh作为一个普通用户连接。我们想要在自己的机器上调试运行在192.168.101.72这台机器上的程序。\n\n### 启动要调试的程序\n\n在192.168.101.72这台主机上以下面的方式启动java程序：还是以JDBTest为例\n\n`java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest`\n\n此时，命令行输出\n\n`Listening for transport dt_socket at address: 8899`\n\n并处于等待状态\n\n下面是几个参数的解释：\n\n-Xdebug 启用调试特性。 \n\n-Xrunjdwp:<sub-options> 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。下面介绍一些特定的子选项。\n从 Java V5 开始，您可以使用 -agentlib:jdwp 选项，而不是 -Xdebug 和 -Xrunjdwp。但如果连接到 V5 以前的 VM，只能选择 -Xdebug 和 -Xrunjdwp。下面简单描述 -Xrunjdwp 子选项。\n\ntransport 这里通常使用套接字传输。但是在 Windows 平台上也可以使用共享内存传输。\n\nserver 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。\n\naddress 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。\n\nsuspend 如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。\n\n### 本机连接远程程序并启动调试\n\n在本机上命令行下输入：\n\n`jdb -connect com.sun.jdi.SocketAttach:hostname=192.168.101.72,port=8899`\n\n然后就进入了调试界面，你可以像调试本机程序那样使用JDB的一些命令来调试了。当退出调试程序时，远程主机上的程序也就退出了。\n\n\n## 使用Eclipse进行远程调试\n\n可以使用Eclipse进行远程调试，就上上面使用JDB一样。\n\n### 启动要调试的程序\n\n与JDB远程调试一样，启动远程主机上的程序：\n\n`java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest`\n\n### 本机启动Eclipse进行调试\n\n首先要右键工程->java compiler\n\n{% asset_img setting.png jdpa %}\n\n上图中的几个选项最好全部打勾，否则调试时会出现无法打断点或者获取不到行号等问题(关于这几个选项的含义在之前的总结中有提到)\n\n接着，右键工程->Debug As->Run Configurations, 在出现的对话框中选择Remote Java Application, 右键->New, 出现如下界面：\n\n{% asset_img remote.png jdpa %}\n\n在Connect页中，选择对应的java 工程，Connection Type选择 Socket Attach，然后填写远程主机的ip和端口，这里应该填写192.168.101.72和8899。\n在Source页中可以添加源代码，如用到的第三方jar的源代码或者引用的工程，调试时就可以进入到这部分代码查看。在Common页可以设置编码的配置。\n\n接下来点击Debug按钮，就可以愉快的在本机调试远程程序了，就像调试本地程序那样。只不过可能有一点一点慢，不过比打Log的方式要好很多了。\n\n## 参考\n\n[使用 Eclipse 远程调试 Java 应用程序](https://www.ibm.com/developerworks/cn/opensource/os-eclipse-javadebug/)\n\n[JDB的简单使用](http://www.ibm.com/developerworks/cn/java/joy-jdb/)\n\n[深入 Java 调试体系: 第 1 部分，JPDA 体系概览 ](https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/)\n","slug":"java远程调试学习","published":1,"updated":"2016-12-08T11:25:51.169Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj55001cdigcbzy14lti","content":"<blockquote>\n<p>集群前后台协议需要做一些修改，我负责jdbc这边的修改。按照协议内容修改完代码之后却面临一个测试的问题：修改后的后台又部署在北京，但北京并不是所有的机器都对天津这边开放，只给提供一台机器A，就是集群的服务器。<br>这样的话,就无法创建节点的连接，测试没有办法进行。</p>\n<p>一开始用了最简单的办法，把打好的jar包通过远程ssh放到A上面，再通过ssh去跑用例，打印结果看看正确与否。但是这样的效率真的太低了，每做一次修改都要打包、部署、运行、分析log。于是借这个机会学习一下java程序的远程调试。以下为总结。</p>\n</blockquote>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><p>JDPA: java平台调试架构</p>\n<p>JVMTI: JVM端调试接口</p>\n<p>JDI: java端调试接口</p>\n<p>JDWP: java调试网络协议</p>\n<img src=\"/2016/12/07/java远程调试学习/jdpa.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>JPDA 定义了一套如何开发调试工具的接口和规范。</p>\n<p>JPDA 由三个独立的模块 JVMTI、JDWP、JDI 组成。</p>\n<p>调试者通过 JDI 发送接受调试命令。</p>\n<p>JDWP 定义调试者和被调试者交流数据的格式。</p>\n<p>JVMTI 可以控制当前虚拟机运行状态。</p>\n<p>上图中的前端工具就是我们要用到的调试工具。如JDB、Eclipse等等。这些工具实现了JDI接口，通过这些工具我们可以达到在命令行或者图形界面下调试的目的。</p>\n<p>关于这部分，只是简单的了解一下概念，更多的关于JDPA的介绍：<a href=\"http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?search_by=%E6%B7%B1%E5%85%A5+Java+%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB\" target=\"_blank\" rel=\"external\">JDPA体系</a></p>\n<h2 id=\"使用JDB进行本地调试\"><a href=\"#使用JDB进行本地调试\" class=\"headerlink\" title=\"使用JDB进行本地调试\"></a>使用JDB进行本地调试</h2><p>JDB 是jdk自带的一个调试工具，用于命令行下调试java程序</p>\n<p>jdb.exe就位于jdk安装目录的bin目录下，安装好jdk并设置好环境变量之后就可以愉快的使用jdb了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:\\Users\\kyu&gt;jdb -help</div><div class=\"line\">用法: jdb &lt;options&gt; &lt;class&gt; &lt;arguments&gt;</div><div class=\"line\"></div><div class=\"line\">其中, 选项包括:</div><div class=\"line\">    -help             输出此消息并退出</div><div class=\"line\">    -sourcepath &lt;由 &quot;;&quot; 分隔的目录&gt;</div><div class=\"line\">                      要在其中查找源文件的目录</div><div class=\"line\">    -attach &lt;address&gt;</div><div class=\"line\">                      使用标准连接器附加到指定地址处正在运行的 VM</div><div class=\"line\">    -listen &lt;address&gt;</div><div class=\"line\">                      等待正在运行的 VM 使用标准连接器在指定地址处连接</div><div class=\"line\">    -listenany</div><div class=\"line\">                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接</div><div class=\"line\">    -launch</div><div class=\"line\">                      立即启动 VM 而不是等待 &apos;run&apos; 命令</div><div class=\"line\">    -listconnectors   列出此 VM 中的可用连接器</div><div class=\"line\">    -connect &lt;connector-name&gt;:&lt;name1&gt;=&lt;value1&gt;,...</div><div class=\"line\">                      使用所列参数值通过指定的连接器连接到目标 VM</div><div class=\"line\">    -dbgtrace [flags] 输出信息供调试jdb</div><div class=\"line\">    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序</div><div class=\"line\">    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序</div><div class=\"line\"></div><div class=\"line\">转发到被调试进程的选项:</div><div class=\"line\">    -v -verbose[:class|gc|jni]</div><div class=\"line\">                      启用详细模式</div><div class=\"line\">    -D&lt;name&gt;=&lt;value&gt;  设置系统属性</div><div class=\"line\">    -classpath &lt;由 &quot;;&quot; 分隔的目录&gt;</div><div class=\"line\">                      列出要在其中查找类的目录</div><div class=\"line\">    -X&lt;option&gt;        非标准目标 VM 选项</div><div class=\"line\"></div><div class=\"line\">&lt;class&gt; 是要开始调试的类的名称</div><div class=\"line\">&lt;arguments&gt; 是传递到 &lt;class&gt; 的 main() 方法的参数</div><div class=\"line\"></div><div class=\"line\">要获得命令的帮助, 请在jdb提示下键入 &apos;help&apos;</div></pre></td></tr></table></figure>\n<p>上面是启动JDB的语法说明。</p>\n<p>现假设运行程序的工程目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">JDBTest</div><div class=\"line\">  |----bin(编译生成的class文件)</div><div class=\"line\">  |     |----*.class</div><div class=\"line\">  |----src(源文件)</div><div class=\"line\">  |     |----*.java</div><div class=\"line\">  |----lib(依赖的第三方jar)</div><div class=\"line\">  |     |----*.jar</div></pre></td></tr></table></figure>\n<p>开始启动JDB调试：</p>\n<p>Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</p>\n<p><code>注意，如果有多个文件，windows下使用 &quot;;&quot; 分隔每个文件或目录，Linux下使用 &quot;:&quot; 分隔每个文件或目录</code></p>\n<p><code>-classpath</code> 指定了类路径，<code>-sourcepath</code> 指定了源文件的路径</p>\n<p>回车，出现如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</div><div class=\"line\">正在初始化jdb...</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<p>此时，JDB调试器等待用户的输入，输入<code>help</code>，出现如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div></pre></td><td class=\"code\"><pre><div class=\"line\">Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</div><div class=\"line\">正在初始化jdb...</div><div class=\"line\">&gt; help</div><div class=\"line\">** 命令列表 **</div><div class=\"line\">connectors                -- 列出此 VM 中可用的连接器和传输</div><div class=\"line\"></div><div class=\"line\">run [class [args]]        -- 开始执行应用程序的主类</div><div class=\"line\"></div><div class=\"line\">threads [threadgroup]     -- 列出线程</div><div class=\"line\">thread &lt;thread id&gt;        -- 设置默认线程</div><div class=\"line\">suspend [thread id(s)]    -- 挂起线程 (默认值: all)</div><div class=\"line\">resume [thread id(s)]     -- 恢复线程 (默认值: all)</div><div class=\"line\">where [&lt;thread id&gt; | all] -- 转储线程的堆栈</div><div class=\"line\">wherei [&lt;thread id&gt; | all]-- 转储线程的堆栈, 以及 pc 信息</div><div class=\"line\">up [n frames]             -- 上移线程的堆栈</div><div class=\"line\">down [n frames]           -- 下移线程的堆栈</div><div class=\"line\">kill &lt;thread id&gt; &lt;expr&gt;   -- 终止具有给定的异常错误对象的线程</div><div class=\"line\">interrupt &lt;thread id&gt;     -- 中断线程</div><div class=\"line\"></div><div class=\"line\">print &lt;expr&gt;              -- 输出表达式的值</div><div class=\"line\">dump &lt;expr&gt;               -- 输出所有对象信息</div><div class=\"line\">eval &lt;expr&gt;               -- 对表达式求值 (与 print 相同)</div><div class=\"line\">set &lt;lvalue&gt; = &lt;expr&gt;     -- 向字段/变量/数组元素分配新值</div><div class=\"line\">locals                    -- 输出当前堆栈帧中的所有本地变量</div><div class=\"line\"></div><div class=\"line\">classes                   -- 列出当前已知的类</div><div class=\"line\">class &lt;class id&gt;          -- 显示已命名类的详细资料</div><div class=\"line\">methods &lt;class id&gt;        -- 列出类的方法</div><div class=\"line\">fields &lt;class id&gt;         -- 列出类的字段</div><div class=\"line\"></div><div class=\"line\">threadgroups              -- 列出线程组</div><div class=\"line\">threadgroup &lt;name&gt;        -- 设置当前线程组</div><div class=\"line\"></div><div class=\"line\">stop in &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]</div><div class=\"line\">                          -- 在方法中设置断点</div><div class=\"line\">stop at &lt;class id&gt;:&lt;line&gt; -- 在行中设置断点</div><div class=\"line\">clear &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]</div><div class=\"line\">                          -- 清除方法中的断点</div><div class=\"line\">clear &lt;class id&gt;:&lt;line&gt;   -- 清除行中的断点</div><div class=\"line\">clear                     -- 列出断点</div><div class=\"line\">catch [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;</div><div class=\"line\">                          -- 出现指定的异常错误时中断</div><div class=\"line\">ignore [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;</div><div class=\"line\">                          -- 对于指定的异常错误, 取消 &apos;catch&apos;</div><div class=\"line\">watch [access|all] &lt;class id&gt;.&lt;field name&gt;</div><div class=\"line\">                          -- 监视对字段的访问/修改</div><div class=\"line\">unwatch [access|all] &lt;class id&gt;.&lt;field name&gt;</div><div class=\"line\">                          -- 停止监视对字段的访问/修改</div><div class=\"line\">trace [go] methods [thread]</div><div class=\"line\">                          -- 跟踪方法进入和退出。</div><div class=\"line\">                          -- 除非指定 &apos;go&apos;, 否则挂起所有线程</div><div class=\"line\">trace [go] method exit | exits [thread]</div><div class=\"line\">                          -- 跟踪当前方法的退出, 或者所有方法的退出</div><div class=\"line\">                          -- 除非指定 &apos;go&apos;, 否则挂起所有线程</div><div class=\"line\">untrace [methods]         -- 停止跟踪方法进入和/或退出</div><div class=\"line\">step                      -- 执行当前行</div><div class=\"line\">step up                   -- 一直执行, 直到当前方法返回到其调用方</div><div class=\"line\">stepi                     -- 执行当前指令</div><div class=\"line\">next                      -- 步进一行 (步过调用)</div><div class=\"line\">cont                      -- 从断点处继续执行</div><div class=\"line\"></div><div class=\"line\">list [line number|method] -- 输出源代码</div><div class=\"line\">use (或 sourcepath) [source file path]</div><div class=\"line\">                          -- 显示或更改源路径</div><div class=\"line\">exclude [&lt;class pattern&gt;, ... | &quot;none&quot;]</div><div class=\"line\">                          -- 对于指定的类, 不报告步骤或方法事件</div><div class=\"line\">classpath                 -- 从目标 VM 输出类路径信息</div><div class=\"line\"></div><div class=\"line\">monitor &lt;command&gt;         -- 每次程序停止时执行命令</div><div class=\"line\">monitor                   -- 列出监视器</div><div class=\"line\">unmonitor &lt;monitor#&gt;      -- 删除监视器</div><div class=\"line\">read &lt;filename&gt;           -- 读取并执行命令文件</div><div class=\"line\"></div><div class=\"line\">lock &lt;expr&gt;               -- 输出对象的锁信息</div><div class=\"line\">threadlocks [thread id]   -- 输出线程的锁信息</div><div class=\"line\"></div><div class=\"line\">pop                       -- 通过当前帧出栈, 且包含当前帧</div><div class=\"line\">reenter                   -- 与 pop 相同, 但重新进入当前帧</div><div class=\"line\">redefine &lt;class id&gt; &lt;class file name&gt;</div><div class=\"line\">                          -- 重新定义类的代码</div><div class=\"line\"></div><div class=\"line\">disablegc &lt;expr&gt;          -- 禁止对象的垃圾收集</div><div class=\"line\">enablegc &lt;expr&gt;           -- 允许对象的垃圾收集</div><div class=\"line\"></div><div class=\"line\">!!                        -- 重复执行最后一个命令</div><div class=\"line\">&lt;n&gt; &lt;command&gt;             -- 将命令重复执行 n 次</div><div class=\"line\"># &lt;command&gt;               -- 放弃 (无操作)</div><div class=\"line\">help (或 ?)               -- 列出命令</div><div class=\"line\">version                   -- 输出版本信息</div><div class=\"line\">exit (或 quit)            -- 退出调试器</div><div class=\"line\"></div><div class=\"line\">&lt;class id&gt;: 带有程序包限定符的完整类名</div><div class=\"line\">&lt;class pattern&gt;: 带有前导或尾随通配符 (&apos;*&apos;) 的类名</div><div class=\"line\">&lt;thread id&gt;: &apos;threads&apos; 命令中报告的线程编号</div><div class=\"line\">&lt;expr&gt;: Java(TM) 编程语言表达式。</div><div class=\"line\">支持大多数常见语法。</div><div class=\"line\"></div><div class=\"line\">可以将启动命令置于 &quot;jdb.ini&quot; 或 &quot;.jdbrc&quot; 中</div><div class=\"line\">位于 user.home 或 user.dir 中</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<p>上面的帮助信息说明了如何进行JDB调试，解释一下其中的几个：</p>\n<p>step: – 执行当前行 相当于Eclipse中的F5</p>\n<p>step up: – 一直执行, 直到当前方法返回到其调用方 相当于Eclipse中的F7</p>\n<p>next: – 步进一行 (步过调用) 相当于Eclipse中的F6</p>\n<p>cont: – 从断点处继续执行 相当于Eclipse中的F8</p>\n<p>此时，继续输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; stop at test.JDBTest:7</div><div class=\"line\">正在延迟断点test.JDBTest:7。</div><div class=\"line\">将在加载类后设置。</div><div class=\"line\">&gt; run</div><div class=\"line\">运行test.JDBTest</div><div class=\"line\">设置未捕获的java.lang.Throwable</div><div class=\"line\">设置延迟的未捕获的java.lang.Throwable</div><div class=\"line\">&gt;</div><div class=\"line\">VM 已启动: 设置延迟的断点test.JDBTest:7</div><div class=\"line\"></div><div class=\"line\">断点命中: &quot;线程=main&quot;, test.JDBTest.main(), 行=7 bci=0</div><div class=\"line\">7               JDBTest jdbTest = new JDBTest();</div><div class=\"line\"></div><div class=\"line\">main[1]</div></pre></td></tr></table></figure>\n<p>stop at test.JDBTest:7 表示在这个类文件的第7行处打一个断点</p>\n<p>接着，输入run，就开始进入调试步骤了。现在可以输入上面帮助中的语法来了解当前程序的执行情况了。一试便知</p>\n<p><code>注意, 若想要在调试时能够正常输出调试信息如变量值等等，需要在编译java文件时指定 -g 参数，否则无法获得其运行时的调试信息</code></p>\n<p>另外，使用list可以打印当前断点处的源代码，如果没有在启动JDB时指定源代码路径 -sourcepath ./src/ ，那么会提示没有源代码信息，无法输出。此时可以使用命令 use ./src/ 来指定源代码路径，再使用list命令时可以正常打印了。</p>\n<p>以上就是使用JDB调试本地程序的方法，具体的使用可根据实际情况参照语法说明去执行。</p>\n<h2 id=\"使用JDB进行远程调试\"><a href=\"#使用JDB进行远程调试\" class=\"headerlink\" title=\"使用JDB进行远程调试\"></a>使用JDB进行远程调试</h2><p>如果程序不是运行在本机，而是在其他机器或者现场的时候，可以使用java提供的远程调试功能。</p>\n<p>假设程序现运行在主机 192.168.101.72 这台机器上，该机器为linux环境，且只可以通过ssh作为一个普通用户连接。我们想要在自己的机器上调试运行在192.168.101.72这台机器上的程序。</p>\n<h3 id=\"启动要调试的程序\"><a href=\"#启动要调试的程序\" class=\"headerlink\" title=\"启动要调试的程序\"></a>启动要调试的程序</h3><p>在192.168.101.72这台主机上以下面的方式启动java程序：还是以JDBTest为例</p>\n<p><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest</code></p>\n<p>此时，命令行输出</p>\n<p><code>Listening for transport dt_socket at address: 8899</code></p>\n<p>并处于等待状态</p>\n<p>下面是几个参数的解释：</p>\n<p>-Xdebug 启用调试特性。 </p>\n<p>-Xrunjdwp:<sub-options> 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。下面介绍一些特定的子选项。<br>从 Java V5 开始，您可以使用 -agentlib:jdwp 选项，而不是 -Xdebug 和 -Xrunjdwp。但如果连接到 V5 以前的 VM，只能选择 -Xdebug 和 -Xrunjdwp。下面简单描述 -Xrunjdwp 子选项。</sub-options></p>\n<p>transport 这里通常使用套接字传输。但是在 Windows 平台上也可以使用共享内存传输。</p>\n<p>server 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。</p>\n<p>address 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。</p>\n<p>suspend 如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。</p>\n<h3 id=\"本机连接远程程序并启动调试\"><a href=\"#本机连接远程程序并启动调试\" class=\"headerlink\" title=\"本机连接远程程序并启动调试\"></a>本机连接远程程序并启动调试</h3><p>在本机上命令行下输入：</p>\n<p><code>jdb -connect com.sun.jdi.SocketAttach:hostname=192.168.101.72,port=8899</code></p>\n<p>然后就进入了调试界面，你可以像调试本机程序那样使用JDB的一些命令来调试了。当退出调试程序时，远程主机上的程序也就退出了。</p>\n<h2 id=\"使用Eclipse进行远程调试\"><a href=\"#使用Eclipse进行远程调试\" class=\"headerlink\" title=\"使用Eclipse进行远程调试\"></a>使用Eclipse进行远程调试</h2><p>可以使用Eclipse进行远程调试，就上上面使用JDB一样。</p>\n<h3 id=\"启动要调试的程序-1\"><a href=\"#启动要调试的程序-1\" class=\"headerlink\" title=\"启动要调试的程序\"></a>启动要调试的程序</h3><p>与JDB远程调试一样，启动远程主机上的程序：</p>\n<p><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest</code></p>\n<h3 id=\"本机启动Eclipse进行调试\"><a href=\"#本机启动Eclipse进行调试\" class=\"headerlink\" title=\"本机启动Eclipse进行调试\"></a>本机启动Eclipse进行调试</h3><p>首先要右键工程-&gt;java compiler</p>\n<img src=\"/2016/12/07/java远程调试学习/setting.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>上图中的几个选项最好全部打勾，否则调试时会出现无法打断点或者获取不到行号等问题(关于这几个选项的含义在之前的总结中有提到)</p>\n<p>接着，右键工程-&gt;Debug As-&gt;Run Configurations, 在出现的对话框中选择Remote Java Application, 右键-&gt;New, 出现如下界面：</p>\n<img src=\"/2016/12/07/java远程调试学习/remote.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>在Connect页中，选择对应的java 工程，Connection Type选择 Socket Attach，然后填写远程主机的ip和端口，这里应该填写192.168.101.72和8899。<br>在Source页中可以添加源代码，如用到的第三方jar的源代码或者引用的工程，调试时就可以进入到这部分代码查看。在Common页可以设置编码的配置。</p>\n<p>接下来点击Debug按钮，就可以愉快的在本机调试远程程序了，就像调试本地程序那样。只不过可能有一点一点慢，不过比打Log的方式要好很多了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-eclipse-javadebug/\" target=\"_blank\" rel=\"external\">使用 Eclipse 远程调试 Java 应用程序</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/java/joy-jdb/\" target=\"_blank\" rel=\"external\">JDB的简单使用</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/\" target=\"_blank\" rel=\"external\">深入 Java 调试体系: 第 1 部分，JPDA 体系概览 </a></p>\n","excerpt":"","more":"<blockquote>\n<p>集群前后台协议需要做一些修改，我负责jdbc这边的修改。按照协议内容修改完代码之后却面临一个测试的问题：修改后的后台又部署在北京，但北京并不是所有的机器都对天津这边开放，只给提供一台机器A，就是集群的服务器。<br>这样的话,就无法创建节点的连接，测试没有办法进行。</p>\n<p>一开始用了最简单的办法，把打好的jar包通过远程ssh放到A上面，再通过ssh去跑用例，打印结果看看正确与否。但是这样的效率真的太低了，每做一次修改都要打包、部署、运行、分析log。于是借这个机会学习一下java程序的远程调试。以下为总结。</p>\n</blockquote>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><p>JDPA: java平台调试架构</p>\n<p>JVMTI: JVM端调试接口</p>\n<p>JDI: java端调试接口</p>\n<p>JDWP: java调试网络协议</p>\n<img src=\"/2016/12/07/java远程调试学习/jdpa.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>JPDA 定义了一套如何开发调试工具的接口和规范。</p>\n<p>JPDA 由三个独立的模块 JVMTI、JDWP、JDI 组成。</p>\n<p>调试者通过 JDI 发送接受调试命令。</p>\n<p>JDWP 定义调试者和被调试者交流数据的格式。</p>\n<p>JVMTI 可以控制当前虚拟机运行状态。</p>\n<p>上图中的前端工具就是我们要用到的调试工具。如JDB、Eclipse等等。这些工具实现了JDI接口，通过这些工具我们可以达到在命令行或者图形界面下调试的目的。</p>\n<p>关于这部分，只是简单的了解一下概念，更多的关于JDPA的介绍：<a href=\"http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?search_by=%E6%B7%B1%E5%85%A5+Java+%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB\">JDPA体系</a></p>\n<h2 id=\"使用JDB进行本地调试\"><a href=\"#使用JDB进行本地调试\" class=\"headerlink\" title=\"使用JDB进行本地调试\"></a>使用JDB进行本地调试</h2><p>JDB 是jdk自带的一个调试工具，用于命令行下调试java程序</p>\n<p>jdb.exe就位于jdk安装目录的bin目录下，安装好jdk并设置好环境变量之后就可以愉快的使用jdb了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:\\Users\\kyu&gt;jdb -help</div><div class=\"line\">用法: jdb &lt;options&gt; &lt;class&gt; &lt;arguments&gt;</div><div class=\"line\"></div><div class=\"line\">其中, 选项包括:</div><div class=\"line\">    -help             输出此消息并退出</div><div class=\"line\">    -sourcepath &lt;由 &quot;;&quot; 分隔的目录&gt;</div><div class=\"line\">                      要在其中查找源文件的目录</div><div class=\"line\">    -attach &lt;address&gt;</div><div class=\"line\">                      使用标准连接器附加到指定地址处正在运行的 VM</div><div class=\"line\">    -listen &lt;address&gt;</div><div class=\"line\">                      等待正在运行的 VM 使用标准连接器在指定地址处连接</div><div class=\"line\">    -listenany</div><div class=\"line\">                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接</div><div class=\"line\">    -launch</div><div class=\"line\">                      立即启动 VM 而不是等待 &apos;run&apos; 命令</div><div class=\"line\">    -listconnectors   列出此 VM 中的可用连接器</div><div class=\"line\">    -connect &lt;connector-name&gt;:&lt;name1&gt;=&lt;value1&gt;,...</div><div class=\"line\">                      使用所列参数值通过指定的连接器连接到目标 VM</div><div class=\"line\">    -dbgtrace [flags] 输出信息供调试jdb</div><div class=\"line\">    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序</div><div class=\"line\">    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序</div><div class=\"line\"></div><div class=\"line\">转发到被调试进程的选项:</div><div class=\"line\">    -v -verbose[:class|gc|jni]</div><div class=\"line\">                      启用详细模式</div><div class=\"line\">    -D&lt;name&gt;=&lt;value&gt;  设置系统属性</div><div class=\"line\">    -classpath &lt;由 &quot;;&quot; 分隔的目录&gt;</div><div class=\"line\">                      列出要在其中查找类的目录</div><div class=\"line\">    -X&lt;option&gt;        非标准目标 VM 选项</div><div class=\"line\"></div><div class=\"line\">&lt;class&gt; 是要开始调试的类的名称</div><div class=\"line\">&lt;arguments&gt; 是传递到 &lt;class&gt; 的 main() 方法的参数</div><div class=\"line\"></div><div class=\"line\">要获得命令的帮助, 请在jdb提示下键入 &apos;help&apos;</div></pre></td></tr></table></figure>\n<p>上面是启动JDB的语法说明。</p>\n<p>现假设运行程序的工程目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">JDBTest</div><div class=\"line\">  |----bin(编译生成的class文件)</div><div class=\"line\">  |     |----*.class</div><div class=\"line\">  |----src(源文件)</div><div class=\"line\">  |     |----*.java</div><div class=\"line\">  |----lib(依赖的第三方jar)</div><div class=\"line\">  |     |----*.jar</div></pre></td></tr></table></figure>\n<p>开始启动JDB调试：</p>\n<p>Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</p>\n<p><code>注意，如果有多个文件，windows下使用 &quot;;&quot; 分隔每个文件或目录，Linux下使用 &quot;:&quot; 分隔每个文件或目录</code></p>\n<p><code>-classpath</code> 指定了类路径，<code>-sourcepath</code> 指定了源文件的路径</p>\n<p>回车，出现如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</div><div class=\"line\">正在初始化jdb...</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<p>此时，JDB调试器等待用户的输入，输入<code>help</code>，出现如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div></pre></td><td class=\"code\"><pre><div class=\"line\">Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</div><div class=\"line\">正在初始化jdb...</div><div class=\"line\">&gt; help</div><div class=\"line\">** 命令列表 **</div><div class=\"line\">connectors                -- 列出此 VM 中可用的连接器和传输</div><div class=\"line\"></div><div class=\"line\">run [class [args]]        -- 开始执行应用程序的主类</div><div class=\"line\"></div><div class=\"line\">threads [threadgroup]     -- 列出线程</div><div class=\"line\">thread &lt;thread id&gt;        -- 设置默认线程</div><div class=\"line\">suspend [thread id(s)]    -- 挂起线程 (默认值: all)</div><div class=\"line\">resume [thread id(s)]     -- 恢复线程 (默认值: all)</div><div class=\"line\">where [&lt;thread id&gt; | all] -- 转储线程的堆栈</div><div class=\"line\">wherei [&lt;thread id&gt; | all]-- 转储线程的堆栈, 以及 pc 信息</div><div class=\"line\">up [n frames]             -- 上移线程的堆栈</div><div class=\"line\">down [n frames]           -- 下移线程的堆栈</div><div class=\"line\">kill &lt;thread id&gt; &lt;expr&gt;   -- 终止具有给定的异常错误对象的线程</div><div class=\"line\">interrupt &lt;thread id&gt;     -- 中断线程</div><div class=\"line\"></div><div class=\"line\">print &lt;expr&gt;              -- 输出表达式的值</div><div class=\"line\">dump &lt;expr&gt;               -- 输出所有对象信息</div><div class=\"line\">eval &lt;expr&gt;               -- 对表达式求值 (与 print 相同)</div><div class=\"line\">set &lt;lvalue&gt; = &lt;expr&gt;     -- 向字段/变量/数组元素分配新值</div><div class=\"line\">locals                    -- 输出当前堆栈帧中的所有本地变量</div><div class=\"line\"></div><div class=\"line\">classes                   -- 列出当前已知的类</div><div class=\"line\">class &lt;class id&gt;          -- 显示已命名类的详细资料</div><div class=\"line\">methods &lt;class id&gt;        -- 列出类的方法</div><div class=\"line\">fields &lt;class id&gt;         -- 列出类的字段</div><div class=\"line\"></div><div class=\"line\">threadgroups              -- 列出线程组</div><div class=\"line\">threadgroup &lt;name&gt;        -- 设置当前线程组</div><div class=\"line\"></div><div class=\"line\">stop in &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]</div><div class=\"line\">                          -- 在方法中设置断点</div><div class=\"line\">stop at &lt;class id&gt;:&lt;line&gt; -- 在行中设置断点</div><div class=\"line\">clear &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]</div><div class=\"line\">                          -- 清除方法中的断点</div><div class=\"line\">clear &lt;class id&gt;:&lt;line&gt;   -- 清除行中的断点</div><div class=\"line\">clear                     -- 列出断点</div><div class=\"line\">catch [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;</div><div class=\"line\">                          -- 出现指定的异常错误时中断</div><div class=\"line\">ignore [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;</div><div class=\"line\">                          -- 对于指定的异常错误, 取消 &apos;catch&apos;</div><div class=\"line\">watch [access|all] &lt;class id&gt;.&lt;field name&gt;</div><div class=\"line\">                          -- 监视对字段的访问/修改</div><div class=\"line\">unwatch [access|all] &lt;class id&gt;.&lt;field name&gt;</div><div class=\"line\">                          -- 停止监视对字段的访问/修改</div><div class=\"line\">trace [go] methods [thread]</div><div class=\"line\">                          -- 跟踪方法进入和退出。</div><div class=\"line\">                          -- 除非指定 &apos;go&apos;, 否则挂起所有线程</div><div class=\"line\">trace [go] method exit | exits [thread]</div><div class=\"line\">                          -- 跟踪当前方法的退出, 或者所有方法的退出</div><div class=\"line\">                          -- 除非指定 &apos;go&apos;, 否则挂起所有线程</div><div class=\"line\">untrace [methods]         -- 停止跟踪方法进入和/或退出</div><div class=\"line\">step                      -- 执行当前行</div><div class=\"line\">step up                   -- 一直执行, 直到当前方法返回到其调用方</div><div class=\"line\">stepi                     -- 执行当前指令</div><div class=\"line\">next                      -- 步进一行 (步过调用)</div><div class=\"line\">cont                      -- 从断点处继续执行</div><div class=\"line\"></div><div class=\"line\">list [line number|method] -- 输出源代码</div><div class=\"line\">use (或 sourcepath) [source file path]</div><div class=\"line\">                          -- 显示或更改源路径</div><div class=\"line\">exclude [&lt;class pattern&gt;, ... | &quot;none&quot;]</div><div class=\"line\">                          -- 对于指定的类, 不报告步骤或方法事件</div><div class=\"line\">classpath                 -- 从目标 VM 输出类路径信息</div><div class=\"line\"></div><div class=\"line\">monitor &lt;command&gt;         -- 每次程序停止时执行命令</div><div class=\"line\">monitor                   -- 列出监视器</div><div class=\"line\">unmonitor &lt;monitor#&gt;      -- 删除监视器</div><div class=\"line\">read &lt;filename&gt;           -- 读取并执行命令文件</div><div class=\"line\"></div><div class=\"line\">lock &lt;expr&gt;               -- 输出对象的锁信息</div><div class=\"line\">threadlocks [thread id]   -- 输出线程的锁信息</div><div class=\"line\"></div><div class=\"line\">pop                       -- 通过当前帧出栈, 且包含当前帧</div><div class=\"line\">reenter                   -- 与 pop 相同, 但重新进入当前帧</div><div class=\"line\">redefine &lt;class id&gt; &lt;class file name&gt;</div><div class=\"line\">                          -- 重新定义类的代码</div><div class=\"line\"></div><div class=\"line\">disablegc &lt;expr&gt;          -- 禁止对象的垃圾收集</div><div class=\"line\">enablegc &lt;expr&gt;           -- 允许对象的垃圾收集</div><div class=\"line\"></div><div class=\"line\">!!                        -- 重复执行最后一个命令</div><div class=\"line\">&lt;n&gt; &lt;command&gt;             -- 将命令重复执行 n 次</div><div class=\"line\"># &lt;command&gt;               -- 放弃 (无操作)</div><div class=\"line\">help (或 ?)               -- 列出命令</div><div class=\"line\">version                   -- 输出版本信息</div><div class=\"line\">exit (或 quit)            -- 退出调试器</div><div class=\"line\"></div><div class=\"line\">&lt;class id&gt;: 带有程序包限定符的完整类名</div><div class=\"line\">&lt;class pattern&gt;: 带有前导或尾随通配符 (&apos;*&apos;) 的类名</div><div class=\"line\">&lt;thread id&gt;: &apos;threads&apos; 命令中报告的线程编号</div><div class=\"line\">&lt;expr&gt;: Java(TM) 编程语言表达式。</div><div class=\"line\">支持大多数常见语法。</div><div class=\"line\"></div><div class=\"line\">可以将启动命令置于 &quot;jdb.ini&quot; 或 &quot;.jdbrc&quot; 中</div><div class=\"line\">位于 user.home 或 user.dir 中</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<p>上面的帮助信息说明了如何进行JDB调试，解释一下其中的几个：</p>\n<p>step: – 执行当前行 相当于Eclipse中的F5</p>\n<p>step up: – 一直执行, 直到当前方法返回到其调用方 相当于Eclipse中的F7</p>\n<p>next: – 步进一行 (步过调用) 相当于Eclipse中的F6</p>\n<p>cont: – 从断点处继续执行 相当于Eclipse中的F8</p>\n<p>此时，继续输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; stop at test.JDBTest:7</div><div class=\"line\">正在延迟断点test.JDBTest:7。</div><div class=\"line\">将在加载类后设置。</div><div class=\"line\">&gt; run</div><div class=\"line\">运行test.JDBTest</div><div class=\"line\">设置未捕获的java.lang.Throwable</div><div class=\"line\">设置延迟的未捕获的java.lang.Throwable</div><div class=\"line\">&gt;</div><div class=\"line\">VM 已启动: 设置延迟的断点test.JDBTest:7</div><div class=\"line\"></div><div class=\"line\">断点命中: &quot;线程=main&quot;, test.JDBTest.main(), 行=7 bci=0</div><div class=\"line\">7               JDBTest jdbTest = new JDBTest();</div><div class=\"line\"></div><div class=\"line\">main[1]</div></pre></td></tr></table></figure>\n<p>stop at test.JDBTest:7 表示在这个类文件的第7行处打一个断点</p>\n<p>接着，输入run，就开始进入调试步骤了。现在可以输入上面帮助中的语法来了解当前程序的执行情况了。一试便知</p>\n<p><code>注意, 若想要在调试时能够正常输出调试信息如变量值等等，需要在编译java文件时指定 -g 参数，否则无法获得其运行时的调试信息</code></p>\n<p>另外，使用list可以打印当前断点处的源代码，如果没有在启动JDB时指定源代码路径 -sourcepath ./src/ ，那么会提示没有源代码信息，无法输出。此时可以使用命令 use ./src/ 来指定源代码路径，再使用list命令时可以正常打印了。</p>\n<p>以上就是使用JDB调试本地程序的方法，具体的使用可根据实际情况参照语法说明去执行。</p>\n<h2 id=\"使用JDB进行远程调试\"><a href=\"#使用JDB进行远程调试\" class=\"headerlink\" title=\"使用JDB进行远程调试\"></a>使用JDB进行远程调试</h2><p>如果程序不是运行在本机，而是在其他机器或者现场的时候，可以使用java提供的远程调试功能。</p>\n<p>假设程序现运行在主机 192.168.101.72 这台机器上，该机器为linux环境，且只可以通过ssh作为一个普通用户连接。我们想要在自己的机器上调试运行在192.168.101.72这台机器上的程序。</p>\n<h3 id=\"启动要调试的程序\"><a href=\"#启动要调试的程序\" class=\"headerlink\" title=\"启动要调试的程序\"></a>启动要调试的程序</h3><p>在192.168.101.72这台主机上以下面的方式启动java程序：还是以JDBTest为例</p>\n<p><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest</code></p>\n<p>此时，命令行输出</p>\n<p><code>Listening for transport dt_socket at address: 8899</code></p>\n<p>并处于等待状态</p>\n<p>下面是几个参数的解释：</p>\n<p>-Xdebug 启用调试特性。 </p>\n<p>-Xrunjdwp:<sub-options> 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。下面介绍一些特定的子选项。<br>从 Java V5 开始，您可以使用 -agentlib:jdwp 选项，而不是 -Xdebug 和 -Xrunjdwp。但如果连接到 V5 以前的 VM，只能选择 -Xdebug 和 -Xrunjdwp。下面简单描述 -Xrunjdwp 子选项。</p>\n<p>transport 这里通常使用套接字传输。但是在 Windows 平台上也可以使用共享内存传输。</p>\n<p>server 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。</p>\n<p>address 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。</p>\n<p>suspend 如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。</p>\n<h3 id=\"本机连接远程程序并启动调试\"><a href=\"#本机连接远程程序并启动调试\" class=\"headerlink\" title=\"本机连接远程程序并启动调试\"></a>本机连接远程程序并启动调试</h3><p>在本机上命令行下输入：</p>\n<p><code>jdb -connect com.sun.jdi.SocketAttach:hostname=192.168.101.72,port=8899</code></p>\n<p>然后就进入了调试界面，你可以像调试本机程序那样使用JDB的一些命令来调试了。当退出调试程序时，远程主机上的程序也就退出了。</p>\n<h2 id=\"使用Eclipse进行远程调试\"><a href=\"#使用Eclipse进行远程调试\" class=\"headerlink\" title=\"使用Eclipse进行远程调试\"></a>使用Eclipse进行远程调试</h2><p>可以使用Eclipse进行远程调试，就上上面使用JDB一样。</p>\n<h3 id=\"启动要调试的程序-1\"><a href=\"#启动要调试的程序-1\" class=\"headerlink\" title=\"启动要调试的程序\"></a>启动要调试的程序</h3><p>与JDB远程调试一样，启动远程主机上的程序：</p>\n<p><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest</code></p>\n<h3 id=\"本机启动Eclipse进行调试\"><a href=\"#本机启动Eclipse进行调试\" class=\"headerlink\" title=\"本机启动Eclipse进行调试\"></a>本机启动Eclipse进行调试</h3><p>首先要右键工程-&gt;java compiler</p>\n<img src=\"/2016/12/07/java远程调试学习/setting.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>上图中的几个选项最好全部打勾，否则调试时会出现无法打断点或者获取不到行号等问题(关于这几个选项的含义在之前的总结中有提到)</p>\n<p>接着，右键工程-&gt;Debug As-&gt;Run Configurations, 在出现的对话框中选择Remote Java Application, 右键-&gt;New, 出现如下界面：</p>\n<img src=\"/2016/12/07/java远程调试学习/remote.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>在Connect页中，选择对应的java 工程，Connection Type选择 Socket Attach，然后填写远程主机的ip和端口，这里应该填写192.168.101.72和8899。<br>在Source页中可以添加源代码，如用到的第三方jar的源代码或者引用的工程，调试时就可以进入到这部分代码查看。在Common页可以设置编码的配置。</p>\n<p>接下来点击Debug按钮，就可以愉快的在本机调试远程程序了，就像调试本地程序那样。只不过可能有一点一点慢，不过比打Log的方式要好很多了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-eclipse-javadebug/\">使用 Eclipse 远程调试 Java 应用程序</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/java/joy-jdb/\">JDB的简单使用</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/\">深入 Java 调试体系: 第 1 部分，JPDA 体系概览 </a></p>\n"},{"layout":"post","title":"notify 问题","date":"2015-12-21T04:48:55.000Z","_content":"\n今天遇到了这么个情况：\n有线程若干，我需要他们按顺序执行。\n代码大概长这样：\n\n```\nclass SyncTag {\n\tpublic int threadNO;\n\tpublic SyncTag() {\n\t    threadNO = 0;\n\t}\n}\nclass ThreadA extend Thread{\n\tSyncTag syncTag;\n\tint scriptNO;\n\tThreadA(SyncTag syncTag,int scriptNO){\n\t\t\tthis.syncTag=syncTag;\n\t\t\tthis.scriptNO=scriptNO;\n\t}\n\tpublic void Run(){\n\t\t\tsynchronized (syncTag) {\n                if (syncTag.threadNO != scriptNO) {\n                        try {\n                                syncTag.wait();\n                        } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                        }\n                }\n                dosomething();\n                syncTag.threadNO++;\n                syncTag.notifyAll();\n\t\t\t}\n\t}\n}\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t    SyncTag syncTag=new SyncTag();\n\t\t\tfor(int i=0;i<10;++i){\n\t\t\t\tThreadA t=new ThreadA(syncTag,i);\n\t\t\t\tt.start();\n\t\t\t}\n\t}\n}\n```\n\n结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。\n研究一番，发现是 notify 与notifyAll 在捣鬼。\n当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。\n其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。\n\t\t \n当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，\n剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，\n没抢到的老实等着。\n\t\t \n这就是notify 与 notifyAll两者的区别.\n\t\t \n那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。\n原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合\nsyncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，\n如果不符合，就继续wait.符合则执行。\n很简单，将 \n\n```java\nif (syncTag.threadNO != scriptNO) {\n        try {\n                syncTag.wait();\n            } catch (InterruptedException e) {\n                                    e.printStackTrace();\n            }\n}\n```\n\n这部分代码 改为： \n\n```java\nwhile (syncTag.threadNO != scriptNO) {\n\t\ttry {\n\t\t\t\tsyncTag.wait();\n\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n这个问题就解决了。\n\n所以，应该记住这样一个原则：**永远在循环（loop）里调用 wait 和 notify，不是在 If 语句**。\n\t \n## **延伸**：\n假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：\n设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO\n这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们\n中的一个。于是陷入死锁，无尽的等待。\n\t\t \n所以，具体使用notify还是notifyAll 就得具体情况具体分析了。","source":"_posts/notify问题.md","raw":"---\nlayout: post\ntitle:  \"notify 问题\"\ndate:   2015-12-21 12:48:55\ncategories: 编程\ntags:\n- java\n- 多线程 \n---\n\n今天遇到了这么个情况：\n有线程若干，我需要他们按顺序执行。\n代码大概长这样：\n\n```\nclass SyncTag {\n\tpublic int threadNO;\n\tpublic SyncTag() {\n\t    threadNO = 0;\n\t}\n}\nclass ThreadA extend Thread{\n\tSyncTag syncTag;\n\tint scriptNO;\n\tThreadA(SyncTag syncTag,int scriptNO){\n\t\t\tthis.syncTag=syncTag;\n\t\t\tthis.scriptNO=scriptNO;\n\t}\n\tpublic void Run(){\n\t\t\tsynchronized (syncTag) {\n                if (syncTag.threadNO != scriptNO) {\n                        try {\n                                syncTag.wait();\n                        } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                        }\n                }\n                dosomething();\n                syncTag.threadNO++;\n                syncTag.notifyAll();\n\t\t\t}\n\t}\n}\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t    SyncTag syncTag=new SyncTag();\n\t\t\tfor(int i=0;i<10;++i){\n\t\t\t\tThreadA t=new ThreadA(syncTag,i);\n\t\t\t\tt.start();\n\t\t\t}\n\t}\n}\n```\n\n结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。\n研究一番，发现是 notify 与notifyAll 在捣鬼。\n当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。\n其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。\n\t\t \n当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，\n剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，\n没抢到的老实等着。\n\t\t \n这就是notify 与 notifyAll两者的区别.\n\t\t \n那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。\n原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合\nsyncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，\n如果不符合，就继续wait.符合则执行。\n很简单，将 \n\n```java\nif (syncTag.threadNO != scriptNO) {\n        try {\n                syncTag.wait();\n            } catch (InterruptedException e) {\n                                    e.printStackTrace();\n            }\n}\n```\n\n这部分代码 改为： \n\n```java\nwhile (syncTag.threadNO != scriptNO) {\n\t\ttry {\n\t\t\t\tsyncTag.wait();\n\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n这个问题就解决了。\n\n所以，应该记住这样一个原则：**永远在循环（loop）里调用 wait 和 notify，不是在 If 语句**。\n\t \n## **延伸**：\n假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：\n设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO\n这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们\n中的一个。于是陷入死锁，无尽的等待。\n\t\t \n所以，具体使用notify还是notifyAll 就得具体情况具体分析了。","slug":"notify问题","published":1,"updated":"2016-11-30T14:32:49.909Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj59001fdigcf8130vsr","content":"<p>今天遇到了这么个情况：<br>有线程若干，我需要他们按顺序执行。<br>代码大概长这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SyncTag &#123;</div><div class=\"line\">\tpublic int threadNO;</div><div class=\"line\">\tpublic SyncTag() &#123;</div><div class=\"line\">\t    threadNO = 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class ThreadA extend Thread&#123;</div><div class=\"line\">\tSyncTag syncTag;</div><div class=\"line\">\tint scriptNO;</div><div class=\"line\">\tThreadA(SyncTag syncTag,int scriptNO)&#123;</div><div class=\"line\">\t\t\tthis.syncTag=syncTag;</div><div class=\"line\">\t\t\tthis.scriptNO=scriptNO;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void Run()&#123;</div><div class=\"line\">\t\t\tsynchronized (syncTag) &#123;</div><div class=\"line\">                if (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">                        try &#123;</div><div class=\"line\">                                syncTag.wait();</div><div class=\"line\">                        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                dosomething();</div><div class=\"line\">                syncTag.threadNO++;</div><div class=\"line\">                syncTag.notifyAll();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">public class Test&#123;</div><div class=\"line\">\tpublic static void main(String args[])&#123;</div><div class=\"line\">\t\t    SyncTag syncTag=new SyncTag();</div><div class=\"line\">\t\t\tfor(int i=0;i&lt;10;++i)&#123;</div><div class=\"line\">\t\t\t\tThreadA t=new ThreadA(syncTag,i);</div><div class=\"line\">\t\t\t\tt.start();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。<br>研究一番，发现是 notify 与notifyAll 在捣鬼。<br>当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。<br>其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。</p>\n<p>当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，<br>剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，<br>没抢到的老实等着。</p>\n<p>这就是notify 与 notifyAll两者的区别.</p>\n<p>那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。<br>原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合<br>syncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，<br>如果不符合，就继续wait.符合则执行。<br>很简单，将 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                syncTag.wait();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这部分代码 改为： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tsyncTag.wait();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个问题就解决了。</p>\n<p>所以，应该记住这样一个原则：<strong>永远在循环（loop）里调用 wait 和 notify，不是在 If 语句</strong>。</p>\n<h2 id=\"延伸：\"><a href=\"#延伸：\" class=\"headerlink\" title=\"延伸：\"></a><strong>延伸</strong>：</h2><p>假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：<br>设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO<br>这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们<br>中的一个。于是陷入死锁，无尽的等待。</p>\n<p>所以，具体使用notify还是notifyAll 就得具体情况具体分析了。</p>\n","excerpt":"","more":"<p>今天遇到了这么个情况：<br>有线程若干，我需要他们按顺序执行。<br>代码大概长这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SyncTag &#123;</div><div class=\"line\">\tpublic int threadNO;</div><div class=\"line\">\tpublic SyncTag() &#123;</div><div class=\"line\">\t    threadNO = 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class ThreadA extend Thread&#123;</div><div class=\"line\">\tSyncTag syncTag;</div><div class=\"line\">\tint scriptNO;</div><div class=\"line\">\tThreadA(SyncTag syncTag,int scriptNO)&#123;</div><div class=\"line\">\t\t\tthis.syncTag=syncTag;</div><div class=\"line\">\t\t\tthis.scriptNO=scriptNO;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void Run()&#123;</div><div class=\"line\">\t\t\tsynchronized (syncTag) &#123;</div><div class=\"line\">                if (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">                        try &#123;</div><div class=\"line\">                                syncTag.wait();</div><div class=\"line\">                        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                dosomething();</div><div class=\"line\">                syncTag.threadNO++;</div><div class=\"line\">                syncTag.notifyAll();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">public class Test&#123;</div><div class=\"line\">\tpublic static void main(String args[])&#123;</div><div class=\"line\">\t\t    SyncTag syncTag=new SyncTag();</div><div class=\"line\">\t\t\tfor(int i=0;i&lt;10;++i)&#123;</div><div class=\"line\">\t\t\t\tThreadA t=new ThreadA(syncTag,i);</div><div class=\"line\">\t\t\t\tt.start();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。<br>研究一番，发现是 notify 与notifyAll 在捣鬼。<br>当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。<br>其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。</p>\n<p>当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，<br>剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，<br>没抢到的老实等着。</p>\n<p>这就是notify 与 notifyAll两者的区别.</p>\n<p>那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。<br>原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合<br>syncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，<br>如果不符合，就继续wait.符合则执行。<br>很简单，将 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                syncTag.wait();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这部分代码 改为： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tsyncTag.wait();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个问题就解决了。</p>\n<p>所以，应该记住这样一个原则：<strong>永远在循环（loop）里调用 wait 和 notify，不是在 If 语句</strong>。</p>\n<h2 id=\"延伸：\"><a href=\"#延伸：\" class=\"headerlink\" title=\"延伸：\"></a><strong>延伸</strong>：</h2><p>假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：<br>设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO<br>这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们<br>中的一个。于是陷入死锁，无尽的等待。</p>\n<p>所以，具体使用notify还是notifyAll 就得具体情况具体分析了。</p>\n"},{"layout":"post","title":"Markdown","date":"2016-03-03T14:10:55.000Z","_content":"\n>[Markdown][markdown-com] 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。\n\n# 常用语法\n \n makedown 语法  \n\n---\n\n## 代码\n\n\\`\\`\\`\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\\`\\`\\`\n\nUse the \\`printf()` function.\n\n---\n\n\n## 标题\n\n\\# 标题1\n\n\\## 标题2\n\n\\### 标题3\n\n\\#### 标题4\n\n\\##### 标题5\n\n\\###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n\n2. 有序列表2\n\n\n\\- 无序列表1\n\n\\- 无序列表2\n\n\\* 无序列表3\n\n\\+ 无序列表4\n\n---\n\n## 链接\n\n\\[谷歌](http://www.google.com)\n\n这是一个 \\[例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 \\[例子] \\[id] 参考链接.\n\n\\[id]: http://google.com/ \"google\"\n\n\n自动链接\n\n```\n<http://example.com/>\n```\n\n---\n\n## 图片\n\n行内链接：\n\\!\\[](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n\\!\\[img]\n\n\\[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n```\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n```\n---\n\n## 引用\n\n\\> 引用\n\n\\>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n\\*这里是斜体\\*\n\n\\*\\*这里是粗体\\*\\*\n\n\\*\\*\\*这里是粗斜体\\*\\*\\*\n\n---\n\n## 表格\n\ndog \\| bird \\| cat\n\n----\\|------\\|----\n\nfoo \\| foo  \\| foo\n\nbar \\| bar  \\| bar\n\nbaz \\| baz  \\| baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\\\   反斜线\n  \n   \\\\`   反引号\n   \n   \\\\*   星号\n   \n   \\\\_   底线\n   \n   \\\\{}  花括号\n   \n   \\\\[]  方括号\n   \n   \\\\()  括弧\n   \n   \\\\#   井字号\n   \n   \\\\+   加号\n   \n   \\\\-   减号\n   \n   \\\\.   英文句点\n   \n   \\\\!   惊叹号\n\n---\n\n## 删除线\n\n\\~~删除这里的内容~~\n\n---\n\n\n\n\n# 效果\n\nmakedown 语法  \n---\n\n## 代码\n\n```\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\n```\n\nUse the `printf()` function.\n\n---\n\n\n## 标题\n\n# 标题1\n\n## 标题2\n\n### 标题3\n\n#### 标题4\n\n##### 标题5\n\n###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n2. 有序列表2\n\n\n- 无序列表1\n- 无序列表2\n* 无序列表3\n+ 无序列表4\n\n---\n\n## 链接\n\n[谷歌](http://www.google.com)\n\n这是一个 [例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 [例子] [id] 参考链接.\n[id]: http://google.com/  \"google\"\n\n\n自动链接\n<http://example.com/>\n\n---\n\n## 图片\n\n行内链接：\n![](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n![img]\n\n[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n\n---\n\n## 引用\n\n> 引用\n\n>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n*这里是斜体*\n\n**这里是粗体**\n\n***这里是粗斜体***\n\n---\n\n## 表格\n\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\   反斜线\n  \n   \\`   反引号\n   \n   \\*   星号\n   \n   \\_   底线\n   \n   \\{}  花括号\n   \n   \\[]  方括号\n   \n   \\()  括弧\n   \n   \\#   井字号\n   \n   \\+   加号\n   \n   \\-   减号\n   \n   \\.   英文句点\n   \n   \\!   惊叹号\n\n---\n\n## 删除线\n\n~~删除这里的内容~~\n\n---\n\n## 一些参考\n\n[Markdown 语法说明 (简体中文版)](http://www.markdown.cn/)\n\n[Markdown 维基百科 ](https://zh.wikipedia.org/wiki/Markdown)\n\n---\n\n[markdown-com]:      http://wowubuntu.com/markdown/\n","source":"_posts/markdown.md","raw":"---\nlayout: post\ntitle:  \"Markdown\"\ndate:   2016-03-03 22:10:55\ncategories: 工具\ntags: \n- markdown\n---\n\n>[Markdown][markdown-com] 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。\n\n# 常用语法\n \n makedown 语法  \n\n---\n\n## 代码\n\n\\`\\`\\`\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\\`\\`\\`\n\nUse the \\`printf()` function.\n\n---\n\n\n## 标题\n\n\\# 标题1\n\n\\## 标题2\n\n\\### 标题3\n\n\\#### 标题4\n\n\\##### 标题5\n\n\\###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n\n2. 有序列表2\n\n\n\\- 无序列表1\n\n\\- 无序列表2\n\n\\* 无序列表3\n\n\\+ 无序列表4\n\n---\n\n## 链接\n\n\\[谷歌](http://www.google.com)\n\n这是一个 \\[例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 \\[例子] \\[id] 参考链接.\n\n\\[id]: http://google.com/ \"google\"\n\n\n自动链接\n\n```\n<http://example.com/>\n```\n\n---\n\n## 图片\n\n行内链接：\n\\!\\[](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n\\!\\[img]\n\n\\[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n```\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n```\n---\n\n## 引用\n\n\\> 引用\n\n\\>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n\\*这里是斜体\\*\n\n\\*\\*这里是粗体\\*\\*\n\n\\*\\*\\*这里是粗斜体\\*\\*\\*\n\n---\n\n## 表格\n\ndog \\| bird \\| cat\n\n----\\|------\\|----\n\nfoo \\| foo  \\| foo\n\nbar \\| bar  \\| bar\n\nbaz \\| baz  \\| baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\\\   反斜线\n  \n   \\\\`   反引号\n   \n   \\\\*   星号\n   \n   \\\\_   底线\n   \n   \\\\{}  花括号\n   \n   \\\\[]  方括号\n   \n   \\\\()  括弧\n   \n   \\\\#   井字号\n   \n   \\\\+   加号\n   \n   \\\\-   减号\n   \n   \\\\.   英文句点\n   \n   \\\\!   惊叹号\n\n---\n\n## 删除线\n\n\\~~删除这里的内容~~\n\n---\n\n\n\n\n# 效果\n\nmakedown 语法  \n---\n\n## 代码\n\n```\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\n```\n\nUse the `printf()` function.\n\n---\n\n\n## 标题\n\n# 标题1\n\n## 标题2\n\n### 标题3\n\n#### 标题4\n\n##### 标题5\n\n###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n2. 有序列表2\n\n\n- 无序列表1\n- 无序列表2\n* 无序列表3\n+ 无序列表4\n\n---\n\n## 链接\n\n[谷歌](http://www.google.com)\n\n这是一个 [例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 [例子] [id] 参考链接.\n[id]: http://google.com/  \"google\"\n\n\n自动链接\n<http://example.com/>\n\n---\n\n## 图片\n\n行内链接：\n![](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n![img]\n\n[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n\n---\n\n## 引用\n\n> 引用\n\n>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n*这里是斜体*\n\n**这里是粗体**\n\n***这里是粗斜体***\n\n---\n\n## 表格\n\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\   反斜线\n  \n   \\`   反引号\n   \n   \\*   星号\n   \n   \\_   底线\n   \n   \\{}  花括号\n   \n   \\[]  方括号\n   \n   \\()  括弧\n   \n   \\#   井字号\n   \n   \\+   加号\n   \n   \\-   减号\n   \n   \\.   英文句点\n   \n   \\!   惊叹号\n\n---\n\n## 删除线\n\n~~删除这里的内容~~\n\n---\n\n## 一些参考\n\n[Markdown 语法说明 (简体中文版)](http://www.markdown.cn/)\n\n[Markdown 维基百科 ](https://zh.wikipedia.org/wiki/Markdown)\n\n---\n\n[markdown-com]:      http://wowubuntu.com/markdown/\n","slug":"markdown","published":1,"updated":"2016-11-30T14:32:49.909Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj5f001idigcy84b84yj","content":"<blockquote>\n<p><a href=\"http://wowubuntu.com/markdown/\" target=\"_blank\" rel=\"external\">Markdown</a> 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>\n</blockquote>\n<p> 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。</p>\n<h1 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h1><p> makedown 语法  </p>\n<hr>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>```<br>public void main(String args[]){<br>    System.out.print(“Hello World”);<br>}<br>```</p>\n<p>Use the `printf()` function.</p>\n<hr>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p># 标题1</p>\n<p>## 标题2</p>\n<p>### 标题3</p>\n<p>#### 标题4</p>\n<p>##### 标题5</p>\n<p>###### 标题6</p>\n<hr>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li><p>有序列表1</p>\n</li>\n<li><p>有序列表2</p>\n</li>\n</ol>\n<p>- 无序列表1</p>\n<p>- 无序列表2</p>\n<p>* 无序列表3</p>\n<p>+ 无序列表4</p>\n<hr>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>[谷歌](<a href=\"http://www.google.com\" target=\"_blank\" rel=\"external\">http://www.google.com</a>)</p>\n<p>这是一个 [例子](<a href=\"http://google.com/\" target=\"_blank\" rel=\"external\">http://google.com/</a> “google”) 行内链接.</p>\n<p>这是一个 [例子] [id] 参考链接.</p>\n<p>[id]: <a href=\"http://google.com/\" target=\"_blank\" rel=\"external\">http://google.com/</a> “google”</p>\n<p>自动链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;http://example.com/&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br>![](<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" target=\"_blank\" rel=\"external\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a>)</p>\n<p>参考链接：<br>![img]</p>\n<p>[img]:<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" target=\"_blank\" rel=\"external\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a></p>\n<p>指定宽高：需用html标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;img src=&quot;http://img3.3lian.com/2013/s1/65/d/104.jpg&quot; width=&quot;200&quot; height=&quot;128&quot;  /&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>> 引用</p>\n<p>>&gt; 嵌套引用</p>\n<hr>\n<h2 id=\"粗体-斜体\"><a href=\"#粗体-斜体\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p>*这里是斜体*</p>\n<p>**这里是粗体**</p>\n<p>***这里是粗斜体***</p>\n<hr>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>dog | bird | cat</p>\n<p>—-|——|—-</p>\n<p>foo | foo  | foo</p>\n<p>bar | bar  | bar</p>\n<p>baz | baz  | baz</p>\n<hr>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\\\   反斜线</p>\n<p>   \\`   反引号</p>\n<p>   \\*   星号</p>\n<p>   \\_   底线</p>\n<p>   \\{}  花括号</p>\n<p>   \\[]  方括号</p>\n<p>   \\()  括弧</p>\n<p>   \\#   井字号</p>\n<p>   \\+   加号</p>\n<p>   \\-   减号</p>\n<p>   \\.   英文句点</p>\n<p>   \\!   惊叹号</p>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>~~删除这里的内容~~</p>\n<hr>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><h2 id=\"makedown-语法\"><a href=\"#makedown-语法\" class=\"headerlink\" title=\"makedown 语法  \"></a>makedown 语法  </h2><h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void main(String args[])&#123;</div><div class=\"line\">    System.out.print(&quot;Hello World&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Use the <code>printf()</code> function.</p>\n<hr>\n<h2 id=\"标题-1\"><a href=\"#标题-1\" class=\"headerlink\" title=\"标题\"></a>标题</h2><h1 id=\"标题1\"><a href=\"#标题1\" class=\"headerlink\" title=\"标题1\"></a>标题1</h1><h2 id=\"标题2\"><a href=\"#标题2\" class=\"headerlink\" title=\"标题2\"></a>标题2</h2><h3 id=\"标题3\"><a href=\"#标题3\" class=\"headerlink\" title=\"标题3\"></a>标题3</h3><h4 id=\"标题4\"><a href=\"#标题4\" class=\"headerlink\" title=\"标题4\"></a>标题4</h4><h5 id=\"标题5\"><a href=\"#标题5\" class=\"headerlink\" title=\"标题5\"></a>标题5</h5><h6 id=\"标题6\"><a href=\"#标题6\" class=\"headerlink\" title=\"标题6\"></a>标题6</h6><hr>\n<h2 id=\"列表-1\"><a href=\"#列表-1\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n</ul>\n<ul>\n<li>无序列表3</li>\n</ul>\n<ul>\n<li>无序列表4</li>\n</ul>\n<hr>\n<h2 id=\"链接-1\"><a href=\"#链接-1\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://www.google.com\" target=\"_blank\" rel=\"external\">谷歌</a></p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\" target=\"_blank\" rel=\"external\">例子</a> 行内链接.</p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\" target=\"_blank\" rel=\"external\">例子</a> 参考链接.</p>\n<p>自动链接<br><a href=\"http://example.com/\" target=\"_blank\" rel=\"external\">http://example.com/</a></p>\n<hr>\n<h2 id=\"图片-1\"><a href=\"#图片-1\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"\"></p>\n<p>参考链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"img\"></p>\n<p>指定宽高：需用html标记</p>\n<p><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\">  </p>\n<hr>\n<h2 id=\"引用-1\"><a href=\"#引用-1\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>引用</p>\n<blockquote>\n<p>嵌套引用</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"粗体-斜体-1\"><a href=\"#粗体-斜体-1\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p><em>这里是斜体</em></p>\n<p><strong>这里是粗体</strong></p>\n<p><strong><em>这里是粗斜体</em></strong></p>\n<hr>\n<h2 id=\"表格-1\"><a href=\"#表格-1\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th>dog</th>\n<th>bird</th>\n<th>cat</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>foo</td>\n<td>foo</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>bar</td>\n<td>bar</td>\n</tr>\n<tr>\n<td>baz</td>\n<td>baz</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"转义-1\"><a href=\"#转义-1\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\   反斜线</p>\n<p>   `   反引号</p>\n<p>   *   星号</p>\n<p>   _   底线</p>\n<p>   {}  花括号</p>\n<p>   []  方括号</p>\n<p>   ()  括弧</p>\n<p>   #   井字号</p>\n<p>   +   加号</p>\n<p>   -   减号</p>\n<p>   .   英文句点</p>\n<p>   !   惊叹号</p>\n<hr>\n<h2 id=\"删除线-1\"><a href=\"#删除线-1\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p><del>删除这里的内容</del></p>\n<hr>\n<h2 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h2><p><a href=\"http://www.markdown.cn/\" target=\"_blank\" rel=\"external\">Markdown 语法说明 (简体中文版)</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"external\">Markdown 维基百科 </a></p>\n<hr>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"http://wowubuntu.com/markdown/\">Markdown</a> 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>\n</blockquote>\n<p> 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。</p>\n<h1 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h1><p> makedown 语法  </p>\n<hr>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>```<br>public void main(String args[]){<br>    System.out.print(“Hello World”);<br>}<br>```</p>\n<p>Use the `printf()` function.</p>\n<hr>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p># 标题1</p>\n<p>## 标题2</p>\n<p>### 标题3</p>\n<p>#### 标题4</p>\n<p>##### 标题5</p>\n<p>###### 标题6</p>\n<hr>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li><p>有序列表1</p>\n</li>\n<li><p>有序列表2</p>\n</li>\n</ol>\n<p>- 无序列表1</p>\n<p>- 无序列表2</p>\n<p>* 无序列表3</p>\n<p>+ 无序列表4</p>\n<hr>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>[谷歌](<a href=\"http://www.google.com\">http://www.google.com</a>)</p>\n<p>这是一个 [例子](<a href=\"http://google.com/\">http://google.com/</a> “google”) 行内链接.</p>\n<p>这是一个 [例子] [id] 参考链接.</p>\n<p>[id]: <a href=\"http://google.com/\">http://google.com/</a> “google”</p>\n<p>自动链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;http://example.com/&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br>![](<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a>)</p>\n<p>参考链接：<br>![img]</p>\n<p>[img]:<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a></p>\n<p>指定宽高：需用html标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;img src=&quot;http://img3.3lian.com/2013/s1/65/d/104.jpg&quot; width=&quot;200&quot; height=&quot;128&quot;  /&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>> 引用</p>\n<p>>&gt; 嵌套引用</p>\n<hr>\n<h2 id=\"粗体-斜体\"><a href=\"#粗体-斜体\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p>*这里是斜体*</p>\n<p>**这里是粗体**</p>\n<p>***这里是粗斜体***</p>\n<hr>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>dog | bird | cat</p>\n<p>—-|——|—-</p>\n<p>foo | foo  | foo</p>\n<p>bar | bar  | bar</p>\n<p>baz | baz  | baz</p>\n<hr>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\\\   反斜线</p>\n<p>   \\`   反引号</p>\n<p>   \\*   星号</p>\n<p>   \\_   底线</p>\n<p>   \\{}  花括号</p>\n<p>   \\[]  方括号</p>\n<p>   \\()  括弧</p>\n<p>   \\#   井字号</p>\n<p>   \\+   加号</p>\n<p>   \\-   减号</p>\n<p>   \\.   英文句点</p>\n<p>   \\!   惊叹号</p>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>~~删除这里的内容~~</p>\n<hr>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><h2 id=\"makedown-语法\"><a href=\"#makedown-语法\" class=\"headerlink\" title=\"makedown 语法  \"></a>makedown 语法  </h2><h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void main(String args[])&#123;</div><div class=\"line\">    System.out.print(&quot;Hello World&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Use the <code>printf()</code> function.</p>\n<hr>\n<h2 id=\"标题-1\"><a href=\"#标题-1\" class=\"headerlink\" title=\"标题\"></a>标题</h2><h1 id=\"标题1\"><a href=\"#标题1\" class=\"headerlink\" title=\"标题1\"></a>标题1</h1><h2 id=\"标题2\"><a href=\"#标题2\" class=\"headerlink\" title=\"标题2\"></a>标题2</h2><h3 id=\"标题3\"><a href=\"#标题3\" class=\"headerlink\" title=\"标题3\"></a>标题3</h3><h4 id=\"标题4\"><a href=\"#标题4\" class=\"headerlink\" title=\"标题4\"></a>标题4</h4><h5 id=\"标题5\"><a href=\"#标题5\" class=\"headerlink\" title=\"标题5\"></a>标题5</h5><h6 id=\"标题6\"><a href=\"#标题6\" class=\"headerlink\" title=\"标题6\"></a>标题6</h6><hr>\n<h2 id=\"列表-1\"><a href=\"#列表-1\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n</ul>\n<ul>\n<li>无序列表3</li>\n</ul>\n<ul>\n<li>无序列表4</li>\n</ul>\n<hr>\n<h2 id=\"链接-1\"><a href=\"#链接-1\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://www.google.com\">谷歌</a></p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\">例子</a> 行内链接.</p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\">例子</a> 参考链接.</p>\n<p>自动链接<br><a href=\"http://example.com/\">http://example.com/</a></p>\n<hr>\n<h2 id=\"图片-1\"><a href=\"#图片-1\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"\"></p>\n<p>参考链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"img\"></p>\n<p>指定宽高：需用html标记</p>\n<p><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  </p>\n<hr>\n<h2 id=\"引用-1\"><a href=\"#引用-1\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>引用</p>\n<blockquote>\n<p>嵌套引用</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"粗体-斜体-1\"><a href=\"#粗体-斜体-1\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p><em>这里是斜体</em></p>\n<p><strong>这里是粗体</strong></p>\n<p><strong><em>这里是粗斜体</em></strong></p>\n<hr>\n<h2 id=\"表格-1\"><a href=\"#表格-1\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th>dog</th>\n<th>bird</th>\n<th>cat</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>foo</td>\n<td>foo</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>bar</td>\n<td>bar</td>\n</tr>\n<tr>\n<td>baz</td>\n<td>baz</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"转义-1\"><a href=\"#转义-1\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\   反斜线</p>\n<p>   `   反引号</p>\n<p>   *   星号</p>\n<p>   _   底线</p>\n<p>   {}  花括号</p>\n<p>   []  方括号</p>\n<p>   ()  括弧</p>\n<p>   #   井字号</p>\n<p>   +   加号</p>\n<p>   -   减号</p>\n<p>   .   英文句点</p>\n<p>   !   惊叹号</p>\n<hr>\n<h2 id=\"删除线-1\"><a href=\"#删除线-1\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p><del>删除这里的内容</del></p>\n<hr>\n<h2 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h2><p><a href=\"http://www.markdown.cn/\">Markdown 语法说明 (简体中文版)</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\">Markdown 维基百科 </a></p>\n<hr>\n"},{"layout":"post","date":"2016-03-30T04:48:55.000Z","title":"sphinx安装问题","_content":"\n>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python\n 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。\n\n>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是\n Python2，Python3与Python2是不兼容的，在编码问题上报错。\n\n>遂改之，卸载Python3，安装Python2.问题来了。\n\n安装完Python2之后，使用 easy_install sphinx \n指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：\n\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 4-5: ordi al not in range(128)\n\n意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内\n，就会抛出异常（ordinal not in range(128)）。\n\n看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆\n.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。\n\n后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。\n\n首先所有修改的动作都是要创建一个叫 **sitecustomize.py**的文件，为什么要创建这个文件呢，是因为python在启动的时候会\n去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。\n\n修改默认字符编码的代码很简单就2行：\n\n```\n\n# sitecustomize.py                   # this file can be anywhere in your Python path,\n# but it usually goes in ${pythondir}/lib/site-packages/\nimport sys\nsys.setdefaultencoding('utf-8') \n\n```\n\n写完这个文件放哪里呢？\n\nwindows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 \n\nok,现在再次运行 easy_install sphinx ，可以通过安装了！\n\nps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。\n\n**参考**\n\n[解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误](http://wangye.org/blog/archives/629/)\n\n[永久修改python默认的字符编码为utf-8](http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html)       \n","source":"_posts/sphinx安装问题.md","raw":"---\nlayout: post\ndate:   2016-03-30 12:48:55\ntitle: \"sphinx安装问题\"\ncategories: 工具\ntags: \n- python\n- 编码\n---\n\n>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python\n 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。\n\n>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是\n Python2，Python3与Python2是不兼容的，在编码问题上报错。\n\n>遂改之，卸载Python3，安装Python2.问题来了。\n\n安装完Python2之后，使用 easy_install sphinx \n指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：\n\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 4-5: ordi al not in range(128)\n\n意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内\n，就会抛出异常（ordinal not in range(128)）。\n\n看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆\n.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。\n\n后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。\n\n首先所有修改的动作都是要创建一个叫 **sitecustomize.py**的文件，为什么要创建这个文件呢，是因为python在启动的时候会\n去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。\n\n修改默认字符编码的代码很简单就2行：\n\n```\n\n# sitecustomize.py                   # this file can be anywhere in your Python path,\n# but it usually goes in ${pythondir}/lib/site-packages/\nimport sys\nsys.setdefaultencoding('utf-8') \n\n```\n\n写完这个文件放哪里呢？\n\nwindows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 \n\nok,现在再次运行 easy_install sphinx ，可以通过安装了！\n\nps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。\n\n**参考**\n\n[解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误](http://wangye.org/blog/archives/629/)\n\n[永久修改python默认的字符编码为utf-8](http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html)       \n","slug":"sphinx安装问题","published":1,"updated":"2016-11-30T14:32:49.909Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj5j001mdigcgrkdvr3a","content":"<blockquote>\n<p>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python<br> 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。</p>\n<p>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是<br> Python2，Python3与Python2是不兼容的，在编码问题上报错。</p>\n<p>遂改之，卸载Python3，安装Python2.问题来了。</p>\n</blockquote>\n<p>安装完Python2之后，使用 easy_install sphinx<br>指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：</p>\n<p>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 4-5: ordi al not in range(128)</p>\n<p>意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内<br>，就会抛出异常（ordinal not in range(128)）。</p>\n<p>看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆<br>.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。</p>\n<p>后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。</p>\n<p>首先所有修改的动作都是要创建一个叫 <strong>sitecustomize.py</strong>的文件，为什么要创建这个文件呢，是因为python在启动的时候会<br>去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。</p>\n<p>修改默认字符编码的代码很简单就2行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># sitecustomize.py                   # this file can be anywhere in your Python path,</div><div class=\"line\"># but it usually goes in $&#123;pythondir&#125;/lib/site-packages/</div><div class=\"line\">import sys</div><div class=\"line\">sys.setdefaultencoding(&apos;utf-8&apos;)</div></pre></td></tr></table></figure>\n<p>写完这个文件放哪里呢？</p>\n<p>windows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 </p>\n<p>ok,现在再次运行 easy_install sphinx ，可以通过安装了！</p>\n<p>ps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"http://wangye.org/blog/archives/629/\" target=\"_blank\" rel=\"external\">解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html\" target=\"_blank\" rel=\"external\">永久修改python默认的字符编码为utf-8</a>       </p>\n","excerpt":"","more":"<blockquote>\n<p>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python<br> 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。</p>\n<p>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是<br> Python2，Python3与Python2是不兼容的，在编码问题上报错。</p>\n<p>遂改之，卸载Python3，安装Python2.问题来了。</p>\n</blockquote>\n<p>安装完Python2之后，使用 easy_install sphinx<br>指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：</p>\n<p>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 4-5: ordi al not in range(128)</p>\n<p>意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内<br>，就会抛出异常（ordinal not in range(128)）。</p>\n<p>看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆<br>.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。</p>\n<p>后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。</p>\n<p>首先所有修改的动作都是要创建一个叫 <strong>sitecustomize.py</strong>的文件，为什么要创建这个文件呢，是因为python在启动的时候会<br>去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。</p>\n<p>修改默认字符编码的代码很简单就2行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># sitecustomize.py                   # this file can be anywhere in your Python path,</div><div class=\"line\"># but it usually goes in $&#123;pythondir&#125;/lib/site-packages/</div><div class=\"line\">import sys</div><div class=\"line\">sys.setdefaultencoding(&apos;utf-8&apos;)</div></pre></td></tr></table></figure>\n<p>写完这个文件放哪里呢？</p>\n<p>windows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 </p>\n<p>ok,现在再次运行 easy_install sphinx ，可以通过安装了！</p>\n<p>ps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"http://wangye.org/blog/archives/629/\">解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html\">永久修改python默认的字符编码为utf-8</a>       </p>\n"},{"layout":"post","date":"2016-08-16T07:31:44.000Z","title":"synchronized的用法","comments":1,"_content":"\n>以前的工作过程中，偶尔会遇到synchronized的使用，比如[这篇总结](http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/)。今天来总结一下自己对synchronized的关键字的一些认识。\n\n## 同步锁\n\nsynchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。\n\n每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：\n\n```java\nsynchronized (object) {\n\t//doSomething...\t\t\n}\n```\n\n上面的 '{' '}' 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。\n\n## synchronized修饰代码块\n\n### synchronized同步锁为普通对象\n\n```java\npublic void function(){\n\tsynchronized (object) {\n\t\t//doSomething...\t\t\n\t}\n}\n```\n当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。\n\n下面的例子：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(new Object());\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n运行结果：\n\n```\nThread-0运行中...\nThread-1运行中...\nThread-2运行中...\nThread-3运行中...\nThread-4运行中...\nThread-1结束...\nThread-0结束...\nThread-3结束...\nThread-4结束...\nThread-2结束...\n```\n\n跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tObject object = new Object();\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(object);\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```java\nThread-0运行中...\nThread-0结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。\n\n重点要理解：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**\n\n### synchronized同步锁为类\n\n类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。\n\n将上面的例子修改一下：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-0结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\n```\n这些线程同样实现了同步，因为他们的同步锁是同一个对象--SyncTest类对象。\n\n需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\tSync1 sync1 = new Sync1(new SyncTest());\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t\t\n\t\tsync1.start();\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n\nclass Sync1 extends Thread{\n\tSyncTest syncTest;\n\tpublic Sync1(SyncTest syncTest){\n\t\tthis.syncTest = syncTest;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncTest) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-5运行中...\nThread-0结束...\nThread-5结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。\n\n## synchronized修饰方法\n\nsynchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。\n\n### synchronized修饰普通方法\n\n```java\npublic synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\nsynchronized修饰普通方法中的同步锁就是这个对象本身，即\"this\"。\n\n下面的代码：\n\n```java\nclass Sync extends Thread{\n\tpublic synchronized void syncFunction(){\n\t\tdoSomething();\n\t}\n\t\n\tpublic void syncFunction2(){\n\t\tsynchronized (this) {\n\t\t\tdoSomething();\n\t\t}\n\t}\n\t\n\tprivate void doSomething(){\n\t\t//doSomething...\n\t}\n}\n```\n\n上面syncFunction()与syncFunction2()实现的同步效果是一样的。\n\n当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的\"this\"。\n\n### synchronized修饰静态方法\n\n```java\npublic static synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\n同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。\n\n不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。\n\n## 总结\n\n理解synchronized的关键就在于：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**这个同步锁，可以理解为一个对象。","source":"_posts/synchronized的一些用法.md","raw":"---\nlayout: post\ndate: 2016-08-16 15:31:44\ncategories: 编程\ntitle: synchronized的用法\ntags: \n- 多线程\n- java\ncomments: true\n---\n\n>以前的工作过程中，偶尔会遇到synchronized的使用，比如[这篇总结](http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/)。今天来总结一下自己对synchronized的关键字的一些认识。\n\n## 同步锁\n\nsynchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。\n\n每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：\n\n```java\nsynchronized (object) {\n\t//doSomething...\t\t\n}\n```\n\n上面的 '{' '}' 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。\n\n## synchronized修饰代码块\n\n### synchronized同步锁为普通对象\n\n```java\npublic void function(){\n\tsynchronized (object) {\n\t\t//doSomething...\t\t\n\t}\n}\n```\n当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。\n\n下面的例子：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(new Object());\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n运行结果：\n\n```\nThread-0运行中...\nThread-1运行中...\nThread-2运行中...\nThread-3运行中...\nThread-4运行中...\nThread-1结束...\nThread-0结束...\nThread-3结束...\nThread-4结束...\nThread-2结束...\n```\n\n跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tObject object = new Object();\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(object);\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```java\nThread-0运行中...\nThread-0结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。\n\n重点要理解：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**\n\n### synchronized同步锁为类\n\n类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。\n\n将上面的例子修改一下：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-0结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\n```\n这些线程同样实现了同步，因为他们的同步锁是同一个对象--SyncTest类对象。\n\n需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\tSync1 sync1 = new Sync1(new SyncTest());\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t\t\n\t\tsync1.start();\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n\nclass Sync1 extends Thread{\n\tSyncTest syncTest;\n\tpublic Sync1(SyncTest syncTest){\n\t\tthis.syncTest = syncTest;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncTest) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-5运行中...\nThread-0结束...\nThread-5结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。\n\n## synchronized修饰方法\n\nsynchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。\n\n### synchronized修饰普通方法\n\n```java\npublic synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\nsynchronized修饰普通方法中的同步锁就是这个对象本身，即\"this\"。\n\n下面的代码：\n\n```java\nclass Sync extends Thread{\n\tpublic synchronized void syncFunction(){\n\t\tdoSomething();\n\t}\n\t\n\tpublic void syncFunction2(){\n\t\tsynchronized (this) {\n\t\t\tdoSomething();\n\t\t}\n\t}\n\t\n\tprivate void doSomething(){\n\t\t//doSomething...\n\t}\n}\n```\n\n上面syncFunction()与syncFunction2()实现的同步效果是一样的。\n\n当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的\"this\"。\n\n### synchronized修饰静态方法\n\n```java\npublic static synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\n同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。\n\n不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。\n\n## 总结\n\n理解synchronized的关键就在于：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**这个同步锁，可以理解为一个对象。","slug":"synchronized的一些用法","published":1,"updated":"2016-11-30T14:32:49.909Z","photos":[],"link":"","_id":"ciyvmgj5m001pdigck3990nkg","content":"<blockquote>\n<p>以前的工作过程中，偶尔会遇到synchronized的使用，比如<a href=\"http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/\">这篇总结</a>。今天来总结一下自己对synchronized的关键字的一些认识。</p>\n</blockquote>\n<h2 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h2><p>synchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。</p>\n<p>每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的 ‘{‘ ‘}’ 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p>\n<h2 id=\"synchronized修饰代码块\"><a href=\"#synchronized修饰代码块\" class=\"headerlink\" title=\"synchronized修饰代码块\"></a>synchronized修饰代码块</h2><h3 id=\"synchronized同步锁为普通对象\"><a href=\"#synchronized同步锁为普通对象\" class=\"headerlink\" title=\"synchronized同步锁为普通对象\"></a>synchronized同步锁为普通对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。</p>\n<p>下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(<span class=\"keyword\">new</span> Object());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\tObject object = <span class=\"keyword\">new</span> Object();</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(object);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-<span class=\"number\">0</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">0</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">4</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">4</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">2</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">2</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">3</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">3</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">1</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">1</span>结束...</div></pre></td></tr></table></figure>\n<p>5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。</p>\n<p>重点要理解：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong></p>\n<h3 id=\"synchronized同步锁为类\"><a href=\"#synchronized同步锁为类\" class=\"headerlink\" title=\"synchronized同步锁为类\"></a>synchronized同步锁为类</h3><p>类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。</p>\n<p>将上面的例子修改一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>这些线程同样实现了同步，因为他们的同步锁是同一个对象–SyncTest类对象。</p>\n<p>需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSync1 sync1 = <span class=\"keyword\">new</span> Sync1(<span class=\"keyword\">new</span> SyncTest());</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsync1.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tSyncTest syncTest;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync1</span><span class=\"params\">(SyncTest syncTest)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncTest = syncTest;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncTest) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-5运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-5结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div></pre></td></tr></table></figure>\n<p>可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。</p>\n<h2 id=\"synchronized修饰方法\"><a href=\"#synchronized修饰方法\" class=\"headerlink\" title=\"synchronized修饰方法\"></a>synchronized修饰方法</h2><p>synchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。</p>\n<h3 id=\"synchronized修饰普通方法\"><a href=\"#synchronized修饰普通方法\" class=\"headerlink\" title=\"synchronized修饰普通方法\"></a>synchronized修饰普通方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>synchronized修饰普通方法中的同步锁就是这个对象本身，即”this”。</p>\n<p>下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tdoSomething();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\tdoSomething();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面syncFunction()与syncFunction2()实现的同步效果是一样的。</p>\n<p>当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的”this”。</p>\n<h3 id=\"synchronized修饰静态方法\"><a href=\"#synchronized修饰静态方法\" class=\"headerlink\" title=\"synchronized修饰静态方法\"></a>synchronized修饰静态方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。</p>\n<p>不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>理解synchronized的关键就在于：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong>这个同步锁，可以理解为一个对象。</p>\n","excerpt":"","more":"<blockquote>\n<p>以前的工作过程中，偶尔会遇到synchronized的使用，比如<a href=\"http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/\">这篇总结</a>。今天来总结一下自己对synchronized的关键字的一些认识。</p>\n</blockquote>\n<h2 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h2><p>synchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。</p>\n<p>每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的 ‘{‘ ‘}’ 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p>\n<h2 id=\"synchronized修饰代码块\"><a href=\"#synchronized修饰代码块\" class=\"headerlink\" title=\"synchronized修饰代码块\"></a>synchronized修饰代码块</h2><h3 id=\"synchronized同步锁为普通对象\"><a href=\"#synchronized同步锁为普通对象\" class=\"headerlink\" title=\"synchronized同步锁为普通对象\"></a>synchronized同步锁为普通对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。</p>\n<p>下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(<span class=\"keyword\">new</span> Object());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\tObject object = <span class=\"keyword\">new</span> Object();</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(object);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-<span class=\"number\">0</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">0</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">4</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">4</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">2</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">2</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">3</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">3</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">1</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">1</span>结束...</div></pre></td></tr></table></figure>\n<p>5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。</p>\n<p>重点要理解：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong></p>\n<h3 id=\"synchronized同步锁为类\"><a href=\"#synchronized同步锁为类\" class=\"headerlink\" title=\"synchronized同步锁为类\"></a>synchronized同步锁为类</h3><p>类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。</p>\n<p>将上面的例子修改一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>这些线程同样实现了同步，因为他们的同步锁是同一个对象–SyncTest类对象。</p>\n<p>需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSync1 sync1 = <span class=\"keyword\">new</span> Sync1(<span class=\"keyword\">new</span> SyncTest());</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsync1.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tSyncTest syncTest;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync1</span><span class=\"params\">(SyncTest syncTest)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncTest = syncTest;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncTest) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-5运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-5结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div></pre></td></tr></table></figure>\n<p>可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。</p>\n<h2 id=\"synchronized修饰方法\"><a href=\"#synchronized修饰方法\" class=\"headerlink\" title=\"synchronized修饰方法\"></a>synchronized修饰方法</h2><p>synchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。</p>\n<h3 id=\"synchronized修饰普通方法\"><a href=\"#synchronized修饰普通方法\" class=\"headerlink\" title=\"synchronized修饰普通方法\"></a>synchronized修饰普通方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>synchronized修饰普通方法中的同步锁就是这个对象本身，即”this”。</p>\n<p>下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tdoSomething();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\tdoSomething();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面syncFunction()与syncFunction2()实现的同步效果是一样的。</p>\n<p>当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的”this”。</p>\n<h3 id=\"synchronized修饰静态方法\"><a href=\"#synchronized修饰静态方法\" class=\"headerlink\" title=\"synchronized修饰静态方法\"></a>synchronized修饰静态方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。</p>\n<p>不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>理解synchronized的关键就在于：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong>这个同步锁，可以理解为一个对象。</p>\n"},{"layout":"post","title":"ssl使用总结","date":"2016-09-25T02:09:10.000Z","_content":"\n>这次维护的web服务器要求使用Https双向认证，了解了一下如何在客户端和服务器之间进行ssl的配置，在此记录。另外，这篇日志主要记录如何使用，并不深入底层原理。\n\n## 简单认识ssl和证书\n\n在理解这部分内容之前，建议先看看前面对的一篇总结：[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)\n\nSSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。\n\nSSL协议提供的服务主要有：\n\n1、认证用户和服务器，确保数据发送到正确的客户机和服务器；\n\n2、加密数据以防止数据中途被窃取；\n\n3、维护数据的完整性，确保数据在传输过程中不被改变。\n\n其实，ssl就是一种协议。我们知道Http协议是明文传输的，安全性不高。Https就是在Http基础之上加一层ssl协议，来达到加密通信的目的。具体的ssl握手过程，可以参考[百度百科](http://baike.baidu.com/view/14121.htm#6)\n\n附上一张图方便理解：\n\n{% asset_img sslprocess.jpg sslprocess %}\n\n图片来自网络\n\n可以看到ssl握手过程中服务器向客户端发送了自己的证书。这个证书是加密过程的重要内容。在前面的[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)这篇博客中，在关于数字证书的一节，我们知道了数字证书可以证明服务器的身份，服务器证书中包含了服务器的公钥，用于之后的通信。\n\n那么，简单了解下证书的工作原理。\n\n首先看一下证书中有哪些内容：\n\n{% asset_img zhifubao.png 支付宝证书 %}\n\n{% asset_img zhufubao1.png 支付宝证书 %}\n\n{% asset_img zhufubao2.png 支付宝证书 %}\n\n上面是我从谷chorme浏览器中截取的支付宝所使用证书的信息截图。\n\n可以看到，里面有颁发者和使用者。颁发者就是颁发此证书的CA(证书颁发机构),使用者就是与我们通信的服务器，也就是该证书的持有者。证书中还包含了我们上面提到的公钥。\n\n我们知道，证书能够证明服务器的身份，那么他是如何证明的呢？我们以浏览器为例：\n\n首先，浏览器(客户端)接收到服务器发来的证书A之后，会去验证这个证书A是否被篡改或者是伪造的。浏览器首先会去操作系统中内置根证书库中搜索A的颁发者的证书。关于这一点要解释一下，数字证书的颁发机构也有自己的证书，这个证书就是根证书，这个根证书在我的系统刚安装好时，就被微软等公司默认安装在操作系统当中了。\n\n如果在操作系统中找到了服务器证书中的颁发者的证书Root，那么继续下一步，否则，就知道这个服务器证书的颁发者是个不受信任的CA发布的，此时，浏览器会给出警告。若我们选择相信这个CA并继续，则继续下一步。\n\n接下来，浏览器从Root中得到Root的公钥，然后用该公钥对A中的指纹算法和指纹进行解密。注意，为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。\n\n那么什么是指纹算法和指纹呢？这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。\n\n此时就可以判断该证书是否是仿冒或者经过伪造篡改的。如没有，则证明这个服务器是可信任的。接下来就可以使用该服务器提供的公钥来进行通信了。\n\n通过上面的分析我们知道了，ssl协议中，首先通过证书来证明服务器的身份，然后取出证书中的公钥，接下来就可以按照[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)这篇博客中说到的通信方式通信了。这大概上就是ssl的原理，当然实际中ssl的细节还是要复杂很多。\n\n了解了ssl的基本原理，对我们实现服务器的https通信有很大的帮助。\n\n## Https 单向认证\n\n单向认证就是服务器必须向客户端发送自己的证书来证明自己的身份，然后进行加密通信。现在服务器的基础框架是springboot，演示如何配置服务器和客户端：\n\n服务器：\n\n打开springboot的配置文件application.properties:\n\nserver.ssl.key-store=server.keystore\n\nserver.ssl.key-store-password=123456\n\nserver.ssl.keyStoreType=JKS\n\nserver.ssl.keyAlias:server\n\n先解释一下上面几个配置：\n\n.keystore: keystore文件中存储了密钥和证书。密钥包括私钥和公钥，而证书中只包含公钥。这个证书就是我们上面所说的证书。注意：密钥和证书是一一对应的。\n\npassword: 生成keystore文件时所填的密码。\n\nkeyStoreType: keystore类型。\n\nkeyAlias: 生成密钥的别名。\n\nkeysotre文件是怎么生成的呢？使用jdk自带的工具：keytool。生成keystore文件的命令如下：\n\n`keytool -genkey -alias server -keyalg RSA -validity 365 -keystore server.keystore`\n\n其中：-alias 指定生成密钥的别名，-keystore 指定生成的keystore文件的位置和名称。其他的参数的含义可以通过keytool -help来查找。\n\n一个keystore文件中可以存储多个证书和证书对应的密钥，这些证书和其对应的密钥通过唯一的别名alias来指定，也就是说，通过alias可以导出证书。但是要注意，无法通过keytool导出私钥。\n\n看一下如何从keystore文件中导出证书：\n\n`keytool -export -alias server -keystore server.keystore -file serverCA.crt`\n\n-alias指定了要导出的证书文件，-file 指定了要导出的证书文件的位置和名称。\n\n了解了上面的几个配置，再结合之前对ssl原理的总结，不难知道：\n\n我们指定的别名(server.ssl.keyAlias:server)之后,服务器通过该别名从keystore文件中获得对应的证书，并将其发送给客户端，同时使用keystore中alias对应的私钥(keytool虽然导不出私钥，但可以通过代码等方式获得)可以对与客户端通信的内容进行加密和解密。这便是keystore文件的作用：存储证书和私钥。\n\n服务器端的配置完成了。现在有一个问题，虽然服务器可以发送证书到客户端了，但是客户端并不会信任我们这个证书。如果这个时候通过浏览器以https的方式访问服务器，浏览器会提醒你，此连接不受信任。那是因为虽然服务器将证书发送到了浏览器(客户端)，但是浏览器并不认为这个证书能够证明服务器的身份。那为什么https访问支付宝等网站没有报这个警告呢？想想上面的内容，浏览器或操作系统内置了颁发给支付宝证书的机构的根证书，通过这个根证书的公钥对支付宝发来的证书进行解密可以证明这个证书确实是由支付宝发过来的，从而证明了服务器的身份。\n\n虽然浏览器并不能验证我们的证书，我们可以手动的把证书添加到浏览器的信任列表中。这个证书就是我们上面通过keytool导出的证书，将这个证书手动添加到浏览器信任列表里面，再次访问服务器就不会有警告啦。(具体的添加方式不再赘述)(从这点上也可以看出自签名证书的不安全性，有可能被假冒和伪造)\n\nso,通过上面的方式我们已经将ssl单向验证配置好了。那么，如果客户端是自己用java写的呢？下面举一个例子，使用HttpsURLConnection实现：\n\n首先生成客户端的信任证书库，用来存放客户端所信任的证书：\n\n`keytool -keystore truststore.jks -alias client -import -trustcacerts -file serverCA.crt`\n\n-file 指定要信任的证书，此例中应该是我们上面导出的证书serverCA.crt\n\n-keystore 指定要生成的信任库路径和名称。\n\n然后生成我们自己的信任证书管理器：\n\n参考了网上的代码：\n\n```java\npublic class MyX509TrustManager implements X509TrustManager {\n\t/*\n\t * The default X509TrustManager returned by SunX509. We'll delegate\n\t * decisions to it, and fall back to the logic in this class if the default\n\t * X509TrustManager doesn't trust it.\n\t */\n\tX509TrustManager sunJSSEX509TrustManager;\n\n\tpublic MyX509TrustManager() throws Exception {\n\t\t// create a \"default\" JSSE X509TrustManager.\n\t\tKeyStore ks = KeyStore.getInstance(\"JKS\");\n\t\t//注意 src/clientTrustCA.jks就是上面生成的信任证书库\n\t\tks.load(new FileInputStream(\"src/clientTrustCA.jks\"), \"123456\".toCharArray());\n\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\", \"SunJSSE\");\n\t\ttmf.init(ks);\n\t\tTrustManager tms[] = tmf.getTrustManagers();\n\t\t/*\n\t\t * Iterate over the returned trustmanagers, look for an instance of\n\t\t * X509TrustManager. If found, use that as our \"default\" trust manager.\n\t\t */\n\t\tfor (int i = 0; i < tms.length; i++) {\n\t\t\tif (tms[i] instanceof X509TrustManager) {\n\t\t\t\tsunJSSEX509TrustManager = (X509TrustManager) tms[i];\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Find some other way to initialize, or else we have to fail the\n\t\t * constructor.\n\t\t */\n\t\tthrow new Exception(\"Couldn't initialize\");\n\t}\n\n\t/*\n\t * Delegate to the default trust manager.\n\t */\n\tpublic void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\ttry {\n\t\t\tsunJSSEX509TrustManager.checkClientTrusted(chain, authType);\n\t\t} catch (CertificateException excep) {\n\t\t\t// do any special handling here, or rethrow exception.\n\t\t}\n\t}\n\n\t/*\n\t * Delegate to the default trust manager.\n\t */\n\tpublic void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\ttry {\n\t\t\tsunJSSEX509TrustManager.checkServerTrusted(chain, authType);\n\t\t} catch (CertificateException excep) {\n\t\t\t/*\n\t\t\t * Possibly pop up a dialog box asking whether to trust the cert\n\t\t\t * chain.\n\t\t\t */\n\t\t}\n\t}\n\n\t/*\n\t * Merely pass this through.\n\t */\n\tpublic X509Certificate[] getAcceptedIssuers() {\n\t\treturn sunJSSEX509TrustManager.getAcceptedIssuers();\n\t}\n}\n```\n接着使用这个管理器：\n\n```java\n TrustManager[] tm = { new MyX509TrustManager() };\n SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n sslContext.init(null, tm, new java.security.SecureRandom());\n // 从上述SSLContext对象中得到SSLSocketFactory对象\n SSLSocketFactory ssf = sslContext.getSocketFactory();\n\n // 创建URL对象\n URL myURL = new URL(url);\n // 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象\n HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();\n httpsConn.setSSLSocketFactory(ssf);\n\n```\n\n接下来就可以使用这个HttpsURLConnection来访问服务器啦。\n\n## Https双向认证\n\n所谓的Https双向认证就是不仅仅客户端要验证浏览器的身份，浏览器也要向服务器证明自己的身份，也就是第一幅图片中的5。\n\n理解了单向认证，双向认证实现起来也就不难了。\n\n首先像我们之前一样使用keytool生成keystore文件client.keystore，这个文件是为客户端使用准备的。\n\n然后通过client.keystore导出证书client.crt。\n\n接着生成信任库文件serverTrust.jks,将client.crt导入其中。\n\n在单向认证中我们给出了客户端单向认证时的java代码，用来下面给出双向认证的代码：\n\n生成读取keystore的类：\n\n```java\npublic class MyKeyManager{\n\t// 相关的 jks 文件及其密码定义\n\t private final static String CERT_STORE=\"src/client.keystore\";\n\t private final static String CERT_STORE_PASSWORD=\"123456\";\n\t \n\t public static KeyManager[] getKeyManagers() throws Exception{\n\t\t // 载入 jks 文件\n\t\t FileInputStream f_certStore=new FileInputStream(CERT_STORE); \n\t\t KeyStore ks=KeyStore.getInstance(\"jks\"); \n\t\t ks.load(f_certStore, CERT_STORE_PASSWORD.toCharArray()); \n\t\t f_certStore.close(); \n\n\t\t // 创建并初始化证书库工厂\n\t\t String alg=KeyManagerFactory.getDefaultAlgorithm(); \n\t\t KeyManagerFactory kmFact=KeyManagerFactory.getInstance(alg); \n\t\t kmFact.init(ks, CERT_STORE_PASSWORD.toCharArray()); \n\n\t\t KeyManager[] kms=kmFact.getKeyManagers(); \n\t\t return kms;\n\t }\n}\n```\n\n像上面单向认证中那样使用它：\n\n```java \n TrustManager[] tm = { new MyX509TrustManager() };\n KeyManager[] km = MyKeyManager.getKeyManagers();\n SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n sslContext.init(km, tm, new java.security.SecureRandom());\n // 从上述SSLContext对象中得到SSLSocketFactory对象\n SSLSocketFactory ssf = sslContext.getSocketFactory();\n\n // 创建URL对象\n URL myURL = new URL(url);\n // 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象\n HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();\n httpsConn.setSSLSocketFactory(ssf);\n```\n\n然后使用HttpsURLConnection就可以使用了。但是此时服务器端还需要配置，因为客户端仅仅是将自己的证书发过去了，服务器应该如何信任它呢？\n\n打开springboot的配置文件application.properties添加以下配置:\n\n#Whether client authentication is wanted (\"want\") or needed (\"need\"). Requires a trust store.\n\nserver.ssl.client-auth=need\n\nserver.ssl.trust-store=serverTrust.jks \n\nserver.ssl.trust-store-password=123456\n\n其中，serverTrust.jks就是刚刚生成的服务器端信任库。\n\n以上步骤全部做完，服务器和客户端就可以愉快的使用Https进行双向认证通信了。\n\n## 关于证书的一些格式\n\n在使用keytool和openssl的时候，会发现有好多种格式让人头晕眼花。不妨参考这篇文章：[那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)](http://www.cnblogs.com/guogangj/p/4118605.html)\n\n我现在也不是理解的十分清楚，故不再赘述。\n\n## 总结\n\n感觉这篇博客没有把自己想要总结的内容全部记录下来，但是现在也不想再写了。服务器实际测试的时候是使用curl这样一个命令行浏览器进行的，使用curl作为客户端进行双向认证的时候也遇到了不少问题，总结了一份配置的[readme](https://github.com/Hikyu/SSL-Configuration/blob/master/ssl%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE.md)，放在github上面，以作记录。readme中的配置方法可能还有一些瑕疵，有些格式转换可能会有冗余，但是整个配置是没有问题的，经过了自己的验证。证书这一块内容感觉还不是理解的特别透彻，尤其是ssl协议的交互和证书格式的一些问题，留作以后学习吧！真的不想看了...\n\n## 参考\n\n[数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html):这篇一定要看，总结的很好！\n\n[浏览器和SSL证书通讯过程](http://www.live-in.org/archives/1302.html)\n\n[Java安全通信：HTTPS与SSL](http://www.cnblogs.com/devinzhang/archive/2012/02/28/2371631.html)\n\n[Java 安全套接字编程以及 keytool 使用最佳实践](http://www.ibm.com/developerworks/cn/java/j-lo-socketkeytool/)\n\n[openssl生成SSL证书的流程](http://blog.csdn.net/liuchunming033/article/details/48470575)\n\n[如何添加自签名SSL证书 自签名SSL证书存风险](https://freessl.wosign.com/911.html)\n\n[keystore提取私钥和证书(重要×××)](http://www.360doc.com/content/11/1226/02/3700464_174996042.shtml)\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/ssl总结.md","raw":"---\nlayout: post\ntitle: ssl使用总结\ndate: 2016-09-25 10:09:10\ncategories: 技术 \ntags: \n- java\n- 加密\n---\n\n>这次维护的web服务器要求使用Https双向认证，了解了一下如何在客户端和服务器之间进行ssl的配置，在此记录。另外，这篇日志主要记录如何使用，并不深入底层原理。\n\n## 简单认识ssl和证书\n\n在理解这部分内容之前，建议先看看前面对的一篇总结：[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)\n\nSSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。\n\nSSL协议提供的服务主要有：\n\n1、认证用户和服务器，确保数据发送到正确的客户机和服务器；\n\n2、加密数据以防止数据中途被窃取；\n\n3、维护数据的完整性，确保数据在传输过程中不被改变。\n\n其实，ssl就是一种协议。我们知道Http协议是明文传输的，安全性不高。Https就是在Http基础之上加一层ssl协议，来达到加密通信的目的。具体的ssl握手过程，可以参考[百度百科](http://baike.baidu.com/view/14121.htm#6)\n\n附上一张图方便理解：\n\n{% asset_img sslprocess.jpg sslprocess %}\n\n图片来自网络\n\n可以看到ssl握手过程中服务器向客户端发送了自己的证书。这个证书是加密过程的重要内容。在前面的[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)这篇博客中，在关于数字证书的一节，我们知道了数字证书可以证明服务器的身份，服务器证书中包含了服务器的公钥，用于之后的通信。\n\n那么，简单了解下证书的工作原理。\n\n首先看一下证书中有哪些内容：\n\n{% asset_img zhifubao.png 支付宝证书 %}\n\n{% asset_img zhufubao1.png 支付宝证书 %}\n\n{% asset_img zhufubao2.png 支付宝证书 %}\n\n上面是我从谷chorme浏览器中截取的支付宝所使用证书的信息截图。\n\n可以看到，里面有颁发者和使用者。颁发者就是颁发此证书的CA(证书颁发机构),使用者就是与我们通信的服务器，也就是该证书的持有者。证书中还包含了我们上面提到的公钥。\n\n我们知道，证书能够证明服务器的身份，那么他是如何证明的呢？我们以浏览器为例：\n\n首先，浏览器(客户端)接收到服务器发来的证书A之后，会去验证这个证书A是否被篡改或者是伪造的。浏览器首先会去操作系统中内置根证书库中搜索A的颁发者的证书。关于这一点要解释一下，数字证书的颁发机构也有自己的证书，这个证书就是根证书，这个根证书在我的系统刚安装好时，就被微软等公司默认安装在操作系统当中了。\n\n如果在操作系统中找到了服务器证书中的颁发者的证书Root，那么继续下一步，否则，就知道这个服务器证书的颁发者是个不受信任的CA发布的，此时，浏览器会给出警告。若我们选择相信这个CA并继续，则继续下一步。\n\n接下来，浏览器从Root中得到Root的公钥，然后用该公钥对A中的指纹算法和指纹进行解密。注意，为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。\n\n那么什么是指纹算法和指纹呢？这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。\n\n此时就可以判断该证书是否是仿冒或者经过伪造篡改的。如没有，则证明这个服务器是可信任的。接下来就可以使用该服务器提供的公钥来进行通信了。\n\n通过上面的分析我们知道了，ssl协议中，首先通过证书来证明服务器的身份，然后取出证书中的公钥，接下来就可以按照[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)这篇博客中说到的通信方式通信了。这大概上就是ssl的原理，当然实际中ssl的细节还是要复杂很多。\n\n了解了ssl的基本原理，对我们实现服务器的https通信有很大的帮助。\n\n## Https 单向认证\n\n单向认证就是服务器必须向客户端发送自己的证书来证明自己的身份，然后进行加密通信。现在服务器的基础框架是springboot，演示如何配置服务器和客户端：\n\n服务器：\n\n打开springboot的配置文件application.properties:\n\nserver.ssl.key-store=server.keystore\n\nserver.ssl.key-store-password=123456\n\nserver.ssl.keyStoreType=JKS\n\nserver.ssl.keyAlias:server\n\n先解释一下上面几个配置：\n\n.keystore: keystore文件中存储了密钥和证书。密钥包括私钥和公钥，而证书中只包含公钥。这个证书就是我们上面所说的证书。注意：密钥和证书是一一对应的。\n\npassword: 生成keystore文件时所填的密码。\n\nkeyStoreType: keystore类型。\n\nkeyAlias: 生成密钥的别名。\n\nkeysotre文件是怎么生成的呢？使用jdk自带的工具：keytool。生成keystore文件的命令如下：\n\n`keytool -genkey -alias server -keyalg RSA -validity 365 -keystore server.keystore`\n\n其中：-alias 指定生成密钥的别名，-keystore 指定生成的keystore文件的位置和名称。其他的参数的含义可以通过keytool -help来查找。\n\n一个keystore文件中可以存储多个证书和证书对应的密钥，这些证书和其对应的密钥通过唯一的别名alias来指定，也就是说，通过alias可以导出证书。但是要注意，无法通过keytool导出私钥。\n\n看一下如何从keystore文件中导出证书：\n\n`keytool -export -alias server -keystore server.keystore -file serverCA.crt`\n\n-alias指定了要导出的证书文件，-file 指定了要导出的证书文件的位置和名称。\n\n了解了上面的几个配置，再结合之前对ssl原理的总结，不难知道：\n\n我们指定的别名(server.ssl.keyAlias:server)之后,服务器通过该别名从keystore文件中获得对应的证书，并将其发送给客户端，同时使用keystore中alias对应的私钥(keytool虽然导不出私钥，但可以通过代码等方式获得)可以对与客户端通信的内容进行加密和解密。这便是keystore文件的作用：存储证书和私钥。\n\n服务器端的配置完成了。现在有一个问题，虽然服务器可以发送证书到客户端了，但是客户端并不会信任我们这个证书。如果这个时候通过浏览器以https的方式访问服务器，浏览器会提醒你，此连接不受信任。那是因为虽然服务器将证书发送到了浏览器(客户端)，但是浏览器并不认为这个证书能够证明服务器的身份。那为什么https访问支付宝等网站没有报这个警告呢？想想上面的内容，浏览器或操作系统内置了颁发给支付宝证书的机构的根证书，通过这个根证书的公钥对支付宝发来的证书进行解密可以证明这个证书确实是由支付宝发过来的，从而证明了服务器的身份。\n\n虽然浏览器并不能验证我们的证书，我们可以手动的把证书添加到浏览器的信任列表中。这个证书就是我们上面通过keytool导出的证书，将这个证书手动添加到浏览器信任列表里面，再次访问服务器就不会有警告啦。(具体的添加方式不再赘述)(从这点上也可以看出自签名证书的不安全性，有可能被假冒和伪造)\n\nso,通过上面的方式我们已经将ssl单向验证配置好了。那么，如果客户端是自己用java写的呢？下面举一个例子，使用HttpsURLConnection实现：\n\n首先生成客户端的信任证书库，用来存放客户端所信任的证书：\n\n`keytool -keystore truststore.jks -alias client -import -trustcacerts -file serverCA.crt`\n\n-file 指定要信任的证书，此例中应该是我们上面导出的证书serverCA.crt\n\n-keystore 指定要生成的信任库路径和名称。\n\n然后生成我们自己的信任证书管理器：\n\n参考了网上的代码：\n\n```java\npublic class MyX509TrustManager implements X509TrustManager {\n\t/*\n\t * The default X509TrustManager returned by SunX509. We'll delegate\n\t * decisions to it, and fall back to the logic in this class if the default\n\t * X509TrustManager doesn't trust it.\n\t */\n\tX509TrustManager sunJSSEX509TrustManager;\n\n\tpublic MyX509TrustManager() throws Exception {\n\t\t// create a \"default\" JSSE X509TrustManager.\n\t\tKeyStore ks = KeyStore.getInstance(\"JKS\");\n\t\t//注意 src/clientTrustCA.jks就是上面生成的信任证书库\n\t\tks.load(new FileInputStream(\"src/clientTrustCA.jks\"), \"123456\".toCharArray());\n\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\", \"SunJSSE\");\n\t\ttmf.init(ks);\n\t\tTrustManager tms[] = tmf.getTrustManagers();\n\t\t/*\n\t\t * Iterate over the returned trustmanagers, look for an instance of\n\t\t * X509TrustManager. If found, use that as our \"default\" trust manager.\n\t\t */\n\t\tfor (int i = 0; i < tms.length; i++) {\n\t\t\tif (tms[i] instanceof X509TrustManager) {\n\t\t\t\tsunJSSEX509TrustManager = (X509TrustManager) tms[i];\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Find some other way to initialize, or else we have to fail the\n\t\t * constructor.\n\t\t */\n\t\tthrow new Exception(\"Couldn't initialize\");\n\t}\n\n\t/*\n\t * Delegate to the default trust manager.\n\t */\n\tpublic void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\ttry {\n\t\t\tsunJSSEX509TrustManager.checkClientTrusted(chain, authType);\n\t\t} catch (CertificateException excep) {\n\t\t\t// do any special handling here, or rethrow exception.\n\t\t}\n\t}\n\n\t/*\n\t * Delegate to the default trust manager.\n\t */\n\tpublic void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\ttry {\n\t\t\tsunJSSEX509TrustManager.checkServerTrusted(chain, authType);\n\t\t} catch (CertificateException excep) {\n\t\t\t/*\n\t\t\t * Possibly pop up a dialog box asking whether to trust the cert\n\t\t\t * chain.\n\t\t\t */\n\t\t}\n\t}\n\n\t/*\n\t * Merely pass this through.\n\t */\n\tpublic X509Certificate[] getAcceptedIssuers() {\n\t\treturn sunJSSEX509TrustManager.getAcceptedIssuers();\n\t}\n}\n```\n接着使用这个管理器：\n\n```java\n TrustManager[] tm = { new MyX509TrustManager() };\n SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n sslContext.init(null, tm, new java.security.SecureRandom());\n // 从上述SSLContext对象中得到SSLSocketFactory对象\n SSLSocketFactory ssf = sslContext.getSocketFactory();\n\n // 创建URL对象\n URL myURL = new URL(url);\n // 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象\n HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();\n httpsConn.setSSLSocketFactory(ssf);\n\n```\n\n接下来就可以使用这个HttpsURLConnection来访问服务器啦。\n\n## Https双向认证\n\n所谓的Https双向认证就是不仅仅客户端要验证浏览器的身份，浏览器也要向服务器证明自己的身份，也就是第一幅图片中的5。\n\n理解了单向认证，双向认证实现起来也就不难了。\n\n首先像我们之前一样使用keytool生成keystore文件client.keystore，这个文件是为客户端使用准备的。\n\n然后通过client.keystore导出证书client.crt。\n\n接着生成信任库文件serverTrust.jks,将client.crt导入其中。\n\n在单向认证中我们给出了客户端单向认证时的java代码，用来下面给出双向认证的代码：\n\n生成读取keystore的类：\n\n```java\npublic class MyKeyManager{\n\t// 相关的 jks 文件及其密码定义\n\t private final static String CERT_STORE=\"src/client.keystore\";\n\t private final static String CERT_STORE_PASSWORD=\"123456\";\n\t \n\t public static KeyManager[] getKeyManagers() throws Exception{\n\t\t // 载入 jks 文件\n\t\t FileInputStream f_certStore=new FileInputStream(CERT_STORE); \n\t\t KeyStore ks=KeyStore.getInstance(\"jks\"); \n\t\t ks.load(f_certStore, CERT_STORE_PASSWORD.toCharArray()); \n\t\t f_certStore.close(); \n\n\t\t // 创建并初始化证书库工厂\n\t\t String alg=KeyManagerFactory.getDefaultAlgorithm(); \n\t\t KeyManagerFactory kmFact=KeyManagerFactory.getInstance(alg); \n\t\t kmFact.init(ks, CERT_STORE_PASSWORD.toCharArray()); \n\n\t\t KeyManager[] kms=kmFact.getKeyManagers(); \n\t\t return kms;\n\t }\n}\n```\n\n像上面单向认证中那样使用它：\n\n```java \n TrustManager[] tm = { new MyX509TrustManager() };\n KeyManager[] km = MyKeyManager.getKeyManagers();\n SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n sslContext.init(km, tm, new java.security.SecureRandom());\n // 从上述SSLContext对象中得到SSLSocketFactory对象\n SSLSocketFactory ssf = sslContext.getSocketFactory();\n\n // 创建URL对象\n URL myURL = new URL(url);\n // 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象\n HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();\n httpsConn.setSSLSocketFactory(ssf);\n```\n\n然后使用HttpsURLConnection就可以使用了。但是此时服务器端还需要配置，因为客户端仅仅是将自己的证书发过去了，服务器应该如何信任它呢？\n\n打开springboot的配置文件application.properties添加以下配置:\n\n#Whether client authentication is wanted (\"want\") or needed (\"need\"). Requires a trust store.\n\nserver.ssl.client-auth=need\n\nserver.ssl.trust-store=serverTrust.jks \n\nserver.ssl.trust-store-password=123456\n\n其中，serverTrust.jks就是刚刚生成的服务器端信任库。\n\n以上步骤全部做完，服务器和客户端就可以愉快的使用Https进行双向认证通信了。\n\n## 关于证书的一些格式\n\n在使用keytool和openssl的时候，会发现有好多种格式让人头晕眼花。不妨参考这篇文章：[那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)](http://www.cnblogs.com/guogangj/p/4118605.html)\n\n我现在也不是理解的十分清楚，故不再赘述。\n\n## 总结\n\n感觉这篇博客没有把自己想要总结的内容全部记录下来，但是现在也不想再写了。服务器实际测试的时候是使用curl这样一个命令行浏览器进行的，使用curl作为客户端进行双向认证的时候也遇到了不少问题，总结了一份配置的[readme](https://github.com/Hikyu/SSL-Configuration/blob/master/ssl%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE.md)，放在github上面，以作记录。readme中的配置方法可能还有一些瑕疵，有些格式转换可能会有冗余，但是整个配置是没有问题的，经过了自己的验证。证书这一块内容感觉还不是理解的特别透彻，尤其是ssl协议的交互和证书格式的一些问题，留作以后学习吧！真的不想看了...\n\n## 参考\n\n[数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html):这篇一定要看，总结的很好！\n\n[浏览器和SSL证书通讯过程](http://www.live-in.org/archives/1302.html)\n\n[Java安全通信：HTTPS与SSL](http://www.cnblogs.com/devinzhang/archive/2012/02/28/2371631.html)\n\n[Java 安全套接字编程以及 keytool 使用最佳实践](http://www.ibm.com/developerworks/cn/java/j-lo-socketkeytool/)\n\n[openssl生成SSL证书的流程](http://blog.csdn.net/liuchunming033/article/details/48470575)\n\n[如何添加自签名SSL证书 自签名SSL证书存风险](https://freessl.wosign.com/911.html)\n\n[keystore提取私钥和证书(重要×××)](http://www.360doc.com/content/11/1226/02/3700464_174996042.shtml)\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"ssl总结","published":1,"updated":"2016-11-30T14:32:49.909Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj5p001tdigcio4bj0ea","content":"<blockquote>\n<p>这次维护的web服务器要求使用Https双向认证，了解了一下如何在客户端和服务器之间进行ssl的配置，在此记录。另外，这篇日志主要记录如何使用，并不深入底层原理。</p>\n</blockquote>\n<h2 id=\"简单认识ssl和证书\"><a href=\"#简单认识ssl和证书\" class=\"headerlink\" title=\"简单认识ssl和证书\"></a>简单认识ssl和证书</h2><p>在理解这部分内容之前，建议先看看前面对的一篇总结：<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a></p>\n<p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</p>\n<p>SSL协议提供的服务主要有：</p>\n<p>1、认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>\n<p>2、加密数据以防止数据中途被窃取；</p>\n<p>3、维护数据的完整性，确保数据在传输过程中不被改变。</p>\n<p>其实，ssl就是一种协议。我们知道Http协议是明文传输的，安全性不高。Https就是在Http基础之上加一层ssl协议，来达到加密通信的目的。具体的ssl握手过程，可以参考<a href=\"http://baike.baidu.com/view/14121.htm#6\" target=\"_blank\" rel=\"external\">百度百科</a></p>\n<p>附上一张图方便理解：</p>\n<img src=\"/2016/09/25/ssl总结/sslprocess.jpg\" alt=\"sslprocess\" title=\"sslprocess\">\n<p>图片来自网络</p>\n<p>可以看到ssl握手过程中服务器向客户端发送了自己的证书。这个证书是加密过程的重要内容。在前面的<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a>这篇博客中，在关于数字证书的一节，我们知道了数字证书可以证明服务器的身份，服务器证书中包含了服务器的公钥，用于之后的通信。</p>\n<p>那么，简单了解下证书的工作原理。</p>\n<p>首先看一下证书中有哪些内容：</p>\n<img src=\"/2016/09/25/ssl总结/zhifubao.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<img src=\"/2016/09/25/ssl总结/zhufubao1.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<img src=\"/2016/09/25/ssl总结/zhufubao2.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<p>上面是我从谷chorme浏览器中截取的支付宝所使用证书的信息截图。</p>\n<p>可以看到，里面有颁发者和使用者。颁发者就是颁发此证书的CA(证书颁发机构),使用者就是与我们通信的服务器，也就是该证书的持有者。证书中还包含了我们上面提到的公钥。</p>\n<p>我们知道，证书能够证明服务器的身份，那么他是如何证明的呢？我们以浏览器为例：</p>\n<p>首先，浏览器(客户端)接收到服务器发来的证书A之后，会去验证这个证书A是否被篡改或者是伪造的。浏览器首先会去操作系统中内置根证书库中搜索A的颁发者的证书。关于这一点要解释一下，数字证书的颁发机构也有自己的证书，这个证书就是根证书，这个根证书在我的系统刚安装好时，就被微软等公司默认安装在操作系统当中了。</p>\n<p>如果在操作系统中找到了服务器证书中的颁发者的证书Root，那么继续下一步，否则，就知道这个服务器证书的颁发者是个不受信任的CA发布的，此时，浏览器会给出警告。若我们选择相信这个CA并继续，则继续下一步。</p>\n<p>接下来，浏览器从Root中得到Root的公钥，然后用该公钥对A中的指纹算法和指纹进行解密。注意，为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。</p>\n<p>那么什么是指纹算法和指纹呢？这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。</p>\n<p>此时就可以判断该证书是否是仿冒或者经过伪造篡改的。如没有，则证明这个服务器是可信任的。接下来就可以使用该服务器提供的公钥来进行通信了。</p>\n<p>通过上面的分析我们知道了，ssl协议中，首先通过证书来证明服务器的身份，然后取出证书中的公钥，接下来就可以按照<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a>这篇博客中说到的通信方式通信了。这大概上就是ssl的原理，当然实际中ssl的细节还是要复杂很多。</p>\n<p>了解了ssl的基本原理，对我们实现服务器的https通信有很大的帮助。</p>\n<h2 id=\"Https-单向认证\"><a href=\"#Https-单向认证\" class=\"headerlink\" title=\"Https 单向认证\"></a>Https 单向认证</h2><p>单向认证就是服务器必须向客户端发送自己的证书来证明自己的身份，然后进行加密通信。现在服务器的基础框架是springboot，演示如何配置服务器和客户端：</p>\n<p>服务器：</p>\n<p>打开springboot的配置文件application.properties:</p>\n<p>server.ssl.key-store=server.keystore</p>\n<p>server.ssl.key-store-password=123456</p>\n<p>server.ssl.keyStoreType=JKS</p>\n<p>server.ssl.keyAlias:server</p>\n<p>先解释一下上面几个配置：</p>\n<p>.keystore: keystore文件中存储了密钥和证书。密钥包括私钥和公钥，而证书中只包含公钥。这个证书就是我们上面所说的证书。注意：密钥和证书是一一对应的。</p>\n<p>password: 生成keystore文件时所填的密码。</p>\n<p>keyStoreType: keystore类型。</p>\n<p>keyAlias: 生成密钥的别名。</p>\n<p>keysotre文件是怎么生成的呢？使用jdk自带的工具：keytool。生成keystore文件的命令如下：</p>\n<p><code>keytool -genkey -alias server -keyalg RSA -validity 365 -keystore server.keystore</code></p>\n<p>其中：-alias 指定生成密钥的别名，-keystore 指定生成的keystore文件的位置和名称。其他的参数的含义可以通过keytool -help来查找。</p>\n<p>一个keystore文件中可以存储多个证书和证书对应的密钥，这些证书和其对应的密钥通过唯一的别名alias来指定，也就是说，通过alias可以导出证书。但是要注意，无法通过keytool导出私钥。</p>\n<p>看一下如何从keystore文件中导出证书：</p>\n<p><code>keytool -export -alias server -keystore server.keystore -file serverCA.crt</code></p>\n<p>-alias指定了要导出的证书文件，-file 指定了要导出的证书文件的位置和名称。</p>\n<p>了解了上面的几个配置，再结合之前对ssl原理的总结，不难知道：</p>\n<p>我们指定的别名(server.ssl.keyAlias:server)之后,服务器通过该别名从keystore文件中获得对应的证书，并将其发送给客户端，同时使用keystore中alias对应的私钥(keytool虽然导不出私钥，但可以通过代码等方式获得)可以对与客户端通信的内容进行加密和解密。这便是keystore文件的作用：存储证书和私钥。</p>\n<p>服务器端的配置完成了。现在有一个问题，虽然服务器可以发送证书到客户端了，但是客户端并不会信任我们这个证书。如果这个时候通过浏览器以https的方式访问服务器，浏览器会提醒你，此连接不受信任。那是因为虽然服务器将证书发送到了浏览器(客户端)，但是浏览器并不认为这个证书能够证明服务器的身份。那为什么https访问支付宝等网站没有报这个警告呢？想想上面的内容，浏览器或操作系统内置了颁发给支付宝证书的机构的根证书，通过这个根证书的公钥对支付宝发来的证书进行解密可以证明这个证书确实是由支付宝发过来的，从而证明了服务器的身份。</p>\n<p>虽然浏览器并不能验证我们的证书，我们可以手动的把证书添加到浏览器的信任列表中。这个证书就是我们上面通过keytool导出的证书，将这个证书手动添加到浏览器信任列表里面，再次访问服务器就不会有警告啦。(具体的添加方式不再赘述)(从这点上也可以看出自签名证书的不安全性，有可能被假冒和伪造)</p>\n<p>so,通过上面的方式我们已经将ssl单向验证配置好了。那么，如果客户端是自己用java写的呢？下面举一个例子，使用HttpsURLConnection实现：</p>\n<p>首先生成客户端的信任证书库，用来存放客户端所信任的证书：</p>\n<p><code>keytool -keystore truststore.jks -alias client -import -trustcacerts -file serverCA.crt</code></p>\n<p>-file 指定要信任的证书，此例中应该是我们上面导出的证书serverCA.crt</p>\n<p>-keystore 指定要生成的信任库路径和名称。</p>\n<p>然后生成我们自己的信任证书管理器：</p>\n<p>参考了网上的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyX509TrustManager</span> <span class=\"keyword\">implements</span> <span class=\"title\">X509TrustManager</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t * The default X509TrustManager returned by SunX509. We'll delegate</div><div class=\"line\">\t * decisions to it, and fall back to the logic in this class if the default</div><div class=\"line\">\t * X509TrustManager doesn't trust it.</div><div class=\"line\">\t */</div><div class=\"line\">\tX509TrustManager sunJSSEX509TrustManager;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyX509TrustManager</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// create a \"default\" JSSE X509TrustManager.</span></div><div class=\"line\">\t\tKeyStore ks = KeyStore.getInstance(<span class=\"string\">\"JKS\"</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//注意 src/clientTrustCA.jks就是上面生成的信任证书库</span></div><div class=\"line\">\t\tks.load(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"src/clientTrustCA.jks\"</span>), <span class=\"string\">\"123456\"</span>.toCharArray());</div><div class=\"line\">\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(<span class=\"string\">\"SunX509\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">\t\ttmf.init(ks);</div><div class=\"line\">\t\tTrustManager tms[] = tmf.getTrustManagers();</div><div class=\"line\">\t\t<span class=\"comment\">/*</span></div><div class=\"line\">\t\t * Iterate over the returned trustmanagers, look for an instance of</div><div class=\"line\">\t\t * X509TrustManager. If found, use that as our \"default\" trust manager.</div><div class=\"line\">\t\t */</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tms.length; i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tms[i] <span class=\"keyword\">instanceof</span> X509TrustManager) &#123;</div><div class=\"line\">\t\t\t\tsunJSSEX509TrustManager = (X509TrustManager) tms[i];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">/*</span></div><div class=\"line\">\t\t * Find some other way to initialize, or else we have to fail the</div><div class=\"line\">\t\t * constructor.</div><div class=\"line\">\t\t */</div><div class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Couldn't initialize\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t * Delegate to the default trust manager.</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkClientTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsunJSSEX509TrustManager.checkClientTrusted(chain, authType);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CertificateException excep) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// do any special handling here, or rethrow exception.</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t * Delegate to the default trust manager.</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkServerTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsunJSSEX509TrustManager.checkServerTrusted(chain, authType);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CertificateException excep) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">/*</span></div><div class=\"line\">\t\t\t * Possibly pop up a dialog box asking whether to trust the cert</div><div class=\"line\">\t\t\t * chain.</div><div class=\"line\">\t\t\t */</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t * Merely pass this through.</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"keyword\">public</span> X509Certificate[] getAcceptedIssuers() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> sunJSSEX509TrustManager.getAcceptedIssuers();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接着使用这个管理器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManager[] tm = &#123; <span class=\"keyword\">new</span> MyX509TrustManager() &#125;;</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(<span class=\"string\">\"SSL\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">sslContext.init(<span class=\"keyword\">null</span>, tm, <span class=\"keyword\">new</span> java.security.SecureRandom());</div><div class=\"line\"><span class=\"comment\">// 从上述SSLContext对象中得到SSLSocketFactory对象</span></div><div class=\"line\">SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建URL对象</span></div><div class=\"line\">URL myURL = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\"><span class=\"comment\">// 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></div><div class=\"line\">HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();</div><div class=\"line\">httpsConn.setSSLSocketFactory(ssf);</div></pre></td></tr></table></figure>\n<p>接下来就可以使用这个HttpsURLConnection来访问服务器啦。</p>\n<h2 id=\"Https双向认证\"><a href=\"#Https双向认证\" class=\"headerlink\" title=\"Https双向认证\"></a>Https双向认证</h2><p>所谓的Https双向认证就是不仅仅客户端要验证浏览器的身份，浏览器也要向服务器证明自己的身份，也就是第一幅图片中的5。</p>\n<p>理解了单向认证，双向认证实现起来也就不难了。</p>\n<p>首先像我们之前一样使用keytool生成keystore文件client.keystore，这个文件是为客户端使用准备的。</p>\n<p>然后通过client.keystore导出证书client.crt。</p>\n<p>接着生成信任库文件serverTrust.jks,将client.crt导入其中。</p>\n<p>在单向认证中我们给出了客户端单向认证时的java代码，用来下面给出双向认证的代码：</p>\n<p>生成读取keystore的类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyKeyManager</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 相关的 jks 文件及其密码定义</span></div><div class=\"line\">\t <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CERT_STORE=<span class=\"string\">\"src/client.keystore\"</span>;</div><div class=\"line\">\t <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CERT_STORE_PASSWORD=<span class=\"string\">\"123456\"</span>;</div><div class=\"line\">\t </div><div class=\"line\">\t <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> KeyManager[] getKeyManagers() <span class=\"keyword\">throws</span> Exception&#123;</div><div class=\"line\">\t\t <span class=\"comment\">// 载入 jks 文件</span></div><div class=\"line\">\t\t FileInputStream f_certStore=<span class=\"keyword\">new</span> FileInputStream(CERT_STORE); </div><div class=\"line\">\t\t KeyStore ks=KeyStore.getInstance(<span class=\"string\">\"jks\"</span>); </div><div class=\"line\">\t\t ks.load(f_certStore, CERT_STORE_PASSWORD.toCharArray()); </div><div class=\"line\">\t\t f_certStore.close(); </div><div class=\"line\"></div><div class=\"line\">\t\t <span class=\"comment\">// 创建并初始化证书库工厂</span></div><div class=\"line\">\t\t String alg=KeyManagerFactory.getDefaultAlgorithm(); </div><div class=\"line\">\t\t KeyManagerFactory kmFact=KeyManagerFactory.getInstance(alg); </div><div class=\"line\">\t\t kmFact.init(ks, CERT_STORE_PASSWORD.toCharArray()); </div><div class=\"line\"></div><div class=\"line\">\t\t KeyManager[] kms=kmFact.getKeyManagers(); </div><div class=\"line\">\t\t <span class=\"keyword\">return</span> kms;</div><div class=\"line\">\t &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面单向认证中那样使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManager[] tm = &#123; <span class=\"keyword\">new</span> MyX509TrustManager() &#125;;</div><div class=\"line\">KeyManager[] km = MyKeyManager.getKeyManagers();</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(<span class=\"string\">\"SSL\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">sslContext.init(km, tm, <span class=\"keyword\">new</span> java.security.SecureRandom());</div><div class=\"line\"><span class=\"comment\">// 从上述SSLContext对象中得到SSLSocketFactory对象</span></div><div class=\"line\">SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建URL对象</span></div><div class=\"line\">URL myURL = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\"><span class=\"comment\">// 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></div><div class=\"line\">HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();</div><div class=\"line\">httpsConn.setSSLSocketFactory(ssf);</div></pre></td></tr></table></figure>\n<p>然后使用HttpsURLConnection就可以使用了。但是此时服务器端还需要配置，因为客户端仅仅是将自己的证书发过去了，服务器应该如何信任它呢？</p>\n<p>打开springboot的配置文件application.properties添加以下配置:</p>\n<p>#Whether client authentication is wanted (“want”) or needed (“need”). Requires a trust store.</p>\n<p>server.ssl.client-auth=need</p>\n<p>server.ssl.trust-store=serverTrust.jks </p>\n<p>server.ssl.trust-store-password=123456</p>\n<p>其中，serverTrust.jks就是刚刚生成的服务器端信任库。</p>\n<p>以上步骤全部做完，服务器和客户端就可以愉快的使用Https进行双向认证通信了。</p>\n<h2 id=\"关于证书的一些格式\"><a href=\"#关于证书的一些格式\" class=\"headerlink\" title=\"关于证书的一些格式\"></a>关于证书的一些格式</h2><p>在使用keytool和openssl的时候，会发现有好多种格式让人头晕眼花。不妨参考这篇文章：<a href=\"http://www.cnblogs.com/guogangj/p/4118605.html\" target=\"_blank\" rel=\"external\">那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)</a></p>\n<p>我现在也不是理解的十分清楚，故不再赘述。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>感觉这篇博客没有把自己想要总结的内容全部记录下来，但是现在也不想再写了。服务器实际测试的时候是使用curl这样一个命令行浏览器进行的，使用curl作为客户端进行双向认证的时候也遇到了不少问题，总结了一份配置的<a href=\"https://github.com/Hikyu/SSL-Configuration/blob/master/ssl%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE.md\" target=\"_blank\" rel=\"external\">readme</a>，放在github上面，以作记录。readme中的配置方法可能还有一些瑕疵，有些格式转换可能会有冗余，但是整个配置是没有问题的，经过了自己的验证。证书这一块内容感觉还不是理解的特别透彻，尤其是ssl协议的交互和证书格式的一些问题，留作以后学习吧！真的不想看了…</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\" target=\"_blank\" rel=\"external\">数字证书原理</a>:这篇一定要看，总结的很好！</p>\n<p><a href=\"http://www.live-in.org/archives/1302.html\" target=\"_blank\" rel=\"external\">浏览器和SSL证书通讯过程</a></p>\n<p><a href=\"http://www.cnblogs.com/devinzhang/archive/2012/02/28/2371631.html\" target=\"_blank\" rel=\"external\">Java安全通信：HTTPS与SSL</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-socketkeytool/\" target=\"_blank\" rel=\"external\">Java 安全套接字编程以及 keytool 使用最佳实践</a></p>\n<p><a href=\"http://blog.csdn.net/liuchunming033/article/details/48470575\" target=\"_blank\" rel=\"external\">openssl生成SSL证书的流程</a></p>\n<p><a href=\"https://freessl.wosign.com/911.html\" target=\"_blank\" rel=\"external\">如何添加自签名SSL证书 自签名SSL证书存风险</a></p>\n<p><a href=\"http://www.360doc.com/content/11/1226/02/3700464_174996042.shtml\" target=\"_blank\" rel=\"external\">keystore提取私钥和证书(重要×××)</a></p>\n","excerpt":"","more":"<blockquote>\n<p>这次维护的web服务器要求使用Https双向认证，了解了一下如何在客户端和服务器之间进行ssl的配置，在此记录。另外，这篇日志主要记录如何使用，并不深入底层原理。</p>\n</blockquote>\n<h2 id=\"简单认识ssl和证书\"><a href=\"#简单认识ssl和证书\" class=\"headerlink\" title=\"简单认识ssl和证书\"></a>简单认识ssl和证书</h2><p>在理解这部分内容之前，建议先看看前面对的一篇总结：<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a></p>\n<p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</p>\n<p>SSL协议提供的服务主要有：</p>\n<p>1、认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>\n<p>2、加密数据以防止数据中途被窃取；</p>\n<p>3、维护数据的完整性，确保数据在传输过程中不被改变。</p>\n<p>其实，ssl就是一种协议。我们知道Http协议是明文传输的，安全性不高。Https就是在Http基础之上加一层ssl协议，来达到加密通信的目的。具体的ssl握手过程，可以参考<a href=\"http://baike.baidu.com/view/14121.htm#6\">百度百科</a></p>\n<p>附上一张图方便理解：</p>\n<img src=\"/2016/09/25/ssl总结/sslprocess.jpg\" alt=\"sslprocess\" title=\"sslprocess\">\n<p>图片来自网络</p>\n<p>可以看到ssl握手过程中服务器向客户端发送了自己的证书。这个证书是加密过程的重要内容。在前面的<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a>这篇博客中，在关于数字证书的一节，我们知道了数字证书可以证明服务器的身份，服务器证书中包含了服务器的公钥，用于之后的通信。</p>\n<p>那么，简单了解下证书的工作原理。</p>\n<p>首先看一下证书中有哪些内容：</p>\n<img src=\"/2016/09/25/ssl总结/zhifubao.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<img src=\"/2016/09/25/ssl总结/zhufubao1.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<img src=\"/2016/09/25/ssl总结/zhufubao2.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<p>上面是我从谷chorme浏览器中截取的支付宝所使用证书的信息截图。</p>\n<p>可以看到，里面有颁发者和使用者。颁发者就是颁发此证书的CA(证书颁发机构),使用者就是与我们通信的服务器，也就是该证书的持有者。证书中还包含了我们上面提到的公钥。</p>\n<p>我们知道，证书能够证明服务器的身份，那么他是如何证明的呢？我们以浏览器为例：</p>\n<p>首先，浏览器(客户端)接收到服务器发来的证书A之后，会去验证这个证书A是否被篡改或者是伪造的。浏览器首先会去操作系统中内置根证书库中搜索A的颁发者的证书。关于这一点要解释一下，数字证书的颁发机构也有自己的证书，这个证书就是根证书，这个根证书在我的系统刚安装好时，就被微软等公司默认安装在操作系统当中了。</p>\n<p>如果在操作系统中找到了服务器证书中的颁发者的证书Root，那么继续下一步，否则，就知道这个服务器证书的颁发者是个不受信任的CA发布的，此时，浏览器会给出警告。若我们选择相信这个CA并继续，则继续下一步。</p>\n<p>接下来，浏览器从Root中得到Root的公钥，然后用该公钥对A中的指纹算法和指纹进行解密。注意，为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。</p>\n<p>那么什么是指纹算法和指纹呢？这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。</p>\n<p>此时就可以判断该证书是否是仿冒或者经过伪造篡改的。如没有，则证明这个服务器是可信任的。接下来就可以使用该服务器提供的公钥来进行通信了。</p>\n<p>通过上面的分析我们知道了，ssl协议中，首先通过证书来证明服务器的身份，然后取出证书中的公钥，接下来就可以按照<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a>这篇博客中说到的通信方式通信了。这大概上就是ssl的原理，当然实际中ssl的细节还是要复杂很多。</p>\n<p>了解了ssl的基本原理，对我们实现服务器的https通信有很大的帮助。</p>\n<h2 id=\"Https-单向认证\"><a href=\"#Https-单向认证\" class=\"headerlink\" title=\"Https 单向认证\"></a>Https 单向认证</h2><p>单向认证就是服务器必须向客户端发送自己的证书来证明自己的身份，然后进行加密通信。现在服务器的基础框架是springboot，演示如何配置服务器和客户端：</p>\n<p>服务器：</p>\n<p>打开springboot的配置文件application.properties:</p>\n<p>server.ssl.key-store=server.keystore</p>\n<p>server.ssl.key-store-password=123456</p>\n<p>server.ssl.keyStoreType=JKS</p>\n<p>server.ssl.keyAlias:server</p>\n<p>先解释一下上面几个配置：</p>\n<p>.keystore: keystore文件中存储了密钥和证书。密钥包括私钥和公钥，而证书中只包含公钥。这个证书就是我们上面所说的证书。注意：密钥和证书是一一对应的。</p>\n<p>password: 生成keystore文件时所填的密码。</p>\n<p>keyStoreType: keystore类型。</p>\n<p>keyAlias: 生成密钥的别名。</p>\n<p>keysotre文件是怎么生成的呢？使用jdk自带的工具：keytool。生成keystore文件的命令如下：</p>\n<p><code>keytool -genkey -alias server -keyalg RSA -validity 365 -keystore server.keystore</code></p>\n<p>其中：-alias 指定生成密钥的别名，-keystore 指定生成的keystore文件的位置和名称。其他的参数的含义可以通过keytool -help来查找。</p>\n<p>一个keystore文件中可以存储多个证书和证书对应的密钥，这些证书和其对应的密钥通过唯一的别名alias来指定，也就是说，通过alias可以导出证书。但是要注意，无法通过keytool导出私钥。</p>\n<p>看一下如何从keystore文件中导出证书：</p>\n<p><code>keytool -export -alias server -keystore server.keystore -file serverCA.crt</code></p>\n<p>-alias指定了要导出的证书文件，-file 指定了要导出的证书文件的位置和名称。</p>\n<p>了解了上面的几个配置，再结合之前对ssl原理的总结，不难知道：</p>\n<p>我们指定的别名(server.ssl.keyAlias:server)之后,服务器通过该别名从keystore文件中获得对应的证书，并将其发送给客户端，同时使用keystore中alias对应的私钥(keytool虽然导不出私钥，但可以通过代码等方式获得)可以对与客户端通信的内容进行加密和解密。这便是keystore文件的作用：存储证书和私钥。</p>\n<p>服务器端的配置完成了。现在有一个问题，虽然服务器可以发送证书到客户端了，但是客户端并不会信任我们这个证书。如果这个时候通过浏览器以https的方式访问服务器，浏览器会提醒你，此连接不受信任。那是因为虽然服务器将证书发送到了浏览器(客户端)，但是浏览器并不认为这个证书能够证明服务器的身份。那为什么https访问支付宝等网站没有报这个警告呢？想想上面的内容，浏览器或操作系统内置了颁发给支付宝证书的机构的根证书，通过这个根证书的公钥对支付宝发来的证书进行解密可以证明这个证书确实是由支付宝发过来的，从而证明了服务器的身份。</p>\n<p>虽然浏览器并不能验证我们的证书，我们可以手动的把证书添加到浏览器的信任列表中。这个证书就是我们上面通过keytool导出的证书，将这个证书手动添加到浏览器信任列表里面，再次访问服务器就不会有警告啦。(具体的添加方式不再赘述)(从这点上也可以看出自签名证书的不安全性，有可能被假冒和伪造)</p>\n<p>so,通过上面的方式我们已经将ssl单向验证配置好了。那么，如果客户端是自己用java写的呢？下面举一个例子，使用HttpsURLConnection实现：</p>\n<p>首先生成客户端的信任证书库，用来存放客户端所信任的证书：</p>\n<p><code>keytool -keystore truststore.jks -alias client -import -trustcacerts -file serverCA.crt</code></p>\n<p>-file 指定要信任的证书，此例中应该是我们上面导出的证书serverCA.crt</p>\n<p>-keystore 指定要生成的信任库路径和名称。</p>\n<p>然后生成我们自己的信任证书管理器：</p>\n<p>参考了网上的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyX509TrustManager</span> <span class=\"keyword\">implements</span> <span class=\"title\">X509TrustManager</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">/*</div><div class=\"line\">\t * The default X509TrustManager returned by SunX509. We'll delegate</div><div class=\"line\">\t * decisions to it, and fall back to the logic in this class if the default</div><div class=\"line\">\t * X509TrustManager doesn't trust it.</div><div class=\"line\">\t */</span></div><div class=\"line\">\tX509TrustManager sunJSSEX509TrustManager;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyX509TrustManager</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// create a \"default\" JSSE X509TrustManager.</span></div><div class=\"line\">\t\tKeyStore ks = KeyStore.getInstance(<span class=\"string\">\"JKS\"</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//注意 src/clientTrustCA.jks就是上面生成的信任证书库</span></div><div class=\"line\">\t\tks.load(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"src/clientTrustCA.jks\"</span>), <span class=\"string\">\"123456\"</span>.toCharArray());</div><div class=\"line\">\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(<span class=\"string\">\"SunX509\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">\t\ttmf.init(ks);</div><div class=\"line\">\t\tTrustManager tms[] = tmf.getTrustManagers();</div><div class=\"line\">\t\t<span class=\"comment\">/*</div><div class=\"line\">\t\t * Iterate over the returned trustmanagers, look for an instance of</div><div class=\"line\">\t\t * X509TrustManager. If found, use that as our \"default\" trust manager.</div><div class=\"line\">\t\t */</span></div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tms.length; i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tms[i] <span class=\"keyword\">instanceof</span> X509TrustManager) &#123;</div><div class=\"line\">\t\t\t\tsunJSSEX509TrustManager = (X509TrustManager) tms[i];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">/*</div><div class=\"line\">\t\t * Find some other way to initialize, or else we have to fail the</div><div class=\"line\">\t\t * constructor.</div><div class=\"line\">\t\t */</span></div><div class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Couldn't initialize\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</div><div class=\"line\">\t * Delegate to the default trust manager.</div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkClientTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsunJSSEX509TrustManager.checkClientTrusted(chain, authType);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CertificateException excep) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// do any special handling here, or rethrow exception.</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</div><div class=\"line\">\t * Delegate to the default trust manager.</div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkServerTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsunJSSEX509TrustManager.checkServerTrusted(chain, authType);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CertificateException excep) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">/*</div><div class=\"line\">\t\t\t * Possibly pop up a dialog box asking whether to trust the cert</div><div class=\"line\">\t\t\t * chain.</div><div class=\"line\">\t\t\t */</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</div><div class=\"line\">\t * Merely pass this through.</div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> X509Certificate[] getAcceptedIssuers() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> sunJSSEX509TrustManager.getAcceptedIssuers();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接着使用这个管理器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManager[] tm = &#123; <span class=\"keyword\">new</span> MyX509TrustManager() &#125;;</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(<span class=\"string\">\"SSL\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">sslContext.init(<span class=\"keyword\">null</span>, tm, <span class=\"keyword\">new</span> java.security.SecureRandom());</div><div class=\"line\"><span class=\"comment\">// 从上述SSLContext对象中得到SSLSocketFactory对象</span></div><div class=\"line\">SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建URL对象</span></div><div class=\"line\">URL myURL = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\"><span class=\"comment\">// 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></div><div class=\"line\">HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();</div><div class=\"line\">httpsConn.setSSLSocketFactory(ssf);</div></pre></td></tr></table></figure>\n<p>接下来就可以使用这个HttpsURLConnection来访问服务器啦。</p>\n<h2 id=\"Https双向认证\"><a href=\"#Https双向认证\" class=\"headerlink\" title=\"Https双向认证\"></a>Https双向认证</h2><p>所谓的Https双向认证就是不仅仅客户端要验证浏览器的身份，浏览器也要向服务器证明自己的身份，也就是第一幅图片中的5。</p>\n<p>理解了单向认证，双向认证实现起来也就不难了。</p>\n<p>首先像我们之前一样使用keytool生成keystore文件client.keystore，这个文件是为客户端使用准备的。</p>\n<p>然后通过client.keystore导出证书client.crt。</p>\n<p>接着生成信任库文件serverTrust.jks,将client.crt导入其中。</p>\n<p>在单向认证中我们给出了客户端单向认证时的java代码，用来下面给出双向认证的代码：</p>\n<p>生成读取keystore的类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyKeyManager</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 相关的 jks 文件及其密码定义</span></div><div class=\"line\">\t <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CERT_STORE=<span class=\"string\">\"src/client.keystore\"</span>;</div><div class=\"line\">\t <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CERT_STORE_PASSWORD=<span class=\"string\">\"123456\"</span>;</div><div class=\"line\">\t </div><div class=\"line\">\t <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> KeyManager[] getKeyManagers() <span class=\"keyword\">throws</span> Exception&#123;</div><div class=\"line\">\t\t <span class=\"comment\">// 载入 jks 文件</span></div><div class=\"line\">\t\t FileInputStream f_certStore=<span class=\"keyword\">new</span> FileInputStream(CERT_STORE); </div><div class=\"line\">\t\t KeyStore ks=KeyStore.getInstance(<span class=\"string\">\"jks\"</span>); </div><div class=\"line\">\t\t ks.load(f_certStore, CERT_STORE_PASSWORD.toCharArray()); </div><div class=\"line\">\t\t f_certStore.close(); </div><div class=\"line\"></div><div class=\"line\">\t\t <span class=\"comment\">// 创建并初始化证书库工厂</span></div><div class=\"line\">\t\t String alg=KeyManagerFactory.getDefaultAlgorithm(); </div><div class=\"line\">\t\t KeyManagerFactory kmFact=KeyManagerFactory.getInstance(alg); </div><div class=\"line\">\t\t kmFact.init(ks, CERT_STORE_PASSWORD.toCharArray()); </div><div class=\"line\"></div><div class=\"line\">\t\t KeyManager[] kms=kmFact.getKeyManagers(); </div><div class=\"line\">\t\t <span class=\"keyword\">return</span> kms;</div><div class=\"line\">\t &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面单向认证中那样使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManager[] tm = &#123; <span class=\"keyword\">new</span> MyX509TrustManager() &#125;;</div><div class=\"line\">KeyManager[] km = MyKeyManager.getKeyManagers();</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(<span class=\"string\">\"SSL\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">sslContext.init(km, tm, <span class=\"keyword\">new</span> java.security.SecureRandom());</div><div class=\"line\"><span class=\"comment\">// 从上述SSLContext对象中得到SSLSocketFactory对象</span></div><div class=\"line\">SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建URL对象</span></div><div class=\"line\">URL myURL = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\"><span class=\"comment\">// 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></div><div class=\"line\">HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();</div><div class=\"line\">httpsConn.setSSLSocketFactory(ssf);</div></pre></td></tr></table></figure>\n<p>然后使用HttpsURLConnection就可以使用了。但是此时服务器端还需要配置，因为客户端仅仅是将自己的证书发过去了，服务器应该如何信任它呢？</p>\n<p>打开springboot的配置文件application.properties添加以下配置:</p>\n<p>#Whether client authentication is wanted (“want”) or needed (“need”). Requires a trust store.</p>\n<p>server.ssl.client-auth=need</p>\n<p>server.ssl.trust-store=serverTrust.jks </p>\n<p>server.ssl.trust-store-password=123456</p>\n<p>其中，serverTrust.jks就是刚刚生成的服务器端信任库。</p>\n<p>以上步骤全部做完，服务器和客户端就可以愉快的使用Https进行双向认证通信了。</p>\n<h2 id=\"关于证书的一些格式\"><a href=\"#关于证书的一些格式\" class=\"headerlink\" title=\"关于证书的一些格式\"></a>关于证书的一些格式</h2><p>在使用keytool和openssl的时候，会发现有好多种格式让人头晕眼花。不妨参考这篇文章：<a href=\"http://www.cnblogs.com/guogangj/p/4118605.html\">那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)</a></p>\n<p>我现在也不是理解的十分清楚，故不再赘述。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>感觉这篇博客没有把自己想要总结的内容全部记录下来，但是现在也不想再写了。服务器实际测试的时候是使用curl这样一个命令行浏览器进行的，使用curl作为客户端进行双向认证的时候也遇到了不少问题，总结了一份配置的<a href=\"https://github.com/Hikyu/SSL-Configuration/blob/master/ssl%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE.md\">readme</a>，放在github上面，以作记录。readme中的配置方法可能还有一些瑕疵，有些格式转换可能会有冗余，但是整个配置是没有问题的，经过了自己的验证。证书这一块内容感觉还不是理解的特别透彻，尤其是ssl协议的交互和证书格式的一些问题，留作以后学习吧！真的不想看了…</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\">数字证书原理</a>:这篇一定要看，总结的很好！</p>\n<p><a href=\"http://www.live-in.org/archives/1302.html\">浏览器和SSL证书通讯过程</a></p>\n<p><a href=\"http://www.cnblogs.com/devinzhang/archive/2012/02/28/2371631.html\">Java安全通信：HTTPS与SSL</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-socketkeytool/\">Java 安全套接字编程以及 keytool 使用最佳实践</a></p>\n<p><a href=\"http://blog.csdn.net/liuchunming033/article/details/48470575\">openssl生成SSL证书的流程</a></p>\n<p><a href=\"https://freessl.wosign.com/911.html\">如何添加自签名SSL证书 自签名SSL证书存风险</a></p>\n<p><a href=\"http://www.360doc.com/content/11/1226/02/3700464_174996042.shtml\">keystore提取私钥和证书(重要×××)</a></p>\n"},{"layout":"post","date":"2016-08-15T06:54:55.000Z","title":"一些计划","comments":0,"_content":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe>\n转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。\n\n上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的[作者](https://github.com/A-limon/pacman)，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名[www.yukai.space](www.yukai.space)作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。\n\n## 关于学习\n\n程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：\n\n### java\n\n吃饭的家伙，必须得用好了。虽然用java写过不少\"小DEMO\",但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：\n\n- Thinking In Java\n\n- Effect Java\n\n- 大话设计模式\n\n- 深入理解Jvm虚拟机\n\n- 重构：改善既有的代码\n\n前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。\n\n### Linux\n\n一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。\n\n从 鸟哥的Linux私房菜 开始吧。\n\n### Groovy\n\n第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。\n\n### 数据库\n\n说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把<<数据库系统概论>>通读一遍吧。贪多嚼不烂。\n\n以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。\n\n## 关于减肥\n\n确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：\n\n腹肌轮：80\n\n卷腹：50\n\n哑铃深蹲：40\n\n俯卧撑：80\n\n其他健身动作：若干\n\n跑步：一周至少三次\n\n## 关于理财\n\n写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。\n\n写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。\n\n以上","source":"_posts/一些计划.md","raw":"---\nlayout: post\ndate: 2016-08-15 14:54:55\ncategories: 生活\ntitle: 一些计划\ncomments: false\n---\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe>\n转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。\n\n上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的[作者](https://github.com/A-limon/pacman)，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名[www.yukai.space](www.yukai.space)作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。\n\n## 关于学习\n\n程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：\n\n### java\n\n吃饭的家伙，必须得用好了。虽然用java写过不少\"小DEMO\",但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：\n\n- Thinking In Java\n\n- Effect Java\n\n- 大话设计模式\n\n- 深入理解Jvm虚拟机\n\n- 重构：改善既有的代码\n\n前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。\n\n### Linux\n\n一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。\n\n从 鸟哥的Linux私房菜 开始吧。\n\n### Groovy\n\n第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。\n\n### 数据库\n\n说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把<<数据库系统概论>>通读一遍吧。贪多嚼不烂。\n\n以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。\n\n## 关于减肥\n\n确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：\n\n腹肌轮：80\n\n卷腹：50\n\n哑铃深蹲：40\n\n俯卧撑：80\n\n其他健身动作：若干\n\n跑步：一周至少三次\n\n## 关于理财\n\n写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。\n\n写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。\n\n以上","slug":"一些计划","published":1,"updated":"2016-11-30T14:32:49.909Z","photos":[],"link":"","_id":"ciyvmgj5u001wdigcsk92xxkz","content":"<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe><br>转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。</p>\n<p>上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的<a href=\"https://github.com/A-limon/pacman\" target=\"_blank\" rel=\"external\">作者</a>，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名<a href=\"www.yukai.space\">www.yukai.space</a>作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。</p>\n<h2 id=\"关于学习\"><a href=\"#关于学习\" class=\"headerlink\" title=\"关于学习\"></a>关于学习</h2><p>程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：</p>\n<h3 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h3><p>吃饭的家伙，必须得用好了。虽然用java写过不少”小DEMO”,但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：</p>\n<ul>\n<li><p>Thinking In Java</p>\n</li>\n<li><p>Effect Java</p>\n</li>\n<li><p>大话设计模式</p>\n</li>\n<li><p>深入理解Jvm虚拟机</p>\n</li>\n<li><p>重构：改善既有的代码</p>\n</li>\n</ul>\n<p>前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。</p>\n<h3 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h3><p>一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。</p>\n<p>从 鸟哥的Linux私房菜 开始吧。</p>\n<h3 id=\"Groovy\"><a href=\"#Groovy\" class=\"headerlink\" title=\"Groovy\"></a>Groovy</h3><p>第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。</p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把&lt;&lt;数据库系统概论&gt;&gt;通读一遍吧。贪多嚼不烂。</p>\n<p>以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。</p>\n<h2 id=\"关于减肥\"><a href=\"#关于减肥\" class=\"headerlink\" title=\"关于减肥\"></a>关于减肥</h2><p>确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：</p>\n<p>腹肌轮：80</p>\n<p>卷腹：50</p>\n<p>哑铃深蹲：40</p>\n<p>俯卧撑：80</p>\n<p>其他健身动作：若干</p>\n<p>跑步：一周至少三次</p>\n<h2 id=\"关于理财\"><a href=\"#关于理财\" class=\"headerlink\" title=\"关于理财\"></a>关于理财</h2><p>写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。</p>\n<p>写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。</p>\n<p>以上</p>\n","excerpt":"","more":"<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe><br>转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。</p>\n<p>上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的<a href=\"https://github.com/A-limon/pacman\">作者</a>，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名<a href=\"www.yukai.space\">www.yukai.space</a>作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。</p>\n<h2 id=\"关于学习\"><a href=\"#关于学习\" class=\"headerlink\" title=\"关于学习\"></a>关于学习</h2><p>程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：</p>\n<h3 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h3><p>吃饭的家伙，必须得用好了。虽然用java写过不少”小DEMO”,但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：</p>\n<ul>\n<li><p>Thinking In Java</p>\n</li>\n<li><p>Effect Java</p>\n</li>\n<li><p>大话设计模式</p>\n</li>\n<li><p>深入理解Jvm虚拟机</p>\n</li>\n<li><p>重构：改善既有的代码</p>\n</li>\n</ul>\n<p>前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。</p>\n<h3 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h3><p>一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。</p>\n<p>从 鸟哥的Linux私房菜 开始吧。</p>\n<h3 id=\"Groovy\"><a href=\"#Groovy\" class=\"headerlink\" title=\"Groovy\"></a>Groovy</h3><p>第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。</p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把&lt;&lt;数据库系统概论&gt;&gt;通读一遍吧。贪多嚼不烂。</p>\n<p>以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。</p>\n<h2 id=\"关于减肥\"><a href=\"#关于减肥\" class=\"headerlink\" title=\"关于减肥\"></a>关于减肥</h2><p>确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：</p>\n<p>腹肌轮：80</p>\n<p>卷腹：50</p>\n<p>哑铃深蹲：40</p>\n<p>俯卧撑：80</p>\n<p>其他健身动作：若干</p>\n<p>跑步：一周至少三次</p>\n<h2 id=\"关于理财\"><a href=\"#关于理财\" class=\"headerlink\" title=\"关于理财\"></a>关于理财</h2><p>写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。</p>\n<p>写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。</p>\n<p>以上</p>\n"},{"layout":"post","date":"2016-07-31T09:30:55.000Z","title":"为什么是final","_content":"\n>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。\n\n注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。\n\n例子是这样的：\n\n```java\npublic class Outer {\n\tprivate int outerVar=0;\n\tpublic void testInner(final String paramVal){\n\t\tfinal Integer localVal = 1;\n\t\tInner inner = new Inner(){\n\t\t\t@Override\n\t\t\tpublic void doSomething() {\n\t\t\t\tSystem.out.println(localVal+paramVal);\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tfinal int localVal1 = 2;\n\t\tclass Inner2{\n\t\t\tpublic void testInner2(){\n\t\t\t\tSystem.out.println(localVal1);\n\t\t\t}\n\t\t}\n\t}\n\tinterface Inner{\n\t\tpublic void doSomething();\n\t}\n\tpublic static void main(String args[]){\n\t\tOuter outer = new Outer();\n\t\touter.testInner(\"hello\");\n\t}\n}\n```\n\n可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。\n\n后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。\n\n我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）\n\n但是确实生成了这样几个.class文件：\n\nOuter.class:class Outer\n\nOuter$1.class:匿名内部类 new Inner(){...}\n\nOuter$1Inner2.class:class Inner2\n\nOuter$Inner.class:interface Inner\n\n这说明，匿名内部类与他的外围类之间确实是相互独立的。\n\n为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：\n\n```java\nclass kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner {\n  final java.lang.Integer val$localVar;\n\n  final java.lang.String val$paramVal;\n\n  final kyu.java.util.Outer this$0;\n\n  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);\n    Code:\n       0: aload_0\n       1: aload_1\n       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;\n       5: aload_0\n       6: aload_2\n       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;\n      10: aload_0\n      11: aload_3\n      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;\n      15: aload_0\n      16: invokespecial #4                  // Method java/lang/Object.\"<init>\":()V\n      19: return\n\n      .....\n }\n```\n\n上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参\n。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。\n\n所以，现在有两个问题：\n\n- **为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？**\n\n我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。\n\n- **局部变量或形参为什么必须是final类型？**\n\n在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。\n\n```java\nfinal Integer localVal = 1;\nInner inner = new Inner(){\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(localVar+paramVal);\n\t}\n};\n```\n\n这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。\n\nps:后来在stackoverflow上看到[Why are only final variables accessible in anonymous class?](http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class)，可以参考一下。","source":"_posts/为什么是final.md","raw":"---\nlayout: post\ndate:   2016-07-31 17:30:55\ntitle: \"为什么是final\"\ncategories: 编程\ntags: \n- java\n---\n\n>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。\n\n注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。\n\n例子是这样的：\n\n```java\npublic class Outer {\n\tprivate int outerVar=0;\n\tpublic void testInner(final String paramVal){\n\t\tfinal Integer localVal = 1;\n\t\tInner inner = new Inner(){\n\t\t\t@Override\n\t\t\tpublic void doSomething() {\n\t\t\t\tSystem.out.println(localVal+paramVal);\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tfinal int localVal1 = 2;\n\t\tclass Inner2{\n\t\t\tpublic void testInner2(){\n\t\t\t\tSystem.out.println(localVal1);\n\t\t\t}\n\t\t}\n\t}\n\tinterface Inner{\n\t\tpublic void doSomething();\n\t}\n\tpublic static void main(String args[]){\n\t\tOuter outer = new Outer();\n\t\touter.testInner(\"hello\");\n\t}\n}\n```\n\n可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。\n\n后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。\n\n我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）\n\n但是确实生成了这样几个.class文件：\n\nOuter.class:class Outer\n\nOuter$1.class:匿名内部类 new Inner(){...}\n\nOuter$1Inner2.class:class Inner2\n\nOuter$Inner.class:interface Inner\n\n这说明，匿名内部类与他的外围类之间确实是相互独立的。\n\n为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：\n\n```java\nclass kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner {\n  final java.lang.Integer val$localVar;\n\n  final java.lang.String val$paramVal;\n\n  final kyu.java.util.Outer this$0;\n\n  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);\n    Code:\n       0: aload_0\n       1: aload_1\n       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;\n       5: aload_0\n       6: aload_2\n       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;\n      10: aload_0\n      11: aload_3\n      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;\n      15: aload_0\n      16: invokespecial #4                  // Method java/lang/Object.\"<init>\":()V\n      19: return\n\n      .....\n }\n```\n\n上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参\n。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。\n\n所以，现在有两个问题：\n\n- **为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？**\n\n我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。\n\n- **局部变量或形参为什么必须是final类型？**\n\n在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。\n\n```java\nfinal Integer localVal = 1;\nInner inner = new Inner(){\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(localVar+paramVal);\n\t}\n};\n```\n\n这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。\n\nps:后来在stackoverflow上看到[Why are only final variables accessible in anonymous class?](http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class)，可以参考一下。","slug":"为什么是final","published":1,"updated":"2016-11-30T14:32:49.909Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj5w001zdigcr76ff0ki","content":"<blockquote>\n<p>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。</p>\n</blockquote>\n<p>注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。</p>\n<p>例子是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> outerVar=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner</span><span class=\"params\">(<span class=\"keyword\">final</span> String paramVal)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">\t\tInner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal+paramVal);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localVal1 = <span class=\"number\">2</span>;</div><div class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner2</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal1);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Inner</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tOuter outer = <span class=\"keyword\">new</span> Outer();</div><div class=\"line\">\t\touter.testInner(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。</p>\n<p>后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。</p>\n<p>我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）</p>\n<p>但是确实生成了这样几个.class文件：</p>\n<p>Outer.class:class Outer</p>\n<p>Outer$1.class:匿名内部类 new Inner(){…}</p>\n<p>Outer$1Inner2.class:class Inner2</p>\n<p>Outer$Inner.class:interface Inner</p>\n<p>这说明，匿名内部类与他的外围类之间确实是相互独立的。</p>\n<p>为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner &#123;</div><div class=\"line\">  final java.lang.Integer val$localVar;</div><div class=\"line\"></div><div class=\"line\">  final java.lang.String val$paramVal;</div><div class=\"line\"></div><div class=\"line\">  final kyu.java.util.Outer this$0;</div><div class=\"line\"></div><div class=\"line\">  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);</div><div class=\"line\">    Code:</div><div class=\"line\">       0: aload_0</div><div class=\"line\">       1: aload_1</div><div class=\"line\">       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;</div><div class=\"line\">       5: aload_0</div><div class=\"line\">       6: aload_2</div><div class=\"line\">       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;</div><div class=\"line\">      10: aload_0</div><div class=\"line\">      11: aload_3</div><div class=\"line\">      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;</div><div class=\"line\">      15: aload_0</div><div class=\"line\">      16: invokespecial #4                  // Method java/lang/Object.\"&lt;init&gt;\":()V</div><div class=\"line\">      19: return</div><div class=\"line\"></div><div class=\"line\">      .....</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参<br>。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。</p>\n<p>所以，现在有两个问题：</p>\n<ul>\n<li><strong>为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？</strong></li>\n</ul>\n<p>我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。</p>\n<ul>\n<li><strong>局部变量或形参为什么必须是final类型？</strong></li>\n</ul>\n<p>在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">Inner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(localVar+paramVal);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。</p>\n<p>ps:后来在stackoverflow上看到<a href=\"http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class\" target=\"_blank\" rel=\"external\">Why are only final variables accessible in anonymous class?</a>，可以参考一下。</p>\n","excerpt":"","more":"<blockquote>\n<p>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。</p>\n</blockquote>\n<p>注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。</p>\n<p>例子是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> outerVar=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner</span><span class=\"params\">(<span class=\"keyword\">final</span> String paramVal)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">\t\tInner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal+paramVal);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localVal1 = <span class=\"number\">2</span>;</div><div class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner2</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal1);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Inner</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tOuter outer = <span class=\"keyword\">new</span> Outer();</div><div class=\"line\">\t\touter.testInner(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。</p>\n<p>后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。</p>\n<p>我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）</p>\n<p>但是确实生成了这样几个.class文件：</p>\n<p>Outer.class:class Outer</p>\n<p>Outer$1.class:匿名内部类 new Inner(){…}</p>\n<p>Outer$1Inner2.class:class Inner2</p>\n<p>Outer$Inner.class:interface Inner</p>\n<p>这说明，匿名内部类与他的外围类之间确实是相互独立的。</p>\n<p>为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner &#123;</div><div class=\"line\">  final java.lang.Integer val$localVar;</div><div class=\"line\"></div><div class=\"line\">  final java.lang.String val$paramVal;</div><div class=\"line\"></div><div class=\"line\">  final kyu.java.util.Outer this$0;</div><div class=\"line\"></div><div class=\"line\">  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);</div><div class=\"line\">    Code:</div><div class=\"line\">       0: aload_0</div><div class=\"line\">       1: aload_1</div><div class=\"line\">       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;</div><div class=\"line\">       5: aload_0</div><div class=\"line\">       6: aload_2</div><div class=\"line\">       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;</div><div class=\"line\">      10: aload_0</div><div class=\"line\">      11: aload_3</div><div class=\"line\">      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;</div><div class=\"line\">      15: aload_0</div><div class=\"line\">      16: invokespecial #4                  // Method java/lang/Object.\"&lt;init&gt;\":()V</div><div class=\"line\">      19: return</div><div class=\"line\"></div><div class=\"line\">      .....</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参<br>。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。</p>\n<p>所以，现在有两个问题：</p>\n<ul>\n<li><strong>为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？</strong></li>\n</ul>\n<p>我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。</p>\n<ul>\n<li><strong>局部变量或形参为什么必须是final类型？</strong></li>\n</ul>\n<p>在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">Inner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(localVar+paramVal);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。</p>\n<p>ps:后来在stackoverflow上看到<a href=\"http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class\">Why are only final variables accessible in anonymous class?</a>，可以参考一下。</p>\n"},{"layout":"post","date":"2016-04-14T05:48:55.000Z","title":"他可是科比布莱恩特","_content":"<center>\n\t<iframe \n\t\twidth=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen>\n\t</iframe>\n</center>\nwhat can i say, Mamba out！\n\n{% asset_img kobe.jpg 科比 %}\n\n\n\n","source":"_posts/他可是科比·布莱恩特!.md","raw":"---\nlayout: post\ndate:   2016-04-14 13:48:55\ntitle: \"他可是科比布莱恩特\"\ncategories: 生活\n---\n<center>\n\t<iframe \n\t\twidth=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen>\n\t</iframe>\n</center>\nwhat can i say, Mamba out！\n\n{% asset_img kobe.jpg 科比 %}\n\n\n\n","slug":"他可是科比·布莱恩特!","published":1,"updated":"2016-11-30T14:32:49.909Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj5y0023digcfdwfzm2k","content":"<p><center><br>    <iframe width=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen><br>    </iframe><br></center><br>what can i say, Mamba out！</p>\n<img src=\"/2016/04/14/他可是科比·布莱恩特!/kobe.jpg\" alt=\"科比\" title=\"科比\">\n","excerpt":"","more":"<p><center><br>    <iframe \n        width=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen><br>    </iframe><br></center><br>what can i say, Mamba out！</p>\n<img src=\"/2016/04/14/他可是科比·布莱恩特!/kobe.jpg\" alt=\"科比\" title=\"科比\">\n"},{"layout":"post","title":"代码规范","date":"2016-03-29T08:31:55.000Z","_content":"\n>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。\n 所以决定总结一些规范，以后写代码要注意了~\n\n- ## **命名**\n\n  - 变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名\n\n  - 避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean\n\n  1. 方法\n\n     方法名第一个单词小写，以后每个单词首字母大写。\n\n  2. 类、接口\n\n     所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词\n\n  3. 字段、常量\n\n     成员变量、局部变量第一个单词小写，如 userName, instance。\n\n     常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。\n\n     代码中禁止使用硬编码，把一些数字或字符串定义成常用量。\n\n- ## **注释**\n\n  1. 成员变量注释\n\n    ```java\n    /** 成员变量注释 */\n    protected Object mObject0;\n\n    /**\n     * 对于注释多于一行的，采用这种方式来\n     * 定义该变量\n     */\n    private Object mObject4;\n    ```\n\n  2. 方法描述\n\n    ```java\n    /**\n      * 方法描述...\n      * \n      * @param param1  参数1描述...\n      * @param param2  参数2描述...\n      * @param paramXX 参数XX描述... （注意：请将参数、描述都对齐）\n      */\n      public void doSomething(int param1, float param2, String paramXX) {}\n    ```\n\n  3.方法内部注释\n\n    可以使用 /*注释*/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。\n    \n    ```java\n    if (a == 2) {\n        return TRUE;            /* special case */\n    } else {    \n        return isprime(a);      /* works only for odd a */}\n    ```\n\n\n- ## **换行、空格**\n\n  - **换行**\n\n    当代码过长造成阅读困难的时候，就应该考虑代码换行。\n\n    有这么几个原则：\n\n    1.在逗号之后换行\n\n    2.在操作符之前换行\n\n    3.考虑在表达式的外层就换行，而不是内层\n\n    4.新一行的开头应该与前一行的同一级代码对齐\n\n    5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。\n\n    **示例**\n\n    ```java\n    function(longExpression1, longExpression2, longExpression3,         \n             longExpression4, longExpression5);\n\n    var = function1(longExpression1,                \n                   function2(longExpression2,\n                             longExpression3));\n    ```\n\n    在表达式外层换行：\n\n    ```java\n    longName1 = longName2 * (longName3 + longName4 - longName5)\n                + 4 * longname6; // PREFER\n\n    longName1 = longName2 * (longName3 + longName4\n                             - longName5) + 4 * longname6; // AVOID\n\n    ```\n\n    插入8个空格的情况\n\n    ```java\n    //INDENT 8 SPACES TO AVOID VERY DEEP INDENTS\n    private static synchronized horkingLongMethodName(int anArg,\n            Object anotherArg, String yetAnotherArg,\n            Object andStillAnother) {    \n         ...\n    } \n\n    //条件表达式8空格原则\n    if ((condition1 && condition2)\n            || (condition3 && condition4)\n            ||!(condition5 && condition6)) {\n        doSomethingAboutIt();\n    }\n    ```\n\n  - **空格**\n\n    1.`{`内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。\n\n    2. 操作符左右，大括号`{}`左右，等于号左右都要有一个空格的间距。\nf\n\n- ## **参考**\n\n  [JavaCode Conventions](http://www.oracle.com/technetwork/java/codeconventions-150003.pdf)","source":"_posts/代码格式.md","raw":"---\nlayout: post\ntitle:  \"代码规范\"\ndate:   2016-03-29 16:31:55\ncategories: 编程 \ntags: \n- java\n---\n\n>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。\n 所以决定总结一些规范，以后写代码要注意了~\n\n- ## **命名**\n\n  - 变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名\n\n  - 避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean\n\n  1. 方法\n\n     方法名第一个单词小写，以后每个单词首字母大写。\n\n  2. 类、接口\n\n     所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词\n\n  3. 字段、常量\n\n     成员变量、局部变量第一个单词小写，如 userName, instance。\n\n     常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。\n\n     代码中禁止使用硬编码，把一些数字或字符串定义成常用量。\n\n- ## **注释**\n\n  1. 成员变量注释\n\n    ```java\n    /** 成员变量注释 */\n    protected Object mObject0;\n\n    /**\n     * 对于注释多于一行的，采用这种方式来\n     * 定义该变量\n     */\n    private Object mObject4;\n    ```\n\n  2. 方法描述\n\n    ```java\n    /**\n      * 方法描述...\n      * \n      * @param param1  参数1描述...\n      * @param param2  参数2描述...\n      * @param paramXX 参数XX描述... （注意：请将参数、描述都对齐）\n      */\n      public void doSomething(int param1, float param2, String paramXX) {}\n    ```\n\n  3.方法内部注释\n\n    可以使用 /*注释*/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。\n    \n    ```java\n    if (a == 2) {\n        return TRUE;            /* special case */\n    } else {    \n        return isprime(a);      /* works only for odd a */}\n    ```\n\n\n- ## **换行、空格**\n\n  - **换行**\n\n    当代码过长造成阅读困难的时候，就应该考虑代码换行。\n\n    有这么几个原则：\n\n    1.在逗号之后换行\n\n    2.在操作符之前换行\n\n    3.考虑在表达式的外层就换行，而不是内层\n\n    4.新一行的开头应该与前一行的同一级代码对齐\n\n    5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。\n\n    **示例**\n\n    ```java\n    function(longExpression1, longExpression2, longExpression3,         \n             longExpression4, longExpression5);\n\n    var = function1(longExpression1,                \n                   function2(longExpression2,\n                             longExpression3));\n    ```\n\n    在表达式外层换行：\n\n    ```java\n    longName1 = longName2 * (longName3 + longName4 - longName5)\n                + 4 * longname6; // PREFER\n\n    longName1 = longName2 * (longName3 + longName4\n                             - longName5) + 4 * longname6; // AVOID\n\n    ```\n\n    插入8个空格的情况\n\n    ```java\n    //INDENT 8 SPACES TO AVOID VERY DEEP INDENTS\n    private static synchronized horkingLongMethodName(int anArg,\n            Object anotherArg, String yetAnotherArg,\n            Object andStillAnother) {    \n         ...\n    } \n\n    //条件表达式8空格原则\n    if ((condition1 && condition2)\n            || (condition3 && condition4)\n            ||!(condition5 && condition6)) {\n        doSomethingAboutIt();\n    }\n    ```\n\n  - **空格**\n\n    1.`{`内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。\n\n    2. 操作符左右，大括号`{}`左右，等于号左右都要有一个空格的间距。\nf\n\n- ## **参考**\n\n  [JavaCode Conventions](http://www.oracle.com/technetwork/java/codeconventions-150003.pdf)","slug":"代码格式","published":1,"updated":"2016-11-30T14:32:49.913Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj620027digcsyw90o09","content":"<blockquote>\n<p>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。<br> 所以决定总结一些规范，以后写代码要注意了~</p>\n</blockquote>\n<ul>\n<li><h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a><strong>命名</strong></h2><ul>\n<li><p>变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名</p>\n</li>\n<li><p>避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean</p>\n</li>\n</ul>\n<ol>\n<li><p>方法</p>\n<p>方法名第一个单词小写，以后每个单词首字母大写。</p>\n</li>\n<li><p>类、接口</p>\n<p>所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词</p>\n</li>\n<li><p>字段、常量</p>\n<p>成员变量、局部变量第一个单词小写，如 userName, instance。</p>\n<p>常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。</p>\n<p>代码中禁止使用硬编码，把一些数字或字符串定义成常用量。</p>\n</li>\n</ol>\n</li>\n<li><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a><strong>注释</strong></h2><ol>\n<li><p>成员变量注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** 成员变量注释 */</span></div><div class=\"line\"><span class=\"keyword\">protected</span> Object mObject0;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 对于注释多于一行的，采用这种方式来</div><div class=\"line\"> * 定义该变量</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">private</span> Object mObject4;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方法描述</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * 方法描述...</div><div class=\"line\">  * </div><div class=\"line\">  * <span class=\"doctag\">@param</span> param1  参数1描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> param2  参数2描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> paramXX 参数XX描述... （注意：请将参数、描述都对齐）</div><div class=\"line\">  */</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> param1, <span class=\"keyword\">float</span> param2, String paramXX)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.方法内部注释</p>\n<p>  可以使用 /<em>注释</em>/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> TRUE;            <span class=\"comment\">/* special case */</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">    <span class=\"keyword\">return</span> isprime(a);      <span class=\"comment\">/* works only for odd a */</span>&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><h2 id=\"换行、空格\"><a href=\"#换行、空格\" class=\"headerlink\" title=\"换行、空格\"></a><strong>换行、空格</strong></h2><ul>\n<li><p><strong>换行</strong></p>\n<p>当代码过长造成阅读困难的时候，就应该考虑代码换行。</p>\n<p>有这么几个原则：</p>\n<p>1.在逗号之后换行</p>\n<p>2.在操作符之前换行</p>\n<p>3.考虑在表达式的外层就换行，而不是内层</p>\n<p>4.新一行的开头应该与前一行的同一级代码对齐</p>\n<p>5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(longExpression1, longExpression2, longExpression3,         </div><div class=\"line\">         longExpression4, longExpression5);</div><div class=\"line\"></div><div class=\"line\">var = function1(longExpression1,                </div><div class=\"line\">               function2(longExpression2,</div><div class=\"line\">                         longExpression3));</div></pre></td></tr></table></figure>\n<p>在表达式外层换行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">longName1 = longName2 * (longName3 + longName4 - longName5)</div><div class=\"line\">            + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// PREFER</span></div><div class=\"line\"></div><div class=\"line\">longName1 = longName2 * (longName3 + longName4</div><div class=\"line\">                         - longName5) + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// AVOID</span></div></pre></td></tr></table></figure>\n<p>插入8个空格的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//INDENT 8 SPACES TO AVOID VERY DEEP INDENTS</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">horkingLongMethodName</span><span class=\"params\">(<span class=\"keyword\">int</span> anArg,</span></span></div><div class=\"line\">        Object anotherArg, String yetAnotherArg,</div><div class=\"line\">        Object andStillAnother) &#123;    </div><div class=\"line\">     ...</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//条件表达式8空格原则</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((condition1 &amp;&amp; condition2)</div><div class=\"line\">        || (condition3 &amp;&amp; condition4)</div><div class=\"line\">        ||!(condition5 &amp;&amp; condition6)) &#123;</div><div class=\"line\">    doSomethingAboutIt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>空格</strong></p>\n<p>1.<code>{</code>内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。</p>\n<ol>\n<li>操作符左右，大括号<code>{}</code>左右，等于号左右都要有一个空格的间距。<br>f</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://www.oracle.com/technetwork/java/codeconventions-150003.pdf\" target=\"_blank\" rel=\"external\">JavaCode Conventions</a></p>\n</li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<p>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。<br> 所以决定总结一些规范，以后写代码要注意了~</p>\n</blockquote>\n<ul>\n<li><h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a><strong>命名</strong></h2><ul>\n<li><p>变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名</p>\n</li>\n<li><p>避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean</p>\n</li>\n</ul>\n<ol>\n<li><p>方法</p>\n<p>方法名第一个单词小写，以后每个单词首字母大写。</p>\n</li>\n<li><p>类、接口</p>\n<p>所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词</p>\n</li>\n<li><p>字段、常量</p>\n<p>成员变量、局部变量第一个单词小写，如 userName, instance。</p>\n<p>常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。</p>\n<p>代码中禁止使用硬编码，把一些数字或字符串定义成常用量。</p>\n</li>\n</ol>\n</li>\n<li><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a><strong>注释</strong></h2><ol>\n<li><p>成员变量注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** 成员变量注释 */</span></div><div class=\"line\"><span class=\"keyword\">protected</span> Object mObject0;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 对于注释多于一行的，采用这种方式来</div><div class=\"line\"> * 定义该变量</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">private</span> Object mObject4;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方法描述</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * 方法描述...</div><div class=\"line\">  * </div><div class=\"line\">  * <span class=\"doctag\">@param</span> param1  参数1描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> param2  参数2描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> paramXX 参数XX描述... （注意：请将参数、描述都对齐）</div><div class=\"line\">  */</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> param1, <span class=\"keyword\">float</span> param2, String paramXX)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.方法内部注释</p>\n<p>  可以使用 /<em>注释</em>/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> TRUE;            <span class=\"comment\">/* special case */</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">    <span class=\"keyword\">return</span> isprime(a);      <span class=\"comment\">/* works only for odd a */</span>&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><h2 id=\"换行、空格\"><a href=\"#换行、空格\" class=\"headerlink\" title=\"换行、空格\"></a><strong>换行、空格</strong></h2><ul>\n<li><p><strong>换行</strong></p>\n<p>当代码过长造成阅读困难的时候，就应该考虑代码换行。</p>\n<p>有这么几个原则：</p>\n<p>1.在逗号之后换行</p>\n<p>2.在操作符之前换行</p>\n<p>3.考虑在表达式的外层就换行，而不是内层</p>\n<p>4.新一行的开头应该与前一行的同一级代码对齐</p>\n<p>5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(longExpression1, longExpression2, longExpression3,         </div><div class=\"line\">         longExpression4, longExpression5);</div><div class=\"line\"></div><div class=\"line\">var = function1(longExpression1,                </div><div class=\"line\">               function2(longExpression2,</div><div class=\"line\">                         longExpression3));</div></pre></td></tr></table></figure>\n<p>在表达式外层换行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">longName1 = longName2 * (longName3 + longName4 - longName5)</div><div class=\"line\">            + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// PREFER</span></div><div class=\"line\"></div><div class=\"line\">longName1 = longName2 * (longName3 + longName4</div><div class=\"line\">                         - longName5) + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// AVOID</span></div></pre></td></tr></table></figure>\n<p>插入8个空格的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//INDENT 8 SPACES TO AVOID VERY DEEP INDENTS</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">horkingLongMethodName</span><span class=\"params\">(<span class=\"keyword\">int</span> anArg,</div><div class=\"line\">        Object anotherArg, String yetAnotherArg,</div><div class=\"line\">        Object andStillAnother)</span> </span>&#123;    </div><div class=\"line\">     ...</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//条件表达式8空格原则</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((condition1 &amp;&amp; condition2)</div><div class=\"line\">        || (condition3 &amp;&amp; condition4)</div><div class=\"line\">        ||!(condition5 &amp;&amp; condition6)) &#123;</div><div class=\"line\">    doSomethingAboutIt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>空格</strong></p>\n<p>1.<code>{</code>内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。</p>\n<ol>\n<li>操作符左右，大括号<code>{}</code>左右，等于号左右都要有一个空格的间距。<br>f</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://www.oracle.com/technetwork/java/codeconventions-150003.pdf\">JavaCode Conventions</a></p>\n</li>\n</ul>\n"},{"layout":"post","title":"ANT编译java工程经jdk路径的设置","date":"2016-04-25T04:48:55.000Z","_content":"\n> 今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。\n\n打包过程中总是报：\n\n```java\n[javac] 警告: [options] 未与 -source 1.5 一起设置引导类路径\n[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:50: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()\n[javac] public class Driver implements java.sql.Driver {\n....\n```\n\n类似这样的一堆错误。\n\n没有过多的思考，百度之...出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。\n\n严重的浪费时间和影响心情，遂放弃。\n\n静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。\n\n后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。\n\n重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。\n\n等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’\n\n果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加\n\n```java\nexecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"\nfork=\"yes\"\n```\n\nBuild Successfull.\n\n这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：\n\n1.不要用百度\n\n2.先思考问题原因，再寻找解决方案\n\n3.学习英语，尽量用英文搜索\n\n## 参考\n\n[Change JDK for running <ANT> task from within build xml](http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml)\n\n\n","source":"_posts/ant编译java工程jdk路径的设置.md","raw":"---\nlayout: post\ntitle:  \"ANT编译java工程经jdk路径的设置\"\ncategories: 工具\ntags: \n- java\n- ant\ndate:   2016-04-25 12:48:55\n---\n\n> 今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。\n\n打包过程中总是报：\n\n```java\n[javac] 警告: [options] 未与 -source 1.5 一起设置引导类路径\n[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:50: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()\n[javac] public class Driver implements java.sql.Driver {\n....\n```\n\n类似这样的一堆错误。\n\n没有过多的思考，百度之...出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。\n\n严重的浪费时间和影响心情，遂放弃。\n\n静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。\n\n后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。\n\n重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。\n\n等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’\n\n果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加\n\n```java\nexecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"\nfork=\"yes\"\n```\n\nBuild Successfull.\n\n这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：\n\n1.不要用百度\n\n2.先思考问题原因，再寻找解决方案\n\n3.学习英语，尽量用英文搜索\n\n## 参考\n\n[Change JDK for running <ANT> task from within build xml](http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml)\n\n\n","slug":"ant编译java工程jdk路径的设置","published":1,"updated":"2016-11-30T14:32:49.905Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj68002adigcnbalc4jw","content":"<blockquote>\n<p>今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。</p>\n</blockquote>\n<p>打包过程中总是报：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[javac] 警告: [options] 未与 -source <span class=\"number\">1.5</span> 一起设置引导类路径</div><div class=\"line\">[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:<span class=\"number\">50</span>: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()</div><div class=\"line\">[javac] <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>类似这样的一堆错误。</p>\n<p>没有过多的思考，百度之…出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。</p>\n<p>严重的浪费时间和影响心情，遂放弃。</p>\n<p>静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。</p>\n<p>后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。</p>\n<p>重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。</p>\n<p>等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’</p>\n<p>果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">executable=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"</span></div><div class=\"line\">fork=<span class=\"string\">\"yes\"</span></div></pre></td></tr></table></figure>\n<p>Build Successfull.</p>\n<p>这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：</p>\n<p>1.不要用百度</p>\n<p>2.先思考问题原因，再寻找解决方案</p>\n<p>3.学习英语，尽量用英文搜索</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml\" target=\"_blank\" rel=\"external\">Change JDK for running <ant> task from within build xml</ant></a></p>\n","excerpt":"","more":"<blockquote>\n<p>今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。</p>\n</blockquote>\n<p>打包过程中总是报：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[javac] 警告: [options] 未与 -source <span class=\"number\">1.5</span> 一起设置引导类路径</div><div class=\"line\">[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:<span class=\"number\">50</span>: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()</div><div class=\"line\">[javac] <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>类似这样的一堆错误。</p>\n<p>没有过多的思考，百度之…出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。</p>\n<p>严重的浪费时间和影响心情，遂放弃。</p>\n<p>静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。</p>\n<p>后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。</p>\n<p>重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。</p>\n<p>等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’</p>\n<p>果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">executable=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"</span></div><div class=\"line\">fork=<span class=\"string\">\"yes\"</span></div></pre></td></tr></table></figure>\n<p>Build Successfull.</p>\n<p>这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：</p>\n<p>1.不要用百度</p>\n<p>2.先思考问题原因，再寻找解决方案</p>\n<p>3.学习英语，尽量用英文搜索</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml\">Change JDK for running <ANT> task from within build xml</a></p>\n"},{"layout":"post","title":"关于加密的一点总结","date":"2016-08-22T12:59:00.000Z","_content":"前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。\n\n## 信息摘要算法\n\n### 简介\n\n验证用户名密码的整个过程主要使用了MD5算法。严格来说，[MD5](https://zh.wikipedia.org/wiki/MD5)不是一种加密算法，而是一种信息摘要算法。\n\n所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在[这篇](http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/)总结中提到过。简单来说，就是把给出的\"信息\"经过哈希之后得到的值，就是这些内容的\"摘要\"。\n\n### 特点\n\n信息摘要算法有这样几个特点：\n\n1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。\n\n2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个[提问](http://www.zhihu.com/question/22651987).\n\n3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。\n\n满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？\n\n1.一致性检验。\n\n我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。\n\n下面是jdk-7u79对应的MD5校验值，从[官方网站](https://www.oracle.com/webfolder/s/digest/7u79checksum.html)截图。\n\n{% asset_img md5.png MD5 %}\n\n2.数字签名\n\n其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。\n\n3.登陆验证\n\n模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回success\n\n3.客户端将密码经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。\n\n那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 [加盐](https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6) 的手段来保证我们密码的安全。\n\n所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。\n\n使用加盐手段后，上面的验证过程改为如下：\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt\n\n3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。\n\n### java中的MD5\n\n```java\npublic static String stringMD5(String input) {  \n  \n   try {    \n      // 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    \n      MessageDigest messageDigest =MessageDigest.getInstance(\"MD5\");  \n      // 输入的字符串转换成字节数组  \n      byte[] inputByteArray = input.getBytes();  \n  \n      // inputByteArray是输入字符串转换得到的字节数组  \n      messageDigest.update(inputByteArray);      \n  \n      // 转换并返回结果，也是字节数组，包含16个元素  \n      byte[] resultByteArray = messageDigest.digest();  \n    \n      // 字符数组转换成字符串返回  \n      return byteArrayToHex(resultByteArray);           \n   } catch (NoSuchAlgorithmException e) {   \n      return null;    \n   }  \n  \n}  \n\npublic static String byteArrayToHex(byte[] byteArray) {    \n   // 首先初始化一个字符数组，用来存放每个16进制字符    \n   char[] hexDigits = {'0','1','2','3','4','5','6','7','8','9', 'A','B','C','D','E','F' };  \n    \n   // new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    \n   char[] resultCharArray =new char[byteArray.length * 2];   \n  \n   // 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    \n   int index = 0;    \n   int pos,tmp;\n   for (byte b : byteArray) {   \n   \t  //当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！\n   \t  //为便于理解，此处对原文进行修改\n   \t  int tmp = b & 0xFF;\n   \t  pos = tmp >> 4;//得到低四位\n      resultCharArray[index++] = hexDigits[pos];  \n      pos = tmp & 0xF;//得到高四位\n      resultCharArray[index++] = hexDigits[pos];   \n   }    \n  \n   // 字符数组组合成字符串返回   \n   return new String(resultCharArray);  \n}\n```\n代码参考自[叉叉哥的BLOG](http://blog.csdn.net/xiao__gui/article/details/8148203)\n\n\n## 数字签名\n\n前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。\n\n首先了解一下两个概念：[对称加密](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86)和[非对称加密](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)。\n\n对称加密，就是信息加密解密使用相同的密钥。\n\n非对称加密，有两种密钥，公钥和私钥。\n\n公钥私钥满足以下几个特点：\n\n1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。\n\n2.顾名思义，公钥是可以公开的，而私钥是不公开的。\n\n3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。\n\n4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容\n\n5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。\n\n与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。\n\n下面看一下数字签名使用过程：\n\n1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。\n\n2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的**身份认证**。\n\n3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了**信息完整性**（一致性检验）。\n\n上面的过程能够得出数字签名的作用：**身份认证**与**完整性检验**\n\n使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。\n\n## 数字证书\n\n数字证书是用来解决公钥从哪里来的问题。\n\n可能有以下两种方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了\n\n所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。\n\n关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。\n\n## 参考\n\n网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。\n\n以下内容来自[无恙-数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html) http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n2、一个加密通信过程的演化\n\n我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：\n\n2.1 第一回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：？？？？\n\n因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”\n\n“黑客”->“客户”：你好，我是服务器\n\n因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：\n\n \n\n2.2 第二回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n      // 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n\n为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。\n\n“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。\n\n假设“黑客”想冒充“服务器”：\n\n“黑客”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。\n\n“客户”->“黑客”：？？？？\n\n由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！\n\n到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：\n\n \n\n2.3 第三回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]\n\n“服务器”->“客户”：{你的余额是100元}[私钥|RSA]\n\n注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。\n\n这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：\n\n \n\n2.4 第四回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。\n\n“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]\n\n在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。\n\n由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。\n\n \n\n总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：\n\n因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。\n客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。\n如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)\n\n到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。\n\n \n\n但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：\n\n“客户”->“黑客”：你好           //黑客截获“客户”发给“服务器”的消息\n\n“黑客”->“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”\n\n因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。\n\n为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：\n\n证书的发布机构\n证书的有效期\n公钥\n证书所有者（Subject）\n签名所使用的算法\n指纹以及指纹算法\n证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：\n\n \n\n2.5 第五回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：\n\n \n\n2.6 完整过程：\n\nstep1： “客户”向服务端发送一个通信请求\n\n“客户”->“服务器”：你好\n\n  \n\nstep2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 \n\n \n\nstep3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。\n\n“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。\n\n“服务器”->“客户”：{一个随机字符串}[私钥|RSA]\n\n \n\nstep4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。\n\n“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]\n\n…… //继续其它的通信\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n另外，也可以看看这篇博客：[阮一峰-数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)\n\n\n\n\n\n\n\n\n","source":"_posts/关于加密的一点总结.md","raw":"layout: post\ntitle: 关于加密的一点总结\ndate: 2016-08-22 20:59:00\ncategories: 技术\ntags: 加密\n---\n前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。\n\n## 信息摘要算法\n\n### 简介\n\n验证用户名密码的整个过程主要使用了MD5算法。严格来说，[MD5](https://zh.wikipedia.org/wiki/MD5)不是一种加密算法，而是一种信息摘要算法。\n\n所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在[这篇](http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/)总结中提到过。简单来说，就是把给出的\"信息\"经过哈希之后得到的值，就是这些内容的\"摘要\"。\n\n### 特点\n\n信息摘要算法有这样几个特点：\n\n1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。\n\n2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个[提问](http://www.zhihu.com/question/22651987).\n\n3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。\n\n满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？\n\n1.一致性检验。\n\n我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。\n\n下面是jdk-7u79对应的MD5校验值，从[官方网站](https://www.oracle.com/webfolder/s/digest/7u79checksum.html)截图。\n\n{% asset_img md5.png MD5 %}\n\n2.数字签名\n\n其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。\n\n3.登陆验证\n\n模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回success\n\n3.客户端将密码经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。\n\n那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 [加盐](https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6) 的手段来保证我们密码的安全。\n\n所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。\n\n使用加盐手段后，上面的验证过程改为如下：\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt\n\n3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。\n\n### java中的MD5\n\n```java\npublic static String stringMD5(String input) {  \n  \n   try {    \n      // 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    \n      MessageDigest messageDigest =MessageDigest.getInstance(\"MD5\");  \n      // 输入的字符串转换成字节数组  \n      byte[] inputByteArray = input.getBytes();  \n  \n      // inputByteArray是输入字符串转换得到的字节数组  \n      messageDigest.update(inputByteArray);      \n  \n      // 转换并返回结果，也是字节数组，包含16个元素  \n      byte[] resultByteArray = messageDigest.digest();  \n    \n      // 字符数组转换成字符串返回  \n      return byteArrayToHex(resultByteArray);           \n   } catch (NoSuchAlgorithmException e) {   \n      return null;    \n   }  \n  \n}  \n\npublic static String byteArrayToHex(byte[] byteArray) {    \n   // 首先初始化一个字符数组，用来存放每个16进制字符    \n   char[] hexDigits = {'0','1','2','3','4','5','6','7','8','9', 'A','B','C','D','E','F' };  \n    \n   // new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    \n   char[] resultCharArray =new char[byteArray.length * 2];   \n  \n   // 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    \n   int index = 0;    \n   int pos,tmp;\n   for (byte b : byteArray) {   \n   \t  //当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！\n   \t  //为便于理解，此处对原文进行修改\n   \t  int tmp = b & 0xFF;\n   \t  pos = tmp >> 4;//得到低四位\n      resultCharArray[index++] = hexDigits[pos];  \n      pos = tmp & 0xF;//得到高四位\n      resultCharArray[index++] = hexDigits[pos];   \n   }    \n  \n   // 字符数组组合成字符串返回   \n   return new String(resultCharArray);  \n}\n```\n代码参考自[叉叉哥的BLOG](http://blog.csdn.net/xiao__gui/article/details/8148203)\n\n\n## 数字签名\n\n前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。\n\n首先了解一下两个概念：[对称加密](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86)和[非对称加密](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)。\n\n对称加密，就是信息加密解密使用相同的密钥。\n\n非对称加密，有两种密钥，公钥和私钥。\n\n公钥私钥满足以下几个特点：\n\n1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。\n\n2.顾名思义，公钥是可以公开的，而私钥是不公开的。\n\n3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。\n\n4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容\n\n5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。\n\n与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。\n\n下面看一下数字签名使用过程：\n\n1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。\n\n2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的**身份认证**。\n\n3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了**信息完整性**（一致性检验）。\n\n上面的过程能够得出数字签名的作用：**身份认证**与**完整性检验**\n\n使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。\n\n## 数字证书\n\n数字证书是用来解决公钥从哪里来的问题。\n\n可能有以下两种方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了\n\n所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。\n\n关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。\n\n## 参考\n\n网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。\n\n以下内容来自[无恙-数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html) http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n2、一个加密通信过程的演化\n\n我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：\n\n2.1 第一回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：？？？？\n\n因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”\n\n“黑客”->“客户”：你好，我是服务器\n\n因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：\n\n \n\n2.2 第二回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n      // 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n\n为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。\n\n“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。\n\n假设“黑客”想冒充“服务器”：\n\n“黑客”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。\n\n“客户”->“黑客”：？？？？\n\n由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！\n\n到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：\n\n \n\n2.3 第三回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]\n\n“服务器”->“客户”：{你的余额是100元}[私钥|RSA]\n\n注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。\n\n这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：\n\n \n\n2.4 第四回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。\n\n“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]\n\n在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。\n\n由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。\n\n \n\n总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：\n\n因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。\n客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。\n如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)\n\n到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。\n\n \n\n但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：\n\n“客户”->“黑客”：你好           //黑客截获“客户”发给“服务器”的消息\n\n“黑客”->“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”\n\n因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。\n\n为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：\n\n证书的发布机构\n证书的有效期\n公钥\n证书所有者（Subject）\n签名所使用的算法\n指纹以及指纹算法\n证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：\n\n \n\n2.5 第五回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：\n\n \n\n2.6 完整过程：\n\nstep1： “客户”向服务端发送一个通信请求\n\n“客户”->“服务器”：你好\n\n  \n\nstep2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 \n\n \n\nstep3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。\n\n“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。\n\n“服务器”->“客户”：{一个随机字符串}[私钥|RSA]\n\n \n\nstep4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。\n\n“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]\n\n…… //继续其它的通信\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n另外，也可以看看这篇博客：[阮一峰-数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)\n\n\n\n\n\n\n\n\n","slug":"关于加密的一点总结","published":1,"updated":"2016-11-30T14:32:49.913Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj6b002edigc1ttqq2rw","content":"<p>前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。</p>\n<h2 id=\"信息摘要算法\"><a href=\"#信息摘要算法\" class=\"headerlink\" title=\"信息摘要算法\"></a>信息摘要算法</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>验证用户名密码的整个过程主要使用了MD5算法。严格来说，<a href=\"https://zh.wikipedia.org/wiki/MD5\" target=\"_blank\" rel=\"external\">MD5</a>不是一种加密算法，而是一种信息摘要算法。</p>\n<p>所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在<a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/\">这篇</a>总结中提到过。简单来说，就是把给出的”信息”经过哈希之后得到的值，就是这些内容的”摘要”。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>信息摘要算法有这样几个特点：</p>\n<p>1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。</p>\n<p>2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个<a href=\"http://www.zhihu.com/question/22651987\" target=\"_blank\" rel=\"external\">提问</a>.</p>\n<p>3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。</p>\n<p>满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？</p>\n<p>1.一致性检验。</p>\n<p>我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。</p>\n<p>下面是jdk-7u79对应的MD5校验值，从<a href=\"https://www.oracle.com/webfolder/s/digest/7u79checksum.html\" target=\"_blank\" rel=\"external\">官方网站</a>截图。</p>\n<img src=\"/2016/08/22/关于加密的一点总结/md5.png\" alt=\"MD5\" title=\"MD5\">\n<p>2.数字签名</p>\n<p>其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。</p>\n<p>3.登陆验证</p>\n<p>模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回success</p>\n<p>3.客户端将密码经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。</p>\n<p>那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 <a href=\"https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6\" target=\"_blank\" rel=\"external\">加盐</a> 的手段来保证我们密码的安全。</p>\n<p>所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。</p>\n<p>使用加盐手段后，上面的验证过程改为如下：</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt</p>\n<p>3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。</p>\n<h3 id=\"java中的MD5\"><a href=\"#java中的MD5\" class=\"headerlink\" title=\"java中的MD5\"></a>java中的MD5</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">stringMD5</span><span class=\"params\">(String input)</span> </span>&#123;  </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">      <span class=\"comment\">// 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    </span></div><div class=\"line\">      MessageDigest messageDigest =MessageDigest.getInstance(<span class=\"string\">\"MD5\"</span>);  </div><div class=\"line\">      <span class=\"comment\">// 输入的字符串转换成字节数组  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] inputByteArray = input.getBytes();  </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// inputByteArray是输入字符串转换得到的字节数组  </span></div><div class=\"line\">      messageDigest.update(inputByteArray);      </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// 转换并返回结果，也是字节数组，包含16个元素  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] resultByteArray = messageDigest.digest();  </div><div class=\"line\">    </div><div class=\"line\">      <span class=\"comment\">// 字符数组转换成字符串返回  </span></div><div class=\"line\">      <span class=\"keyword\">return</span> byteArrayToHex(resultByteArray);           </div><div class=\"line\">   &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;   </div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;    </div><div class=\"line\">   &#125;  </div><div class=\"line\">  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">byteArrayToHex</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] byteArray)</span> </span>&#123;    </div><div class=\"line\">   <span class=\"comment\">// 首先初始化一个字符数组，用来存放每个16进制字符    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] hexDigits = &#123;<span class=\"string\">'0'</span>,<span class=\"string\">'1'</span>,<span class=\"string\">'2'</span>,<span class=\"string\">'3'</span>,<span class=\"string\">'4'</span>,<span class=\"string\">'5'</span>,<span class=\"string\">'6'</span>,<span class=\"string\">'7'</span>,<span class=\"string\">'8'</span>,<span class=\"string\">'9'</span>, <span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span> &#125;;  </div><div class=\"line\">    </div><div class=\"line\">   <span class=\"comment\">// new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] resultCharArray =<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[byteArray.length * <span class=\"number\">2</span>];   </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    </span></div><div class=\"line\">   <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;    </div><div class=\"line\">   <span class=\"keyword\">int</span> pos,tmp;</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">byte</span> b : byteArray) &#123;   </div><div class=\"line\">   \t  <span class=\"comment\">//当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！</span></div><div class=\"line\">   \t  <span class=\"comment\">//为便于理解，此处对原文进行修改</span></div><div class=\"line\">   \t  <span class=\"keyword\">int</span> tmp = b &amp; <span class=\"number\">0xFF</span>;</div><div class=\"line\">   \t  pos = tmp &gt;&gt; <span class=\"number\">4</span>;<span class=\"comment\">//得到低四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];  </div><div class=\"line\">      pos = tmp &amp; <span class=\"number\">0xF</span>;<span class=\"comment\">//得到高四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];   </div><div class=\"line\">   &#125;    </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 字符数组组合成字符串返回   </span></div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(resultCharArray);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码参考自<a href=\"http://blog.csdn.net/xiao__gui/article/details/8148203\" target=\"_blank\" rel=\"external\">叉叉哥的BLOG</a></p>\n<h2 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h2><p>前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。</p>\n<p>首先了解一下两个概念：<a href=\"https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86\" target=\"_blank\" rel=\"external\">对称加密</a>和<a href=\"https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86\" target=\"_blank\" rel=\"external\">非对称加密</a>。</p>\n<p>对称加密，就是信息加密解密使用相同的密钥。</p>\n<p>非对称加密，有两种密钥，公钥和私钥。</p>\n<p>公钥私钥满足以下几个特点：</p>\n<p>1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。</p>\n<p>2.顾名思义，公钥是可以公开的，而私钥是不公开的。</p>\n<p>3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。</p>\n<p>4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容</p>\n<p>5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。</p>\n<p>与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。</p>\n<p>下面看一下数字签名使用过程：</p>\n<p>1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。</p>\n<p>2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的<strong>身份认证</strong>。</p>\n<p>3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了<strong>信息完整性</strong>（一致性检验）。</p>\n<p>上面的过程能够得出数字签名的作用：<strong>身份认证</strong>与<strong>完整性检验</strong></p>\n<p>使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。</p>\n<h2 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h2><p>数字证书是用来解决公钥从哪里来的问题。</p>\n<p>可能有以下两种方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了</p>\n<p>所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。</p>\n<p>关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。</p>\n<p>以下内容来自<a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\" target=\"_blank\" rel=\"external\">无恙-数字证书原理</a> <a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html</a></p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>2、一个加密通信过程的演化</p>\n<p>我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：</p>\n<p>2.1 第一回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：？？？？</p>\n<p>因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：</p>\n<p>2.2 第二回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<pre><code>// 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n</code></pre><p>为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。</p>\n<p>“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。</p>\n<p>假设“黑客”想冒充“服务器”：</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。</p>\n<p>“客户”-&gt;“黑客”：？？？？</p>\n<p>由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！</p>\n<p>到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：</p>\n<p>2.3 第三回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[私钥|RSA]</p>\n<p>注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。</p>\n<p>这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：</p>\n<p>2.4 第四回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。</p>\n<p>“服务器”-&gt;“客户”：{OK，收到！}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[密钥|对称加密算法]</p>\n<p>在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。</p>\n<p>由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。</p>\n<p>总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：</p>\n<p>因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。<br>客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。<br>如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)</p>\n<p>到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。</p>\n<p>但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：</p>\n<p>“客户”-&gt;“黑客”：你好           //黑客截获“客户”发给“服务器”的消息</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”</p>\n<p>因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。</p>\n<p>为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：</p>\n<p>证书的发布机构<br>证书的有效期<br>公钥<br>证书所有者（Subject）<br>签名所使用的算法<br>指纹以及指纹算法<br>证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：</p>\n<p>2.5 第五回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：</p>\n<p>2.6 完整过程：</p>\n<p>step1： “客户”向服务端发送一个通信请求</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>step2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 </p>\n<p>step3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。</p>\n<p>“服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]</p>\n<p>step4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>\n<p>“服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]</p>\n<p>…… //继续其它的通信</p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>另外，也可以看看这篇博客：<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\" target=\"_blank\" rel=\"external\">阮一峰-数字签名是什么？</a></p>\n","excerpt":"","more":"<p>前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。</p>\n<h2 id=\"信息摘要算法\"><a href=\"#信息摘要算法\" class=\"headerlink\" title=\"信息摘要算法\"></a>信息摘要算法</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>验证用户名密码的整个过程主要使用了MD5算法。严格来说，<a href=\"https://zh.wikipedia.org/wiki/MD5\">MD5</a>不是一种加密算法，而是一种信息摘要算法。</p>\n<p>所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在<a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/\">这篇</a>总结中提到过。简单来说，就是把给出的”信息”经过哈希之后得到的值，就是这些内容的”摘要”。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>信息摘要算法有这样几个特点：</p>\n<p>1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。</p>\n<p>2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个<a href=\"http://www.zhihu.com/question/22651987\">提问</a>.</p>\n<p>3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。</p>\n<p>满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？</p>\n<p>1.一致性检验。</p>\n<p>我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。</p>\n<p>下面是jdk-7u79对应的MD5校验值，从<a href=\"https://www.oracle.com/webfolder/s/digest/7u79checksum.html\">官方网站</a>截图。</p>\n<img src=\"/2016/08/22/关于加密的一点总结/md5.png\" alt=\"MD5\" title=\"MD5\">\n<p>2.数字签名</p>\n<p>其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。</p>\n<p>3.登陆验证</p>\n<p>模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回success</p>\n<p>3.客户端将密码经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。</p>\n<p>那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 <a href=\"https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6\">加盐</a> 的手段来保证我们密码的安全。</p>\n<p>所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。</p>\n<p>使用加盐手段后，上面的验证过程改为如下：</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt</p>\n<p>3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。</p>\n<h3 id=\"java中的MD5\"><a href=\"#java中的MD5\" class=\"headerlink\" title=\"java中的MD5\"></a>java中的MD5</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">stringMD5</span><span class=\"params\">(String input)</span> </span>&#123;  </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">      <span class=\"comment\">// 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    </span></div><div class=\"line\">      MessageDigest messageDigest =MessageDigest.getInstance(<span class=\"string\">\"MD5\"</span>);  </div><div class=\"line\">      <span class=\"comment\">// 输入的字符串转换成字节数组  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] inputByteArray = input.getBytes();  </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// inputByteArray是输入字符串转换得到的字节数组  </span></div><div class=\"line\">      messageDigest.update(inputByteArray);      </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// 转换并返回结果，也是字节数组，包含16个元素  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] resultByteArray = messageDigest.digest();  </div><div class=\"line\">    </div><div class=\"line\">      <span class=\"comment\">// 字符数组转换成字符串返回  </span></div><div class=\"line\">      <span class=\"keyword\">return</span> byteArrayToHex(resultByteArray);           </div><div class=\"line\">   &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;   </div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;    </div><div class=\"line\">   &#125;  </div><div class=\"line\">  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">byteArrayToHex</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] byteArray)</span> </span>&#123;    </div><div class=\"line\">   <span class=\"comment\">// 首先初始化一个字符数组，用来存放每个16进制字符    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] hexDigits = &#123;<span class=\"string\">'0'</span>,<span class=\"string\">'1'</span>,<span class=\"string\">'2'</span>,<span class=\"string\">'3'</span>,<span class=\"string\">'4'</span>,<span class=\"string\">'5'</span>,<span class=\"string\">'6'</span>,<span class=\"string\">'7'</span>,<span class=\"string\">'8'</span>,<span class=\"string\">'9'</span>, <span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span> &#125;;  </div><div class=\"line\">    </div><div class=\"line\">   <span class=\"comment\">// new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] resultCharArray =<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[byteArray.length * <span class=\"number\">2</span>];   </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    </span></div><div class=\"line\">   <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;    </div><div class=\"line\">   <span class=\"keyword\">int</span> pos,tmp;</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">byte</span> b : byteArray) &#123;   </div><div class=\"line\">   \t  <span class=\"comment\">//当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！</span></div><div class=\"line\">   \t  <span class=\"comment\">//为便于理解，此处对原文进行修改</span></div><div class=\"line\">   \t  <span class=\"keyword\">int</span> tmp = b &amp; <span class=\"number\">0xFF</span>;</div><div class=\"line\">   \t  pos = tmp &gt;&gt; <span class=\"number\">4</span>;<span class=\"comment\">//得到低四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];  </div><div class=\"line\">      pos = tmp &amp; <span class=\"number\">0xF</span>;<span class=\"comment\">//得到高四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];   </div><div class=\"line\">   &#125;    </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 字符数组组合成字符串返回   </span></div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(resultCharArray);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码参考自<a href=\"http://blog.csdn.net/xiao__gui/article/details/8148203\">叉叉哥的BLOG</a></p>\n<h2 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h2><p>前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。</p>\n<p>首先了解一下两个概念：<a href=\"https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86\">对称加密</a>和<a href=\"https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86\">非对称加密</a>。</p>\n<p>对称加密，就是信息加密解密使用相同的密钥。</p>\n<p>非对称加密，有两种密钥，公钥和私钥。</p>\n<p>公钥私钥满足以下几个特点：</p>\n<p>1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。</p>\n<p>2.顾名思义，公钥是可以公开的，而私钥是不公开的。</p>\n<p>3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。</p>\n<p>4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容</p>\n<p>5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。</p>\n<p>与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。</p>\n<p>下面看一下数字签名使用过程：</p>\n<p>1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。</p>\n<p>2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的<strong>身份认证</strong>。</p>\n<p>3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了<strong>信息完整性</strong>（一致性检验）。</p>\n<p>上面的过程能够得出数字签名的作用：<strong>身份认证</strong>与<strong>完整性检验</strong></p>\n<p>使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。</p>\n<h2 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h2><p>数字证书是用来解决公钥从哪里来的问题。</p>\n<p>可能有以下两种方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了</p>\n<p>所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。</p>\n<p>关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。</p>\n<p>以下内容来自<a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\">无恙-数字证书原理</a> <a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\">http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html</a></p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>2、一个加密通信过程的演化</p>\n<p>我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：</p>\n<p>2.1 第一回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：？？？？</p>\n<p>因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：</p>\n<p>2.2 第二回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<pre><code>// 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n</code></pre><p>为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。</p>\n<p>“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。</p>\n<p>假设“黑客”想冒充“服务器”：</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。</p>\n<p>“客户”-&gt;“黑客”：？？？？</p>\n<p>由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！</p>\n<p>到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：</p>\n<p>2.3 第三回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[私钥|RSA]</p>\n<p>注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。</p>\n<p>这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：</p>\n<p>2.4 第四回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。</p>\n<p>“服务器”-&gt;“客户”：{OK，收到！}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[密钥|对称加密算法]</p>\n<p>在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。</p>\n<p>由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。</p>\n<p>总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：</p>\n<p>因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。<br>客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。<br>如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)</p>\n<p>到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。</p>\n<p>但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：</p>\n<p>“客户”-&gt;“黑客”：你好           //黑客截获“客户”发给“服务器”的消息</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”</p>\n<p>因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。</p>\n<p>为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：</p>\n<p>证书的发布机构<br>证书的有效期<br>公钥<br>证书所有者（Subject）<br>签名所使用的算法<br>指纹以及指纹算法<br>证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：</p>\n<p>2.5 第五回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：</p>\n<p>2.6 完整过程：</p>\n<p>step1： “客户”向服务端发送一个通信请求</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>step2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 </p>\n<p>step3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。</p>\n<p>“服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]</p>\n<p>step4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>\n<p>“服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]</p>\n<p>…… //继续其它的通信</p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>另外，也可以看看这篇博客：<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\">阮一峰-数字签名是什么？</a></p>\n"},{"layout":"post","title":"java中的ThreadLocal","date":"2016-06-21T04:48:55.000Z","_content":"\n> 今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal...\n\n## **问题背景**：\n\n每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：\n\n```java\nLsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());\n```\n\n其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。\n\n遂改之：\n\n```java\nLsnVo lv = ((DispatchConnection) conn).getLsnVo();\n```\n\n将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。\n\n曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。\n\n后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！\n\nPS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29\n\nso,按照上面的改法问题解决了。\n\n那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。\n\n这就是ThreadLocal的一个典型应用场景。\n\n## **ThreadLocal原理**：\n\n使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。\n\nThreadLocal的set和get方法：\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n}\n\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            return (T)map.get(this);\n\n        // Maps are constructed lazily.  if the map for this thread\n        // doesn't exist, create it, with this ThreadLocal and its\n        // initial value as its only entry.\n        T value = initialValue();\n        createMap(t, value);\n        return value;\n}\n```\n\n可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。\n\n很容易明白他的工作原理。\n\n## **应用场景**\n\n之前看了网上很多资料说ThreadLocal的应用场景：\n\n1.解决了多线程共享对象的问题，\n\n2.实现线程间的数据隔离，每个线程都有他自己的变量副本。\n\n对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。\n\n对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。\n\n我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：\n\n1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。\n\n2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。\n\n所以，使用ThreadLocal的场景应该是这样：**这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。**\n\nPS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。\n\n另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。\n\n我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。\n\n## **2016/11/01更新**\n\n今天在地铁上看到了一篇不错的文章，介绍ThreadLocal内存泄漏的实例–ThreadLocal 内存泄露的实例分析.\n\n另外，该作者的另一篇blog，讲解ThreadLocal的原理，也很清晰深入分析 ThreadLocal 内存泄漏问题\n\n拜读完作者的文章后，回家又翻了一遍ThreadLocal的源码，认为和作者所要解释的一致，并且对ThreadLocal的理解更加深了。\n\n> ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread\n\n上面的话出自java doc\n\noracle鼓励我们将ThreadLocal对象声明为一个private static类型的变量A。结合上述文章和源码来看，A的生命周期将变得和保存他的类对象一样长，这样ThreadLocalMap中设置的A的弱引用就失去了弱引用的作用，该键A对应的value也不会得到释放，直到此线程销毁。这样一来，如果是使用了线程池的话，当该线程复用时，很有可能会取得错误的值，造成业务逻辑混乱。\n\n解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\n--------------------\n另外，有一个例子展示了ThreadLocal的应用场景，现在贴过来。同样来自java doc。例子虽然很简单，但是我觉得很生动的展示了Threadlocal的一个应用场景，让人豁然开朗。\n\n试想如果不采用ThreadLocal的话，我自己的做法应该会在创建的线程类里面增加一个字段，用来标明线程的id。但是这么做有两点问题：\n\n第一，增加了字段，挺low。\n\n第二，有很大的限制，你只能为自己实现的线程类里面加字段。但是往往有些线程不是我们自己定义的。\n\n这个例子很好的说明了怎么实现一个线程变量。\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\npublic class ThreadId {\n     // Atomic integer containing the next thread ID to be assigned\n     private static final AtomicInteger nextId = new AtomicInteger(0);\n     // Thread local variable containing each thread's ID\n     private static final ThreadLocal<Integer> threadId =\n         new ThreadLocal<Integer>() {\n             @Override protected Integer initialValue() {\n                 return nextId.getAndIncrement();\n         }\n     };\n     // Returns the current thread's unique ID, assigning it if necessary\n     public static int get() {\n         return threadId.get();\n     }\n}\n```\n","source":"_posts/java中的ThreadLocal.md","raw":"---\nlayout: post\ntitle:  \"java中的ThreadLocal\"\ncategories: 编程\ntags: \n- java\n- 多线程\ndate:   2016-06-21 12:48:55\n---\n\n> 今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal...\n\n## **问题背景**：\n\n每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：\n\n```java\nLsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());\n```\n\n其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。\n\n遂改之：\n\n```java\nLsnVo lv = ((DispatchConnection) conn).getLsnVo();\n```\n\n将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。\n\n曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。\n\n后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！\n\nPS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29\n\nso,按照上面的改法问题解决了。\n\n那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。\n\n这就是ThreadLocal的一个典型应用场景。\n\n## **ThreadLocal原理**：\n\n使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。\n\nThreadLocal的set和get方法：\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n}\n\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            return (T)map.get(this);\n\n        // Maps are constructed lazily.  if the map for this thread\n        // doesn't exist, create it, with this ThreadLocal and its\n        // initial value as its only entry.\n        T value = initialValue();\n        createMap(t, value);\n        return value;\n}\n```\n\n可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。\n\n很容易明白他的工作原理。\n\n## **应用场景**\n\n之前看了网上很多资料说ThreadLocal的应用场景：\n\n1.解决了多线程共享对象的问题，\n\n2.实现线程间的数据隔离，每个线程都有他自己的变量副本。\n\n对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。\n\n对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。\n\n我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：\n\n1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。\n\n2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。\n\n所以，使用ThreadLocal的场景应该是这样：**这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。**\n\nPS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。\n\n另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。\n\n我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。\n\n## **2016/11/01更新**\n\n今天在地铁上看到了一篇不错的文章，介绍ThreadLocal内存泄漏的实例–ThreadLocal 内存泄露的实例分析.\n\n另外，该作者的另一篇blog，讲解ThreadLocal的原理，也很清晰深入分析 ThreadLocal 内存泄漏问题\n\n拜读完作者的文章后，回家又翻了一遍ThreadLocal的源码，认为和作者所要解释的一致，并且对ThreadLocal的理解更加深了。\n\n> ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread\n\n上面的话出自java doc\n\noracle鼓励我们将ThreadLocal对象声明为一个private static类型的变量A。结合上述文章和源码来看，A的生命周期将变得和保存他的类对象一样长，这样ThreadLocalMap中设置的A的弱引用就失去了弱引用的作用，该键A对应的value也不会得到释放，直到此线程销毁。这样一来，如果是使用了线程池的话，当该线程复用时，很有可能会取得错误的值，造成业务逻辑混乱。\n\n解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\n--------------------\n另外，有一个例子展示了ThreadLocal的应用场景，现在贴过来。同样来自java doc。例子虽然很简单，但是我觉得很生动的展示了Threadlocal的一个应用场景，让人豁然开朗。\n\n试想如果不采用ThreadLocal的话，我自己的做法应该会在创建的线程类里面增加一个字段，用来标明线程的id。但是这么做有两点问题：\n\n第一，增加了字段，挺low。\n\n第二，有很大的限制，你只能为自己实现的线程类里面加字段。但是往往有些线程不是我们自己定义的。\n\n这个例子很好的说明了怎么实现一个线程变量。\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\npublic class ThreadId {\n     // Atomic integer containing the next thread ID to be assigned\n     private static final AtomicInteger nextId = new AtomicInteger(0);\n     // Thread local variable containing each thread's ID\n     private static final ThreadLocal<Integer> threadId =\n         new ThreadLocal<Integer>() {\n             @Override protected Integer initialValue() {\n                 return nextId.getAndIncrement();\n         }\n     };\n     // Returns the current thread's unique ID, assigning it if necessary\n     public static int get() {\n         return threadId.get();\n     }\n}\n```\n","slug":"java中的ThreadLocal","published":1,"updated":"2016-11-30T14:32:49.905Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj6e002idigce1hrbqxq","content":"<blockquote>\n<p>今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal…</p>\n</blockquote>\n<h2 id=\"问题背景：\"><a href=\"#问题背景：\" class=\"headerlink\" title=\"问题背景：\"></a><strong>问题背景</strong>：</h2><p>每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());</div></pre></td></tr></table></figure>\n<p>其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。</p>\n<p>遂改之：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((DispatchConnection) conn).getLsnVo();</div></pre></td></tr></table></figure>\n<p>将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。</p>\n<p>曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。</p>\n<p>后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！</p>\n<p>PS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29</p>\n<p>so,按照上面的改法问题解决了。</p>\n<p>那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。</p>\n<p>这就是ThreadLocal的一个典型应用场景。</p>\n<h2 id=\"ThreadLocal原理：\"><a href=\"#ThreadLocal原理：\" class=\"headerlink\" title=\"ThreadLocal原理：\"></a><strong>ThreadLocal原理</strong>：</h2><p>使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。</p>\n<p>ThreadLocal的set和get方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> (T)map.get(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Maps are constructed lazily.  if the map for this thread</span></div><div class=\"line\">        <span class=\"comment\">// doesn't exist, create it, with this ThreadLocal and its</span></div><div class=\"line\">        <span class=\"comment\">// initial value as its only entry.</span></div><div class=\"line\">        T value = initialValue();</div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。</p>\n<p>很容易明白他的工作原理。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h2><p>之前看了网上很多资料说ThreadLocal的应用场景：</p>\n<p>1.解决了多线程共享对象的问题，</p>\n<p>2.实现线程间的数据隔离，每个线程都有他自己的变量副本。</p>\n<p>对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。</p>\n<p>对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。</p>\n<p>我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：</p>\n<p>1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。</p>\n<p>2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。</p>\n<p>所以，使用ThreadLocal的场景应该是这样：<strong>这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。</strong></p>\n<p>PS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。</p>\n<p>另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。</p>\n<p>我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。</p>\n<h2 id=\"2016-11-01更新\"><a href=\"#2016-11-01更新\" class=\"headerlink\" title=\"2016/11/01更新\"></a><strong>2016/11/01更新</strong></h2><p>今天在地铁上看到了一篇不错的文章，介绍ThreadLocal内存泄漏的实例–ThreadLocal 内存泄露的实例分析.</p>\n<p>另外，该作者的另一篇blog，讲解ThreadLocal的原理，也很清晰深入分析 ThreadLocal 内存泄漏问题</p>\n<p>拜读完作者的文章后，回家又翻了一遍ThreadLocal的源码，认为和作者所要解释的一致，并且对ThreadLocal的理解更加深了。</p>\n<blockquote>\n<p>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread</p>\n</blockquote>\n<p>上面的话出自java doc</p>\n<p>oracle鼓励我们将ThreadLocal对象声明为一个private static类型的变量A。结合上述文章和源码来看，A的生命周期将变得和保存他的类对象一样长，这样ThreadLocalMap中设置的A的弱引用就失去了弱引用的作用，该键A对应的value也不会得到释放，直到此线程销毁。这样一来，如果是使用了线程池的话，当该线程复用时，很有可能会取得错误的值，造成业务逻辑混乱。</p>\n<h2 id=\"解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\"><a href=\"#解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\" class=\"headerlink\" title=\"解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\"></a>解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。</h2><p>另外，有一个例子展示了ThreadLocal的应用场景，现在贴过来。同样来自java doc。例子虽然很简单，但是我觉得很生动的展示了Threadlocal的一个应用场景，让人豁然开朗。</p>\n<p>试想如果不采用ThreadLocal的话，我自己的做法应该会在创建的线程类里面增加一个字段，用来标明线程的id。但是这么做有两点问题：</p>\n<p>第一，增加了字段，挺low。</p>\n<p>第二，有很大的限制，你只能为自己实现的线程类里面加字段。但是往往有些线程不是我们自己定义的。</p>\n<p>这个例子很好的说明了怎么实现一个线程变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadId</span> </span>&#123;</div><div class=\"line\">     <span class=\"comment\">// Atomic integer containing the next thread ID to be assigned</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicInteger nextId = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</div><div class=\"line\">     <span class=\"comment\">// Thread local variable containing each thread's ID</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Integer&gt; threadId =</div><div class=\"line\">         <span class=\"keyword\">new</span> ThreadLocal&lt;Integer&gt;() &#123;</div><div class=\"line\">             <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                 <span class=\"keyword\">return</span> nextId.getAndIncrement();</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;;</div><div class=\"line\">     <span class=\"comment\">// Returns the current thread's unique ID, assigning it if necessary</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> threadId.get();</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<blockquote>\n<p>今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal…</p>\n</blockquote>\n<h2 id=\"问题背景：\"><a href=\"#问题背景：\" class=\"headerlink\" title=\"问题背景：\"></a><strong>问题背景</strong>：</h2><p>每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());</div></pre></td></tr></table></figure>\n<p>其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。</p>\n<p>遂改之：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((DispatchConnection) conn).getLsnVo();</div></pre></td></tr></table></figure>\n<p>将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。</p>\n<p>曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。</p>\n<p>后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！</p>\n<p>PS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29</p>\n<p>so,按照上面的改法问题解决了。</p>\n<p>那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。</p>\n<p>这就是ThreadLocal的一个典型应用场景。</p>\n<h2 id=\"ThreadLocal原理：\"><a href=\"#ThreadLocal原理：\" class=\"headerlink\" title=\"ThreadLocal原理：\"></a><strong>ThreadLocal原理</strong>：</h2><p>使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。</p>\n<p>ThreadLocal的set和get方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> (T)map.get(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Maps are constructed lazily.  if the map for this thread</span></div><div class=\"line\">        <span class=\"comment\">// doesn't exist, create it, with this ThreadLocal and its</span></div><div class=\"line\">        <span class=\"comment\">// initial value as its only entry.</span></div><div class=\"line\">        T value = initialValue();</div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。</p>\n<p>很容易明白他的工作原理。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h2><p>之前看了网上很多资料说ThreadLocal的应用场景：</p>\n<p>1.解决了多线程共享对象的问题，</p>\n<p>2.实现线程间的数据隔离，每个线程都有他自己的变量副本。</p>\n<p>对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。</p>\n<p>对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。</p>\n<p>我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：</p>\n<p>1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。</p>\n<p>2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。</p>\n<p>所以，使用ThreadLocal的场景应该是这样：<strong>这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。</strong></p>\n<p>PS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。</p>\n<p>另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。</p>\n<p>我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。</p>\n<h2 id=\"2016-11-01更新\"><a href=\"#2016-11-01更新\" class=\"headerlink\" title=\"2016/11/01更新\"></a><strong>2016/11/01更新</strong></h2><p>今天在地铁上看到了一篇不错的文章，介绍ThreadLocal内存泄漏的实例–ThreadLocal 内存泄露的实例分析.</p>\n<p>另外，该作者的另一篇blog，讲解ThreadLocal的原理，也很清晰深入分析 ThreadLocal 内存泄漏问题</p>\n<p>拜读完作者的文章后，回家又翻了一遍ThreadLocal的源码，认为和作者所要解释的一致，并且对ThreadLocal的理解更加深了。</p>\n<blockquote>\n<p>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread</p>\n</blockquote>\n<p>上面的话出自java doc</p>\n<p>oracle鼓励我们将ThreadLocal对象声明为一个private static类型的变量A。结合上述文章和源码来看，A的生命周期将变得和保存他的类对象一样长，这样ThreadLocalMap中设置的A的弱引用就失去了弱引用的作用，该键A对应的value也不会得到释放，直到此线程销毁。这样一来，如果是使用了线程池的话，当该线程复用时，很有可能会取得错误的值，造成业务逻辑混乱。</p>\n<h2 id=\"解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\"><a href=\"#解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\" class=\"headerlink\" title=\"解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\"></a>解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。</h2><p>另外，有一个例子展示了ThreadLocal的应用场景，现在贴过来。同样来自java doc。例子虽然很简单，但是我觉得很生动的展示了Threadlocal的一个应用场景，让人豁然开朗。</p>\n<p>试想如果不采用ThreadLocal的话，我自己的做法应该会在创建的线程类里面增加一个字段，用来标明线程的id。但是这么做有两点问题：</p>\n<p>第一，增加了字段，挺low。</p>\n<p>第二，有很大的限制，你只能为自己实现的线程类里面加字段。但是往往有些线程不是我们自己定义的。</p>\n<p>这个例子很好的说明了怎么实现一个线程变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadId</span> </span>&#123;</div><div class=\"line\">     <span class=\"comment\">// Atomic integer containing the next thread ID to be assigned</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicInteger nextId = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</div><div class=\"line\">     <span class=\"comment\">// Thread local variable containing each thread's ID</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Integer&gt; threadId =</div><div class=\"line\">         <span class=\"keyword\">new</span> ThreadLocal&lt;Integer&gt;() &#123;</div><div class=\"line\">             <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                 <span class=\"keyword\">return</span> nextId.getAndIncrement();</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;;</div><div class=\"line\">     <span class=\"comment\">// Returns the current thread's unique ID, assigning it if necessary</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> threadId.get();</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"java同步锁锁什么","date":"2015-12-17T06:10:55.000Z","_content":"\n在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：\n情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;\nThreadTest中的成员变量 j 被赋值为 i \n在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;\n在synchronized块中，我改变了这个 j 的值。代码大概是这样的：\n\n```\t\t\t\t\t   \nInteger j;\nThreadTest(Integer i){\n\t\tj=i;\n}\npublic void run() {\n\t\tsynchronized(j){\n\t\t  j++;\n\t\t}\n}\n\n```\n\n1. 一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。\n\n2. 另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。\n\n苦逼了。结果不对\n后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，\n即 void test(Object  i){\n\t\ti.dosomething()......\n   }\n函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。\n这样就解释了出错的 原因：\nInteger 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。\n所以 \n\n对于 1. \n\n当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望\n\n对于 2. \n\n使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步\n\t\t\t\t\t\t\t\n上面的情况也证明了，**synchronized 锁的是内存 ，而不是指向内存的引用**。\n\t\t\t\t\t\t\t\n这样的情况也说明了另外一种情况的问题，那就是**在函数中给实参分配内存,实际在函数体外是得不到这个对象的**。\n\t\t\t\t\t\t\t\n解决的办法：\n放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，\n各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。","source":"_posts/java同步锁锁什么.md","raw":"---\nlayout: post\ntitle:  \"java同步锁锁什么\"\ndate:   2015-12-17 14:10:55\ncategories: 编程\ntags: \n- java\n- 多线程\n---\n\n在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：\n情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;\nThreadTest中的成员变量 j 被赋值为 i \n在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;\n在synchronized块中，我改变了这个 j 的值。代码大概是这样的：\n\n```\t\t\t\t\t   \nInteger j;\nThreadTest(Integer i){\n\t\tj=i;\n}\npublic void run() {\n\t\tsynchronized(j){\n\t\t  j++;\n\t\t}\n}\n\n```\n\n1. 一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。\n\n2. 另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。\n\n苦逼了。结果不对\n后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，\n即 void test(Object  i){\n\t\ti.dosomething()......\n   }\n函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。\n这样就解释了出错的 原因：\nInteger 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。\n所以 \n\n对于 1. \n\n当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望\n\n对于 2. \n\n使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步\n\t\t\t\t\t\t\t\n上面的情况也证明了，**synchronized 锁的是内存 ，而不是指向内存的引用**。\n\t\t\t\t\t\t\t\n这样的情况也说明了另外一种情况的问题，那就是**在函数中给实参分配内存,实际在函数体外是得不到这个对象的**。\n\t\t\t\t\t\t\t\n解决的办法：\n放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，\n各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。","slug":"java同步锁锁什么","published":1,"updated":"2016-11-30T14:32:49.909Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj6g002ldigcwceqcdth","content":"<p>在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：<br>情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;<br>ThreadTest中的成员变量 j 被赋值为 i<br>在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;<br>在synchronized块中，我改变了这个 j 的值。代码大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer j;</div><div class=\"line\">ThreadTest(Integer i)&#123;</div><div class=\"line\">\t\tj=i;</div><div class=\"line\">&#125;</div><div class=\"line\">public void run() &#123;</div><div class=\"line\">\t\tsynchronized(j)&#123;</div><div class=\"line\">\t\t  j++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。</p>\n</li>\n<li><p>另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。</p>\n</li>\n</ol>\n<p>苦逼了。结果不对<br>后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，<br>即 void test(Object  i){<br>        i.dosomething()……<br>   }<br>函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。<br>这样就解释了出错的 原因：<br>Integer 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。<br>所以 </p>\n<p>对于 1. </p>\n<p>当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望</p>\n<p>对于 2. </p>\n<p>使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步</p>\n<p>上面的情况也证明了，<strong>synchronized 锁的是内存 ，而不是指向内存的引用</strong>。</p>\n<p>这样的情况也说明了另外一种情况的问题，那就是<strong>在函数中给实参分配内存,实际在函数体外是得不到这个对象的</strong>。</p>\n<p>解决的办法：<br>放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，<br>各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。</p>\n","excerpt":"","more":"<p>在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：<br>情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;<br>ThreadTest中的成员变量 j 被赋值为 i<br>在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;<br>在synchronized块中，我改变了这个 j 的值。代码大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer j;</div><div class=\"line\">ThreadTest(Integer i)&#123;</div><div class=\"line\">\t\tj=i;</div><div class=\"line\">&#125;</div><div class=\"line\">public void run() &#123;</div><div class=\"line\">\t\tsynchronized(j)&#123;</div><div class=\"line\">\t\t  j++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。</p>\n</li>\n<li><p>另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。</p>\n</li>\n</ol>\n<p>苦逼了。结果不对<br>后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，<br>即 void test(Object  i){<br>        i.dosomething()……<br>   }<br>函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。<br>这样就解释了出错的 原因：<br>Integer 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。<br>所以 </p>\n<p>对于 1. </p>\n<p>当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望</p>\n<p>对于 2. </p>\n<p>使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步</p>\n<p>上面的情况也证明了，<strong>synchronized 锁的是内存 ，而不是指向内存的引用</strong>。</p>\n<p>这样的情况也说明了另外一种情况的问题，那就是<strong>在函数中给实参分配内存,实际在函数体外是得不到这个对象的</strong>。</p>\n<p>解决的办法：<br>放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，<br>各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。</p>\n"},{"layout":"post","title":"常用快捷键总结","date":"2016-03-22T08:31:55.000Z","_content":"- ## ECLIPSE:\n\n   **查看代码**\n   \n   Ctrl+O 搜索当前类变量及方法\n\n   Ctrl+H 打开搜索对话框\n\n   Ctrl+Shift+G  搜索选中变量或方法的引用\n\n   Ctrl+D 删除当前行\n\n   Ctrl+Shift+F 格式化代码\n\n   F4 查看当前类继承结构\n\n   Ctrl+Shift+R 搜索类，文件等资源\n\n   Ctrl+Shift+O 倒包\n   \n   Ctrl + 1 ：快速修复\n  \n   Ctrl + Shift + /(小键盘) ：收起左侧导航树或代码(依据当前焦点而定)\n\n   Ctrl + *(小键盘) ：展开代码\n\n   Shift + Enter ：在当前行下方插入一行空行\n\n   Alt + 向上键 ：当前行与上方行交换\n\n   Alt + 向下键 ：当前行与下方行交换\n\n   Shift + Alt + R : 重命名\n\n   Shift + Alt + L (表达式末尾)：为表达式赋值为局部变量\n\n   Shift + 向上键/向下键 : 选中此行\n\n   Shift + Alt + M : 提取选中代码为一个方法\n\n   Ctrl + . : 下一个错误\n\n   **调试**\n     \n     F5 进入方法内部\n     \n     F6 顺序执行到下一行\n     \n     F7 跳出方法，返回调用处\n     \n     F8 执行到下一个断点\n\n     Ctrl+Shift+I  查看选中表达式的值\n\n     Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法\n\n     Ctrl+R   运行到光标所在的行\n     \n- ## WINDOWS:\n   \n   ALT+TAB 切换窗口\n   \n   ALT+F4  关闭窗口\n   \n   Ctrl+L  锁定\n   \n   Windows+D 显示桌面\n   \n   Windows+E 打开我的电脑\n   \n   Windows+R 打开运行对话框\n   \n   Ctrl+Z 撤销上一步操作\n   \n   Ctrl+Y 恢复撤销的操作\n   \n   Ctrl+Shift+Esc 打开任务管理器\n\n   按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口\n   \n- ## Chorme:\n  \n   Ctrl+N 打开新窗口\n   \n   Ctrl+Tab 切换标签页\n   \n   Ctrl+L 选中网址栏\n   \n   Ctrl+T 新建标签页\n   \n   Ctrl+Shift+T 重新打开上次关闭的标签页\n   \n   Home 转至网页顶部\n   \n   Ctrl+W 关闭标签页\n   \n","source":"_posts/常用快捷键总结.md","raw":"---\nlayout: post\ntitle:  \"常用快捷键总结\"\ndate:   2016-03-22 16:31:55\ncategories: 工具\ntags: \n- 快捷键\n---\n- ## ECLIPSE:\n\n   **查看代码**\n   \n   Ctrl+O 搜索当前类变量及方法\n\n   Ctrl+H 打开搜索对话框\n\n   Ctrl+Shift+G  搜索选中变量或方法的引用\n\n   Ctrl+D 删除当前行\n\n   Ctrl+Shift+F 格式化代码\n\n   F4 查看当前类继承结构\n\n   Ctrl+Shift+R 搜索类，文件等资源\n\n   Ctrl+Shift+O 倒包\n   \n   Ctrl + 1 ：快速修复\n  \n   Ctrl + Shift + /(小键盘) ：收起左侧导航树或代码(依据当前焦点而定)\n\n   Ctrl + *(小键盘) ：展开代码\n\n   Shift + Enter ：在当前行下方插入一行空行\n\n   Alt + 向上键 ：当前行与上方行交换\n\n   Alt + 向下键 ：当前行与下方行交换\n\n   Shift + Alt + R : 重命名\n\n   Shift + Alt + L (表达式末尾)：为表达式赋值为局部变量\n\n   Shift + 向上键/向下键 : 选中此行\n\n   Shift + Alt + M : 提取选中代码为一个方法\n\n   Ctrl + . : 下一个错误\n\n   **调试**\n     \n     F5 进入方法内部\n     \n     F6 顺序执行到下一行\n     \n     F7 跳出方法，返回调用处\n     \n     F8 执行到下一个断点\n\n     Ctrl+Shift+I  查看选中表达式的值\n\n     Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法\n\n     Ctrl+R   运行到光标所在的行\n     \n- ## WINDOWS:\n   \n   ALT+TAB 切换窗口\n   \n   ALT+F4  关闭窗口\n   \n   Ctrl+L  锁定\n   \n   Windows+D 显示桌面\n   \n   Windows+E 打开我的电脑\n   \n   Windows+R 打开运行对话框\n   \n   Ctrl+Z 撤销上一步操作\n   \n   Ctrl+Y 恢复撤销的操作\n   \n   Ctrl+Shift+Esc 打开任务管理器\n\n   按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口\n   \n- ## Chorme:\n  \n   Ctrl+N 打开新窗口\n   \n   Ctrl+Tab 切换标签页\n   \n   Ctrl+L 选中网址栏\n   \n   Ctrl+T 新建标签页\n   \n   Ctrl+Shift+T 重新打开上次关闭的标签页\n   \n   Home 转至网页顶部\n   \n   Ctrl+W 关闭标签页\n   \n","slug":"常用快捷键总结","published":1,"updated":"2016-11-30T14:32:49.913Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj6k002pdigc0vtvnumb","content":"<ul>\n<li><h2 id=\"ECLIPSE\"><a href=\"#ECLIPSE\" class=\"headerlink\" title=\"ECLIPSE:\"></a>ECLIPSE:</h2><p> <strong>查看代码</strong></p>\n<p> Ctrl+O 搜索当前类变量及方法</p>\n<p> Ctrl+H 打开搜索对话框</p>\n<p> Ctrl+Shift+G  搜索选中变量或方法的引用</p>\n<p> Ctrl+D 删除当前行</p>\n<p> Ctrl+Shift+F 格式化代码</p>\n<p> F4 查看当前类继承结构</p>\n<p> Ctrl+Shift+R 搜索类，文件等资源</p>\n<p> Ctrl+Shift+O 倒包</p>\n<p> Ctrl + 1 ：快速修复</p>\n<p> Ctrl + Shift + /(小键盘) ：收起左侧导航树或代码(依据当前焦点而定)</p>\n<p> Ctrl + *(小键盘) ：展开代码</p>\n<p> Shift + Enter ：在当前行下方插入一行空行</p>\n<p> Alt + 向上键 ：当前行与上方行交换</p>\n<p> Alt + 向下键 ：当前行与下方行交换</p>\n<p> Shift + Alt + R : 重命名</p>\n<p> Shift + Alt + L (表达式末尾)：为表达式赋值为局部变量</p>\n<p> Shift + 向上键/向下键 : 选中此行</p>\n<p> Shift + Alt + M : 提取选中代码为一个方法</p>\n<p> Ctrl + . : 下一个错误</p>\n<p> <strong>调试</strong></p>\n<p>   F5 进入方法内部</p>\n<p>   F6 顺序执行到下一行</p>\n<p>   F7 跳出方法，返回调用处</p>\n<p>   F8 执行到下一个断点</p>\n<p>   Ctrl+Shift+I  查看选中表达式的值</p>\n<p>   Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法</p>\n<p>   Ctrl+R   运行到光标所在的行</p>\n</li>\n<li><h2 id=\"WINDOWS\"><a href=\"#WINDOWS\" class=\"headerlink\" title=\"WINDOWS:\"></a>WINDOWS:</h2><p> ALT+TAB 切换窗口</p>\n<p> ALT+F4  关闭窗口</p>\n<p> Ctrl+L  锁定</p>\n<p> Windows+D 显示桌面</p>\n<p> Windows+E 打开我的电脑</p>\n<p> Windows+R 打开运行对话框</p>\n<p> Ctrl+Z 撤销上一步操作</p>\n<p> Ctrl+Y 恢复撤销的操作</p>\n<p> Ctrl+Shift+Esc 打开任务管理器</p>\n<p> 按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口</p>\n</li>\n<li><h2 id=\"Chorme\"><a href=\"#Chorme\" class=\"headerlink\" title=\"Chorme:\"></a>Chorme:</h2><p> Ctrl+N 打开新窗口</p>\n<p> Ctrl+Tab 切换标签页</p>\n<p> Ctrl+L 选中网址栏</p>\n<p> Ctrl+T 新建标签页</p>\n<p> Ctrl+Shift+T 重新打开上次关闭的标签页</p>\n<p> Home 转至网页顶部</p>\n<p> Ctrl+W 关闭标签页</p>\n</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li><h2 id=\"ECLIPSE\"><a href=\"#ECLIPSE\" class=\"headerlink\" title=\"ECLIPSE:\"></a>ECLIPSE:</h2><p> <strong>查看代码</strong></p>\n<p> Ctrl+O 搜索当前类变量及方法</p>\n<p> Ctrl+H 打开搜索对话框</p>\n<p> Ctrl+Shift+G  搜索选中变量或方法的引用</p>\n<p> Ctrl+D 删除当前行</p>\n<p> Ctrl+Shift+F 格式化代码</p>\n<p> F4 查看当前类继承结构</p>\n<p> Ctrl+Shift+R 搜索类，文件等资源</p>\n<p> Ctrl+Shift+O 倒包</p>\n<p> Ctrl + 1 ：快速修复</p>\n<p> Ctrl + Shift + /(小键盘) ：收起左侧导航树或代码(依据当前焦点而定)</p>\n<p> Ctrl + *(小键盘) ：展开代码</p>\n<p> Shift + Enter ：在当前行下方插入一行空行</p>\n<p> Alt + 向上键 ：当前行与上方行交换</p>\n<p> Alt + 向下键 ：当前行与下方行交换</p>\n<p> Shift + Alt + R : 重命名</p>\n<p> Shift + Alt + L (表达式末尾)：为表达式赋值为局部变量</p>\n<p> Shift + 向上键/向下键 : 选中此行</p>\n<p> Shift + Alt + M : 提取选中代码为一个方法</p>\n<p> Ctrl + . : 下一个错误</p>\n<p> <strong>调试</strong></p>\n<p>   F5 进入方法内部</p>\n<p>   F6 顺序执行到下一行</p>\n<p>   F7 跳出方法，返回调用处</p>\n<p>   F8 执行到下一个断点</p>\n<p>   Ctrl+Shift+I  查看选中表达式的值</p>\n<p>   Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法</p>\n<p>   Ctrl+R   运行到光标所在的行</p>\n</li>\n<li><h2 id=\"WINDOWS\"><a href=\"#WINDOWS\" class=\"headerlink\" title=\"WINDOWS:\"></a>WINDOWS:</h2><p> ALT+TAB 切换窗口</p>\n<p> ALT+F4  关闭窗口</p>\n<p> Ctrl+L  锁定</p>\n<p> Windows+D 显示桌面</p>\n<p> Windows+E 打开我的电脑</p>\n<p> Windows+R 打开运行对话框</p>\n<p> Ctrl+Z 撤销上一步操作</p>\n<p> Ctrl+Y 恢复撤销的操作</p>\n<p> Ctrl+Shift+Esc 打开任务管理器</p>\n<p> 按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口</p>\n</li>\n<li><h2 id=\"Chorme\"><a href=\"#Chorme\" class=\"headerlink\" title=\"Chorme:\"></a>Chorme:</h2><p> Ctrl+N 打开新窗口</p>\n<p> Ctrl+Tab 切换标签页</p>\n<p> Ctrl+L 选中网址栏</p>\n<p> Ctrl+T 新建标签页</p>\n<p> Ctrl+Shift+T 重新打开上次关闭的标签页</p>\n<p> Home 转至网页顶部</p>\n<p> Ctrl+W 关闭标签页</p>\n</li>\n</ul>\n"},{"layout":"post","title":"关于抽象类和接口","date":"2016-04-15T14:48:55.000Z","_content":"\n## 抽象类：\n\n> 使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.\n\n   - 抽象类不能被实例化\n\n   - 如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类\n\n   - 抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。\n\n   - 可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。\n   \n   - 不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。\n\n   - 抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。\n\n   - 子类中的抽象方法不能与父类的抽象方法同名\n\n   - 其余情况抽象类与普通类相同。\n\n\n## 接口：\n\n\n > 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.\n\n   - 接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。\n\n   - 接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。\n\n   - 接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。\n\n   - 接口中没有构造方法，不能被实例化。\n\n   - 如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。\n\n   - 接口中不能含有静态代码块以及静态方法。\n\n   - 在实现多接口的时候一定要避免方法名的重复。\n\n## 区别与联系：\n   \n   - **语义**\n   \n     1. 一个类只能继承一个抽象类，但可以实现多个接口。\n\n     2. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法\n\n   - **设计思想**\n\n     >抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。\n\n     1. 抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。\n\n        对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。\n\n     2. 抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。\n    \n        抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n\n     3. 抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n\n        对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。\n\n     **示例**\n\n     门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n\n  \n```java\nabstract class Door {\n      public abstract void open();\n      public abstract void close();\n}\n```\n    \t\n\n或\n \n```java\ninterface Door {\n      public abstract void open();\n      public abstract void close();\n} \n```\n\n\n但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：\n\n1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；\n\n2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。\n\n从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。\n      \n\n```java\ninterface Alram {\n      void alarm();\n}\nabstract class Door {\n      void open();\n      void close();\n}\nclass AlarmDoor extends Door implements Alarm {\n      void oepn() {\n           //....\n      }\n      void close() {\n           //....\n      }\n      void alarm() {\n           //....\n      }\n} \n```\n---------------------\n## **对继承的思考**\n\n2016/10/27更新\n\n写代码的过程中发现java的继承经常被滥用。思考一下解决方法...\n\n1.当子类和父类属于同一个种类时使用继承，而不是拥有相同的功能。\n\n  比如：飞机能飞，鸟也能飞。但是这两种东西不应该归为一类。飞只是个功能，可以作为一个接口。\n        鸟却可以是大雁的父类，他们从本质上是一种东西\n\n2.继承可用于模板方法模式。即能够从很多类中抽象出同一个流程，把这个流程作为一个模板写在父类当中。设置好钩子供子类实现。\n\n3.既不属于同一种类又没有抽象出模板，但是多个类之间有相同的代码冗余。考虑委托，写一个通用的Utility类，吧冗余的代码放到utility类当中去，把需要的参数传进去。避免滥用继承。比如：\n\n写web服务器时，有很多controller，如果这些controller关联不大，没必要继承同一个父类。但是都有一个验证身份的verify方法，考虑把这个verify方法写到一个Utility类中，所有的controller去调用它。\n\n\n## **资料:**\n\n   [Java 中的接口有什么作用？](https://www.zhihu.com/question/20111251)\n\n   [java提高篇（四）-----抽象类与接口](http://blog.csdn.net/chenssy/article/details/12858267)\n\n","source":"_posts/关于抽象类和接口.md","raw":"---\nlayout: post\ntitle:  \"关于抽象类和接口\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-15 22:48:55\n---\n\n## 抽象类：\n\n> 使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.\n\n   - 抽象类不能被实例化\n\n   - 如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类\n\n   - 抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。\n\n   - 可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。\n   \n   - 不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。\n\n   - 抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。\n\n   - 子类中的抽象方法不能与父类的抽象方法同名\n\n   - 其余情况抽象类与普通类相同。\n\n\n## 接口：\n\n\n > 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.\n\n   - 接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。\n\n   - 接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。\n\n   - 接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。\n\n   - 接口中没有构造方法，不能被实例化。\n\n   - 如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。\n\n   - 接口中不能含有静态代码块以及静态方法。\n\n   - 在实现多接口的时候一定要避免方法名的重复。\n\n## 区别与联系：\n   \n   - **语义**\n   \n     1. 一个类只能继承一个抽象类，但可以实现多个接口。\n\n     2. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法\n\n   - **设计思想**\n\n     >抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。\n\n     1. 抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。\n\n        对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。\n\n     2. 抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。\n    \n        抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n\n     3. 抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n\n        对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。\n\n     **示例**\n\n     门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n\n  \n```java\nabstract class Door {\n      public abstract void open();\n      public abstract void close();\n}\n```\n    \t\n\n或\n \n```java\ninterface Door {\n      public abstract void open();\n      public abstract void close();\n} \n```\n\n\n但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：\n\n1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；\n\n2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。\n\n从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。\n      \n\n```java\ninterface Alram {\n      void alarm();\n}\nabstract class Door {\n      void open();\n      void close();\n}\nclass AlarmDoor extends Door implements Alarm {\n      void oepn() {\n           //....\n      }\n      void close() {\n           //....\n      }\n      void alarm() {\n           //....\n      }\n} \n```\n---------------------\n## **对继承的思考**\n\n2016/10/27更新\n\n写代码的过程中发现java的继承经常被滥用。思考一下解决方法...\n\n1.当子类和父类属于同一个种类时使用继承，而不是拥有相同的功能。\n\n  比如：飞机能飞，鸟也能飞。但是这两种东西不应该归为一类。飞只是个功能，可以作为一个接口。\n        鸟却可以是大雁的父类，他们从本质上是一种东西\n\n2.继承可用于模板方法模式。即能够从很多类中抽象出同一个流程，把这个流程作为一个模板写在父类当中。设置好钩子供子类实现。\n\n3.既不属于同一种类又没有抽象出模板，但是多个类之间有相同的代码冗余。考虑委托，写一个通用的Utility类，吧冗余的代码放到utility类当中去，把需要的参数传进去。避免滥用继承。比如：\n\n写web服务器时，有很多controller，如果这些controller关联不大，没必要继承同一个父类。但是都有一个验证身份的verify方法，考虑把这个verify方法写到一个Utility类中，所有的controller去调用它。\n\n\n## **资料:**\n\n   [Java 中的接口有什么作用？](https://www.zhihu.com/question/20111251)\n\n   [java提高篇（四）-----抽象类与接口](http://blog.csdn.net/chenssy/article/details/12858267)\n\n","slug":"关于抽象类和接口","published":1,"updated":"2016-11-30T14:32:49.913Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj6m002sdigcxou9yme9","content":"<h2 id=\"抽象类：\"><a href=\"#抽象类：\" class=\"headerlink\" title=\"抽象类：\"></a>抽象类：</h2><blockquote>\n<p>使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.</p>\n</blockquote>\n<ul>\n<li><p>抽象类不能被实例化</p>\n</li>\n<li><p>如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类</p>\n</li>\n<li><p>抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。</p>\n</li>\n<li><p>可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。</p>\n</li>\n<li><p>不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。</p>\n</li>\n<li><p>抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。</p>\n</li>\n<li><p>子类中的抽象方法不能与父类的抽象方法同名</p>\n</li>\n<li><p>其余情况抽象类与普通类相同。</p>\n</li>\n</ul>\n<h2 id=\"接口：\"><a href=\"#接口：\" class=\"headerlink\" title=\"接口：\"></a>接口：</h2><blockquote>\n<p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.</p>\n</blockquote>\n<ul>\n<li><p>接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。</p>\n</li>\n<li><p>接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。</p>\n</li>\n<li><p>接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。</p>\n</li>\n<li><p>接口中没有构造方法，不能被实例化。</p>\n</li>\n<li><p>如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>\n</li>\n<li><p>接口中不能含有静态代码块以及静态方法。</p>\n</li>\n<li><p>在实现多接口的时候一定要避免方法名的重复。</p>\n</li>\n</ul>\n<h2 id=\"区别与联系：\"><a href=\"#区别与联系：\" class=\"headerlink\" title=\"区别与联系：\"></a>区别与联系：</h2><ul>\n<li><p><strong>语义</strong></p>\n<ol>\n<li><p>一个类只能继承一个抽象类，但可以实现多个接口。</p>\n</li>\n<li><p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法</p>\n</li>\n</ol>\n</li>\n<li><p><strong>设计思想</strong></p>\n<blockquote>\n<p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</p>\n</blockquote>\n<ol>\n<li><p>抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。</p>\n<p>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>\n</li>\n<li><p>抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。</p>\n<p>抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。</p>\n</li>\n<li><p>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>\n<p>对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。</p>\n</li>\n</ol>\n<p><strong>示例</strong></p>\n<p>门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>\n<p>1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>\n<p>2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>\n<p>从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alram</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">oepn</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"对继承的思考\"><a href=\"#对继承的思考\" class=\"headerlink\" title=\"对继承的思考\"></a><strong>对继承的思考</strong></h2><p>2016/10/27更新</p>\n<p>写代码的过程中发现java的继承经常被滥用。思考一下解决方法…</p>\n<p>1.当子类和父类属于同一个种类时使用继承，而不是拥有相同的功能。</p>\n<p>  比如：飞机能飞，鸟也能飞。但是这两种东西不应该归为一类。飞只是个功能，可以作为一个接口。<br>        鸟却可以是大雁的父类，他们从本质上是一种东西</p>\n<p>2.继承可用于模板方法模式。即能够从很多类中抽象出同一个流程，把这个流程作为一个模板写在父类当中。设置好钩子供子类实现。</p>\n<p>3.既不属于同一种类又没有抽象出模板，但是多个类之间有相同的代码冗余。考虑委托，写一个通用的Utility类，吧冗余的代码放到utility类当中去，把需要的参数传进去。避免滥用继承。比如：</p>\n<p>写web服务器时，有很多controller，如果这些controller关联不大，没必要继承同一个父类。但是都有一个验证身份的verify方法，考虑把这个verify方法写到一个Utility类中，所有的controller去调用它。</p>\n<h2 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料:\"></a><strong>资料:</strong></h2><p>   <a href=\"https://www.zhihu.com/question/20111251\" target=\"_blank\" rel=\"external\">Java 中的接口有什么作用？</a></p>\n<p>   <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\" target=\"_blank\" rel=\"external\">java提高篇（四）—–抽象类与接口</a></p>\n","excerpt":"","more":"<h2 id=\"抽象类：\"><a href=\"#抽象类：\" class=\"headerlink\" title=\"抽象类：\"></a>抽象类：</h2><blockquote>\n<p>使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.</p>\n</blockquote>\n<ul>\n<li><p>抽象类不能被实例化</p>\n</li>\n<li><p>如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类</p>\n</li>\n<li><p>抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。</p>\n</li>\n<li><p>可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。</p>\n</li>\n<li><p>不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。</p>\n</li>\n<li><p>抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。</p>\n</li>\n<li><p>子类中的抽象方法不能与父类的抽象方法同名</p>\n</li>\n<li><p>其余情况抽象类与普通类相同。</p>\n</li>\n</ul>\n<h2 id=\"接口：\"><a href=\"#接口：\" class=\"headerlink\" title=\"接口：\"></a>接口：</h2><blockquote>\n<p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.</p>\n</blockquote>\n<ul>\n<li><p>接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。</p>\n</li>\n<li><p>接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。</p>\n</li>\n<li><p>接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。</p>\n</li>\n<li><p>接口中没有构造方法，不能被实例化。</p>\n</li>\n<li><p>如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>\n</li>\n<li><p>接口中不能含有静态代码块以及静态方法。</p>\n</li>\n<li><p>在实现多接口的时候一定要避免方法名的重复。</p>\n</li>\n</ul>\n<h2 id=\"区别与联系：\"><a href=\"#区别与联系：\" class=\"headerlink\" title=\"区别与联系：\"></a>区别与联系：</h2><ul>\n<li><p><strong>语义</strong></p>\n<ol>\n<li><p>一个类只能继承一个抽象类，但可以实现多个接口。</p>\n</li>\n<li><p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法</p>\n</li>\n</ol>\n</li>\n<li><p><strong>设计思想</strong></p>\n<blockquote>\n<p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</p>\n</blockquote>\n<ol>\n<li><p>抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。</p>\n<p>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>\n</li>\n<li><p>抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。</p>\n<p>抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。</p>\n</li>\n<li><p>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>\n<p>对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。</p>\n</li>\n</ol>\n<p><strong>示例</strong></p>\n<p>门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>\n<p>1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>\n<p>2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>\n<p>从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alram</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">oepn</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"对继承的思考\"><a href=\"#对继承的思考\" class=\"headerlink\" title=\"对继承的思考\"></a><strong>对继承的思考</strong></h2><p>2016/10/27更新</p>\n<p>写代码的过程中发现java的继承经常被滥用。思考一下解决方法…</p>\n<p>1.当子类和父类属于同一个种类时使用继承，而不是拥有相同的功能。</p>\n<p>  比如：飞机能飞，鸟也能飞。但是这两种东西不应该归为一类。飞只是个功能，可以作为一个接口。<br>        鸟却可以是大雁的父类，他们从本质上是一种东西</p>\n<p>2.继承可用于模板方法模式。即能够从很多类中抽象出同一个流程，把这个流程作为一个模板写在父类当中。设置好钩子供子类实现。</p>\n<p>3.既不属于同一种类又没有抽象出模板，但是多个类之间有相同的代码冗余。考虑委托，写一个通用的Utility类，吧冗余的代码放到utility类当中去，把需要的参数传进去。避免滥用继承。比如：</p>\n<p>写web服务器时，有很多controller，如果这些controller关联不大，没必要继承同一个父类。但是都有一个验证身份的verify方法，考虑把这个verify方法写到一个Utility类中，所有的controller去调用它。</p>\n<h2 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料:\"></a><strong>资料:</strong></h2><p>   <a href=\"https://www.zhihu.com/question/20111251\">Java 中的接口有什么作用？</a></p>\n<p>   <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\">java提高篇（四）—–抽象类与接口</a></p>\n"},{"layout":"post","title":"理解notify notifyall sleep","date":"2016-08-31T13:27:09.000Z","_content":"\n今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。\n\n## 从线程状态说起\n\n一般的操作系统中，线程的状态大概有这么几个：\n\n1. 执行：线程获得cpu，程序正在执行\n\n2. 就绪：线程已经准备好运行，只要获得cpu，便立即执行\n\n3. 阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度\n\n4. 挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。\n\n5. 激活：把一个挂起的线程激活\n\n着重理解一下几个关键状态的转换：\n\n活动就绪-->静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。\n\n活动阻塞-->静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。\n\n注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。\n\n画个图理解一下：\n\n{% asset_img 线程状态.png %}\n\n线程创建和终止状态不再讨论。\n\n## wait\n\nwait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。\n\n当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。\n\n调用wait方法，相当于上图中**执行->活动阻塞->静止阻塞**的过程。同时，wait方法释放了对象的锁，然后阻塞，挂起，等待被唤醒。\n\n## notify\n\n当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒(挂起)的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒(激活),这个过程相当于上图中**静止阻塞->活动阻塞**的过程。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。\n\n此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图**活动阻塞->活动就绪**的过程。此时线程等待调度执行。\n\n需要注意的是，notify不恰当使用很有可能造成死锁问题。\n\n## notifyAll\n\n当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒(挂起)的线程(调用了A的wait方法的线程)唤醒(激活)。这些线程会开始竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。\n\n## sleep\n\n与以上三个关键字不同的是，sleep方法是Thread中的方法。\n\n当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。调用sleep的目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;\n\n调用线程Y的sleep(1000)sleep方法，相当于上图中**执行->静止就绪状态**。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。\n\n## synchronized\n\n当程序执行遇到synchronized关键字的时候，若此时锁被占用，则线程被阻塞。相当于上图中**执行->活动阻塞**过程。\n\nPS：上述的几个状态跟java中描述的Thread.state并不尽相同。而且底层真正的运行情况(OS的线程状态)是否是跟以上描述相同也有待考究。但是我理解的这几个关键字对外的表现应该与上述描述是一样的。\n\n参考知乎上的一个提问：[java sleep和wait的区别的疑惑?](https://www.zhihu.com/question/23328075)\n\n## 使用场景\n\nObject.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？\n\n在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。\n\n例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。","source":"_posts/理解notify notifyall sleep.md","raw":"layout: post\ntitle: 理解notify notifyall sleep\ndate: 2016-08-31 21:27:09\ncategories: 编程\ntags:\n- java\n- 多线程 \n---\n\n今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。\n\n## 从线程状态说起\n\n一般的操作系统中，线程的状态大概有这么几个：\n\n1. 执行：线程获得cpu，程序正在执行\n\n2. 就绪：线程已经准备好运行，只要获得cpu，便立即执行\n\n3. 阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度\n\n4. 挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。\n\n5. 激活：把一个挂起的线程激活\n\n着重理解一下几个关键状态的转换：\n\n活动就绪-->静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。\n\n活动阻塞-->静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。\n\n注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。\n\n画个图理解一下：\n\n{% asset_img 线程状态.png %}\n\n线程创建和终止状态不再讨论。\n\n## wait\n\nwait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。\n\n当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。\n\n调用wait方法，相当于上图中**执行->活动阻塞->静止阻塞**的过程。同时，wait方法释放了对象的锁，然后阻塞，挂起，等待被唤醒。\n\n## notify\n\n当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒(挂起)的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒(激活),这个过程相当于上图中**静止阻塞->活动阻塞**的过程。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。\n\n此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图**活动阻塞->活动就绪**的过程。此时线程等待调度执行。\n\n需要注意的是，notify不恰当使用很有可能造成死锁问题。\n\n## notifyAll\n\n当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒(挂起)的线程(调用了A的wait方法的线程)唤醒(激活)。这些线程会开始竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。\n\n## sleep\n\n与以上三个关键字不同的是，sleep方法是Thread中的方法。\n\n当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。调用sleep的目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;\n\n调用线程Y的sleep(1000)sleep方法，相当于上图中**执行->静止就绪状态**。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。\n\n## synchronized\n\n当程序执行遇到synchronized关键字的时候，若此时锁被占用，则线程被阻塞。相当于上图中**执行->活动阻塞**过程。\n\nPS：上述的几个状态跟java中描述的Thread.state并不尽相同。而且底层真正的运行情况(OS的线程状态)是否是跟以上描述相同也有待考究。但是我理解的这几个关键字对外的表现应该与上述描述是一样的。\n\n参考知乎上的一个提问：[java sleep和wait的区别的疑惑?](https://www.zhihu.com/question/23328075)\n\n## 使用场景\n\nObject.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？\n\n在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。\n\n例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。","slug":"理解notify notifyall sleep","published":1,"updated":"2016-11-30T14:32:49.921Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj6p002wdigcd2i6nfzk","content":"<p>今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。</p>\n<h2 id=\"从线程状态说起\"><a href=\"#从线程状态说起\" class=\"headerlink\" title=\"从线程状态说起\"></a>从线程状态说起</h2><p>一般的操作系统中，线程的状态大概有这么几个：</p>\n<ol>\n<li><p>执行：线程获得cpu，程序正在执行</p>\n</li>\n<li><p>就绪：线程已经准备好运行，只要获得cpu，便立即执行</p>\n</li>\n<li><p>阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度</p>\n</li>\n<li><p>挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。</p>\n</li>\n<li><p>激活：把一个挂起的线程激活</p>\n</li>\n</ol>\n<p>着重理解一下几个关键状态的转换：</p>\n<p>活动就绪–&gt;静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。</p>\n<p>活动阻塞–&gt;静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。</p>\n<p>注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。</p>\n<p>画个图理解一下：</p>\n<img src=\"/2016/08/31/理解notify%20notifyall%20sleep/线程状态.png\" alt=\"线程状态.png\" title=\"\">\n<p>线程创建和终止状态不再讨论。</p>\n<h2 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h2><p>wait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。</p>\n<p>当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。</p>\n<p>调用wait方法，相当于上图中<strong>执行-&gt;活动阻塞-&gt;静止阻塞</strong>的过程。同时，wait方法释放了对象的锁，然后阻塞，挂起，等待被唤醒。</p>\n<h2 id=\"notify\"><a href=\"#notify\" class=\"headerlink\" title=\"notify\"></a>notify</h2><p>当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒(挂起)的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒(激活),这个过程相当于上图中<strong>静止阻塞-&gt;活动阻塞</strong>的过程。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。</p>\n<p>此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图<strong>活动阻塞-&gt;活动就绪</strong>的过程。此时线程等待调度执行。</p>\n<p>需要注意的是，notify不恰当使用很有可能造成死锁问题。</p>\n<h2 id=\"notifyAll\"><a href=\"#notifyAll\" class=\"headerlink\" title=\"notifyAll\"></a>notifyAll</h2><p>当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒(挂起)的线程(调用了A的wait方法的线程)唤醒(激活)。这些线程会开始竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。</p>\n<h2 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep\"></a>sleep</h2><p>与以上三个关键字不同的是，sleep方法是Thread中的方法。</p>\n<p>当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。调用sleep的目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;</p>\n<p>调用线程Y的sleep(1000)sleep方法，相当于上图中<strong>执行-&gt;静止就绪状态</strong>。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。</p>\n<h2 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h2><p>当程序执行遇到synchronized关键字的时候，若此时锁被占用，则线程被阻塞。相当于上图中<strong>执行-&gt;活动阻塞</strong>过程。</p>\n<p>PS：上述的几个状态跟java中描述的Thread.state并不尽相同。而且底层真正的运行情况(OS的线程状态)是否是跟以上描述相同也有待考究。但是我理解的这几个关键字对外的表现应该与上述描述是一样的。</p>\n<p>参考知乎上的一个提问：<a href=\"https://www.zhihu.com/question/23328075\" target=\"_blank\" rel=\"external\">java sleep和wait的区别的疑惑?</a></p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>Object.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？</p>\n<p>在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。</p>\n<p>例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。</p>\n","excerpt":"","more":"<p>今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。</p>\n<h2 id=\"从线程状态说起\"><a href=\"#从线程状态说起\" class=\"headerlink\" title=\"从线程状态说起\"></a>从线程状态说起</h2><p>一般的操作系统中，线程的状态大概有这么几个：</p>\n<ol>\n<li><p>执行：线程获得cpu，程序正在执行</p>\n</li>\n<li><p>就绪：线程已经准备好运行，只要获得cpu，便立即执行</p>\n</li>\n<li><p>阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度</p>\n</li>\n<li><p>挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。</p>\n</li>\n<li><p>激活：把一个挂起的线程激活</p>\n</li>\n</ol>\n<p>着重理解一下几个关键状态的转换：</p>\n<p>活动就绪–&gt;静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。</p>\n<p>活动阻塞–&gt;静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。</p>\n<p>注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。</p>\n<p>画个图理解一下：</p>\n<img src=\"/2016/08/31/理解notify%20notifyall%20sleep/线程状态.png\" alt=\"线程状态.png\" title=\"\">\n<p>线程创建和终止状态不再讨论。</p>\n<h2 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h2><p>wait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。</p>\n<p>当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。</p>\n<p>调用wait方法，相当于上图中<strong>执行-&gt;活动阻塞-&gt;静止阻塞</strong>的过程。同时，wait方法释放了对象的锁，然后阻塞，挂起，等待被唤醒。</p>\n<h2 id=\"notify\"><a href=\"#notify\" class=\"headerlink\" title=\"notify\"></a>notify</h2><p>当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒(挂起)的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒(激活),这个过程相当于上图中<strong>静止阻塞-&gt;活动阻塞</strong>的过程。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。</p>\n<p>此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图<strong>活动阻塞-&gt;活动就绪</strong>的过程。此时线程等待调度执行。</p>\n<p>需要注意的是，notify不恰当使用很有可能造成死锁问题。</p>\n<h2 id=\"notifyAll\"><a href=\"#notifyAll\" class=\"headerlink\" title=\"notifyAll\"></a>notifyAll</h2><p>当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒(挂起)的线程(调用了A的wait方法的线程)唤醒(激活)。这些线程会开始竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。</p>\n<h2 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep\"></a>sleep</h2><p>与以上三个关键字不同的是，sleep方法是Thread中的方法。</p>\n<p>当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。调用sleep的目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;</p>\n<p>调用线程Y的sleep(1000)sleep方法，相当于上图中<strong>执行-&gt;静止就绪状态</strong>。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。</p>\n<h2 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h2><p>当程序执行遇到synchronized关键字的时候，若此时锁被占用，则线程被阻塞。相当于上图中<strong>执行-&gt;活动阻塞</strong>过程。</p>\n<p>PS：上述的几个状态跟java中描述的Thread.state并不尽相同。而且底层真正的运行情况(OS的线程状态)是否是跟以上描述相同也有待考究。但是我理解的这几个关键字对外的表现应该与上述描述是一样的。</p>\n<p>参考知乎上的一个提问：<a href=\"https://www.zhihu.com/question/23328075\">java sleep和wait的区别的疑惑?</a></p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>Object.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？</p>\n<p>在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。</p>\n<p>例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。</p>\n"},{"layout":"post","title":"理解java内存模型","date":"2016-09-10T02:32:40.000Z","_content":"\n最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~\n\n## 并发为啥会出现问题\n\nPS：2016/9/13更新：今天在地铁上看到这篇文章：[Java 并发原理无废话指南](http://toutiao.io/posts/493923/app_preview),感觉跟我这一小节要说明的问题比较相似，参考一下。\n\n### 原子性\n\n其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：\n\n```java\npublic class BankAccount {\n\tprivate static int accountBalance = 10000;\n\n\tstatic class Save implements Runnable {\n\t\tprivate int money;\n\n\t\tpublic Save(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\t//存钱\n\t\t\tint tempAccount = accountBalance + money;\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次存入：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tstatic class Obtain implements Runnable {\n\n\t\tprivate int money;\n\n\t\tpublic Obtain(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (money > accountBalance) {\n\t\t\t\tSystem.out.println(\"余额不足\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//取钱\n\t\t\tint tempAccount = accountBalance - money;\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);//艾玛，卡了一秒\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次取出：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tint saveMoney = 10000;\n\t\tint obtainMoney = 10000;\n\t\t//自己取钱\n\t\tThread obtain = new Thread(new Obtain(obtainMoney));\n\t\t//老婆存钱\n\t\tThread save = new Thread(new Save(saveMoney));\n\t\tobtain.start();\n\t\tsave.start();\n\t}\n\n}\n```\n\n输出结果：\n\n```\n此次存入：10000\n当前余额：20000\n此次取出：10000\n当前余额：0\n```\n\n可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。\n\n分析一下出现问题的原因：\n\n出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。\n\n这就涉及到线程并发的第一个问题：原子性。\n\n我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。\n\n```\n//取钱\nint tempAccount = accountBalance - money;\n\n//设置余额\naccountBalance = tempAccount;\n```\n\n为了实现这种错误的效果，我故意把\n\n```\naccountBalance -= accountBalance;\n```\n\n拆成了上面的两行。其实`accountBalance -= accountBalance;`本身就不是一个原子操作，拆成两行是为了放大这种效果。\n\n通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。\n\n原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。\n\njava中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。\n\n那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。\n\n### 可见性\n\n组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。\n\nJava虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）\n\n画个图：\n\n{% asset_img 内存模型.png 内存模型 %}\n\n这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。\n\n我们回到上述的例子：\n\n上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似`accountBalance -= accountBalance;`这样的操作是原子性操作，设想以下的场景：\n\n1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时`accountBalance~ = 20000;accountBalance = 10000;`\n\n2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时`accountBalance~ = 0;accountBalance = 10000;`\n\n3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；\n\n4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；\n\n通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。\n\n我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。\n\n### 有序性\n\nCpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。\n\n以下例子来自《深入理解Java虚拟机》：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\nconfigOptions = new HashMap();\nconfigText = readConfigFile(flieName);\nprocessConfigOptions(configText,configOptions);\ninitialized = true;\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\nwhile(!initialized){\n\tsleep();\n}\n//使用线程A中初始化好的配置信息\ndoSomethingWithConfig();\n```\n\n在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码`initialized=true`被提前执行，这样线程B中使用配置信息的代码就可能出现错误。\n\n所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\npublic synchronized void init(){\n\tconfigOptions = new HashMap();\n\tconfigText = readConfigFile(flieName);\n\tprocessConfigOptions(configText,configOptions);\n\tinitialized = true;\n}\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\npublic synchronized void doSomething(){\n\twhile(!initialized){\n\t\tsleep();\n\t}\n\t//使用线程A中初始化好的配置信息\n\tdoSomethingWithConfig();\n}\n```\n注意上面两个方法在同一个类中实现。\n\n至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇[synchronized的用法](http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/)，对synchronized的使用更加得心应手啦！\n\n## 先行发生原则\n\n没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。\n\n比如我想到了之前宇哥跟我提到的一个bug:\n\n在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。\n\n后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用`calendar.setTime(date);`,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个`calendar.setTime(date);`，结果肯定就变得混乱了。\n\n上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。\n\n解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。\n\n先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。\n\n还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：\n\n```\n//以下操作在线程A中执行\ni = 1;\n\n//以下操作在线程B中执行\nj = i;\n\n//以下操作在线程C中执行\ni = 2;\n```\n\n假设线程A中的操作`i=1`先行发生于线程B的操作`j=i`,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，`i=1`的结果可以被B观察到。\n\n现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。\n\n其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。\n\n你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性...\n\n如果还没有理解所谓的先行发生原则的话，可以看一下[这篇文章](http://ifeve.com/easy-happens-before/)。\n\n下面介绍几个java内存模型中存在的先行发生关系：\n\n**程序次序规则**：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。\n\n**管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。\n\n**volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。\n\n**传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。\n\n以上只是一部分先行发生关系，其他的不再一一介绍。\n\n那么，先行发生原则如何使用呢？我们看一个例子：\n\n```java\nprivate int value = 0;\n\npublic void setValue(int value){\n\tthis.value = value;\n}\n\npublic int getValue(){\n\treturn value;\n}\n```\n\n假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？\n\n套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看[这个](http://wiki.jikexueyuan.com/project/java-memory-model/lock.html)\n\n通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。\n\n## Volatile关键字\n\n通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。\n\nvolatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：**保证内存可见性和禁止重排序**。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：\n\n```java\npublic class VolatileTest {\n\tpublic static volatile int race = 0;\n\t\n\tpublic static void increase(){\n\t\trace++;\n\t}\n\t\n\tprivate static int THREAD_COUNT = 20;\n\t\n\tpublic static void main(String args[]) {\n\t\tThread[] threads = new Thread[THREAD_COUNT];\n\t\tfor (int i = 0; i < THREAD_COUNT; i++) {\n\t\t\tthreads[i] = new Thread(new Runnable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i< 10000; i++) {\n\t\t\t\t\t\tincrease();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthreads[i].start();\n\t\t}\n\t\twhile (Thread.activeCount()>1) {\n\t\t\tThread.yield();\n\t\t}\n\t\tSystem.out.println(race);\n\t}\n}\n\n```\n\n```\n运行结果：130310 //每次运行结果并不相同\n```\n\n可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于`race++`,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。\n\n这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。\n\n现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：**每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量**。\n\n当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。\n\n当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。\n\n关于volatile怎么实现内存可见性，是通过一个叫[内存屏障](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C)的东西来实现的。具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。\n\n关于volatile关键字的禁止重排序，具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n我们从先行发生原则的角度看一下volatile的禁止重排序：\n\n{% asset_img volatile.png volatile先行发生原则 %}\n\n其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。\n\n根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。\n\n即：**普通读写不能与其后的所有写volatile变量重排序**。同理，**普通读写不能与之前的所有读volatile变量重排序**。\n\n下面看看volatile的使用场景：\n\n1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n\n2.变量不需要与其他状态的变量共同参与不变约束。\n\n第一点就很好理解了，volatile不保证原子性嘛~~\n\n**第二点我也有点疑惑，待研究...**\n\n关于volatile的使用场景，可以看看这篇文章：[Java 理论与实践: 正确使用 Volatile 变量](http://www.ibm.com/developerworks/cn/java/j-jtp06197.html)\n\n## 最后\n\n终于把自己想要总结的写完了~~断断续续写了四个小时...好累...\n\n加油！\n\n\n\n\n\n","source":"_posts/理解java内存模型.md","raw":"---\nlayout: post\ntitle: 理解java内存模型\ndate: 2016-09-10 10:32:40\ncategories: 技术\ntags: java\n---\n\n最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~\n\n## 并发为啥会出现问题\n\nPS：2016/9/13更新：今天在地铁上看到这篇文章：[Java 并发原理无废话指南](http://toutiao.io/posts/493923/app_preview),感觉跟我这一小节要说明的问题比较相似，参考一下。\n\n### 原子性\n\n其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：\n\n```java\npublic class BankAccount {\n\tprivate static int accountBalance = 10000;\n\n\tstatic class Save implements Runnable {\n\t\tprivate int money;\n\n\t\tpublic Save(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\t//存钱\n\t\t\tint tempAccount = accountBalance + money;\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次存入：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tstatic class Obtain implements Runnable {\n\n\t\tprivate int money;\n\n\t\tpublic Obtain(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (money > accountBalance) {\n\t\t\t\tSystem.out.println(\"余额不足\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//取钱\n\t\t\tint tempAccount = accountBalance - money;\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);//艾玛，卡了一秒\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次取出：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tint saveMoney = 10000;\n\t\tint obtainMoney = 10000;\n\t\t//自己取钱\n\t\tThread obtain = new Thread(new Obtain(obtainMoney));\n\t\t//老婆存钱\n\t\tThread save = new Thread(new Save(saveMoney));\n\t\tobtain.start();\n\t\tsave.start();\n\t}\n\n}\n```\n\n输出结果：\n\n```\n此次存入：10000\n当前余额：20000\n此次取出：10000\n当前余额：0\n```\n\n可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。\n\n分析一下出现问题的原因：\n\n出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。\n\n这就涉及到线程并发的第一个问题：原子性。\n\n我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。\n\n```\n//取钱\nint tempAccount = accountBalance - money;\n\n//设置余额\naccountBalance = tempAccount;\n```\n\n为了实现这种错误的效果，我故意把\n\n```\naccountBalance -= accountBalance;\n```\n\n拆成了上面的两行。其实`accountBalance -= accountBalance;`本身就不是一个原子操作，拆成两行是为了放大这种效果。\n\n通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。\n\n原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。\n\njava中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。\n\n那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。\n\n### 可见性\n\n组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。\n\nJava虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）\n\n画个图：\n\n{% asset_img 内存模型.png 内存模型 %}\n\n这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。\n\n我们回到上述的例子：\n\n上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似`accountBalance -= accountBalance;`这样的操作是原子性操作，设想以下的场景：\n\n1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时`accountBalance~ = 20000;accountBalance = 10000;`\n\n2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时`accountBalance~ = 0;accountBalance = 10000;`\n\n3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；\n\n4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；\n\n通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。\n\n我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。\n\n### 有序性\n\nCpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。\n\n以下例子来自《深入理解Java虚拟机》：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\nconfigOptions = new HashMap();\nconfigText = readConfigFile(flieName);\nprocessConfigOptions(configText,configOptions);\ninitialized = true;\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\nwhile(!initialized){\n\tsleep();\n}\n//使用线程A中初始化好的配置信息\ndoSomethingWithConfig();\n```\n\n在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码`initialized=true`被提前执行，这样线程B中使用配置信息的代码就可能出现错误。\n\n所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\npublic synchronized void init(){\n\tconfigOptions = new HashMap();\n\tconfigText = readConfigFile(flieName);\n\tprocessConfigOptions(configText,configOptions);\n\tinitialized = true;\n}\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\npublic synchronized void doSomething(){\n\twhile(!initialized){\n\t\tsleep();\n\t}\n\t//使用线程A中初始化好的配置信息\n\tdoSomethingWithConfig();\n}\n```\n注意上面两个方法在同一个类中实现。\n\n至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇[synchronized的用法](http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/)，对synchronized的使用更加得心应手啦！\n\n## 先行发生原则\n\n没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。\n\n比如我想到了之前宇哥跟我提到的一个bug:\n\n在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。\n\n后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用`calendar.setTime(date);`,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个`calendar.setTime(date);`，结果肯定就变得混乱了。\n\n上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。\n\n解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。\n\n先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。\n\n还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：\n\n```\n//以下操作在线程A中执行\ni = 1;\n\n//以下操作在线程B中执行\nj = i;\n\n//以下操作在线程C中执行\ni = 2;\n```\n\n假设线程A中的操作`i=1`先行发生于线程B的操作`j=i`,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，`i=1`的结果可以被B观察到。\n\n现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。\n\n其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。\n\n你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性...\n\n如果还没有理解所谓的先行发生原则的话，可以看一下[这篇文章](http://ifeve.com/easy-happens-before/)。\n\n下面介绍几个java内存模型中存在的先行发生关系：\n\n**程序次序规则**：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。\n\n**管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。\n\n**volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。\n\n**传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。\n\n以上只是一部分先行发生关系，其他的不再一一介绍。\n\n那么，先行发生原则如何使用呢？我们看一个例子：\n\n```java\nprivate int value = 0;\n\npublic void setValue(int value){\n\tthis.value = value;\n}\n\npublic int getValue(){\n\treturn value;\n}\n```\n\n假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？\n\n套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看[这个](http://wiki.jikexueyuan.com/project/java-memory-model/lock.html)\n\n通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。\n\n## Volatile关键字\n\n通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。\n\nvolatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：**保证内存可见性和禁止重排序**。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：\n\n```java\npublic class VolatileTest {\n\tpublic static volatile int race = 0;\n\t\n\tpublic static void increase(){\n\t\trace++;\n\t}\n\t\n\tprivate static int THREAD_COUNT = 20;\n\t\n\tpublic static void main(String args[]) {\n\t\tThread[] threads = new Thread[THREAD_COUNT];\n\t\tfor (int i = 0; i < THREAD_COUNT; i++) {\n\t\t\tthreads[i] = new Thread(new Runnable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i< 10000; i++) {\n\t\t\t\t\t\tincrease();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthreads[i].start();\n\t\t}\n\t\twhile (Thread.activeCount()>1) {\n\t\t\tThread.yield();\n\t\t}\n\t\tSystem.out.println(race);\n\t}\n}\n\n```\n\n```\n运行结果：130310 //每次运行结果并不相同\n```\n\n可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于`race++`,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。\n\n这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。\n\n现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：**每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量**。\n\n当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。\n\n当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。\n\n关于volatile怎么实现内存可见性，是通过一个叫[内存屏障](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C)的东西来实现的。具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。\n\n关于volatile关键字的禁止重排序，具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n我们从先行发生原则的角度看一下volatile的禁止重排序：\n\n{% asset_img volatile.png volatile先行发生原则 %}\n\n其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。\n\n根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。\n\n即：**普通读写不能与其后的所有写volatile变量重排序**。同理，**普通读写不能与之前的所有读volatile变量重排序**。\n\n下面看看volatile的使用场景：\n\n1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n\n2.变量不需要与其他状态的变量共同参与不变约束。\n\n第一点就很好理解了，volatile不保证原子性嘛~~\n\n**第二点我也有点疑惑，待研究...**\n\n关于volatile的使用场景，可以看看这篇文章：[Java 理论与实践: 正确使用 Volatile 变量](http://www.ibm.com/developerworks/cn/java/j-jtp06197.html)\n\n## 最后\n\n终于把自己想要总结的写完了~~断断续续写了四个小时...好累...\n\n加油！\n\n\n\n\n\n","slug":"理解java内存模型","published":1,"updated":"2016-11-30T14:32:49.917Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj6t002zdigc3ekkcx0v","content":"<p>最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~</p>\n<h2 id=\"并发为啥会出现问题\"><a href=\"#并发为啥会出现问题\" class=\"headerlink\" title=\"并发为啥会出现问题\"></a>并发为啥会出现问题</h2><p>PS：2016/9/13更新：今天在地铁上看到这篇文章：<a href=\"http://toutiao.io/posts/493923/app_preview\" target=\"_blank\" rel=\"external\">Java 并发原理无废话指南</a>,感觉跟我这一小节要说明的问题比较相似，参考一下。</p>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankAccount</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> accountBalance = <span class=\"number\">10000</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Save</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Save</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//存钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance + money;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次存入：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Obtain</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Obtain</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (money &gt; accountBalance) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"余额不足\"</span>);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//取钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance - money;</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//艾玛，卡了一秒</span></div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次取出：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> saveMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> obtainMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"comment\">//自己取钱</span></div><div class=\"line\">\t\tThread obtain = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Obtain(obtainMoney));</div><div class=\"line\">\t\t<span class=\"comment\">//老婆存钱</span></div><div class=\"line\">\t\tThread save = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Save(saveMoney));</div><div class=\"line\">\t\tobtain.start();</div><div class=\"line\">\t\tsave.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">此次存入：10000</div><div class=\"line\">当前余额：20000</div><div class=\"line\">此次取出：10000</div><div class=\"line\">当前余额：0</div></pre></td></tr></table></figure>\n<p>可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。</p>\n<p>分析一下出现问题的原因：</p>\n<p>出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。</p>\n<p>这就涉及到线程并发的第一个问题：原子性。</p>\n<p>我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//取钱</div><div class=\"line\">int tempAccount = accountBalance - money;</div><div class=\"line\"></div><div class=\"line\">//设置余额</div><div class=\"line\">accountBalance = tempAccount;</div></pre></td></tr></table></figure>\n<p>为了实现这种错误的效果，我故意把</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">accountBalance -= accountBalance;</div></pre></td></tr></table></figure>\n<p>拆成了上面的两行。其实<code>accountBalance -= accountBalance;</code>本身就不是一个原子操作，拆成两行是为了放大这种效果。</p>\n<p>通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。</p>\n<p>原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。</p>\n<p>java中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。</p>\n<p>那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。</p>\n<h3 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h3><p>组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。</p>\n<p>Java虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）</p>\n<p>画个图：</p>\n<img src=\"/2016/09/10/理解java内存模型/内存模型.png\" alt=\"内存模型\" title=\"内存模型\">\n<p>这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。</p>\n<p>我们回到上述的例子：</p>\n<p>上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似<code>accountBalance -= accountBalance;</code>这样的操作是原子性操作，设想以下的场景：</p>\n<p>1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时<code>accountBalance~ = 20000;accountBalance = 10000;</code></p>\n<p>2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时<code>accountBalance~ = 0;accountBalance = 10000;</code></p>\n<p>3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；</p>\n<p>4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；</p>\n<p>通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。</p>\n<p>我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。</p>\n<h3 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h3><p>Cpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。</p>\n<p>以下例子来自《深入理解Java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\">configOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">configText = readConfigFile(flieName);</div><div class=\"line\">processConfigOptions(configText,configOptions);</div><div class=\"line\">initialized = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\tsleep();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">doSomethingWithConfig();</div></pre></td></tr></table></figure>\n<p>在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码<code>initialized=true</code>被提前执行，这样线程B中使用配置信息的代码就可能出现错误。</p>\n<p>所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tconfigOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">\tconfigText = readConfigFile(flieName);</div><div class=\"line\">\tprocessConfigOptions(configText,configOptions);</div><div class=\"line\">\tinitialized = <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\t\tsleep();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">\tdoSomethingWithConfig();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意上面两个方法在同一个类中实现。</p>\n<p>至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇<a href=\"http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/\">synchronized的用法</a>，对synchronized的使用更加得心应手啦！</p>\n<h2 id=\"先行发生原则\"><a href=\"#先行发生原则\" class=\"headerlink\" title=\"先行发生原则\"></a>先行发生原则</h2><p>没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。</p>\n<p>比如我想到了之前宇哥跟我提到的一个bug:</p>\n<p>在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。</p>\n<p>后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用<code>calendar.setTime(date);</code>,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个<code>calendar.setTime(date);</code>，结果肯定就变得混乱了。</p>\n<p>上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。</p>\n<p>解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。</p>\n<p>先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。</p>\n<p>还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下操作在线程A中执行</div><div class=\"line\">i = 1;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程B中执行</div><div class=\"line\">j = i;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程C中执行</div><div class=\"line\">i = 2;</div></pre></td></tr></table></figure>\n<p>假设线程A中的操作<code>i=1</code>先行发生于线程B的操作<code>j=i</code>,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，<code>i=1</code>的结果可以被B观察到。</p>\n<p>现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。</p>\n<p>其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。</p>\n<p>你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性…</p>\n<p>如果还没有理解所谓的先行发生原则的话，可以看一下<a href=\"http://ifeve.com/easy-happens-before/\" target=\"_blank\" rel=\"external\">这篇文章</a>。</p>\n<p>下面介绍几个java内存模型中存在的先行发生关系：</p>\n<p><strong>程序次序规则</strong>：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。</p>\n<p><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。</p>\n<p><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。</p>\n<p><strong>传递性</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。</p>\n<p>以上只是一部分先行发生关系，其他的不再一一介绍。</p>\n<p>那么，先行发生原则如何使用呢？我们看一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？</p>\n<p>套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看<a href=\"http://wiki.jikexueyuan.com/project/java-memory-model/lock.html\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。</p>\n<h2 id=\"Volatile关键字\"><a href=\"#Volatile关键字\" class=\"headerlink\" title=\"Volatile关键字\"></a>Volatile关键字</h2><p>通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。</p>\n<p>volatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：<strong>保证内存可见性和禁止重排序</strong>。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> race = <span class=\"number\">0</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\trace++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> THREAD_COUNT = <span class=\"number\">20</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\tThread[] threads = <span class=\"keyword\">new</span> Thread[THREAD_COUNT];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; THREAD_COUNT; i++) &#123;</div><div class=\"line\">\t\t\tthreads[i] = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t\t\t</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"number\">10000</span>; i++) &#123;</div><div class=\"line\">\t\t\t\t\t\tincrease();</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t\tthreads[i].start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (Thread.activeCount()&gt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">\t\t\tThread.yield();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.println(race);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">运行结果：130310 //每次运行结果并不相同</div></pre></td></tr></table></figure>\n<p>可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于<code>race++</code>,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。</p>\n<p>这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。</p>\n<p>现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：<strong>每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量</strong>。</p>\n<p>当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。</p>\n<p>当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。</p>\n<p>关于volatile怎么实现内存可见性，是通过一个叫<a href=\"https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C\" target=\"_blank\" rel=\"external\">内存屏障</a>的东西来实现的。具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。</p>\n<p>关于volatile关键字的禁止重排序，具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>我们从先行发生原则的角度看一下volatile的禁止重排序：</p>\n<img src=\"/2016/09/10/理解java内存模型/volatile.png\" alt=\"volatile先行发生原则\" title=\"volatile先行发生原则\">\n<p>其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。</p>\n<p>根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。</p>\n<p>即：<strong>普通读写不能与其后的所有写volatile变量重排序</strong>。同理，<strong>普通读写不能与之前的所有读volatile变量重排序</strong>。</p>\n<p>下面看看volatile的使用场景：</p>\n<p>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>\n<p>2.变量不需要与其他状态的变量共同参与不变约束。</p>\n<p>第一点就很好理解了，volatile不保证原子性嘛~~</p>\n<p><strong>第二点我也有点疑惑，待研究…</strong></p>\n<p>关于volatile的使用场景，可以看看这篇文章：<a href=\"http://www.ibm.com/developerworks/cn/java/j-jtp06197.html\" target=\"_blank\" rel=\"external\">Java 理论与实践: 正确使用 Volatile 变量</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>终于把自己想要总结的写完了~~断断续续写了四个小时…好累…</p>\n<p>加油！</p>\n","excerpt":"","more":"<p>最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~</p>\n<h2 id=\"并发为啥会出现问题\"><a href=\"#并发为啥会出现问题\" class=\"headerlink\" title=\"并发为啥会出现问题\"></a>并发为啥会出现问题</h2><p>PS：2016/9/13更新：今天在地铁上看到这篇文章：<a href=\"http://toutiao.io/posts/493923/app_preview\">Java 并发原理无废话指南</a>,感觉跟我这一小节要说明的问题比较相似，参考一下。</p>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankAccount</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> accountBalance = <span class=\"number\">10000</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Save</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Save</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//存钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance + money;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次存入：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Obtain</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Obtain</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (money &gt; accountBalance) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"余额不足\"</span>);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//取钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance - money;</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//艾玛，卡了一秒</span></div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次取出：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> saveMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> obtainMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"comment\">//自己取钱</span></div><div class=\"line\">\t\tThread obtain = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Obtain(obtainMoney));</div><div class=\"line\">\t\t<span class=\"comment\">//老婆存钱</span></div><div class=\"line\">\t\tThread save = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Save(saveMoney));</div><div class=\"line\">\t\tobtain.start();</div><div class=\"line\">\t\tsave.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">此次存入：10000</div><div class=\"line\">当前余额：20000</div><div class=\"line\">此次取出：10000</div><div class=\"line\">当前余额：0</div></pre></td></tr></table></figure>\n<p>可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。</p>\n<p>分析一下出现问题的原因：</p>\n<p>出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。</p>\n<p>这就涉及到线程并发的第一个问题：原子性。</p>\n<p>我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//取钱</div><div class=\"line\">int tempAccount = accountBalance - money;</div><div class=\"line\"></div><div class=\"line\">//设置余额</div><div class=\"line\">accountBalance = tempAccount;</div></pre></td></tr></table></figure>\n<p>为了实现这种错误的效果，我故意把</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">accountBalance -= accountBalance;</div></pre></td></tr></table></figure>\n<p>拆成了上面的两行。其实<code>accountBalance -= accountBalance;</code>本身就不是一个原子操作，拆成两行是为了放大这种效果。</p>\n<p>通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。</p>\n<p>原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。</p>\n<p>java中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。</p>\n<p>那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。</p>\n<h3 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h3><p>组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。</p>\n<p>Java虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）</p>\n<p>画个图：</p>\n<img src=\"/2016/09/10/理解java内存模型/内存模型.png\" alt=\"内存模型\" title=\"内存模型\">\n<p>这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。</p>\n<p>我们回到上述的例子：</p>\n<p>上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似<code>accountBalance -= accountBalance;</code>这样的操作是原子性操作，设想以下的场景：</p>\n<p>1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时<code>accountBalance~ = 20000;accountBalance = 10000;</code></p>\n<p>2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时<code>accountBalance~ = 0;accountBalance = 10000;</code></p>\n<p>3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；</p>\n<p>4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；</p>\n<p>通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。</p>\n<p>我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。</p>\n<h3 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h3><p>Cpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。</p>\n<p>以下例子来自《深入理解Java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\">configOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">configText = readConfigFile(flieName);</div><div class=\"line\">processConfigOptions(configText,configOptions);</div><div class=\"line\">initialized = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\tsleep();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">doSomethingWithConfig();</div></pre></td></tr></table></figure>\n<p>在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码<code>initialized=true</code>被提前执行，这样线程B中使用配置信息的代码就可能出现错误。</p>\n<p>所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tconfigOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">\tconfigText = readConfigFile(flieName);</div><div class=\"line\">\tprocessConfigOptions(configText,configOptions);</div><div class=\"line\">\tinitialized = <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\t\tsleep();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">\tdoSomethingWithConfig();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意上面两个方法在同一个类中实现。</p>\n<p>至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇<a href=\"http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/\">synchronized的用法</a>，对synchronized的使用更加得心应手啦！</p>\n<h2 id=\"先行发生原则\"><a href=\"#先行发生原则\" class=\"headerlink\" title=\"先行发生原则\"></a>先行发生原则</h2><p>没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。</p>\n<p>比如我想到了之前宇哥跟我提到的一个bug:</p>\n<p>在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。</p>\n<p>后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用<code>calendar.setTime(date);</code>,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个<code>calendar.setTime(date);</code>，结果肯定就变得混乱了。</p>\n<p>上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。</p>\n<p>解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。</p>\n<p>先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。</p>\n<p>还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下操作在线程A中执行</div><div class=\"line\">i = 1;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程B中执行</div><div class=\"line\">j = i;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程C中执行</div><div class=\"line\">i = 2;</div></pre></td></tr></table></figure>\n<p>假设线程A中的操作<code>i=1</code>先行发生于线程B的操作<code>j=i</code>,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，<code>i=1</code>的结果可以被B观察到。</p>\n<p>现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。</p>\n<p>其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。</p>\n<p>你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性…</p>\n<p>如果还没有理解所谓的先行发生原则的话，可以看一下<a href=\"http://ifeve.com/easy-happens-before/\">这篇文章</a>。</p>\n<p>下面介绍几个java内存模型中存在的先行发生关系：</p>\n<p><strong>程序次序规则</strong>：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。</p>\n<p><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。</p>\n<p><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。</p>\n<p><strong>传递性</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。</p>\n<p>以上只是一部分先行发生关系，其他的不再一一介绍。</p>\n<p>那么，先行发生原则如何使用呢？我们看一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？</p>\n<p>套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看<a href=\"http://wiki.jikexueyuan.com/project/java-memory-model/lock.html\">这个</a></p>\n<p>通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。</p>\n<h2 id=\"Volatile关键字\"><a href=\"#Volatile关键字\" class=\"headerlink\" title=\"Volatile关键字\"></a>Volatile关键字</h2><p>通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。</p>\n<p>volatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：<strong>保证内存可见性和禁止重排序</strong>。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> race = <span class=\"number\">0</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\trace++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> THREAD_COUNT = <span class=\"number\">20</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\tThread[] threads = <span class=\"keyword\">new</span> Thread[THREAD_COUNT];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; THREAD_COUNT; i++) &#123;</div><div class=\"line\">\t\t\tthreads[i] = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t\t\t</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"number\">10000</span>; i++) &#123;</div><div class=\"line\">\t\t\t\t\t\tincrease();</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t\tthreads[i].start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (Thread.activeCount()&gt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">\t\t\tThread.yield();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.println(race);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">运行结果：130310 //每次运行结果并不相同</div></pre></td></tr></table></figure>\n<p>可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于<code>race++</code>,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。</p>\n<p>这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。</p>\n<p>现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：<strong>每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量</strong>。</p>\n<p>当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。</p>\n<p>当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。</p>\n<p>关于volatile怎么实现内存可见性，是通过一个叫<a href=\"https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C\">内存屏障</a>的东西来实现的。具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\">这个</a></p>\n<p>所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。</p>\n<p>关于volatile关键字的禁止重排序，具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\">这个</a></p>\n<p>我们从先行发生原则的角度看一下volatile的禁止重排序：</p>\n<img src=\"/2016/09/10/理解java内存模型/volatile.png\" alt=\"volatile先行发生原则\" title=\"volatile先行发生原则\">\n<p>其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。</p>\n<p>根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。</p>\n<p>即：<strong>普通读写不能与其后的所有写volatile变量重排序</strong>。同理，<strong>普通读写不能与之前的所有读volatile变量重排序</strong>。</p>\n<p>下面看看volatile的使用场景：</p>\n<p>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>\n<p>2.变量不需要与其他状态的变量共同参与不变约束。</p>\n<p>第一点就很好理解了，volatile不保证原子性嘛~~</p>\n<p><strong>第二点我也有点疑惑，待研究…</strong></p>\n<p>关于volatile的使用场景，可以看看这篇文章：<a href=\"http://www.ibm.com/developerworks/cn/java/j-jtp06197.html\">Java 理论与实践: 正确使用 Volatile 变量</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>终于把自己想要总结的写完了~~断断续续写了四个小时…好累…</p>\n<p>加油！</p>\n"},{"layout":"post","title":"记录工作遇到的坑","date":"2016-09-24T08:30:44.000Z","_content":"\n昨天晚上12.30才进的家门，回来之后还远程合了个代码打了个包，发布restAPI新版本之用。这一周的主要工作就是在做一个web服务器，是一个集群的中间件。因为着急发布新版本，所以昨晚加班到12点多...\n\n主要实现了几个接口，实现了ssl双向验证功能。其实ssl双向验证的功能主要是了解ssl原理之后如何配置的问题。期间还学习了session和cookie的原理。ssl与cookie、session单开一篇进行总结。这篇日志记录一下这周工作中遇到的一些坑，不一定是技术上的，但是遇到这些小问题还是耽误了一些时间。这篇日志也会持续更新，把以后遇到的坑都总结到这里来。\n\n希望以后遇到类似的情况能够迅速找到原因将其解决，同时也希望能帮助到可能会看到这篇文章的人。\n\n## Spring项目通过export方法打包为jar的问题\n\n在前面的日志中已经有[专门的一篇](http://yukai.space/2016/09/19/Spring%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAjar/)来总结这个问题:**当通过export方式打包Spring项目时，一定要记得勾选Add Directory Entries这个选项，否则spring无法正确扫描到controller，发生404**\n\n## 使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常\n\n假如你的项目中有一个类似下面的controller来接收一个请求：\n\n```java\n@GET\n@RequestMapping(\"web/{groupName}\")\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\npublic void getWorkerAddress(HttpServletRequest request, HttpServletResponse response,\n\t\t@PathVariable String groupName) {\n\t\tdoSomething...\n}\t\t\n\n```\n\n当你的项目运行时你发起一个`http://ip:port/web/groupName1`这样的请求，那么很有可能服务器会报这样一个异常：**java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.**\n\n大概的意思就是参数名称信息没有在类文件中找到。若是浏览器为客户端，浏览器的页面是这样的：\n\n{% asset_img error.png error %}\n\n解决这个异常的方法有两种：\n\n**1.在@PathVariable注解后面加上参数名，比如：@PathVariable(\"groupName\")**\n\n**2.编译时将debug信息勾选进去：**\n\n{% asset_img compiler.png compiler %}\n\n编译时把上图绿色框中的单选框勾选，就不会报异常。原因在于Local variable属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量名称和描述符之间的映射关系。\n\n顺便了解一下上面四个选项的作用：\n\n{% asset_img gengeration.png compiler %}\n\n图片截取自：[Eclipse用户手册](http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-compiler.htm)\n\n其实就是java工程编译时的一些选项。当我们在debug时遇到问题，比如断点打不上，source not found等等或许修改这些选项可以得到解决。\n\n参考一篇文章：[java编译时生成调试信息选项详解（javac -g）](http://daimojingdeyu.iteye.com/blog/679030)\n\n## Windows环境下使用Curl，要使用双引号包裹内容\n\nweb服务器是通过curl来测试的。之前自己也没用过这个所谓的命令行浏览器工具。在机器上装好curl之后，把测试那边提供的脚本拿过来，由于脚本是linux环境下的，做了一点修改之后(其实就是直接换成.bat啦)就直接跑了。脚本内容类似这样：\n\n```\ncurl -X POST -H 'content-type: application/json' -d @del.txt https://localhost:8899/web/rest/data/load/topictarget  -k -b cookie.txt>delresult.txt\n```\n\n但是实际测试的过程中，发现收到的post的数据为null，确定了不是服务器的问题之后，感觉应该是curl使用的问题。查了一些资料，是说post的数据要使用双引号包裹，而不是单引号。由于是从del.txt中提取post的数据，所以不存在这个问题。后来将content-type: application/json 的单引号换成双引号之后，问题解决。\n\n**所以：Windows环境下使用Curl，要使用双引号包裹需要加引号的内容，而不是单引号**\n\n## Spring项目运行过程中，@Autowired注解的变量为null的问题\n\n2016/09/09 更新\n\n这两天开发了一个公众账号来做一些简单的记账工作。后台服务器是用springboot搭建的，测试过程中遇到了这么个情况:\n\n在运行时服务器报了空指针NullPointerException异常，debug看了一下，发现是一个使用了@Autowired注解的变量没有被初始化。但是按理来说使用了@Autowired注解某个变量后spring会自动为我们实例化这个变量的啊！谷歌了一下，找到了一个类似的情况：[Why is my Spring @Autowired field null?](http://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null).\n\n下面模拟一下问题出现的场景(代码来自上面的链接)：\n\n```java\n@Controller\npublic class MileageFeeController {    \n    @RequestMapping(\"/mileage/{miles}\")\n    @ResponseBody\n    public float mileageFee(@PathVariable int miles) {\n        MileageFeeCalculator calc = new MileageFeeCalculator();\n        return calc.mileageCharge(miles);\n    }\n}\n\n@Service\npublic class MileageFeeCalculator {\n\n    @Autowired\n    private MileageRateService rateService; // <--- should be autowired, is null\n\n    public float mileageCharge(final int miles) {\n        return (miles * rateService.ratePerMile()); // <--- throws NPE\n    }\n}\n\n@Service\npublic class MileageFeeCalculator {\n\n    @Autowired\n    private MileageRateService rateService; // <--- should be autowired, is null\n\n    public float mileageCharge(final int miles) {\n        return (miles * rateService.ratePerMile()); // <--- throws NPE\n    }\n}\n```\n\n访问MileageFeeController时报错：\n\n```\njava.lang.NullPointerException: null\n    at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13)\n    at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14)\n```\n\n可以看到，变量rateService是个空值。导致空指针异常...\n\n原因就在于MileageFeeController.mileageFee中使用了new这种方式实例化了MileageFeeCalculator对象，该对象中的rateService为空，我们使用new这种方式实例化对象时，无法通过spring的@Autowired注解自动实例化对象中的属性。解决的方法就是实例化对象时应该通知spring，使其能够自动配置。\n\n我采用了上述链接中的第三种方法，解决了问题：\n\n```java\n@Component\npublic class ApplicationContextHolder implements ApplicationContextAware {\n    private static ApplicationContext context;\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        context = applicationContext;   \n    }\n\n    public static ApplicationContext getContext() {\n        return context;\n    }\n}\n\n@Controller\npublic class MileageFeeController {    \n    @RequestMapping(\"/mileage/{miles}\")\n    @ResponseBody\n    public float mileageFee(@PathVariable int miles) {\n        MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);\n        return calc.mileageCharge(miles);\n    }\n}\n```\n\n发生这些问题的原因还是在于对框架的不熟悉，内部原理不甚明了。有机会真得研究研究spring的源码~~\n\n## @RestController与@Controller\n\n2016/10/24 更新\n\nSpringboot 使用 Thymeleaf 模板 打算给公众号加一点地图功能，按照[这个教程](https://hellokoding.com/spring-boot-hello-world-example-with-thymeleaf/)在springboot项目中配置Thymeleaf，但是每次都没有正确返回html页面，反而是返回了这个html的名称。试了几次才发现自己用错了@RestController这个注解...Controller代码如下：\n\n```java\n@RestController\n@RequestMapping(\"/wechat\")\npublic class MapController {\n    @RequestMapping(\"/map/showRestaurant\")\n    public String showRestaurant(@RequestParam(value = \"location_x\", required = true) String location_x,\n            @RequestParam(value = \"location_y\", required = true) String location_y,\n            @RequestParam(value = \"label\", required = true) String label, Model model) {\n        model.addAttribute(\"locationx\", location_x);\n        model.addAttribute(\"locationy\", location_y);\n        model.addAttribute(\"label\",label);\n        return \"hello\";\n    }\n}\n\n```\n问题原因就在于上面的@RestController这个注解，将其替换为@Controller便解决了。\n \n根本原因在于@RestController与@Controller[这两个注解之间的区别](http://stackoverflow.com/questions/25242321/difference-between-spring-controller-and-restcontroller-annotation)\n\n## Linux下可靠的启动webservice\n\n2016/12/14 更新\n\n今天线上webservice发现了一个问题，技服把出现的问题描述和日志发给了我，需要解决一下。最终确定不是代码的问题，而是linux下启动程序的方式引发的一个错误。虽然简单，却很容易被疏忽导致问题的发生，值得记录下来。\n情况是这样的，每次springboot程序会不定时自动停止，观察log发现，每次挂掉之前都会打印一行log,大致意思是，代码中调用的系统程序tail退出了。查看代码时发现确实在tail程序退出时会打印这么一行日志，但却是正常表现，程序运行在一个死循环当中，随后就会重启tail这个程序。循环当中也做了相应的异常捕获，按道理来说webservice不应该挂掉。初步怀疑多次启动tail导致内存泄漏以至于程序退出。由于代码中没有对内存泄漏这种error类型的异常捕获和记录到日志，从日志中无法判断是否发生了内存泄漏。代码中实现了Throwable级别异常的捕获，并记录异常信息到日志，再次抛出该异常。\n打包，发送给技服到测试机上去跑。一会之后，又挂了。观察新的Log，竟然与之前的没什么区别，并没有什么新的异常信息输出。也就是说，压根没有异常从代码中抛出。很有可能是程序被认为关闭或被系统干掉了。但是之前询问技服，对方否定了这种情况。\n这就怪了。继续观察日志，此时，发现这么一行：`Unregistering JMX-exposed beans on shutdown`.确实是springboot退出时打印的信息。google之，大部分的答案是没有添加依赖`spring-boot-starter-web`所导致springboot无法启动。与现在的情况不符，当前情况是启动正常，运行时突然挂掉。\n再次询问技服是否kill掉了运行webservice的进程。技服否认，说该程序时运行在后台的，继续询问如何运行在后台，回答是： `java -jar MyApplication.jar & `\n果然，使用这种方式运行在后台的程序，当ssh断掉或关闭bash窗口后，程序依然会被系统干掉，父进程都被干掉了，子进程也一并干掉了...\n正确的启动方式应为：`nohup java -jar MyApplication.jar &`\n\n```\nnohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。\n\n该命令的一般形式为：nohup command &\n\n使用nohup命令提交作业\n\n如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：\n\nnohup command > myout.file 2>&1 &\n\n在上面的例子中，输出被重定向到myout.file文件中。\n```\n该问题虽然不是很难解决，但是很容易被忽略。故在此记录。\n\n## 持续更新中....\n\n\n\n\n\n\n\n\n","source":"_posts/记录这周工作遇到的坑.md","raw":"---\nlayout: post\ntitle: 记录工作遇到的坑\ndate: 2016-09-24 16:30:44\ncategories: 技术 \ntags: \n- spring\n- curl\n---\n\n昨天晚上12.30才进的家门，回来之后还远程合了个代码打了个包，发布restAPI新版本之用。这一周的主要工作就是在做一个web服务器，是一个集群的中间件。因为着急发布新版本，所以昨晚加班到12点多...\n\n主要实现了几个接口，实现了ssl双向验证功能。其实ssl双向验证的功能主要是了解ssl原理之后如何配置的问题。期间还学习了session和cookie的原理。ssl与cookie、session单开一篇进行总结。这篇日志记录一下这周工作中遇到的一些坑，不一定是技术上的，但是遇到这些小问题还是耽误了一些时间。这篇日志也会持续更新，把以后遇到的坑都总结到这里来。\n\n希望以后遇到类似的情况能够迅速找到原因将其解决，同时也希望能帮助到可能会看到这篇文章的人。\n\n## Spring项目通过export方法打包为jar的问题\n\n在前面的日志中已经有[专门的一篇](http://yukai.space/2016/09/19/Spring%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAjar/)来总结这个问题:**当通过export方式打包Spring项目时，一定要记得勾选Add Directory Entries这个选项，否则spring无法正确扫描到controller，发生404**\n\n## 使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常\n\n假如你的项目中有一个类似下面的controller来接收一个请求：\n\n```java\n@GET\n@RequestMapping(\"web/{groupName}\")\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\npublic void getWorkerAddress(HttpServletRequest request, HttpServletResponse response,\n\t\t@PathVariable String groupName) {\n\t\tdoSomething...\n}\t\t\n\n```\n\n当你的项目运行时你发起一个`http://ip:port/web/groupName1`这样的请求，那么很有可能服务器会报这样一个异常：**java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.**\n\n大概的意思就是参数名称信息没有在类文件中找到。若是浏览器为客户端，浏览器的页面是这样的：\n\n{% asset_img error.png error %}\n\n解决这个异常的方法有两种：\n\n**1.在@PathVariable注解后面加上参数名，比如：@PathVariable(\"groupName\")**\n\n**2.编译时将debug信息勾选进去：**\n\n{% asset_img compiler.png compiler %}\n\n编译时把上图绿色框中的单选框勾选，就不会报异常。原因在于Local variable属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量名称和描述符之间的映射关系。\n\n顺便了解一下上面四个选项的作用：\n\n{% asset_img gengeration.png compiler %}\n\n图片截取自：[Eclipse用户手册](http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-compiler.htm)\n\n其实就是java工程编译时的一些选项。当我们在debug时遇到问题，比如断点打不上，source not found等等或许修改这些选项可以得到解决。\n\n参考一篇文章：[java编译时生成调试信息选项详解（javac -g）](http://daimojingdeyu.iteye.com/blog/679030)\n\n## Windows环境下使用Curl，要使用双引号包裹内容\n\nweb服务器是通过curl来测试的。之前自己也没用过这个所谓的命令行浏览器工具。在机器上装好curl之后，把测试那边提供的脚本拿过来，由于脚本是linux环境下的，做了一点修改之后(其实就是直接换成.bat啦)就直接跑了。脚本内容类似这样：\n\n```\ncurl -X POST -H 'content-type: application/json' -d @del.txt https://localhost:8899/web/rest/data/load/topictarget  -k -b cookie.txt>delresult.txt\n```\n\n但是实际测试的过程中，发现收到的post的数据为null，确定了不是服务器的问题之后，感觉应该是curl使用的问题。查了一些资料，是说post的数据要使用双引号包裹，而不是单引号。由于是从del.txt中提取post的数据，所以不存在这个问题。后来将content-type: application/json 的单引号换成双引号之后，问题解决。\n\n**所以：Windows环境下使用Curl，要使用双引号包裹需要加引号的内容，而不是单引号**\n\n## Spring项目运行过程中，@Autowired注解的变量为null的问题\n\n2016/09/09 更新\n\n这两天开发了一个公众账号来做一些简单的记账工作。后台服务器是用springboot搭建的，测试过程中遇到了这么个情况:\n\n在运行时服务器报了空指针NullPointerException异常，debug看了一下，发现是一个使用了@Autowired注解的变量没有被初始化。但是按理来说使用了@Autowired注解某个变量后spring会自动为我们实例化这个变量的啊！谷歌了一下，找到了一个类似的情况：[Why is my Spring @Autowired field null?](http://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null).\n\n下面模拟一下问题出现的场景(代码来自上面的链接)：\n\n```java\n@Controller\npublic class MileageFeeController {    \n    @RequestMapping(\"/mileage/{miles}\")\n    @ResponseBody\n    public float mileageFee(@PathVariable int miles) {\n        MileageFeeCalculator calc = new MileageFeeCalculator();\n        return calc.mileageCharge(miles);\n    }\n}\n\n@Service\npublic class MileageFeeCalculator {\n\n    @Autowired\n    private MileageRateService rateService; // <--- should be autowired, is null\n\n    public float mileageCharge(final int miles) {\n        return (miles * rateService.ratePerMile()); // <--- throws NPE\n    }\n}\n\n@Service\npublic class MileageFeeCalculator {\n\n    @Autowired\n    private MileageRateService rateService; // <--- should be autowired, is null\n\n    public float mileageCharge(final int miles) {\n        return (miles * rateService.ratePerMile()); // <--- throws NPE\n    }\n}\n```\n\n访问MileageFeeController时报错：\n\n```\njava.lang.NullPointerException: null\n    at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13)\n    at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14)\n```\n\n可以看到，变量rateService是个空值。导致空指针异常...\n\n原因就在于MileageFeeController.mileageFee中使用了new这种方式实例化了MileageFeeCalculator对象，该对象中的rateService为空，我们使用new这种方式实例化对象时，无法通过spring的@Autowired注解自动实例化对象中的属性。解决的方法就是实例化对象时应该通知spring，使其能够自动配置。\n\n我采用了上述链接中的第三种方法，解决了问题：\n\n```java\n@Component\npublic class ApplicationContextHolder implements ApplicationContextAware {\n    private static ApplicationContext context;\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        context = applicationContext;   \n    }\n\n    public static ApplicationContext getContext() {\n        return context;\n    }\n}\n\n@Controller\npublic class MileageFeeController {    \n    @RequestMapping(\"/mileage/{miles}\")\n    @ResponseBody\n    public float mileageFee(@PathVariable int miles) {\n        MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);\n        return calc.mileageCharge(miles);\n    }\n}\n```\n\n发生这些问题的原因还是在于对框架的不熟悉，内部原理不甚明了。有机会真得研究研究spring的源码~~\n\n## @RestController与@Controller\n\n2016/10/24 更新\n\nSpringboot 使用 Thymeleaf 模板 打算给公众号加一点地图功能，按照[这个教程](https://hellokoding.com/spring-boot-hello-world-example-with-thymeleaf/)在springboot项目中配置Thymeleaf，但是每次都没有正确返回html页面，反而是返回了这个html的名称。试了几次才发现自己用错了@RestController这个注解...Controller代码如下：\n\n```java\n@RestController\n@RequestMapping(\"/wechat\")\npublic class MapController {\n    @RequestMapping(\"/map/showRestaurant\")\n    public String showRestaurant(@RequestParam(value = \"location_x\", required = true) String location_x,\n            @RequestParam(value = \"location_y\", required = true) String location_y,\n            @RequestParam(value = \"label\", required = true) String label, Model model) {\n        model.addAttribute(\"locationx\", location_x);\n        model.addAttribute(\"locationy\", location_y);\n        model.addAttribute(\"label\",label);\n        return \"hello\";\n    }\n}\n\n```\n问题原因就在于上面的@RestController这个注解，将其替换为@Controller便解决了。\n \n根本原因在于@RestController与@Controller[这两个注解之间的区别](http://stackoverflow.com/questions/25242321/difference-between-spring-controller-and-restcontroller-annotation)\n\n## Linux下可靠的启动webservice\n\n2016/12/14 更新\n\n今天线上webservice发现了一个问题，技服把出现的问题描述和日志发给了我，需要解决一下。最终确定不是代码的问题，而是linux下启动程序的方式引发的一个错误。虽然简单，却很容易被疏忽导致问题的发生，值得记录下来。\n情况是这样的，每次springboot程序会不定时自动停止，观察log发现，每次挂掉之前都会打印一行log,大致意思是，代码中调用的系统程序tail退出了。查看代码时发现确实在tail程序退出时会打印这么一行日志，但却是正常表现，程序运行在一个死循环当中，随后就会重启tail这个程序。循环当中也做了相应的异常捕获，按道理来说webservice不应该挂掉。初步怀疑多次启动tail导致内存泄漏以至于程序退出。由于代码中没有对内存泄漏这种error类型的异常捕获和记录到日志，从日志中无法判断是否发生了内存泄漏。代码中实现了Throwable级别异常的捕获，并记录异常信息到日志，再次抛出该异常。\n打包，发送给技服到测试机上去跑。一会之后，又挂了。观察新的Log，竟然与之前的没什么区别，并没有什么新的异常信息输出。也就是说，压根没有异常从代码中抛出。很有可能是程序被认为关闭或被系统干掉了。但是之前询问技服，对方否定了这种情况。\n这就怪了。继续观察日志，此时，发现这么一行：`Unregistering JMX-exposed beans on shutdown`.确实是springboot退出时打印的信息。google之，大部分的答案是没有添加依赖`spring-boot-starter-web`所导致springboot无法启动。与现在的情况不符，当前情况是启动正常，运行时突然挂掉。\n再次询问技服是否kill掉了运行webservice的进程。技服否认，说该程序时运行在后台的，继续询问如何运行在后台，回答是： `java -jar MyApplication.jar & `\n果然，使用这种方式运行在后台的程序，当ssh断掉或关闭bash窗口后，程序依然会被系统干掉，父进程都被干掉了，子进程也一并干掉了...\n正确的启动方式应为：`nohup java -jar MyApplication.jar &`\n\n```\nnohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。\n\n该命令的一般形式为：nohup command &\n\n使用nohup命令提交作业\n\n如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：\n\nnohup command > myout.file 2>&1 &\n\n在上面的例子中，输出被重定向到myout.file文件中。\n```\n该问题虽然不是很难解决，但是很容易被忽略。故在此记录。\n\n## 持续更新中....\n\n\n\n\n\n\n\n\n","slug":"记录这周工作遇到的坑","published":1,"updated":"2016-12-14T13:26:58.080Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj6w0033digcxuij395q","content":"<p>昨天晚上12.30才进的家门，回来之后还远程合了个代码打了个包，发布restAPI新版本之用。这一周的主要工作就是在做一个web服务器，是一个集群的中间件。因为着急发布新版本，所以昨晚加班到12点多…</p>\n<p>主要实现了几个接口，实现了ssl双向验证功能。其实ssl双向验证的功能主要是了解ssl原理之后如何配置的问题。期间还学习了session和cookie的原理。ssl与cookie、session单开一篇进行总结。这篇日志记录一下这周工作中遇到的一些坑，不一定是技术上的，但是遇到这些小问题还是耽误了一些时间。这篇日志也会持续更新，把以后遇到的坑都总结到这里来。</p>\n<p>希望以后遇到类似的情况能够迅速找到原因将其解决，同时也希望能帮助到可能会看到这篇文章的人。</p>\n<h2 id=\"Spring项目通过export方法打包为jar的问题\"><a href=\"#Spring项目通过export方法打包为jar的问题\" class=\"headerlink\" title=\"Spring项目通过export方法打包为jar的问题\"></a>Spring项目通过export方法打包为jar的问题</h2><p>在前面的日志中已经有<a href=\"http://yukai.space/2016/09/19/Spring%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAjar/\">专门的一篇</a>来总结这个问题:<strong>当通过export方式打包Spring项目时，一定要记得勾选Add Directory Entries这个选项，否则spring无法正确扫描到controller，发生404</strong></p>\n<h2 id=\"使用-PathVariable注解时抛出java-lang-IllegalArgumentException异常\"><a href=\"#使用-PathVariable注解时抛出java-lang-IllegalArgumentException异常\" class=\"headerlink\" title=\"使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常\"></a>使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常</h2><p>假如你的项目中有一个类似下面的controller来接收一个请求：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@GET</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"web/&#123;groupName&#125;\"</span>)</div><div class=\"line\"><span class=\"meta\">@Consumes</span>(MediaType.APPLICATION_JSON)</div><div class=\"line\"><span class=\"meta\">@Produces</span>(MediaType.APPLICATION_JSON)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getWorkerAddress</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response,</span></span></div><div class=\"line\">\t\t@PathVariable String groupName) &#123;</div><div class=\"line\">\t\tdoSomething...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当你的项目运行时你发起一个<code>http://ip:port/web/groupName1</code>这样的请求，那么很有可能服务器会报这样一个异常：<strong>java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.</strong></p>\n<p>大概的意思就是参数名称信息没有在类文件中找到。若是浏览器为客户端，浏览器的页面是这样的：</p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/error.png\" alt=\"error\" title=\"error\">\n<p>解决这个异常的方法有两种：</p>\n<p><strong>1.在@PathVariable注解后面加上参数名，比如：@PathVariable(“groupName”)</strong></p>\n<p><strong>2.编译时将debug信息勾选进去：</strong></p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/compiler.png\" alt=\"compiler\" title=\"compiler\">\n<p>编译时把上图绿色框中的单选框勾选，就不会报异常。原因在于Local variable属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量名称和描述符之间的映射关系。</p>\n<p>顺便了解一下上面四个选项的作用：</p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/gengeration.png\" alt=\"compiler\" title=\"compiler\">\n<p>图片截取自：<a href=\"http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-compiler.htm\" target=\"_blank\" rel=\"external\">Eclipse用户手册</a></p>\n<p>其实就是java工程编译时的一些选项。当我们在debug时遇到问题，比如断点打不上，source not found等等或许修改这些选项可以得到解决。</p>\n<p>参考一篇文章：<a href=\"http://daimojingdeyu.iteye.com/blog/679030\" target=\"_blank\" rel=\"external\">java编译时生成调试信息选项详解（javac -g）</a></p>\n<h2 id=\"Windows环境下使用Curl，要使用双引号包裹内容\"><a href=\"#Windows环境下使用Curl，要使用双引号包裹内容\" class=\"headerlink\" title=\"Windows环境下使用Curl，要使用双引号包裹内容\"></a>Windows环境下使用Curl，要使用双引号包裹内容</h2><p>web服务器是通过curl来测试的。之前自己也没用过这个所谓的命令行浏览器工具。在机器上装好curl之后，把测试那边提供的脚本拿过来，由于脚本是linux环境下的，做了一点修改之后(其实就是直接换成.bat啦)就直接跑了。脚本内容类似这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -X POST -H &apos;content-type: application/json&apos; -d @del.txt https://localhost:8899/web/rest/data/load/topictarget  -k -b cookie.txt&gt;delresult.txt</div></pre></td></tr></table></figure>\n<p>但是实际测试的过程中，发现收到的post的数据为null，确定了不是服务器的问题之后，感觉应该是curl使用的问题。查了一些资料，是说post的数据要使用双引号包裹，而不是单引号。由于是从del.txt中提取post的数据，所以不存在这个问题。后来将content-type: application/json 的单引号换成双引号之后，问题解决。</p>\n<p><strong>所以：Windows环境下使用Curl，要使用双引号包裹需要加引号的内容，而不是单引号</strong></p>\n<h2 id=\"Spring项目运行过程中，-Autowired注解的变量为null的问题\"><a href=\"#Spring项目运行过程中，-Autowired注解的变量为null的问题\" class=\"headerlink\" title=\"Spring项目运行过程中，@Autowired注解的变量为null的问题\"></a>Spring项目运行过程中，@Autowired注解的变量为null的问题</h2><p>2016/09/09 更新</p>\n<p>这两天开发了一个公众账号来做一些简单的记账工作。后台服务器是用springboot搭建的，测试过程中遇到了这么个情况:</p>\n<p>在运行时服务器报了空指针NullPointerException异常，debug看了一下，发现是一个使用了@Autowired注解的变量没有被初始化。但是按理来说使用了@Autowired注解某个变量后spring会自动为我们实例化这个变量的啊！谷歌了一下，找到了一个类似的情况：<a href=\"http://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null\" target=\"_blank\" rel=\"external\">Why is my Spring @Autowired field null?</a>.</p>\n<p>下面模拟一下问题出现的场景(代码来自上面的链接)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeController</span> </span>&#123;    </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mileage/&#123;miles&#125;\"</span>)</div><div class=\"line\">    <span class=\"meta\">@ResponseBody</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageFee</span><span class=\"params\">(@PathVariable <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        MileageFeeCalculator calc = <span class=\"keyword\">new</span> MileageFeeCalculator();</div><div class=\"line\">        <span class=\"keyword\">return</span> calc.mileageCharge(miles);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Service</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeCalculator</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> MileageRateService rateService; <span class=\"comment\">// &lt;--- should be autowired, is null</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageCharge</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (miles * rateService.ratePerMile()); <span class=\"comment\">// &lt;--- throws NPE</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Service</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeCalculator</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> MileageRateService rateService; <span class=\"comment\">// &lt;--- should be autowired, is null</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageCharge</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (miles * rateService.ratePerMile()); <span class=\"comment\">// &lt;--- throws NPE</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>访问MileageFeeController时报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.NullPointerException: null</div><div class=\"line\">    at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13)</div><div class=\"line\">    at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14)</div></pre></td></tr></table></figure>\n<p>可以看到，变量rateService是个空值。导致空指针异常…</p>\n<p>原因就在于MileageFeeController.mileageFee中使用了new这种方式实例化了MileageFeeCalculator对象，该对象中的rateService为空，我们使用new这种方式实例化对象时，无法通过spring的@Autowired注解自动实例化对象中的属性。解决的方法就是实例化对象时应该通知spring，使其能够自动配置。</p>\n<p>我采用了上述链接中的第三种方法，解决了问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Component</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationContextHolder</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationContextAware</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ApplicationContext context;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</div><div class=\"line\">        context = applicationContext;   </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ApplicationContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> context;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeController</span> </span>&#123;    </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mileage/&#123;miles&#125;\"</span>)</div><div class=\"line\">    <span class=\"meta\">@ResponseBody</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageFee</span><span class=\"params\">(@PathVariable <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);</div><div class=\"line\">        <span class=\"keyword\">return</span> calc.mileageCharge(miles);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>发生这些问题的原因还是在于对框架的不熟悉，内部原理不甚明了。有机会真得研究研究spring的源码~~</p>\n<h2 id=\"RestController与-Controller\"><a href=\"#RestController与-Controller\" class=\"headerlink\" title=\"@RestController与@Controller\"></a>@RestController与@Controller</h2><p>2016/10/24 更新</p>\n<p>Springboot 使用 Thymeleaf 模板 打算给公众号加一点地图功能，按照<a href=\"https://hellokoding.com/spring-boot-hello-world-example-with-thymeleaf/\" target=\"_blank\" rel=\"external\">这个教程</a>在springboot项目中配置Thymeleaf，但是每次都没有正确返回html页面，反而是返回了这个html的名称。试了几次才发现自己用错了@RestController这个注解…Controller代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@RestController</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/wechat\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapController</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/map/showRestaurant\"</span>)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showRestaurant</span><span class=\"params\">(@RequestParam(value = <span class=\"string\">\"location_x\"</span>, required = <span class=\"keyword\">true</span>)</span> String location_x,</span></div><div class=\"line\">            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"location_y\"</span>, required = <span class=\"keyword\">true</span>)</span> String location_y,</div><div class=\"line\">            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"label\"</span>, required = <span class=\"keyword\">true</span>)</span> String label, Model model) &#123;</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"locationx\"</span>, location_x);</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"locationy\"</span>, location_y);</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"label\"</span>,label);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"hello\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>问题原因就在于上面的@RestController这个注解，将其替换为@Controller便解决了。</p>\n<p>根本原因在于@RestController与@Controller<a href=\"http://stackoverflow.com/questions/25242321/difference-between-spring-controller-and-restcontroller-annotation\" target=\"_blank\" rel=\"external\">这两个注解之间的区别</a></p>\n<h2 id=\"Linux下可靠的启动webservice\"><a href=\"#Linux下可靠的启动webservice\" class=\"headerlink\" title=\"Linux下可靠的启动webservice\"></a>Linux下可靠的启动webservice</h2><p>2016/12/14 更新</p>\n<p>今天线上webservice发现了一个问题，技服把出现的问题描述和日志发给了我，需要解决一下。最终确定不是代码的问题，而是linux下启动程序的方式引发的一个错误。虽然简单，却很容易被疏忽导致问题的发生，值得记录下来。<br>情况是这样的，每次springboot程序会不定时自动停止，观察log发现，每次挂掉之前都会打印一行log,大致意思是，代码中调用的系统程序tail退出了。查看代码时发现确实在tail程序退出时会打印这么一行日志，但却是正常表现，程序运行在一个死循环当中，随后就会重启tail这个程序。循环当中也做了相应的异常捕获，按道理来说webservice不应该挂掉。初步怀疑多次启动tail导致内存泄漏以至于程序退出。由于代码中没有对内存泄漏这种error类型的异常捕获和记录到日志，从日志中无法判断是否发生了内存泄漏。代码中实现了Throwable级别异常的捕获，并记录异常信息到日志，再次抛出该异常。<br>打包，发送给技服到测试机上去跑。一会之后，又挂了。观察新的Log，竟然与之前的没什么区别，并没有什么新的异常信息输出。也就是说，压根没有异常从代码中抛出。很有可能是程序被认为关闭或被系统干掉了。但是之前询问技服，对方否定了这种情况。<br>这就怪了。继续观察日志，此时，发现这么一行：<code>Unregistering JMX-exposed beans on shutdown</code>.确实是springboot退出时打印的信息。google之，大部分的答案是没有添加依赖<code>spring-boot-starter-web</code>所导致springboot无法启动。与现在的情况不符，当前情况是启动正常，运行时突然挂掉。<br>再次询问技服是否kill掉了运行webservice的进程。技服否认，说该程序时运行在后台的，继续询问如何运行在后台，回答是： <code>java -jar MyApplication.jar &amp;</code><br>果然，使用这种方式运行在后台的程序，当ssh断掉或关闭bash窗口后，程序依然会被系统干掉，父进程都被干掉了，子进程也一并干掉了…<br>正确的启动方式应为：<code>nohup java -jar MyApplication.jar &amp;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。</div><div class=\"line\"></div><div class=\"line\">该命令的一般形式为：nohup command &amp;</div><div class=\"line\"></div><div class=\"line\">使用nohup命令提交作业</div><div class=\"line\"></div><div class=\"line\">如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</div><div class=\"line\"></div><div class=\"line\">nohup command &gt; myout.file 2&gt;&amp;1 &amp;</div><div class=\"line\"></div><div class=\"line\">在上面的例子中，输出被重定向到myout.file文件中。</div></pre></td></tr></table></figure>\n<p>该问题虽然不是很难解决，但是很容易被忽略。故在此记录。</p>\n<h2 id=\"持续更新中…\"><a href=\"#持续更新中…\" class=\"headerlink\" title=\"持续更新中….\"></a>持续更新中….</h2>","excerpt":"","more":"<p>昨天晚上12.30才进的家门，回来之后还远程合了个代码打了个包，发布restAPI新版本之用。这一周的主要工作就是在做一个web服务器，是一个集群的中间件。因为着急发布新版本，所以昨晚加班到12点多…</p>\n<p>主要实现了几个接口，实现了ssl双向验证功能。其实ssl双向验证的功能主要是了解ssl原理之后如何配置的问题。期间还学习了session和cookie的原理。ssl与cookie、session单开一篇进行总结。这篇日志记录一下这周工作中遇到的一些坑，不一定是技术上的，但是遇到这些小问题还是耽误了一些时间。这篇日志也会持续更新，把以后遇到的坑都总结到这里来。</p>\n<p>希望以后遇到类似的情况能够迅速找到原因将其解决，同时也希望能帮助到可能会看到这篇文章的人。</p>\n<h2 id=\"Spring项目通过export方法打包为jar的问题\"><a href=\"#Spring项目通过export方法打包为jar的问题\" class=\"headerlink\" title=\"Spring项目通过export方法打包为jar的问题\"></a>Spring项目通过export方法打包为jar的问题</h2><p>在前面的日志中已经有<a href=\"http://yukai.space/2016/09/19/Spring%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAjar/\">专门的一篇</a>来总结这个问题:<strong>当通过export方式打包Spring项目时，一定要记得勾选Add Directory Entries这个选项，否则spring无法正确扫描到controller，发生404</strong></p>\n<h2 id=\"使用-PathVariable注解时抛出java-lang-IllegalArgumentException异常\"><a href=\"#使用-PathVariable注解时抛出java-lang-IllegalArgumentException异常\" class=\"headerlink\" title=\"使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常\"></a>使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常</h2><p>假如你的项目中有一个类似下面的controller来接收一个请求：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@GET</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"web/&#123;groupName&#125;\"</span>)</div><div class=\"line\"><span class=\"meta\">@Consumes</span>(MediaType.APPLICATION_JSON)</div><div class=\"line\"><span class=\"meta\">@Produces</span>(MediaType.APPLICATION_JSON)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getWorkerAddress</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response,</div><div class=\"line\">\t\t@PathVariable String groupName)</span> </span>&#123;</div><div class=\"line\">\t\tdoSomething...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当你的项目运行时你发起一个<code>http://ip:port/web/groupName1</code>这样的请求，那么很有可能服务器会报这样一个异常：<strong>java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.</strong></p>\n<p>大概的意思就是参数名称信息没有在类文件中找到。若是浏览器为客户端，浏览器的页面是这样的：</p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/error.png\" alt=\"error\" title=\"error\">\n<p>解决这个异常的方法有两种：</p>\n<p><strong>1.在@PathVariable注解后面加上参数名，比如：@PathVariable(“groupName”)</strong></p>\n<p><strong>2.编译时将debug信息勾选进去：</strong></p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/compiler.png\" alt=\"compiler\" title=\"compiler\">\n<p>编译时把上图绿色框中的单选框勾选，就不会报异常。原因在于Local variable属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量名称和描述符之间的映射关系。</p>\n<p>顺便了解一下上面四个选项的作用：</p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/gengeration.png\" alt=\"compiler\" title=\"compiler\">\n<p>图片截取自：<a href=\"http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-compiler.htm\">Eclipse用户手册</a></p>\n<p>其实就是java工程编译时的一些选项。当我们在debug时遇到问题，比如断点打不上，source not found等等或许修改这些选项可以得到解决。</p>\n<p>参考一篇文章：<a href=\"http://daimojingdeyu.iteye.com/blog/679030\">java编译时生成调试信息选项详解（javac -g）</a></p>\n<h2 id=\"Windows环境下使用Curl，要使用双引号包裹内容\"><a href=\"#Windows环境下使用Curl，要使用双引号包裹内容\" class=\"headerlink\" title=\"Windows环境下使用Curl，要使用双引号包裹内容\"></a>Windows环境下使用Curl，要使用双引号包裹内容</h2><p>web服务器是通过curl来测试的。之前自己也没用过这个所谓的命令行浏览器工具。在机器上装好curl之后，把测试那边提供的脚本拿过来，由于脚本是linux环境下的，做了一点修改之后(其实就是直接换成.bat啦)就直接跑了。脚本内容类似这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -X POST -H &apos;content-type: application/json&apos; -d @del.txt https://localhost:8899/web/rest/data/load/topictarget  -k -b cookie.txt&gt;delresult.txt</div></pre></td></tr></table></figure>\n<p>但是实际测试的过程中，发现收到的post的数据为null，确定了不是服务器的问题之后，感觉应该是curl使用的问题。查了一些资料，是说post的数据要使用双引号包裹，而不是单引号。由于是从del.txt中提取post的数据，所以不存在这个问题。后来将content-type: application/json 的单引号换成双引号之后，问题解决。</p>\n<p><strong>所以：Windows环境下使用Curl，要使用双引号包裹需要加引号的内容，而不是单引号</strong></p>\n<h2 id=\"Spring项目运行过程中，-Autowired注解的变量为null的问题\"><a href=\"#Spring项目运行过程中，-Autowired注解的变量为null的问题\" class=\"headerlink\" title=\"Spring项目运行过程中，@Autowired注解的变量为null的问题\"></a>Spring项目运行过程中，@Autowired注解的变量为null的问题</h2><p>2016/09/09 更新</p>\n<p>这两天开发了一个公众账号来做一些简单的记账工作。后台服务器是用springboot搭建的，测试过程中遇到了这么个情况:</p>\n<p>在运行时服务器报了空指针NullPointerException异常，debug看了一下，发现是一个使用了@Autowired注解的变量没有被初始化。但是按理来说使用了@Autowired注解某个变量后spring会自动为我们实例化这个变量的啊！谷歌了一下，找到了一个类似的情况：<a href=\"http://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null\">Why is my Spring @Autowired field null?</a>.</p>\n<p>下面模拟一下问题出现的场景(代码来自上面的链接)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeController</span> </span>&#123;    </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mileage/&#123;miles&#125;\"</span>)</div><div class=\"line\">    <span class=\"meta\">@ResponseBody</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageFee</span><span class=\"params\">(@PathVariable <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        MileageFeeCalculator calc = <span class=\"keyword\">new</span> MileageFeeCalculator();</div><div class=\"line\">        <span class=\"keyword\">return</span> calc.mileageCharge(miles);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Service</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeCalculator</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> MileageRateService rateService; <span class=\"comment\">// &lt;--- should be autowired, is null</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageCharge</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (miles * rateService.ratePerMile()); <span class=\"comment\">// &lt;--- throws NPE</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Service</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeCalculator</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> MileageRateService rateService; <span class=\"comment\">// &lt;--- should be autowired, is null</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageCharge</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (miles * rateService.ratePerMile()); <span class=\"comment\">// &lt;--- throws NPE</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>访问MileageFeeController时报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.NullPointerException: null</div><div class=\"line\">    at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13)</div><div class=\"line\">    at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14)</div></pre></td></tr></table></figure>\n<p>可以看到，变量rateService是个空值。导致空指针异常…</p>\n<p>原因就在于MileageFeeController.mileageFee中使用了new这种方式实例化了MileageFeeCalculator对象，该对象中的rateService为空，我们使用new这种方式实例化对象时，无法通过spring的@Autowired注解自动实例化对象中的属性。解决的方法就是实例化对象时应该通知spring，使其能够自动配置。</p>\n<p>我采用了上述链接中的第三种方法，解决了问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Component</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationContextHolder</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationContextAware</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ApplicationContext context;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</div><div class=\"line\">        context = applicationContext;   </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ApplicationContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> context;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeController</span> </span>&#123;    </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mileage/&#123;miles&#125;\"</span>)</div><div class=\"line\">    <span class=\"meta\">@ResponseBody</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageFee</span><span class=\"params\">(@PathVariable <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);</div><div class=\"line\">        <span class=\"keyword\">return</span> calc.mileageCharge(miles);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>发生这些问题的原因还是在于对框架的不熟悉，内部原理不甚明了。有机会真得研究研究spring的源码~~</p>\n<h2 id=\"RestController与-Controller\"><a href=\"#RestController与-Controller\" class=\"headerlink\" title=\"@RestController与@Controller\"></a>@RestController与@Controller</h2><p>2016/10/24 更新</p>\n<p>Springboot 使用 Thymeleaf 模板 打算给公众号加一点地图功能，按照<a href=\"https://hellokoding.com/spring-boot-hello-world-example-with-thymeleaf/\">这个教程</a>在springboot项目中配置Thymeleaf，但是每次都没有正确返回html页面，反而是返回了这个html的名称。试了几次才发现自己用错了@RestController这个注解…Controller代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@RestController</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/wechat\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapController</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/map/showRestaurant\"</span>)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showRestaurant</span><span class=\"params\">(@RequestParam(value = <span class=\"string\">\"location_x\"</span>, required = <span class=\"keyword\">true</span>)</span> String location_x,</div><div class=\"line\">            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"location_y\"</span>, required = <span class=\"keyword\">true</span>)</span> String location_y,</div><div class=\"line\">            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"label\"</span>, required = <span class=\"keyword\">true</span>)</span> String label, Model model) </span>&#123;</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"locationx\"</span>, location_x);</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"locationy\"</span>, location_y);</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"label\"</span>,label);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"hello\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>问题原因就在于上面的@RestController这个注解，将其替换为@Controller便解决了。</p>\n<p>根本原因在于@RestController与@Controller<a href=\"http://stackoverflow.com/questions/25242321/difference-between-spring-controller-and-restcontroller-annotation\">这两个注解之间的区别</a></p>\n<h2 id=\"Linux下可靠的启动webservice\"><a href=\"#Linux下可靠的启动webservice\" class=\"headerlink\" title=\"Linux下可靠的启动webservice\"></a>Linux下可靠的启动webservice</h2><p>2016/12/14 更新</p>\n<p>今天线上webservice发现了一个问题，技服把出现的问题描述和日志发给了我，需要解决一下。最终确定不是代码的问题，而是linux下启动程序的方式引发的一个错误。虽然简单，却很容易被疏忽导致问题的发生，值得记录下来。<br>情况是这样的，每次springboot程序会不定时自动停止，观察log发现，每次挂掉之前都会打印一行log,大致意思是，代码中调用的系统程序tail退出了。查看代码时发现确实在tail程序退出时会打印这么一行日志，但却是正常表现，程序运行在一个死循环当中，随后就会重启tail这个程序。循环当中也做了相应的异常捕获，按道理来说webservice不应该挂掉。初步怀疑多次启动tail导致内存泄漏以至于程序退出。由于代码中没有对内存泄漏这种error类型的异常捕获和记录到日志，从日志中无法判断是否发生了内存泄漏。代码中实现了Throwable级别异常的捕获，并记录异常信息到日志，再次抛出该异常。<br>打包，发送给技服到测试机上去跑。一会之后，又挂了。观察新的Log，竟然与之前的没什么区别，并没有什么新的异常信息输出。也就是说，压根没有异常从代码中抛出。很有可能是程序被认为关闭或被系统干掉了。但是之前询问技服，对方否定了这种情况。<br>这就怪了。继续观察日志，此时，发现这么一行：<code>Unregistering JMX-exposed beans on shutdown</code>.确实是springboot退出时打印的信息。google之，大部分的答案是没有添加依赖<code>spring-boot-starter-web</code>所导致springboot无法启动。与现在的情况不符，当前情况是启动正常，运行时突然挂掉。<br>再次询问技服是否kill掉了运行webservice的进程。技服否认，说该程序时运行在后台的，继续询问如何运行在后台，回答是： <code>java -jar MyApplication.jar &amp;</code><br>果然，使用这种方式运行在后台的程序，当ssh断掉或关闭bash窗口后，程序依然会被系统干掉，父进程都被干掉了，子进程也一并干掉了…<br>正确的启动方式应为：<code>nohup java -jar MyApplication.jar &amp;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。</div><div class=\"line\"></div><div class=\"line\">该命令的一般形式为：nohup command &amp;</div><div class=\"line\"></div><div class=\"line\">使用nohup命令提交作业</div><div class=\"line\"></div><div class=\"line\">如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</div><div class=\"line\"></div><div class=\"line\">nohup command &gt; myout.file 2&gt;&amp;1 &amp;</div><div class=\"line\"></div><div class=\"line\">在上面的例子中，输出被重定向到myout.file文件中。</div></pre></td></tr></table></figure>\n<p>该问题虽然不是很难解决，但是很容易被忽略。故在此记录。</p>\n<h2 id=\"持续更新中…\"><a href=\"#持续更新中…\" class=\"headerlink\" title=\"持续更新中….\"></a>持续更新中….</h2>"},{"layout":"post","title":"毕业了","date":"2016-06-30T15:48:55.000Z","_content":"<iframe \n\tframeborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\">\n</iframe>\n毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。\n\n转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。\n\n但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？\n\n大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。\n\n希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。\n\n{% asset_img graduation1.jpg 毕业照 %}\n\n{% asset_img graduation2.jpg 毕设之后金客来 %}\n\n{% asset_img graduation3.jpg 跳蚤市场卖书 %}\n\n{% asset_img graduation4.jpg 去唱K %}\n\n{% asset_img graduation5.jpg 毕业照之前 %}\n\n{% asset_img graduation6.jpg 机房老师 %}\n\n{% asset_img graduation7.jpg 毕业照之前 %}\n\n{% asset_img graduation8.jpg 我和张蕾 %}\n\n\n\n\n","source":"_posts/毕业了.md","raw":"---\nlayout: post\ntitle:  \"毕业了\"\ncategories: 生活 \ndate:  2016-06-30 23:48:55\n---\n<iframe \n\tframeborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\">\n</iframe>\n毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。\n\n转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。\n\n但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？\n\n大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。\n\n希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。\n\n{% asset_img graduation1.jpg 毕业照 %}\n\n{% asset_img graduation2.jpg 毕设之后金客来 %}\n\n{% asset_img graduation3.jpg 跳蚤市场卖书 %}\n\n{% asset_img graduation4.jpg 去唱K %}\n\n{% asset_img graduation5.jpg 毕业照之前 %}\n\n{% asset_img graduation6.jpg 机房老师 %}\n\n{% asset_img graduation7.jpg 毕业照之前 %}\n\n{% asset_img graduation8.jpg 我和张蕾 %}\n\n\n\n\n","slug":"毕业了","published":1,"updated":"2016-11-30T14:32:49.913Z","comments":1,"photos":[],"link":"","_id":"ciyvmgj7h0042digc89ugpp51","content":"<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\"><br></iframe><br>毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。</p>\n<p>转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。</p>\n<p>但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？</p>\n<p>大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。</p>\n<p>希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。</p>\n<img src=\"/2016/06/30/毕业了/graduation1.jpg\" alt=\"毕业照\" title=\"毕业照\">\n<img src=\"/2016/06/30/毕业了/graduation2.jpg\" alt=\"毕设之后金客来\" title=\"毕设之后金客来\">\n<img src=\"/2016/06/30/毕业了/graduation3.jpg\" alt=\"跳蚤市场卖书\" title=\"跳蚤市场卖书\">\n<img src=\"/2016/06/30/毕业了/graduation4.jpg\" alt=\"去唱K\" title=\"去唱K\">\n<img src=\"/2016/06/30/毕业了/graduation5.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation6.jpg\" alt=\"机房老师\" title=\"机房老师\">\n<img src=\"/2016/06/30/毕业了/graduation7.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation8.jpg\" alt=\"我和张蕾\" title=\"我和张蕾\">\n","excerpt":"","more":"<p><iframe \n    frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\"><br></iframe><br>毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。</p>\n<p>转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。</p>\n<p>但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？</p>\n<p>大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。</p>\n<p>希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。</p>\n<img src=\"/2016/06/30/毕业了/graduation1.jpg\" alt=\"毕业照\" title=\"毕业照\">\n<img src=\"/2016/06/30/毕业了/graduation2.jpg\" alt=\"毕设之后金客来\" title=\"毕设之后金客来\">\n<img src=\"/2016/06/30/毕业了/graduation3.jpg\" alt=\"跳蚤市场卖书\" title=\"跳蚤市场卖书\">\n<img src=\"/2016/06/30/毕业了/graduation4.jpg\" alt=\"去唱K\" title=\"去唱K\">\n<img src=\"/2016/06/30/毕业了/graduation5.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation6.jpg\" alt=\"机房老师\" title=\"机房老师\">\n<img src=\"/2016/06/30/毕业了/graduation7.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation8.jpg\" alt=\"我和张蕾\" title=\"我和张蕾\">\n"}],"PostAsset":[{"_id":"source/_posts/毕业了/graduation3.jpg","slug":"graduation3.jpg","post":"ciyvmgj7h0042digc89ugpp51","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation2.jpg","slug":"graduation2.jpg","post":"ciyvmgj7h0042digc89ugpp51","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation8.jpg","slug":"graduation8.jpg","post":"ciyvmgj7h0042digc89ugpp51","modified":0,"renderable":0},{"_id":"source/_posts/Java集合框架学习总结/collection.png","slug":"collection.png","post":"ciyvmgj3j0005digcz3cp0ws2","modified":0,"renderable":0},{"_id":"source/_posts/java中的equals与hashcode/entry.png","slug":"entry.png","post":"ciyvmgj46000cdigcaoyuu06j","modified":0,"renderable":0},{"_id":"source/_posts/java泛型学习/easybill.jpg","slug":"easybill.jpg","post":"ciyvmgj4u0014digclq1drm2y","modified":0,"renderable":0},{"_id":"source/_posts/java异常的学习/java.png","slug":"java.png","post":"ciyvmgj4s000zdigcjh46qmzy","modified":0,"renderable":0},{"_id":"source/_posts/他可是科比·布莱恩特!/kobe.jpg","slug":"kobe.jpg","post":"ciyvmgj5y0023digcfdwfzm2k","modified":0,"renderable":0},{"_id":"source/_posts/关于加密的一点总结/md5.png","slug":"md5.png","post":"ciyvmgj6b002edigc1ttqq2rw","modified":0,"renderable":0},{"_id":"source/_posts/理解notify notifyall sleep/线程状态.png","slug":"线程状态.png","post":"ciyvmgj6p002wdigcd2i6nfzk","modified":0,"renderable":0},{"_id":"source/_posts/理解java内存模型/volatile.png","slug":"volatile.png","post":"ciyvmgj6t002zdigc3ekkcx0v","modified":0,"renderable":0},{"_id":"source/_posts/理解java内存模型/内存模型.png","slug":"内存模型.png","post":"ciyvmgj6t002zdigc3ekkcx0v","modified":0,"renderable":0},{"_id":"source/_posts/java中的编码问题/reader.png","slug":"reader.png","post":"ciyvmgj4m000rdigczzakbd58","modified":0,"renderable":0},{"_id":"source/_posts/java中的编码问题/utf8.png","slug":"utf8.png","post":"ciyvmgj4m000rdigczzakbd58","modified":0,"renderable":0},{"_id":"source/_posts/java中的编码问题/writer.png","slug":"writer.png","post":"ciyvmgj4m000rdigczzakbd58","modified":0,"renderable":0},{"_id":"source/_posts/java远程调试学习/jdpa.png","slug":"jdpa.png","post":"ciyvmgj55001cdigcbzy14lti","modified":0,"renderable":0},{"_id":"source/_posts/java远程调试学习/remote.png","slug":"remote.png","post":"ciyvmgj55001cdigcbzy14lti","modified":0,"renderable":0},{"_id":"source/_posts/java远程调试学习/setting.png","slug":"setting.png","post":"ciyvmgj55001cdigcbzy14lti","modified":0,"renderable":0},{"_id":"source/_posts/记录这周工作遇到的坑/compiler.png","slug":"compiler.png","post":"ciyvmgj6w0033digcxuij395q","modified":0,"renderable":0},{"_id":"source/_posts/记录这周工作遇到的坑/error.png","slug":"error.png","post":"ciyvmgj6w0033digcxuij395q","modified":0,"renderable":0},{"_id":"source/_posts/记录这周工作遇到的坑/gengeration.png","slug":"gengeration.png","post":"ciyvmgj6w0033digcxuij395q","modified":0,"renderable":0},{"_id":"source/_posts/ssl总结/sslprocess.jpg","slug":"sslprocess.jpg","post":"ciyvmgj5p001tdigcio4bj0ea","modified":0,"renderable":0},{"_id":"source/_posts/ssl总结/zhifubao.png","slug":"zhifubao.png","post":"ciyvmgj5p001tdigcio4bj0ea","modified":0,"renderable":0},{"_id":"source/_posts/ssl总结/zhufubao1.png","slug":"zhufubao1.png","post":"ciyvmgj5p001tdigcio4bj0ea","modified":0,"renderable":0},{"_id":"source/_posts/ssl总结/zhufubao2.png","slug":"zhufubao2.png","post":"ciyvmgj5p001tdigcio4bj0ea","modified":0,"renderable":0},{"_id":"source/_posts/Spring项目打包为jar/1.png","slug":"1.png","post":"ciyvmgj3n0006digc4veqaa4s","modified":0,"renderable":0},{"_id":"source/_posts/Spring项目打包为jar/2.png","slug":"2.png","post":"ciyvmgj3n0006digc4veqaa4s","modified":0,"renderable":0},{"_id":"source/_posts/Spring项目打包为jar/3.png","slug":"3.png","post":"ciyvmgj3n0006digc4veqaa4s","modified":0,"renderable":0},{"_id":"source/_posts/Spring项目打包为jar/4.png","slug":"4.png","post":"ciyvmgj3n0006digc4veqaa4s","modified":0,"renderable":0},{"_id":"source/_posts/Spring项目打包为jar/5.png","slug":"5.png","post":"ciyvmgj3n0006digc4veqaa4s","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/1.png","slug":"1.png","post":"ciyvmgj3a0002digc269r50s4","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/2.png","slug":"2.png","post":"ciyvmgj3a0002digc269r50s4","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/3.png","slug":"3.png","post":"ciyvmgj3a0002digc269r50s4","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/4.png","slug":"4.png","post":"ciyvmgj3a0002digc269r50s4","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/5.png","slug":"5.png","post":"ciyvmgj3a0002digc269r50s4","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/6.png","slug":"6.png","post":"ciyvmgj3a0002digc269r50s4","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/7.png","slug":"7.png","post":"ciyvmgj3a0002digc269r50s4","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation1.jpg","slug":"graduation1.jpg","post":"ciyvmgj7h0042digc89ugpp51","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation7.jpg","slug":"graduation7.jpg","post":"ciyvmgj7h0042digc89ugpp51","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation4.jpg","slug":"graduation4.jpg","post":"ciyvmgj7h0042digc89ugpp51","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation5.jpg","slug":"graduation5.jpg","post":"ciyvmgj7h0042digc89ugpp51","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation6.jpg","slug":"graduation6.jpg","post":"ciyvmgj7h0042digc89ugpp51","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ciyvmgj2z0000digcvw4mxujf","category_id":"ciyvmgj3i0004digc622avmvb","_id":"ciyvmgj45000bdigctqzdjr28"},{"post_id":"ciyvmgj3z0008digcuz928vlu","category_id":"ciyvmgj3i0004digc622avmvb","_id":"ciyvmgj49000gdigcbuoo634a"},{"post_id":"ciyvmgj3a0002digc269r50s4","category_id":"ciyvmgj3i0004digc622avmvb","_id":"ciyvmgj4d000jdigcmi9agf7y"},{"post_id":"ciyvmgj4a000hdigcdin43lw7","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj4l000qdigcwrx0srsh"},{"post_id":"ciyvmgj3j0005digcz3cp0ws2","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj4o000vdigcg5ve7fw2"},{"post_id":"ciyvmgj4e000kdigc1ehh7z07","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj4r000ydigchpy670hf"},{"post_id":"ciyvmgj4h000odigc81qrv5if","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj4u0013digc63tm423t"},{"post_id":"ciyvmgj3n0006digc4veqaa4s","category_id":"ciyvmgj4g000ldigcroaveipd","_id":"ciyvmgj4y0016digcfqxd71aw"},{"post_id":"ciyvmgj4m000rdigczzakbd58","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj54001adigcfsufwljn"},{"post_id":"ciyvmgj42000adigctiwrc790","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj59001edigcjbdo1f7d"},{"post_id":"ciyvmgj4u0014digclq1drm2y","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj5f001hdigcgmfdggd8"},{"post_id":"ciyvmgj46000cdigcaoyuu06j","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj5j001ldigccwq78ue6"},{"post_id":"ciyvmgj510017digct04jwglg","category_id":"ciyvmgj3i0004digc622avmvb","_id":"ciyvmgj5l001odigcqthlqf83"},{"post_id":"ciyvmgj55001cdigcbzy14lti","category_id":"ciyvmgj540019digco6lcphan","_id":"ciyvmgj5p001sdigctlnzl5tk"},{"post_id":"ciyvmgj4p000wdigcuecrp6cj","category_id":"ciyvmgj540019digco6lcphan","_id":"ciyvmgj5t001vdigclorm1o5g"},{"post_id":"ciyvmgj59001fdigcf8130vsr","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj5v001ydigc34nm6jm4"},{"post_id":"ciyvmgj5f001idigcy84b84yj","category_id":"ciyvmgj3i0004digc622avmvb","_id":"ciyvmgj5y0022digcmz1pytot"},{"post_id":"ciyvmgj5j001mdigcgrkdvr3a","category_id":"ciyvmgj3i0004digc622avmvb","_id":"ciyvmgj620025digck791l5hs"},{"post_id":"ciyvmgj5m001pdigck3990nkg","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj670029digcqhomibyr"},{"post_id":"ciyvmgj5p001tdigcio4bj0ea","category_id":"ciyvmgj4g000ldigcroaveipd","_id":"ciyvmgj6a002ddigcqgq1i40x"},{"post_id":"ciyvmgj5w001zdigcr76ff0ki","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj6e002hdigco0dibedp"},{"post_id":"ciyvmgj620027digcsyw90o09","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj6g002kdigcmk8wvi6q"},{"post_id":"ciyvmgj5u001wdigcsk92xxkz","category_id":"ciyvmgj5y0021digcqdem8tgp","_id":"ciyvmgj6k002odigc6g3b04bj"},{"post_id":"ciyvmgj68002adigcnbalc4jw","category_id":"ciyvmgj3i0004digc622avmvb","_id":"ciyvmgj6m002rdigcv3hxd0nj"},{"post_id":"ciyvmgj6b002edigc1ttqq2rw","category_id":"ciyvmgj4g000ldigcroaveipd","_id":"ciyvmgj6o002vdigcfey3c21p"},{"post_id":"ciyvmgj5y0023digcfdwfzm2k","category_id":"ciyvmgj5y0021digcqdem8tgp","_id":"ciyvmgj6s002ydigc5ts6ov9w"},{"post_id":"ciyvmgj6e002idigce1hrbqxq","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj6u0031digcsu4prfet"},{"post_id":"ciyvmgj6g002ldigcwceqcdth","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj6y0035digcd9ooh1ld"},{"post_id":"ciyvmgj6k002pdigc0vtvnumb","category_id":"ciyvmgj3i0004digc622avmvb","_id":"ciyvmgj6y0037digcuaj6b4n1"},{"post_id":"ciyvmgj6m002sdigcxou9yme9","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj6z003adigc6isnhsgm"},{"post_id":"ciyvmgj6p002wdigcd2i6nfzk","category_id":"ciyvmgj48000ddigcgs043grk","_id":"ciyvmgj6z003cdigcxxurfs4w"},{"post_id":"ciyvmgj6t002zdigc3ekkcx0v","category_id":"ciyvmgj4g000ldigcroaveipd","_id":"ciyvmgj70003fdigcqwslvpjz"},{"post_id":"ciyvmgj6w0033digcxuij395q","category_id":"ciyvmgj4g000ldigcroaveipd","_id":"ciyvmgj70003hdigcz0iacwon"},{"post_id":"ciyvmgj7h0042digc89ugpp51","category_id":"ciyvmgj5y0021digcqdem8tgp","_id":"ciyvmgj7k0043digcjdqv42i7"}],"PostTag":[{"post_id":"ciyvmgj42000adigctiwrc790","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj49000fdigc73dyyxmx"},{"post_id":"ciyvmgj2z0000digcvw4mxujf","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj4c000idigc2c7igyvs"},{"post_id":"ciyvmgj2z0000digcvw4mxujf","tag_id":"ciyvmgj3y0007digc3vjvaopa","_id":"ciyvmgj4g000ndigcm64tihrz"},{"post_id":"ciyvmgj46000cdigcaoyuu06j","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj4l000pdigcfrws0nv4"},{"post_id":"ciyvmgj4a000hdigcdin43lw7","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj4o000tdigc503793vb"},{"post_id":"ciyvmgj3a0002digc269r50s4","tag_id":"ciyvmgj48000edigcu1z2g2hu","_id":"ciyvmgj4r000xdigcci3fty0l"},{"post_id":"ciyvmgj4e000kdigc1ehh7z07","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj4t0010digcmes33y51"},{"post_id":"ciyvmgj4h000odigc81qrv5if","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj4x0015digcp19xmd3d"},{"post_id":"ciyvmgj3j0005digcz3cp0ws2","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj530018digcndph0bmi"},{"post_id":"ciyvmgj3j0005digcz3cp0ws2","tag_id":"ciyvmgj4o000sdigc5dds65ca","_id":"ciyvmgj58001ddigcxt1ihwat"},{"post_id":"ciyvmgj4s000zdigcjh46qmzy","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj5f001gdigci3ndmm08"},{"post_id":"ciyvmgj4u0014digclq1drm2y","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj5i001kdigcz5ti2oc2"},{"post_id":"ciyvmgj3n0006digc4veqaa4s","tag_id":"ciyvmgj4t0012digcx875q0bg","_id":"ciyvmgj5l001ndigcnmmi2ws3"},{"post_id":"ciyvmgj3n0006digc4veqaa4s","tag_id":"ciyvmgj54001bdigcbsj95vzw","_id":"ciyvmgj5o001rdigc5nwbi4yh"},{"post_id":"ciyvmgj3z0008digcuz928vlu","tag_id":"ciyvmgj5i001jdigctv0fn32t","_id":"ciyvmgj5s001udigcctgfp8ts"},{"post_id":"ciyvmgj4m000rdigczzakbd58","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj5y0020digci3nlqhz2"},{"post_id":"ciyvmgj4m000rdigczzakbd58","tag_id":"ciyvmgj5n001qdigctedy7m5i","_id":"ciyvmgj610024digc5sf5pw9l"},{"post_id":"ciyvmgj5w001zdigcr76ff0ki","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj670028digcxqfs5gmr"},{"post_id":"ciyvmgj620027digcsyw90o09","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj6a002cdigc68u6vk4l"},{"post_id":"ciyvmgj68002adigcnbalc4jw","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj6e002gdigcgw8uzpf1"},{"post_id":"ciyvmgj68002adigcnbalc4jw","tag_id":"ciyvmgj3y0007digc3vjvaopa","_id":"ciyvmgj6g002jdigc0g6v4uhy"},{"post_id":"ciyvmgj510017digct04jwglg","tag_id":"ciyvmgj5v001xdigcojkpfv61","_id":"ciyvmgj6k002ndigc18hkvpmj"},{"post_id":"ciyvmgj510017digct04jwglg","tag_id":"ciyvmgj620026digc1m7ett0g","_id":"ciyvmgj6m002qdigczpd0645b"},{"post_id":"ciyvmgj55001cdigcbzy14lti","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj6o002tdigczoyrqzu9"},{"post_id":"ciyvmgj55001cdigcbzy14lti","tag_id":"ciyvmgj6d002fdigc1l1wwpv2","_id":"ciyvmgj6s002xdigchyucy3qa"},{"post_id":"ciyvmgj59001fdigcf8130vsr","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj6u0030digcdluyzv8x"},{"post_id":"ciyvmgj59001fdigcf8130vsr","tag_id":"ciyvmgj6j002mdigcgm5wizcz","_id":"ciyvmgj6y0034digc1n6c66pl"},{"post_id":"ciyvmgj6m002sdigcxou9yme9","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj6y0036digcedwp54fy"},{"post_id":"ciyvmgj6p002wdigcd2i6nfzk","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj6z0039digcequ35j9f"},{"post_id":"ciyvmgj6p002wdigcd2i6nfzk","tag_id":"ciyvmgj6j002mdigcgm5wizcz","_id":"ciyvmgj6z003bdigcyedug4n0"},{"post_id":"ciyvmgj6t002zdigc3ekkcx0v","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj70003edigci7e4tep4"},{"post_id":"ciyvmgj5f001idigcy84b84yj","tag_id":"ciyvmgj6o002udigcaoke40d4","_id":"ciyvmgj70003gdigcjsqdp361"},{"post_id":"ciyvmgj5j001mdigcgrkdvr3a","tag_id":"ciyvmgj6v0032digc1aa4zbce","_id":"ciyvmgj70003jdigcj4v3jlc2"},{"post_id":"ciyvmgj5j001mdigcgrkdvr3a","tag_id":"ciyvmgj5n001qdigctedy7m5i","_id":"ciyvmgj70003kdigcpgt9su6c"},{"post_id":"ciyvmgj5m001pdigck3990nkg","tag_id":"ciyvmgj6j002mdigcgm5wizcz","_id":"ciyvmgj71003mdigcn2nu5a4r"},{"post_id":"ciyvmgj5m001pdigck3990nkg","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj72003ndigc531zihu1"},{"post_id":"ciyvmgj5p001tdigcio4bj0ea","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj72003pdigcz9rc4apg"},{"post_id":"ciyvmgj5p001tdigcio4bj0ea","tag_id":"ciyvmgj70003idigcxxknk8jb","_id":"ciyvmgj73003qdigci2aho5uu"},{"post_id":"ciyvmgj6b002edigc1ttqq2rw","tag_id":"ciyvmgj70003idigcxxknk8jb","_id":"ciyvmgj74003sdigccmqg9ezo"},{"post_id":"ciyvmgj6e002idigce1hrbqxq","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj74003tdigc4u8fudcf"},{"post_id":"ciyvmgj6e002idigce1hrbqxq","tag_id":"ciyvmgj6j002mdigcgm5wizcz","_id":"ciyvmgj74003vdigc676ctfcz"},{"post_id":"ciyvmgj6g002ldigcwceqcdth","tag_id":"ciyvmgj3e0003digcunromwbu","_id":"ciyvmgj74003wdigcqg17uvmw"},{"post_id":"ciyvmgj6g002ldigcwceqcdth","tag_id":"ciyvmgj6j002mdigcgm5wizcz","_id":"ciyvmgj75003xdigcanjgu27w"},{"post_id":"ciyvmgj6k002pdigc0vtvnumb","tag_id":"ciyvmgj74003udigcncj5hhvx","_id":"ciyvmgj75003zdigc5kvytlb5"},{"post_id":"ciyvmgj6w0033digcxuij395q","tag_id":"ciyvmgj54001bdigcbsj95vzw","_id":"ciyvmgj750040digcjfjq6f5g"},{"post_id":"ciyvmgj6w0033digcxuij395q","tag_id":"ciyvmgj75003ydigcswa9pdvq","_id":"ciyvmgj750041digcpcalp5pk"}],"Tag":[{"name":"java","_id":"ciyvmgj3e0003digcunromwbu"},{"name":"ant","_id":"ciyvmgj3y0007digc3vjvaopa"},{"name":"Eclipse","_id":"ciyvmgj48000edigcu1z2g2hu"},{"name":"源码","_id":"ciyvmgj4o000sdigc5dds65ca"},{"name":"服务器","_id":"ciyvmgj4t0012digcx875q0bg"},{"name":"spring","_id":"ciyvmgj54001bdigcbsj95vzw"},{"name":"linux","_id":"ciyvmgj5i001jdigctv0fn32t"},{"name":"编码","_id":"ciyvmgj5n001qdigctedy7m5i"},{"name":"junit","_id":"ciyvmgj5v001xdigcojkpfv61"},{"name":"测试","_id":"ciyvmgj620026digc1m7ett0g"},{"name":"调试","_id":"ciyvmgj6d002fdigc1l1wwpv2"},{"name":"多线程","_id":"ciyvmgj6j002mdigcgm5wizcz"},{"name":"markdown","_id":"ciyvmgj6o002udigcaoke40d4"},{"name":"python","_id":"ciyvmgj6v0032digc1aa4zbce"},{"name":"加密","_id":"ciyvmgj70003idigcxxknk8jb"},{"name":"快捷键","_id":"ciyvmgj74003udigcncj5hhvx"},{"name":"curl","_id":"ciyvmgj75003ydigcswa9pdvq"}]}}