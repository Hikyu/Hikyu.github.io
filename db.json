{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/pacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/author.jpg","path":"img/author.jpg","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/xiaoxin.ico","path":"img/xiaoxin.ico","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/xiaoxin.png","path":"img/xiaoxin.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/xiaoxin.jpg","path":"img/xiaoxin.jpg","modified":1,"renderable":1},{"_id":"themes/pacman/source/js/jquery-2.1.0.min.js","path":"js/jquery-2.1.0.min.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"75913de577e6e2674855228ebb98f985574fdca1","modified":1471149316499},{"_id":"themes/pacman/LICENSE","hash":"4847e5a63399a0ef85af6844fd19a48c69a8869c","modified":1471163188030},{"_id":"themes/pacman/README.md","hash":"9f0be78dbd1f34f44a955cf02bbe03f979c7a1e6","modified":1471163188035},{"_id":"themes/pacman/_config.yml","hash":"4bd98b542c07dfc9e6ae44c9c684ff97c305538e","modified":1471531092262},{"_id":"source/_posts/Ant的使用.md","hash":"0b9556e59d1dd1eb68ccfcd427d009ececb9302b","modified":1471165582810},{"_id":"source/_posts/Java集合框架学习总结.md","hash":"b2f0e5b0f86ace849a277b685434c97c5b6d63cb","modified":1471870678716},{"_id":"source/_posts/ant编译java工程jdk路径的设置.md","hash":"363cd4e9b485f14f3ecace15eb756efbb92b4cb9","modified":1471163187863},{"_id":"source/_posts/java_Tips.md","hash":"07239be2ba019a7b8309020fff49ed9489c2c93a","modified":1472479365716},{"_id":"source/_posts/java中的ThreadLocal.md","hash":"f9cc4f6fea9ba91ed338be75b2dfaea987c44f53","modified":1471163187877},{"_id":"source/_posts/java中的equals与hashcode.md","hash":"cd559667c69eaa9b784ae0d1822be0984c109fa6","modified":1471910991223},{"_id":"source/_posts/java中的枚举.md","hash":"4724c638e404ef6d366bfb78bc985f84014a92b7","modified":1471180210126},{"_id":"source/_posts/java中的类型转换.md","hash":"1248e2002c9d056665889ad30c3821f5ec8bfe93","modified":1471163187899},{"_id":"source/_posts/java中的编码问题.md","hash":"31e19205d1eec29be4c533338f52963454d1889c","modified":1472650543063},{"_id":"source/_posts/java同步锁锁什么.md","hash":"e864394007c4efd37534180170957618c31402ea","modified":1471163187914},{"_id":"source/_posts/junit使用.md","hash":"73be3a7510e33351504f753f6646465d9f835f2c","modified":1471163187926},{"_id":"source/_posts/markdown.md","hash":"74564b0853bc2c4f29b2b92268dd9bdd6eceb49f","modified":1471163187932},{"_id":"source/_posts/notify问题.md","hash":"1380f520f0812cb8ed93fc302b58bcde3c89b6db","modified":1471180875796},{"_id":"source/_posts/sphinx安装问题.md","hash":"d8e860a7bf662aec845ba3792ea1ad9b9f7c289d","modified":1471163187941},{"_id":"source/_posts/synchronized的一些用法.md","hash":"625baddd8e8aae00fa94df8a70d6f6e136e72b53","modified":1471350850585},{"_id":"source/_posts/一些计划.md","hash":"d6c07e1267493f60a5a5d32a173d14d17c366e5f","modified":1471880570697},{"_id":"source/_posts/为什么是final.md","hash":"bf251e6074bb2cf6228f63049a51de1519e79fe3","modified":1471163187942},{"_id":"source/_posts/他可是科比·布莱恩特!.md","hash":"2dde1cdef9d4958a816e454002358e9e9ddac07a","modified":1471163187943},{"_id":"source/_posts/代码格式.md","hash":"b8d8ec128ce39cb2199a51ecfd2fd04c6fefb758","modified":1471163187957},{"_id":"source/_posts/关于加密的一点总结.md","hash":"1cf22a4128ae294794a1044fae63db9e3e8e1317","modified":1471911011819},{"_id":"source/_posts/关于抽象类和接口.md","hash":"227f5f427cee51015baa90d2114ed06098d5bac8","modified":1471165817537},{"_id":"source/_posts/常用快捷键总结.md","hash":"bdae2b8857bbfa51fbda2ed8e7df26efdcd7e8f0","modified":1471163187963},{"_id":"source/_posts/毕业了.md","hash":"2b9821f648cc35d07350042c10134a5731031a6a","modified":1471167071130},{"_id":"source/_posts/理解java内存模型.md","hash":"a9d19b549fce47203e023e4017a8edfed8fcc7ce","modified":1473511105964},{"_id":"source/_posts/理解notify notifyall sleep.md","hash":"2720396348a3bb4b629fe19fae4c34bc575bb17a","modified":1472660308478},{"_id":"source/page/index.md","hash":"82081b3d275db6e4ccf5a0e8d7f0b1d27f12d75a","modified":1473167929392},{"_id":"themes/pacman/languages/default.yml","hash":"9ffaaf4dbe83f1f343ea702e59493dc6f3f46877","modified":1471163188043},{"_id":"themes/pacman/languages/zh-CN.yml","hash":"680d877a531f8df04b30b462a5131b5d3a8ca372","modified":1471163188047},{"_id":"themes/pacman/languages/zh-TW.yml","hash":"08a6eae3c1e48f96690ca4c29ce67f8d6ff9a8bd","modified":1471163188051},{"_id":"themes/pacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1471163188190},{"_id":"themes/pacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1471163188194},{"_id":"themes/pacman/layout/index.ejs","hash":"dc463eb532313dcdddea9c1a0c8f5a35dbd55f6e","modified":1471163188195},{"_id":"themes/pacman/layout/layout.ejs","hash":"4a5ff6004214906b9ca159fc4187b8923c7bcd11","modified":1471163188196},{"_id":"themes/pacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1471163188197},{"_id":"themes/pacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1471163188201},{"_id":"themes/pacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1471163188202},{"_id":"themes/pacman/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1471163188204},{"_id":"source/_posts/Java集合框架学习总结/collection.png","hash":"9644281b68a057f4db9b162c45ac4c076c7c5651","modified":1471393400658},{"_id":"source/_posts/java中的equals与hashcode/entry.png","hash":"c6c32336b30c74d2e825684e590fc8bb15af2dc1","modified":1471156461592},{"_id":"source/_posts/java中的编码问题/reader.png","hash":"4cf16c765f0952a9134bc5097270d3a6b2679f76","modified":1471163187907},{"_id":"source/_posts/java中的编码问题/utf8.png","hash":"f4a2eb95b15e12d6957c07099fafd42d9b6c035e","modified":1471163187908},{"_id":"source/_posts/java中的编码问题/writer.png","hash":"3ac4dcf3e18dc011372297be5069f387fef0e9f9","modified":1471163187910},{"_id":"source/_posts/关于加密的一点总结/md5.png","hash":"5830f21212d5da0f37cb94dd97fc8db37dcdf033","modified":1471873026215},{"_id":"source/_posts/理解java内存模型/volatile.png","hash":"66e532f81e9747722754733ee0361d3e28bf3ce1","modified":1473510103790},{"_id":"source/_posts/理解java内存模型/内存模型.png","hash":"9afbd38d84a83cd56288172cc45fc627867113c2","modified":1473494485002},{"_id":"source/_posts/理解notify notifyall sleep/线程状态.png","hash":"0716019dc5c338a2b07197e0cd5f593d4dedc504","modified":1472654649249},{"_id":"themes/pacman/layout/_partial/after_footer.ejs","hash":"db09ae62aa29b4c6495c698f9bb14d718a637423","modified":1471163188052},{"_id":"themes/pacman/layout/_partial/archive.ejs","hash":"2241d64f001c96cffa4a129ebea177a5421d147d","modified":1471163188053},{"_id":"themes/pacman/layout/_partial/article.ejs","hash":"8e446ec97c30774807657fc9fb7bceb6905699aa","modified":1471163188066},{"_id":"themes/pacman/layout/_partial/categories.ejs","hash":"2b77ff6cbc8571cab27c3bdc4ad51a79510bbca2","modified":1471163188071},{"_id":"themes/pacman/layout/_partial/footer.ejs","hash":"e9ff0c5864cb64a33eb69076c6de79cd2f70222d","modified":1471183808087},{"_id":"themes/pacman/layout/_partial/google_analytics.ejs","hash":"7ebccafcfdaca5cb5b8f4f06548f1d50958726ef","modified":1471163188094},{"_id":"themes/pacman/layout/_partial/head.ejs","hash":"dc9ecf58ae7990f16089784e33753dd94ed4becc","modified":1471163188109},{"_id":"themes/pacman/layout/_partial/header.ejs","hash":"dc77ad898bdd8273d5bff00923197a5345aa02ca","modified":1471163188121},{"_id":"themes/pacman/layout/_partial/pagination.ejs","hash":"6cf37f844f150af4bbe212610da61e5140317de9","modified":1471163188123},{"_id":"themes/pacman/layout/_partial/search.ejs","hash":"5f1c22e78158cdb77f2af28517b6cbe96150fdd5","modified":1471163188171},{"_id":"themes/pacman/layout/_partial/sidebar.ejs","hash":"565979955cecaab9105b23f668aa63bf97e9c20e","modified":1471163188172},{"_id":"themes/pacman/layout/_partial/tags.ejs","hash":"c5c858742b29e6364da2e1d098e7d6cd8cef038f","modified":1471163188173},{"_id":"themes/pacman/layout/_widget/archive.ejs","hash":"b82d7fb0d1119738a9f9bb747d415e8c99e454ae","modified":1471163188174},{"_id":"themes/pacman/layout/_widget/category.ejs","hash":"ab647b97f55e550af54598dee0c4bb132ef43c46","modified":1471163188176},{"_id":"themes/pacman/layout/_widget/links.ejs","hash":"0d5ef5c05694fb61020fedffbdebe02cb6361c8d","modified":1471163188177},{"_id":"themes/pacman/layout/_widget/rss.ejs","hash":"ebfb11bdd603cd6e4dcf3949cc52e38009615c25","modified":1471163188180},{"_id":"themes/pacman/layout/_widget/tag.ejs","hash":"b994f8c43b190b852568e355944d5af151dcefe6","modified":1471163188186},{"_id":"themes/pacman/layout/_widget/tagcloud.ejs","hash":"317d420f5448c7452290e37f0ed8516cb73f4068","modified":1471163188187},{"_id":"themes/pacman/source/css/style.styl","hash":"fd9224ce13feac0a9b406c28d9bafbd4deda42f5","modified":1471163188241},{"_id":"themes/pacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1471163188243},{"_id":"themes/pacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1471163188245},{"_id":"themes/pacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1471163188246},{"_id":"themes/pacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1471163188247},{"_id":"themes/pacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1471163188248},{"_id":"themes/pacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1471163188250},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1471163188261},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1471163188272},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1471163188295},{"_id":"themes/pacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1471163188304},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1471163188321},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1471163188336},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1471163188341},{"_id":"themes/pacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1471163188357},{"_id":"themes/pacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1471163188384},{"_id":"themes/pacman/source/img/author.jpg","hash":"cf5161efc731fc892ab04b77c2369c7fdad21d87","modified":1471163188389},{"_id":"themes/pacman/source/img/logo.svg","hash":"cef3f0bb4bf3661dd3a58c81b9a7be79601a0bfb","modified":1471163188394},{"_id":"themes/pacman/source/img/xiaoxin.ico","hash":"82778e9316d3d1d366442a8f5d0468dda013d983","modified":1471163188395},{"_id":"themes/pacman/source/img/xiaoxin.png","hash":"479898e56ba23fdc6c68a611939316ad58f6e78c","modified":1471163188402},{"_id":"source/_posts/他可是科比·布莱恩特!/kobe.jpg","hash":"5e2e8343a4fba076d7475cc6cda941d21176be44","modified":1471163187950},{"_id":"source/_posts/毕业了/graduation5.jpg","hash":"976ff6965b27f578d365ae139db1c8d5c298d757","modified":1471163188006},{"_id":"source/_posts/毕业了/graduation6.jpg","hash":"4f36689e7db00afd3f2bc3b4c33480e9d1f1a99c","modified":1471163188013},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.svg","hash":"739808e56a56e10a03bc93d03eb55abd19590942","modified":1471163188329},{"_id":"themes/pacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1471163188376},{"_id":"themes/pacman/source/img/xiaoxin.jpg","hash":"2ee983f8da1be448bd89e8fe0b7c093606bf9788","modified":1471163188401},{"_id":"themes/pacman/source/js/jquery-2.1.0.min.js","hash":"0faaa0c56f563693cdeafa299f97e3d5bd6fcdd8","modified":1471163188443},{"_id":"themes/pacman/layout/_partial/post/article.ejs","hash":"d6f989cf2be408cb8573629f260c75b20df42982","modified":1471163188129},{"_id":"themes/pacman/layout/_partial/post/catetags.ejs","hash":"fa03892b35dc344de7a722b9393978286c0376fe","modified":1471163188130},{"_id":"themes/pacman/layout/_partial/post/comment.ejs","hash":"f0e21c685c0e3fe78c9b5f5f6d4eb9c1b5cf036f","modified":1471163188136},{"_id":"themes/pacman/layout/_partial/post/footer.ejs","hash":"abdfbe549bb371a98884a31e66f71fd92f997bfd","modified":1471183001405},{"_id":"themes/pacman/layout/_partial/post/gallery.ejs","hash":"6bd8723f24b192158e6e840bf14028503ad50045","modified":1471163188138},{"_id":"themes/pacman/layout/_partial/post/header.ejs","hash":"953e6feaf7b156fab79165342e9bca0ef54384ba","modified":1471163188148},{"_id":"themes/pacman/layout/_partial/post/jiathis.ejs","hash":"5043a5058887cf6ad15182cfde345d36cb6ab323","modified":1471163188156},{"_id":"themes/pacman/layout/_partial/post/pagination.ejs","hash":"7b2c70d381d6d6f8a55d89180a9bc0f27118812e","modified":1471163188160},{"_id":"themes/pacman/source/css/_base/code.styl","hash":"577798b3c101be20b7ceb3d1e0421b4c4426d0ce","modified":1471163188210},{"_id":"themes/pacman/source/css/_base/font.styl","hash":"772749cc7c6a47410bb667f8127b37767d029283","modified":1471163188211},{"_id":"themes/pacman/source/css/_base/public.styl","hash":"a9d7524315303734f3f47e5e875a14b867888a50","modified":1471163188217},{"_id":"themes/pacman/source/css/_base/variable.styl","hash":"d02b22aa60d6be15e6edecbad3a23b54ceb2a641","modified":1471180031076},{"_id":"themes/pacman/source/css/_partial/article.styl","hash":"ffc40f735883bea18297dd380ad78ed554c9d5fb","modified":1471163188223},{"_id":"themes/pacman/source/css/_partial/aside.styl","hash":"ac937e5921c4084f29249819d51224ebc4296225","modified":1471163188224},{"_id":"themes/pacman/source/css/_partial/duoshuo.styl","hash":"3ec423b734639614fbd11ec2c3445d3a03f5231d","modified":1471163188228},{"_id":"themes/pacman/source/css/_partial/footer.styl","hash":"65c0ea98fdda93d266f9bc5b9af9032c46fb479b","modified":1471163188233},{"_id":"themes/pacman/source/css/_partial/gallery.styl","hash":"b85a32c4bc71f720d74143a17a202fe8fa067950","modified":1471163188234},{"_id":"themes/pacman/source/css/_partial/header.styl","hash":"7d4ef4b2b1916909f8f198519f576c3d712d7423","modified":1471163188235},{"_id":"themes/pacman/source/css/_partial/helper.styl","hash":"554a7bc576b1419f0055ff56113d4be803b118d1","modified":1471163188236},{"_id":"themes/pacman/source/css/_partial/index.styl","hash":"a00aafe86d0238bf58f093834b6ae7406e918ec0","modified":1471163188240},{"_id":"themes/pacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1471163188251},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1471163188252},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1471163188253},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1471163188254},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1471163188255},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1471163188256},{"_id":"source/_posts/毕业了/graduation3.jpg","hash":"54cffe443f66930659fe9d0a6ee12154ce8d5c28","modified":1471163187990},{"_id":"themes/pacman/source/font/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1471163188367},{"_id":"source/_posts/毕业了/graduation2.jpg","hash":"ccffa377b02496a0f2437578d7f6d35b879373a5","modified":1471163187984},{"_id":"source/_posts/毕业了/graduation8.jpg","hash":"ab88166275c1a01036fe3680407dfff9f52c3434","modified":1471163188028},{"_id":"source/_posts/毕业了/graduation1.jpg","hash":"55cd28acab408b9a81fd6877a47e24d20749e20c","modified":1471163187977},{"_id":"source/_posts/毕业了/graduation7.jpg","hash":"4ef31ad176f81cde92dff0958cfc0b70d789e754","modified":1471163188020},{"_id":"source/_posts/毕业了/graduation4.jpg","hash":"e84c1f0a512f1aba02163ba3a8cf39460b9cb28b","modified":1471163188000},{"_id":"public/page/index.html","hash":"65cfc97bbf1450a633d76d8ed9159cc2e5a7451f","modified":1473511521847},{"_id":"public/2016/06/30/毕业了/index.html","hash":"4525456906e78f7703f06938257b99b110132b29","modified":1473511521847},{"_id":"public/2016/04/25/ant编译java工程jdk路径的设置/index.html","hash":"3ebf2328d53c8c5cd47029848ba8223137c32fe0","modified":1473511521847},{"_id":"public/2016/04/14/他可是科比·布莱恩特!/index.html","hash":"9e4de5e0c73005fe5e0088e5ebce03b5e7fa6f39","modified":1473511521847},{"_id":"public/2016/04/12/junit使用/index.html","hash":"9d29bc5503a6744e44648fc71c58a8f6aa3e9be9","modified":1473511521847},{"_id":"public/2016/03/30/sphinx安装问题/index.html","hash":"245e64723879a6b04b8083703092ce36ce4223c0","modified":1473511521847},{"_id":"public/2016/03/22/常用快捷键总结/index.html","hash":"faf1f79aee47e97b743b15453a65623b9defa8d6","modified":1473511521847},{"_id":"public/2015/12/17/java同步锁锁什么/index.html","hash":"2a691fce0c62fb8350691ef5b08189300cfad0aa","modified":1473511521847},{"_id":"public/archives/index.html","hash":"58cad037e5adffd860c3697a81d49abcab9d00d7","modified":1473511521847},{"_id":"public/archives/page/2/index.html","hash":"4215ac79ea37ecb72ab99eb6dbef8d1246215085","modified":1473511521847},{"_id":"public/archives/page/3/index.html","hash":"87b82a590e8a117986cb4ad806ca32191f40eda7","modified":1473511521847},{"_id":"public/archives/2015/index.html","hash":"5b0dce8e103c96c34978ecf23d4c03a176bf08a9","modified":1473511521847},{"_id":"public/archives/2015/12/index.html","hash":"f1a7a3546a4119d72fedd93ab74c290ee64dfe15","modified":1473511521847},{"_id":"public/archives/2016/index.html","hash":"552489c7bfba13b3ecf596c2f99171e6e0adce6c","modified":1473511521847},{"_id":"public/archives/2016/page/2/index.html","hash":"8e8735c7e5b7ee6ff0c10047ccf7e45a1acf9a1d","modified":1473511521847},{"_id":"public/archives/2016/page/3/index.html","hash":"7dcffd9b0fb226bf6d57bdad077c91a7f1227665","modified":1473511521847},{"_id":"public/archives/2016/03/index.html","hash":"b05a8a8637c97f7796c1ba881283d42fcecd2495","modified":1473511521847},{"_id":"public/archives/2016/04/index.html","hash":"e69ae2371abf45c4da8f8afe4c5edf9f1355f84a","modified":1473511521847},{"_id":"public/archives/2016/06/index.html","hash":"3b7cd2f5ce8ce367f0f6b3940066176db0b65451","modified":1473511521847},{"_id":"public/archives/2016/07/index.html","hash":"809c9984d62e35922c5c919c1657b80432b9a626","modified":1473511521847},{"_id":"public/archives/2016/08/index.html","hash":"0d97bb639a239c5650ffa9fc3b26085cfce4cf6a","modified":1473511521847},{"_id":"public/archives/2016/09/index.html","hash":"5cc03ca699033ea061b326d53171edecf1d51b73","modified":1473511521847},{"_id":"public/categories/工具/index.html","hash":"a3414f30b242aef48b9f58c63002ec1d26537d5b","modified":1473511521847},{"_id":"public/categories/编程/index.html","hash":"96d256c3732c32b91200780ea2101ba631113cff","modified":1473511521847},{"_id":"public/categories/编程/page/2/index.html","hash":"92360314b5a0bcb47d78a778dce6e9c0b4392c59","modified":1473511521847},{"_id":"public/categories/生活/index.html","hash":"4ebab327b7ff26ef042564a01b01e8435c054d27","modified":1473511521847},{"_id":"public/categories/技术/index.html","hash":"ec68fdc3bf0b7d362874774bd51a14d4093dbff3","modified":1473511521847},{"_id":"public/index.html","hash":"e6677dae2f053cbd37ad3380cd2afff694400ee4","modified":1473511521847},{"_id":"public/page/2/index.html","hash":"b24b1788f50fab1fe3381852b2a8b824b67f10e1","modified":1473511521847},{"_id":"public/page/3/index.html","hash":"bdac84b253c7b9f23152ff2f7653786325238c27","modified":1473511521847},{"_id":"public/tags/java/index.html","hash":"9c4bb814c7b4d321d076638d081ec910c0e9d08c","modified":1473511521847},{"_id":"public/tags/java/page/2/index.html","hash":"b60e367411163e514885481fb216c0f17dbb1b6c","modified":1473511521847},{"_id":"public/tags/ant/index.html","hash":"6cbfa4b6e98ff263d5f2fa641ade75c933bb60ab","modified":1473511521847},{"_id":"public/tags/源码/index.html","hash":"02e96e10cc4a85a2ae0afd9fb7f75ef2bed0d09f","modified":1473511521847},{"_id":"public/tags/多线程/index.html","hash":"65b82b20c0cc2f75631922ed50ae3c18c69aeb30","modified":1473511521847},{"_id":"public/tags/编码/index.html","hash":"c6a0d67f36bb2dd58733c0252e56dc95cf6fff71","modified":1473511521847},{"_id":"public/tags/junit/index.html","hash":"240d17e7d48d094b827a7f3bf5d46da0b72858c0","modified":1473511521847},{"_id":"public/tags/测试/index.html","hash":"a4e1f9416d05506af644666b4e963276abaf15b3","modified":1473511521847},{"_id":"public/tags/markdown/index.html","hash":"270e940ca2485323e5705604fc3257dbb522f226","modified":1473511521847},{"_id":"public/tags/python/index.html","hash":"25e8bfa313bcaefcfa320b51e08cf6a8663507ff","modified":1473511521847},{"_id":"public/tags/加密/index.html","hash":"e9777c2ab77de29a734cb6b771f03ce38483ce67","modified":1473511521847},{"_id":"public/tags/快捷键/index.html","hash":"a26588876236b44c947474ddf9a96c8a5780e5f5","modified":1473511521847},{"_id":"public/2016/09/10/理解java内存模型/index.html","hash":"dde711a773de95fdd3f746469d2c52939150727d","modified":1473511521847},{"_id":"public/2016/08/31/理解notify notifyall sleep/index.html","hash":"463cc3a6424c9bb9dc8fb318016afbafda2175b9","modified":1473511521847},{"_id":"public/2016/08/22/关于加密的一点总结/index.html","hash":"83ff72984e9955ac3b88404affcb02a172e846b3","modified":1473511521847},{"_id":"public/2016/08/16/Java集合框架学习总结/index.html","hash":"6c0c937ad8ca85c2b743ca1705f08c0313500e81","modified":1473511521847},{"_id":"public/2016/08/16/synchronized的一些用法/index.html","hash":"c094364fb9684a70a1a04ca0bb44cb1ba130f7b3","modified":1473511521847},{"_id":"public/2016/08/15/一些计划/index.html","hash":"7b112c6fd003fd859f6d7959d76b5ab5a1ba2a5d","modified":1473511521847},{"_id":"public/2016/07/31/为什么是final/index.html","hash":"a363387000f967c74a246edaca79f30e512f33eb","modified":1473511521847},{"_id":"public/2016/07/24/java_Tips/index.html","hash":"731daba5ca286d202047b7178f9d198c0abaaf52","modified":1473511521847},{"_id":"public/2016/07/18/Ant的使用/index.html","hash":"e927a10b043ad097d83ec28327489a77e6d3090e","modified":1473511521847},{"_id":"public/2016/06/30/java中的枚举/index.html","hash":"e35b0e8221288c12136168f419b4948671dac9ba","modified":1473511521847},{"_id":"public/2016/06/21/java中的ThreadLocal/index.html","hash":"7ef952951755b58cf495d1b0617356c091f941a9","modified":1473511521847},{"_id":"public/2016/04/28/java中的类型转换/index.html","hash":"ab4701b33fb2e9136c7aa8dd797b275196b328e9","modified":1473511521847},{"_id":"public/2016/04/28/java中的equals与hashcode/index.html","hash":"af1473915e1d8922491151504f41856237e926d8","modified":1473511521847},{"_id":"public/2016/04/20/java中的编码问题/index.html","hash":"88d6433e2caf4c65f8c0d64e9923e2b0ed0745bf","modified":1473511521847},{"_id":"public/2016/04/15/关于抽象类和接口/index.html","hash":"e45a0054d631f5a3b1307f7db7081c753a08ed97","modified":1473511521847},{"_id":"public/2016/03/29/代码格式/index.html","hash":"879ffb386f463c65ba1ada3447fb6b84aaca5e6f","modified":1473511521847},{"_id":"public/2016/03/03/markdown/index.html","hash":"3413b53f69813030b14d84021cb3084f74e72699","modified":1473511521847},{"_id":"public/2015/12/21/notify问题/index.html","hash":"83ec508e3108508986d49869e3cb56fa84cbabbc","modified":1473511521847},{"_id":"public/CNAME","hash":"75913de577e6e2674855228ebb98f985574fdca1","modified":1473511521879},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1473511521879},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1473511521879},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1473511521879},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1473511521879},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1473511521879},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1473511521879},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1473511521879},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1473511521879},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1473511521879},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1473511521879},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1473511521879},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1473511521879},{"_id":"public/img/author.jpg","hash":"cf5161efc731fc892ab04b77c2369c7fdad21d87","modified":1473511521879},{"_id":"public/img/logo.svg","hash":"cef3f0bb4bf3661dd3a58c81b9a7be79601a0bfb","modified":1473511521879},{"_id":"public/img/xiaoxin.ico","hash":"82778e9316d3d1d366442a8f5d0468dda013d983","modified":1473511521879},{"_id":"public/img/xiaoxin.png","hash":"479898e56ba23fdc6c68a611939316ad58f6e78c","modified":1473511521879},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1473511521879},{"_id":"public/2016/08/16/Java集合框架学习总结/collection.png","hash":"9644281b68a057f4db9b162c45ac4c076c7c5651","modified":1473511521879},{"_id":"public/2016/04/28/java中的equals与hashcode/entry.png","hash":"c6c32336b30c74d2e825684e590fc8bb15af2dc1","modified":1473511521879},{"_id":"public/2016/08/22/关于加密的一点总结/md5.png","hash":"5830f21212d5da0f37cb94dd97fc8db37dcdf033","modified":1473511521879},{"_id":"public/2016/08/31/理解notify notifyall sleep/线程状态.png","hash":"0716019dc5c338a2b07197e0cd5f593d4dedc504","modified":1473511521879},{"_id":"public/2016/09/10/理解java内存模型/volatile.png","hash":"66e532f81e9747722754733ee0361d3e28bf3ce1","modified":1473511521879},{"_id":"public/2016/09/10/理解java内存模型/内存模型.png","hash":"9afbd38d84a83cd56288172cc45fc627867113c2","modified":1473511521894},{"_id":"public/2016/04/20/java中的编码问题/reader.png","hash":"4cf16c765f0952a9134bc5097270d3a6b2679f76","modified":1473511521894},{"_id":"public/2016/04/20/java中的编码问题/utf8.png","hash":"f4a2eb95b15e12d6957c07099fafd42d9b6c035e","modified":1473511521894},{"_id":"public/2016/04/20/java中的编码问题/writer.png","hash":"3ac4dcf3e18dc011372297be5069f387fef0e9f9","modified":1473511521894},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"739808e56a56e10a03bc93d03eb55abd19590942","modified":1473511523630},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1473511523630},{"_id":"public/img/xiaoxin.jpg","hash":"2ee983f8da1be448bd89e8fe0b7c093606bf9788","modified":1473511523630},{"_id":"public/2016/04/14/他可是科比·布莱恩特!/kobe.jpg","hash":"5e2e8343a4fba076d7475cc6cda941d21176be44","modified":1473511523630},{"_id":"public/2016/06/30/毕业了/graduation5.jpg","hash":"976ff6965b27f578d365ae139db1c8d5c298d757","modified":1473511523630},{"_id":"public/2016/06/30/毕业了/graduation6.jpg","hash":"4f36689e7db00afd3f2bc3b4c33480e9d1f1a99c","modified":1473511523630},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1473511523646},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1473511523646},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1473511523646},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1473511523646},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1473511523646},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1473511523646},{"_id":"public/css/style.css","hash":"e3e1ec9060ce2fa8cae11c2e113dd1b45cfed017","modified":1473511523646},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1473511523646},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1473511523646},{"_id":"public/js/jquery-2.1.0.min.js","hash":"98884258cbdb0d939fa2c5e74fc7ac9e56d8170f","modified":1473511523646},{"_id":"public/font/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1473511523661},{"_id":"public/2016/06/30/毕业了/graduation3.jpg","hash":"54cffe443f66930659fe9d0a6ee12154ce8d5c28","modified":1473511523661},{"_id":"public/2016/06/30/毕业了/graduation2.jpg","hash":"ccffa377b02496a0f2437578d7f6d35b879373a5","modified":1473511523661},{"_id":"public/2016/06/30/毕业了/graduation8.jpg","hash":"ab88166275c1a01036fe3680407dfff9f52c3434","modified":1473511523661},{"_id":"public/2016/06/30/毕业了/graduation1.jpg","hash":"55cd28acab408b9a81fd6877a47e24d20749e20c","modified":1473511523724},{"_id":"public/2016/06/30/毕业了/graduation7.jpg","hash":"4ef31ad176f81cde92dff0958cfc0b70d789e754","modified":1473511523724},{"_id":"public/2016/06/30/毕业了/graduation4.jpg","hash":"e84c1f0a512f1aba02163ba3a8cf39460b9cb28b","modified":1473511523771}],"Category":[{"name":"工具","_id":"cisx6polz0004zsqcxuvdyt9t"},{"name":"编程","_id":"cisx6pomf0009zsqcytekf40q"},{"name":"生活","_id":"cisx6poo5001fzsqcefz42wps"},{"name":"技术","_id":"cisx6pop1001xzsqc715lvz6z"}],"Data":[],"Page":[{"layout":"page","title":"README","comments":0,"_content":"{% codeblock lang:java %}\n name: \"于凯\"\n university: \"中国民航大学\"\n hometown: \"山西晋中\"\n dream: \"两亩地一头牛，老婆孩子热炕头\"\n{% endcodeblock %}\n\n本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。也有生活中的一些总结。\n\n# 博客基础\n\n[Hexo](https://hexo.io/)一款轻量级的静态博客框架\n[Pacman](https://github.com/A-limon/pacman)扁平化、响应式Hexo主题\n[Markdown](https://www.gitbook.com/book/noahsoft/-makedown/details)一款轻量级的标记语言\n\n# 技能栈\n\nJava\n\nGit\n\nMarkdown\n\n设计模式\n\n# 书单\n\n《重构 改善既有代码的设计》  人民邮电出版社\n\n《深入理解JVM虚拟机》  机械工业出版社\n\n《大话设计模式》  清华大学出版社  \n\n\n","source":"page/index.md","raw":"layout: page\ntitle: README\ncomments: false\n---\n{% codeblock lang:java %}\n name: \"于凯\"\n university: \"中国民航大学\"\n hometown: \"山西晋中\"\n dream: \"两亩地一头牛，老婆孩子热炕头\"\n{% endcodeblock %}\n\n本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。也有生活中的一些总结。\n\n# 博客基础\n\n[Hexo](https://hexo.io/)一款轻量级的静态博客框架\n[Pacman](https://github.com/A-limon/pacman)扁平化、响应式Hexo主题\n[Markdown](https://www.gitbook.com/book/noahsoft/-makedown/details)一款轻量级的标记语言\n\n# 技能栈\n\nJava\n\nGit\n\nMarkdown\n\n设计模式\n\n# 书单\n\n《重构 改善既有代码的设计》  人民邮电出版社\n\n《深入理解JVM虚拟机》  机械工业出版社\n\n《大话设计模式》  清华大学出版社  \n\n\n","date":"2016-09-06T13:18:49.392Z","updated":"2016-09-06T13:18:49.392Z","path":"page/index.html","_id":"cisx6polk0001zsqcaz9otwn3","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">name: <span class=\"string\">\"于凯\"</span></div><div class=\"line\">university: <span class=\"string\">\"中国民航大学\"</span></div><div class=\"line\">hometown: <span class=\"string\">\"山西晋中\"</span></div><div class=\"line\">dream: <span class=\"string\">\"两亩地一头牛，老婆孩子热炕头\"</span></div></pre></td></tr></table></figure>\n<p>本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。也有生活中的一些总结。</p>\n<h1 id=\"博客基础\"><a href=\"#博客基础\" class=\"headerlink\" title=\"博客基础\"></a>博客基础</h1><p><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>一款轻量级的静态博客框架<br><a href=\"https://github.com/A-limon/pacman\" target=\"_blank\" rel=\"external\">Pacman</a>扁平化、响应式Hexo主题<br><a href=\"https://www.gitbook.com/book/noahsoft/-makedown/details\" target=\"_blank\" rel=\"external\">Markdown</a>一款轻量级的标记语言</p>\n<h1 id=\"技能栈\"><a href=\"#技能栈\" class=\"headerlink\" title=\"技能栈\"></a>技能栈</h1><p>Java</p>\n<p>Git</p>\n<p>Markdown</p>\n<p>设计模式</p>\n<h1 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h1><p>《重构 改善既有代码的设计》  人民邮电出版社</p>\n<p>《深入理解JVM虚拟机》  机械工业出版社</p>\n<p>《大话设计模式》  清华大学出版社  </p>\n","excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">name: <span class=\"string\">\"于凯\"</span></div><div class=\"line\">university: <span class=\"string\">\"中国民航大学\"</span></div><div class=\"line\">hometown: <span class=\"string\">\"山西晋中\"</span></div><div class=\"line\">dream: <span class=\"string\">\"两亩地一头牛，老婆孩子热炕头\"</span></div></pre></td></tr></table></figure>\n<p>本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。也有生活中的一些总结。</p>\n<h1 id=\"博客基础\"><a href=\"#博客基础\" class=\"headerlink\" title=\"博客基础\"></a>博客基础</h1><p><a href=\"https://hexo.io/\">Hexo</a>一款轻量级的静态博客框架<br><a href=\"https://github.com/A-limon/pacman\">Pacman</a>扁平化、响应式Hexo主题<br><a href=\"https://www.gitbook.com/book/noahsoft/-makedown/details\">Markdown</a>一款轻量级的标记语言</p>\n<h1 id=\"技能栈\"><a href=\"#技能栈\" class=\"headerlink\" title=\"技能栈\"></a>技能栈</h1><p>Java</p>\n<p>Git</p>\n<p>Markdown</p>\n<p>设计模式</p>\n<h1 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h1><p>《重构 改善既有代码的设计》  人民邮电出版社</p>\n<p>《深入理解JVM虚拟机》  机械工业出版社</p>\n<p>《大话设计模式》  清华大学出版社  </p>\n"}],"Post":[{"layout":"post","date":"2016-07-18T04:48:55.000Z","title":"ANT的使用","_content":"\n>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和[Ant](http://ant.apache.org/)打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。\n\n## 教程\n\nAnt是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。\n\n[Ant Tutorial](http://www.tutorialspoint.com/ant/index.htm)\n\n[Ant 实践](http://www.uml.org.cn/j2ee/j2ee091302.htm#content)\n\n另外附上Ant常用命令：\n\n[Overview of Apache Ant Tasks](https://ant.apache.org/manual/tasksoverview.html)\n\n## 实践\n\n下面是自己写的build.xml。存在这里，以后用到可以参考。\n\n下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。\n\n- **build.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n    Oscar XcluseterHibernate Ant build file\n-->\n<project name=\"OSCAR-XCLUSETER-HIBERNATE\" default=\"usage\" basedir=\".\">\n\t<target name=\"build\" depends=\"clean\" />\n\n\t<target name=\"init\" description=\"default init\">\n\t\t<property file=\"build.properties\" />\n\n\t\t<!-- Project Properties -->\n\t\t<property name=\"project\" value=\"oscarXcluseterHibernate3\" />\n\t\t<property name=\"name\" value=\"OSCAR HIBERNATE\" />\n\t\t<tstamp>\n\t\t\t<format property=\"year\" pattern=\"yyyy\" locale=\"zh_CN\" />\n\t\t\t<format property=\"builddate\" pattern=\"yyMMdd\" locale=\"zh_CN\" />\n\t\t</tstamp>\n\t\t<property name=\"version\" value=\"${version.major}.${version.minor}.${version.revision}${version.suffix}\" />\n\t\t<property name=\"version.number\" value=\"${version.major}.${version.minor}.${version.revision}\" />\n\t\t<property name=\"version.major.minor\" value=\"${version.major}.${version.minor}\" />\n\n\t\t<property name=\"final.name\" value=\"${project}\" />\n\t\t<property name=\"vesrion.build\" value=\"build${builddate} ${version.subbuild} ${version.buildID} for ALL \" />\n\n\t\t<!-- Build Defaults -->\n\t\t<property name=\"src.dir\" value=\"${basedir}/src\" />\n\t\t<property name=\"lib.dir\" value=\"${basedir}/lib\" />\n\t\t<property name=\"build.home\" value=\"${basedir}\" />\n\t\t<property name=\"build.src\" value=\"${basedir}/build\" />\n\t\t<property name=\"build.dest\" value=\"${basedir}/antClasses\" />\n\t\t<property name=\"build.release\" value=\"${basedir}/release\" />\n\t\t<property name=\"build.tmp\" value=\"${basedir}/tmp\" />\n\n\t\t<!-- JAR artifacts -->\n\t\t<property name=\"hiberante3.jar\" value=\"${lib.dir}/hibernate3.jar\" />\n\n\t\t<!-- Version info filter set -->\n\t\t<tstamp>\n\t\t\t<format property=\"DSTAMP\" pattern=\"yyyyMMdd\" locale=\"zh_CN\" />\n\t\t\t<format property=\"TSTAMP\" pattern=\"hhmm\" />\n\t\t</tstamp>\n\t\t<filterset id=\"version.filters\">\n\t\t\t<filter token=\"VERSION_NUMBER\" value=\"${version.number}\" />\n\t\t\t<filter token=\"BUNDLE_NAME\" value=\"${vesrion.name}\" />\n\t\t\t<filter token=\"BUNDLE_VERSION\" value=\"${version}${DSTAMP}${TSTAMP}\" />\n\t\t\t<filter token=\"BUILD_VERSION\" value=\"${vesrion.build}\" />\n\t\t</filterset>\n\t\t<path id=\"classpath\">\n\t\t\t<pathelement location=\"${hiberante3.jar}\" />\n\t\t</path>\n\t</target>\n\n\t<target name=\"usage\" depends=\"init\">\n\t\t<echo message=\"${name} Build file\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" available targets are:\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"   package  --> generates oscarXcluseterHibernate file\" />\n\t\t<echo message=\"   build    --> compiles the source code\" />\n\t\t<echo message=\"   clean    --> cleans up the directory\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" See the comments inside the build.xml file for more details.\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"\" />\n\t</target>\n\n\t<!-- Just build -->\n\t<target name=\"compile-prepare\" depends=\"init\" description=\"Prepare for compile\">\n\n\t\t<!-- create directories -->\n\t\t<mkdir dir=\"${build.src}\" />\n\t\t<mkdir dir=\"${build.dest}\" />\n\n\t\t<!-- copy src files -->\n\t\t<copy todir=\"${build.src}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${src.dir}\">\n\t\t\t\t<exclude name=\"**/*.MF\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"compile\" depends=\"compile-prepare\" description=\"compile the project\">\n\n\t\t<!-- Compiles the source directory  -->\n\t\t<javac srcdir=\"${build.src}\" \n\t\t\tdestdir=\"${build.dest}\" \n\t\t\tdebug=\"${build.debug}\" \n\t\t\tdeprecation=\"${build.deprecation}\" \n\t\t\tsource=\"${build.source}\" \n\t\t\ttarget=\"${build.target}\" \n\t\t\tcompiler=\"${build.compiler}\" \n\t\t\toptimize=\"${build.optimize}\" \n\t\t\tincludes=\"**/*.java\" \n\t\t\texcludes=\"**/CVS/**,**/.svn/**\" \n\t\t\tencoding=\"GB18030\"\n\t\t\tincludeantruntime=\"false\"\n\t\t\texecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"\n\t\t\tfork=\"yes\">\n\t\t\t<classpath refid=\"classpath\" />\n\t\t</javac>\n\n\t\t<!-- copy src files exclude java file-->\n\t\t<copy todir=\"${build.dest}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${build.src}\">\n\t\t\t\t<exclude name=\"**/*.java\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"build-manifests\" depends=\"init,compile-prepare\">\n\t\t<!-- Filtering tokens for JAR manifests-->\n\t\t<filter token=\"source.jdk\" value=\"${build.source}\" />\n\t\t<filter token=\"target.jdk\" value=\"${build.target}\" />\n\t\t<mkdir dir=\"${build.tmp}\" />\n\t\t<copy todir=\"${build.tmp}\" overwrite=\"yes\" filtering=\"yes\" encoding=\"GB18030\">\n\t\t\t<filterset refid=\"version.filters\" />\n\t\t\t<fileset dir=\"src/META-INF\" includes=\"MANIFEST.MF\" />\n\t\t</copy>\n\t</target>\n\n\t<target name=\"package\" depends=\"compile,build-manifests\" description=\"create jar file\">\n\t\t<mkdir dir=\"${build.release}\" />\n\t\t<jar jarfile=\"${build.release}/${final.name}.jar\" manifest=\"${build.tmp}/MANIFEST.MF\" basedir=\"${build.dest}\" includes=\"**\" />\n\t</target>\n\n\t<target name=\"clean\" depends=\"package\">\n\t\t<delete dir=\"${build.src}\" />\n\t\t<delete dir=\"${build.dest}\" />\n\t\t<delete dir=\"${build.tmp}\" />\n\t</target>\n</project>\n\n```\n\n- **build.properties**\n\n```java\n\n# -----------------------------------------------------------------------------\n# build.properties\n#\n# This is an example \"build.properties\" file, used to customize building \n# OSCAR-JDBC for your local environment.  It defines the location of all external\n# modules that OSCAR-JDBC depends on.\n# -----------------------------------------------------------------------------\n\n# ----- Version Control Flags -----\nvesrion.name=Main\nversion.major=1\nversion.minor=0\nversion.revision=0\nversion.suffix=x\nversion.subbuild=001\nversion.buildID=00000000\n\nbuild.source=1.5\nbuild.target=1.5\nbuild.debug=false\nbuild.optimize=true\nbuild.compiler=javac1.5\n\n```","source":"_posts/Ant的使用.md","raw":"---\nlayout: post\ndate:   2016-07-18 12:48:55\ntitle:  \"ANT的使用\"\ncategories: 工具\ntags: \n- java\n- ant\n---\n\n>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和[Ant](http://ant.apache.org/)打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。\n\n## 教程\n\nAnt是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。\n\n[Ant Tutorial](http://www.tutorialspoint.com/ant/index.htm)\n\n[Ant 实践](http://www.uml.org.cn/j2ee/j2ee091302.htm#content)\n\n另外附上Ant常用命令：\n\n[Overview of Apache Ant Tasks](https://ant.apache.org/manual/tasksoverview.html)\n\n## 实践\n\n下面是自己写的build.xml。存在这里，以后用到可以参考。\n\n下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。\n\n- **build.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n    Oscar XcluseterHibernate Ant build file\n-->\n<project name=\"OSCAR-XCLUSETER-HIBERNATE\" default=\"usage\" basedir=\".\">\n\t<target name=\"build\" depends=\"clean\" />\n\n\t<target name=\"init\" description=\"default init\">\n\t\t<property file=\"build.properties\" />\n\n\t\t<!-- Project Properties -->\n\t\t<property name=\"project\" value=\"oscarXcluseterHibernate3\" />\n\t\t<property name=\"name\" value=\"OSCAR HIBERNATE\" />\n\t\t<tstamp>\n\t\t\t<format property=\"year\" pattern=\"yyyy\" locale=\"zh_CN\" />\n\t\t\t<format property=\"builddate\" pattern=\"yyMMdd\" locale=\"zh_CN\" />\n\t\t</tstamp>\n\t\t<property name=\"version\" value=\"${version.major}.${version.minor}.${version.revision}${version.suffix}\" />\n\t\t<property name=\"version.number\" value=\"${version.major}.${version.minor}.${version.revision}\" />\n\t\t<property name=\"version.major.minor\" value=\"${version.major}.${version.minor}\" />\n\n\t\t<property name=\"final.name\" value=\"${project}\" />\n\t\t<property name=\"vesrion.build\" value=\"build${builddate} ${version.subbuild} ${version.buildID} for ALL \" />\n\n\t\t<!-- Build Defaults -->\n\t\t<property name=\"src.dir\" value=\"${basedir}/src\" />\n\t\t<property name=\"lib.dir\" value=\"${basedir}/lib\" />\n\t\t<property name=\"build.home\" value=\"${basedir}\" />\n\t\t<property name=\"build.src\" value=\"${basedir}/build\" />\n\t\t<property name=\"build.dest\" value=\"${basedir}/antClasses\" />\n\t\t<property name=\"build.release\" value=\"${basedir}/release\" />\n\t\t<property name=\"build.tmp\" value=\"${basedir}/tmp\" />\n\n\t\t<!-- JAR artifacts -->\n\t\t<property name=\"hiberante3.jar\" value=\"${lib.dir}/hibernate3.jar\" />\n\n\t\t<!-- Version info filter set -->\n\t\t<tstamp>\n\t\t\t<format property=\"DSTAMP\" pattern=\"yyyyMMdd\" locale=\"zh_CN\" />\n\t\t\t<format property=\"TSTAMP\" pattern=\"hhmm\" />\n\t\t</tstamp>\n\t\t<filterset id=\"version.filters\">\n\t\t\t<filter token=\"VERSION_NUMBER\" value=\"${version.number}\" />\n\t\t\t<filter token=\"BUNDLE_NAME\" value=\"${vesrion.name}\" />\n\t\t\t<filter token=\"BUNDLE_VERSION\" value=\"${version}${DSTAMP}${TSTAMP}\" />\n\t\t\t<filter token=\"BUILD_VERSION\" value=\"${vesrion.build}\" />\n\t\t</filterset>\n\t\t<path id=\"classpath\">\n\t\t\t<pathelement location=\"${hiberante3.jar}\" />\n\t\t</path>\n\t</target>\n\n\t<target name=\"usage\" depends=\"init\">\n\t\t<echo message=\"${name} Build file\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" available targets are:\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"   package  --> generates oscarXcluseterHibernate file\" />\n\t\t<echo message=\"   build    --> compiles the source code\" />\n\t\t<echo message=\"   clean    --> cleans up the directory\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" See the comments inside the build.xml file for more details.\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"\" />\n\t</target>\n\n\t<!-- Just build -->\n\t<target name=\"compile-prepare\" depends=\"init\" description=\"Prepare for compile\">\n\n\t\t<!-- create directories -->\n\t\t<mkdir dir=\"${build.src}\" />\n\t\t<mkdir dir=\"${build.dest}\" />\n\n\t\t<!-- copy src files -->\n\t\t<copy todir=\"${build.src}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${src.dir}\">\n\t\t\t\t<exclude name=\"**/*.MF\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"compile\" depends=\"compile-prepare\" description=\"compile the project\">\n\n\t\t<!-- Compiles the source directory  -->\n\t\t<javac srcdir=\"${build.src}\" \n\t\t\tdestdir=\"${build.dest}\" \n\t\t\tdebug=\"${build.debug}\" \n\t\t\tdeprecation=\"${build.deprecation}\" \n\t\t\tsource=\"${build.source}\" \n\t\t\ttarget=\"${build.target}\" \n\t\t\tcompiler=\"${build.compiler}\" \n\t\t\toptimize=\"${build.optimize}\" \n\t\t\tincludes=\"**/*.java\" \n\t\t\texcludes=\"**/CVS/**,**/.svn/**\" \n\t\t\tencoding=\"GB18030\"\n\t\t\tincludeantruntime=\"false\"\n\t\t\texecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"\n\t\t\tfork=\"yes\">\n\t\t\t<classpath refid=\"classpath\" />\n\t\t</javac>\n\n\t\t<!-- copy src files exclude java file-->\n\t\t<copy todir=\"${build.dest}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${build.src}\">\n\t\t\t\t<exclude name=\"**/*.java\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"build-manifests\" depends=\"init,compile-prepare\">\n\t\t<!-- Filtering tokens for JAR manifests-->\n\t\t<filter token=\"source.jdk\" value=\"${build.source}\" />\n\t\t<filter token=\"target.jdk\" value=\"${build.target}\" />\n\t\t<mkdir dir=\"${build.tmp}\" />\n\t\t<copy todir=\"${build.tmp}\" overwrite=\"yes\" filtering=\"yes\" encoding=\"GB18030\">\n\t\t\t<filterset refid=\"version.filters\" />\n\t\t\t<fileset dir=\"src/META-INF\" includes=\"MANIFEST.MF\" />\n\t\t</copy>\n\t</target>\n\n\t<target name=\"package\" depends=\"compile,build-manifests\" description=\"create jar file\">\n\t\t<mkdir dir=\"${build.release}\" />\n\t\t<jar jarfile=\"${build.release}/${final.name}.jar\" manifest=\"${build.tmp}/MANIFEST.MF\" basedir=\"${build.dest}\" includes=\"**\" />\n\t</target>\n\n\t<target name=\"clean\" depends=\"package\">\n\t\t<delete dir=\"${build.src}\" />\n\t\t<delete dir=\"${build.dest}\" />\n\t\t<delete dir=\"${build.tmp}\" />\n\t</target>\n</project>\n\n```\n\n- **build.properties**\n\n```java\n\n# -----------------------------------------------------------------------------\n# build.properties\n#\n# This is an example \"build.properties\" file, used to customize building \n# OSCAR-JDBC for your local environment.  It defines the location of all external\n# modules that OSCAR-JDBC depends on.\n# -----------------------------------------------------------------------------\n\n# ----- Version Control Flags -----\nvesrion.name=Main\nversion.major=1\nversion.minor=0\nversion.revision=0\nversion.suffix=x\nversion.subbuild=001\nversion.buildID=00000000\n\nbuild.source=1.5\nbuild.target=1.5\nbuild.debug=false\nbuild.optimize=true\nbuild.compiler=javac1.5\n\n```","slug":"Ant的使用","published":1,"updated":"2016-08-14T09:06:22.810Z","comments":1,"photos":[],"link":"","_id":"cisx6pol40000zsqcda89bi4n","content":"<blockquote>\n<p>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和<a href=\"http://ant.apache.org/\" target=\"_blank\" rel=\"external\">Ant</a>打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。</p>\n</blockquote>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><p>Ant是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。</p>\n<p><a href=\"http://www.tutorialspoint.com/ant/index.htm\" target=\"_blank\" rel=\"external\">Ant Tutorial</a></p>\n<p><a href=\"http://www.uml.org.cn/j2ee/j2ee091302.htm#content\" target=\"_blank\" rel=\"external\">Ant 实践</a></p>\n<p>另外附上Ant常用命令：</p>\n<p><a href=\"https://ant.apache.org/manual/tasksoverview.html\" target=\"_blank\" rel=\"external\">Overview of Apache Ant Tasks</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>下面是自己写的build.xml。存在这里，以后用到可以参考。</p>\n<p>下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。</p>\n<ul>\n<li><strong>build.xml</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"comment\">&lt;!--</span></div><div class=\"line\">    Oscar XcluseterHibernate Ant build file</div><div class=\"line\">--&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">name</span>=<span class=\"string\">\"OSCAR-XCLUSETER-HIBERNATE\"</span> <span class=\"attr\">default</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\".\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"clean\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"default init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">file</span>=<span class=\"string\">\"build.properties\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Project Properties --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"project\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"oscarXcluseterHibernate3\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"OSCAR HIBERNATE\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"year\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyy\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"builddate\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;$&#123;version.suffix&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.number\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.major.minor\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"final.name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;project&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"vesrion.build\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"build$&#123;builddate&#125; $&#123;version.subbuild&#125; $&#123;version.buildID&#125; for ALL \"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Build Defaults --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"src.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/src\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lib.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/lib\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.home\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.src\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/build\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.dest\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/antClasses\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.release\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/release\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.tmp\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/tmp\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- JAR artifacts --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hiberante3.jar\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;lib.dir&#125;/hibernate3.jar\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Version info filter set --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"DSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"TSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"hhmm\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">id</span>=<span class=\"string\">\"version.filters\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"VERSION_NUMBER\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.number&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_NAME\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.name&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version&#125;$&#123;DSTAMP&#125;$&#123;TSTAMP&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUILD_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.build&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">filterset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"classpath\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">pathelement</span> <span class=\"attr\">location</span>=<span class=\"string\">\"$&#123;hiberante3.jar&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"$&#123;name&#125; Build file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" available targets are:\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   package  --&gt; generates oscarXcluseterHibernate file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   build    --&gt; compiles the source code\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   clean    --&gt; cleans up the directory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" See the comments inside the build.xml file for more details.\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- Just build --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"Prepare for compile\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- create directories --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;src.dir&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"compile the project\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Compiles the source directory  --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">javac</span> <span class=\"attr\">srcdir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> </span></div><div class=\"line\">\t\t\t<span class=\"attr\">destdir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">debug</span>=<span class=\"string\">\"$&#123;build.debug&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">deprecation</span>=<span class=\"string\">\"$&#123;build.deprecation&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">source</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">target</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">compiler</span>=<span class=\"string\">\"$&#123;build.compiler&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">optimize</span>=<span class=\"string\">\"$&#123;build.optimize&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">includes</span>=<span class=\"string\">\"**/*.java\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">excludes</span>=<span class=\"string\">\"**/CVS/**,**/.svn/**\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">includeantruntime</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">executable</span>=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">fork</span>=<span class=\"string\">\"yes\"</span>&gt;</div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">classpath</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"classpath\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">javac</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files exclude java file--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.java\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build-manifests\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init,compile-prepare\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Filtering tokens for JAR manifests--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"source.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"target.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">filtering</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"version.filters\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"src/META-INF\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"MANIFEST.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"package\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile,build-manifests\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"create jar file\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.release&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">jar</span> <span class=\"attr\">jarfile</span>=<span class=\"string\">\"$&#123;build.release&#125;/$&#123;final.name&#125;.jar\"</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"$&#123;build.tmp&#125;/MANIFEST.MF\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"**\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"clean\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"package\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li><strong>build.properties</strong></li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"># build.properties</div><div class=\"line\">#</div><div class=\"line\"># This is an example \"build.properties\" file, used to customize building </div><div class=\"line\"># OSCAR-JDBC for your local environment.  It defines the location of all external</div><div class=\"line\"># modules that OSCAR-JDBC depends on.</div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\"># ----- Version Control Flags -----</div><div class=\"line\">vesrion.name=Main</div><div class=\"line\">version.major=1</div><div class=\"line\">version.minor=0</div><div class=\"line\">version.revision=0</div><div class=\"line\">version.suffix=x</div><div class=\"line\">version.subbuild=001</div><div class=\"line\">version.buildID=00000000</div><div class=\"line\"></div><div class=\"line\">build.source=1.5</div><div class=\"line\">build.target=1.5</div><div class=\"line\">build.debug=false</div><div class=\"line\">build.optimize=true</div><div class=\"line\">build.compiler=javac1.5</div></pre></td></tr></table></figure>","excerpt":"","more":"<blockquote>\n<p>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和<a href=\"http://ant.apache.org/\">Ant</a>打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。</p>\n</blockquote>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><p>Ant是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。</p>\n<p><a href=\"http://www.tutorialspoint.com/ant/index.htm\">Ant Tutorial</a></p>\n<p><a href=\"http://www.uml.org.cn/j2ee/j2ee091302.htm#content\">Ant 实践</a></p>\n<p>另外附上Ant常用命令：</p>\n<p><a href=\"https://ant.apache.org/manual/tasksoverview.html\">Overview of Apache Ant Tasks</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>下面是自己写的build.xml。存在这里，以后用到可以参考。</p>\n<p>下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。</p>\n<ul>\n<li><strong>build.xml</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"comment\">&lt;!--</div><div class=\"line\">    Oscar XcluseterHibernate Ant build file</div><div class=\"line\">--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">name</span>=<span class=\"string\">\"OSCAR-XCLUSETER-HIBERNATE\"</span> <span class=\"attr\">default</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\".\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"clean\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"default init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">file</span>=<span class=\"string\">\"build.properties\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Project Properties --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"project\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"oscarXcluseterHibernate3\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"OSCAR HIBERNATE\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"year\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyy\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"builddate\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;$&#123;version.suffix&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.number\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.major.minor\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"final.name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;project&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"vesrion.build\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"build$&#123;builddate&#125; $&#123;version.subbuild&#125; $&#123;version.buildID&#125; for ALL \"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Build Defaults --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"src.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/src\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lib.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/lib\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.home\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.src\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/build\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.dest\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/antClasses\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.release\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/release\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.tmp\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/tmp\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- JAR artifacts --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hiberante3.jar\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;lib.dir&#125;/hibernate3.jar\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Version info filter set --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"DSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"TSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"hhmm\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">id</span>=<span class=\"string\">\"version.filters\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"VERSION_NUMBER\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.number&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_NAME\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.name&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version&#125;$&#123;DSTAMP&#125;$&#123;TSTAMP&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUILD_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.build&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">filterset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"classpath\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">pathelement</span> <span class=\"attr\">location</span>=<span class=\"string\">\"$&#123;hiberante3.jar&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"$&#123;name&#125; Build file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" available targets are:\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   package  --&gt; generates oscarXcluseterHibernate file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   build    --&gt; compiles the source code\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   clean    --&gt; cleans up the directory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" See the comments inside the build.xml file for more details.\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- Just build --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"Prepare for compile\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- create directories --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;src.dir&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"compile the project\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Compiles the source directory  --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">javac</span> <span class=\"attr\">srcdir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">destdir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">debug</span>=<span class=\"string\">\"$&#123;build.debug&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">deprecation</span>=<span class=\"string\">\"$&#123;build.deprecation&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">source</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">target</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">compiler</span>=<span class=\"string\">\"$&#123;build.compiler&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">optimize</span>=<span class=\"string\">\"$&#123;build.optimize&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">includes</span>=<span class=\"string\">\"**/*.java\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">excludes</span>=<span class=\"string\">\"**/CVS/**,**/.svn/**\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">includeantruntime</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">executable</span>=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">fork</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">classpath</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"classpath\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">javac</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files exclude java file--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.java\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build-manifests\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init,compile-prepare\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Filtering tokens for JAR manifests--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"source.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"target.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">filtering</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"version.filters\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"src/META-INF\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"MANIFEST.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"package\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile,build-manifests\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"create jar file\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.release&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">jar</span> <span class=\"attr\">jarfile</span>=<span class=\"string\">\"$&#123;build.release&#125;/$&#123;final.name&#125;.jar\"</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"$&#123;build.tmp&#125;/MANIFEST.MF\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"**\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"clean\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"package\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li><strong>build.properties</strong></li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"># build.properties</div><div class=\"line\">#</div><div class=\"line\"># This is an example \"build.properties\" file, used to customize building </div><div class=\"line\"># OSCAR-JDBC for your local environment.  It defines the location of all external</div><div class=\"line\"># modules that OSCAR-JDBC depends on.</div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\"># ----- Version Control Flags -----</div><div class=\"line\">vesrion.name=Main</div><div class=\"line\">version.major=1</div><div class=\"line\">version.minor=0</div><div class=\"line\">version.revision=0</div><div class=\"line\">version.suffix=x</div><div class=\"line\">version.subbuild=001</div><div class=\"line\">version.buildID=00000000</div><div class=\"line\"></div><div class=\"line\">build.source=1.5</div><div class=\"line\">build.target=1.5</div><div class=\"line\">build.debug=false</div><div class=\"line\">build.optimize=true</div><div class=\"line\">build.compiler=javac1.5</div></pre></td></tr></table></figure>"},{"layout":"post","title":"Java集合框架学习总结","date":"2016-08-16T14:50:16.000Z","_content":"\n看Jdk的源码有大概一个月时间了，中间零零散散算是把[Java的集合](https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html)看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：[Java IO](https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description)\n\n## 框架\n\n{% asset_img collection.png 集合框架 %}\n\n上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。\n\n通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。\n\n## List\n\n### Iterator\n\n在总结List之前，先看一下Iterable这个接口,它只包含一个方法:\n\n```java\nIterator<T> iterator();\n```\n\n这个方法返回一个[Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。\n\n### [Collection](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)\n\nCollection 提供了集合的一些基本操作,Collection 接口提供的主要方法：\n\n```\nboolean add(Object o) 添加对象到集合；\nboolean remove(Object o) 删除指定的对象；\nint size() 返回当前集合中元素的数量；\nboolean contains(Object o) 查找集合中是否有指定的对象；\nboolean isEmpty() 判断集合是否为空；\nIterator iterator() 返回一个迭代器；\nboolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；\nboolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；\nvoid clear() 删除集合中所有元素；\nvoid removeAll(Collection c) 从集合中删除 C 集合中也有的元素；\nvoid retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。\n```\n没发现有什么好说的。\n\n### [List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)\n\nList\n\n\n\n","source":"_posts/Java集合框架学习总结.md","raw":"layout: post\ntitle: Java集合框架学习总结\ndate: 2016-08-16 22:50:16\ncategories: 编程 \ntags: \n- java\n- 源码\n---\n\n看Jdk的源码有大概一个月时间了，中间零零散散算是把[Java的集合](https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html)看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：[Java IO](https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description)\n\n## 框架\n\n{% asset_img collection.png 集合框架 %}\n\n上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。\n\n通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。\n\n## List\n\n### Iterator\n\n在总结List之前，先看一下Iterable这个接口,它只包含一个方法:\n\n```java\nIterator<T> iterator();\n```\n\n这个方法返回一个[Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。\n\n### [Collection](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)\n\nCollection 提供了集合的一些基本操作,Collection 接口提供的主要方法：\n\n```\nboolean add(Object o) 添加对象到集合；\nboolean remove(Object o) 删除指定的对象；\nint size() 返回当前集合中元素的数量；\nboolean contains(Object o) 查找集合中是否有指定的对象；\nboolean isEmpty() 判断集合是否为空；\nIterator iterator() 返回一个迭代器；\nboolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；\nboolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；\nvoid clear() 删除集合中所有元素；\nvoid removeAll(Collection c) 从集合中删除 C 集合中也有的元素；\nvoid retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。\n```\n没发现有什么好说的。\n\n### [List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)\n\nList\n\n\n\n","slug":"Java集合框架学习总结","published":1,"updated":"2016-08-22T12:57:58.716Z","comments":1,"photos":[],"link":"","_id":"cisx6polk0002zsqc80bvf3gv","content":"<p>看Jdk的源码有大概一个月时间了，中间零零散散算是把<a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html\" target=\"_blank\" rel=\"external\">Java的集合</a>看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description\" target=\"_blank\" rel=\"external\">Java IO</a></p>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><img src=\"/2016/08/16/Java集合框架学习总结/collection.png\" alt=\"集合框架\" title=\"集合框架\">\n<p>上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。</p>\n<p>通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。</p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h3><p>在总结List之前，先看一下Iterable这个接口,它只包含一个方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Iterator&lt;T&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</div></pre></td></tr></table></figure>\n<p>这个方法返回一个<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\" target=\"_blank\" rel=\"external\">Iterator</a>，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。</p>\n<h3 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html\" target=\"_blank\" rel=\"external\">Collection</a></h3><p>Collection 提供了集合的一些基本操作,Collection 接口提供的主要方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean add(Object o) 添加对象到集合；</div><div class=\"line\">boolean remove(Object o) 删除指定的对象；</div><div class=\"line\">int size() 返回当前集合中元素的数量；</div><div class=\"line\">boolean contains(Object o) 查找集合中是否有指定的对象；</div><div class=\"line\">boolean isEmpty() 判断集合是否为空；</div><div class=\"line\">Iterator iterator() 返回一个迭代器；</div><div class=\"line\">boolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；</div><div class=\"line\">boolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；</div><div class=\"line\">void clear() 删除集合中所有元素；</div><div class=\"line\">void removeAll(Collection c) 从集合中删除 C 集合中也有的元素；</div><div class=\"line\">void retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。</div></pre></td></tr></table></figure>\n<p>没发现有什么好说的。</p>\n<h3 id=\"List-1\"><a href=\"#List-1\" class=\"headerlink\" title=\"List\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/List.html\" target=\"_blank\" rel=\"external\">List</a></h3><p>List</p>\n","excerpt":"","more":"<p>看Jdk的源码有大概一个月时间了，中间零零散散算是把<a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html\">Java的集合</a>看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description\">Java IO</a></p>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><img src=\"/2016/08/16/Java集合框架学习总结/collection.png\" alt=\"集合框架\" title=\"集合框架\">\n<p>上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。</p>\n<p>通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。</p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h3><p>在总结List之前，先看一下Iterable这个接口,它只包含一个方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Iterator&lt;T&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</div></pre></td></tr></table></figure>\n<p>这个方法返回一个<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\">Iterator</a>，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。</p>\n<h3 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html\">Collection</a></h3><p>Collection 提供了集合的一些基本操作,Collection 接口提供的主要方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean add(Object o) 添加对象到集合；</div><div class=\"line\">boolean remove(Object o) 删除指定的对象；</div><div class=\"line\">int size() 返回当前集合中元素的数量；</div><div class=\"line\">boolean contains(Object o) 查找集合中是否有指定的对象；</div><div class=\"line\">boolean isEmpty() 判断集合是否为空；</div><div class=\"line\">Iterator iterator() 返回一个迭代器；</div><div class=\"line\">boolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；</div><div class=\"line\">boolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；</div><div class=\"line\">void clear() 删除集合中所有元素；</div><div class=\"line\">void removeAll(Collection c) 从集合中删除 C 集合中也有的元素；</div><div class=\"line\">void retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。</div></pre></td></tr></table></figure>\n<p>没发现有什么好说的。</p>\n<h3 id=\"List-1\"><a href=\"#List-1\" class=\"headerlink\" title=\"List\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/List.html\">List</a></h3><p>List</p>\n"},{"layout":"post","title":"ANT编译java工程经jdk路径的设置","date":"2016-04-25T04:48:55.000Z","_content":"\n> 今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。\n\n打包过程中总是报：\n\n```java\n[javac] 警告: [options] 未与 -source 1.5 一起设置引导类路径\n[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:50: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()\n[javac] public class Driver implements java.sql.Driver {\n....\n```\n\n类似这样的一堆错误。\n\n没有过多的思考，百度之...出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。\n\n严重的浪费时间和影响心情，遂放弃。\n\n静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。\n\n后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。\n\n重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。\n\n等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’\n\n果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加\n\n```java\nexecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"\nfork=\"yes\"\n```\n\nBuild Successfull.\n\n这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：\n\n1.不要用百度\n\n2.先思考问题原因，再寻找解决方案\n\n3.学习英语，尽量用英文搜索\n\n## 参考\n\n[Change JDK for running <ANT> task from within build xml](http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml)\n\n\n","source":"_posts/ant编译java工程jdk路径的设置.md","raw":"---\nlayout: post\ntitle:  \"ANT编译java工程经jdk路径的设置\"\ncategories: 工具\ntags: \n- java\n- ant\ndate:   2016-04-25 12:48:55\n---\n\n> 今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。\n\n打包过程中总是报：\n\n```java\n[javac] 警告: [options] 未与 -source 1.5 一起设置引导类路径\n[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:50: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()\n[javac] public class Driver implements java.sql.Driver {\n....\n```\n\n类似这样的一堆错误。\n\n没有过多的思考，百度之...出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。\n\n严重的浪费时间和影响心情，遂放弃。\n\n静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。\n\n后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。\n\n重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。\n\n等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’\n\n果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加\n\n```java\nexecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"\nfork=\"yes\"\n```\n\nBuild Successfull.\n\n这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：\n\n1.不要用百度\n\n2.先思考问题原因，再寻找解决方案\n\n3.学习英语，尽量用英文搜索\n\n## 参考\n\n[Change JDK for running <ANT> task from within build xml](http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml)\n\n\n","slug":"ant编译java工程jdk路径的设置","published":1,"updated":"2016-08-14T08:26:27.863Z","comments":1,"photos":[],"link":"","_id":"cisx6polz0005zsqcqe4yhk6a","content":"<blockquote>\n<p>今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。</p>\n</blockquote>\n<p>打包过程中总是报：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[javac] 警告: [options] 未与 -source <span class=\"number\">1.5</span> 一起设置引导类路径</div><div class=\"line\">[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:<span class=\"number\">50</span>: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()</div><div class=\"line\">[javac] <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>类似这样的一堆错误。</p>\n<p>没有过多的思考，百度之…出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。</p>\n<p>严重的浪费时间和影响心情，遂放弃。</p>\n<p>静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。</p>\n<p>后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。</p>\n<p>重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。</p>\n<p>等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’</p>\n<p>果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">executable=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"</span></div><div class=\"line\">fork=<span class=\"string\">\"yes\"</span></div></pre></td></tr></table></figure>\n<p>Build Successfull.</p>\n<p>这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：</p>\n<p>1.不要用百度</p>\n<p>2.先思考问题原因，再寻找解决方案</p>\n<p>3.学习英语，尽量用英文搜索</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml\" target=\"_blank\" rel=\"external\">Change JDK for running <ant> task from within build xml</ant></a></p>\n","excerpt":"","more":"<blockquote>\n<p>今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。</p>\n</blockquote>\n<p>打包过程中总是报：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[javac] 警告: [options] 未与 -source <span class=\"number\">1.5</span> 一起设置引导类路径</div><div class=\"line\">[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:<span class=\"number\">50</span>: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()</div><div class=\"line\">[javac] <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>类似这样的一堆错误。</p>\n<p>没有过多的思考，百度之…出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。</p>\n<p>严重的浪费时间和影响心情，遂放弃。</p>\n<p>静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。</p>\n<p>后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。</p>\n<p>重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。</p>\n<p>等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’</p>\n<p>果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">executable=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"</span></div><div class=\"line\">fork=<span class=\"string\">\"yes\"</span></div></pre></td></tr></table></figure>\n<p>Build Successfull.</p>\n<p>这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：</p>\n<p>1.不要用百度</p>\n<p>2.先思考问题原因，再寻找解决方案</p>\n<p>3.学习英语，尽量用英文搜索</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml\">Change JDK for running <ANT> task from within build xml</a></p>\n"},{"layout":"post","title":"java编程技巧","date":"2016-07-24T04:48:55.000Z","_content":"\n>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~\n\n **1**. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层\n\n **2**. if语句中,判断条件尽量不要使用if(!...)的形式，这样只会使代码更加难以理解\n\n **3**. 循环内不要不断创建对象引用，而应该：\n\n```java\n     Object obj = null;\n     for (int i = 0; i <= count; i++) { \n      obj = new Object(); \n     }\n```\n\n **4**. 不要在循环条件中重复计算变量，比如：\n\n```java\n    for (int i = 0; i <= obj.size(); i++){...}\n```\n\n **5**. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字\n\n **6**. 尽量采用懒加载的策略，即在需要的时候才创建,例如：\n\n```java\n    String str = \"aaa\";\n    if (i == 1) { \n       list.add(str);\n    }\n```\n\n建议替换为：\n\n```java\n\n\tif (i == 1) { \n     String str = \"aaa\"; list.add(str);\n   }\n```\n\n\n **7**. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码\n\n **8**. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能\n\n **9**. 使用&& ,\\|\\| 操作符时，将首先需要满足的条件置于操作符之前。因为&& 和 \\|\\| 具有短路性。另外，体会if(e. key==k\\|\\|k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用\\|\\|将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）\n\n **10**. 尽量用for each语句代替for循环\n\n **11**. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。\n\n **12**. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。\n       \n```java\n    if(\"hello\".equals(variable)){...}\n```\n\n **13**. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：\n\n```java\n    if(string.indexof(character) != -1){...}`\n```\n\n应改为：\n\n```java\n    if(string.indexof(character) >0 ){...}\n```\n\n **14**. 避免意外的赋值，比如：\n \n```java\n    if(variable == 5){...}`\n```\n\n应改为：\n\n```java\n    if(5 == variable){...}\n```\n\n避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出`if(variable = 5)`这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~\n\n **15**. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：\n\n```java\n\tif(array.length > 0){...}\n```\n\n应改为：\n\n```java\n\tif(array != null && array.length > 0){...}\n```\n\n\n **16**. 确保只有一个退出点。比如：\n\n```java\n    private boolean isEligible(int age){\n\n    \tif(age > 18) {\n\n    \t\treturn true;\n\n    \t} else {\n\n            return false;\n    \t}\n\n    }\n```\n\n应改为：\n\n```java\n    private boolean isEligible(int age){\n    \tboolean result;\n\n    \tif(age > 18) {\n\n    \t\tresult = true;\n\n    \t} else {\n\n            result = false;\n    \t}\n\n    \treturn result;\n    }\n```\n\n **17**. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。\n\n```java\n \tprivate boolean isEligible(final int age){...}\n```\n\n **18**. 把多个if语句组合成单一if语句。比如：\n\n```java\n\tif(age > 18){\n\t\tif(!man){...}\n\t}\n```\n\n应改为：\n\n```java\n\tif(age > 18 && !man){...}\n```\n\n **19**.  尽量不返回null\n\n null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。\n\n **20**. if嵌套不超过三层。\n\n **21**. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)\n\n实现RandomAccess接口的代表类：ArrayList\n未实现RandomAccess接口的代表类：LinkedList\n\n\n\n","source":"_posts/java_Tips.md","raw":"---\nlayout: post\ntitle: \"java编程技巧\"\ncategories: 编程\ntags: \n- java\ndate:   2016-7-24 12:48:55\n---\n\n>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~\n\n **1**. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层\n\n **2**. if语句中,判断条件尽量不要使用if(!...)的形式，这样只会使代码更加难以理解\n\n **3**. 循环内不要不断创建对象引用，而应该：\n\n```java\n     Object obj = null;\n     for (int i = 0; i <= count; i++) { \n      obj = new Object(); \n     }\n```\n\n **4**. 不要在循环条件中重复计算变量，比如：\n\n```java\n    for (int i = 0; i <= obj.size(); i++){...}\n```\n\n **5**. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字\n\n **6**. 尽量采用懒加载的策略，即在需要的时候才创建,例如：\n\n```java\n    String str = \"aaa\";\n    if (i == 1) { \n       list.add(str);\n    }\n```\n\n建议替换为：\n\n```java\n\n\tif (i == 1) { \n     String str = \"aaa\"; list.add(str);\n   }\n```\n\n\n **7**. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码\n\n **8**. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能\n\n **9**. 使用&& ,\\|\\| 操作符时，将首先需要满足的条件置于操作符之前。因为&& 和 \\|\\| 具有短路性。另外，体会if(e. key==k\\|\\|k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用\\|\\|将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）\n\n **10**. 尽量用for each语句代替for循环\n\n **11**. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。\n\n **12**. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。\n       \n```java\n    if(\"hello\".equals(variable)){...}\n```\n\n **13**. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：\n\n```java\n    if(string.indexof(character) != -1){...}`\n```\n\n应改为：\n\n```java\n    if(string.indexof(character) >0 ){...}\n```\n\n **14**. 避免意外的赋值，比如：\n \n```java\n    if(variable == 5){...}`\n```\n\n应改为：\n\n```java\n    if(5 == variable){...}\n```\n\n避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出`if(variable = 5)`这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~\n\n **15**. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：\n\n```java\n\tif(array.length > 0){...}\n```\n\n应改为：\n\n```java\n\tif(array != null && array.length > 0){...}\n```\n\n\n **16**. 确保只有一个退出点。比如：\n\n```java\n    private boolean isEligible(int age){\n\n    \tif(age > 18) {\n\n    \t\treturn true;\n\n    \t} else {\n\n            return false;\n    \t}\n\n    }\n```\n\n应改为：\n\n```java\n    private boolean isEligible(int age){\n    \tboolean result;\n\n    \tif(age > 18) {\n\n    \t\tresult = true;\n\n    \t} else {\n\n            result = false;\n    \t}\n\n    \treturn result;\n    }\n```\n\n **17**. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。\n\n```java\n \tprivate boolean isEligible(final int age){...}\n```\n\n **18**. 把多个if语句组合成单一if语句。比如：\n\n```java\n\tif(age > 18){\n\t\tif(!man){...}\n\t}\n```\n\n应改为：\n\n```java\n\tif(age > 18 && !man){...}\n```\n\n **19**.  尽量不返回null\n\n null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。\n\n **20**. if嵌套不超过三层。\n\n **21**. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)\n\n实现RandomAccess接口的代表类：ArrayList\n未实现RandomAccess接口的代表类：LinkedList\n\n\n\n","slug":"java_Tips","published":1,"updated":"2016-08-29T14:02:45.716Z","comments":1,"photos":[],"link":"","_id":"cisx6polz0006zsqcu0mfkk4g","content":"<blockquote>\n<p>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~</p>\n</blockquote>\n<p> <strong>1</strong>. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层</p>\n<p> <strong>2</strong>. if语句中,判断条件尽量不要使用if(!…)的形式，这样只会使代码更加难以理解</p>\n<p> <strong>3</strong>. 循环内不要不断创建对象引用，而应该：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= count; i++) &#123; </div><div class=\"line\"> obj = <span class=\"keyword\">new</span> Object(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>4</strong>. 不要在循环条件中重复计算变量，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= obj.size(); i++)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>5</strong>. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字</p>\n<p> <strong>6</strong>. 尽量采用懒加载的策略，即在需要的时候才创建,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str = <span class=\"string\">\"aaa\"</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">   list.add(str);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>建议替换为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">    String str = <span class=\"string\">\"aaa\"</span>; list.add(str);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p> <strong>7</strong>. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码</p>\n<p> <strong>8</strong>. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能</p>\n<p> <strong>9</strong>. 使用&amp;&amp; ,|| 操作符时，将首先需要满足的条件置于操作符之前。因为&amp;&amp; 和 || 具有短路性。另外，体会if(e. key==k||k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用||将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）</p>\n<p> <strong>10</strong>. 尽量用for each语句代替for循环</p>\n<p> <strong>11</strong>. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。</p>\n<p> <strong>12</strong>. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">\"hello\"</span>.equals(variable))&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>13</strong>. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) != -<span class=\"number\">1</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) &gt;<span class=\"number\">0</span> )&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>14</strong>. 避免意外的赋值，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(variable == <span class=\"number\">5</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">5</span> == variable)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出<code>if(variable = 5)</code>这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~</p>\n<p> <strong>15</strong>. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array != <span class=\"keyword\">null</span> &amp;&amp; array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>16</strong>. 确保只有一个退出点。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">boolean</span> result;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tresult = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        result = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>17</strong>. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>18</strong>. 把多个if语句组合成单一if语句。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>)&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(!man)&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span> &amp;&amp; !man)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>19</strong>.  尽量不返回null</p>\n<p> null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。</p>\n<p> <strong>20</strong>. if嵌套不超过三层。</p>\n<p> <strong>21</strong>. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)</p>\n<p>实现RandomAccess接口的代表类：ArrayList<br>未实现RandomAccess接口的代表类：LinkedList</p>\n","excerpt":"","more":"<blockquote>\n<p>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~</p>\n</blockquote>\n<p> <strong>1</strong>. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层</p>\n<p> <strong>2</strong>. if语句中,判断条件尽量不要使用if(!…)的形式，这样只会使代码更加难以理解</p>\n<p> <strong>3</strong>. 循环内不要不断创建对象引用，而应该：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= count; i++) &#123; </div><div class=\"line\"> obj = <span class=\"keyword\">new</span> Object(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>4</strong>. 不要在循环条件中重复计算变量，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= obj.size(); i++)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>5</strong>. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字</p>\n<p> <strong>6</strong>. 尽量采用懒加载的策略，即在需要的时候才创建,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str = <span class=\"string\">\"aaa\"</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">   list.add(str);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>建议替换为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">    String str = <span class=\"string\">\"aaa\"</span>; list.add(str);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p> <strong>7</strong>. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码</p>\n<p> <strong>8</strong>. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能</p>\n<p> <strong>9</strong>. 使用&amp;&amp; ,|| 操作符时，将首先需要满足的条件置于操作符之前。因为&amp;&amp; 和 || 具有短路性。另外，体会if(e. key==k||k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用||将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）</p>\n<p> <strong>10</strong>. 尽量用for each语句代替for循环</p>\n<p> <strong>11</strong>. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。</p>\n<p> <strong>12</strong>. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">\"hello\"</span>.equals(variable))&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>13</strong>. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) != -<span class=\"number\">1</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) &gt;<span class=\"number\">0</span> )&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>14</strong>. 避免意外的赋值，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(variable == <span class=\"number\">5</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">5</span> == variable)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出<code>if(variable = 5)</code>这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~</p>\n<p> <strong>15</strong>. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array != <span class=\"keyword\">null</span> &amp;&amp; array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>16</strong>. 确保只有一个退出点。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">boolean</span> result;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tresult = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        result = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>17</strong>. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>18</strong>. 把多个if语句组合成单一if语句。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>)&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(!man)&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span> &amp;&amp; !man)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>19</strong>.  尽量不返回null</p>\n<p> null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。</p>\n<p> <strong>20</strong>. if嵌套不超过三层。</p>\n<p> <strong>21</strong>. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)</p>\n<p>实现RandomAccess接口的代表类：ArrayList<br>未实现RandomAccess接口的代表类：LinkedList</p>\n"},{"layout":"post","title":"java中的ThreadLocal","date":"2016-06-21T04:48:55.000Z","_content":"\n> 今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal...\n\n## **问题背景**：\n\n每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：\n\n```java\nLsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());\n```\n\n其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。\n\n遂改之：\n\n```java\nLsnVo lv = ((DispatchConnection) conn).getLsnVo();\n```\n\n将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。\n\n曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。\n\n后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！\n\nPS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29\n\nso,按照上面的改法问题解决了。\n\n那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。\n\n这就是ThreadLocal的一个典型应用场景。\n\n## **ThreadLocal原理**：\n\n使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。\n\nThreadLocal的set和get方法：\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n}\n\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            return (T)map.get(this);\n\n        // Maps are constructed lazily.  if the map for this thread\n        // doesn't exist, create it, with this ThreadLocal and its\n        // initial value as its only entry.\n        T value = initialValue();\n        createMap(t, value);\n        return value;\n}\n```\n\n可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。\n\n很容易明白他的工作原理。\n\n## **应用场景**\n\n之前看了网上很多资料说ThreadLocal的应用场景：\n\n1.解决了多线程共享对象的问题，\n\n2.实现线程间的数据隔离，每个线程都有他自己的变量副本。\n\n对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。\n\n对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。\n\n我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：\n\n1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。\n\n2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。\n\n所以，使用ThreadLocal的场景应该是这样：**这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。**\n\nPS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。\n\n另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。\n\n我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。\n","source":"_posts/java中的ThreadLocal.md","raw":"---\nlayout: post\ntitle:  \"java中的ThreadLocal\"\ncategories: 编程\ntags: \n- java\n- 多线程\ndate:   2016-06-21 12:48:55\n---\n\n> 今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal...\n\n## **问题背景**：\n\n每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：\n\n```java\nLsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());\n```\n\n其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。\n\n遂改之：\n\n```java\nLsnVo lv = ((DispatchConnection) conn).getLsnVo();\n```\n\n将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。\n\n曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。\n\n后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！\n\nPS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29\n\nso,按照上面的改法问题解决了。\n\n那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。\n\n这就是ThreadLocal的一个典型应用场景。\n\n## **ThreadLocal原理**：\n\n使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。\n\nThreadLocal的set和get方法：\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n}\n\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            return (T)map.get(this);\n\n        // Maps are constructed lazily.  if the map for this thread\n        // doesn't exist, create it, with this ThreadLocal and its\n        // initial value as its only entry.\n        T value = initialValue();\n        createMap(t, value);\n        return value;\n}\n```\n\n可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。\n\n很容易明白他的工作原理。\n\n## **应用场景**\n\n之前看了网上很多资料说ThreadLocal的应用场景：\n\n1.解决了多线程共享对象的问题，\n\n2.实现线程间的数据隔离，每个线程都有他自己的变量副本。\n\n对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。\n\n对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。\n\n我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：\n\n1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。\n\n2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。\n\n所以，使用ThreadLocal的场景应该是这样：**这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。**\n\nPS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。\n\n另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。\n\n我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。\n","slug":"java中的ThreadLocal","published":1,"updated":"2016-08-14T08:26:27.877Z","comments":1,"photos":[],"link":"","_id":"cisx6polz0008zsqcqetm2k5f","content":"<blockquote>\n<p>今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal…</p>\n</blockquote>\n<h2 id=\"问题背景：\"><a href=\"#问题背景：\" class=\"headerlink\" title=\"问题背景：\"></a><strong>问题背景</strong>：</h2><p>每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());</div></pre></td></tr></table></figure>\n<p>其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。</p>\n<p>遂改之：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((DispatchConnection) conn).getLsnVo();</div></pre></td></tr></table></figure>\n<p>将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。</p>\n<p>曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。</p>\n<p>后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！</p>\n<p>PS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29</p>\n<p>so,按照上面的改法问题解决了。</p>\n<p>那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。</p>\n<p>这就是ThreadLocal的一个典型应用场景。</p>\n<h2 id=\"ThreadLocal原理：\"><a href=\"#ThreadLocal原理：\" class=\"headerlink\" title=\"ThreadLocal原理：\"></a><strong>ThreadLocal原理</strong>：</h2><p>使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。</p>\n<p>ThreadLocal的set和get方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> (T)map.get(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Maps are constructed lazily.  if the map for this thread</span></div><div class=\"line\">        <span class=\"comment\">// doesn't exist, create it, with this ThreadLocal and its</span></div><div class=\"line\">        <span class=\"comment\">// initial value as its only entry.</span></div><div class=\"line\">        T value = initialValue();</div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。</p>\n<p>很容易明白他的工作原理。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h2><p>之前看了网上很多资料说ThreadLocal的应用场景：</p>\n<p>1.解决了多线程共享对象的问题，</p>\n<p>2.实现线程间的数据隔离，每个线程都有他自己的变量副本。</p>\n<p>对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。</p>\n<p>对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。</p>\n<p>我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：</p>\n<p>1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。</p>\n<p>2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。</p>\n<p>所以，使用ThreadLocal的场景应该是这样：<strong>这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。</strong></p>\n<p>PS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。</p>\n<p>另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。</p>\n<p>我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。</p>\n","excerpt":"","more":"<blockquote>\n<p>今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal…</p>\n</blockquote>\n<h2 id=\"问题背景：\"><a href=\"#问题背景：\" class=\"headerlink\" title=\"问题背景：\"></a><strong>问题背景</strong>：</h2><p>每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());</div></pre></td></tr></table></figure>\n<p>其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。</p>\n<p>遂改之：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((DispatchConnection) conn).getLsnVo();</div></pre></td></tr></table></figure>\n<p>将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。</p>\n<p>曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。</p>\n<p>后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！</p>\n<p>PS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29</p>\n<p>so,按照上面的改法问题解决了。</p>\n<p>那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。</p>\n<p>这就是ThreadLocal的一个典型应用场景。</p>\n<h2 id=\"ThreadLocal原理：\"><a href=\"#ThreadLocal原理：\" class=\"headerlink\" title=\"ThreadLocal原理：\"></a><strong>ThreadLocal原理</strong>：</h2><p>使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。</p>\n<p>ThreadLocal的set和get方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> (T)map.get(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Maps are constructed lazily.  if the map for this thread</span></div><div class=\"line\">        <span class=\"comment\">// doesn't exist, create it, with this ThreadLocal and its</span></div><div class=\"line\">        <span class=\"comment\">// initial value as its only entry.</span></div><div class=\"line\">        T value = initialValue();</div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。</p>\n<p>很容易明白他的工作原理。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h2><p>之前看了网上很多资料说ThreadLocal的应用场景：</p>\n<p>1.解决了多线程共享对象的问题，</p>\n<p>2.实现线程间的数据隔离，每个线程都有他自己的变量副本。</p>\n<p>对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。</p>\n<p>对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。</p>\n<p>我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：</p>\n<p>1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。</p>\n<p>2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。</p>\n<p>所以，使用ThreadLocal的场景应该是这样：<strong>这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。</strong></p>\n<p>PS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。</p>\n<p>另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。</p>\n<p>我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。</p>\n"},{"layout":"post","title":"java中的equals与hashcode","date":"2016-04-28T04:48:55.000Z","_content":"\n>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。\n\n## 什么是hashcode,hashcode的作用是什么\n\nhashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。\n\n理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，也就是记录所在的位置。\n\n按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。\n\nhashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。\n\n注：以下代码均来自jdk1.7\n\nString中hashCode()方法的实现：\n\n```java\npublic int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            char val[] = value;\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n}\n```\n\n## 什么是equals(Object obj)方法\n\nequals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：\n\n```java\npublic boolean equals(Object obj) {\n        return (this == obj);\n}\n```\n\n也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。\n\n这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。\n\nString中equals(Object obj)方法的实现：\n\n```java\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String) anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                            return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n}\n```\n\n## 在java中hashcode方法与equals方法的作用\n\n首先看一下HashMap中的put方法：\n\n```java\npublic V put(K key, V value) {\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n        if (key == null)\n            return putForNullKey(value);\n        int hash = hash(key);//得到hash值\n        int i = indexFor(hash, table.length);//找到槽\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n\n        modCount++;\n        addEntry(hash, key, value, i);\n        return null;\n    }\n\n```\n\n我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。\n\n首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：\n\n```java\nfinal int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n可以看到，这个方法里调用了key本身的hashCode方法，得到了他的hashcode，然后对该hashcode进行了一些操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，他指向了记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？其实这跟记录在散列表中的存放方式有关系(HashMap底层存储就是一个散列表数组),有兴趣可以看看[这个](https://www.zhihu.com/question/20733617)\n\n接下来，int i = indexFor(hash, table.length);找到所谓的槽，也就是记录存在的位置。\n\n要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。\n\n散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？反过来说，能否给出一个散列函数，其可以保证对于所有调用它的对象都可以返回一个唯一的hashcode？恐怕这是很难做到的吧。此时就会产生冲突。从另一个角度来讲，我们的散列表长度是有限的，有用这有限的空间存储更多的记录，势必会产生冲突。这也是我们理解hashcode的一个重要的点：**不同的对象(equals返回false)可以有相同的hashcode**。\n\n那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：\n\n{% asset_img entry.png 冲突 %}\n\n其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3....为散列表的索引位置。\n\n接下来的代码  `for (Entry<K,V> e = table[i]; e != null; e = e.next)`就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：`addEntry(hash, key, value, i);`.\n\n那么，怎么判断两个关键码在逻辑上是否相同呢？\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`\n\n可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：e.hash == hash 。为什么要加这样的判断我们之前也提到了，那就是冲突造成同一个槽里有不同的对象存在，这些对象的hashcode可能相同，也可能不同(hashcode经过取模运算散列到同一个位置)。我们知道**不同的对象(equals返回false)可以有相同的hashcode**。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：**相同的对象(equals返回true)hashcode一定相等**。\n\n`e.hash == hash && ((k = e.key) == key`这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断**关键码是否相等**，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。\n\n`key.equals(k)`：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`这句代码中其实包含了一种短路思想，\\|\\| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。\n\n至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。\n\n## 总结\n\n通过上面的分析，我们知道了hashcode与equals的几个关键：\n\n#### 1.**不同的对象(equals返回false)可以有相同的hashcode**\n\n#### 2.**相同的对象(equals返回true)hashcode一定相等**\n\n#### 3.**若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义**（对1、2的遵守）\n\n[关于如何重写equals方法与hashCode方法](http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java)\n\n## equals与==\n\n\"==\" 比较的是两个对象的内存地址，是物理意义上的相等\n\nequals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等\n\n两个对象进行比较：\n\n**== 返回true，则equals一定返回true**；\n\n**equals返回true，== 不一定返回true**。\n\n\n\n\n\n\n\n","source":"_posts/java中的equals与hashcode.md","raw":"---\nlayout: post\ntitle:  \"java中的equals与hashcode\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-28 12:48:55\n---\n\n>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。\n\n## 什么是hashcode,hashcode的作用是什么\n\nhashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。\n\n理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，也就是记录所在的位置。\n\n按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。\n\nhashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。\n\n注：以下代码均来自jdk1.7\n\nString中hashCode()方法的实现：\n\n```java\npublic int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            char val[] = value;\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n}\n```\n\n## 什么是equals(Object obj)方法\n\nequals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：\n\n```java\npublic boolean equals(Object obj) {\n        return (this == obj);\n}\n```\n\n也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。\n\n这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。\n\nString中equals(Object obj)方法的实现：\n\n```java\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String) anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                            return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n}\n```\n\n## 在java中hashcode方法与equals方法的作用\n\n首先看一下HashMap中的put方法：\n\n```java\npublic V put(K key, V value) {\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n        if (key == null)\n            return putForNullKey(value);\n        int hash = hash(key);//得到hash值\n        int i = indexFor(hash, table.length);//找到槽\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n\n        modCount++;\n        addEntry(hash, key, value, i);\n        return null;\n    }\n\n```\n\n我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。\n\n首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：\n\n```java\nfinal int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n可以看到，这个方法里调用了key本身的hashCode方法，得到了他的hashcode，然后对该hashcode进行了一些操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，他指向了记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？其实这跟记录在散列表中的存放方式有关系(HashMap底层存储就是一个散列表数组),有兴趣可以看看[这个](https://www.zhihu.com/question/20733617)\n\n接下来，int i = indexFor(hash, table.length);找到所谓的槽，也就是记录存在的位置。\n\n要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。\n\n散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？反过来说，能否给出一个散列函数，其可以保证对于所有调用它的对象都可以返回一个唯一的hashcode？恐怕这是很难做到的吧。此时就会产生冲突。从另一个角度来讲，我们的散列表长度是有限的，有用这有限的空间存储更多的记录，势必会产生冲突。这也是我们理解hashcode的一个重要的点：**不同的对象(equals返回false)可以有相同的hashcode**。\n\n那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：\n\n{% asset_img entry.png 冲突 %}\n\n其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3....为散列表的索引位置。\n\n接下来的代码  `for (Entry<K,V> e = table[i]; e != null; e = e.next)`就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：`addEntry(hash, key, value, i);`.\n\n那么，怎么判断两个关键码在逻辑上是否相同呢？\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`\n\n可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：e.hash == hash 。为什么要加这样的判断我们之前也提到了，那就是冲突造成同一个槽里有不同的对象存在，这些对象的hashcode可能相同，也可能不同(hashcode经过取模运算散列到同一个位置)。我们知道**不同的对象(equals返回false)可以有相同的hashcode**。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：**相同的对象(equals返回true)hashcode一定相等**。\n\n`e.hash == hash && ((k = e.key) == key`这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断**关键码是否相等**，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。\n\n`key.equals(k)`：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`这句代码中其实包含了一种短路思想，\\|\\| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。\n\n至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。\n\n## 总结\n\n通过上面的分析，我们知道了hashcode与equals的几个关键：\n\n#### 1.**不同的对象(equals返回false)可以有相同的hashcode**\n\n#### 2.**相同的对象(equals返回true)hashcode一定相等**\n\n#### 3.**若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义**（对1、2的遵守）\n\n[关于如何重写equals方法与hashCode方法](http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java)\n\n## equals与==\n\n\"==\" 比较的是两个对象的内存地址，是物理意义上的相等\n\nequals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等\n\n两个对象进行比较：\n\n**== 返回true，则equals一定返回true**；\n\n**equals返回true，== 不一定返回true**。\n\n\n\n\n\n\n\n","slug":"java中的equals与hashcode","published":1,"updated":"2016-08-23T00:09:51.223Z","comments":1,"photos":[],"link":"","_id":"cisx6pomf000bzsqc5ualr40q","content":"<blockquote>\n<p>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。</p>\n</blockquote>\n<h2 id=\"什么是hashcode-hashcode的作用是什么\"><a href=\"#什么是hashcode-hashcode的作用是什么\" class=\"headerlink\" title=\"什么是hashcode,hashcode的作用是什么\"></a>什么是hashcode,hashcode的作用是什么</h2><p>hashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。</p>\n<p>理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，也就是记录所在的位置。</p>\n<p>按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。</p>\n<p>hashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。</p>\n<p>注：以下代码均来自jdk1.7</p>\n<p>String中hashCode()方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hash;</div><div class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">char</span> val[] = value;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</div><div class=\"line\">                h = <span class=\"number\">31</span> * h + val[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            hash = h;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> h;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"什么是equals-Object-obj-方法\"><a href=\"#什么是equals-Object-obj-方法\" class=\"headerlink\" title=\"什么是equals(Object obj)方法\"></a>什么是equals(Object obj)方法</h2><p>equals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。</p>\n<p>这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。</p>\n<p>String中equals(Object obj)方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            String anotherString = (String) anObject;</div><div class=\"line\">            <span class=\"keyword\">int</span> n = value.length;</div><div class=\"line\">            <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> v1[] = value;</div><div class=\"line\">                <span class=\"keyword\">char</span> v2[] = anotherString.value;</div><div class=\"line\">                <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (v1[i] != v2[i])</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                    i++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"在java中hashcode方法与equals方法的作用\"><a href=\"#在java中hashcode方法与equals方法的作用\" class=\"headerlink\" title=\"在java中hashcode方法与equals方法的作用\"></a>在java中hashcode方法与equals方法的作用</h2><p>首先看一下HashMap中的put方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</div><div class=\"line\">            inflateTable(threshold);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> putForNullKey(value);</div><div class=\"line\">        <span class=\"keyword\">int</span> hash = hash(key);<span class=\"comment\">//得到hash值</span></div><div class=\"line\">        <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//找到槽</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\">            Object k;</div><div class=\"line\">            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class=\"line\">                V oldValue = e.value;</div><div class=\"line\">                e.value = value;</div><div class=\"line\">                e.recordAccess(<span class=\"keyword\">this</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        modCount++;</div><div class=\"line\">        addEntry(hash, key, value, i);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。</p>\n<p>首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hashSeed;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != h &amp;&amp; k <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        h ^= k.hashCode();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></div><div class=\"line\">        <span class=\"comment\">// constant multiples at each bit position have a bounded</span></div><div class=\"line\">        <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></div><div class=\"line\">        h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这个方法里调用了key本身的hashCode方法，得到了他的hashcode，然后对该hashcode进行了一些操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，他指向了记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？其实这跟记录在散列表中的存放方式有关系(HashMap底层存储就是一个散列表数组),有兴趣可以看看<a href=\"https://www.zhihu.com/question/20733617\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>接下来，int i = indexFor(hash, table.length);找到所谓的槽，也就是记录存在的位置。</p>\n<p>要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。</p>\n<p>散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？反过来说，能否给出一个散列函数，其可以保证对于所有调用它的对象都可以返回一个唯一的hashcode？恐怕这是很难做到的吧。此时就会产生冲突。从另一个角度来讲，我们的散列表长度是有限的，有用这有限的空间存储更多的记录，势必会产生冲突。这也是我们理解hashcode的一个重要的点：<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。</p>\n<p>那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：</p>\n<img src=\"/2016/04/28/java中的equals与hashcode/entry.png\" alt=\"冲突\" title=\"冲突\">\n<p>其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3….为散列表的索引位置。</p>\n<p>接下来的代码  <code>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next)</code>就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：<code>addEntry(hash, key, value, i);</code>.</p>\n<p>那么，怎么判断两个关键码在逻辑上是否相同呢？</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code></p>\n<p>可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：e.hash == hash 。为什么要加这样的判断我们之前也提到了，那就是冲突造成同一个槽里有不同的对象存在，这些对象的hashcode可能相同，也可能不同(hashcode经过取模运算散列到同一个位置)。我们知道<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：<strong>相同的对象(equals返回true)hashcode一定相等</strong>。</p>\n<p><code>e.hash == hash &amp;&amp; ((k = e.key) == key</code>这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断<strong>关键码是否相等</strong>，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。</p>\n<p><code>key.equals(k)</code>：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>这句代码中其实包含了一种短路思想，|| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。</p>\n<p>至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面的分析，我们知道了hashcode与equals的几个关键：</p>\n<h4 id=\"1-不同的对象-equals返回false-可以有相同的hashcode\"><a href=\"#1-不同的对象-equals返回false-可以有相同的hashcode\" class=\"headerlink\" title=\"1.不同的对象(equals返回false)可以有相同的hashcode\"></a>1.<strong>不同的对象(equals返回false)可以有相同的hashcode</strong></h4><h4 id=\"2-相同的对象-equals返回true-hashcode一定相等\"><a href=\"#2-相同的对象-equals返回true-hashcode一定相等\" class=\"headerlink\" title=\"2.相同的对象(equals返回true)hashcode一定相等\"></a>2.<strong>相同的对象(equals返回true)hashcode一定相等</strong></h4><h4 id=\"3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"><a href=\"#3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\" class=\"headerlink\" title=\"3.若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"></a>3.<strong>若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义</strong>（对1、2的遵守）</h4><p><a href=\"http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java\" target=\"_blank\" rel=\"external\">关于如何重写equals方法与hashCode方法</a></p>\n<h2 id=\"equals与\"><a href=\"#equals与\" class=\"headerlink\" title=\"equals与==\"></a>equals与==</h2><p>“==” 比较的是两个对象的内存地址，是物理意义上的相等</p>\n<p>equals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等</p>\n<p>两个对象进行比较：</p>\n<p><strong>== 返回true，则equals一定返回true</strong>；</p>\n<p><strong>equals返回true，== 不一定返回true</strong>。</p>\n","excerpt":"","more":"<blockquote>\n<p>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。</p>\n</blockquote>\n<h2 id=\"什么是hashcode-hashcode的作用是什么\"><a href=\"#什么是hashcode-hashcode的作用是什么\" class=\"headerlink\" title=\"什么是hashcode,hashcode的作用是什么\"></a>什么是hashcode,hashcode的作用是什么</h2><p>hashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。</p>\n<p>理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，也就是记录所在的位置。</p>\n<p>按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。</p>\n<p>hashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。</p>\n<p>注：以下代码均来自jdk1.7</p>\n<p>String中hashCode()方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hash;</div><div class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">char</span> val[] = value;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</div><div class=\"line\">                h = <span class=\"number\">31</span> * h + val[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            hash = h;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> h;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"什么是equals-Object-obj-方法\"><a href=\"#什么是equals-Object-obj-方法\" class=\"headerlink\" title=\"什么是equals(Object obj)方法\"></a>什么是equals(Object obj)方法</h2><p>equals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。</p>\n<p>这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。</p>\n<p>String中equals(Object obj)方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            String anotherString = (String) anObject;</div><div class=\"line\">            <span class=\"keyword\">int</span> n = value.length;</div><div class=\"line\">            <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> v1[] = value;</div><div class=\"line\">                <span class=\"keyword\">char</span> v2[] = anotherString.value;</div><div class=\"line\">                <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (v1[i] != v2[i])</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                    i++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"在java中hashcode方法与equals方法的作用\"><a href=\"#在java中hashcode方法与equals方法的作用\" class=\"headerlink\" title=\"在java中hashcode方法与equals方法的作用\"></a>在java中hashcode方法与equals方法的作用</h2><p>首先看一下HashMap中的put方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</div><div class=\"line\">            inflateTable(threshold);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> putForNullKey(value);</div><div class=\"line\">        <span class=\"keyword\">int</span> hash = hash(key);<span class=\"comment\">//得到hash值</span></div><div class=\"line\">        <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//找到槽</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\">            Object k;</div><div class=\"line\">            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class=\"line\">                V oldValue = e.value;</div><div class=\"line\">                e.value = value;</div><div class=\"line\">                e.recordAccess(<span class=\"keyword\">this</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        modCount++;</div><div class=\"line\">        addEntry(hash, key, value, i);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。</p>\n<p>首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hashSeed;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != h &amp;&amp; k <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        h ^= k.hashCode();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></div><div class=\"line\">        <span class=\"comment\">// constant multiples at each bit position have a bounded</span></div><div class=\"line\">        <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></div><div class=\"line\">        h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这个方法里调用了key本身的hashCode方法，得到了他的hashcode，然后对该hashcode进行了一些操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，他指向了记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？其实这跟记录在散列表中的存放方式有关系(HashMap底层存储就是一个散列表数组),有兴趣可以看看<a href=\"https://www.zhihu.com/question/20733617\">这个</a></p>\n<p>接下来，int i = indexFor(hash, table.length);找到所谓的槽，也就是记录存在的位置。</p>\n<p>要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。</p>\n<p>散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？反过来说，能否给出一个散列函数，其可以保证对于所有调用它的对象都可以返回一个唯一的hashcode？恐怕这是很难做到的吧。此时就会产生冲突。从另一个角度来讲，我们的散列表长度是有限的，有用这有限的空间存储更多的记录，势必会产生冲突。这也是我们理解hashcode的一个重要的点：<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。</p>\n<p>那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：</p>\n<img src=\"/2016/04/28/java中的equals与hashcode/entry.png\" alt=\"冲突\" title=\"冲突\">\n<p>其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3….为散列表的索引位置。</p>\n<p>接下来的代码  <code>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next)</code>就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：<code>addEntry(hash, key, value, i);</code>.</p>\n<p>那么，怎么判断两个关键码在逻辑上是否相同呢？</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code></p>\n<p>可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：e.hash == hash 。为什么要加这样的判断我们之前也提到了，那就是冲突造成同一个槽里有不同的对象存在，这些对象的hashcode可能相同，也可能不同(hashcode经过取模运算散列到同一个位置)。我们知道<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：<strong>相同的对象(equals返回true)hashcode一定相等</strong>。</p>\n<p><code>e.hash == hash &amp;&amp; ((k = e.key) == key</code>这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断<strong>关键码是否相等</strong>，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。</p>\n<p><code>key.equals(k)</code>：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>这句代码中其实包含了一种短路思想，|| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。</p>\n<p>至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面的分析，我们知道了hashcode与equals的几个关键：</p>\n<h4 id=\"1-不同的对象-equals返回false-可以有相同的hashcode\"><a href=\"#1-不同的对象-equals返回false-可以有相同的hashcode\" class=\"headerlink\" title=\"1.不同的对象(equals返回false)可以有相同的hashcode\"></a>1.<strong>不同的对象(equals返回false)可以有相同的hashcode</strong></h4><h4 id=\"2-相同的对象-equals返回true-hashcode一定相等\"><a href=\"#2-相同的对象-equals返回true-hashcode一定相等\" class=\"headerlink\" title=\"2.相同的对象(equals返回true)hashcode一定相等\"></a>2.<strong>相同的对象(equals返回true)hashcode一定相等</strong></h4><h4 id=\"3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"><a href=\"#3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\" class=\"headerlink\" title=\"3.若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"></a>3.<strong>若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义</strong>（对1、2的遵守）</h4><p><a href=\"http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java\">关于如何重写equals方法与hashCode方法</a></p>\n<h2 id=\"equals与\"><a href=\"#equals与\" class=\"headerlink\" title=\"equals与==\"></a>equals与==</h2><p>“==” 比较的是两个对象的内存地址，是物理意义上的相等</p>\n<p>equals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等</p>\n<p>两个对象进行比较：</p>\n<p><strong>== 返回true，则equals一定返回true</strong>；</p>\n<p><strong>equals返回true，== 不一定返回true</strong>。</p>\n"},{"layout":"post","title":"java中的枚举","date":"2016-06-30T04:48:55.000Z","_content":"\n> 已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。\n\nJava中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。\n  \n## 使用场景：\n\n每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。\n\n## 与 public static final 的常量定义方式进行比较：\n\n在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：\n\n```java\npublic class State {\n\tpublic static final int Normal = 0;//正常\n\tpublic static final int Update = 1;//已更新\n\tpublic static final int Delete = 2;//已删除\n}\n```\n\n使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：\n\n```java\npublic void doSomething(int state){\n\tswitch(state){\n\t\tcase State.Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Update:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n1. 在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。\n\n2. 另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。\n\n3. 因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。\n\n那如果换成枚举常量呢？\n\n```java\npublic enum State {\n\tNormal,Update,Delete\n}\n```\n\n类型安全检查：\n\n```java\npublic void doSomething(State state){\n\tswitch(state){\n\t\tcase Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase Update:\n\t\t  ...\n\t\t  break;\n\t\tcase Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。\n\n另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。\n\n## 枚举类型的使用\n\n- **常量**：\n\n```java\npublic enum State{\n\tNormal,Update,Delete\n}\n```\n\n遍历枚举常量：\n\n```java\n   for(State state:State.values()){\n   \t\tSystem.out.println(state);\n   }\n```\n\n- **自定义属性、方法**：\n\n```java\npublic enum State{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }    \n}\n\npublic void test(){\n\tfor (State state : State.values()) {\n\t    //输出：正常:0 已更新:1 已删除:2\n\t\tSystem.out.println(state);\n\t}\n}\n```\n\n实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。\n其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。\n\n因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。\n\n- **实现接口**\n\n```java\npublic interface HandleState{\n\tvoid printState();\n}\n\npublic enum State implements HandleState{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }  \n\n    public void printState() {\n\t\tSystem.out.println(this);\n\t}\n}\n```\n\n可以看到，枚举和一般的类一样都可以实现接口。\n\n- **Enum 相关工具类**\n\nJDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。\n\n## 参考\n\n[java enum的用法详解[转]](https://hacpai.com/article/1437056657634)\n\n[Java 语言中Enum类型的使用介绍](https://www.ibm.com/developerworks/cn/java/j-lo-enum/)","source":"_posts/java中的枚举.md","raw":"---\nlayout: post\ntitle:  \"java中的枚举\"\ncategories: 编程\ntags: \n- java\ndate:   2016-06-30 12:48:55\n---\n\n> 已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。\n\nJava中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。\n  \n## 使用场景：\n\n每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。\n\n## 与 public static final 的常量定义方式进行比较：\n\n在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：\n\n```java\npublic class State {\n\tpublic static final int Normal = 0;//正常\n\tpublic static final int Update = 1;//已更新\n\tpublic static final int Delete = 2;//已删除\n}\n```\n\n使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：\n\n```java\npublic void doSomething(int state){\n\tswitch(state){\n\t\tcase State.Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Update:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n1. 在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。\n\n2. 另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。\n\n3. 因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。\n\n那如果换成枚举常量呢？\n\n```java\npublic enum State {\n\tNormal,Update,Delete\n}\n```\n\n类型安全检查：\n\n```java\npublic void doSomething(State state){\n\tswitch(state){\n\t\tcase Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase Update:\n\t\t  ...\n\t\t  break;\n\t\tcase Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。\n\n另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。\n\n## 枚举类型的使用\n\n- **常量**：\n\n```java\npublic enum State{\n\tNormal,Update,Delete\n}\n```\n\n遍历枚举常量：\n\n```java\n   for(State state:State.values()){\n   \t\tSystem.out.println(state);\n   }\n```\n\n- **自定义属性、方法**：\n\n```java\npublic enum State{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }    \n}\n\npublic void test(){\n\tfor (State state : State.values()) {\n\t    //输出：正常:0 已更新:1 已删除:2\n\t\tSystem.out.println(state);\n\t}\n}\n```\n\n实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。\n其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。\n\n因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。\n\n- **实现接口**\n\n```java\npublic interface HandleState{\n\tvoid printState();\n}\n\npublic enum State implements HandleState{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }  \n\n    public void printState() {\n\t\tSystem.out.println(this);\n\t}\n}\n```\n\n可以看到，枚举和一般的类一样都可以实现接口。\n\n- **Enum 相关工具类**\n\nJDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。\n\n## 参考\n\n[java enum的用法详解[转]](https://hacpai.com/article/1437056657634)\n\n[Java 语言中Enum类型的使用介绍](https://www.ibm.com/developerworks/cn/java/j-lo-enum/)","slug":"java中的枚举","published":1,"updated":"2016-08-14T13:10:10.126Z","comments":1,"photos":[],"link":"","_id":"cisx6pomu000dzsqc4epcu70d","content":"<blockquote>\n<p>已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。</p>\n</blockquote>\n<p>Java中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。</p>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><p>每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。</p>\n<h2 id=\"与-public-static-final-的常量定义方式进行比较：\"><a href=\"#与-public-static-final-的常量定义方式进行比较：\" class=\"headerlink\" title=\"与 public static final 的常量定义方式进行比较：\"></a>与 public static final 的常量定义方式进行比较：</h2><p>在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">State</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Normal = <span class=\"number\">0</span>;<span class=\"comment\">//正常</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Update = <span class=\"number\">1</span>;<span class=\"comment\">//已更新</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Delete = <span class=\"number\">2</span>;<span class=\"comment\">//已删除</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。</p>\n</li>\n<li><p>另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。</p>\n</li>\n<li><p>因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。</p>\n</li>\n</ol>\n<p>那如果换成枚举常量呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类型安全检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(State state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。</p>\n<p>另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。</p>\n<h2 id=\"枚举类型的使用\"><a href=\"#枚举类型的使用\" class=\"headerlink\" title=\"枚举类型的使用\"></a>枚举类型的使用</h2><ul>\n<li><strong>常量</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遍历枚举常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(State state:State.values())&#123;</div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>自定义属性、方法</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (State state : State.values()) &#123;</div><div class=\"line\">\t    <span class=\"comment\">//输出：正常:0 已更新:1 已删除:2</span></div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。<br>其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(“正常”,0),Update(“已更新”,1),Delete(“已删除”,2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。</p>\n<p>因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。</p>\n<ul>\n<li><strong>实现接口</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandleState</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State implements HandleState&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，枚举和一般的类一样都可以实现接口。</p>\n<ul>\n<li><strong>Enum 相关工具类</strong></li>\n</ul>\n<p>JDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://hacpai.com/article/1437056657634\" target=\"_blank\" rel=\"external\">java enum的用法详解[转]</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-enum/\" target=\"_blank\" rel=\"external\">Java 语言中Enum类型的使用介绍</a></p>\n","excerpt":"","more":"<blockquote>\n<p>已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。</p>\n</blockquote>\n<p>Java中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。</p>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><p>每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。</p>\n<h2 id=\"与-public-static-final-的常量定义方式进行比较：\"><a href=\"#与-public-static-final-的常量定义方式进行比较：\" class=\"headerlink\" title=\"与 public static final 的常量定义方式进行比较：\"></a>与 public static final 的常量定义方式进行比较：</h2><p>在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">State</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Normal = <span class=\"number\">0</span>;<span class=\"comment\">//正常</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Update = <span class=\"number\">1</span>;<span class=\"comment\">//已更新</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Delete = <span class=\"number\">2</span>;<span class=\"comment\">//已删除</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。</p>\n</li>\n<li><p>另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。</p>\n</li>\n<li><p>因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。</p>\n</li>\n</ol>\n<p>那如果换成枚举常量呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类型安全检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(State state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。</p>\n<p>另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。</p>\n<h2 id=\"枚举类型的使用\"><a href=\"#枚举类型的使用\" class=\"headerlink\" title=\"枚举类型的使用\"></a>枚举类型的使用</h2><ul>\n<li><strong>常量</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遍历枚举常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(State state:State.values())&#123;</div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>自定义属性、方法</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (State state : State.values()) &#123;</div><div class=\"line\">\t    <span class=\"comment\">//输出：正常:0 已更新:1 已删除:2</span></div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。<br>其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(“正常”,0),Update(“已更新”,1),Delete(“已删除”,2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。</p>\n<p>因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。</p>\n<ul>\n<li><strong>实现接口</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandleState</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State implements HandleState&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，枚举和一般的类一样都可以实现接口。</p>\n<ul>\n<li><strong>Enum 相关工具类</strong></li>\n</ul>\n<p>JDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://hacpai.com/article/1437056657634\">java enum的用法详解[转]</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-enum/\">Java 语言中Enum类型的使用介绍</a></p>\n"},{"layout":"post","title":"java中的类型转换","date":"2016-04-28T04:48:55.000Z","_content":"\n>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：\n\n## **基本类型**\n\n- **基本类型优先级**\n\n首先来看java中的基本类型有哪些：\n\nbyte：byte数据类型是一个8位有符号二进制补码整数。\n\nshort：short数据类型为16位有符号二进制补码整数。\n\nint：int数据类型是一个32位有符号二进制补码整数\n\nlong: long数据类型是一个64位二进制补码整数\n\nfloat: float数据类型是单精度、32位、符合IEEE 754标准的浮点数\n\nboolean: boolean数据类型只有两个可能的值：true和false\n\ndouble: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；\n\nchar: char数据类型是一个16位的Unicode字符\n\n基本类型优先级由低到高排序：\n\n(byte short char) int long float double\n\n其中，byte short char 平级\n\n- **转换规则**\n\n1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算\n\n3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。\n\n2.byte short char 他们三者在计算时，首先会转换为int类型\n\n3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。\n\n4.boolean不能与其他类型转换\n\n\n## **类类型**\n\n类类型之间的转换有以下几个规则：\n\n1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。\n\n2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。\n\n3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。\n  \n说的比较拗口，用代码来解释吧。\n\n```java\npublic class Test {\n\n    class Father {}\n\t\n    class Son extends Father{}\n\t\n    class Daughter extends Father {}\n\n    @org.junit.Test\n    public void test(){\n        Father fatherApp;\n        Son sonApp;\n        Daughter daughterApp;\n        Father fatherIns=new Father();\n        Son sonIns=new Son();\n        Daughter daughterIns=new Daughter();\n\t\t\n        //目标类型为父类，源类型为子类，自动转换\n        fatherApp=sonIns;   \n        //源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。\n        sonApp=(Son) fatherIns;\n        //源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        \n        sonApp=(Son) fatherApp;\n        //目标类型与源类型不存在父子关系，编译无法通过\n        daughterApp=sonIns;  \n\t\t\n    }\t\n}\n```\n\n\n\n## **参考**\n\n[Java 7之基础类型第1篇 - Java数据类型](http://blog.csdn.net/mazhimazh/article/details/16799925)\n\n[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)\n\n[ Java中的类型转换](http://blog.csdn.net/darxin/article/details/5163043)\n","source":"_posts/java中的类型转换.md","raw":"---\nlayout: post\ntitle:  \"java中的类型转换\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-28 12:48:55\n---\n\n>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：\n\n## **基本类型**\n\n- **基本类型优先级**\n\n首先来看java中的基本类型有哪些：\n\nbyte：byte数据类型是一个8位有符号二进制补码整数。\n\nshort：short数据类型为16位有符号二进制补码整数。\n\nint：int数据类型是一个32位有符号二进制补码整数\n\nlong: long数据类型是一个64位二进制补码整数\n\nfloat: float数据类型是单精度、32位、符合IEEE 754标准的浮点数\n\nboolean: boolean数据类型只有两个可能的值：true和false\n\ndouble: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；\n\nchar: char数据类型是一个16位的Unicode字符\n\n基本类型优先级由低到高排序：\n\n(byte short char) int long float double\n\n其中，byte short char 平级\n\n- **转换规则**\n\n1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算\n\n3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。\n\n2.byte short char 他们三者在计算时，首先会转换为int类型\n\n3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。\n\n4.boolean不能与其他类型转换\n\n\n## **类类型**\n\n类类型之间的转换有以下几个规则：\n\n1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。\n\n2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。\n\n3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。\n  \n说的比较拗口，用代码来解释吧。\n\n```java\npublic class Test {\n\n    class Father {}\n\t\n    class Son extends Father{}\n\t\n    class Daughter extends Father {}\n\n    @org.junit.Test\n    public void test(){\n        Father fatherApp;\n        Son sonApp;\n        Daughter daughterApp;\n        Father fatherIns=new Father();\n        Son sonIns=new Son();\n        Daughter daughterIns=new Daughter();\n\t\t\n        //目标类型为父类，源类型为子类，自动转换\n        fatherApp=sonIns;   \n        //源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。\n        sonApp=(Son) fatherIns;\n        //源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        \n        sonApp=(Son) fatherApp;\n        //目标类型与源类型不存在父子关系，编译无法通过\n        daughterApp=sonIns;  \n\t\t\n    }\t\n}\n```\n\n\n\n## **参考**\n\n[Java 7之基础类型第1篇 - Java数据类型](http://blog.csdn.net/mazhimazh/article/details/16799925)\n\n[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)\n\n[ Java中的类型转换](http://blog.csdn.net/darxin/article/details/5163043)\n","slug":"java中的类型转换","published":1,"updated":"2016-08-14T08:26:27.899Z","comments":1,"photos":[],"link":"","_id":"cisx6pomu000hzsqcvjbfhoxk","content":"<blockquote>\n<p>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：</p>\n</blockquote>\n<h2 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a><strong>基本类型</strong></h2><ul>\n<li><strong>基本类型优先级</strong></li>\n</ul>\n<p>首先来看java中的基本类型有哪些：</p>\n<p>byte：byte数据类型是一个8位有符号二进制补码整数。</p>\n<p>short：short数据类型为16位有符号二进制补码整数。</p>\n<p>int：int数据类型是一个32位有符号二进制补码整数</p>\n<p>long: long数据类型是一个64位二进制补码整数</p>\n<p>float: float数据类型是单精度、32位、符合IEEE 754标准的浮点数</p>\n<p>boolean: boolean数据类型只有两个可能的值：true和false</p>\n<p>double: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</p>\n<p>char: char数据类型是一个16位的Unicode字符</p>\n<p>基本类型优先级由低到高排序：</p>\n<p>(byte short char) int long float double</p>\n<p>其中，byte short char 平级</p>\n<ul>\n<li><strong>转换规则</strong></li>\n</ul>\n<p>1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算</p>\n<p>3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。</p>\n<p>2.byte short char 他们三者在计算时，首先会转换为int类型</p>\n<p>3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。</p>\n<p>4.boolean不能与其他类型转换</p>\n<h2 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a><strong>类类型</strong></h2><p>类类型之间的转换有以下几个规则：</p>\n<p>1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。</p>\n<p>2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。</p>\n<p>3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。</p>\n<p>说的比较拗口，用代码来解释吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@org</span>.junit.<span class=\"function\">Test</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span>&#123;</div><div class=\"line\">        Father fatherApp;</div><div class=\"line\">        Son sonApp;</div><div class=\"line\">        Daughter daughterApp;</div><div class=\"line\">        Father fatherIns=<span class=\"keyword\">new</span> Father();</div><div class=\"line\">        Son sonIns=<span class=\"keyword\">new</span> Son();</div><div class=\"line\">        Daughter daughterIns=<span class=\"keyword\">new</span> Daughter();</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\">//目标类型为父类，源类型为子类，自动转换</span></div><div class=\"line\">        fatherApp=sonIns;   </div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。</span></div><div class=\"line\">        sonApp=(Son) fatherIns;</div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        </span></div><div class=\"line\">        sonApp=(Son) fatherApp;</div><div class=\"line\">        <span class=\"comment\">//目标类型与源类型不存在父子关系，编译无法通过</span></div><div class=\"line\">        daughterApp=sonIns;  </div><div class=\"line\">\t\t</div><div class=\"line\">    &#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://blog.csdn.net/mazhimazh/article/details/16799925\" target=\"_blank\" rel=\"external\">Java 7之基础类型第1篇 - Java数据类型</a></p>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\" target=\"_blank\" rel=\"external\">The Java™ Tutorials</a></p>\n<p><a href=\"http://blog.csdn.net/darxin/article/details/5163043\" target=\"_blank\" rel=\"external\"> Java中的类型转换</a></p>\n","excerpt":"","more":"<blockquote>\n<p>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：</p>\n</blockquote>\n<h2 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a><strong>基本类型</strong></h2><ul>\n<li><strong>基本类型优先级</strong></li>\n</ul>\n<p>首先来看java中的基本类型有哪些：</p>\n<p>byte：byte数据类型是一个8位有符号二进制补码整数。</p>\n<p>short：short数据类型为16位有符号二进制补码整数。</p>\n<p>int：int数据类型是一个32位有符号二进制补码整数</p>\n<p>long: long数据类型是一个64位二进制补码整数</p>\n<p>float: float数据类型是单精度、32位、符合IEEE 754标准的浮点数</p>\n<p>boolean: boolean数据类型只有两个可能的值：true和false</p>\n<p>double: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</p>\n<p>char: char数据类型是一个16位的Unicode字符</p>\n<p>基本类型优先级由低到高排序：</p>\n<p>(byte short char) int long float double</p>\n<p>其中，byte short char 平级</p>\n<ul>\n<li><strong>转换规则</strong></li>\n</ul>\n<p>1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算</p>\n<p>3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。</p>\n<p>2.byte short char 他们三者在计算时，首先会转换为int类型</p>\n<p>3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。</p>\n<p>4.boolean不能与其他类型转换</p>\n<h2 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a><strong>类类型</strong></h2><p>类类型之间的转换有以下几个规则：</p>\n<p>1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。</p>\n<p>2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。</p>\n<p>3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。</p>\n<p>说的比较拗口，用代码来解释吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@org</span>.junit.<span class=\"function\">Test</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        Father fatherApp;</div><div class=\"line\">        Son sonApp;</div><div class=\"line\">        Daughter daughterApp;</div><div class=\"line\">        Father fatherIns=<span class=\"keyword\">new</span> Father();</div><div class=\"line\">        Son sonIns=<span class=\"keyword\">new</span> Son();</div><div class=\"line\">        Daughter daughterIns=<span class=\"keyword\">new</span> Daughter();</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\">//目标类型为父类，源类型为子类，自动转换</span></div><div class=\"line\">        fatherApp=sonIns;   </div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。</span></div><div class=\"line\">        sonApp=(Son) fatherIns;</div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        </span></div><div class=\"line\">        sonApp=(Son) fatherApp;</div><div class=\"line\">        <span class=\"comment\">//目标类型与源类型不存在父子关系，编译无法通过</span></div><div class=\"line\">        daughterApp=sonIns;  </div><div class=\"line\">\t\t</div><div class=\"line\">    &#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://blog.csdn.net/mazhimazh/article/details/16799925\">Java 7之基础类型第1篇 - Java数据类型</a></p>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\">The Java™ Tutorials</a></p>\n<p><a href=\"http://blog.csdn.net/darxin/article/details/5163043\"> Java中的类型转换</a></p>\n"},{"layout":"post","title":"java中的编码问题","date":"2016-04-20T04:48:55.000Z","_content":"\n>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。\n\n## 编码\n什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。\n\n- #### **[Ascii编码](http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&fromid=99077&type=syn)**\n\n标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。\n\n- #### **[GB2312](http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&fromid=483170&type=syn)**\n\nGB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。\n\n- #### **[UTF-8](http://baike.baidu.com/view/25412.htm)**\n\n事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是[Unicode编码](http://baike.baidu.com/item/unicode)\n事实上，Unicode也是一套字符集。\n\n**字符集**简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字\"严\"。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？\n\n这是因为：\n\n比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n\n**字符编码**就是用来解决以上所说的如何存储字符对应二进制编码问题的。\n\nUTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8的编码规则很简单，只有两条： \n\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 \n\n2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n\n下面以utf-8为例，看下编码的过程。\n\n{% asset_img utf8.png utf-8 %}\n\n根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。\n\n以汉字”严”为例，演示如何实现UTF-8编码。\n\n已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。\n\n还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。\n\n## java 中的编码\n\n- #### **class文件与内存中的编码**\n\n{% asset_img javaencode.jpg %}\n\n上图说明了java编码转换的过程\n\n首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。\n\njava程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。\n\n**总结**:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。\n\n- #### **InputStreamReader与OutputStreamWriter**\n\n{% asset_img reader.png %}\n{% asset_img writer.png %}\n\nReader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。\n\n写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。\n\n```java\n String file = \"c:/stream.txt\"; \n String charset = \"UTF-8\"; \n // 写字符换转成字节流\n FileOutputStream outputStream = new FileOutputStream(file); \n OutputStreamWriter writer = new OutputStreamWriter( \n outputStream, charset); \n try { \n    writer.write(\"这是要保存的中文字符\"); \n } finally { \n    writer.close(); \n } \n // 读取字节转换成字符\n FileInputStream inputStream = new FileInputStream(file); \n InputStreamReader reader = new InputStreamReader( \n inputStream, charset); \n StringBuffer buffer = new StringBuffer(); \n char[] buf = new char[64]; \n int count = 0; \n try { \n    while ((count = reader.read(buf)) != -1) { \n        buffer.append(buf, 0, count); \n    } \n } finally { \n    reader.close(); \n }\n```\n\n- #### **String与byte[]**\n\n利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。\n\n```java\nString str=\"中\";  \n// 将内存中的str(utf-16)转换为系统默认编码的字节数组\nbyte[] bytes1 = str.getBytes();  \n// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 \nbyte[] bytes2 = str.getBytes(\"ISO-8859-1\");\n// 正常显示中    \nSystem.out.println(new String(bytes1));  \n// 输出\"?\"      \nSystem.out.println(new String(bytes2));      \n```\n\n利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。\n\n```java\n// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”\nbyte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31};  \n// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符\nString str1 = new String(bytes);                      \n// 将bytes按照ISO-8859-1解码，产生Unicode字符\nString str2= new String(bytes,\"ISO-8859-1\");          \n// 中1  将Unicode字符转换为GBK编码输出\nSystem.out.println(str1);                             \n\n/*\n *在ISO-8859-1编码方式中没有对应0xD6和0xD0\n *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”\n *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。\n */ \nSystem.out.println(str2);    // ??1                             \n```\n\n- #### **CharSet**\n\n从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。\n\n```java\nCharset charset = Charset.forName(\"UTF-8\");   \nByteBuffer byteBuffer = charset.encode(string);   \nCharBuffer charBuffer = charset.decode(byteBuffer); \n```\n\n## 延伸 byte\n\n字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。\n\n无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。\n\n有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.\n\n## 参考\n\n[十分钟搞清字符集和字符编码](http://cenalulu.github.io/linux/character-encoding/)\n\n[字符编码笔记：ASCII，Unicode和UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n[java编码转换过程](http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html)\n\n[Java 7之基础 - 编码与解码](http://blog.csdn.net/mazhimazh/article/details/19327421)\n\n[深入分析 Java 中的中文编码问题](https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/)","source":"_posts/java中的编码问题.md","raw":"---\nlayout: post\ntitle:  \"java中的编码问题\"\ncategories: 编程\ntags: \n- java\n- 编码\ndate:   2016-04-20 12:48:55\n---\n\n>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。\n\n## 编码\n什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。\n\n- #### **[Ascii编码](http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&fromid=99077&type=syn)**\n\n标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。\n\n- #### **[GB2312](http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&fromid=483170&type=syn)**\n\nGB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。\n\n- #### **[UTF-8](http://baike.baidu.com/view/25412.htm)**\n\n事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是[Unicode编码](http://baike.baidu.com/item/unicode)\n事实上，Unicode也是一套字符集。\n\n**字符集**简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字\"严\"。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？\n\n这是因为：\n\n比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n\n**字符编码**就是用来解决以上所说的如何存储字符对应二进制编码问题的。\n\nUTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8的编码规则很简单，只有两条： \n\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 \n\n2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n\n下面以utf-8为例，看下编码的过程。\n\n{% asset_img utf8.png utf-8 %}\n\n根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。\n\n以汉字”严”为例，演示如何实现UTF-8编码。\n\n已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。\n\n还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。\n\n## java 中的编码\n\n- #### **class文件与内存中的编码**\n\n{% asset_img javaencode.jpg %}\n\n上图说明了java编码转换的过程\n\n首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。\n\njava程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。\n\n**总结**:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。\n\n- #### **InputStreamReader与OutputStreamWriter**\n\n{% asset_img reader.png %}\n{% asset_img writer.png %}\n\nReader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。\n\n写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。\n\n```java\n String file = \"c:/stream.txt\"; \n String charset = \"UTF-8\"; \n // 写字符换转成字节流\n FileOutputStream outputStream = new FileOutputStream(file); \n OutputStreamWriter writer = new OutputStreamWriter( \n outputStream, charset); \n try { \n    writer.write(\"这是要保存的中文字符\"); \n } finally { \n    writer.close(); \n } \n // 读取字节转换成字符\n FileInputStream inputStream = new FileInputStream(file); \n InputStreamReader reader = new InputStreamReader( \n inputStream, charset); \n StringBuffer buffer = new StringBuffer(); \n char[] buf = new char[64]; \n int count = 0; \n try { \n    while ((count = reader.read(buf)) != -1) { \n        buffer.append(buf, 0, count); \n    } \n } finally { \n    reader.close(); \n }\n```\n\n- #### **String与byte[]**\n\n利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。\n\n```java\nString str=\"中\";  \n// 将内存中的str(utf-16)转换为系统默认编码的字节数组\nbyte[] bytes1 = str.getBytes();  \n// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 \nbyte[] bytes2 = str.getBytes(\"ISO-8859-1\");\n// 正常显示中    \nSystem.out.println(new String(bytes1));  \n// 输出\"?\"      \nSystem.out.println(new String(bytes2));      \n```\n\n利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。\n\n```java\n// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”\nbyte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31};  \n// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符\nString str1 = new String(bytes);                      \n// 将bytes按照ISO-8859-1解码，产生Unicode字符\nString str2= new String(bytes,\"ISO-8859-1\");          \n// 中1  将Unicode字符转换为GBK编码输出\nSystem.out.println(str1);                             \n\n/*\n *在ISO-8859-1编码方式中没有对应0xD6和0xD0\n *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”\n *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。\n */ \nSystem.out.println(str2);    // ??1                             \n```\n\n- #### **CharSet**\n\n从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。\n\n```java\nCharset charset = Charset.forName(\"UTF-8\");   \nByteBuffer byteBuffer = charset.encode(string);   \nCharBuffer charBuffer = charset.decode(byteBuffer); \n```\n\n## 延伸 byte\n\n字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。\n\n无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。\n\n有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.\n\n## 参考\n\n[十分钟搞清字符集和字符编码](http://cenalulu.github.io/linux/character-encoding/)\n\n[字符编码笔记：ASCII，Unicode和UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n[java编码转换过程](http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html)\n\n[Java 7之基础 - 编码与解码](http://blog.csdn.net/mazhimazh/article/details/19327421)\n\n[深入分析 Java 中的中文编码问题](https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/)","slug":"java中的编码问题","published":1,"updated":"2016-08-31T13:35:43.063Z","comments":1,"photos":[],"link":"","_id":"cisx6pomu000kzsqc1q6x2an9","content":"<blockquote>\n<p>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。</p>\n</blockquote>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。</p>\n<ul>\n<li><h4 id=\"Ascii编码\"><a href=\"#Ascii编码\" class=\"headerlink\" title=\"Ascii编码\"></a><strong><a href=\"http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&amp;fromid=99077&amp;type=syn\" target=\"_blank\" rel=\"external\">Ascii编码</a></strong></h4></li>\n</ul>\n<p>标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。</p>\n<ul>\n<li><h4 id=\"GB2312\"><a href=\"#GB2312\" class=\"headerlink\" title=\"GB2312\"></a><strong><a href=\"http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&amp;fromid=483170&amp;type=syn\" target=\"_blank\" rel=\"external\">GB2312</a></strong></h4></li>\n</ul>\n<p>GB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p>\n<ul>\n<li><h4 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a><strong><a href=\"http://baike.baidu.com/view/25412.htm\" target=\"_blank\" rel=\"external\">UTF-8</a></strong></h4></li>\n</ul>\n<p>事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是<a href=\"http://baike.baidu.com/item/unicode\" target=\"_blank\" rel=\"external\">Unicode编码</a><br>事实上，Unicode也是一套字符集。</p>\n<p><strong>字符集</strong>简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？</p>\n<p>这是因为：</p>\n<p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。<br>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>\n<p><strong>字符编码</strong>就是用来解决以上所说的如何存储字符对应二进制编码问题的。</p>\n<p>UTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<p>UTF-8的编码规则很简单，只有两条： </p>\n<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </p>\n<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>\n<p>下面以utf-8为例，看下编码的过程。</p>\n<img src=\"/2016/04/20/java中的编码问题/utf8.png\" alt=\"utf-8\" title=\"utf-8\">\n<p>根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。</p>\n<p>以汉字”严”为例，演示如何实现UTF-8编码。</p>\n<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。</p>\n<p>还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。</p>\n<h2 id=\"java-中的编码\"><a href=\"#java-中的编码\" class=\"headerlink\" title=\"java 中的编码\"></a>java 中的编码</h2><ul>\n<li><h4 id=\"class文件与内存中的编码\"><a href=\"#class文件与内存中的编码\" class=\"headerlink\" title=\"class文件与内存中的编码\"></a><strong>class文件与内存中的编码</strong></h4></li>\n</ul>\n\n<p>上图说明了java编码转换的过程</p>\n<p>首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。</p>\n<p>java程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。</p>\n<p><strong>总结</strong>:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。</p>\n<ul>\n<li><h4 id=\"InputStreamReader与OutputStreamWriter\"><a href=\"#InputStreamReader与OutputStreamWriter\" class=\"headerlink\" title=\"InputStreamReader与OutputStreamWriter\"></a><strong>InputStreamReader与OutputStreamWriter</strong></h4></li>\n</ul>\n<img src=\"/2016/04/20/java中的编码问题/reader.png\" alt=\"reader.png\" title=\"\">\n<img src=\"/2016/04/20/java中的编码问题/writer.png\" alt=\"writer.png\" title=\"\">\n<p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。</p>\n<p>写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">String file = <span class=\"string\">\"c:/stream.txt\"</span>; </div><div class=\"line\">String charset = <span class=\"string\">\"UTF-8\"</span>; </div><div class=\"line\"><span class=\"comment\">// 写字符换转成字节流</span></div><div class=\"line\">FileOutputStream outputStream = <span class=\"keyword\">new</span> FileOutputStream(file); </div><div class=\"line\">OutputStreamWriter writer = <span class=\"keyword\">new</span> OutputStreamWriter( </div><div class=\"line\">outputStream, charset); </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   writer.write(<span class=\"string\">\"这是要保存的中文字符\"</span>); </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   writer.close(); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"comment\">// 读取字节转换成字符</span></div><div class=\"line\">FileInputStream inputStream = <span class=\"keyword\">new</span> FileInputStream(file); </div><div class=\"line\">InputStreamReader reader = <span class=\"keyword\">new</span> InputStreamReader( </div><div class=\"line\">inputStream, charset); </div><div class=\"line\">StringBuffer buffer = <span class=\"keyword\">new</span> StringBuffer(); </div><div class=\"line\"><span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>]; </div><div class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   <span class=\"keyword\">while</span> ((count = reader.read(buf)) != -<span class=\"number\">1</span>) &#123; </div><div class=\"line\">       buffer.append(buf, <span class=\"number\">0</span>, count); </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   reader.close(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"String与byte\"><a href=\"#String与byte\" class=\"headerlink\" title=\"String与byte[]\"></a><strong>String与byte[]</strong></h4></li>\n</ul>\n<p>利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"string\">\"中\"</span>;  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为系统默认编码的字节数组</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = str.getBytes();  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 </span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = str.getBytes(<span class=\"string\">\"ISO-8859-1\"</span>);</div><div class=\"line\"><span class=\"comment\">// 正常显示中    </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes1));  </div><div class=\"line\"><span class=\"comment\">// 输出\"?\"      </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes2));</div></pre></td></tr></table></figure>\n<p>利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes = &#123;(<span class=\"keyword\">byte</span>)<span class=\"number\">0xD6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0xD0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0x31</span>&#125;;  </div><div class=\"line\"><span class=\"comment\">// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符</span></div><div class=\"line\">String str1 = <span class=\"keyword\">new</span> String(bytes);                      </div><div class=\"line\"><span class=\"comment\">// 将bytes按照ISO-8859-1解码，产生Unicode字符</span></div><div class=\"line\">String str2= <span class=\"keyword\">new</span> String(bytes,<span class=\"string\">\"ISO-8859-1\"</span>);          </div><div class=\"line\"><span class=\"comment\">// 中1  将Unicode字符转换为GBK编码输出</span></div><div class=\"line\">System.out.println(str1);                             </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> *在ISO-8859-1编码方式中没有对应0xD6和0xD0</div><div class=\"line\"> *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”</div><div class=\"line\"> *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。</div><div class=\"line\"> */ </div><div class=\"line\">System.out.println(str2);    <span class=\"comment\">// ??1</span></div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"CharSet\"><a href=\"#CharSet\" class=\"headerlink\" title=\"CharSet\"></a><strong>CharSet</strong></h4></li>\n</ul>\n<p>从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(<span class=\"string\">\"UTF-8\"</span>);   </div><div class=\"line\">ByteBuffer byteBuffer = charset.encode(string);   </div><div class=\"line\">CharBuffer charBuffer = charset.decode(byteBuffer);</div></pre></td></tr></table></figure>\n<h2 id=\"延伸-byte\"><a href=\"#延伸-byte\" class=\"headerlink\" title=\"延伸 byte\"></a>延伸 byte</h2><p>字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。</p>\n<p>无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。</p>\n<p>有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://cenalulu.github.io/linux/character-encoding/\" target=\"_blank\" rel=\"external\">十分钟搞清字符集和字符编码</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\" target=\"_blank\" rel=\"external\">字符编码笔记：ASCII，Unicode和UTF-8</a></p>\n<p><a href=\"http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html\" target=\"_blank\" rel=\"external\">java编码转换过程</a></p>\n<p><a href=\"http://blog.csdn.net/mazhimazh/article/details/19327421\" target=\"_blank\" rel=\"external\">Java 7之基础 - 编码与解码</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/\" target=\"_blank\" rel=\"external\">深入分析 Java 中的中文编码问题</a></p>\n","excerpt":"","more":"<blockquote>\n<p>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。</p>\n</blockquote>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。</p>\n<ul>\n<li><h4 id=\"Ascii编码\"><a href=\"#Ascii编码\" class=\"headerlink\" title=\"Ascii编码\"></a><strong><a href=\"http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&amp;fromid=99077&amp;type=syn\">Ascii编码</a></strong></h4></li>\n</ul>\n<p>标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。</p>\n<ul>\n<li><h4 id=\"GB2312\"><a href=\"#GB2312\" class=\"headerlink\" title=\"GB2312\"></a><strong><a href=\"http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&amp;fromid=483170&amp;type=syn\">GB2312</a></strong></h4></li>\n</ul>\n<p>GB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p>\n<ul>\n<li><h4 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a><strong><a href=\"http://baike.baidu.com/view/25412.htm\">UTF-8</a></strong></h4></li>\n</ul>\n<p>事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是<a href=\"http://baike.baidu.com/item/unicode\">Unicode编码</a><br>事实上，Unicode也是一套字符集。</p>\n<p><strong>字符集</strong>简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？</p>\n<p>这是因为：</p>\n<p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。<br>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>\n<p><strong>字符编码</strong>就是用来解决以上所说的如何存储字符对应二进制编码问题的。</p>\n<p>UTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<p>UTF-8的编码规则很简单，只有两条： </p>\n<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </p>\n<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>\n<p>下面以utf-8为例，看下编码的过程。</p>\n<img src=\"/2016/04/20/java中的编码问题/utf8.png\" alt=\"utf-8\" title=\"utf-8\">\n<p>根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。</p>\n<p>以汉字”严”为例，演示如何实现UTF-8编码。</p>\n<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。</p>\n<p>还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。</p>\n<h2 id=\"java-中的编码\"><a href=\"#java-中的编码\" class=\"headerlink\" title=\"java 中的编码\"></a>java 中的编码</h2><ul>\n<li><h4 id=\"class文件与内存中的编码\"><a href=\"#class文件与内存中的编码\" class=\"headerlink\" title=\"class文件与内存中的编码\"></a><strong>class文件与内存中的编码</strong></h4></li>\n</ul>\n\n<p>上图说明了java编码转换的过程</p>\n<p>首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。</p>\n<p>java程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。</p>\n<p><strong>总结</strong>:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。</p>\n<ul>\n<li><h4 id=\"InputStreamReader与OutputStreamWriter\"><a href=\"#InputStreamReader与OutputStreamWriter\" class=\"headerlink\" title=\"InputStreamReader与OutputStreamWriter\"></a><strong>InputStreamReader与OutputStreamWriter</strong></h4></li>\n</ul>\n<img src=\"/2016/04/20/java中的编码问题/reader.png\" alt=\"reader.png\" title=\"\">\n<img src=\"/2016/04/20/java中的编码问题/writer.png\" alt=\"writer.png\" title=\"\">\n<p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。</p>\n<p>写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">String file = <span class=\"string\">\"c:/stream.txt\"</span>; </div><div class=\"line\">String charset = <span class=\"string\">\"UTF-8\"</span>; </div><div class=\"line\"><span class=\"comment\">// 写字符换转成字节流</span></div><div class=\"line\">FileOutputStream outputStream = <span class=\"keyword\">new</span> FileOutputStream(file); </div><div class=\"line\">OutputStreamWriter writer = <span class=\"keyword\">new</span> OutputStreamWriter( </div><div class=\"line\">outputStream, charset); </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   writer.write(<span class=\"string\">\"这是要保存的中文字符\"</span>); </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   writer.close(); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"comment\">// 读取字节转换成字符</span></div><div class=\"line\">FileInputStream inputStream = <span class=\"keyword\">new</span> FileInputStream(file); </div><div class=\"line\">InputStreamReader reader = <span class=\"keyword\">new</span> InputStreamReader( </div><div class=\"line\">inputStream, charset); </div><div class=\"line\">StringBuffer buffer = <span class=\"keyword\">new</span> StringBuffer(); </div><div class=\"line\"><span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>]; </div><div class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   <span class=\"keyword\">while</span> ((count = reader.read(buf)) != -<span class=\"number\">1</span>) &#123; </div><div class=\"line\">       buffer.append(buf, <span class=\"number\">0</span>, count); </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   reader.close(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"String与byte\"><a href=\"#String与byte\" class=\"headerlink\" title=\"String与byte[]\"></a><strong>String与byte[]</strong></h4></li>\n</ul>\n<p>利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"string\">\"中\"</span>;  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为系统默认编码的字节数组</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = str.getBytes();  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 </span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = str.getBytes(<span class=\"string\">\"ISO-8859-1\"</span>);</div><div class=\"line\"><span class=\"comment\">// 正常显示中    </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes1));  </div><div class=\"line\"><span class=\"comment\">// 输出\"?\"      </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes2));</div></pre></td></tr></table></figure>\n<p>利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes = &#123;(<span class=\"keyword\">byte</span>)<span class=\"number\">0xD6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0xD0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0x31</span>&#125;;  </div><div class=\"line\"><span class=\"comment\">// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符</span></div><div class=\"line\">String str1 = <span class=\"keyword\">new</span> String(bytes);                      </div><div class=\"line\"><span class=\"comment\">// 将bytes按照ISO-8859-1解码，产生Unicode字符</span></div><div class=\"line\">String str2= <span class=\"keyword\">new</span> String(bytes,<span class=\"string\">\"ISO-8859-1\"</span>);          </div><div class=\"line\"><span class=\"comment\">// 中1  将Unicode字符转换为GBK编码输出</span></div><div class=\"line\">System.out.println(str1);                             </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\"> *在ISO-8859-1编码方式中没有对应0xD6和0xD0</div><div class=\"line\"> *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”</div><div class=\"line\"> *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。</div><div class=\"line\"> */</span> </div><div class=\"line\">System.out.println(str2);    <span class=\"comment\">// ??1</span></div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"CharSet\"><a href=\"#CharSet\" class=\"headerlink\" title=\"CharSet\"></a><strong>CharSet</strong></h4></li>\n</ul>\n<p>从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(<span class=\"string\">\"UTF-8\"</span>);   </div><div class=\"line\">ByteBuffer byteBuffer = charset.encode(string);   </div><div class=\"line\">CharBuffer charBuffer = charset.decode(byteBuffer);</div></pre></td></tr></table></figure>\n<h2 id=\"延伸-byte\"><a href=\"#延伸-byte\" class=\"headerlink\" title=\"延伸 byte\"></a>延伸 byte</h2><p>字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。</p>\n<p>无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。</p>\n<p>有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://cenalulu.github.io/linux/character-encoding/\">十分钟搞清字符集和字符编码</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\">字符编码笔记：ASCII，Unicode和UTF-8</a></p>\n<p><a href=\"http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html\">java编码转换过程</a></p>\n<p><a href=\"http://blog.csdn.net/mazhimazh/article/details/19327421\">Java 7之基础 - 编码与解码</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/\">深入分析 Java 中的中文编码问题</a></p>\n"},{"layout":"post","title":"java同步锁锁什么","date":"2015-12-17T06:10:55.000Z","_content":"\n在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：\n情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;\nThreadTest中的成员变量 j 被赋值为 i \n在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;\n在synchronized块中，我改变了这个 j 的值。代码大概是这样的：\n\n```\t\t\t\t\t   \nInteger j;\nThreadTest(Integer i){\n\t\tj=i;\n}\npublic void run() {\n\t\tsynchronized(j){\n\t\t  j++;\n\t\t}\n}\n\n```\n\n1. 一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。\n\n2. 另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。\n\n苦逼了。结果不对\n后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，\n即 void test(Object  i){\n\t\ti.dosomething()......\n   }\n函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。\n这样就解释了出错的 原因：\nInteger 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。\n所以 \n\n对于 1. \n\n当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望\n\n对于 2. \n\n使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步\n\t\t\t\t\t\t\t\n上面的情况也证明了，**synchronized 锁的是内存 ，而不是指向内存的引用**。\n\t\t\t\t\t\t\t\n这样的情况也说明了另外一种情况的问题，那就是**在函数中给实参分配内存,实际在函数体外是得不到这个对象的**。\n\t\t\t\t\t\t\t\n解决的办法：\n放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，\n各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。","source":"_posts/java同步锁锁什么.md","raw":"---\nlayout: post\ntitle:  \"java同步锁锁什么\"\ndate:   2015-12-17 14:10:55\ncategories: 编程\ntags: \n- java\n- 多线程\n---\n\n在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：\n情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;\nThreadTest中的成员变量 j 被赋值为 i \n在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;\n在synchronized块中，我改变了这个 j 的值。代码大概是这样的：\n\n```\t\t\t\t\t   \nInteger j;\nThreadTest(Integer i){\n\t\tj=i;\n}\npublic void run() {\n\t\tsynchronized(j){\n\t\t  j++;\n\t\t}\n}\n\n```\n\n1. 一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。\n\n2. 另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。\n\n苦逼了。结果不对\n后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，\n即 void test(Object  i){\n\t\ti.dosomething()......\n   }\n函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。\n这样就解释了出错的 原因：\nInteger 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。\n所以 \n\n对于 1. \n\n当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望\n\n对于 2. \n\n使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步\n\t\t\t\t\t\t\t\n上面的情况也证明了，**synchronized 锁的是内存 ，而不是指向内存的引用**。\n\t\t\t\t\t\t\t\n这样的情况也说明了另外一种情况的问题，那就是**在函数中给实参分配内存,实际在函数体外是得不到这个对象的**。\n\t\t\t\t\t\t\t\n解决的办法：\n放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，\n各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。","slug":"java同步锁锁什么","published":1,"updated":"2016-08-14T08:26:27.914Z","comments":1,"photos":[],"link":"","_id":"cisx6pona000pzsqcvtxqcx98","content":"<p>在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：<br>情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;<br>ThreadTest中的成员变量 j 被赋值为 i<br>在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;<br>在synchronized块中，我改变了这个 j 的值。代码大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer j;</div><div class=\"line\">ThreadTest(Integer i)&#123;</div><div class=\"line\">\t\tj=i;</div><div class=\"line\">&#125;</div><div class=\"line\">public void run() &#123;</div><div class=\"line\">\t\tsynchronized(j)&#123;</div><div class=\"line\">\t\t  j++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。</p>\n</li>\n<li><p>另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。</p>\n</li>\n</ol>\n<p>苦逼了。结果不对<br>后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，<br>即 void test(Object  i){<br>        i.dosomething()……<br>   }<br>函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。<br>这样就解释了出错的 原因：<br>Integer 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。<br>所以 </p>\n<p>对于 1. </p>\n<p>当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望</p>\n<p>对于 2. </p>\n<p>使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步</p>\n<p>上面的情况也证明了，<strong>synchronized 锁的是内存 ，而不是指向内存的引用</strong>。</p>\n<p>这样的情况也说明了另外一种情况的问题，那就是<strong>在函数中给实参分配内存,实际在函数体外是得不到这个对象的</strong>。</p>\n<p>解决的办法：<br>放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，<br>各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。</p>\n","excerpt":"","more":"<p>在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：<br>情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;<br>ThreadTest中的成员变量 j 被赋值为 i<br>在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;<br>在synchronized块中，我改变了这个 j 的值。代码大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer j;</div><div class=\"line\">ThreadTest(Integer i)&#123;</div><div class=\"line\">\t\tj=i;</div><div class=\"line\">&#125;</div><div class=\"line\">public void run() &#123;</div><div class=\"line\">\t\tsynchronized(j)&#123;</div><div class=\"line\">\t\t  j++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。</p>\n</li>\n<li><p>另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。</p>\n</li>\n</ol>\n<p>苦逼了。结果不对<br>后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，<br>即 void test(Object  i){<br>        i.dosomething()……<br>   }<br>函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。<br>这样就解释了出错的 原因：<br>Integer 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。<br>所以 </p>\n<p>对于 1. </p>\n<p>当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望</p>\n<p>对于 2. </p>\n<p>使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步</p>\n<p>上面的情况也证明了，<strong>synchronized 锁的是内存 ，而不是指向内存的引用</strong>。</p>\n<p>这样的情况也说明了另外一种情况的问题，那就是<strong>在函数中给实参分配内存,实际在函数体外是得不到这个对象的</strong>。</p>\n<p>解决的办法：<br>放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，<br>各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。</p>\n"},{"layout":"post","date":"2016-04-12T04:48:55.000Z","title":"Junit的使用","_content":"\n>[Junit](http://junit.org/junit4/)是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。\n\n\n\n\n\n\n\n**资料**\n\n[Unit Testing with JUnit - Tutorial](http://www.vogella.com/tutorials/JUnit/article.html)\n\n[JUnit Tutorial](http://www.tutorialspoint.com/junit/)\n\n[走进java测试利器-junit](http://developer.51cto.com/art/201103/252490.htm)\n\n","source":"_posts/junit使用.md","raw":"---\nlayout: post\ndate:   2016-04-12 12:48:55\ntitle: \"Junit的使用\"\ncategories: 工具\ntags: \n- junit\n- 测试\n---\n\n>[Junit](http://junit.org/junit4/)是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。\n\n\n\n\n\n\n\n**资料**\n\n[Unit Testing with JUnit - Tutorial](http://www.vogella.com/tutorials/JUnit/article.html)\n\n[JUnit Tutorial](http://www.tutorialspoint.com/junit/)\n\n[走进java测试利器-junit](http://developer.51cto.com/art/201103/252490.htm)\n\n","slug":"junit使用","published":1,"updated":"2016-08-14T08:26:27.926Z","comments":1,"photos":[],"link":"","_id":"cisx6pona000szsqcomk9r6og","content":"<blockquote>\n<p><a href=\"http://junit.org/junit4/\" target=\"_blank\" rel=\"external\">Junit</a>是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。</p>\n</blockquote>\n<p><strong>资料</strong></p>\n<p><a href=\"http://www.vogella.com/tutorials/JUnit/article.html\" target=\"_blank\" rel=\"external\">Unit Testing with JUnit - Tutorial</a></p>\n<p><a href=\"http://www.tutorialspoint.com/junit/\" target=\"_blank\" rel=\"external\">JUnit Tutorial</a></p>\n<p><a href=\"http://developer.51cto.com/art/201103/252490.htm\" target=\"_blank\" rel=\"external\">走进java测试利器-junit</a></p>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"http://junit.org/junit4/\">Junit</a>是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。</p>\n</blockquote>\n<p><strong>资料</strong></p>\n<p><a href=\"http://www.vogella.com/tutorials/JUnit/article.html\">Unit Testing with JUnit - Tutorial</a></p>\n<p><a href=\"http://www.tutorialspoint.com/junit/\">JUnit Tutorial</a></p>\n<p><a href=\"http://developer.51cto.com/art/201103/252490.htm\">走进java测试利器-junit</a></p>\n"},{"layout":"post","title":"Markdown","date":"2016-03-03T14:10:55.000Z","_content":"\n>[Markdown][markdown-com] 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。\n\n# 常用语法\n \n makedown 语法  \n\n---\n\n## 代码\n\n\\`\\`\\`\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\\`\\`\\`\n\nUse the \\`printf()` function.\n\n---\n\n\n## 标题\n\n\\# 标题1\n\n\\## 标题2\n\n\\### 标题3\n\n\\#### 标题4\n\n\\##### 标题5\n\n\\###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n\n2. 有序列表2\n\n\n\\- 无序列表1\n\n\\- 无序列表2\n\n\\* 无序列表3\n\n\\+ 无序列表4\n\n---\n\n## 链接\n\n\\[谷歌](http://www.google.com)\n\n这是一个 \\[例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 \\[例子] \\[id] 参考链接.\n\n\\[id]: http://google.com/ \"google\"\n\n\n自动链接\n\n```\n<http://example.com/>\n```\n\n---\n\n## 图片\n\n行内链接：\n\\!\\[](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n\\!\\[img]\n\n\\[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n```\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n```\n---\n\n## 引用\n\n\\> 引用\n\n\\>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n\\*这里是斜体\\*\n\n\\*\\*这里是粗体\\*\\*\n\n\\*\\*\\*这里是粗斜体\\*\\*\\*\n\n---\n\n## 表格\n\ndog \\| bird \\| cat\n\n----\\|------\\|----\n\nfoo \\| foo  \\| foo\n\nbar \\| bar  \\| bar\n\nbaz \\| baz  \\| baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\\\   反斜线\n  \n   \\\\`   反引号\n   \n   \\\\*   星号\n   \n   \\\\_   底线\n   \n   \\\\{}  花括号\n   \n   \\\\[]  方括号\n   \n   \\\\()  括弧\n   \n   \\\\#   井字号\n   \n   \\\\+   加号\n   \n   \\\\-   减号\n   \n   \\\\.   英文句点\n   \n   \\\\!   惊叹号\n\n---\n\n## 删除线\n\n\\~~删除这里的内容~~\n\n---\n\n\n\n\n# 效果\n\nmakedown 语法  \n---\n\n## 代码\n\n```\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\n```\n\nUse the `printf()` function.\n\n---\n\n\n## 标题\n\n# 标题1\n\n## 标题2\n\n### 标题3\n\n#### 标题4\n\n##### 标题5\n\n###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n2. 有序列表2\n\n\n- 无序列表1\n- 无序列表2\n* 无序列表3\n+ 无序列表4\n\n---\n\n## 链接\n\n[谷歌](http://www.google.com)\n\n这是一个 [例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 [例子] [id] 参考链接.\n[id]: http://google.com/  \"google\"\n\n\n自动链接\n<http://example.com/>\n\n---\n\n## 图片\n\n行内链接：\n![](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n![img]\n\n[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n\n---\n\n## 引用\n\n> 引用\n\n>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n*这里是斜体*\n\n**这里是粗体**\n\n***这里是粗斜体***\n\n---\n\n## 表格\n\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\   反斜线\n  \n   \\`   反引号\n   \n   \\*   星号\n   \n   \\_   底线\n   \n   \\{}  花括号\n   \n   \\[]  方括号\n   \n   \\()  括弧\n   \n   \\#   井字号\n   \n   \\+   加号\n   \n   \\-   减号\n   \n   \\.   英文句点\n   \n   \\!   惊叹号\n\n---\n\n## 删除线\n\n~~删除这里的内容~~\n\n---\n\n## 一些参考\n\n[Markdown 语法说明 (简体中文版)](http://www.markdown.cn/)\n\n[Markdown 维基百科 ](https://zh.wikipedia.org/wiki/Markdown)\n\n---\n\n[markdown-com]:      http://wowubuntu.com/markdown/\n","source":"_posts/markdown.md","raw":"---\nlayout: post\ntitle:  \"Markdown\"\ndate:   2016-03-03 22:10:55\ncategories: 工具\ntags: \n- markdown\n---\n\n>[Markdown][markdown-com] 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。\n\n# 常用语法\n \n makedown 语法  \n\n---\n\n## 代码\n\n\\`\\`\\`\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\\`\\`\\`\n\nUse the \\`printf()` function.\n\n---\n\n\n## 标题\n\n\\# 标题1\n\n\\## 标题2\n\n\\### 标题3\n\n\\#### 标题4\n\n\\##### 标题5\n\n\\###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n\n2. 有序列表2\n\n\n\\- 无序列表1\n\n\\- 无序列表2\n\n\\* 无序列表3\n\n\\+ 无序列表4\n\n---\n\n## 链接\n\n\\[谷歌](http://www.google.com)\n\n这是一个 \\[例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 \\[例子] \\[id] 参考链接.\n\n\\[id]: http://google.com/ \"google\"\n\n\n自动链接\n\n```\n<http://example.com/>\n```\n\n---\n\n## 图片\n\n行内链接：\n\\!\\[](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n\\!\\[img]\n\n\\[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n```\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n```\n---\n\n## 引用\n\n\\> 引用\n\n\\>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n\\*这里是斜体\\*\n\n\\*\\*这里是粗体\\*\\*\n\n\\*\\*\\*这里是粗斜体\\*\\*\\*\n\n---\n\n## 表格\n\ndog \\| bird \\| cat\n\n----\\|------\\|----\n\nfoo \\| foo  \\| foo\n\nbar \\| bar  \\| bar\n\nbaz \\| baz  \\| baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\\\   反斜线\n  \n   \\\\`   反引号\n   \n   \\\\*   星号\n   \n   \\\\_   底线\n   \n   \\\\{}  花括号\n   \n   \\\\[]  方括号\n   \n   \\\\()  括弧\n   \n   \\\\#   井字号\n   \n   \\\\+   加号\n   \n   \\\\-   减号\n   \n   \\\\.   英文句点\n   \n   \\\\!   惊叹号\n\n---\n\n## 删除线\n\n\\~~删除这里的内容~~\n\n---\n\n\n\n\n# 效果\n\nmakedown 语法  \n---\n\n## 代码\n\n```\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\n```\n\nUse the `printf()` function.\n\n---\n\n\n## 标题\n\n# 标题1\n\n## 标题2\n\n### 标题3\n\n#### 标题4\n\n##### 标题5\n\n###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n2. 有序列表2\n\n\n- 无序列表1\n- 无序列表2\n* 无序列表3\n+ 无序列表4\n\n---\n\n## 链接\n\n[谷歌](http://www.google.com)\n\n这是一个 [例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 [例子] [id] 参考链接.\n[id]: http://google.com/  \"google\"\n\n\n自动链接\n<http://example.com/>\n\n---\n\n## 图片\n\n行内链接：\n![](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n![img]\n\n[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n\n---\n\n## 引用\n\n> 引用\n\n>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n*这里是斜体*\n\n**这里是粗体**\n\n***这里是粗斜体***\n\n---\n\n## 表格\n\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\   反斜线\n  \n   \\`   反引号\n   \n   \\*   星号\n   \n   \\_   底线\n   \n   \\{}  花括号\n   \n   \\[]  方括号\n   \n   \\()  括弧\n   \n   \\#   井字号\n   \n   \\+   加号\n   \n   \\-   减号\n   \n   \\.   英文句点\n   \n   \\!   惊叹号\n\n---\n\n## 删除线\n\n~~删除这里的内容~~\n\n---\n\n## 一些参考\n\n[Markdown 语法说明 (简体中文版)](http://www.markdown.cn/)\n\n[Markdown 维基百科 ](https://zh.wikipedia.org/wiki/Markdown)\n\n---\n\n[markdown-com]:      http://wowubuntu.com/markdown/\n","slug":"markdown","published":1,"updated":"2016-08-14T08:26:27.932Z","comments":1,"photos":[],"link":"","_id":"cisx6pona000xzsqcosqyz3r5","content":"<blockquote>\n<p><a href=\"http://wowubuntu.com/markdown/\" target=\"_blank\" rel=\"external\">Markdown</a> 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>\n</blockquote>\n<p> 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。</p>\n<h1 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h1><p> makedown 语法  </p>\n<hr>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>```<br>public void main(String args[]){<br>    System.out.print(“Hello World”);<br>}<br>```</p>\n<p>Use the `printf()` function.</p>\n<hr>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p># 标题1</p>\n<p>## 标题2</p>\n<p>### 标题3</p>\n<p>#### 标题4</p>\n<p>##### 标题5</p>\n<p>###### 标题6</p>\n<hr>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li><p>有序列表1</p>\n</li>\n<li><p>有序列表2</p>\n</li>\n</ol>\n<p>- 无序列表1</p>\n<p>- 无序列表2</p>\n<p>* 无序列表3</p>\n<p>+ 无序列表4</p>\n<hr>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>[谷歌](<a href=\"http://www.google.com\" target=\"_blank\" rel=\"external\">http://www.google.com</a>)</p>\n<p>这是一个 [例子](<a href=\"http://google.com/\" target=\"_blank\" rel=\"external\">http://google.com/</a> “google”) 行内链接.</p>\n<p>这是一个 [例子] [id] 参考链接.</p>\n<p>[id]: <a href=\"http://google.com/\" target=\"_blank\" rel=\"external\">http://google.com/</a> “google”</p>\n<p>自动链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;http://example.com/&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br>![](<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" target=\"_blank\" rel=\"external\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a>)</p>\n<p>参考链接：<br>![img]</p>\n<p>[img]:<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" target=\"_blank\" rel=\"external\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a></p>\n<p>指定宽高：需用html标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;img src=&quot;http://img3.3lian.com/2013/s1/65/d/104.jpg&quot; width=&quot;200&quot; height=&quot;128&quot;  /&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>> 引用</p>\n<p>>&gt; 嵌套引用</p>\n<hr>\n<h2 id=\"粗体-斜体\"><a href=\"#粗体-斜体\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p>*这里是斜体*</p>\n<p>**这里是粗体**</p>\n<p>***这里是粗斜体***</p>\n<hr>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>dog | bird | cat</p>\n<p>—-|——|—-</p>\n<p>foo | foo  | foo</p>\n<p>bar | bar  | bar</p>\n<p>baz | baz  | baz</p>\n<hr>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\\\   反斜线</p>\n<p>   \\`   反引号</p>\n<p>   \\*   星号</p>\n<p>   \\_   底线</p>\n<p>   \\{}  花括号</p>\n<p>   \\[]  方括号</p>\n<p>   \\()  括弧</p>\n<p>   \\#   井字号</p>\n<p>   \\+   加号</p>\n<p>   \\-   减号</p>\n<p>   \\.   英文句点</p>\n<p>   \\!   惊叹号</p>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>~~删除这里的内容~~</p>\n<hr>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><h2 id=\"makedown-语法\"><a href=\"#makedown-语法\" class=\"headerlink\" title=\"makedown 语法  \"></a>makedown 语法  </h2><h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void main(String args[])&#123;</div><div class=\"line\">    System.out.print(&quot;Hello World&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Use the <code>printf()</code> function.</p>\n<hr>\n<h2 id=\"标题-1\"><a href=\"#标题-1\" class=\"headerlink\" title=\"标题\"></a>标题</h2><h1 id=\"标题1\"><a href=\"#标题1\" class=\"headerlink\" title=\"标题1\"></a>标题1</h1><h2 id=\"标题2\"><a href=\"#标题2\" class=\"headerlink\" title=\"标题2\"></a>标题2</h2><h3 id=\"标题3\"><a href=\"#标题3\" class=\"headerlink\" title=\"标题3\"></a>标题3</h3><h4 id=\"标题4\"><a href=\"#标题4\" class=\"headerlink\" title=\"标题4\"></a>标题4</h4><h5 id=\"标题5\"><a href=\"#标题5\" class=\"headerlink\" title=\"标题5\"></a>标题5</h5><h6 id=\"标题6\"><a href=\"#标题6\" class=\"headerlink\" title=\"标题6\"></a>标题6</h6><hr>\n<h2 id=\"列表-1\"><a href=\"#列表-1\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n</ul>\n<ul>\n<li>无序列表3</li>\n</ul>\n<ul>\n<li>无序列表4</li>\n</ul>\n<hr>\n<h2 id=\"链接-1\"><a href=\"#链接-1\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://www.google.com\" target=\"_blank\" rel=\"external\">谷歌</a></p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\" target=\"_blank\" rel=\"external\">例子</a> 行内链接.</p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\" target=\"_blank\" rel=\"external\">例子</a> 参考链接.</p>\n<p>自动链接<br><a href=\"http://example.com/\" target=\"_blank\" rel=\"external\">http://example.com/</a></p>\n<hr>\n<h2 id=\"图片-1\"><a href=\"#图片-1\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"\"></p>\n<p>参考链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"img\"></p>\n<p>指定宽高：需用html标记</p>\n<p><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\">  </p>\n<hr>\n<h2 id=\"引用-1\"><a href=\"#引用-1\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>引用</p>\n<blockquote>\n<p>嵌套引用</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"粗体-斜体-1\"><a href=\"#粗体-斜体-1\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p><em>这里是斜体</em></p>\n<p><strong>这里是粗体</strong></p>\n<p><strong><em>这里是粗斜体</em></strong></p>\n<hr>\n<h2 id=\"表格-1\"><a href=\"#表格-1\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th>dog</th>\n<th>bird</th>\n<th>cat</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>foo</td>\n<td>foo</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>bar</td>\n<td>bar</td>\n</tr>\n<tr>\n<td>baz</td>\n<td>baz</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"转义-1\"><a href=\"#转义-1\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\   反斜线</p>\n<p>   `   反引号</p>\n<p>   *   星号</p>\n<p>   _   底线</p>\n<p>   {}  花括号</p>\n<p>   []  方括号</p>\n<p>   ()  括弧</p>\n<p>   #   井字号</p>\n<p>   +   加号</p>\n<p>   -   减号</p>\n<p>   .   英文句点</p>\n<p>   !   惊叹号</p>\n<hr>\n<h2 id=\"删除线-1\"><a href=\"#删除线-1\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p><del>删除这里的内容</del></p>\n<hr>\n<h2 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h2><p><a href=\"http://www.markdown.cn/\" target=\"_blank\" rel=\"external\">Markdown 语法说明 (简体中文版)</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"external\">Markdown 维基百科 </a></p>\n<hr>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"http://wowubuntu.com/markdown/\">Markdown</a> 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>\n</blockquote>\n<p> 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。</p>\n<h1 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h1><p> makedown 语法  </p>\n<hr>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>```<br>public void main(String args[]){<br>    System.out.print(“Hello World”);<br>}<br>```</p>\n<p>Use the `printf()` function.</p>\n<hr>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p># 标题1</p>\n<p>## 标题2</p>\n<p>### 标题3</p>\n<p>#### 标题4</p>\n<p>##### 标题5</p>\n<p>###### 标题6</p>\n<hr>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li><p>有序列表1</p>\n</li>\n<li><p>有序列表2</p>\n</li>\n</ol>\n<p>- 无序列表1</p>\n<p>- 无序列表2</p>\n<p>* 无序列表3</p>\n<p>+ 无序列表4</p>\n<hr>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>[谷歌](<a href=\"http://www.google.com\">http://www.google.com</a>)</p>\n<p>这是一个 [例子](<a href=\"http://google.com/\">http://google.com/</a> “google”) 行内链接.</p>\n<p>这是一个 [例子] [id] 参考链接.</p>\n<p>[id]: <a href=\"http://google.com/\">http://google.com/</a> “google”</p>\n<p>自动链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;http://example.com/&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br>![](<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a>)</p>\n<p>参考链接：<br>![img]</p>\n<p>[img]:<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a></p>\n<p>指定宽高：需用html标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;img src=&quot;http://img3.3lian.com/2013/s1/65/d/104.jpg&quot; width=&quot;200&quot; height=&quot;128&quot;  /&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>> 引用</p>\n<p>>&gt; 嵌套引用</p>\n<hr>\n<h2 id=\"粗体-斜体\"><a href=\"#粗体-斜体\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p>*这里是斜体*</p>\n<p>**这里是粗体**</p>\n<p>***这里是粗斜体***</p>\n<hr>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>dog | bird | cat</p>\n<p>—-|——|—-</p>\n<p>foo | foo  | foo</p>\n<p>bar | bar  | bar</p>\n<p>baz | baz  | baz</p>\n<hr>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\\\   反斜线</p>\n<p>   \\`   反引号</p>\n<p>   \\*   星号</p>\n<p>   \\_   底线</p>\n<p>   \\{}  花括号</p>\n<p>   \\[]  方括号</p>\n<p>   \\()  括弧</p>\n<p>   \\#   井字号</p>\n<p>   \\+   加号</p>\n<p>   \\-   减号</p>\n<p>   \\.   英文句点</p>\n<p>   \\!   惊叹号</p>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>~~删除这里的内容~~</p>\n<hr>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><h2 id=\"makedown-语法\"><a href=\"#makedown-语法\" class=\"headerlink\" title=\"makedown 语法  \"></a>makedown 语法  </h2><h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void main(String args[])&#123;</div><div class=\"line\">    System.out.print(&quot;Hello World&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Use the <code>printf()</code> function.</p>\n<hr>\n<h2 id=\"标题-1\"><a href=\"#标题-1\" class=\"headerlink\" title=\"标题\"></a>标题</h2><h1 id=\"标题1\"><a href=\"#标题1\" class=\"headerlink\" title=\"标题1\"></a>标题1</h1><h2 id=\"标题2\"><a href=\"#标题2\" class=\"headerlink\" title=\"标题2\"></a>标题2</h2><h3 id=\"标题3\"><a href=\"#标题3\" class=\"headerlink\" title=\"标题3\"></a>标题3</h3><h4 id=\"标题4\"><a href=\"#标题4\" class=\"headerlink\" title=\"标题4\"></a>标题4</h4><h5 id=\"标题5\"><a href=\"#标题5\" class=\"headerlink\" title=\"标题5\"></a>标题5</h5><h6 id=\"标题6\"><a href=\"#标题6\" class=\"headerlink\" title=\"标题6\"></a>标题6</h6><hr>\n<h2 id=\"列表-1\"><a href=\"#列表-1\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n</ul>\n<ul>\n<li>无序列表3</li>\n</ul>\n<ul>\n<li>无序列表4</li>\n</ul>\n<hr>\n<h2 id=\"链接-1\"><a href=\"#链接-1\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://www.google.com\">谷歌</a></p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\">例子</a> 行内链接.</p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\">例子</a> 参考链接.</p>\n<p>自动链接<br><a href=\"http://example.com/\">http://example.com/</a></p>\n<hr>\n<h2 id=\"图片-1\"><a href=\"#图片-1\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"\"></p>\n<p>参考链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"img\"></p>\n<p>指定宽高：需用html标记</p>\n<p><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  </p>\n<hr>\n<h2 id=\"引用-1\"><a href=\"#引用-1\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>引用</p>\n<blockquote>\n<p>嵌套引用</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"粗体-斜体-1\"><a href=\"#粗体-斜体-1\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p><em>这里是斜体</em></p>\n<p><strong>这里是粗体</strong></p>\n<p><strong><em>这里是粗斜体</em></strong></p>\n<hr>\n<h2 id=\"表格-1\"><a href=\"#表格-1\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th>dog</th>\n<th>bird</th>\n<th>cat</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>foo</td>\n<td>foo</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>bar</td>\n<td>bar</td>\n</tr>\n<tr>\n<td>baz</td>\n<td>baz</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"转义-1\"><a href=\"#转义-1\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\   反斜线</p>\n<p>   `   反引号</p>\n<p>   *   星号</p>\n<p>   _   底线</p>\n<p>   {}  花括号</p>\n<p>   []  方括号</p>\n<p>   ()  括弧</p>\n<p>   #   井字号</p>\n<p>   +   加号</p>\n<p>   -   减号</p>\n<p>   .   英文句点</p>\n<p>   !   惊叹号</p>\n<hr>\n<h2 id=\"删除线-1\"><a href=\"#删除线-1\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p><del>删除这里的内容</del></p>\n<hr>\n<h2 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h2><p><a href=\"http://www.markdown.cn/\">Markdown 语法说明 (简体中文版)</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\">Markdown 维基百科 </a></p>\n<hr>\n"},{"layout":"post","title":"notify 问题","date":"2015-12-21T04:48:55.000Z","_content":"\n今天遇到了这么个情况：\n有线程若干，我需要他们按顺序执行。\n代码大概长这样：\n\n```\nclass SyncTag {\n\tpublic int threadNO;\n\tpublic SyncTag() {\n\t    threadNO = 0;\n\t}\n}\nclass ThreadA extend Thread{\n\tSyncTag syncTag;\n\tint scriptNO;\n\tThreadA(SyncTag syncTag,int scriptNO){\n\t\t\tthis.syncTag=syncTag;\n\t\t\tthis.scriptNO=scriptNO;\n\t}\n\tpublic void Run(){\n\t\t\tsynchronized (syncTag) {\n                if (syncTag.threadNO != scriptNO) {\n                        try {\n                                syncTag.wait();\n                        } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                        }\n                }\n                dosomething();\n                syncTag.threadNO++;\n                syncTag.notifyAll();\n\t\t\t}\n\t}\n}\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t    SyncTag syncTag=new SyncTag();\n\t\t\tfor(int i=0;i<10;++i){\n\t\t\t\tThreadA t=new ThreadA(syncTag,i);\n\t\t\t\tt.start();\n\t\t\t}\n\t}\n}\n```\n\n结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。\n研究一番，发现是 notify 与notifyAll 在捣鬼。\n当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。\n其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。\n\t\t \n当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，\n剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，\n没抢到的老实等着。\n\t\t \n这就是notify 与 notifyAll两者的区别.\n\t\t \n那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。\n原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合\nsyncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，\n如果不符合，就继续wait.符合则执行。\n很简单，将 \n\n```java\nif (syncTag.threadNO != scriptNO) {\n        try {\n                syncTag.wait();\n            } catch (InterruptedException e) {\n                                    e.printStackTrace();\n            }\n}\n```\n\n这部分代码 改为： \n\n```java\nwhile (syncTag.threadNO != scriptNO) {\n\t\ttry {\n\t\t\t\tsyncTag.wait();\n\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n这个问题就解决了。\n\t \n## **延伸**：\n假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：\n设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO\n这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们\n中的一个。于是陷入死锁，无尽的等待。\n\t\t \n所以，具体使用notify还是notifyAll 就得具体情况具体分析了。","source":"_posts/notify问题.md","raw":"---\nlayout: post\ntitle:  \"notify 问题\"\ndate:   2015-12-21 12:48:55\ncategories: 编程\ntags:\n- java\n- 多线程 \n---\n\n今天遇到了这么个情况：\n有线程若干，我需要他们按顺序执行。\n代码大概长这样：\n\n```\nclass SyncTag {\n\tpublic int threadNO;\n\tpublic SyncTag() {\n\t    threadNO = 0;\n\t}\n}\nclass ThreadA extend Thread{\n\tSyncTag syncTag;\n\tint scriptNO;\n\tThreadA(SyncTag syncTag,int scriptNO){\n\t\t\tthis.syncTag=syncTag;\n\t\t\tthis.scriptNO=scriptNO;\n\t}\n\tpublic void Run(){\n\t\t\tsynchronized (syncTag) {\n                if (syncTag.threadNO != scriptNO) {\n                        try {\n                                syncTag.wait();\n                        } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                        }\n                }\n                dosomething();\n                syncTag.threadNO++;\n                syncTag.notifyAll();\n\t\t\t}\n\t}\n}\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t    SyncTag syncTag=new SyncTag();\n\t\t\tfor(int i=0;i<10;++i){\n\t\t\t\tThreadA t=new ThreadA(syncTag,i);\n\t\t\t\tt.start();\n\t\t\t}\n\t}\n}\n```\n\n结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。\n研究一番，发现是 notify 与notifyAll 在捣鬼。\n当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。\n其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。\n\t\t \n当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，\n剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，\n没抢到的老实等着。\n\t\t \n这就是notify 与 notifyAll两者的区别.\n\t\t \n那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。\n原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合\nsyncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，\n如果不符合，就继续wait.符合则执行。\n很简单，将 \n\n```java\nif (syncTag.threadNO != scriptNO) {\n        try {\n                syncTag.wait();\n            } catch (InterruptedException e) {\n                                    e.printStackTrace();\n            }\n}\n```\n\n这部分代码 改为： \n\n```java\nwhile (syncTag.threadNO != scriptNO) {\n\t\ttry {\n\t\t\t\tsyncTag.wait();\n\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n这个问题就解决了。\n\t \n## **延伸**：\n假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：\n设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO\n这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们\n中的一个。于是陷入死锁，无尽的等待。\n\t\t \n所以，具体使用notify还是notifyAll 就得具体情况具体分析了。","slug":"notify问题","published":1,"updated":"2016-08-14T13:21:15.796Z","comments":1,"photos":[],"link":"","_id":"cisx6pona0010zsqcpblwg8jq","content":"<p>今天遇到了这么个情况：<br>有线程若干，我需要他们按顺序执行。<br>代码大概长这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SyncTag &#123;</div><div class=\"line\">\tpublic int threadNO;</div><div class=\"line\">\tpublic SyncTag() &#123;</div><div class=\"line\">\t    threadNO = 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class ThreadA extend Thread&#123;</div><div class=\"line\">\tSyncTag syncTag;</div><div class=\"line\">\tint scriptNO;</div><div class=\"line\">\tThreadA(SyncTag syncTag,int scriptNO)&#123;</div><div class=\"line\">\t\t\tthis.syncTag=syncTag;</div><div class=\"line\">\t\t\tthis.scriptNO=scriptNO;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void Run()&#123;</div><div class=\"line\">\t\t\tsynchronized (syncTag) &#123;</div><div class=\"line\">                if (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">                        try &#123;</div><div class=\"line\">                                syncTag.wait();</div><div class=\"line\">                        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                dosomething();</div><div class=\"line\">                syncTag.threadNO++;</div><div class=\"line\">                syncTag.notifyAll();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">public class Test&#123;</div><div class=\"line\">\tpublic static void main(String args[])&#123;</div><div class=\"line\">\t\t    SyncTag syncTag=new SyncTag();</div><div class=\"line\">\t\t\tfor(int i=0;i&lt;10;++i)&#123;</div><div class=\"line\">\t\t\t\tThreadA t=new ThreadA(syncTag,i);</div><div class=\"line\">\t\t\t\tt.start();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。<br>研究一番，发现是 notify 与notifyAll 在捣鬼。<br>当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。<br>其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。</p>\n<p>当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，<br>剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，<br>没抢到的老实等着。</p>\n<p>这就是notify 与 notifyAll两者的区别.</p>\n<p>那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。<br>原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合<br>syncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，<br>如果不符合，就继续wait.符合则执行。<br>很简单，将 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                syncTag.wait();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这部分代码 改为： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tsyncTag.wait();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个问题就解决了。</p>\n<h2 id=\"延伸：\"><a href=\"#延伸：\" class=\"headerlink\" title=\"延伸：\"></a><strong>延伸</strong>：</h2><p>假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：<br>设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO<br>这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们<br>中的一个。于是陷入死锁，无尽的等待。</p>\n<p>所以，具体使用notify还是notifyAll 就得具体情况具体分析了。</p>\n","excerpt":"","more":"<p>今天遇到了这么个情况：<br>有线程若干，我需要他们按顺序执行。<br>代码大概长这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SyncTag &#123;</div><div class=\"line\">\tpublic int threadNO;</div><div class=\"line\">\tpublic SyncTag() &#123;</div><div class=\"line\">\t    threadNO = 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class ThreadA extend Thread&#123;</div><div class=\"line\">\tSyncTag syncTag;</div><div class=\"line\">\tint scriptNO;</div><div class=\"line\">\tThreadA(SyncTag syncTag,int scriptNO)&#123;</div><div class=\"line\">\t\t\tthis.syncTag=syncTag;</div><div class=\"line\">\t\t\tthis.scriptNO=scriptNO;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void Run()&#123;</div><div class=\"line\">\t\t\tsynchronized (syncTag) &#123;</div><div class=\"line\">                if (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">                        try &#123;</div><div class=\"line\">                                syncTag.wait();</div><div class=\"line\">                        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                dosomething();</div><div class=\"line\">                syncTag.threadNO++;</div><div class=\"line\">                syncTag.notifyAll();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">public class Test&#123;</div><div class=\"line\">\tpublic static void main(String args[])&#123;</div><div class=\"line\">\t\t    SyncTag syncTag=new SyncTag();</div><div class=\"line\">\t\t\tfor(int i=0;i&lt;10;++i)&#123;</div><div class=\"line\">\t\t\t\tThreadA t=new ThreadA(syncTag,i);</div><div class=\"line\">\t\t\t\tt.start();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。<br>研究一番，发现是 notify 与notifyAll 在捣鬼。<br>当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。<br>其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。</p>\n<p>当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，<br>剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，<br>没抢到的老实等着。</p>\n<p>这就是notify 与 notifyAll两者的区别.</p>\n<p>那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。<br>原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合<br>syncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，<br>如果不符合，就继续wait.符合则执行。<br>很简单，将 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                syncTag.wait();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这部分代码 改为： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tsyncTag.wait();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个问题就解决了。</p>\n<h2 id=\"延伸：\"><a href=\"#延伸：\" class=\"headerlink\" title=\"延伸：\"></a><strong>延伸</strong>：</h2><p>假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：<br>设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO<br>这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们<br>中的一个。于是陷入死锁，无尽的等待。</p>\n<p>所以，具体使用notify还是notifyAll 就得具体情况具体分析了。</p>\n"},{"layout":"post","date":"2016-03-30T04:48:55.000Z","title":"sphinx安装问题","_content":"\n>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python\n 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。\n\n>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是\n Python2，Python3与Python2是不兼容的，在编码问题上报错。\n\n>遂改之，卸载Python3，安装Python2.问题来了。\n\n安装完Python2之后，使用 easy_install sphinx \n指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：\n\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 4-5: ordi al not in range(128)\n\n意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内\n，就会抛出异常（ordinal not in range(128)）。\n\n看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆\n.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。\n\n后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。\n\n首先所有修改的动作都是要创建一个叫 **sitecustomize.py**的文件，为什么要创建这个文件呢，是因为python在启动的时候会\n去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。\n\n修改默认字符编码的代码很简单就2行：\n\n```\n\n# sitecustomize.py                   # this file can be anywhere in your Python path,\n# but it usually goes in ${pythondir}/lib/site-packages/\nimport sys\nsys.setdefaultencoding('utf-8') \n\n```\n\n写完这个文件放哪里呢？\n\nwindows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 \n\nok,现在再次运行 easy_install sphinx ，可以通过安装了！\n\nps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。\n\n**参考**\n\n[解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误](http://wangye.org/blog/archives/629/)\n\n[永久修改python默认的字符编码为utf-8](http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html)       \n","source":"_posts/sphinx安装问题.md","raw":"---\nlayout: post\ndate:   2016-03-30 12:48:55\ntitle: \"sphinx安装问题\"\ncategories: 工具\ntags: \n- python\n- 编码\n---\n\n>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python\n 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。\n\n>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是\n Python2，Python3与Python2是不兼容的，在编码问题上报错。\n\n>遂改之，卸载Python3，安装Python2.问题来了。\n\n安装完Python2之后，使用 easy_install sphinx \n指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：\n\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 4-5: ordi al not in range(128)\n\n意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内\n，就会抛出异常（ordinal not in range(128)）。\n\n看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆\n.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。\n\n后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。\n\n首先所有修改的动作都是要创建一个叫 **sitecustomize.py**的文件，为什么要创建这个文件呢，是因为python在启动的时候会\n去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。\n\n修改默认字符编码的代码很简单就2行：\n\n```\n\n# sitecustomize.py                   # this file can be anywhere in your Python path,\n# but it usually goes in ${pythondir}/lib/site-packages/\nimport sys\nsys.setdefaultencoding('utf-8') \n\n```\n\n写完这个文件放哪里呢？\n\nwindows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 \n\nok,现在再次运行 easy_install sphinx ，可以通过安装了！\n\nps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。\n\n**参考**\n\n[解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误](http://wangye.org/blog/archives/629/)\n\n[永久修改python默认的字符编码为utf-8](http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html)       \n","slug":"sphinx安装问题","published":1,"updated":"2016-08-14T08:26:27.941Z","comments":1,"photos":[],"link":"","_id":"cisx6ponq0014zsqckm7bl98j","content":"<blockquote>\n<p>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python<br> 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。</p>\n<p>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是<br> Python2，Python3与Python2是不兼容的，在编码问题上报错。</p>\n<p>遂改之，卸载Python3，安装Python2.问题来了。</p>\n</blockquote>\n<p>安装完Python2之后，使用 easy_install sphinx<br>指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：</p>\n<p>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 4-5: ordi al not in range(128)</p>\n<p>意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内<br>，就会抛出异常（ordinal not in range(128)）。</p>\n<p>看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆<br>.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。</p>\n<p>后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。</p>\n<p>首先所有修改的动作都是要创建一个叫 <strong>sitecustomize.py</strong>的文件，为什么要创建这个文件呢，是因为python在启动的时候会<br>去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。</p>\n<p>修改默认字符编码的代码很简单就2行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># sitecustomize.py                   # this file can be anywhere in your Python path,</div><div class=\"line\"># but it usually goes in $&#123;pythondir&#125;/lib/site-packages/</div><div class=\"line\">import sys</div><div class=\"line\">sys.setdefaultencoding(&apos;utf-8&apos;)</div></pre></td></tr></table></figure>\n<p>写完这个文件放哪里呢？</p>\n<p>windows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 </p>\n<p>ok,现在再次运行 easy_install sphinx ，可以通过安装了！</p>\n<p>ps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"http://wangye.org/blog/archives/629/\" target=\"_blank\" rel=\"external\">解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html\" target=\"_blank\" rel=\"external\">永久修改python默认的字符编码为utf-8</a>       </p>\n","excerpt":"","more":"<blockquote>\n<p>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python<br> 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。</p>\n<p>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是<br> Python2，Python3与Python2是不兼容的，在编码问题上报错。</p>\n<p>遂改之，卸载Python3，安装Python2.问题来了。</p>\n</blockquote>\n<p>安装完Python2之后，使用 easy_install sphinx<br>指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：</p>\n<p>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 4-5: ordi al not in range(128)</p>\n<p>意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内<br>，就会抛出异常（ordinal not in range(128)）。</p>\n<p>看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆<br>.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。</p>\n<p>后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。</p>\n<p>首先所有修改的动作都是要创建一个叫 <strong>sitecustomize.py</strong>的文件，为什么要创建这个文件呢，是因为python在启动的时候会<br>去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。</p>\n<p>修改默认字符编码的代码很简单就2行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># sitecustomize.py                   # this file can be anywhere in your Python path,</div><div class=\"line\"># but it usually goes in $&#123;pythondir&#125;/lib/site-packages/</div><div class=\"line\">import sys</div><div class=\"line\">sys.setdefaultencoding(&apos;utf-8&apos;)</div></pre></td></tr></table></figure>\n<p>写完这个文件放哪里呢？</p>\n<p>windows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 </p>\n<p>ok,现在再次运行 easy_install sphinx ，可以通过安装了！</p>\n<p>ps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"http://wangye.org/blog/archives/629/\">解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html\">永久修改python默认的字符编码为utf-8</a>       </p>\n"},{"layout":"post","date":"2016-08-16T07:31:44.000Z","title":"synchronized的用法","comments":1,"_content":"\n>以前的工作过程中，偶尔会遇到synchronized的使用，比如[这篇总结](http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/)。今天来总结一下自己对synchronized的关键字的一些认识。\n\n## 同步锁\n\nsynchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。\n\n每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：\n\n```java\nsynchronized (object) {\n\t//doSomething...\t\t\n}\n```\n\n上面的 '{' '}' 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。\n\n## synchronized修饰代码块\n\n### synchronized同步锁为普通对象\n\n```java\npublic void function(){\n\tsynchronized (object) {\n\t\t//doSomething...\t\t\n\t}\n}\n```\n当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。\n\n下面的例子：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(new Object());\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n运行结果：\n\n```\nThread-0运行中...\nThread-1运行中...\nThread-2运行中...\nThread-3运行中...\nThread-4运行中...\nThread-1结束...\nThread-0结束...\nThread-3结束...\nThread-4结束...\nThread-2结束...\n```\n\n跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tObject object = new Object();\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(object);\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```java\nThread-0运行中...\nThread-0结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。\n\n重点要理解：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**\n\n### synchronized同步锁为类\n\n类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。\n\n将上面的例子修改一下：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-0结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\n```\n这些线程同样实现了同步，因为他们的同步锁是同一个对象--SyncTest类对象。\n\n需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\tSync1 sync1 = new Sync1(new SyncTest());\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t\t\n\t\tsync1.start();\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n\nclass Sync1 extends Thread{\n\tSyncTest syncTest;\n\tpublic Sync1(SyncTest syncTest){\n\t\tthis.syncTest = syncTest;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncTest) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-5运行中...\nThread-0结束...\nThread-5结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。\n\n## synchronized修饰方法\n\nsynchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。\n\n### synchronized修饰普通方法\n\n```java\npublic synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\nsynchronized修饰普通方法中的同步锁就是这个对象本身，即\"this\"。\n\n下面的代码：\n\n```java\nclass Sync extends Thread{\n\tpublic synchronized void syncFunction(){\n\t\tdoSomething();\n\t}\n\t\n\tpublic void syncFunction2(){\n\t\tsynchronized (this) {\n\t\t\tdoSomething();\n\t\t}\n\t}\n\t\n\tprivate void doSomething(){\n\t\t//doSomething...\n\t}\n}\n```\n\n上面syncFunction()与syncFunction2()实现的同步效果是一样的。\n\n当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的\"this\"。\n\n### synchronized修饰静态方法\n\n```java\npublic static synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\n同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。\n\n不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。\n\n## 总结\n\n理解synchronized的关键就在于：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**这个同步锁，可以理解为一个对象。","source":"_posts/synchronized的一些用法.md","raw":"---\nlayout: post\ndate: 2016-08-16 15:31:44\ncategories: 编程\ntitle: synchronized的用法\ntags: \n- 多线程\n- java\ncomments: true\n---\n\n>以前的工作过程中，偶尔会遇到synchronized的使用，比如[这篇总结](http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/)。今天来总结一下自己对synchronized的关键字的一些认识。\n\n## 同步锁\n\nsynchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。\n\n每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：\n\n```java\nsynchronized (object) {\n\t//doSomething...\t\t\n}\n```\n\n上面的 '{' '}' 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。\n\n## synchronized修饰代码块\n\n### synchronized同步锁为普通对象\n\n```java\npublic void function(){\n\tsynchronized (object) {\n\t\t//doSomething...\t\t\n\t}\n}\n```\n当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。\n\n下面的例子：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(new Object());\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n运行结果：\n\n```\nThread-0运行中...\nThread-1运行中...\nThread-2运行中...\nThread-3运行中...\nThread-4运行中...\nThread-1结束...\nThread-0结束...\nThread-3结束...\nThread-4结束...\nThread-2结束...\n```\n\n跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tObject object = new Object();\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(object);\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```java\nThread-0运行中...\nThread-0结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。\n\n重点要理解：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**\n\n### synchronized同步锁为类\n\n类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。\n\n将上面的例子修改一下：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-0结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\n```\n这些线程同样实现了同步，因为他们的同步锁是同一个对象--SyncTest类对象。\n\n需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\tSync1 sync1 = new Sync1(new SyncTest());\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t\t\n\t\tsync1.start();\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n\nclass Sync1 extends Thread{\n\tSyncTest syncTest;\n\tpublic Sync1(SyncTest syncTest){\n\t\tthis.syncTest = syncTest;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncTest) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-5运行中...\nThread-0结束...\nThread-5结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。\n\n## synchronized修饰方法\n\nsynchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。\n\n### synchronized修饰普通方法\n\n```java\npublic synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\nsynchronized修饰普通方法中的同步锁就是这个对象本身，即\"this\"。\n\n下面的代码：\n\n```java\nclass Sync extends Thread{\n\tpublic synchronized void syncFunction(){\n\t\tdoSomething();\n\t}\n\t\n\tpublic void syncFunction2(){\n\t\tsynchronized (this) {\n\t\t\tdoSomething();\n\t\t}\n\t}\n\t\n\tprivate void doSomething(){\n\t\t//doSomething...\n\t}\n}\n```\n\n上面syncFunction()与syncFunction2()实现的同步效果是一样的。\n\n当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的\"this\"。\n\n### synchronized修饰静态方法\n\n```java\npublic static synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\n同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。\n\n不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。\n\n## 总结\n\n理解synchronized的关键就在于：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**这个同步锁，可以理解为一个对象。","slug":"synchronized的一些用法","published":1,"updated":"2016-08-16T12:34:10.585Z","photos":[],"link":"","_id":"cisx6ponq0016zsqc5m8zqqst","content":"<blockquote>\n<p>以前的工作过程中，偶尔会遇到synchronized的使用，比如<a href=\"http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/\">这篇总结</a>。今天来总结一下自己对synchronized的关键字的一些认识。</p>\n</blockquote>\n<h2 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h2><p>synchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。</p>\n<p>每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的 ‘{‘ ‘}’ 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p>\n<h2 id=\"synchronized修饰代码块\"><a href=\"#synchronized修饰代码块\" class=\"headerlink\" title=\"synchronized修饰代码块\"></a>synchronized修饰代码块</h2><h3 id=\"synchronized同步锁为普通对象\"><a href=\"#synchronized同步锁为普通对象\" class=\"headerlink\" title=\"synchronized同步锁为普通对象\"></a>synchronized同步锁为普通对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。</p>\n<p>下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(<span class=\"keyword\">new</span> Object());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\tObject object = <span class=\"keyword\">new</span> Object();</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(object);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-<span class=\"number\">0</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">0</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">4</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">4</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">2</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">2</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">3</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">3</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">1</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">1</span>结束...</div></pre></td></tr></table></figure>\n<p>5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。</p>\n<p>重点要理解：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong></p>\n<h3 id=\"synchronized同步锁为类\"><a href=\"#synchronized同步锁为类\" class=\"headerlink\" title=\"synchronized同步锁为类\"></a>synchronized同步锁为类</h3><p>类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。</p>\n<p>将上面的例子修改一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>这些线程同样实现了同步，因为他们的同步锁是同一个对象–SyncTest类对象。</p>\n<p>需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSync1 sync1 = <span class=\"keyword\">new</span> Sync1(<span class=\"keyword\">new</span> SyncTest());</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsync1.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tSyncTest syncTest;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync1</span><span class=\"params\">(SyncTest syncTest)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncTest = syncTest;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncTest) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-5运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-5结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div></pre></td></tr></table></figure>\n<p>可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。</p>\n<h2 id=\"synchronized修饰方法\"><a href=\"#synchronized修饰方法\" class=\"headerlink\" title=\"synchronized修饰方法\"></a>synchronized修饰方法</h2><p>synchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。</p>\n<h3 id=\"synchronized修饰普通方法\"><a href=\"#synchronized修饰普通方法\" class=\"headerlink\" title=\"synchronized修饰普通方法\"></a>synchronized修饰普通方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>synchronized修饰普通方法中的同步锁就是这个对象本身，即”this”。</p>\n<p>下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tdoSomething();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\tdoSomething();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面syncFunction()与syncFunction2()实现的同步效果是一样的。</p>\n<p>当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的”this”。</p>\n<h3 id=\"synchronized修饰静态方法\"><a href=\"#synchronized修饰静态方法\" class=\"headerlink\" title=\"synchronized修饰静态方法\"></a>synchronized修饰静态方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。</p>\n<p>不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>理解synchronized的关键就在于：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong>这个同步锁，可以理解为一个对象。</p>\n","excerpt":"","more":"<blockquote>\n<p>以前的工作过程中，偶尔会遇到synchronized的使用，比如<a href=\"http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/\">这篇总结</a>。今天来总结一下自己对synchronized的关键字的一些认识。</p>\n</blockquote>\n<h2 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h2><p>synchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。</p>\n<p>每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的 ‘{‘ ‘}’ 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p>\n<h2 id=\"synchronized修饰代码块\"><a href=\"#synchronized修饰代码块\" class=\"headerlink\" title=\"synchronized修饰代码块\"></a>synchronized修饰代码块</h2><h3 id=\"synchronized同步锁为普通对象\"><a href=\"#synchronized同步锁为普通对象\" class=\"headerlink\" title=\"synchronized同步锁为普通对象\"></a>synchronized同步锁为普通对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。</p>\n<p>下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(<span class=\"keyword\">new</span> Object());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\tObject object = <span class=\"keyword\">new</span> Object();</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(object);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-<span class=\"number\">0</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">0</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">4</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">4</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">2</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">2</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">3</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">3</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">1</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">1</span>结束...</div></pre></td></tr></table></figure>\n<p>5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。</p>\n<p>重点要理解：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong></p>\n<h3 id=\"synchronized同步锁为类\"><a href=\"#synchronized同步锁为类\" class=\"headerlink\" title=\"synchronized同步锁为类\"></a>synchronized同步锁为类</h3><p>类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。</p>\n<p>将上面的例子修改一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>这些线程同样实现了同步，因为他们的同步锁是同一个对象–SyncTest类对象。</p>\n<p>需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSync1 sync1 = <span class=\"keyword\">new</span> Sync1(<span class=\"keyword\">new</span> SyncTest());</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsync1.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tSyncTest syncTest;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync1</span><span class=\"params\">(SyncTest syncTest)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncTest = syncTest;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncTest) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-5运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-5结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div></pre></td></tr></table></figure>\n<p>可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。</p>\n<h2 id=\"synchronized修饰方法\"><a href=\"#synchronized修饰方法\" class=\"headerlink\" title=\"synchronized修饰方法\"></a>synchronized修饰方法</h2><p>synchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。</p>\n<h3 id=\"synchronized修饰普通方法\"><a href=\"#synchronized修饰普通方法\" class=\"headerlink\" title=\"synchronized修饰普通方法\"></a>synchronized修饰普通方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>synchronized修饰普通方法中的同步锁就是这个对象本身，即”this”。</p>\n<p>下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tdoSomething();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\tdoSomething();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面syncFunction()与syncFunction2()实现的同步效果是一样的。</p>\n<p>当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的”this”。</p>\n<h3 id=\"synchronized修饰静态方法\"><a href=\"#synchronized修饰静态方法\" class=\"headerlink\" title=\"synchronized修饰静态方法\"></a>synchronized修饰静态方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。</p>\n<p>不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>理解synchronized的关键就在于：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong>这个同步锁，可以理解为一个对象。</p>\n"},{"layout":"post","date":"2016-08-15T06:54:55.000Z","title":"一些计划","comments":0,"_content":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe>\n转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。\n\n上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的[作者](https://github.com/A-limon/pacman)，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名[www.yukai.space](www.yukai.space)作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。\n\n## 关于学习\n\n程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：\n\n### java\n\n吃饭的家伙，必须得用好了。虽然用java写过不少\"小DEMO\",但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：\n\n- Thinking In Java\n\n- Effect Java\n\n- 大话设计模式\n\n- 深入理解Jvm虚拟机\n\n- 重构：改善既有的代码\n\n前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。\n\n### Linux\n\n一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。\n\n从 鸟哥的Linux私房菜 开始吧。\n\n### Groovy\n\n第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。\n\n### 数据库\n\n说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把<<数据库系统概论>>通读一遍吧。贪多嚼不烂。\n\n以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。\n\n## 关于减肥\n\n确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：\n\n腹肌轮：80\n\n卷腹：50\n\n哑铃深蹲：40\n\n俯卧撑：80\n\n其他健身动作：若干\n\n跑步：一周至少三次\n\n## 关于理财\n\n写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。\n\n写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。\n\n以上","source":"_posts/一些计划.md","raw":"---\nlayout: post\ndate: 2016-08-15 14:54:55\ncategories: 生活\ntitle: 一些计划\ncomments: false\n---\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe>\n转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。\n\n上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的[作者](https://github.com/A-limon/pacman)，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名[www.yukai.space](www.yukai.space)作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。\n\n## 关于学习\n\n程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：\n\n### java\n\n吃饭的家伙，必须得用好了。虽然用java写过不少\"小DEMO\",但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：\n\n- Thinking In Java\n\n- Effect Java\n\n- 大话设计模式\n\n- 深入理解Jvm虚拟机\n\n- 重构：改善既有的代码\n\n前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。\n\n### Linux\n\n一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。\n\n从 鸟哥的Linux私房菜 开始吧。\n\n### Groovy\n\n第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。\n\n### 数据库\n\n说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把<<数据库系统概论>>通读一遍吧。贪多嚼不烂。\n\n以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。\n\n## 关于减肥\n\n确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：\n\n腹肌轮：80\n\n卷腹：50\n\n哑铃深蹲：40\n\n俯卧撑：80\n\n其他健身动作：若干\n\n跑步：一周至少三次\n\n## 关于理财\n\n写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。\n\n写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。\n\n以上","slug":"一些计划","published":1,"updated":"2016-08-22T15:42:50.697Z","photos":[],"link":"","_id":"cisx6ponq0019zsqc514htfm9","content":"<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe><br>转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。</p>\n<p>上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的<a href=\"https://github.com/A-limon/pacman\" target=\"_blank\" rel=\"external\">作者</a>，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名<a href=\"www.yukai.space\">www.yukai.space</a>作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。</p>\n<h2 id=\"关于学习\"><a href=\"#关于学习\" class=\"headerlink\" title=\"关于学习\"></a>关于学习</h2><p>程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：</p>\n<h3 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h3><p>吃饭的家伙，必须得用好了。虽然用java写过不少”小DEMO”,但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：</p>\n<ul>\n<li><p>Thinking In Java</p>\n</li>\n<li><p>Effect Java</p>\n</li>\n<li><p>大话设计模式</p>\n</li>\n<li><p>深入理解Jvm虚拟机</p>\n</li>\n<li><p>重构：改善既有的代码</p>\n</li>\n</ul>\n<p>前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。</p>\n<h3 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h3><p>一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。</p>\n<p>从 鸟哥的Linux私房菜 开始吧。</p>\n<h3 id=\"Groovy\"><a href=\"#Groovy\" class=\"headerlink\" title=\"Groovy\"></a>Groovy</h3><p>第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。</p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把&lt;&lt;数据库系统概论&gt;&gt;通读一遍吧。贪多嚼不烂。</p>\n<p>以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。</p>\n<h2 id=\"关于减肥\"><a href=\"#关于减肥\" class=\"headerlink\" title=\"关于减肥\"></a>关于减肥</h2><p>确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：</p>\n<p>腹肌轮：80</p>\n<p>卷腹：50</p>\n<p>哑铃深蹲：40</p>\n<p>俯卧撑：80</p>\n<p>其他健身动作：若干</p>\n<p>跑步：一周至少三次</p>\n<h2 id=\"关于理财\"><a href=\"#关于理财\" class=\"headerlink\" title=\"关于理财\"></a>关于理财</h2><p>写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。</p>\n<p>写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。</p>\n<p>以上</p>\n","excerpt":"","more":"<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe><br>转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。</p>\n<p>上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的<a href=\"https://github.com/A-limon/pacman\">作者</a>，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名<a href=\"www.yukai.space\">www.yukai.space</a>作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。</p>\n<h2 id=\"关于学习\"><a href=\"#关于学习\" class=\"headerlink\" title=\"关于学习\"></a>关于学习</h2><p>程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：</p>\n<h3 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h3><p>吃饭的家伙，必须得用好了。虽然用java写过不少”小DEMO”,但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：</p>\n<ul>\n<li><p>Thinking In Java</p>\n</li>\n<li><p>Effect Java</p>\n</li>\n<li><p>大话设计模式</p>\n</li>\n<li><p>深入理解Jvm虚拟机</p>\n</li>\n<li><p>重构：改善既有的代码</p>\n</li>\n</ul>\n<p>前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。</p>\n<h3 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h3><p>一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。</p>\n<p>从 鸟哥的Linux私房菜 开始吧。</p>\n<h3 id=\"Groovy\"><a href=\"#Groovy\" class=\"headerlink\" title=\"Groovy\"></a>Groovy</h3><p>第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。</p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把&lt;&lt;数据库系统概论&gt;&gt;通读一遍吧。贪多嚼不烂。</p>\n<p>以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。</p>\n<h2 id=\"关于减肥\"><a href=\"#关于减肥\" class=\"headerlink\" title=\"关于减肥\"></a>关于减肥</h2><p>确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：</p>\n<p>腹肌轮：80</p>\n<p>卷腹：50</p>\n<p>哑铃深蹲：40</p>\n<p>俯卧撑：80</p>\n<p>其他健身动作：若干</p>\n<p>跑步：一周至少三次</p>\n<h2 id=\"关于理财\"><a href=\"#关于理财\" class=\"headerlink\" title=\"关于理财\"></a>关于理财</h2><p>写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。</p>\n<p>写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。</p>\n<p>以上</p>\n"},{"layout":"post","date":"2016-07-31T09:30:55.000Z","title":"为什么是final","_content":"\n>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。\n\n注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。\n\n例子是这样的：\n\n```java\npublic class Outer {\n\tprivate int outerVar=0;\n\tpublic void testInner(final String paramVal){\n\t\tfinal Integer localVal = 1;\n\t\tInner inner = new Inner(){\n\t\t\t@Override\n\t\t\tpublic void doSomething() {\n\t\t\t\tSystem.out.println(localVal+paramVal);\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tfinal int localVal1 = 2;\n\t\tclass Inner2{\n\t\t\tpublic void testInner2(){\n\t\t\t\tSystem.out.println(localVal1);\n\t\t\t}\n\t\t}\n\t}\n\tinterface Inner{\n\t\tpublic void doSomething();\n\t}\n\tpublic static void main(String args[]){\n\t\tOuter outer = new Outer();\n\t\touter.testInner(\"hello\");\n\t}\n}\n```\n\n可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。\n\n后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。\n\n我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）\n\n但是确实生成了这样几个.class文件：\n\nOuter.class:class Outer\n\nOuter$1.class:匿名内部类 new Inner(){...}\n\nOuter$1Inner2.class:class Inner2\n\nOuter$Inner.class:interface Inner\n\n这说明，匿名内部类与他的外围类之间确实是相互独立的。\n\n为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：\n\n```java\nclass kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner {\n  final java.lang.Integer val$localVar;\n\n  final java.lang.String val$paramVal;\n\n  final kyu.java.util.Outer this$0;\n\n  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);\n    Code:\n       0: aload_0\n       1: aload_1\n       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;\n       5: aload_0\n       6: aload_2\n       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;\n      10: aload_0\n      11: aload_3\n      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;\n      15: aload_0\n      16: invokespecial #4                  // Method java/lang/Object.\"<init>\":()V\n      19: return\n\n      .....\n }\n```\n\n上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参\n。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。\n\n所以，现在有两个问题：\n\n- **为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？**\n\n我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。\n\n- **局部变量或形参为什么必须是final类型？**\n\n在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。\n\n```java\nfinal Integer localVal = 1;\nInner inner = new Inner(){\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(localVar+paramVal);\n\t}\n};\n```\n\n这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。\n\nps:后来在stackoverflow上看到[Why are only final variables accessible in anonymous class?](http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class)，可以参考一下。","source":"_posts/为什么是final.md","raw":"---\nlayout: post\ndate:   2016-07-31 17:30:55\ntitle: \"为什么是final\"\ncategories: 编程\ntags: \n- java\n---\n\n>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。\n\n注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。\n\n例子是这样的：\n\n```java\npublic class Outer {\n\tprivate int outerVar=0;\n\tpublic void testInner(final String paramVal){\n\t\tfinal Integer localVal = 1;\n\t\tInner inner = new Inner(){\n\t\t\t@Override\n\t\t\tpublic void doSomething() {\n\t\t\t\tSystem.out.println(localVal+paramVal);\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tfinal int localVal1 = 2;\n\t\tclass Inner2{\n\t\t\tpublic void testInner2(){\n\t\t\t\tSystem.out.println(localVal1);\n\t\t\t}\n\t\t}\n\t}\n\tinterface Inner{\n\t\tpublic void doSomething();\n\t}\n\tpublic static void main(String args[]){\n\t\tOuter outer = new Outer();\n\t\touter.testInner(\"hello\");\n\t}\n}\n```\n\n可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。\n\n后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。\n\n我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）\n\n但是确实生成了这样几个.class文件：\n\nOuter.class:class Outer\n\nOuter$1.class:匿名内部类 new Inner(){...}\n\nOuter$1Inner2.class:class Inner2\n\nOuter$Inner.class:interface Inner\n\n这说明，匿名内部类与他的外围类之间确实是相互独立的。\n\n为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：\n\n```java\nclass kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner {\n  final java.lang.Integer val$localVar;\n\n  final java.lang.String val$paramVal;\n\n  final kyu.java.util.Outer this$0;\n\n  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);\n    Code:\n       0: aload_0\n       1: aload_1\n       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;\n       5: aload_0\n       6: aload_2\n       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;\n      10: aload_0\n      11: aload_3\n      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;\n      15: aload_0\n      16: invokespecial #4                  // Method java/lang/Object.\"<init>\":()V\n      19: return\n\n      .....\n }\n```\n\n上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参\n。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。\n\n所以，现在有两个问题：\n\n- **为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？**\n\n我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。\n\n- **局部变量或形参为什么必须是final类型？**\n\n在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。\n\n```java\nfinal Integer localVal = 1;\nInner inner = new Inner(){\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(localVar+paramVal);\n\t}\n};\n```\n\n这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。\n\nps:后来在stackoverflow上看到[Why are only final variables accessible in anonymous class?](http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class)，可以参考一下。","slug":"为什么是final","published":1,"updated":"2016-08-14T08:26:27.942Z","comments":1,"photos":[],"link":"","_id":"cisx6poo5001czsqcmnn3f5t0","content":"<blockquote>\n<p>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。</p>\n</blockquote>\n<p>注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。</p>\n<p>例子是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> outerVar=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner</span><span class=\"params\">(<span class=\"keyword\">final</span> String paramVal)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">\t\tInner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal+paramVal);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localVal1 = <span class=\"number\">2</span>;</div><div class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner2</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal1);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Inner</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tOuter outer = <span class=\"keyword\">new</span> Outer();</div><div class=\"line\">\t\touter.testInner(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。</p>\n<p>后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。</p>\n<p>我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）</p>\n<p>但是确实生成了这样几个.class文件：</p>\n<p>Outer.class:class Outer</p>\n<p>Outer$1.class:匿名内部类 new Inner(){…}</p>\n<p>Outer$1Inner2.class:class Inner2</p>\n<p>Outer$Inner.class:interface Inner</p>\n<p>这说明，匿名内部类与他的外围类之间确实是相互独立的。</p>\n<p>为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner &#123;</div><div class=\"line\">  final java.lang.Integer val$localVar;</div><div class=\"line\"></div><div class=\"line\">  final java.lang.String val$paramVal;</div><div class=\"line\"></div><div class=\"line\">  final kyu.java.util.Outer this$0;</div><div class=\"line\"></div><div class=\"line\">  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);</div><div class=\"line\">    Code:</div><div class=\"line\">       0: aload_0</div><div class=\"line\">       1: aload_1</div><div class=\"line\">       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;</div><div class=\"line\">       5: aload_0</div><div class=\"line\">       6: aload_2</div><div class=\"line\">       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;</div><div class=\"line\">      10: aload_0</div><div class=\"line\">      11: aload_3</div><div class=\"line\">      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;</div><div class=\"line\">      15: aload_0</div><div class=\"line\">      16: invokespecial #4                  // Method java/lang/Object.\"&lt;init&gt;\":()V</div><div class=\"line\">      19: return</div><div class=\"line\"></div><div class=\"line\">      .....</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参<br>。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。</p>\n<p>所以，现在有两个问题：</p>\n<ul>\n<li><strong>为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？</strong></li>\n</ul>\n<p>我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。</p>\n<ul>\n<li><strong>局部变量或形参为什么必须是final类型？</strong></li>\n</ul>\n<p>在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">Inner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(localVar+paramVal);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。</p>\n<p>ps:后来在stackoverflow上看到<a href=\"http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class\" target=\"_blank\" rel=\"external\">Why are only final variables accessible in anonymous class?</a>，可以参考一下。</p>\n","excerpt":"","more":"<blockquote>\n<p>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。</p>\n</blockquote>\n<p>注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。</p>\n<p>例子是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> outerVar=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner</span><span class=\"params\">(<span class=\"keyword\">final</span> String paramVal)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">\t\tInner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal+paramVal);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localVal1 = <span class=\"number\">2</span>;</div><div class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner2</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal1);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Inner</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tOuter outer = <span class=\"keyword\">new</span> Outer();</div><div class=\"line\">\t\touter.testInner(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。</p>\n<p>后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。</p>\n<p>我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）</p>\n<p>但是确实生成了这样几个.class文件：</p>\n<p>Outer.class:class Outer</p>\n<p>Outer$1.class:匿名内部类 new Inner(){…}</p>\n<p>Outer$1Inner2.class:class Inner2</p>\n<p>Outer$Inner.class:interface Inner</p>\n<p>这说明，匿名内部类与他的外围类之间确实是相互独立的。</p>\n<p>为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner &#123;</div><div class=\"line\">  final java.lang.Integer val$localVar;</div><div class=\"line\"></div><div class=\"line\">  final java.lang.String val$paramVal;</div><div class=\"line\"></div><div class=\"line\">  final kyu.java.util.Outer this$0;</div><div class=\"line\"></div><div class=\"line\">  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);</div><div class=\"line\">    Code:</div><div class=\"line\">       0: aload_0</div><div class=\"line\">       1: aload_1</div><div class=\"line\">       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;</div><div class=\"line\">       5: aload_0</div><div class=\"line\">       6: aload_2</div><div class=\"line\">       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;</div><div class=\"line\">      10: aload_0</div><div class=\"line\">      11: aload_3</div><div class=\"line\">      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;</div><div class=\"line\">      15: aload_0</div><div class=\"line\">      16: invokespecial #4                  // Method java/lang/Object.\"&lt;init&gt;\":()V</div><div class=\"line\">      19: return</div><div class=\"line\"></div><div class=\"line\">      .....</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参<br>。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。</p>\n<p>所以，现在有两个问题：</p>\n<ul>\n<li><strong>为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？</strong></li>\n</ul>\n<p>我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。</p>\n<ul>\n<li><strong>局部变量或形参为什么必须是final类型？</strong></li>\n</ul>\n<p>在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">Inner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(localVar+paramVal);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。</p>\n<p>ps:后来在stackoverflow上看到<a href=\"http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class\">Why are only final variables accessible in anonymous class?</a>，可以参考一下。</p>\n"},{"layout":"post","date":"2016-04-14T05:48:55.000Z","title":"他可是科比布莱恩特","_content":"<center>\n\t<iframe \n\t\twidth=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen>\n\t</iframe>\n</center>\nwhat can i say, Mamba out！\n\n{% asset_img kobe.jpg 科比 %}\n\n\n\n","source":"_posts/他可是科比·布莱恩特!.md","raw":"---\nlayout: post\ndate:   2016-04-14 13:48:55\ntitle: \"他可是科比布莱恩特\"\ncategories: 生活\n---\n<center>\n\t<iframe \n\t\twidth=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen>\n\t</iframe>\n</center>\nwhat can i say, Mamba out！\n\n{% asset_img kobe.jpg 科比 %}\n\n\n\n","slug":"他可是科比·布莱恩特!","published":1,"updated":"2016-08-14T08:26:27.943Z","comments":1,"photos":[],"link":"","_id":"cisx6poo5001hzsqczh2vrgrq","content":"<p><center><br>    <iframe width=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen><br>    </iframe><br></center><br>what can i say, Mamba out！</p>\n<img src=\"/2016/04/14/他可是科比·布莱恩特!/kobe.jpg\" alt=\"科比\" title=\"科比\">\n","excerpt":"","more":"<p><center><br>    <iframe \n        width=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen><br>    </iframe><br></center><br>what can i say, Mamba out！</p>\n<img src=\"/2016/04/14/他可是科比·布莱恩特!/kobe.jpg\" alt=\"科比\" title=\"科比\">\n"},{"layout":"post","title":"关于加密的一点总结","date":"2016-08-22T12:59:00.000Z","_content":"前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。\n\n## 信息摘要算法\n\n### 简介\n\n验证用户名密码的整个过程主要使用了MD5算法。严格来说，[MD5](https://zh.wikipedia.org/wiki/MD5)不是一种加密算法，而是一种信息摘要算法。\n\n所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在[这篇](http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/)总结中提到过。简单来说，就是把给出的\"信息\"经过哈希之后得到的值，就是这些内容的\"摘要\"。\n\n### 特点\n\n信息摘要算法有这样几个特点：\n\n1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。\n\n2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个[提问](http://www.zhihu.com/question/22651987).\n\n3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。\n\n满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？\n\n1.一致性检验。\n\n我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。\n\n下面是jdk-7u79对应的MD5校验值，从[官方网站](https://www.oracle.com/webfolder/s/digest/7u79checksum.html)截图。\n\n{% asset_img md5.png MD5 %}\n\n2.数字签名\n\n其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。\n\n3.登陆验证\n\n模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回success\n\n3.客户端将密码经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。\n\n那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 [加盐](https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6) 的手段来保证我们密码的安全。\n\n所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。\n\n使用加盐手段后，上面的验证过程改为如下：\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt\n\n3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。\n\n### java中的MD5\n\n```java\npublic static String stringMD5(String input) {  \n  \n   try {    \n      // 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    \n      MessageDigest messageDigest =MessageDigest.getInstance(\"MD5\");  \n      // 输入的字符串转换成字节数组  \n      byte[] inputByteArray = input.getBytes();  \n  \n      // inputByteArray是输入字符串转换得到的字节数组  \n      messageDigest.update(inputByteArray);      \n  \n      // 转换并返回结果，也是字节数组，包含16个元素  \n      byte[] resultByteArray = messageDigest.digest();  \n    \n      // 字符数组转换成字符串返回  \n      return byteArrayToHex(resultByteArray);           \n   } catch (NoSuchAlgorithmException e) {   \n      return null;    \n   }  \n  \n}  \n\npublic static String byteArrayToHex(byte[] byteArray) {    \n   // 首先初始化一个字符数组，用来存放每个16进制字符    \n   char[] hexDigits = {'0','1','2','3','4','5','6','7','8','9', 'A','B','C','D','E','F' };  \n    \n   // new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    \n   char[] resultCharArray =new char[byteArray.length * 2];   \n  \n   // 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    \n   int index = 0;    \n   int pos,tmp;\n   for (byte b : byteArray) {   \n   \t  //当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！\n   \t  //为便于理解，此处对原文进行修改\n   \t  int tmp = b & 0xFF;\n   \t  pos = tmp >> 4;//得到低四位\n      resultCharArray[index++] = hexDigits[pos];  \n      pos = tmp & 0xF;//得到高四位\n      resultCharArray[index++] = hexDigits[pos];   \n   }    \n  \n   // 字符数组组合成字符串返回   \n   return new String(resultCharArray);  \n}\n```\n代码参考自[叉叉哥的BLOG](http://blog.csdn.net/xiao__gui/article/details/8148203)\n\n\n## 数字签名\n\n前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。\n\n首先了解一下两个概念：[对称加密](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86)和[非对称加密](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)。\n\n对称加密，就是信息加密解密使用相同的密钥。\n\n非对称加密，有两种密钥，公钥和私钥。\n\n公钥私钥满足以下几个特点：\n\n1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。\n\n2.顾名思义，公钥是可以公开的，而私钥是不公开的。\n\n3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。\n\n4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容\n\n5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。\n\n与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。\n\n下面看一下数字签名使用过程：\n\n1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。\n\n2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的**身份认证**。\n\n3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了**信息完整性**（一致性检验）。\n\n上面的过程能够得出数字签名的作用：**身份认证**与**完整性检验**\n\n使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。\n\n## 数字证书\n\n数字证书是用来解决公钥从哪里来的问题。\n\n可能有以下两种方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了\n\n所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。\n\n关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。\n\n## 参考\n\n网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。\n\n以下内容来自[无恙-数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html) http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n2、一个加密通信过程的演化\n\n我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：\n\n2.1 第一回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：？？？？\n\n因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”\n\n“黑客”->“客户”：你好，我是服务器\n\n因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：\n\n \n\n2.2 第二回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n      // 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n\n为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。\n\n“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。\n\n假设“黑客”想冒充“服务器”：\n\n“黑客”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。\n\n“客户”->“黑客”：？？？？\n\n由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！\n\n到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：\n\n \n\n2.3 第三回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]\n\n“服务器”->“客户”：{你的余额是100元}[私钥|RSA]\n\n注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。\n\n这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：\n\n \n\n2.4 第四回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。\n\n“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]\n\n在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。\n\n由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。\n\n \n\n总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：\n\n因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。\n客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。\n如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)\n\n到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。\n\n \n\n但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：\n\n“客户”->“黑客”：你好           //黑客截获“客户”发给“服务器”的消息\n\n“黑客”->“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”\n\n因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。\n\n为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：\n\n证书的发布机构\n证书的有效期\n公钥\n证书所有者（Subject）\n签名所使用的算法\n指纹以及指纹算法\n证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：\n\n \n\n2.5 第五回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：\n\n \n\n2.6 完整过程：\n\nstep1： “客户”向服务端发送一个通信请求\n\n“客户”->“服务器”：你好\n\n  \n\nstep2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 \n\n \n\nstep3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。\n\n“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。\n\n“服务器”->“客户”：{一个随机字符串}[私钥|RSA]\n\n \n\nstep4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。\n\n“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]\n\n…… //继续其它的通信\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n另外，也可以看看这篇博客：[阮一峰-数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)\n\n\n\n\n\n\n\n\n","source":"_posts/关于加密的一点总结.md","raw":"layout: post\ntitle: 关于加密的一点总结\ndate: 2016-08-22 20:59:00\ncategories: 技术\ntags: 加密\n---\n前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。\n\n## 信息摘要算法\n\n### 简介\n\n验证用户名密码的整个过程主要使用了MD5算法。严格来说，[MD5](https://zh.wikipedia.org/wiki/MD5)不是一种加密算法，而是一种信息摘要算法。\n\n所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在[这篇](http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/)总结中提到过。简单来说，就是把给出的\"信息\"经过哈希之后得到的值，就是这些内容的\"摘要\"。\n\n### 特点\n\n信息摘要算法有这样几个特点：\n\n1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。\n\n2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个[提问](http://www.zhihu.com/question/22651987).\n\n3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。\n\n满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？\n\n1.一致性检验。\n\n我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。\n\n下面是jdk-7u79对应的MD5校验值，从[官方网站](https://www.oracle.com/webfolder/s/digest/7u79checksum.html)截图。\n\n{% asset_img md5.png MD5 %}\n\n2.数字签名\n\n其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。\n\n3.登陆验证\n\n模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回success\n\n3.客户端将密码经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。\n\n那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 [加盐](https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6) 的手段来保证我们密码的安全。\n\n所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。\n\n使用加盐手段后，上面的验证过程改为如下：\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt\n\n3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。\n\n### java中的MD5\n\n```java\npublic static String stringMD5(String input) {  \n  \n   try {    \n      // 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    \n      MessageDigest messageDigest =MessageDigest.getInstance(\"MD5\");  \n      // 输入的字符串转换成字节数组  \n      byte[] inputByteArray = input.getBytes();  \n  \n      // inputByteArray是输入字符串转换得到的字节数组  \n      messageDigest.update(inputByteArray);      \n  \n      // 转换并返回结果，也是字节数组，包含16个元素  \n      byte[] resultByteArray = messageDigest.digest();  \n    \n      // 字符数组转换成字符串返回  \n      return byteArrayToHex(resultByteArray);           \n   } catch (NoSuchAlgorithmException e) {   \n      return null;    \n   }  \n  \n}  \n\npublic static String byteArrayToHex(byte[] byteArray) {    \n   // 首先初始化一个字符数组，用来存放每个16进制字符    \n   char[] hexDigits = {'0','1','2','3','4','5','6','7','8','9', 'A','B','C','D','E','F' };  \n    \n   // new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    \n   char[] resultCharArray =new char[byteArray.length * 2];   \n  \n   // 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    \n   int index = 0;    \n   int pos,tmp;\n   for (byte b : byteArray) {   \n   \t  //当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！\n   \t  //为便于理解，此处对原文进行修改\n   \t  int tmp = b & 0xFF;\n   \t  pos = tmp >> 4;//得到低四位\n      resultCharArray[index++] = hexDigits[pos];  \n      pos = tmp & 0xF;//得到高四位\n      resultCharArray[index++] = hexDigits[pos];   \n   }    \n  \n   // 字符数组组合成字符串返回   \n   return new String(resultCharArray);  \n}\n```\n代码参考自[叉叉哥的BLOG](http://blog.csdn.net/xiao__gui/article/details/8148203)\n\n\n## 数字签名\n\n前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。\n\n首先了解一下两个概念：[对称加密](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86)和[非对称加密](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)。\n\n对称加密，就是信息加密解密使用相同的密钥。\n\n非对称加密，有两种密钥，公钥和私钥。\n\n公钥私钥满足以下几个特点：\n\n1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。\n\n2.顾名思义，公钥是可以公开的，而私钥是不公开的。\n\n3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。\n\n4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容\n\n5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。\n\n与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。\n\n下面看一下数字签名使用过程：\n\n1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。\n\n2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的**身份认证**。\n\n3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了**信息完整性**（一致性检验）。\n\n上面的过程能够得出数字签名的作用：**身份认证**与**完整性检验**\n\n使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。\n\n## 数字证书\n\n数字证书是用来解决公钥从哪里来的问题。\n\n可能有以下两种方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了\n\n所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。\n\n关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。\n\n## 参考\n\n网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。\n\n以下内容来自[无恙-数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html) http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n2、一个加密通信过程的演化\n\n我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：\n\n2.1 第一回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：？？？？\n\n因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”\n\n“黑客”->“客户”：你好，我是服务器\n\n因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：\n\n \n\n2.2 第二回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n      // 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n\n为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。\n\n“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。\n\n假设“黑客”想冒充“服务器”：\n\n“黑客”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。\n\n“客户”->“黑客”：？？？？\n\n由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！\n\n到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：\n\n \n\n2.3 第三回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]\n\n“服务器”->“客户”：{你的余额是100元}[私钥|RSA]\n\n注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。\n\n这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：\n\n \n\n2.4 第四回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。\n\n“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]\n\n在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。\n\n由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。\n\n \n\n总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：\n\n因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。\n客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。\n如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)\n\n到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。\n\n \n\n但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：\n\n“客户”->“黑客”：你好           //黑客截获“客户”发给“服务器”的消息\n\n“黑客”->“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”\n\n因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。\n\n为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：\n\n证书的发布机构\n证书的有效期\n公钥\n证书所有者（Subject）\n签名所使用的算法\n指纹以及指纹算法\n证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：\n\n \n\n2.5 第五回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：\n\n \n\n2.6 完整过程：\n\nstep1： “客户”向服务端发送一个通信请求\n\n“客户”->“服务器”：你好\n\n  \n\nstep2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 \n\n \n\nstep3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。\n\n“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。\n\n“服务器”->“客户”：{一个随机字符串}[私钥|RSA]\n\n \n\nstep4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。\n\n“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]\n\n…… //继续其它的通信\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n另外，也可以看看这篇博客：[阮一峰-数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)\n\n\n\n\n\n\n\n\n","slug":"关于加密的一点总结","published":1,"updated":"2016-08-23T00:10:11.819Z","comments":1,"photos":[],"link":"","_id":"cisx6poo5001kzsqc0lvzctdo","content":"<p>前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。</p>\n<h2 id=\"信息摘要算法\"><a href=\"#信息摘要算法\" class=\"headerlink\" title=\"信息摘要算法\"></a>信息摘要算法</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>验证用户名密码的整个过程主要使用了MD5算法。严格来说，<a href=\"https://zh.wikipedia.org/wiki/MD5\" target=\"_blank\" rel=\"external\">MD5</a>不是一种加密算法，而是一种信息摘要算法。</p>\n<p>所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在<a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/\">这篇</a>总结中提到过。简单来说，就是把给出的”信息”经过哈希之后得到的值，就是这些内容的”摘要”。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>信息摘要算法有这样几个特点：</p>\n<p>1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。</p>\n<p>2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个<a href=\"http://www.zhihu.com/question/22651987\" target=\"_blank\" rel=\"external\">提问</a>.</p>\n<p>3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。</p>\n<p>满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？</p>\n<p>1.一致性检验。</p>\n<p>我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。</p>\n<p>下面是jdk-7u79对应的MD5校验值，从<a href=\"https://www.oracle.com/webfolder/s/digest/7u79checksum.html\" target=\"_blank\" rel=\"external\">官方网站</a>截图。</p>\n<img src=\"/2016/08/22/关于加密的一点总结/md5.png\" alt=\"MD5\" title=\"MD5\">\n<p>2.数字签名</p>\n<p>其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。</p>\n<p>3.登陆验证</p>\n<p>模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回success</p>\n<p>3.客户端将密码经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。</p>\n<p>那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 <a href=\"https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6\" target=\"_blank\" rel=\"external\">加盐</a> 的手段来保证我们密码的安全。</p>\n<p>所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。</p>\n<p>使用加盐手段后，上面的验证过程改为如下：</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt</p>\n<p>3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。</p>\n<h3 id=\"java中的MD5\"><a href=\"#java中的MD5\" class=\"headerlink\" title=\"java中的MD5\"></a>java中的MD5</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">stringMD5</span><span class=\"params\">(String input)</span> </span>&#123;  </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">      <span class=\"comment\">// 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    </span></div><div class=\"line\">      MessageDigest messageDigest =MessageDigest.getInstance(<span class=\"string\">\"MD5\"</span>);  </div><div class=\"line\">      <span class=\"comment\">// 输入的字符串转换成字节数组  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] inputByteArray = input.getBytes();  </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// inputByteArray是输入字符串转换得到的字节数组  </span></div><div class=\"line\">      messageDigest.update(inputByteArray);      </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// 转换并返回结果，也是字节数组，包含16个元素  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] resultByteArray = messageDigest.digest();  </div><div class=\"line\">    </div><div class=\"line\">      <span class=\"comment\">// 字符数组转换成字符串返回  </span></div><div class=\"line\">      <span class=\"keyword\">return</span> byteArrayToHex(resultByteArray);           </div><div class=\"line\">   &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;   </div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;    </div><div class=\"line\">   &#125;  </div><div class=\"line\">  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">byteArrayToHex</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] byteArray)</span> </span>&#123;    </div><div class=\"line\">   <span class=\"comment\">// 首先初始化一个字符数组，用来存放每个16进制字符    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] hexDigits = &#123;<span class=\"string\">'0'</span>,<span class=\"string\">'1'</span>,<span class=\"string\">'2'</span>,<span class=\"string\">'3'</span>,<span class=\"string\">'4'</span>,<span class=\"string\">'5'</span>,<span class=\"string\">'6'</span>,<span class=\"string\">'7'</span>,<span class=\"string\">'8'</span>,<span class=\"string\">'9'</span>, <span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span> &#125;;  </div><div class=\"line\">    </div><div class=\"line\">   <span class=\"comment\">// new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] resultCharArray =<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[byteArray.length * <span class=\"number\">2</span>];   </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    </span></div><div class=\"line\">   <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;    </div><div class=\"line\">   <span class=\"keyword\">int</span> pos,tmp;</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">byte</span> b : byteArray) &#123;   </div><div class=\"line\">   \t  <span class=\"comment\">//当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！</span></div><div class=\"line\">   \t  <span class=\"comment\">//为便于理解，此处对原文进行修改</span></div><div class=\"line\">   \t  <span class=\"keyword\">int</span> tmp = b &amp; <span class=\"number\">0xFF</span>;</div><div class=\"line\">   \t  pos = tmp &gt;&gt; <span class=\"number\">4</span>;<span class=\"comment\">//得到低四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];  </div><div class=\"line\">      pos = tmp &amp; <span class=\"number\">0xF</span>;<span class=\"comment\">//得到高四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];   </div><div class=\"line\">   &#125;    </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 字符数组组合成字符串返回   </span></div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(resultCharArray);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码参考自<a href=\"http://blog.csdn.net/xiao__gui/article/details/8148203\" target=\"_blank\" rel=\"external\">叉叉哥的BLOG</a></p>\n<h2 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h2><p>前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。</p>\n<p>首先了解一下两个概念：<a href=\"https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86\" target=\"_blank\" rel=\"external\">对称加密</a>和<a href=\"https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86\" target=\"_blank\" rel=\"external\">非对称加密</a>。</p>\n<p>对称加密，就是信息加密解密使用相同的密钥。</p>\n<p>非对称加密，有两种密钥，公钥和私钥。</p>\n<p>公钥私钥满足以下几个特点：</p>\n<p>1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。</p>\n<p>2.顾名思义，公钥是可以公开的，而私钥是不公开的。</p>\n<p>3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。</p>\n<p>4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容</p>\n<p>5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。</p>\n<p>与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。</p>\n<p>下面看一下数字签名使用过程：</p>\n<p>1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。</p>\n<p>2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的<strong>身份认证</strong>。</p>\n<p>3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了<strong>信息完整性</strong>（一致性检验）。</p>\n<p>上面的过程能够得出数字签名的作用：<strong>身份认证</strong>与<strong>完整性检验</strong></p>\n<p>使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。</p>\n<h2 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h2><p>数字证书是用来解决公钥从哪里来的问题。</p>\n<p>可能有以下两种方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了</p>\n<p>所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。</p>\n<p>关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。</p>\n<p>以下内容来自<a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\" target=\"_blank\" rel=\"external\">无恙-数字证书原理</a> <a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html</a></p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>2、一个加密通信过程的演化</p>\n<p>我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：</p>\n<p>2.1 第一回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：？？？？</p>\n<p>因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：</p>\n<p>2.2 第二回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<pre><code>// 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n</code></pre><p>为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。</p>\n<p>“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。</p>\n<p>假设“黑客”想冒充“服务器”：</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。</p>\n<p>“客户”-&gt;“黑客”：？？？？</p>\n<p>由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！</p>\n<p>到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：</p>\n<p>2.3 第三回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[私钥|RSA]</p>\n<p>注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。</p>\n<p>这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：</p>\n<p>2.4 第四回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。</p>\n<p>“服务器”-&gt;“客户”：{OK，收到！}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[密钥|对称加密算法]</p>\n<p>在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。</p>\n<p>由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。</p>\n<p>总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：</p>\n<p>因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。<br>客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。<br>如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)</p>\n<p>到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。</p>\n<p>但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：</p>\n<p>“客户”-&gt;“黑客”：你好           //黑客截获“客户”发给“服务器”的消息</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”</p>\n<p>因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。</p>\n<p>为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：</p>\n<p>证书的发布机构<br>证书的有效期<br>公钥<br>证书所有者（Subject）<br>签名所使用的算法<br>指纹以及指纹算法<br>证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：</p>\n<p>2.5 第五回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：</p>\n<p>2.6 完整过程：</p>\n<p>step1： “客户”向服务端发送一个通信请求</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>step2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 </p>\n<p>step3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。</p>\n<p>“服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]</p>\n<p>step4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>\n<p>“服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]</p>\n<p>…… //继续其它的通信</p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>另外，也可以看看这篇博客：<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\" target=\"_blank\" rel=\"external\">阮一峰-数字签名是什么？</a></p>\n","excerpt":"","more":"<p>前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。</p>\n<h2 id=\"信息摘要算法\"><a href=\"#信息摘要算法\" class=\"headerlink\" title=\"信息摘要算法\"></a>信息摘要算法</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>验证用户名密码的整个过程主要使用了MD5算法。严格来说，<a href=\"https://zh.wikipedia.org/wiki/MD5\">MD5</a>不是一种加密算法，而是一种信息摘要算法。</p>\n<p>所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在<a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/\">这篇</a>总结中提到过。简单来说，就是把给出的”信息”经过哈希之后得到的值，就是这些内容的”摘要”。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>信息摘要算法有这样几个特点：</p>\n<p>1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。</p>\n<p>2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个<a href=\"http://www.zhihu.com/question/22651987\">提问</a>.</p>\n<p>3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。</p>\n<p>满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？</p>\n<p>1.一致性检验。</p>\n<p>我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。</p>\n<p>下面是jdk-7u79对应的MD5校验值，从<a href=\"https://www.oracle.com/webfolder/s/digest/7u79checksum.html\">官方网站</a>截图。</p>\n<img src=\"/2016/08/22/关于加密的一点总结/md5.png\" alt=\"MD5\" title=\"MD5\">\n<p>2.数字签名</p>\n<p>其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。</p>\n<p>3.登陆验证</p>\n<p>模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回success</p>\n<p>3.客户端将密码经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。</p>\n<p>那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 <a href=\"https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6\">加盐</a> 的手段来保证我们密码的安全。</p>\n<p>所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。</p>\n<p>使用加盐手段后，上面的验证过程改为如下：</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt</p>\n<p>3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。</p>\n<h3 id=\"java中的MD5\"><a href=\"#java中的MD5\" class=\"headerlink\" title=\"java中的MD5\"></a>java中的MD5</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">stringMD5</span><span class=\"params\">(String input)</span> </span>&#123;  </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">      <span class=\"comment\">// 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    </span></div><div class=\"line\">      MessageDigest messageDigest =MessageDigest.getInstance(<span class=\"string\">\"MD5\"</span>);  </div><div class=\"line\">      <span class=\"comment\">// 输入的字符串转换成字节数组  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] inputByteArray = input.getBytes();  </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// inputByteArray是输入字符串转换得到的字节数组  </span></div><div class=\"line\">      messageDigest.update(inputByteArray);      </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// 转换并返回结果，也是字节数组，包含16个元素  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] resultByteArray = messageDigest.digest();  </div><div class=\"line\">    </div><div class=\"line\">      <span class=\"comment\">// 字符数组转换成字符串返回  </span></div><div class=\"line\">      <span class=\"keyword\">return</span> byteArrayToHex(resultByteArray);           </div><div class=\"line\">   &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;   </div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;    </div><div class=\"line\">   &#125;  </div><div class=\"line\">  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">byteArrayToHex</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] byteArray)</span> </span>&#123;    </div><div class=\"line\">   <span class=\"comment\">// 首先初始化一个字符数组，用来存放每个16进制字符    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] hexDigits = &#123;<span class=\"string\">'0'</span>,<span class=\"string\">'1'</span>,<span class=\"string\">'2'</span>,<span class=\"string\">'3'</span>,<span class=\"string\">'4'</span>,<span class=\"string\">'5'</span>,<span class=\"string\">'6'</span>,<span class=\"string\">'7'</span>,<span class=\"string\">'8'</span>,<span class=\"string\">'9'</span>, <span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span> &#125;;  </div><div class=\"line\">    </div><div class=\"line\">   <span class=\"comment\">// new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] resultCharArray =<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[byteArray.length * <span class=\"number\">2</span>];   </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    </span></div><div class=\"line\">   <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;    </div><div class=\"line\">   <span class=\"keyword\">int</span> pos,tmp;</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">byte</span> b : byteArray) &#123;   </div><div class=\"line\">   \t  <span class=\"comment\">//当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！</span></div><div class=\"line\">   \t  <span class=\"comment\">//为便于理解，此处对原文进行修改</span></div><div class=\"line\">   \t  <span class=\"keyword\">int</span> tmp = b &amp; <span class=\"number\">0xFF</span>;</div><div class=\"line\">   \t  pos = tmp &gt;&gt; <span class=\"number\">4</span>;<span class=\"comment\">//得到低四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];  </div><div class=\"line\">      pos = tmp &amp; <span class=\"number\">0xF</span>;<span class=\"comment\">//得到高四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];   </div><div class=\"line\">   &#125;    </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 字符数组组合成字符串返回   </span></div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(resultCharArray);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码参考自<a href=\"http://blog.csdn.net/xiao__gui/article/details/8148203\">叉叉哥的BLOG</a></p>\n<h2 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h2><p>前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。</p>\n<p>首先了解一下两个概念：<a href=\"https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86\">对称加密</a>和<a href=\"https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86\">非对称加密</a>。</p>\n<p>对称加密，就是信息加密解密使用相同的密钥。</p>\n<p>非对称加密，有两种密钥，公钥和私钥。</p>\n<p>公钥私钥满足以下几个特点：</p>\n<p>1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。</p>\n<p>2.顾名思义，公钥是可以公开的，而私钥是不公开的。</p>\n<p>3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。</p>\n<p>4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容</p>\n<p>5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。</p>\n<p>与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。</p>\n<p>下面看一下数字签名使用过程：</p>\n<p>1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。</p>\n<p>2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的<strong>身份认证</strong>。</p>\n<p>3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了<strong>信息完整性</strong>（一致性检验）。</p>\n<p>上面的过程能够得出数字签名的作用：<strong>身份认证</strong>与<strong>完整性检验</strong></p>\n<p>使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。</p>\n<h2 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h2><p>数字证书是用来解决公钥从哪里来的问题。</p>\n<p>可能有以下两种方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了</p>\n<p>所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。</p>\n<p>关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。</p>\n<p>以下内容来自<a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\">无恙-数字证书原理</a> <a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\">http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html</a></p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>2、一个加密通信过程的演化</p>\n<p>我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：</p>\n<p>2.1 第一回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：？？？？</p>\n<p>因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：</p>\n<p>2.2 第二回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<pre><code>// 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n</code></pre><p>为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。</p>\n<p>“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。</p>\n<p>假设“黑客”想冒充“服务器”：</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。</p>\n<p>“客户”-&gt;“黑客”：？？？？</p>\n<p>由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！</p>\n<p>到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：</p>\n<p>2.3 第三回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[私钥|RSA]</p>\n<p>注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。</p>\n<p>这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：</p>\n<p>2.4 第四回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。</p>\n<p>“服务器”-&gt;“客户”：{OK，收到！}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[密钥|对称加密算法]</p>\n<p>在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。</p>\n<p>由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。</p>\n<p>总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：</p>\n<p>因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。<br>客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。<br>如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)</p>\n<p>到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。</p>\n<p>但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：</p>\n<p>“客户”-&gt;“黑客”：你好           //黑客截获“客户”发给“服务器”的消息</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”</p>\n<p>因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。</p>\n<p>为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：</p>\n<p>证书的发布机构<br>证书的有效期<br>公钥<br>证书所有者（Subject）<br>签名所使用的算法<br>指纹以及指纹算法<br>证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：</p>\n<p>2.5 第五回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：</p>\n<p>2.6 完整过程：</p>\n<p>step1： “客户”向服务端发送一个通信请求</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>step2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 </p>\n<p>step3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。</p>\n<p>“服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]</p>\n<p>step4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>\n<p>“服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]</p>\n<p>…… //继续其它的通信</p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>另外，也可以看看这篇博客：<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\">阮一峰-数字签名是什么？</a></p>\n"},{"layout":"post","title":"代码规范","date":"2016-03-29T08:31:55.000Z","_content":"\n>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。\n 所以决定总结一些规范，以后写代码要注意了~\n\n- ## **命名**\n\n  - 变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名\n\n  - 避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean\n\n  1. 方法\n\n     方法名第一个单词小写，以后每个单词首字母大写。\n\n  2. 类、接口\n\n     所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词\n\n  3. 字段、常量\n\n     成员变量、局部变量第一个单词小写，如 userName, instance。\n\n     常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。\n\n     代码中禁止使用硬编码，把一些数字或字符串定义成常用量。\n\n- ## **注释**\n\n  1. 成员变量注释\n\n    ```java\n    /** 成员变量注释 */\n    protected Object mObject0;\n\n    /**\n     * 对于注释多于一行的，采用这种方式来\n     * 定义该变量\n     */\n    private Object mObject4;\n    ```\n\n  2. 方法描述\n\n    ```java\n    /**\n      * 方法描述...\n      * \n      * @param param1  参数1描述...\n      * @param param2  参数2描述...\n      * @param paramXX 参数XX描述... （注意：请将参数、描述都对齐）\n      */\n      public void doSomething(int param1, float param2, String paramXX) {}\n    ```\n\n  3.方法内部注释\n\n    可以使用 /*注释*/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。\n    \n    ```java\n    if (a == 2) {\n        return TRUE;            /* special case */\n    } else {    \n        return isprime(a);      /* works only for odd a */}\n    ```\n\n\n- ## **换行、空格**\n\n  - **换行**\n\n    当代码过长造成阅读困难的时候，就应该考虑代码换行。\n\n    有这么几个原则：\n\n    1.在逗号之后换行\n\n    2.在操作符之前换行\n\n    3.考虑在表达式的外层就换行，而不是内层\n\n    4.新一行的开头应该与前一行的同一级代码对齐\n\n    5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。\n\n    **示例**\n\n    ```java\n    function(longExpression1, longExpression2, longExpression3,         \n             longExpression4, longExpression5);\n\n    var = function1(longExpression1,                \n                   function2(longExpression2,\n                             longExpression3));\n    ```\n\n    在表达式外层换行：\n\n    ```java\n    longName1 = longName2 * (longName3 + longName4 - longName5)\n                + 4 * longname6; // PREFER\n\n    longName1 = longName2 * (longName3 + longName4\n                             - longName5) + 4 * longname6; // AVOID\n\n    ```\n\n    插入8个空格的情况\n\n    ```java\n    //INDENT 8 SPACES TO AVOID VERY DEEP INDENTS\n    private static synchronized horkingLongMethodName(int anArg,\n            Object anotherArg, String yetAnotherArg,\n            Object andStillAnother) {    \n         ...\n    } \n\n    //条件表达式8空格原则\n    if ((condition1 && condition2)\n            || (condition3 && condition4)\n            ||!(condition5 && condition6)) {\n        doSomethingAboutIt();\n    }\n    ```\n\n  - **空格**\n\n    1.`{`内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。\n\n    2. 操作符左右，大括号`{}`左右，等于号左右都要有一个空格的间距。\nf\n\n- ## **参考**\n\n  [JavaCode Conventions](http://www.oracle.com/technetwork/java/codeconventions-150003.pdf)","source":"_posts/代码格式.md","raw":"---\nlayout: post\ntitle:  \"代码规范\"\ndate:   2016-03-29 16:31:55\ncategories: 编程 \ntags: \n- java\n---\n\n>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。\n 所以决定总结一些规范，以后写代码要注意了~\n\n- ## **命名**\n\n  - 变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名\n\n  - 避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean\n\n  1. 方法\n\n     方法名第一个单词小写，以后每个单词首字母大写。\n\n  2. 类、接口\n\n     所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词\n\n  3. 字段、常量\n\n     成员变量、局部变量第一个单词小写，如 userName, instance。\n\n     常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。\n\n     代码中禁止使用硬编码，把一些数字或字符串定义成常用量。\n\n- ## **注释**\n\n  1. 成员变量注释\n\n    ```java\n    /** 成员变量注释 */\n    protected Object mObject0;\n\n    /**\n     * 对于注释多于一行的，采用这种方式来\n     * 定义该变量\n     */\n    private Object mObject4;\n    ```\n\n  2. 方法描述\n\n    ```java\n    /**\n      * 方法描述...\n      * \n      * @param param1  参数1描述...\n      * @param param2  参数2描述...\n      * @param paramXX 参数XX描述... （注意：请将参数、描述都对齐）\n      */\n      public void doSomething(int param1, float param2, String paramXX) {}\n    ```\n\n  3.方法内部注释\n\n    可以使用 /*注释*/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。\n    \n    ```java\n    if (a == 2) {\n        return TRUE;            /* special case */\n    } else {    \n        return isprime(a);      /* works only for odd a */}\n    ```\n\n\n- ## **换行、空格**\n\n  - **换行**\n\n    当代码过长造成阅读困难的时候，就应该考虑代码换行。\n\n    有这么几个原则：\n\n    1.在逗号之后换行\n\n    2.在操作符之前换行\n\n    3.考虑在表达式的外层就换行，而不是内层\n\n    4.新一行的开头应该与前一行的同一级代码对齐\n\n    5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。\n\n    **示例**\n\n    ```java\n    function(longExpression1, longExpression2, longExpression3,         \n             longExpression4, longExpression5);\n\n    var = function1(longExpression1,                \n                   function2(longExpression2,\n                             longExpression3));\n    ```\n\n    在表达式外层换行：\n\n    ```java\n    longName1 = longName2 * (longName3 + longName4 - longName5)\n                + 4 * longname6; // PREFER\n\n    longName1 = longName2 * (longName3 + longName4\n                             - longName5) + 4 * longname6; // AVOID\n\n    ```\n\n    插入8个空格的情况\n\n    ```java\n    //INDENT 8 SPACES TO AVOID VERY DEEP INDENTS\n    private static synchronized horkingLongMethodName(int anArg,\n            Object anotherArg, String yetAnotherArg,\n            Object andStillAnother) {    \n         ...\n    } \n\n    //条件表达式8空格原则\n    if ((condition1 && condition2)\n            || (condition3 && condition4)\n            ||!(condition5 && condition6)) {\n        doSomethingAboutIt();\n    }\n    ```\n\n  - **空格**\n\n    1.`{`内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。\n\n    2. 操作符左右，大括号`{}`左右，等于号左右都要有一个空格的间距。\nf\n\n- ## **参考**\n\n  [JavaCode Conventions](http://www.oracle.com/technetwork/java/codeconventions-150003.pdf)","slug":"代码格式","published":1,"updated":"2016-08-14T08:26:27.957Z","comments":1,"photos":[],"link":"","_id":"cisx6poo5001ozsqc7agqg4oi","content":"<blockquote>\n<p>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。<br> 所以决定总结一些规范，以后写代码要注意了~</p>\n</blockquote>\n<ul>\n<li><h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a><strong>命名</strong></h2><ul>\n<li><p>变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名</p>\n</li>\n<li><p>避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean</p>\n</li>\n</ul>\n<ol>\n<li><p>方法</p>\n<p>方法名第一个单词小写，以后每个单词首字母大写。</p>\n</li>\n<li><p>类、接口</p>\n<p>所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词</p>\n</li>\n<li><p>字段、常量</p>\n<p>成员变量、局部变量第一个单词小写，如 userName, instance。</p>\n<p>常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。</p>\n<p>代码中禁止使用硬编码，把一些数字或字符串定义成常用量。</p>\n</li>\n</ol>\n</li>\n<li><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a><strong>注释</strong></h2><ol>\n<li><p>成员变量注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** 成员变量注释 */</span></div><div class=\"line\"><span class=\"keyword\">protected</span> Object mObject0;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 对于注释多于一行的，采用这种方式来</div><div class=\"line\"> * 定义该变量</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">private</span> Object mObject4;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方法描述</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * 方法描述...</div><div class=\"line\">  * </div><div class=\"line\">  * <span class=\"doctag\">@param</span> param1  参数1描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> param2  参数2描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> paramXX 参数XX描述... （注意：请将参数、描述都对齐）</div><div class=\"line\">  */</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> param1, <span class=\"keyword\">float</span> param2, String paramXX)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.方法内部注释</p>\n<p>  可以使用 /<em>注释</em>/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> TRUE;            <span class=\"comment\">/* special case */</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">    <span class=\"keyword\">return</span> isprime(a);      <span class=\"comment\">/* works only for odd a */</span>&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><h2 id=\"换行、空格\"><a href=\"#换行、空格\" class=\"headerlink\" title=\"换行、空格\"></a><strong>换行、空格</strong></h2><ul>\n<li><p><strong>换行</strong></p>\n<p>当代码过长造成阅读困难的时候，就应该考虑代码换行。</p>\n<p>有这么几个原则：</p>\n<p>1.在逗号之后换行</p>\n<p>2.在操作符之前换行</p>\n<p>3.考虑在表达式的外层就换行，而不是内层</p>\n<p>4.新一行的开头应该与前一行的同一级代码对齐</p>\n<p>5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(longExpression1, longExpression2, longExpression3,         </div><div class=\"line\">         longExpression4, longExpression5);</div><div class=\"line\"></div><div class=\"line\">var = function1(longExpression1,                </div><div class=\"line\">               function2(longExpression2,</div><div class=\"line\">                         longExpression3));</div></pre></td></tr></table></figure>\n<p>在表达式外层换行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">longName1 = longName2 * (longName3 + longName4 - longName5)</div><div class=\"line\">            + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// PREFER</span></div><div class=\"line\"></div><div class=\"line\">longName1 = longName2 * (longName3 + longName4</div><div class=\"line\">                         - longName5) + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// AVOID</span></div></pre></td></tr></table></figure>\n<p>插入8个空格的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//INDENT 8 SPACES TO AVOID VERY DEEP INDENTS</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">horkingLongMethodName</span><span class=\"params\">(<span class=\"keyword\">int</span> anArg,</span></span></div><div class=\"line\">        Object anotherArg, String yetAnotherArg,</div><div class=\"line\">        Object andStillAnother) &#123;    </div><div class=\"line\">     ...</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//条件表达式8空格原则</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((condition1 &amp;&amp; condition2)</div><div class=\"line\">        || (condition3 &amp;&amp; condition4)</div><div class=\"line\">        ||!(condition5 &amp;&amp; condition6)) &#123;</div><div class=\"line\">    doSomethingAboutIt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>空格</strong></p>\n<p>1.<code>{</code>内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。</p>\n<ol>\n<li>操作符左右，大括号<code>{}</code>左右，等于号左右都要有一个空格的间距。<br>f</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://www.oracle.com/technetwork/java/codeconventions-150003.pdf\" target=\"_blank\" rel=\"external\">JavaCode Conventions</a></p>\n</li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<p>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。<br> 所以决定总结一些规范，以后写代码要注意了~</p>\n</blockquote>\n<ul>\n<li><h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a><strong>命名</strong></h2><ul>\n<li><p>变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名</p>\n</li>\n<li><p>避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean</p>\n</li>\n</ul>\n<ol>\n<li><p>方法</p>\n<p>方法名第一个单词小写，以后每个单词首字母大写。</p>\n</li>\n<li><p>类、接口</p>\n<p>所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词</p>\n</li>\n<li><p>字段、常量</p>\n<p>成员变量、局部变量第一个单词小写，如 userName, instance。</p>\n<p>常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。</p>\n<p>代码中禁止使用硬编码，把一些数字或字符串定义成常用量。</p>\n</li>\n</ol>\n</li>\n<li><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a><strong>注释</strong></h2><ol>\n<li><p>成员变量注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** 成员变量注释 */</span></div><div class=\"line\"><span class=\"keyword\">protected</span> Object mObject0;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 对于注释多于一行的，采用这种方式来</div><div class=\"line\"> * 定义该变量</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">private</span> Object mObject4;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方法描述</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * 方法描述...</div><div class=\"line\">  * </div><div class=\"line\">  * <span class=\"doctag\">@param</span> param1  参数1描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> param2  参数2描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> paramXX 参数XX描述... （注意：请将参数、描述都对齐）</div><div class=\"line\">  */</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> param1, <span class=\"keyword\">float</span> param2, String paramXX)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.方法内部注释</p>\n<p>  可以使用 /<em>注释</em>/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> TRUE;            <span class=\"comment\">/* special case */</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">    <span class=\"keyword\">return</span> isprime(a);      <span class=\"comment\">/* works only for odd a */</span>&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><h2 id=\"换行、空格\"><a href=\"#换行、空格\" class=\"headerlink\" title=\"换行、空格\"></a><strong>换行、空格</strong></h2><ul>\n<li><p><strong>换行</strong></p>\n<p>当代码过长造成阅读困难的时候，就应该考虑代码换行。</p>\n<p>有这么几个原则：</p>\n<p>1.在逗号之后换行</p>\n<p>2.在操作符之前换行</p>\n<p>3.考虑在表达式的外层就换行，而不是内层</p>\n<p>4.新一行的开头应该与前一行的同一级代码对齐</p>\n<p>5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(longExpression1, longExpression2, longExpression3,         </div><div class=\"line\">         longExpression4, longExpression5);</div><div class=\"line\"></div><div class=\"line\">var = function1(longExpression1,                </div><div class=\"line\">               function2(longExpression2,</div><div class=\"line\">                         longExpression3));</div></pre></td></tr></table></figure>\n<p>在表达式外层换行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">longName1 = longName2 * (longName3 + longName4 - longName5)</div><div class=\"line\">            + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// PREFER</span></div><div class=\"line\"></div><div class=\"line\">longName1 = longName2 * (longName3 + longName4</div><div class=\"line\">                         - longName5) + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// AVOID</span></div></pre></td></tr></table></figure>\n<p>插入8个空格的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//INDENT 8 SPACES TO AVOID VERY DEEP INDENTS</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">horkingLongMethodName</span><span class=\"params\">(<span class=\"keyword\">int</span> anArg,</div><div class=\"line\">        Object anotherArg, String yetAnotherArg,</div><div class=\"line\">        Object andStillAnother)</span> </span>&#123;    </div><div class=\"line\">     ...</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//条件表达式8空格原则</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((condition1 &amp;&amp; condition2)</div><div class=\"line\">        || (condition3 &amp;&amp; condition4)</div><div class=\"line\">        ||!(condition5 &amp;&amp; condition6)) &#123;</div><div class=\"line\">    doSomethingAboutIt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>空格</strong></p>\n<p>1.<code>{</code>内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。</p>\n<ol>\n<li>操作符左右，大括号<code>{}</code>左右，等于号左右都要有一个空格的间距。<br>f</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://www.oracle.com/technetwork/java/codeconventions-150003.pdf\">JavaCode Conventions</a></p>\n</li>\n</ul>\n"},{"layout":"post","title":"关于抽象类和接口","date":"2016-04-15T14:48:55.000Z","_content":"\n## 抽象类：\n\n> 使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.\n\n   - 抽象类不能被实例化\n\n   - 如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类\n\n   - 抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。\n\n   - 可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。\n   \n   - 不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。\n\n   - 抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。\n\n   - 子类中的抽象方法不能与父类的抽象方法同名\n\n   - 其余情况抽象类与普通类相同。\n\n\n## 接口：\n\n\n > 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.\n\n   - 接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。\n\n   - 接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。\n\n   - 接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。\n\n   - 接口中没有构造方法，不能被实例化。\n\n   - 如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。\n\n   - 接口中不能含有静态代码块以及静态方法。\n\n   - 在实现多接口的时候一定要避免方法名的重复。\n\n## 区别与联系：\n   \n   - **语义**\n   \n     1. 一个类只能继承一个抽象类，但可以实现多个接口。\n\n     2. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法\n\n   - **设计思想**\n\n     >抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。\n\n     1. 抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。\n\n        对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。\n\n     2. 抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。\n    \n        抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n\n     3. 抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n\n        对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。\n\n     **示例**\n\n     门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n\n  \n```java\nabstract class Door {\n      public abstract void open();\n      public abstract void close();\n}\n```\n    \t\n\n或\n \n```java\ninterface Door {\n      public abstract void open();\n      public abstract void close();\n} \n```\n\n\n但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：\n\n1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；\n\n2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。\n\n从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。\n      \n\n```java\ninterface Alram {\n      void alarm();\n}\nabstract class Door {\n      void open();\n      void close();\n}\nclass AlarmDoor extends Door implements Alarm {\n      void oepn() {\n           //....\n      }\n      void close() {\n           //....\n      }\n      void alarm() {\n           //....\n      }\n} \n```\n\n\n\n\n## **资料:**\n\n   [Java 中的接口有什么作用？](https://www.zhihu.com/question/20111251)\n\n   [java提高篇（四）-----抽象类与接口](http://blog.csdn.net/chenssy/article/details/12858267)\n\n","source":"_posts/关于抽象类和接口.md","raw":"---\nlayout: post\ntitle:  \"关于抽象类和接口\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-15 22:48:55\n---\n\n## 抽象类：\n\n> 使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.\n\n   - 抽象类不能被实例化\n\n   - 如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类\n\n   - 抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。\n\n   - 可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。\n   \n   - 不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。\n\n   - 抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。\n\n   - 子类中的抽象方法不能与父类的抽象方法同名\n\n   - 其余情况抽象类与普通类相同。\n\n\n## 接口：\n\n\n > 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.\n\n   - 接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。\n\n   - 接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。\n\n   - 接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。\n\n   - 接口中没有构造方法，不能被实例化。\n\n   - 如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。\n\n   - 接口中不能含有静态代码块以及静态方法。\n\n   - 在实现多接口的时候一定要避免方法名的重复。\n\n## 区别与联系：\n   \n   - **语义**\n   \n     1. 一个类只能继承一个抽象类，但可以实现多个接口。\n\n     2. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法\n\n   - **设计思想**\n\n     >抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。\n\n     1. 抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。\n\n        对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。\n\n     2. 抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。\n    \n        抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n\n     3. 抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n\n        对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。\n\n     **示例**\n\n     门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n\n  \n```java\nabstract class Door {\n      public abstract void open();\n      public abstract void close();\n}\n```\n    \t\n\n或\n \n```java\ninterface Door {\n      public abstract void open();\n      public abstract void close();\n} \n```\n\n\n但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：\n\n1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；\n\n2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。\n\n从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。\n      \n\n```java\ninterface Alram {\n      void alarm();\n}\nabstract class Door {\n      void open();\n      void close();\n}\nclass AlarmDoor extends Door implements Alarm {\n      void oepn() {\n           //....\n      }\n      void close() {\n           //....\n      }\n      void alarm() {\n           //....\n      }\n} \n```\n\n\n\n\n## **资料:**\n\n   [Java 中的接口有什么作用？](https://www.zhihu.com/question/20111251)\n\n   [java提高篇（四）-----抽象类与接口](http://blog.csdn.net/chenssy/article/details/12858267)\n\n","slug":"关于抽象类和接口","published":1,"updated":"2016-08-14T09:10:17.537Z","comments":1,"photos":[],"link":"","_id":"cisx6pool001szsqcy5utrvev","content":"<h2 id=\"抽象类：\"><a href=\"#抽象类：\" class=\"headerlink\" title=\"抽象类：\"></a>抽象类：</h2><blockquote>\n<p>使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.</p>\n</blockquote>\n<ul>\n<li><p>抽象类不能被实例化</p>\n</li>\n<li><p>如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类</p>\n</li>\n<li><p>抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。</p>\n</li>\n<li><p>可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。</p>\n</li>\n<li><p>不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。</p>\n</li>\n<li><p>抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。</p>\n</li>\n<li><p>子类中的抽象方法不能与父类的抽象方法同名</p>\n</li>\n<li><p>其余情况抽象类与普通类相同。</p>\n</li>\n</ul>\n<h2 id=\"接口：\"><a href=\"#接口：\" class=\"headerlink\" title=\"接口：\"></a>接口：</h2><blockquote>\n<p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.</p>\n</blockquote>\n<ul>\n<li><p>接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。</p>\n</li>\n<li><p>接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。</p>\n</li>\n<li><p>接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。</p>\n</li>\n<li><p>接口中没有构造方法，不能被实例化。</p>\n</li>\n<li><p>如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>\n</li>\n<li><p>接口中不能含有静态代码块以及静态方法。</p>\n</li>\n<li><p>在实现多接口的时候一定要避免方法名的重复。</p>\n</li>\n</ul>\n<h2 id=\"区别与联系：\"><a href=\"#区别与联系：\" class=\"headerlink\" title=\"区别与联系：\"></a>区别与联系：</h2><ul>\n<li><p><strong>语义</strong></p>\n<ol>\n<li><p>一个类只能继承一个抽象类，但可以实现多个接口。</p>\n</li>\n<li><p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法</p>\n</li>\n</ol>\n</li>\n<li><p><strong>设计思想</strong></p>\n<blockquote>\n<p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</p>\n</blockquote>\n<ol>\n<li><p>抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。</p>\n<p>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>\n</li>\n<li><p>抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。</p>\n<p>抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。</p>\n</li>\n<li><p>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>\n<p>对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。</p>\n</li>\n</ol>\n<p><strong>示例</strong></p>\n<p>门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>\n<p>1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>\n<p>2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>\n<p>从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alram</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">oepn</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料:\"></a><strong>资料:</strong></h2><p>   <a href=\"https://www.zhihu.com/question/20111251\" target=\"_blank\" rel=\"external\">Java 中的接口有什么作用？</a></p>\n<p>   <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\" target=\"_blank\" rel=\"external\">java提高篇（四）—–抽象类与接口</a></p>\n","excerpt":"","more":"<h2 id=\"抽象类：\"><a href=\"#抽象类：\" class=\"headerlink\" title=\"抽象类：\"></a>抽象类：</h2><blockquote>\n<p>使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.</p>\n</blockquote>\n<ul>\n<li><p>抽象类不能被实例化</p>\n</li>\n<li><p>如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类</p>\n</li>\n<li><p>抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。</p>\n</li>\n<li><p>可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。</p>\n</li>\n<li><p>不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。</p>\n</li>\n<li><p>抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。</p>\n</li>\n<li><p>子类中的抽象方法不能与父类的抽象方法同名</p>\n</li>\n<li><p>其余情况抽象类与普通类相同。</p>\n</li>\n</ul>\n<h2 id=\"接口：\"><a href=\"#接口：\" class=\"headerlink\" title=\"接口：\"></a>接口：</h2><blockquote>\n<p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.</p>\n</blockquote>\n<ul>\n<li><p>接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。</p>\n</li>\n<li><p>接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。</p>\n</li>\n<li><p>接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。</p>\n</li>\n<li><p>接口中没有构造方法，不能被实例化。</p>\n</li>\n<li><p>如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>\n</li>\n<li><p>接口中不能含有静态代码块以及静态方法。</p>\n</li>\n<li><p>在实现多接口的时候一定要避免方法名的重复。</p>\n</li>\n</ul>\n<h2 id=\"区别与联系：\"><a href=\"#区别与联系：\" class=\"headerlink\" title=\"区别与联系：\"></a>区别与联系：</h2><ul>\n<li><p><strong>语义</strong></p>\n<ol>\n<li><p>一个类只能继承一个抽象类，但可以实现多个接口。</p>\n</li>\n<li><p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法</p>\n</li>\n</ol>\n</li>\n<li><p><strong>设计思想</strong></p>\n<blockquote>\n<p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</p>\n</blockquote>\n<ol>\n<li><p>抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。</p>\n<p>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>\n</li>\n<li><p>抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。</p>\n<p>抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。</p>\n</li>\n<li><p>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>\n<p>对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。</p>\n</li>\n</ol>\n<p><strong>示例</strong></p>\n<p>门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>\n<p>1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>\n<p>2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>\n<p>从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alram</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">oepn</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料:\"></a><strong>资料:</strong></h2><p>   <a href=\"https://www.zhihu.com/question/20111251\">Java 中的接口有什么作用？</a></p>\n<p>   <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\">java提高篇（四）—–抽象类与接口</a></p>\n"},{"layout":"post","title":"常用快捷键总结","date":"2016-03-22T08:31:55.000Z","_content":"- ## ECLIPSE:\n\n   **查看代码**\n   \n   Ctrl+O 搜索当前类变量及方法\n\n   Ctrl+H 打开搜索对话框\n\n   Ctrl+Shift+G  搜索选中变量或方法的引用\n\n   Ctrl+D 删除当前行\n\n   Ctrl+Shift+F 格式化代码\n\n   F4 查看当前类继承结构\n\n   Ctrl+Shift+R 搜索类，文件等资源\n\n   Ctrl+Shift+O 倒包\n   \n   **调试**\n     \n     F5 进入方法内部\n     \n     F6 顺序执行到下一行\n     \n     F7 跳出方法，返回调用处\n     \n     F8 执行到下一个断点\n\n     Ctrl+Shift+I  查看选中表达式的值\n\n     Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法\n\n     Ctrl+R   运行到光标所在的行\n     \n- ## WINDOWS:\n   \n   ALT+TAB 切换窗口\n   \n   ALT+F4  关闭窗口\n   \n   Ctrl+L  锁定\n   \n   Windows+D 显示桌面\n   \n   Windows+E 打开我的电脑\n   \n   Windows+R 打开运行对话框\n   \n   Ctrl+Z 撤销上一步操作\n   \n   Ctrl+Y 恢复撤销的操作\n   \n   Ctrl+Shift+Esc 打开任务管理器\n\n   按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口\n   \n- ## Chorme:\n  \n   Ctrl+N 打开新窗口\n   \n   Ctrl+Tab 切换标签页\n   \n   Ctrl+L 选中网址栏\n   \n   Ctrl+T 新建标签页\n   \n   Ctrl+Shift+T 重新打开上次关闭的标签页\n   \n   Home 转至网页顶部\n   \n   Ctrl+W 关闭标签页\n   ","source":"_posts/常用快捷键总结.md","raw":"---\nlayout: post\ntitle:  \"常用快捷键总结\"\ndate:   2016-03-22 16:31:55\ncategories: 工具\ntags: \n- 快捷键\n---\n- ## ECLIPSE:\n\n   **查看代码**\n   \n   Ctrl+O 搜索当前类变量及方法\n\n   Ctrl+H 打开搜索对话框\n\n   Ctrl+Shift+G  搜索选中变量或方法的引用\n\n   Ctrl+D 删除当前行\n\n   Ctrl+Shift+F 格式化代码\n\n   F4 查看当前类继承结构\n\n   Ctrl+Shift+R 搜索类，文件等资源\n\n   Ctrl+Shift+O 倒包\n   \n   **调试**\n     \n     F5 进入方法内部\n     \n     F6 顺序执行到下一行\n     \n     F7 跳出方法，返回调用处\n     \n     F8 执行到下一个断点\n\n     Ctrl+Shift+I  查看选中表达式的值\n\n     Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法\n\n     Ctrl+R   运行到光标所在的行\n     \n- ## WINDOWS:\n   \n   ALT+TAB 切换窗口\n   \n   ALT+F4  关闭窗口\n   \n   Ctrl+L  锁定\n   \n   Windows+D 显示桌面\n   \n   Windows+E 打开我的电脑\n   \n   Windows+R 打开运行对话框\n   \n   Ctrl+Z 撤销上一步操作\n   \n   Ctrl+Y 恢复撤销的操作\n   \n   Ctrl+Shift+Esc 打开任务管理器\n\n   按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口\n   \n- ## Chorme:\n  \n   Ctrl+N 打开新窗口\n   \n   Ctrl+Tab 切换标签页\n   \n   Ctrl+L 选中网址栏\n   \n   Ctrl+T 新建标签页\n   \n   Ctrl+Shift+T 重新打开上次关闭的标签页\n   \n   Home 转至网页顶部\n   \n   Ctrl+W 关闭标签页\n   ","slug":"常用快捷键总结","published":1,"updated":"2016-08-14T08:26:27.963Z","comments":1,"photos":[],"link":"","_id":"cisx6pop1001wzsqc1phrgum2","content":"<ul>\n<li><h2 id=\"ECLIPSE\"><a href=\"#ECLIPSE\" class=\"headerlink\" title=\"ECLIPSE:\"></a>ECLIPSE:</h2><p> <strong>查看代码</strong></p>\n<p> Ctrl+O 搜索当前类变量及方法</p>\n<p> Ctrl+H 打开搜索对话框</p>\n<p> Ctrl+Shift+G  搜索选中变量或方法的引用</p>\n<p> Ctrl+D 删除当前行</p>\n<p> Ctrl+Shift+F 格式化代码</p>\n<p> F4 查看当前类继承结构</p>\n<p> Ctrl+Shift+R 搜索类，文件等资源</p>\n<p> Ctrl+Shift+O 倒包</p>\n<p> <strong>调试</strong></p>\n<p>   F5 进入方法内部</p>\n<p>   F6 顺序执行到下一行</p>\n<p>   F7 跳出方法，返回调用处</p>\n<p>   F8 执行到下一个断点</p>\n<p>   Ctrl+Shift+I  查看选中表达式的值</p>\n<p>   Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法</p>\n<p>   Ctrl+R   运行到光标所在的行</p>\n</li>\n<li><h2 id=\"WINDOWS\"><a href=\"#WINDOWS\" class=\"headerlink\" title=\"WINDOWS:\"></a>WINDOWS:</h2><p> ALT+TAB 切换窗口</p>\n<p> ALT+F4  关闭窗口</p>\n<p> Ctrl+L  锁定</p>\n<p> Windows+D 显示桌面</p>\n<p> Windows+E 打开我的电脑</p>\n<p> Windows+R 打开运行对话框</p>\n<p> Ctrl+Z 撤销上一步操作</p>\n<p> Ctrl+Y 恢复撤销的操作</p>\n<p> Ctrl+Shift+Esc 打开任务管理器</p>\n<p> 按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口</p>\n</li>\n<li><h2 id=\"Chorme\"><a href=\"#Chorme\" class=\"headerlink\" title=\"Chorme:\"></a>Chorme:</h2><p> Ctrl+N 打开新窗口</p>\n<p> Ctrl+Tab 切换标签页</p>\n<p> Ctrl+L 选中网址栏</p>\n<p> Ctrl+T 新建标签页</p>\n<p> Ctrl+Shift+T 重新打开上次关闭的标签页</p>\n<p> Home 转至网页顶部</p>\n<p> Ctrl+W 关闭标签页</p>\n</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li><h2 id=\"ECLIPSE\"><a href=\"#ECLIPSE\" class=\"headerlink\" title=\"ECLIPSE:\"></a>ECLIPSE:</h2><p> <strong>查看代码</strong></p>\n<p> Ctrl+O 搜索当前类变量及方法</p>\n<p> Ctrl+H 打开搜索对话框</p>\n<p> Ctrl+Shift+G  搜索选中变量或方法的引用</p>\n<p> Ctrl+D 删除当前行</p>\n<p> Ctrl+Shift+F 格式化代码</p>\n<p> F4 查看当前类继承结构</p>\n<p> Ctrl+Shift+R 搜索类，文件等资源</p>\n<p> Ctrl+Shift+O 倒包</p>\n<p> <strong>调试</strong></p>\n<p>   F5 进入方法内部</p>\n<p>   F6 顺序执行到下一行</p>\n<p>   F7 跳出方法，返回调用处</p>\n<p>   F8 执行到下一个断点</p>\n<p>   Ctrl+Shift+I  查看选中表达式的值</p>\n<p>   Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法</p>\n<p>   Ctrl+R   运行到光标所在的行</p>\n</li>\n<li><h2 id=\"WINDOWS\"><a href=\"#WINDOWS\" class=\"headerlink\" title=\"WINDOWS:\"></a>WINDOWS:</h2><p> ALT+TAB 切换窗口</p>\n<p> ALT+F4  关闭窗口</p>\n<p> Ctrl+L  锁定</p>\n<p> Windows+D 显示桌面</p>\n<p> Windows+E 打开我的电脑</p>\n<p> Windows+R 打开运行对话框</p>\n<p> Ctrl+Z 撤销上一步操作</p>\n<p> Ctrl+Y 恢复撤销的操作</p>\n<p> Ctrl+Shift+Esc 打开任务管理器</p>\n<p> 按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口</p>\n</li>\n<li><h2 id=\"Chorme\"><a href=\"#Chorme\" class=\"headerlink\" title=\"Chorme:\"></a>Chorme:</h2><p> Ctrl+N 打开新窗口</p>\n<p> Ctrl+Tab 切换标签页</p>\n<p> Ctrl+L 选中网址栏</p>\n<p> Ctrl+T 新建标签页</p>\n<p> Ctrl+Shift+T 重新打开上次关闭的标签页</p>\n<p> Home 转至网页顶部</p>\n<p> Ctrl+W 关闭标签页</p>\n</li>\n</ul>\n"},{"layout":"post","title":"毕业了","date":"2016-06-30T15:48:55.000Z","_content":"<iframe \n\tframeborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\">\n</iframe>\n毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。\n\n转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。\n\n但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？\n\n大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。\n\n希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。\n\n{% asset_img graduation1.jpg 毕业照 %}\n\n{% asset_img graduation2.jpg 毕设之后金客来 %}\n\n{% asset_img graduation3.jpg 跳蚤市场卖书 %}\n\n{% asset_img graduation4.jpg 去唱K %}\n\n{% asset_img graduation5.jpg 毕业照之前 %}\n\n{% asset_img graduation6.jpg 机房老师 %}\n\n{% asset_img graduation7.jpg 毕业照之前 %}\n\n{% asset_img graduation8.jpg 我和张蕾 %}\n\n\n\n\n","source":"_posts/毕业了.md","raw":"---\nlayout: post\ntitle:  \"毕业了\"\ncategories: 生活 \ndate:  2016-06-30 23:48:55\n---\n<iframe \n\tframeborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\">\n</iframe>\n毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。\n\n转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。\n\n但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？\n\n大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。\n\n希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。\n\n{% asset_img graduation1.jpg 毕业照 %}\n\n{% asset_img graduation2.jpg 毕设之后金客来 %}\n\n{% asset_img graduation3.jpg 跳蚤市场卖书 %}\n\n{% asset_img graduation4.jpg 去唱K %}\n\n{% asset_img graduation5.jpg 毕业照之前 %}\n\n{% asset_img graduation6.jpg 机房老师 %}\n\n{% asset_img graduation7.jpg 毕业照之前 %}\n\n{% asset_img graduation8.jpg 我和张蕾 %}\n\n\n\n\n","slug":"毕业了","published":1,"updated":"2016-08-14T09:31:11.130Z","comments":1,"photos":[],"link":"","_id":"cisx6pop10020zsqc70khn3xn","content":"<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\"><br></iframe><br>毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。</p>\n<p>转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。</p>\n<p>但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？</p>\n<p>大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。</p>\n<p>希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。</p>\n<img src=\"/2016/06/30/毕业了/graduation1.jpg\" alt=\"毕业照\" title=\"毕业照\">\n<img src=\"/2016/06/30/毕业了/graduation2.jpg\" alt=\"毕设之后金客来\" title=\"毕设之后金客来\">\n<img src=\"/2016/06/30/毕业了/graduation3.jpg\" alt=\"跳蚤市场卖书\" title=\"跳蚤市场卖书\">\n<img src=\"/2016/06/30/毕业了/graduation4.jpg\" alt=\"去唱K\" title=\"去唱K\">\n<img src=\"/2016/06/30/毕业了/graduation5.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation6.jpg\" alt=\"机房老师\" title=\"机房老师\">\n<img src=\"/2016/06/30/毕业了/graduation7.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation8.jpg\" alt=\"我和张蕾\" title=\"我和张蕾\">\n","excerpt":"","more":"<p><iframe \n    frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\"><br></iframe><br>毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。</p>\n<p>转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。</p>\n<p>但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？</p>\n<p>大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。</p>\n<p>希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。</p>\n<img src=\"/2016/06/30/毕业了/graduation1.jpg\" alt=\"毕业照\" title=\"毕业照\">\n<img src=\"/2016/06/30/毕业了/graduation2.jpg\" alt=\"毕设之后金客来\" title=\"毕设之后金客来\">\n<img src=\"/2016/06/30/毕业了/graduation3.jpg\" alt=\"跳蚤市场卖书\" title=\"跳蚤市场卖书\">\n<img src=\"/2016/06/30/毕业了/graduation4.jpg\" alt=\"去唱K\" title=\"去唱K\">\n<img src=\"/2016/06/30/毕业了/graduation5.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation6.jpg\" alt=\"机房老师\" title=\"机房老师\">\n<img src=\"/2016/06/30/毕业了/graduation7.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation8.jpg\" alt=\"我和张蕾\" title=\"我和张蕾\">\n"},{"layout":"post","title":"理解java内存模型","date":"2016-09-10T02:32:40.000Z","_content":"\n最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~\n\n## 并发为啥会出现问题\n\n### 原子性\n\n其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：\n\n```java\npublic class BankAccount {\n\tprivate static int accountBalance = 10000;\n\n\tstatic class Save implements Runnable {\n\t\tprivate int money;\n\n\t\tpublic Save(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\t//存钱\n\t\t\tint tempAccount = accountBalance + money;\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次存入：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tstatic class Obtain implements Runnable {\n\n\t\tprivate int money;\n\n\t\tpublic Obtain(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (money > accountBalance) {\n\t\t\t\tSystem.out.println(\"余额不足\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//取钱\n\t\t\tint tempAccount = accountBalance - money;\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);//艾玛，卡了一秒\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次取出：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tint saveMoney = 10000;\n\t\tint obtainMoney = 10000;\n\t\t//自己取钱\n\t\tThread obtain = new Thread(new Obtain(obtainMoney));\n\t\t//老婆存钱\n\t\tThread save = new Thread(new Save(saveMoney));\n\t\tobtain.start();\n\t\tsave.start();\n\t}\n\n}\n```\n\n输出结果：\n\n```\n此次存入：10000\n当前余额：20000\n此次取出：10000\n当前余额：0\n```\n\n可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。\n\n分析一下出现问题的原因：\n\n出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。\n\n这就涉及到线程并发的第一个问题：原子性。\n\n我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。\n\n```\n//取钱\nint tempAccount = accountBalance - money;\n\n//设置余额\naccountBalance = tempAccount;\n```\n\n为了实现这种错误的效果，我故意把\n\n```\naccountBalance -= accountBalance;\n```\n\n拆成了上面的两行。其实`accountBalance -= accountBalance;`本身就不是一个原子操作，拆成两行是为了放大这种效果。\n\n通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。\n\n原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。\n\njava中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。\n\n那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。\n\n### 可见性\n\n组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。\n\nJava虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）\n\n画个图：\n\n{% asset_img 内存模型.png 内存模型 %}\n\n这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。\n\n我们回到上述的例子：\n\n上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似`accountBalance -= accountBalance;`这样的操作是原子性操作，设想以下的场景：\n\n1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时`accountBalance~ = 20000;accountBalance = 10000;`\n\n2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时`accountBalance~ = 0;accountBalance = 10000;`\n\n3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；\n\n4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；\n\n通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。\n\n我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。\n\n### 有序性\n\nCpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。\n\n以下例子来自《深入理解Java虚拟机》：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\nconfigOptions = new HashMap();\nconfigText = readConfigFile(flieName);\nprocessConfigOptions(configText,configOptions);\ninitialized = true;\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\nwhile(!initialized){\n\tsleep();\n}\n//使用线程A中初始化好的配置信息\ndoSomethingWithConfig();\n```\n\n在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码`initialized=true`被提前执行，这样线程B中使用配置信息的代码就可能出现错误。\n\n所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\npublic synchronized void init(){\n\tconfigOptions = new HashMap();\n\tconfigText = readConfigFile(flieName);\n\tprocessConfigOptions(configText,configOptions);\n\tinitialized = true;\n}\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\npublic synchronized void doSomething(){\n\twhile(!initialized){\n\t\tsleep();\n\t}\n\t//使用线程A中初始化好的配置信息\n\tdoSomethingWithConfig();\n}\n```\n注意上面两个方法在同一个类中实现。\n\n至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇[synchronized的用法](http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/)，对synchronized的使用更加得心应手啦！\n\n## 先行发生原则\n\n没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。\n\n比如我想到了之前宇哥跟我提到的一个bug:\n\n在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。\n\n后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用`calendar.setTime(date);`,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个`calendar.setTime(date);`，结果肯定就变得混乱了。\n\n上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。\n\n解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。\n\n先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。\n\n还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：\n\n```\n//以下操作在线程A中执行\ni = 1;\n\n//以下操作在线程B中执行\nj = i;\n\n//以下操作在线程C中执行\ni = 2;\n```\n\n假设线程A中的操作`i=1`先行发生于线程B的操作`j=i`,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，`i=1`的结果可以被B观察到。\n\n现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。\n\n其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。\n\n你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性...\n\n如果还没有理解所谓的先行发生原则的话，可以看一下[这篇文章](http://ifeve.com/easy-happens-before/)。\n\n下面介绍几个java内存模型中存在的先行发生关系：\n\n**程序次序规则**：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。\n\n**管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。\n\n**volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。\n\n**传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。\n\n以上只是一部分先行发生关系，其他的不再一一介绍。\n\n那么，先行发生原则如何使用呢？我们看一个例子：\n\n```java\nprivate int value = 0;\n\npublic void setValue(int value){\n\tthis.value = value;\n}\n\npublic int getValue(){\n\treturn value;\n}\n```\n\n假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？\n\n套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看[这个](http://wiki.jikexueyuan.com/project/java-memory-model/lock.html)\n\n通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。\n\n## Volatile关键字\n\n通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。\n\nvolatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：**保证内存可见性和禁止重排序**。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：\n\n```java\npublic class VolatileTest {\n\tpublic static volatile int race = 0;\n\t\n\tpublic static void increase(){\n\t\trace++;\n\t}\n\t\n\tprivate static int THREAD_COUNT = 20;\n\t\n\tpublic static void main(String args[]) {\n\t\tThread[] threads = new Thread[THREAD_COUNT];\n\t\tfor (int i = 0; i < THREAD_COUNT; i++) {\n\t\t\tthreads[i] = new Thread(new Runnable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i< 10000; i++) {\n\t\t\t\t\t\tincrease();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthreads[i].start();\n\t\t}\n\t\twhile (Thread.activeCount()>1) {\n\t\t\tThread.yield();\n\t\t}\n\t\tSystem.out.println(race);\n\t}\n}\n\n```\n\n```\n运行结果：130310 //每次运行结果并不相同\n```\n\n可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于`race++`,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。\n\n这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。\n\n现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：**每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量**。\n\n当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。\n\n当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。\n\n关于volatile怎么实现内存可见性，是通过一个叫[内存屏障](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C)的东西来实现的。具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。\n\n关于volatile关键字的禁止重排序，具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n我们从先行发生原则的角度看一下volatile的禁止重排序：\n\n{% asset_img volatile.png volatile先行发生原则 %}\n\n其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。\n\n根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。\n\n即：**普通读写不能与其后的所有写volatile变量重排序**。同理，**普通读写不能与之前的所有读volatile变量重排序**。\n\n下面看看volatile的使用场景：\n\n1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n\n2.变量不需要与其他状态的变量共同参与不变约束。\n\n第一点就很好理解了，volatile不保证原子性嘛~~\n\n**第二点我也有点疑惑，待研究...**\n\n关于volatile的使用场景，可以看看这篇文章：[Java 理论与实践: 正确使用 Volatile 变量](http://www.ibm.com/developerworks/cn/java/j-jtp06197.html)\n\n## 最后\n\n终于把自己想要总结的写完了~~断断续续写了四个小时...好累...\n\n加油！\n\n\n\n\n\n","source":"_posts/理解java内存模型.md","raw":"---\nlayout: post\ntitle: 理解java内存模型\ndate: 2016-09-10 10:32:40\ncategories: 技术\ntags: java\n---\n\n最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~\n\n## 并发为啥会出现问题\n\n### 原子性\n\n其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：\n\n```java\npublic class BankAccount {\n\tprivate static int accountBalance = 10000;\n\n\tstatic class Save implements Runnable {\n\t\tprivate int money;\n\n\t\tpublic Save(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\t//存钱\n\t\t\tint tempAccount = accountBalance + money;\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次存入：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tstatic class Obtain implements Runnable {\n\n\t\tprivate int money;\n\n\t\tpublic Obtain(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (money > accountBalance) {\n\t\t\t\tSystem.out.println(\"余额不足\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//取钱\n\t\t\tint tempAccount = accountBalance - money;\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);//艾玛，卡了一秒\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次取出：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tint saveMoney = 10000;\n\t\tint obtainMoney = 10000;\n\t\t//自己取钱\n\t\tThread obtain = new Thread(new Obtain(obtainMoney));\n\t\t//老婆存钱\n\t\tThread save = new Thread(new Save(saveMoney));\n\t\tobtain.start();\n\t\tsave.start();\n\t}\n\n}\n```\n\n输出结果：\n\n```\n此次存入：10000\n当前余额：20000\n此次取出：10000\n当前余额：0\n```\n\n可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。\n\n分析一下出现问题的原因：\n\n出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。\n\n这就涉及到线程并发的第一个问题：原子性。\n\n我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。\n\n```\n//取钱\nint tempAccount = accountBalance - money;\n\n//设置余额\naccountBalance = tempAccount;\n```\n\n为了实现这种错误的效果，我故意把\n\n```\naccountBalance -= accountBalance;\n```\n\n拆成了上面的两行。其实`accountBalance -= accountBalance;`本身就不是一个原子操作，拆成两行是为了放大这种效果。\n\n通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。\n\n原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。\n\njava中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。\n\n那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。\n\n### 可见性\n\n组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。\n\nJava虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）\n\n画个图：\n\n{% asset_img 内存模型.png 内存模型 %}\n\n这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。\n\n我们回到上述的例子：\n\n上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似`accountBalance -= accountBalance;`这样的操作是原子性操作，设想以下的场景：\n\n1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时`accountBalance~ = 20000;accountBalance = 10000;`\n\n2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时`accountBalance~ = 0;accountBalance = 10000;`\n\n3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；\n\n4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；\n\n通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。\n\n我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。\n\n### 有序性\n\nCpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。\n\n以下例子来自《深入理解Java虚拟机》：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\nconfigOptions = new HashMap();\nconfigText = readConfigFile(flieName);\nprocessConfigOptions(configText,configOptions);\ninitialized = true;\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\nwhile(!initialized){\n\tsleep();\n}\n//使用线程A中初始化好的配置信息\ndoSomethingWithConfig();\n```\n\n在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码`initialized=true`被提前执行，这样线程B中使用配置信息的代码就可能出现错误。\n\n所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\npublic synchronized void init(){\n\tconfigOptions = new HashMap();\n\tconfigText = readConfigFile(flieName);\n\tprocessConfigOptions(configText,configOptions);\n\tinitialized = true;\n}\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\npublic synchronized void doSomething(){\n\twhile(!initialized){\n\t\tsleep();\n\t}\n\t//使用线程A中初始化好的配置信息\n\tdoSomethingWithConfig();\n}\n```\n注意上面两个方法在同一个类中实现。\n\n至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇[synchronized的用法](http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/)，对synchronized的使用更加得心应手啦！\n\n## 先行发生原则\n\n没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。\n\n比如我想到了之前宇哥跟我提到的一个bug:\n\n在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。\n\n后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用`calendar.setTime(date);`,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个`calendar.setTime(date);`，结果肯定就变得混乱了。\n\n上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。\n\n解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。\n\n先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。\n\n还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：\n\n```\n//以下操作在线程A中执行\ni = 1;\n\n//以下操作在线程B中执行\nj = i;\n\n//以下操作在线程C中执行\ni = 2;\n```\n\n假设线程A中的操作`i=1`先行发生于线程B的操作`j=i`,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，`i=1`的结果可以被B观察到。\n\n现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。\n\n其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。\n\n你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性...\n\n如果还没有理解所谓的先行发生原则的话，可以看一下[这篇文章](http://ifeve.com/easy-happens-before/)。\n\n下面介绍几个java内存模型中存在的先行发生关系：\n\n**程序次序规则**：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。\n\n**管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。\n\n**volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。\n\n**传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。\n\n以上只是一部分先行发生关系，其他的不再一一介绍。\n\n那么，先行发生原则如何使用呢？我们看一个例子：\n\n```java\nprivate int value = 0;\n\npublic void setValue(int value){\n\tthis.value = value;\n}\n\npublic int getValue(){\n\treturn value;\n}\n```\n\n假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？\n\n套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看[这个](http://wiki.jikexueyuan.com/project/java-memory-model/lock.html)\n\n通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。\n\n## Volatile关键字\n\n通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。\n\nvolatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：**保证内存可见性和禁止重排序**。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：\n\n```java\npublic class VolatileTest {\n\tpublic static volatile int race = 0;\n\t\n\tpublic static void increase(){\n\t\trace++;\n\t}\n\t\n\tprivate static int THREAD_COUNT = 20;\n\t\n\tpublic static void main(String args[]) {\n\t\tThread[] threads = new Thread[THREAD_COUNT];\n\t\tfor (int i = 0; i < THREAD_COUNT; i++) {\n\t\t\tthreads[i] = new Thread(new Runnable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i< 10000; i++) {\n\t\t\t\t\t\tincrease();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthreads[i].start();\n\t\t}\n\t\twhile (Thread.activeCount()>1) {\n\t\t\tThread.yield();\n\t\t}\n\t\tSystem.out.println(race);\n\t}\n}\n\n```\n\n```\n运行结果：130310 //每次运行结果并不相同\n```\n\n可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于`race++`,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。\n\n这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。\n\n现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：**每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量**。\n\n当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。\n\n当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。\n\n关于volatile怎么实现内存可见性，是通过一个叫[内存屏障](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C)的东西来实现的。具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。\n\n关于volatile关键字的禁止重排序，具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n我们从先行发生原则的角度看一下volatile的禁止重排序：\n\n{% asset_img volatile.png volatile先行发生原则 %}\n\n其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。\n\n根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。\n\n即：**普通读写不能与其后的所有写volatile变量重排序**。同理，**普通读写不能与之前的所有读volatile变量重排序**。\n\n下面看看volatile的使用场景：\n\n1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n\n2.变量不需要与其他状态的变量共同参与不变约束。\n\n第一点就很好理解了，volatile不保证原子性嘛~~\n\n**第二点我也有点疑惑，待研究...**\n\n关于volatile的使用场景，可以看看这篇文章：[Java 理论与实践: 正确使用 Volatile 变量](http://www.ibm.com/developerworks/cn/java/j-jtp06197.html)\n\n## 最后\n\n终于把自己想要总结的写完了~~断断续续写了四个小时...好累...\n\n加油！\n\n\n\n\n\n","slug":"理解java内存模型","published":1,"updated":"2016-09-10T12:38:25.964Z","comments":1,"photos":[],"link":"","_id":"cisx6pop10023zsqcfkflog59","content":"<p>最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~</p>\n<h2 id=\"并发为啥会出现问题\"><a href=\"#并发为啥会出现问题\" class=\"headerlink\" title=\"并发为啥会出现问题\"></a>并发为啥会出现问题</h2><h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankAccount</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> accountBalance = <span class=\"number\">10000</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Save</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Save</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//存钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance + money;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次存入：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Obtain</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Obtain</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (money &gt; accountBalance) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"余额不足\"</span>);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//取钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance - money;</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//艾玛，卡了一秒</span></div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次取出：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> saveMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> obtainMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"comment\">//自己取钱</span></div><div class=\"line\">\t\tThread obtain = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Obtain(obtainMoney));</div><div class=\"line\">\t\t<span class=\"comment\">//老婆存钱</span></div><div class=\"line\">\t\tThread save = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Save(saveMoney));</div><div class=\"line\">\t\tobtain.start();</div><div class=\"line\">\t\tsave.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">此次存入：10000</div><div class=\"line\">当前余额：20000</div><div class=\"line\">此次取出：10000</div><div class=\"line\">当前余额：0</div></pre></td></tr></table></figure>\n<p>可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。</p>\n<p>分析一下出现问题的原因：</p>\n<p>出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。</p>\n<p>这就涉及到线程并发的第一个问题：原子性。</p>\n<p>我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//取钱</div><div class=\"line\">int tempAccount = accountBalance - money;</div><div class=\"line\"></div><div class=\"line\">//设置余额</div><div class=\"line\">accountBalance = tempAccount;</div></pre></td></tr></table></figure>\n<p>为了实现这种错误的效果，我故意把</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">accountBalance -= accountBalance;</div></pre></td></tr></table></figure>\n<p>拆成了上面的两行。其实<code>accountBalance -= accountBalance;</code>本身就不是一个原子操作，拆成两行是为了放大这种效果。</p>\n<p>通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。</p>\n<p>原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。</p>\n<p>java中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。</p>\n<p>那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。</p>\n<h3 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h3><p>组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。</p>\n<p>Java虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）</p>\n<p>画个图：</p>\n<img src=\"/2016/09/10/理解java内存模型/内存模型.png\" alt=\"内存模型\" title=\"内存模型\">\n<p>这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。</p>\n<p>我们回到上述的例子：</p>\n<p>上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似<code>accountBalance -= accountBalance;</code>这样的操作是原子性操作，设想以下的场景：</p>\n<p>1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时<code>accountBalance~ = 20000;accountBalance = 10000;</code></p>\n<p>2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时<code>accountBalance~ = 0;accountBalance = 10000;</code></p>\n<p>3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；</p>\n<p>4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；</p>\n<p>通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。</p>\n<p>我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。</p>\n<h3 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h3><p>Cpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。</p>\n<p>以下例子来自《深入理解Java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\">configOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">configText = readConfigFile(flieName);</div><div class=\"line\">processConfigOptions(configText,configOptions);</div><div class=\"line\">initialized = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\tsleep();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">doSomethingWithConfig();</div></pre></td></tr></table></figure>\n<p>在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码<code>initialized=true</code>被提前执行，这样线程B中使用配置信息的代码就可能出现错误。</p>\n<p>所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tconfigOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">\tconfigText = readConfigFile(flieName);</div><div class=\"line\">\tprocessConfigOptions(configText,configOptions);</div><div class=\"line\">\tinitialized = <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\t\tsleep();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">\tdoSomethingWithConfig();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意上面两个方法在同一个类中实现。</p>\n<p>至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇<a href=\"http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/\">synchronized的用法</a>，对synchronized的使用更加得心应手啦！</p>\n<h2 id=\"先行发生原则\"><a href=\"#先行发生原则\" class=\"headerlink\" title=\"先行发生原则\"></a>先行发生原则</h2><p>没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。</p>\n<p>比如我想到了之前宇哥跟我提到的一个bug:</p>\n<p>在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。</p>\n<p>后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用<code>calendar.setTime(date);</code>,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个<code>calendar.setTime(date);</code>，结果肯定就变得混乱了。</p>\n<p>上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。</p>\n<p>解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。</p>\n<p>先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。</p>\n<p>还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下操作在线程A中执行</div><div class=\"line\">i = 1;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程B中执行</div><div class=\"line\">j = i;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程C中执行</div><div class=\"line\">i = 2;</div></pre></td></tr></table></figure>\n<p>假设线程A中的操作<code>i=1</code>先行发生于线程B的操作<code>j=i</code>,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，<code>i=1</code>的结果可以被B观察到。</p>\n<p>现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。</p>\n<p>其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。</p>\n<p>你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性…</p>\n<p>如果还没有理解所谓的先行发生原则的话，可以看一下<a href=\"http://ifeve.com/easy-happens-before/\" target=\"_blank\" rel=\"external\">这篇文章</a>。</p>\n<p>下面介绍几个java内存模型中存在的先行发生关系：</p>\n<p><strong>程序次序规则</strong>：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。</p>\n<p><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。</p>\n<p><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。</p>\n<p><strong>传递性</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。</p>\n<p>以上只是一部分先行发生关系，其他的不再一一介绍。</p>\n<p>那么，先行发生原则如何使用呢？我们看一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？</p>\n<p>套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看<a href=\"http://wiki.jikexueyuan.com/project/java-memory-model/lock.html\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。</p>\n<h2 id=\"Volatile关键字\"><a href=\"#Volatile关键字\" class=\"headerlink\" title=\"Volatile关键字\"></a>Volatile关键字</h2><p>通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。</p>\n<p>volatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：<strong>保证内存可见性和禁止重排序</strong>。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> race = <span class=\"number\">0</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\trace++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> THREAD_COUNT = <span class=\"number\">20</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\tThread[] threads = <span class=\"keyword\">new</span> Thread[THREAD_COUNT];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; THREAD_COUNT; i++) &#123;</div><div class=\"line\">\t\t\tthreads[i] = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t\t\t</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"number\">10000</span>; i++) &#123;</div><div class=\"line\">\t\t\t\t\t\tincrease();</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t\tthreads[i].start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (Thread.activeCount()&gt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">\t\t\tThread.yield();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.println(race);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">运行结果：130310 //每次运行结果并不相同</div></pre></td></tr></table></figure>\n<p>可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于<code>race++</code>,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。</p>\n<p>这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。</p>\n<p>现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：<strong>每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量</strong>。</p>\n<p>当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。</p>\n<p>当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。</p>\n<p>关于volatile怎么实现内存可见性，是通过一个叫<a href=\"https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C\" target=\"_blank\" rel=\"external\">内存屏障</a>的东西来实现的。具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。</p>\n<p>关于volatile关键字的禁止重排序，具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>我们从先行发生原则的角度看一下volatile的禁止重排序：</p>\n<img src=\"/2016/09/10/理解java内存模型/volatile.png\" alt=\"volatile先行发生原则\" title=\"volatile先行发生原则\">\n<p>其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。</p>\n<p>根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。</p>\n<p>即：<strong>普通读写不能与其后的所有写volatile变量重排序</strong>。同理，<strong>普通读写不能与之前的所有读volatile变量重排序</strong>。</p>\n<p>下面看看volatile的使用场景：</p>\n<p>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>\n<p>2.变量不需要与其他状态的变量共同参与不变约束。</p>\n<p>第一点就很好理解了，volatile不保证原子性嘛~~</p>\n<p><strong>第二点我也有点疑惑，待研究…</strong></p>\n<p>关于volatile的使用场景，可以看看这篇文章：<a href=\"http://www.ibm.com/developerworks/cn/java/j-jtp06197.html\" target=\"_blank\" rel=\"external\">Java 理论与实践: 正确使用 Volatile 变量</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>终于把自己想要总结的写完了~~断断续续写了四个小时…好累…</p>\n<p>加油！</p>\n","excerpt":"","more":"<p>最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~</p>\n<h2 id=\"并发为啥会出现问题\"><a href=\"#并发为啥会出现问题\" class=\"headerlink\" title=\"并发为啥会出现问题\"></a>并发为啥会出现问题</h2><h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankAccount</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> accountBalance = <span class=\"number\">10000</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Save</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Save</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//存钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance + money;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次存入：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Obtain</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Obtain</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (money &gt; accountBalance) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"余额不足\"</span>);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//取钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance - money;</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//艾玛，卡了一秒</span></div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次取出：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> saveMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> obtainMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"comment\">//自己取钱</span></div><div class=\"line\">\t\tThread obtain = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Obtain(obtainMoney));</div><div class=\"line\">\t\t<span class=\"comment\">//老婆存钱</span></div><div class=\"line\">\t\tThread save = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Save(saveMoney));</div><div class=\"line\">\t\tobtain.start();</div><div class=\"line\">\t\tsave.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">此次存入：10000</div><div class=\"line\">当前余额：20000</div><div class=\"line\">此次取出：10000</div><div class=\"line\">当前余额：0</div></pre></td></tr></table></figure>\n<p>可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。</p>\n<p>分析一下出现问题的原因：</p>\n<p>出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。</p>\n<p>这就涉及到线程并发的第一个问题：原子性。</p>\n<p>我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//取钱</div><div class=\"line\">int tempAccount = accountBalance - money;</div><div class=\"line\"></div><div class=\"line\">//设置余额</div><div class=\"line\">accountBalance = tempAccount;</div></pre></td></tr></table></figure>\n<p>为了实现这种错误的效果，我故意把</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">accountBalance -= accountBalance;</div></pre></td></tr></table></figure>\n<p>拆成了上面的两行。其实<code>accountBalance -= accountBalance;</code>本身就不是一个原子操作，拆成两行是为了放大这种效果。</p>\n<p>通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。</p>\n<p>原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。</p>\n<p>java中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。</p>\n<p>那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。</p>\n<h3 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h3><p>组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。</p>\n<p>Java虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）</p>\n<p>画个图：</p>\n<img src=\"/2016/09/10/理解java内存模型/内存模型.png\" alt=\"内存模型\" title=\"内存模型\">\n<p>这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。</p>\n<p>我们回到上述的例子：</p>\n<p>上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似<code>accountBalance -= accountBalance;</code>这样的操作是原子性操作，设想以下的场景：</p>\n<p>1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时<code>accountBalance~ = 20000;accountBalance = 10000;</code></p>\n<p>2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时<code>accountBalance~ = 0;accountBalance = 10000;</code></p>\n<p>3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；</p>\n<p>4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；</p>\n<p>通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。</p>\n<p>我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。</p>\n<h3 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h3><p>Cpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。</p>\n<p>以下例子来自《深入理解Java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\">configOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">configText = readConfigFile(flieName);</div><div class=\"line\">processConfigOptions(configText,configOptions);</div><div class=\"line\">initialized = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\tsleep();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">doSomethingWithConfig();</div></pre></td></tr></table></figure>\n<p>在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码<code>initialized=true</code>被提前执行，这样线程B中使用配置信息的代码就可能出现错误。</p>\n<p>所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tconfigOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">\tconfigText = readConfigFile(flieName);</div><div class=\"line\">\tprocessConfigOptions(configText,configOptions);</div><div class=\"line\">\tinitialized = <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\t\tsleep();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">\tdoSomethingWithConfig();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意上面两个方法在同一个类中实现。</p>\n<p>至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇<a href=\"http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/\">synchronized的用法</a>，对synchronized的使用更加得心应手啦！</p>\n<h2 id=\"先行发生原则\"><a href=\"#先行发生原则\" class=\"headerlink\" title=\"先行发生原则\"></a>先行发生原则</h2><p>没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。</p>\n<p>比如我想到了之前宇哥跟我提到的一个bug:</p>\n<p>在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。</p>\n<p>后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用<code>calendar.setTime(date);</code>,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个<code>calendar.setTime(date);</code>，结果肯定就变得混乱了。</p>\n<p>上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。</p>\n<p>解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。</p>\n<p>先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。</p>\n<p>还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下操作在线程A中执行</div><div class=\"line\">i = 1;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程B中执行</div><div class=\"line\">j = i;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程C中执行</div><div class=\"line\">i = 2;</div></pre></td></tr></table></figure>\n<p>假设线程A中的操作<code>i=1</code>先行发生于线程B的操作<code>j=i</code>,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，<code>i=1</code>的结果可以被B观察到。</p>\n<p>现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。</p>\n<p>其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。</p>\n<p>你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性…</p>\n<p>如果还没有理解所谓的先行发生原则的话，可以看一下<a href=\"http://ifeve.com/easy-happens-before/\">这篇文章</a>。</p>\n<p>下面介绍几个java内存模型中存在的先行发生关系：</p>\n<p><strong>程序次序规则</strong>：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。</p>\n<p><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。</p>\n<p><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。</p>\n<p><strong>传递性</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。</p>\n<p>以上只是一部分先行发生关系，其他的不再一一介绍。</p>\n<p>那么，先行发生原则如何使用呢？我们看一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？</p>\n<p>套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看<a href=\"http://wiki.jikexueyuan.com/project/java-memory-model/lock.html\">这个</a></p>\n<p>通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。</p>\n<h2 id=\"Volatile关键字\"><a href=\"#Volatile关键字\" class=\"headerlink\" title=\"Volatile关键字\"></a>Volatile关键字</h2><p>通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。</p>\n<p>volatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：<strong>保证内存可见性和禁止重排序</strong>。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> race = <span class=\"number\">0</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\trace++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> THREAD_COUNT = <span class=\"number\">20</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\tThread[] threads = <span class=\"keyword\">new</span> Thread[THREAD_COUNT];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; THREAD_COUNT; i++) &#123;</div><div class=\"line\">\t\t\tthreads[i] = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t\t\t</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"number\">10000</span>; i++) &#123;</div><div class=\"line\">\t\t\t\t\t\tincrease();</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t\tthreads[i].start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (Thread.activeCount()&gt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">\t\t\tThread.yield();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.println(race);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">运行结果：130310 //每次运行结果并不相同</div></pre></td></tr></table></figure>\n<p>可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于<code>race++</code>,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。</p>\n<p>这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。</p>\n<p>现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：<strong>每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量</strong>。</p>\n<p>当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。</p>\n<p>当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。</p>\n<p>关于volatile怎么实现内存可见性，是通过一个叫<a href=\"https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C\">内存屏障</a>的东西来实现的。具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\">这个</a></p>\n<p>所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。</p>\n<p>关于volatile关键字的禁止重排序，具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\">这个</a></p>\n<p>我们从先行发生原则的角度看一下volatile的禁止重排序：</p>\n<img src=\"/2016/09/10/理解java内存模型/volatile.png\" alt=\"volatile先行发生原则\" title=\"volatile先行发生原则\">\n<p>其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。</p>\n<p>根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。</p>\n<p>即：<strong>普通读写不能与其后的所有写volatile变量重排序</strong>。同理，<strong>普通读写不能与之前的所有读volatile变量重排序</strong>。</p>\n<p>下面看看volatile的使用场景：</p>\n<p>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>\n<p>2.变量不需要与其他状态的变量共同参与不变约束。</p>\n<p>第一点就很好理解了，volatile不保证原子性嘛~~</p>\n<p><strong>第二点我也有点疑惑，待研究…</strong></p>\n<p>关于volatile的使用场景，可以看看这篇文章：<a href=\"http://www.ibm.com/developerworks/cn/java/j-jtp06197.html\">Java 理论与实践: 正确使用 Volatile 变量</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>终于把自己想要总结的写完了~~断断续续写了四个小时…好累…</p>\n<p>加油！</p>\n"},{"layout":"post","title":"理解notify notifyall sleep","date":"2016-08-31T13:27:09.000Z","_content":"\n今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。\n\n## 从线程状态说起\n\n一般的操作系统中，线程的状态大概有这么几个：\n\n1. 执行：线程获得cpu，程序正在执行\n\n2. 就绪：线程已经准备好运行，只要获得cpu，便立即执行\n\n3. 阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度\n\n4. 挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。\n\n5. 激活：把一个挂起的线程激活\n\n着重理解一下几个关键状态的转换：\n\n活动就绪-->静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。\n\n活动阻塞-->静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。\n\n注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。\n\n画个图理解一下：\n\n{% asset_img 线程状态.png %}\n\n线程创建和终止状态不再讨论。\n\n## wait\n\nwait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。\n\n当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。\n\n调用wait方法，相当于上图中从执行到活动阻塞的过程。但也有一些区别，wait方法释放了对象的锁，然后阻塞，等待被唤醒。\n\n## notify\n\n当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。\n\n此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图从活动阻塞到活动就绪的过程。此时线程等待调度执行。\n\n需要注意的是，notify不恰当使用很有可能造成死锁问题。\n\n## notifyAll\n\n当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒的线程(调用了A的wait方法的线程)唤醒。这些线程会竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。\n\n## sleep\n\n与以上三个关键字不同的是，sleep方法是Thread中的方法。\n\n当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。\n\n调用线程Y的sleep(1000)sleep方法，相当于上图中从执行到静止就绪状态。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。\n\n## 使用场景\n\nObject.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？\n\n在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。\n\n例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。","source":"_posts/理解notify notifyall sleep.md","raw":"layout: post\ntitle: 理解notify notifyall sleep\ndate: 2016-08-31 21:27:09\ncategories: 编程\ntags:\n- java\n- 多线程 \n---\n\n今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。\n\n## 从线程状态说起\n\n一般的操作系统中，线程的状态大概有这么几个：\n\n1. 执行：线程获得cpu，程序正在执行\n\n2. 就绪：线程已经准备好运行，只要获得cpu，便立即执行\n\n3. 阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度\n\n4. 挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。\n\n5. 激活：把一个挂起的线程激活\n\n着重理解一下几个关键状态的转换：\n\n活动就绪-->静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。\n\n活动阻塞-->静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。\n\n注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。\n\n画个图理解一下：\n\n{% asset_img 线程状态.png %}\n\n线程创建和终止状态不再讨论。\n\n## wait\n\nwait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。\n\n当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。\n\n调用wait方法，相当于上图中从执行到活动阻塞的过程。但也有一些区别，wait方法释放了对象的锁，然后阻塞，等待被唤醒。\n\n## notify\n\n当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。\n\n此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图从活动阻塞到活动就绪的过程。此时线程等待调度执行。\n\n需要注意的是，notify不恰当使用很有可能造成死锁问题。\n\n## notifyAll\n\n当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒的线程(调用了A的wait方法的线程)唤醒。这些线程会竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。\n\n## sleep\n\n与以上三个关键字不同的是，sleep方法是Thread中的方法。\n\n当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。\n\n调用线程Y的sleep(1000)sleep方法，相当于上图中从执行到静止就绪状态。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。\n\n## 使用场景\n\nObject.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？\n\n在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。\n\n例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。","slug":"理解notify notifyall sleep","published":1,"updated":"2016-08-31T16:18:28.478Z","comments":1,"photos":[],"link":"","_id":"cisx6popg0027zsqc7flbqvcc","content":"<p>今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。</p>\n<h2 id=\"从线程状态说起\"><a href=\"#从线程状态说起\" class=\"headerlink\" title=\"从线程状态说起\"></a>从线程状态说起</h2><p>一般的操作系统中，线程的状态大概有这么几个：</p>\n<ol>\n<li><p>执行：线程获得cpu，程序正在执行</p>\n</li>\n<li><p>就绪：线程已经准备好运行，只要获得cpu，便立即执行</p>\n</li>\n<li><p>阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度</p>\n</li>\n<li><p>挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。</p>\n</li>\n<li><p>激活：把一个挂起的线程激活</p>\n</li>\n</ol>\n<p>着重理解一下几个关键状态的转换：</p>\n<p>活动就绪–&gt;静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。</p>\n<p>活动阻塞–&gt;静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。</p>\n<p>注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。</p>\n<p>画个图理解一下：</p>\n<img src=\"/2016/08/31/理解notify%20notifyall%20sleep/线程状态.png\" alt=\"线程状态.png\" title=\"\">\n<p>线程创建和终止状态不再讨论。</p>\n<h2 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h2><p>wait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。</p>\n<p>当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。</p>\n<p>调用wait方法，相当于上图中从执行到活动阻塞的过程。但也有一些区别，wait方法释放了对象的锁，然后阻塞，等待被唤醒。</p>\n<h2 id=\"notify\"><a href=\"#notify\" class=\"headerlink\" title=\"notify\"></a>notify</h2><p>当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。</p>\n<p>此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图从活动阻塞到活动就绪的过程。此时线程等待调度执行。</p>\n<p>需要注意的是，notify不恰当使用很有可能造成死锁问题。</p>\n<h2 id=\"notifyAll\"><a href=\"#notifyAll\" class=\"headerlink\" title=\"notifyAll\"></a>notifyAll</h2><p>当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒的线程(调用了A的wait方法的线程)唤醒。这些线程会竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。</p>\n<h2 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep\"></a>sleep</h2><p>与以上三个关键字不同的是，sleep方法是Thread中的方法。</p>\n<p>当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。</p>\n<p>调用线程Y的sleep(1000)sleep方法，相当于上图中从执行到静止就绪状态。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>Object.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？</p>\n<p>在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。</p>\n<p>例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。</p>\n","excerpt":"","more":"<p>今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。</p>\n<h2 id=\"从线程状态说起\"><a href=\"#从线程状态说起\" class=\"headerlink\" title=\"从线程状态说起\"></a>从线程状态说起</h2><p>一般的操作系统中，线程的状态大概有这么几个：</p>\n<ol>\n<li><p>执行：线程获得cpu，程序正在执行</p>\n</li>\n<li><p>就绪：线程已经准备好运行，只要获得cpu，便立即执行</p>\n</li>\n<li><p>阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度</p>\n</li>\n<li><p>挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。</p>\n</li>\n<li><p>激活：把一个挂起的线程激活</p>\n</li>\n</ol>\n<p>着重理解一下几个关键状态的转换：</p>\n<p>活动就绪–&gt;静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。</p>\n<p>活动阻塞–&gt;静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。</p>\n<p>注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。</p>\n<p>画个图理解一下：</p>\n<img src=\"/2016/08/31/理解notify%20notifyall%20sleep/线程状态.png\" alt=\"线程状态.png\" title=\"\">\n<p>线程创建和终止状态不再讨论。</p>\n<h2 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h2><p>wait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。</p>\n<p>当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。</p>\n<p>调用wait方法，相当于上图中从执行到活动阻塞的过程。但也有一些区别，wait方法释放了对象的锁，然后阻塞，等待被唤醒。</p>\n<h2 id=\"notify\"><a href=\"#notify\" class=\"headerlink\" title=\"notify\"></a>notify</h2><p>当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。</p>\n<p>此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图从活动阻塞到活动就绪的过程。此时线程等待调度执行。</p>\n<p>需要注意的是，notify不恰当使用很有可能造成死锁问题。</p>\n<h2 id=\"notifyAll\"><a href=\"#notifyAll\" class=\"headerlink\" title=\"notifyAll\"></a>notifyAll</h2><p>当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒的线程(调用了A的wait方法的线程)唤醒。这些线程会竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。</p>\n<h2 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep\"></a>sleep</h2><p>与以上三个关键字不同的是，sleep方法是Thread中的方法。</p>\n<p>当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。</p>\n<p>调用线程Y的sleep(1000)sleep方法，相当于上图中从执行到静止就绪状态。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>Object.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？</p>\n<p>在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。</p>\n<p>例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。</p>\n"}],"PostAsset":[{"_id":"source/_posts/毕业了/graduation3.jpg","slug":"graduation3.jpg","post":"cisx6pop10020zsqc70khn3xn","modified":1,"renderable":0},{"_id":"source/_posts/毕业了/graduation2.jpg","slug":"graduation2.jpg","post":"cisx6pop10020zsqc70khn3xn","modified":1,"renderable":0},{"_id":"source/_posts/毕业了/graduation8.jpg","slug":"graduation8.jpg","post":"cisx6pop10020zsqc70khn3xn","modified":1,"renderable":0},{"_id":"source/_posts/Java集合框架学习总结/collection.png","post":"cisx6polk0002zsqc80bvf3gv","slug":"collection.png","modified":1,"renderable":1},{"_id":"source/_posts/java中的equals与hashcode/entry.png","post":"cisx6pomf000bzsqc5ualr40q","slug":"entry.png","modified":1,"renderable":1},{"_id":"source/_posts/他可是科比·布莱恩特!/kobe.jpg","post":"cisx6poo5001hzsqczh2vrgrq","slug":"kobe.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于加密的一点总结/md5.png","post":"cisx6poo5001kzsqc0lvzctdo","slug":"md5.png","modified":1,"renderable":1},{"_id":"source/_posts/理解notify notifyall sleep/线程状态.png","post":"cisx6popg0027zsqc7flbqvcc","slug":"线程状态.png","modified":1,"renderable":1},{"_id":"source/_posts/理解java内存模型/volatile.png","post":"cisx6pop10023zsqcfkflog59","slug":"volatile.png","modified":1,"renderable":1},{"_id":"source/_posts/理解java内存模型/内存模型.png","post":"cisx6pop10023zsqcfkflog59","slug":"内存模型.png","modified":1,"renderable":1},{"_id":"source/_posts/java中的编码问题/reader.png","post":"cisx6pomu000kzsqc1q6x2an9","slug":"reader.png","modified":1,"renderable":1},{"_id":"source/_posts/java中的编码问题/utf8.png","post":"cisx6pomu000kzsqc1q6x2an9","slug":"utf8.png","modified":1,"renderable":1},{"_id":"source/_posts/java中的编码问题/writer.png","post":"cisx6pomu000kzsqc1q6x2an9","slug":"writer.png","modified":1,"renderable":1},{"_id":"source/_posts/毕业了/graduation1.jpg","slug":"graduation1.jpg","post":"cisx6pop10020zsqc70khn3xn","modified":1,"renderable":0},{"_id":"source/_posts/毕业了/graduation4.jpg","slug":"graduation4.jpg","post":"cisx6pop10020zsqc70khn3xn","modified":1,"renderable":0},{"_id":"source/_posts/毕业了/graduation5.jpg","post":"cisx6pop10020zsqc70khn3xn","slug":"graduation5.jpg","modified":1,"renderable":1},{"_id":"source/_posts/毕业了/graduation6.jpg","post":"cisx6pop10020zsqc70khn3xn","slug":"graduation6.jpg","modified":1,"renderable":1},{"_id":"source/_posts/毕业了/graduation7.jpg","slug":"graduation7.jpg","post":"cisx6pop10020zsqc70khn3xn","modified":1,"renderable":0}],"PostCategory":[{"post_id":"cisx6pol40000zsqcda89bi4n","category_id":"cisx6polz0004zsqcxuvdyt9t","_id":"cisx6pomu000czsqce5k94bx2"},{"post_id":"cisx6pomf000bzsqc5ualr40q","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6pomu000jzsqcxu9dcz4y"},{"post_id":"cisx6polk0002zsqc80bvf3gv","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6pona000ozsqc97i2s0hb"},{"post_id":"cisx6pomu000dzsqc4epcu70d","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6pona000rzsqczgtf436n"},{"post_id":"cisx6pomu000hzsqcvjbfhoxk","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6pona000wzsqc9n2iib4e"},{"post_id":"cisx6polz0005zsqcqe4yhk6a","category_id":"cisx6polz0004zsqcxuvdyt9t","_id":"cisx6pona000zzsqcf5wbkb50"},{"post_id":"cisx6pomu000kzsqc1q6x2an9","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6ponq0013zsqc4nborvxq"},{"post_id":"cisx6pona000pzsqcvtxqcx98","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6ponq0015zsqc1mbhh9cn"},{"post_id":"cisx6polz0006zsqcu0mfkk4g","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6ponq0018zsqcmox73zh3"},{"post_id":"cisx6pona000szsqcomk9r6og","category_id":"cisx6polz0004zsqcxuvdyt9t","_id":"cisx6poo5001bzsqc1h1uyff5"},{"post_id":"cisx6pona000xzsqcosqyz3r5","category_id":"cisx6polz0004zsqcxuvdyt9t","_id":"cisx6poo5001gzsqcukv86eik"},{"post_id":"cisx6polz0008zsqcqetm2k5f","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6poo5001jzsqcivpfa68k"},{"post_id":"cisx6pona0010zsqcpblwg8jq","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6poo5001mzsqclsb3buo0"},{"post_id":"cisx6ponq0014zsqckm7bl98j","category_id":"cisx6polz0004zsqcxuvdyt9t","_id":"cisx6pool001rzsqcmlc44v0p"},{"post_id":"cisx6ponq0016zsqc5m8zqqst","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6pop1001uzsqcot1w3hz3"},{"post_id":"cisx6poo5001czsqcmnn3f5t0","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6pop1001zzsqc5a09hs9k"},{"post_id":"cisx6ponq0019zsqc514htfm9","category_id":"cisx6poo5001fzsqcefz42wps","_id":"cisx6pop10022zsqc9mahly7p"},{"post_id":"cisx6poo5001ozsqc7agqg4oi","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6popg0026zsqc3bzzjx92"},{"post_id":"cisx6pool001szsqcy5utrvev","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6popg0029zsqcrijwrfnj"},{"post_id":"cisx6poo5001hzsqczh2vrgrq","category_id":"cisx6poo5001fzsqcefz42wps","_id":"cisx6popg002czsqc7eiouxr5"},{"post_id":"cisx6pop1001wzsqc1phrgum2","category_id":"cisx6polz0004zsqcxuvdyt9t","_id":"cisx6popw002ezsqckwjfepem"},{"post_id":"cisx6pop10020zsqc70khn3xn","category_id":"cisx6poo5001fzsqcefz42wps","_id":"cisx6popw002hzsqcoqr53okw"},{"post_id":"cisx6poo5001kzsqc0lvzctdo","category_id":"cisx6pop1001xzsqc715lvz6z","_id":"cisx6popw002jzsqcpn8j7laj"},{"post_id":"cisx6pop10023zsqcfkflog59","category_id":"cisx6pop1001xzsqc715lvz6z","_id":"cisx6popw002mzsqca1l4e12v"},{"post_id":"cisx6popg0027zsqc7flbqvcc","category_id":"cisx6pomf0009zsqcytekf40q","_id":"cisx6popw002ozsqc6gaeixml"}],"PostTag":[{"post_id":"cisx6polz0006zsqcu0mfkk4g","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6pomf000azsqcfiuim8ea"},{"post_id":"cisx6pomf000bzsqc5ualr40q","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6pomu000gzsqcoay3ayts"},{"post_id":"cisx6pol40000zsqcda89bi4n","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6pomu000izsqc6c6lf8ih"},{"post_id":"cisx6pol40000zsqcda89bi4n","tag_id":"cisx6polz0007zsqcpwk4sts4","_id":"cisx6pona000nzsqc3ivj17ay"},{"post_id":"cisx6pomu000dzsqc4epcu70d","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6pona000qzsqcwa0qwv7v"},{"post_id":"cisx6pomu000hzsqcvjbfhoxk","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6pona000vzsqcmkvet870"},{"post_id":"cisx6polk0002zsqc80bvf3gv","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6pona000yzsqch42qyey7"},{"post_id":"cisx6polk0002zsqc80bvf3gv","tag_id":"cisx6pona000lzsqcq0sijany","_id":"cisx6ponq0012zsqccf102euj"},{"post_id":"cisx6polz0005zsqcqe4yhk6a","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6ponq001azsqcavmfcgyp"},{"post_id":"cisx6polz0005zsqcqe4yhk6a","tag_id":"cisx6polz0007zsqcpwk4sts4","_id":"cisx6poo5001dzsqcdghr6jsj"},{"post_id":"cisx6polz0008zsqcqetm2k5f","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6poo5001izsqc2hznzjv9"},{"post_id":"cisx6polz0008zsqcqetm2k5f","tag_id":"cisx6ponq0017zsqcc77096bz","_id":"cisx6poo5001lzsqcqgwmu3ci"},{"post_id":"cisx6poo5001czsqcmnn3f5t0","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6pool001qzsqc71mllny6"},{"post_id":"cisx6pomu000kzsqc1q6x2an9","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6pool001tzsqcn87dhp6v"},{"post_id":"cisx6pomu000kzsqc1q6x2an9","tag_id":"cisx6poo5001ezsqcb6fhnrc4","_id":"cisx6pop1001yzsqcdnupnj1p"},{"post_id":"cisx6poo5001ozsqc7agqg4oi","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6pop10021zsqcwnr672j8"},{"post_id":"cisx6pool001szsqcy5utrvev","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6popg0025zsqcxjcbjld4"},{"post_id":"cisx6pona000pzsqcvtxqcx98","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6popg0028zsqcmnqiqlpy"},{"post_id":"cisx6pona000pzsqcvtxqcx98","tag_id":"cisx6ponq0017zsqcc77096bz","_id":"cisx6popg002bzsqc9qqafwc0"},{"post_id":"cisx6pop10023zsqcfkflog59","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6popw002dzsqcl5trj1cn"},{"post_id":"cisx6popg0027zsqc7flbqvcc","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6popw002fzsqc0ie1p0vj"},{"post_id":"cisx6popg0027zsqc7flbqvcc","tag_id":"cisx6ponq0017zsqcc77096bz","_id":"cisx6popw002izsqcke7zj7qu"},{"post_id":"cisx6pona000szsqcomk9r6og","tag_id":"cisx6pop1001vzsqcof2chcab","_id":"cisx6popw002kzsqc0uibabqs"},{"post_id":"cisx6pona000szsqcomk9r6og","tag_id":"cisx6popg0024zsqcpe2qlhsc","_id":"cisx6popw002nzsqcjdya1szg"},{"post_id":"cisx6pona000xzsqcosqyz3r5","tag_id":"cisx6popg002azsqcbrsvy0hv","_id":"cisx6popw002pzsqcqvefjjao"},{"post_id":"cisx6pona0010zsqcpblwg8jq","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6popw002rzsqc0y17onjk"},{"post_id":"cisx6pona0010zsqcpblwg8jq","tag_id":"cisx6ponq0017zsqcc77096bz","_id":"cisx6popw002szsqchj2cewl0"},{"post_id":"cisx6ponq0014zsqckm7bl98j","tag_id":"cisx6popw002lzsqcmwsom5vx","_id":"cisx6popw002uzsqc7oxyux7v"},{"post_id":"cisx6ponq0014zsqckm7bl98j","tag_id":"cisx6poo5001ezsqcb6fhnrc4","_id":"cisx6popw002vzsqc5tu27svp"},{"post_id":"cisx6ponq0016zsqc5m8zqqst","tag_id":"cisx6ponq0017zsqcc77096bz","_id":"cisx6popw002xzsqc8n1e7enl"},{"post_id":"cisx6ponq0016zsqc5m8zqqst","tag_id":"cisx6polk0003zsqcsqh5pfvw","_id":"cisx6popw002yzsqcq9q8xe0y"},{"post_id":"cisx6poo5001kzsqc0lvzctdo","tag_id":"cisx6popw002wzsqciljwnsjr","_id":"cisx6popw0030zsqc6ytkfbl6"},{"post_id":"cisx6pop1001wzsqc1phrgum2","tag_id":"cisx6popw002zzsqckon1gzfe","_id":"cisx6popw0031zsqcl5s7uxkx"}],"Tag":[{"name":"java","_id":"cisx6polk0003zsqcsqh5pfvw"},{"name":"ant","_id":"cisx6polz0007zsqcpwk4sts4"},{"name":"源码","_id":"cisx6pona000lzsqcq0sijany"},{"name":"多线程","_id":"cisx6ponq0017zsqcc77096bz"},{"name":"编码","_id":"cisx6poo5001ezsqcb6fhnrc4"},{"name":"junit","_id":"cisx6pop1001vzsqcof2chcab"},{"name":"测试","_id":"cisx6popg0024zsqcpe2qlhsc"},{"name":"markdown","_id":"cisx6popg002azsqcbrsvy0hv"},{"name":"python","_id":"cisx6popw002lzsqcmwsom5vx"},{"name":"加密","_id":"cisx6popw002wzsqciljwnsjr"},{"name":"快捷键","_id":"cisx6popw002zzsqckon1gzfe"}]}}