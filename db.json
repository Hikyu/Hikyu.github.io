{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/pacman/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/author.jpg","path":"img/author.jpg","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/xiaoxin.ico","path":"img/xiaoxin.ico","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/xiaoxin.png","path":"img/xiaoxin.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/xiaoxin.jpg","path":"img/xiaoxin.jpg","modified":0,"renderable":1},{"_id":"themes/pacman/source/js/jquery-2.1.0.min.js","path":"js/jquery-2.1.0.min.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"75913de577e6e2674855228ebb98f985574fdca1","modified":1487509691028},{"_id":"themes/pacman/LICENSE","hash":"0138565d68df6e5536667ad445232981ea808aec","modified":1487509691054},{"_id":"themes/pacman/README.md","hash":"d7efa5614e13f8fc7db5e9030e4cc2b27c2df171","modified":1487509691054},{"_id":"themes/pacman/_config.yml","hash":"faa5b9a5a4f51f269aa37be6a09b40995a30aebd","modified":1487509691054},{"_id":"source/_posts/Ant的使用.md","hash":"ad6ab972acbe476c585db9f8a89cc97fd38f05cd","modified":1487509691028},{"_id":"source/_posts/Eclipse编码问题终极解决方案.md","hash":"b81e4d14525e6bfa71fdc73ab5063af5183b9caa","modified":1487509691028},{"_id":"source/_posts/I-O总结.md","hash":"9977c5d60a5b3dd0bf3824ab79971c1ca733b433","modified":1490767589989},{"_id":"source/_posts/Java集合框架学习总结.md","hash":"b2f0e5b0f86ace849a277b685434c97c5b6d63cb","modified":1487509691031},{"_id":"source/_posts/Linux的五个查找命令.md","hash":"4017d9b582edc3a3aec531196ad6a15bb4585632","modified":1488072361000},{"_id":"source/_posts/Spring项目打包为jar.md","hash":"d2d06daa86fc823a5aedf7aed418d66955ea01e6","modified":1487509691031},{"_id":"source/_posts/Vps使用笔记.md","hash":"02ac30321a9feaf0a14594ee756445919b423770","modified":1487509691032},{"_id":"source/_posts/ant编译java工程jdk路径的设置.md","hash":"cead1fd3259cf027e655cad04ddc051dba143e54","modified":1487509691032},{"_id":"source/_posts/centos7BCM驱动安装.md","hash":"918ad4ec1b74622488b6153d4547ecb482b139b6","modified":1488006740292},{"_id":"source/_posts/java_Tips.md","hash":"16c88dafce04df5ab7fa02456033c8a9f1668fc4","modified":1487509691033},{"_id":"source/_posts/java中的ThreadLocal.md","hash":"1111a383a4f0cf8dac77742bef59ab9f4e2eb899","modified":1487509691033},{"_id":"source/_posts/java中的equals与hashcode.md","hash":"77cc119bc5c8f8e37574a4b424437f6e87c9ea3c","modified":1487509691033},{"_id":"source/_posts/java中的int/byte互转.md","hash":"1e03e7c37002ccb9593f1dbcf155af18e7784981","modified":1487509691033},{"_id":"source/_posts/java中的枚举.md","hash":"d484013f17b93148d2e615b7cac3d7082fcf6291","modified":1487509691033},{"_id":"source/_posts/java中的类型转换.md","hash":"c020fc75944a55f877a133e7edecf7553926217b","modified":1487509691033},{"_id":"source/_posts/java中的编码问题.md","hash":"20fc99083e25783d9edec744120624058b972663","modified":1487509691033},{"_id":"source/_posts/java中的路径.md","hash":"3cea51dc84e0f295e9f9cc0bcfbbbe4003c84ca0","modified":1490767668031},{"_id":"source/_posts/java代理机制.md","hash":"b172c51104ab2992ec5ae3428bc0f90658c865b6","modified":1490757780399},{"_id":"source/_posts/java同步锁锁什么.md","hash":"68a5cc79e9ebfad12392ca7ab1f1b6e65712b181","modified":1487509691034},{"_id":"source/_posts/java国际化.md","hash":"a4302a37d53c3897a178f706898c2eaa321fee88","modified":1487510117719},{"_id":"source/_posts/java序列化与反序列化.md","hash":"e08751fb37d9d6ad912f5d73b1650cc35f623bc3","modified":1490757509497},{"_id":"source/_posts/java异常的学习.md","hash":"e846ab9535298dd85ae2d99ceedf983edf5e9fb7","modified":1487509691034},{"_id":"source/_posts/java日志使用.md","hash":"0e6da6b1d184fd2517206885a2c7a61d41eabadd","modified":1487769755571},{"_id":"source/_posts/java泛型学习.md","hash":"5c2373436e63c9b045106ff58da2c1ec1b960b26","modified":1487509691034},{"_id":"source/_posts/java注解.md","hash":"94640c2f1a320821b66d4c377c5aeac9379f6e4d","modified":1491100339000},{"_id":"source/_posts/java线程中断总结.md","hash":"897e778ee0e6b13158eeb4a4d855ec95e8f05f2b","modified":1487509691035},{"_id":"source/_posts/java远程调试学习.md","hash":"334ccbaecfb2b926067f7bbc4423befce31adb9d","modified":1490767692000},{"_id":"source/_posts/junit使用.md","hash":"4c06f84517b5918b4257ad5993f6c8d4b423b85a","modified":1487509691036},{"_id":"source/_posts/linux分区.md","hash":"821c6bd0d0b99a47b95a7e786df48b5e426a5b8b","modified":1488718167753},{"_id":"source/_posts/markdown.md","hash":"a7d4f052cd3802f3a1ebbabf91bfa47129bcf79c","modified":1487509691036},{"_id":"source/_posts/notify问题.md","hash":"62c8a233c9d484fd9dafa3c29ec999581b29d313","modified":1487509691036},{"_id":"source/_posts/sphinx安装问题.md","hash":"65e54c0c48d1ebd0eff1277e657e6faa14fd2526","modified":1487509691036},{"_id":"source/_posts/ssh的两种用法.md","hash":"091517b31a3cc3cf04fdb2599104ed6476a82920","modified":1487853294645},{"_id":"source/_posts/ssl总结.md","hash":"202833382b04ec912a5b5469bbfec0feb8908bfc","modified":1487509691036},{"_id":"source/_posts/synchronized的一些用法.md","hash":"304192e87d0f57d71808ebee2ad334412f50aaac","modified":1487509691038},{"_id":"source/_posts/webservice相关.md","hash":"f6395d7868586e21f57edcc124bffa8574477b47","modified":1489587633000},{"_id":"source/_posts/win7与centos7双系统安装.md","hash":"3eb9d79d5358eeee8ec288f144c7f1792c830c8c","modified":1487509691038},{"_id":"source/_posts/一些计划.md","hash":"d382a597742dbfb3b039b7db2caf5352a8b32ad1","modified":1487509691038},{"_id":"source/_posts/为什么是final.md","hash":"026e6818b24f856bcfc45abeeedef83b51a01a81","modified":1487509691038},{"_id":"source/_posts/他可是科比·布莱恩特!.md","hash":"928198fb521d3f19425ed374d55b68e0c020c50c","modified":1487509691038},{"_id":"source/_posts/代码格式.md","hash":"097926e9a86497f17b0a13a7d73e12227c6d3c97","modified":1487509691038},{"_id":"source/_posts/关于加密的一点总结.md","hash":"1cf22a4128ae294794a1044fae63db9e3e8e1317","modified":1487509691039},{"_id":"source/_posts/关于抽象类和接口.md","hash":"fc655dc5bce1978904d31c3c89490b4fafc51210","modified":1487509691039},{"_id":"source/_posts/常用快捷键总结.md","hash":"70cd5116a478ce7c1c57efc1dcc35ea78bd4771f","modified":1487509691039},{"_id":"source/_posts/毕业了.md","hash":"581ef7d10cf5eb71884b3d13588df23c658d1b35","modified":1487509691039},{"_id":"source/_posts/理解java内存模型.md","hash":"d91a2d1daa94f07322ce9f4ed37ce4c5d3cff725","modified":1487509691044},{"_id":"source/_posts/理解notify notifyall sleep.md","hash":"469f165b53e2a9ed3e66aa568a2874487c662f67","modified":1487509691045},{"_id":"source/_posts/记录这周工作遇到的坑.md","hash":"ed63eb9875e7fdc0adf389172aa957b1f9bbd0a9","modified":1487509691045},{"_id":"source/page/index.md","hash":"aae446d1d6ef6bf243f854eb58fcc717d36615a4","modified":1487509691046},{"_id":"themes/pacman/languages/default.yml","hash":"7e9594aa9551cd4841905b4b4d4fcabc2b40e447","modified":1487509691054},{"_id":"themes/pacman/languages/zh-CN.yml","hash":"991b90926686c0d10731a8f4ea61b96c3f087531","modified":1487509691054},{"_id":"themes/pacman/languages/zh-TW.yml","hash":"48b652fa2eb73f9f7cd512472d0cb20057152aea","modified":1487509691054},{"_id":"themes/pacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1487509691056},{"_id":"themes/pacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1487509691056},{"_id":"themes/pacman/layout/index.ejs","hash":"774f7e89d05e9a9b43970a873d5100ad5c9d21ba","modified":1487509691056},{"_id":"themes/pacman/layout/layout.ejs","hash":"87b543229bec7e77cc0ec68cfdd11f2f33df4a1b","modified":1487509691056},{"_id":"themes/pacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1487509691056},{"_id":"themes/pacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1487509691056},{"_id":"themes/pacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1487509691056},{"_id":"themes/pacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1487509691056},{"_id":"source/_posts/Eclipse编码问题终极解决方案/2.png","hash":"4dd8a8d179e898c803a879fec14afb855a34b23d","modified":1487509691029},{"_id":"source/_posts/Eclipse编码问题终极解决方案/3.png","hash":"d62218e89ab63a0c4a05ebfd35192b7f3c031588","modified":1487509691029},{"_id":"source/_posts/Eclipse编码问题终极解决方案/4.png","hash":"5ef56fc1e37d46da093fbf0b94273b45eb3cb8bd","modified":1487509691030},{"_id":"source/_posts/Eclipse编码问题终极解决方案/5.png","hash":"7fc75d3a44bebd24c9df7ad7e7d49d70de611325","modified":1487509691030},{"_id":"source/_posts/I-O总结/child-817369__340.jpg","hash":"bd3bc9c879086c56a6b11fb9bf537a7aefea6bbf","modified":1490272082421},{"_id":"source/_posts/I-O总结/decoder.jpg","hash":"3ade788875dedb4a1bfb181edb2e6a3124e80f82","modified":1489933552408},{"_id":"source/_posts/I-O总结/decorator.jpg","hash":"7cc2521b403bd45ab7078ee7eb9557e0df6ccc65","modified":1489929803236},{"_id":"source/_posts/I-O总结/encoder.jpg","hash":"d4eb18c566bc686b1ef2c570e54e30cfbba3dec3","modified":1489933562852},{"_id":"source/_posts/Java集合框架学习总结/collection.png","hash":"9644281b68a057f4db9b162c45ac4c076c7c5651","modified":1487509691031},{"_id":"source/_posts/Spring项目打包为jar/2.png","hash":"7ff532cc98f22996c89a2a590954c113e2de486f","modified":1487509691032},{"_id":"source/_posts/Spring项目打包为jar/3.png","hash":"a6c93e41c454ca4d89a2c5153ff74ac3c9eec04a","modified":1487509691032},{"_id":"source/_posts/Spring项目打包为jar/4.png","hash":"644dca24dfefc583f2b222e967962d2de68452bb","modified":1487509691032},{"_id":"source/_posts/Spring项目打包为jar/5.png","hash":"7c9911eab320a22ef1a310dfb15a8996aa37de2b","modified":1487509691032},{"_id":"source/_posts/centos7BCM驱动安装/demo.png","hash":"bcc155b1952c95c1e4f710668c1fbf66c3fec530","modified":1488006286628},{"_id":"source/_posts/java中的equals与hashcode/entry.png","hash":"c6c32336b30c74d2e825684e590fc8bb15af2dc1","modified":1487509691033},{"_id":"source/_posts/java中的编码问题/reader.png","hash":"4cf16c765f0952a9134bc5097270d3a6b2679f76","modified":1487509691033},{"_id":"source/_posts/java中的编码问题/utf8.png","hash":"f4a2eb95b15e12d6957c07099fafd42d9b6c035e","modified":1487509691034},{"_id":"source/_posts/java中的编码问题/writer.png","hash":"3ac4dcf3e18dc011372297be5069f387fef0e9f9","modified":1487509691034},{"_id":"source/_posts/java代理机制/1.png","hash":"56ebe545cbaf4dc499f7cad5850d8abaa1300bf1","modified":1490706253317},{"_id":"source/_posts/java代理机制/2.png","hash":"8bdbbb357ab36dd4fd07c36616a9693538738929","modified":1490706485506},{"_id":"source/_posts/java代理机制/3.png","hash":"a87ecd9f56c1d3c3d430512faccdf919814c849f","modified":1490706521771},{"_id":"source/_posts/java代理机制/4.png","hash":"f654d9216ca853f0c48d5b09882580a366fc6fd7","modified":1490707812938},{"_id":"source/_posts/java代理机制/5.png","hash":"69bce396b216a2cd2a54f5c0d0e27f9afdc3344a","modified":1490708199397},{"_id":"source/_posts/java代理机制/Proxy.jpg","hash":"3a9e9d0a8266db70d1e842a01511830832456efb","modified":1490693120723},{"_id":"source/_posts/java代理机制/seq_Proxy.jpg","hash":"8370dba164de10270140c8825538326d8701465a","modified":1490693134308},{"_id":"source/_posts/java异常的学习/java.png","hash":"1f36e7cffb24b7771a60661d3d7301b9ca8c8f87","modified":1487509691034},{"_id":"source/_posts/java泛型学习/easybill.jpg","hash":"4090b7f4d3fb71aa1213a4ac8ef44e1d11dd8818","modified":1487509691035},{"_id":"source/_posts/java注解/decode.jpg","hash":"e030ecf761e8d22dc3b1c0384117c43b2da8cda1","modified":1490965938820},{"_id":"source/_posts/java注解/doc.jpg","hash":"03a06b49ab366ff3c94cea331ed365b09468e929","modified":1490965945980},{"_id":"source/_posts/java远程调试学习/jdpa.png","hash":"d0fc92e1d6b23a66eb753304c6ca06df2f91357d","modified":1487509691035},{"_id":"source/_posts/java远程调试学习/setting.png","hash":"5cdc18528edb9e01c731b8c4c5057467670ea59e","modified":1487509691035},{"_id":"source/_posts/linux分区/cipan.png","hash":"1e77c52d0c861bc5fd7510e831d568abf572678f","modified":1488710007546},{"_id":"source/_posts/linux分区/fen.png","hash":"de50e2303147c158b8a7b7cc2a37f73dd5684024","modified":1488712384363},{"_id":"source/_posts/linux分区/kuozhan.png","hash":"df39a6db64d871444b8dfaf6b60230b5b5dd35e7","modified":1488713583670},{"_id":"source/_posts/linux分区/yindao.jpg","hash":"6a6e4a3550ac8e515a08c22c71f1197b353a815e","modified":1488714658137},{"_id":"source/_posts/linux分区/zhumian.jpg","hash":"8b553452a7eab6e787183f5b39f1c35e7302de2d","modified":1488711999777},{"_id":"source/_posts/ssl总结/zhifubao.png","hash":"861fb5b3e7686cab022872e16f93eee43f2f657c","modified":1487509691037},{"_id":"source/_posts/ssl总结/zhufubao1.png","hash":"31d3700c1b34205b3527e551806815a179012710","modified":1487509691037},{"_id":"source/_posts/ssl总结/zhufubao2.png","hash":"670fb52cc2d6a871af24621ff34613d80f47213a","modified":1487509691038},{"_id":"source/_posts/关于加密的一点总结/md5.png","hash":"5830f21212d5da0f37cb94dd97fc8db37dcdf033","modified":1487509691039},{"_id":"source/_posts/理解java内存模型/volatile.png","hash":"66e532f81e9747722754733ee0361d3e28bf3ce1","modified":1487509691045},{"_id":"source/_posts/理解java内存模型/内存模型.png","hash":"9afbd38d84a83cd56288172cc45fc627867113c2","modified":1487509691045},{"_id":"source/_posts/理解notify notifyall sleep/线程状态.png","hash":"0716019dc5c338a2b07197e0cd5f593d4dedc504","modified":1487509691045},{"_id":"source/_posts/记录这周工作遇到的坑/compiler.png","hash":"9ac5d2d7f2e76b216a82cf9eaea2034857c18127","modified":1487509691046},{"_id":"source/_posts/记录这周工作遇到的坑/error.png","hash":"016f7b6c6d5ef72cc405baa5777bf2077d178931","modified":1487509691046},{"_id":"source/_posts/记录这周工作遇到的坑/gengeration.png","hash":"acd8916c32713eb373fed19198b000b0516080e6","modified":1487509691046},{"_id":"themes/pacman/layout/_partial/after_footer.ejs","hash":"af5d700c7e22e364216535142bc0adc798fac22f","modified":1487509691054},{"_id":"themes/pacman/layout/_partial/archive.ejs","hash":"a1ada891cbacf49b397cfa7dd921bdd0ae545a4e","modified":1487509691054},{"_id":"themes/pacman/layout/_partial/article.ejs","hash":"38837fc6a1a799e83b8a75db642b0daf1ff81828","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/footer.ejs","hash":"86bf52b852d45895a1fa24eb5e45dd2f40d5fb47","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/google_analytics.ejs","hash":"b6871f67c87c87acb5295ce4fb673b16a7296a01","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/head.ejs","hash":"f21fc1b1c16498610a44a552d23059d338f34d2a","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/header.ejs","hash":"515074e0e1449259cfb668217b21224f6e0adde5","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/search.ejs","hash":"aed90406246cc43f60dda8cd6558e9eccee342a4","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/sidebar.ejs","hash":"b5aeaab660a18b7a4da568f015e61260eb478916","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1487509691055},{"_id":"themes/pacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1487509691055},{"_id":"themes/pacman/layout/_widget/category.ejs","hash":"9b4cc6be18aa6c5da4cf45913d5be83fc33081db","modified":1487509691056},{"_id":"themes/pacman/layout/_widget/links.ejs","hash":"3635a1a407fde93a3be58178b85f51ceb8b87f15","modified":1487509691056},{"_id":"themes/pacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1487509691056},{"_id":"themes/pacman/layout/_widget/tag.ejs","hash":"cc97db230f727c27519298166ad904358811fb53","modified":1487509691056},{"_id":"themes/pacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1487509691056},{"_id":"themes/pacman/source/css/style.styl","hash":"b096cc43460e68004bbef41229f67420b5816637","modified":1487509691057},{"_id":"themes/pacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1487509691057},{"_id":"themes/pacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1487509691057},{"_id":"themes/pacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1487509691057},{"_id":"themes/pacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1487509691057},{"_id":"themes/pacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1487509691057},{"_id":"themes/pacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1487509691057},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1487509691058},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1487509691058},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1487509691058},{"_id":"themes/pacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1487509691059},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1487509691059},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1487509691060},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1487509691060},{"_id":"themes/pacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1487509691060},{"_id":"themes/pacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1487509691062},{"_id":"themes/pacman/source/img/author.jpg","hash":"cf5161efc731fc892ab04b77c2369c7fdad21d87","modified":1487509691062},{"_id":"themes/pacman/source/img/logo.svg","hash":"0eb0ae32d95c6f0b14adb9ab491775dcd1da3af3","modified":1487509691062},{"_id":"themes/pacman/source/img/xiaoxin.ico","hash":"82778e9316d3d1d366442a8f5d0468dda013d983","modified":1487509691062},{"_id":"themes/pacman/source/img/xiaoxin.png","hash":"479898e56ba23fdc6c68a611939316ad58f6e78c","modified":1487509691062},{"_id":"source/_posts/Eclipse编码问题终极解决方案/1.png","hash":"6ed1e52158e7dbce544e72af037ede46b38f1600","modified":1487509691029},{"_id":"source/_posts/Eclipse编码问题终极解决方案/6.png","hash":"b27b88bd85eb9e2dac3cc7164678ca203c3ff9c7","modified":1487509691030},{"_id":"source/_posts/Eclipse编码问题终极解决方案/7.png","hash":"1558afd4f271658241ff3a5189ee10bf7f5ebbf2","modified":1487509691031},{"_id":"source/_posts/I-O总结/stream.png","hash":"961acbb3af1a3fcbf57e4dd4fe6539808c0796f6","modified":1489919650469},{"_id":"source/_posts/Spring项目打包为jar/1.png","hash":"925c9162dc357b505520543c5c47d3dd11dc840a","modified":1487509691032},{"_id":"source/_posts/centos7BCM驱动安装/iwconfig.png","hash":"32e3d93bd385129acf493856b8357b025adf683a","modified":1488003638709},{"_id":"source/_posts/java远程调试学习/remote.png","hash":"31329d2e3f6c04d6d13be67437e7a4322c31a061","modified":1487509691035},{"_id":"source/_posts/他可是科比·布莱恩特!/kobe.jpg","hash":"5e2e8343a4fba076d7475cc6cda941d21176be44","modified":1487509691038},{"_id":"source/_posts/毕业了/graduation5.jpg","hash":"976ff6965b27f578d365ae139db1c8d5c298d757","modified":1487509691042},{"_id":"source/_posts/毕业了/graduation6.jpg","hash":"4f36689e7db00afd3f2bc3b4c33480e9d1f1a99c","modified":1487509691043},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1487509691060},{"_id":"themes/pacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1487509691061},{"_id":"themes/pacman/source/img/xiaoxin.jpg","hash":"2ee983f8da1be448bd89e8fe0b7c093606bf9788","modified":1487509691062},{"_id":"themes/pacman/source/js/jquery-2.1.0.min.js","hash":"98884258cbdb0d939fa2c5e74fc7ac9e56d8170f","modified":1487509691063},{"_id":"source/_posts/ssl总结/sslprocess.jpg","hash":"449b6c730fb7f7452592972d8748cf6bbe942de8","modified":1487509691037},{"_id":"themes/pacman/layout/_partial/post/article.ejs","hash":"ec5e8f66886dedf35b9a5746d11fe0dc4a7ab68f","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/post/catetags.ejs","hash":"f6b107078094333b6567d4a97700f559159675e1","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/post/comment.ejs","hash":"5c0afcd1fd1d7b4e8335f76bc181b8e72ffed38e","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/post/footer.ejs","hash":"5b6e1fd8c9708d865f2b97e0a644f4f8f5c35fe9","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/post/gallery.ejs","hash":"7ca5b1db9439be61a8b77f6f7d857b56fdf1517f","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/post/header.ejs","hash":"73aa8a410cc80277930acaec23003c30eeac6d79","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/post/jiathis.ejs","hash":"adc047d2bbd031092df86f3be2866ea9c3b5f3c9","modified":1487509691055},{"_id":"themes/pacman/layout/_partial/post/pagination.ejs","hash":"dd9563aaa7094c7082a16e6c9cbc24b33aaef87c","modified":1487509691055},{"_id":"themes/pacman/source/css/_base/code.styl","hash":"330209ebaebe69308e131fada85b9b619c85fbd9","modified":1487509691056},{"_id":"themes/pacman/source/css/_base/font.styl","hash":"75f264bc742888dbe192e8d19eda70705d13c709","modified":1487509691056},{"_id":"themes/pacman/source/css/_base/public.styl","hash":"29deec49b60533cc4196175345eaa4b2d611a97e","modified":1487509691056},{"_id":"themes/pacman/source/css/_base/variable.styl","hash":"d227693a63c267245a54448340c49cd566244b87","modified":1487509691056},{"_id":"themes/pacman/source/css/_partial/article.styl","hash":"82d7621920e221b7e52dfdb74cbcec718d0cc666","modified":1487509691056},{"_id":"themes/pacman/source/css/_partial/aside.styl","hash":"8fb8c2172883913b404f8e49e181103317486ecc","modified":1487509691057},{"_id":"themes/pacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1487509691057},{"_id":"themes/pacman/source/css/_partial/footer.styl","hash":"77c2e6251cea1f3970646f6fbe5d557ed4f98586","modified":1487509691057},{"_id":"themes/pacman/source/css/_partial/gallery.styl","hash":"a544a58fdb4c8dd8274159323abd1e38cb03215e","modified":1487509691057},{"_id":"themes/pacman/source/css/_partial/header.styl","hash":"d27d0057b86dc61a1ab8a9037ee43dfcc43766b3","modified":1487509691057},{"_id":"themes/pacman/source/css/_partial/helper.styl","hash":"52d4ee51b7087c2c2a7e7ded6f63270165d9de89","modified":1487509691057},{"_id":"themes/pacman/source/css/_partial/index.styl","hash":"0d219fc6fb76c0d4ffd1dc2a119969d78a157285","modified":1487509691057},{"_id":"themes/pacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1487509691057},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1487509691058},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1487509691058},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1487509691058},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1487509691058},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1487509691058},{"_id":"source/_posts/毕业了/graduation3.jpg","hash":"54cffe443f66930659fe9d0a6ee12154ce8d5c28","modified":1487509691041},{"_id":"themes/pacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1487509691061},{"_id":"source/_posts/I-O总结/javaio.png","hash":"25d4f5daf95fac37cd3ca03cab4d82dc39ce06cf","modified":1489919774528},{"_id":"source/_posts/毕业了/graduation2.jpg","hash":"ccffa377b02496a0f2437578d7f6d35b879373a5","modified":1487509691041},{"_id":"source/_posts/毕业了/graduation8.jpg","hash":"ab88166275c1a01036fe3680407dfff9f52c3434","modified":1487509691044},{"_id":"source/_posts/I-O总结/io.png","hash":"68f3e58424ea0ad2e2d87b20dbb321b4b8415787","modified":1489919191558},{"_id":"source/_posts/毕业了/graduation1.jpg","hash":"55cd28acab408b9a81fd6877a47e24d20749e20c","modified":1487509691040},{"_id":"source/_posts/毕业了/graduation7.jpg","hash":"4ef31ad176f81cde92dff0958cfc0b70d789e754","modified":1487509691044},{"_id":"source/_posts/毕业了/graduation4.jpg","hash":"e84c1f0a512f1aba02163ba3a8cf39460b9cb28b","modified":1487509691042},{"_id":"source/_posts/I-O总结/javaio2.bmp","hash":"fbf20e5aaf5773f62162cb12f3c7beb6a37c520e","modified":1489933463803},{"_id":"public/page/index.html","hash":"bad067a2c6ea8ac8d75d347c3ba7f171ab5e86be","modified":1490966555783},{"_id":"public/2016/04/14/他可是科比·布莱恩特!/index.html","hash":"dc6fdc0e2069ab8a2b6f1ab262165e3ad1d053a7","modified":1490966555818},{"_id":"public/2016/04/12/junit使用/index.html","hash":"46b0cb34f83bdd08217924423305d78f86a55d00","modified":1490966555820},{"_id":"public/archives/index.html","hash":"f1c222bd6b3face8d707a8068c8d5bba4897a5ca","modified":1490966555820},{"_id":"public/archives/page/2/index.html","hash":"2d4829412e0d07c11a6d027025abd276a29428d1","modified":1490966555820},{"_id":"public/archives/page/3/index.html","hash":"ab5bd7ed21eeb16d0c0f115c2493affbe8d74afa","modified":1490966555820},{"_id":"public/archives/page/4/index.html","hash":"460387b08b19c8572303e5125e7021adc1841bf2","modified":1490966555820},{"_id":"public/archives/page/5/index.html","hash":"6ea1a72d5f5bb49d30b8341b344badbbb3027812","modified":1490966555820},{"_id":"public/archives/2015/index.html","hash":"0ab5dce4037fd95e3da1daa91cddc1441689d357","modified":1490966555820},{"_id":"public/archives/2015/12/index.html","hash":"ad0426226df6016c19f4a772954387f6ea4e5772","modified":1490966555820},{"_id":"public/archives/2016/index.html","hash":"93ae1e9681de67d859f8219234aac1c7575256ec","modified":1490966555820},{"_id":"public/archives/2016/page/2/index.html","hash":"7bd3ede4f1cd206e4fe3243950436b755e7101f2","modified":1490966555820},{"_id":"public/archives/2016/page/3/index.html","hash":"4aff7af4b7a9433e1edbca0fca0426f7444b1d51","modified":1490966555820},{"_id":"public/archives/2016/page/4/index.html","hash":"8a2af6f51fc524ea36bcbba9d62ca8977ac7c7b1","modified":1490966555820},{"_id":"public/archives/2016/03/index.html","hash":"07d7e2f2b803aa6e7209472392be081e05fa617d","modified":1490966555820},{"_id":"public/archives/2016/04/index.html","hash":"3e9233e8b5ab870f8bc8f8159109f6342539d913","modified":1490966555821},{"_id":"public/archives/2016/06/index.html","hash":"8185d5d7efd2cbcf325a33830efa48b0f31bb3f7","modified":1490966555821},{"_id":"public/archives/2016/07/index.html","hash":"3545d50b4826870dbb1165af2b85972fa6cc5f55","modified":1490966555821},{"_id":"public/archives/2016/08/index.html","hash":"6bd59275fc7fa311886d38843afbd6dce7609308","modified":1490966555821},{"_id":"public/archives/2016/09/index.html","hash":"ef78380e644b145f86b0b7afba3168f4bd251277","modified":1490966555821},{"_id":"public/archives/2016/10/index.html","hash":"1a29e65ceccee0abe2ce7d4a7dfd084a5ee6e748","modified":1490966555821},{"_id":"public/archives/2016/11/index.html","hash":"970788dc07c2ecaf7b762c417d9800c04554bdbf","modified":1490966555821},{"_id":"public/archives/2016/12/index.html","hash":"29e259bf6998a164aceed2d82e0c3612ec60dd40","modified":1490966555821},{"_id":"public/archives/2017/index.html","hash":"f2b0990e362d82a5a3d212ac1564bc5989910b35","modified":1490966555821},{"_id":"public/archives/2017/page/2/index.html","hash":"de00809eb709f77488cb17e6b86e7ef69a3e7455","modified":1490966555821},{"_id":"public/archives/2017/02/index.html","hash":"398a88dcc6fae139962662160e44e9ba4ba6d628","modified":1490966555821},{"_id":"public/archives/2017/03/index.html","hash":"2a8345b702ea9d7a99d31449a094fed8a549f38d","modified":1490966555821},{"_id":"public/categories/工具/index.html","hash":"7a006f940654d43892c873344ca7b40ee48c3b31","modified":1490966555821},{"_id":"public/categories/工具/page/2/index.html","hash":"979e292cf98d48b3326634ccf09bce30b6c2531c","modified":1490966555821},{"_id":"public/categories/编程/index.html","hash":"5ed058a1de1f73166f3a9fa8699353b7afa8472f","modified":1490966555821},{"_id":"public/categories/编程/page/2/index.html","hash":"f72170bb833b7c0813087576731e5384174faed5","modified":1490966555822},{"_id":"public/categories/编程/page/3/index.html","hash":"5ce68daae8b59421f0e8666e924f3e9ee0a77303","modified":1490966555822},{"_id":"public/categories/技术/index.html","hash":"b1b1e03f61e7fc084064e51e8265ef2fc29ff509","modified":1490966555822},{"_id":"public/categories/生活/index.html","hash":"0a24d6a1b7f803e19ab4ab587c83c8eb4bfbeb67","modified":1490966555822},{"_id":"public/page/5/index.html","hash":"8f1a4fb0362070eea2834225d1609a976a7325bc","modified":1490966555822},{"_id":"public/tags/java/index.html","hash":"fa65b390d0c78fcb0bf535844b2e964ad02f97ff","modified":1490966555822},{"_id":"public/tags/java/page/2/index.html","hash":"0fe0a2c3fad58323ae84ff76e540bd33e4225f69","modified":1490966555822},{"_id":"public/tags/java/page/3/index.html","hash":"d2b9e6f5f01f27a1f877d47449cd00d22ddecc97","modified":1490966555822},{"_id":"public/tags/ant/index.html","hash":"19f7e3813a2fb64cd70d4db54712620189e4aa88","modified":1490966555822},{"_id":"public/tags/Eclipse/index.html","hash":"4e2cf2f6bdee72b612e3f59e3a8c5f2c2621173b","modified":1490966555822},{"_id":"public/tags/java-io/index.html","hash":"2b469819cef778bf21d5a4b78a2837a77fa87f92","modified":1490966555822},{"_id":"public/tags/源码/index.html","hash":"256060f14765f13df4f8308b2d85c3bbbab71ad7","modified":1490966555822},{"_id":"public/tags/linux/index.html","hash":"23daf4ae0950b322a05040ebbe8f8c7789cdb1f5","modified":1490966555822},{"_id":"public/tags/服务器/index.html","hash":"fcdd7839846f2d603821fa5ad1d3b7b48fd16569","modified":1490966555822},{"_id":"public/tags/spring/index.html","hash":"21ee7093135f4f4ec140b8300b0d1fde2aa58e25","modified":1490966555822},{"_id":"public/tags/多线程/index.html","hash":"bd316b0bb66dd96b1d128a1ad9a0dff1b6d55653","modified":1490966555823},{"_id":"public/tags/编码/index.html","hash":"83b6cb7e8a8165975bc625c29f63257f10670206","modified":1490966555823},{"_id":"public/tags/调试/index.html","hash":"ab2e1152e7b1b5c62850fa0ad99c50f7cb293bb5","modified":1490966555823},{"_id":"public/tags/junit/index.html","hash":"489aeaf8d7e7103df01e3ac6bd45df699a587661","modified":1490966555823},{"_id":"public/tags/测试/index.html","hash":"bd4a2305515b98f3d2e6d507708a501c79e94f98","modified":1490966555823},{"_id":"public/tags/markdown/index.html","hash":"d2063e412367ceddac3334f035ef5e0003983785","modified":1490966555823},{"_id":"public/tags/python/index.html","hash":"19d4c5c6b0146bba16446e38cb1f30c21f123b33","modified":1490966555823},{"_id":"public/tags/加密/index.html","hash":"28791d51c48a7143aa46ce350de343c3362869e5","modified":1490966555824},{"_id":"public/tags/web/index.html","hash":"704cbfece48a0afe8746142cf836db63bd59427a","modified":1490966555824},{"_id":"public/tags/快捷键/index.html","hash":"6608cb2af73745e7db500bf5a578a494acc3e4d0","modified":1490966555824},{"_id":"public/tags/curl/index.html","hash":"eaf6322d80abfd02634f86910a40dcab10919607","modified":1490966555824},{"_id":"public/2017/03/28/java代理机制/index.html","hash":"27c31883b5d3ad89a6bbadaa2a560c6893971027","modified":1490966555824},{"_id":"public/2017/03/22/java序列化与反序列化/index.html","hash":"7ebe3da29172853759a646d3b14fd256061d6dea","modified":1490966555824},{"_id":"public/2017/03/19/I-O总结/index.html","hash":"e557ad8a612f632cea9a69fb7eb3664e7bf130b8","modified":1490966555824},{"_id":"public/2017/03/15/webservice相关/index.html","hash":"5868d455d4e63ea692e5c31d7bb36ce2fbae5103","modified":1490966555824},{"_id":"public/2017/03/04/linux分区/index.html","hash":"b982cb4bcb0b2194a78ad3ea872c78c6f922ff89","modified":1490966555824},{"_id":"public/2017/02/26/Linux的五个查找命令/index.html","hash":"75e3bf1924e67360745a9ebe34340d806e3ea75e","modified":1490966555824},{"_id":"public/2017/02/25/centos7BCM驱动安装/index.html","hash":"de370f72af7193eee384b175045846e72c6bac1b","modified":1490966555824},{"_id":"public/2017/02/23/ssh的两种用法/index.html","hash":"0a85af37f58698d7f9162002ed15c0f64e29adc0","modified":1490966555824},{"_id":"public/2017/02/21/java日志使用/index.html","hash":"dc63d33f748f199ce76724446de725e014e5a48d","modified":1490966555825},{"_id":"public/2017/02/19/java国际化/index.html","hash":"48d38ffb0f7ebcf3575da8abaa448b18253537bf","modified":1490966555825},{"_id":"public/2017/02/18/win7与centos7双系统安装/index.html","hash":"d7b22c55670c22810d6ca46fe1ca3752ac488216","modified":1490966555825},{"_id":"public/2017/02/07/Vps使用笔记/index.html","hash":"aebba77c879a171029add9948f6ad2f01d55cbe6","modified":1490966555825},{"_id":"public/2016/12/13/java异常的学习/index.html","hash":"4bf9e2c69896c6f43c1819ec24d2b80339178867","modified":1490966555825},{"_id":"public/2016/12/07/java远程调试学习/index.html","hash":"def873154fb6a0dcc7a1bc61d25511cd808caa41","modified":1490966555825},{"_id":"public/2016/12/04/java中的路径/index.html","hash":"446ad32271bacaab2bd5402b7124d7185ee977f5","modified":1490966555825},{"_id":"public/2016/11/24/java中的int/byte互转/index.html","hash":"05e6ffc41b494c6cb27073a1817cd670c2357deb","modified":1490966555825},{"_id":"public/2016/10/10/java泛型学习/index.html","hash":"4d714a0ede9cb51b2d2227755f9effd13be3a1aa","modified":1490966555825},{"_id":"public/2016/09/25/ssl总结/index.html","hash":"901164b13e48210acf44ad2dab5a717443f568a2","modified":1490966555825},{"_id":"public/2016/09/24/记录这周工作遇到的坑/index.html","hash":"4a9a61d046b02c746f09676c2647e6e5a7a7f987","modified":1490966555825},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/index.html","hash":"bd1afff9359cf5006d782b7fbc7b3fbfd43c82dc","modified":1490966555825},{"_id":"public/2016/09/19/Spring项目打包为jar/index.html","hash":"44d13cd9ff7d9b15c1b09e88031233a0e228d426","modified":1490966555825},{"_id":"public/2016/09/10/理解java内存模型/index.html","hash":"9f1ef5b96192720814a136daa6d028b3882a5177","modified":1490966555825},{"_id":"public/2016/08/31/理解notify notifyall sleep/index.html","hash":"1a036624787f84ac1f97e2ea4e085f4abc74f1e1","modified":1490966555826},{"_id":"public/2016/08/22/关于加密的一点总结/index.html","hash":"9b21bde1762e5e9ec3e5af726db1d6a58099fe94","modified":1490966555826},{"_id":"public/2016/08/16/Java集合框架学习总结/index.html","hash":"94d6bc30a60bd9d660689abd4579534ce6b679b3","modified":1490966555826},{"_id":"public/2016/08/16/synchronized的一些用法/index.html","hash":"5a3d94b2e79246490fb71d648da83a35f50e958d","modified":1490966555826},{"_id":"public/2016/08/15/一些计划/index.html","hash":"2f01c358947e9bf48b006ad4a0a6e220a4262b2d","modified":1490966555827},{"_id":"public/2016/07/31/为什么是final/index.html","hash":"16113c7d89dc4208d4aab7ed5c9e6d39cf207a7d","modified":1490966555827},{"_id":"public/2016/07/24/java_Tips/index.html","hash":"35b3037d886d0921494ccd08a41ec9a3af94676d","modified":1490966555827},{"_id":"public/2016/07/18/Ant的使用/index.html","hash":"3540ceec2dc47889d02b1d3bf3d2bf9ac09016d3","modified":1490966555827},{"_id":"public/2016/06/30/毕业了/index.html","hash":"555de5f2a6f8f97d9a615bc6434e7b0ac382d779","modified":1490966555827},{"_id":"public/2016/06/30/java中的枚举/index.html","hash":"09f1595d8abf1e111dac7827a32169b9270c64f4","modified":1490966555827},{"_id":"public/2016/06/21/java中的ThreadLocal/index.html","hash":"cb5cdcad004a18d1b94a71ac62e2d1c8073927ad","modified":1490966555827},{"_id":"public/2016/04/28/java中的类型转换/index.html","hash":"1413d3876e884ffe375a13c6ae9563896f8d4798","modified":1490966555827},{"_id":"public/2016/04/28/java中的equals与hashcode/index.html","hash":"b0361c7bf617f5b74fe529a6137c18a18b997e70","modified":1490966555827},{"_id":"public/2016/04/25/ant编译java工程jdk路径的设置/index.html","hash":"eca8a1fa1472e5a0ee31dbcdbec4b6313c57b21b","modified":1490966555828},{"_id":"public/2016/04/20/java中的编码问题/index.html","hash":"9ec7fcc0e93d570751e4e8bed83cec9fe31bf783","modified":1490966555828},{"_id":"public/2016/04/15/关于抽象类和接口/index.html","hash":"3528e477cf7f1b94a80547b36a24b81cd6884fa0","modified":1490966555828},{"_id":"public/2016/03/30/sphinx安装问题/index.html","hash":"f9606e86043697629dcb73ad3e9c5abd0dea6165","modified":1490966555828},{"_id":"public/2016/03/29/代码格式/index.html","hash":"d377079b81cebea575d4500e1c6367952a818652","modified":1490966555828},{"_id":"public/2016/03/22/常用快捷键总结/index.html","hash":"f3187189282417fbe94418c335ef86a2061e041a","modified":1490966555828},{"_id":"public/2016/03/03/markdown/index.html","hash":"da978125ad35e54b826dacc1ea6a06c0c93dcee4","modified":1490966555828},{"_id":"public/2015/12/21/notify问题/index.html","hash":"bb1cf306180300d440d2014b1b48a429f546bca9","modified":1490966555828},{"_id":"public/2015/12/17/java同步锁锁什么/index.html","hash":"9dec25663ea6cde6df171a3b3623befefa696264","modified":1490966555828},{"_id":"public/index.html","hash":"7f6d7153ab181f051e2de32d49b1b5e12a53be22","modified":1490966555828},{"_id":"public/page/2/index.html","hash":"00e2bd2ae8a99aa7c1fcfe59fd71c2a07b4a0113","modified":1490966555828},{"_id":"public/page/3/index.html","hash":"7d37978cbf64c93feaba671f5053974a0e3c0593","modified":1490966555828},{"_id":"public/page/4/index.html","hash":"edb63c640272a5dab870726c996e32c299576493","modified":1490966555828},{"_id":"public/2017/03/31/java注解/index.html","hash":"0b8161d806f15d358f3026636fb3f640dbd98ccd","modified":1491100354306},{"_id":"public/CNAME","hash":"75913de577e6e2674855228ebb98f985574fdca1","modified":1490966555903},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1490966555903},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1490966555903},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1490966555903},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1490966555903},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1490966555903},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1490966555903},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1490966555903},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1490966555903},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1490966555903},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1490966555904},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1490966555904},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1490966555904},{"_id":"public/img/author.jpg","hash":"cf5161efc731fc892ab04b77c2369c7fdad21d87","modified":1490966555904},{"_id":"public/img/logo.svg","hash":"0eb0ae32d95c6f0b14adb9ab491775dcd1da3af3","modified":1490966555904},{"_id":"public/img/xiaoxin.ico","hash":"82778e9316d3d1d366442a8f5d0468dda013d983","modified":1490966555904},{"_id":"public/img/xiaoxin.png","hash":"479898e56ba23fdc6c68a611939316ad58f6e78c","modified":1490966555904},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1490966555904},{"_id":"public/2016/08/16/Java集合框架学习总结/collection.png","hash":"9644281b68a057f4db9b162c45ac4c076c7c5651","modified":1490966555904},{"_id":"public/2016/04/28/java中的equals与hashcode/entry.png","hash":"c6c32336b30c74d2e825684e590fc8bb15af2dc1","modified":1490966555904},{"_id":"public/2016/12/13/java异常的学习/java.png","hash":"1f36e7cffb24b7771a60661d3d7301b9ca8c8f87","modified":1490966555904},{"_id":"public/2016/10/10/java泛型学习/easybill.jpg","hash":"4090b7f4d3fb71aa1213a4ac8ef44e1d11dd8818","modified":1490966555904},{"_id":"public/2016/08/22/关于加密的一点总结/md5.png","hash":"5830f21212d5da0f37cb94dd97fc8db37dcdf033","modified":1490966555904},{"_id":"public/2016/08/31/理解notify notifyall sleep/线程状态.png","hash":"0716019dc5c338a2b07197e0cd5f593d4dedc504","modified":1490966555904},{"_id":"public/2017/02/25/centos7BCM驱动安装/demo.png","hash":"bcc155b1952c95c1e4f710668c1fbf66c3fec530","modified":1490966555905},{"_id":"public/2016/09/10/理解java内存模型/volatile.png","hash":"66e532f81e9747722754733ee0361d3e28bf3ce1","modified":1490966555905},{"_id":"public/2016/09/10/理解java内存模型/内存模型.png","hash":"9afbd38d84a83cd56288172cc45fc627867113c2","modified":1490966555905},{"_id":"public/2016/04/20/java中的编码问题/reader.png","hash":"4cf16c765f0952a9134bc5097270d3a6b2679f76","modified":1490966555905},{"_id":"public/2016/04/20/java中的编码问题/utf8.png","hash":"f4a2eb95b15e12d6957c07099fafd42d9b6c035e","modified":1490966555906},{"_id":"public/2016/04/20/java中的编码问题/writer.png","hash":"3ac4dcf3e18dc011372297be5069f387fef0e9f9","modified":1490966555906},{"_id":"public/2016/12/07/java远程调试学习/jdpa.png","hash":"d0fc92e1d6b23a66eb753304c6ca06df2f91357d","modified":1490966555906},{"_id":"public/2016/12/07/java远程调试学习/setting.png","hash":"5cdc18528edb9e01c731b8c4c5057467670ea59e","modified":1490966555906},{"_id":"public/2016/09/24/记录这周工作遇到的坑/error.png","hash":"016f7b6c6d5ef72cc405baa5777bf2077d178931","modified":1490966555906},{"_id":"public/2016/09/24/记录这周工作遇到的坑/compiler.png","hash":"9ac5d2d7f2e76b216a82cf9eaea2034857c18127","modified":1490966555906},{"_id":"public/2016/09/24/记录这周工作遇到的坑/gengeration.png","hash":"acd8916c32713eb373fed19198b000b0516080e6","modified":1490966555906},{"_id":"public/2016/09/25/ssl总结/zhifubao.png","hash":"861fb5b3e7686cab022872e16f93eee43f2f657c","modified":1490966555907},{"_id":"public/2016/09/25/ssl总结/zhufubao1.png","hash":"31d3700c1b34205b3527e551806815a179012710","modified":1490966555907},{"_id":"public/2016/09/25/ssl总结/zhufubao2.png","hash":"670fb52cc2d6a871af24621ff34613d80f47213a","modified":1490966555907},{"_id":"public/2016/09/19/Spring项目打包为jar/2.png","hash":"7ff532cc98f22996c89a2a590954c113e2de486f","modified":1490966555907},{"_id":"public/2016/09/19/Spring项目打包为jar/3.png","hash":"a6c93e41c454ca4d89a2c5153ff74ac3c9eec04a","modified":1490966555907},{"_id":"public/2016/09/19/Spring项目打包为jar/4.png","hash":"644dca24dfefc583f2b222e967962d2de68452bb","modified":1490966555907},{"_id":"public/2016/09/19/Spring项目打包为jar/5.png","hash":"7c9911eab320a22ef1a310dfb15a8996aa37de2b","modified":1490966555907},{"_id":"public/2017/03/04/linux分区/cipan.png","hash":"1e77c52d0c861bc5fd7510e831d568abf572678f","modified":1490966555907},{"_id":"public/2017/03/04/linux分区/fen.png","hash":"de50e2303147c158b8a7b7cc2a37f73dd5684024","modified":1490966555907},{"_id":"public/2017/03/04/linux分区/kuozhan.png","hash":"df39a6db64d871444b8dfaf6b60230b5b5dd35e7","modified":1490966555907},{"_id":"public/2017/03/04/linux分区/yindao.jpg","hash":"6a6e4a3550ac8e515a08c22c71f1197b353a815e","modified":1490966555907},{"_id":"public/2017/03/04/linux分区/zhumian.jpg","hash":"8b553452a7eab6e787183f5b39f1c35e7302de2d","modified":1490966555907},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/2.png","hash":"4dd8a8d179e898c803a879fec14afb855a34b23d","modified":1490966555907},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/3.png","hash":"d62218e89ab63a0c4a05ebfd35192b7f3c031588","modified":1490966555907},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/4.png","hash":"5ef56fc1e37d46da093fbf0b94273b45eb3cb8bd","modified":1490966555907},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/5.png","hash":"7fc75d3a44bebd24c9df7ad7e7d49d70de611325","modified":1490966555907},{"_id":"public/2017/03/28/java代理机制/1.png","hash":"56ebe545cbaf4dc499f7cad5850d8abaa1300bf1","modified":1490966555908},{"_id":"public/2017/03/28/java代理机制/2.png","hash":"8bdbbb357ab36dd4fd07c36616a9693538738929","modified":1490966555908},{"_id":"public/2017/03/28/java代理机制/3.png","hash":"a87ecd9f56c1d3c3d430512faccdf919814c849f","modified":1490966555908},{"_id":"public/2017/03/28/java代理机制/4.png","hash":"f654d9216ca853f0c48d5b09882580a366fc6fd7","modified":1490966555908},{"_id":"public/2017/03/28/java代理机制/5.png","hash":"69bce396b216a2cd2a54f5c0d0e27f9afdc3344a","modified":1490966555908},{"_id":"public/2017/03/28/java代理机制/Proxy.jpg","hash":"3a9e9d0a8266db70d1e842a01511830832456efb","modified":1490966555908},{"_id":"public/2017/03/28/java代理机制/seq_Proxy.jpg","hash":"8370dba164de10270140c8825538326d8701465a","modified":1490966555908},{"_id":"public/2017/03/19/I-O总结/child-817369__340.jpg","hash":"bd3bc9c879086c56a6b11fb9bf537a7aefea6bbf","modified":1490966555908},{"_id":"public/2017/03/19/I-O总结/decoder.jpg","hash":"3ade788875dedb4a1bfb181edb2e6a3124e80f82","modified":1490966555908},{"_id":"public/2017/03/19/I-O总结/decorator.jpg","hash":"7cc2521b403bd45ab7078ee7eb9557e0df6ccc65","modified":1490966555908},{"_id":"public/2017/03/19/I-O总结/encoder.jpg","hash":"d4eb18c566bc686b1ef2c570e54e30cfbba3dec3","modified":1490966555908},{"_id":"public/2017/03/31/java注解/decode.jpg","hash":"e030ecf761e8d22dc3b1c0384117c43b2da8cda1","modified":1490966555908},{"_id":"public/2017/03/31/java注解/doc.jpg","hash":"03a06b49ab366ff3c94cea331ed365b09468e929","modified":1490966555908},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1490966556889},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1490966556892},{"_id":"public/img/xiaoxin.jpg","hash":"2ee983f8da1be448bd89e8fe0b7c093606bf9788","modified":1490966556896},{"_id":"public/2016/04/14/他可是科比·布莱恩特!/kobe.jpg","hash":"5e2e8343a4fba076d7475cc6cda941d21176be44","modified":1490966556896},{"_id":"public/2017/02/25/centos7BCM驱动安装/iwconfig.png","hash":"32e3d93bd385129acf493856b8357b025adf683a","modified":1490966556897},{"_id":"public/2016/12/07/java远程调试学习/remote.png","hash":"31329d2e3f6c04d6d13be67437e7a4322c31a061","modified":1490966556897},{"_id":"public/2016/09/19/Spring项目打包为jar/1.png","hash":"925c9162dc357b505520543c5c47d3dd11dc840a","modified":1490966556897},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/1.png","hash":"6ed1e52158e7dbce544e72af037ede46b38f1600","modified":1490966556897},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/6.png","hash":"b27b88bd85eb9e2dac3cc7164678ca203c3ff9c7","modified":1490966556897},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/7.png","hash":"1558afd4f271658241ff3a5189ee10bf7f5ebbf2","modified":1490966556897},{"_id":"public/2017/03/19/I-O总结/stream.png","hash":"961acbb3af1a3fcbf57e4dd4fe6539808c0796f6","modified":1490966556897},{"_id":"public/2016/06/30/毕业了/graduation5.jpg","hash":"976ff6965b27f578d365ae139db1c8d5c298d757","modified":1490966556897},{"_id":"public/2016/06/30/毕业了/graduation6.jpg","hash":"4f36689e7db00afd3f2bc3b4c33480e9d1f1a99c","modified":1490966556897},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1490966556912},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1490966556912},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1490966556912},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1490966556912},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1490966556912},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1490966556912},{"_id":"public/css/style.css","hash":"e3e1ec9060ce2fa8cae11c2e113dd1b45cfed017","modified":1490966556912},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1490966556912},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1490966556912},{"_id":"public/js/jquery-2.1.0.min.js","hash":"98884258cbdb0d939fa2c5e74fc7ac9e56d8170f","modified":1490966556912},{"_id":"public/2016/09/25/ssl总结/sslprocess.jpg","hash":"449b6c730fb7f7452592972d8748cf6bbe942de8","modified":1490966556912},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1490966556919},{"_id":"public/2016/06/30/毕业了/graduation3.jpg","hash":"54cffe443f66930659fe9d0a6ee12154ce8d5c28","modified":1490966556919},{"_id":"public/2017/03/19/I-O总结/javaio.png","hash":"25d4f5daf95fac37cd3ca03cab4d82dc39ce06cf","modified":1490966556926},{"_id":"public/2016/06/30/毕业了/graduation2.jpg","hash":"ccffa377b02496a0f2437578d7f6d35b879373a5","modified":1490966556926},{"_id":"public/2016/06/30/毕业了/graduation8.jpg","hash":"ab88166275c1a01036fe3680407dfff9f52c3434","modified":1490966556926},{"_id":"public/2017/03/19/I-O总结/io.png","hash":"68f3e58424ea0ad2e2d87b20dbb321b4b8415787","modified":1490966556929},{"_id":"public/2016/06/30/毕业了/graduation1.jpg","hash":"55cd28acab408b9a81fd6877a47e24d20749e20c","modified":1490966556929},{"_id":"public/2016/06/30/毕业了/graduation7.jpg","hash":"4ef31ad176f81cde92dff0958cfc0b70d789e754","modified":1490966556929},{"_id":"public/2016/06/30/毕业了/graduation4.jpg","hash":"e84c1f0a512f1aba02163ba3a8cf39460b9cb28b","modified":1490966556934},{"_id":"public/2017/03/19/I-O总结/javaio2.bmp","hash":"fbf20e5aaf5773f62162cb12f3c7beb6a37c520e","modified":1490966556943}],"Category":[{"name":"工具","_id":"cj0xuzlpf0004vegci8jmlp0u"},{"name":"编程","_id":"cj0xuzlq2000dvegcbswl3sbm"},{"name":"技术","_id":"cj0xuzlqp000tvegc673r1prx"},{"name":"生活","_id":"cj0xuzlsm003gvegctjt692d5"}],"Data":[],"Page":[{"layout":"page","title":"README","comments":0,"_content":"{% codeblock lang:java %}\n name: \"于凯\"\n university: \"中国民航大学\"\n hometown: \"山西晋中\"\n dream: \"两亩地一头牛，老婆孩子热炕头\"\n{% endcodeblock %}\n\n本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。也有生活中的一些总结。\n\n# 博客基础\n\n[Hexo](https://hexo.io/)一款轻量级的静态博客框架\n[Pacman](https://github.com/A-limon/pacman)扁平化、响应式Hexo主题\n[Markdown](https://www.gitbook.com/book/noahsoft/-makedown/details)一款轻量级的标记语言\n\n# 技能栈\n\nJava\n\nGit\n\n设计模式\n\nLinux\n\n# 书单\n\n《重构 改善既有代码的设计》  人民邮电出版社\n\n《深入理解JVM虚拟机》  机械工业出版社\n\n《大话设计模式》  清华大学出版社  \n\n《Java 并发编程实战》 机械工业出版社\n\n《鸟哥的Linux私房菜》 人民邮电出版社\n \n《大型网站技术架构》 电子工业出版社\n\n","source":"page/index.md","raw":"layout: page\ntitle: README\ncomments: false\n---\n{% codeblock lang:java %}\n name: \"于凯\"\n university: \"中国民航大学\"\n hometown: \"山西晋中\"\n dream: \"两亩地一头牛，老婆孩子热炕头\"\n{% endcodeblock %}\n\n本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。也有生活中的一些总结。\n\n# 博客基础\n\n[Hexo](https://hexo.io/)一款轻量级的静态博客框架\n[Pacman](https://github.com/A-limon/pacman)扁平化、响应式Hexo主题\n[Markdown](https://www.gitbook.com/book/noahsoft/-makedown/details)一款轻量级的标记语言\n\n# 技能栈\n\nJava\n\nGit\n\n设计模式\n\nLinux\n\n# 书单\n\n《重构 改善既有代码的设计》  人民邮电出版社\n\n《深入理解JVM虚拟机》  机械工业出版社\n\n《大话设计模式》  清华大学出版社  \n\n《Java 并发编程实战》 机械工业出版社\n\n《鸟哥的Linux私房菜》 人民邮电出版社\n \n《大型网站技术架构》 电子工业出版社\n\n","date":"2017-02-19T13:08:11.046Z","updated":"2017-02-19T13:08:11.046Z","path":"page/index.html","_id":"cj0xuzlp20001vegc9nw5u9o9","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">name: <span class=\"string\">\"于凯\"</span></div><div class=\"line\">university: <span class=\"string\">\"中国民航大学\"</span></div><div class=\"line\">hometown: <span class=\"string\">\"山西晋中\"</span></div><div class=\"line\">dream: <span class=\"string\">\"两亩地一头牛，老婆孩子热炕头\"</span></div></pre></td></tr></table></figure>\n<p>本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。也有生活中的一些总结。</p>\n<h1 id=\"博客基础\"><a href=\"#博客基础\" class=\"headerlink\" title=\"博客基础\"></a>博客基础</h1><p><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>一款轻量级的静态博客框架<br><a href=\"https://github.com/A-limon/pacman\" target=\"_blank\" rel=\"external\">Pacman</a>扁平化、响应式Hexo主题<br><a href=\"https://www.gitbook.com/book/noahsoft/-makedown/details\" target=\"_blank\" rel=\"external\">Markdown</a>一款轻量级的标记语言</p>\n<h1 id=\"技能栈\"><a href=\"#技能栈\" class=\"headerlink\" title=\"技能栈\"></a>技能栈</h1><p>Java</p>\n<p>Git</p>\n<p>设计模式</p>\n<p>Linux</p>\n<h1 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h1><p>《重构 改善既有代码的设计》  人民邮电出版社</p>\n<p>《深入理解JVM虚拟机》  机械工业出版社</p>\n<p>《大话设计模式》  清华大学出版社  </p>\n<p>《Java 并发编程实战》 机械工业出版社</p>\n<p>《鸟哥的Linux私房菜》 人民邮电出版社</p>\n<p>《大型网站技术架构》 电子工业出版社</p>\n","excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">name: <span class=\"string\">\"于凯\"</span></div><div class=\"line\">university: <span class=\"string\">\"中国民航大学\"</span></div><div class=\"line\">hometown: <span class=\"string\">\"山西晋中\"</span></div><div class=\"line\">dream: <span class=\"string\">\"两亩地一头牛，老婆孩子热炕头\"</span></div></pre></td></tr></table></figure>\n<p>本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。也有生活中的一些总结。</p>\n<h1 id=\"博客基础\"><a href=\"#博客基础\" class=\"headerlink\" title=\"博客基础\"></a>博客基础</h1><p><a href=\"https://hexo.io/\">Hexo</a>一款轻量级的静态博客框架<br><a href=\"https://github.com/A-limon/pacman\">Pacman</a>扁平化、响应式Hexo主题<br><a href=\"https://www.gitbook.com/book/noahsoft/-makedown/details\">Markdown</a>一款轻量级的标记语言</p>\n<h1 id=\"技能栈\"><a href=\"#技能栈\" class=\"headerlink\" title=\"技能栈\"></a>技能栈</h1><p>Java</p>\n<p>Git</p>\n<p>设计模式</p>\n<p>Linux</p>\n<h1 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h1><p>《重构 改善既有代码的设计》  人民邮电出版社</p>\n<p>《深入理解JVM虚拟机》  机械工业出版社</p>\n<p>《大话设计模式》  清华大学出版社  </p>\n<p>《Java 并发编程实战》 机械工业出版社</p>\n<p>《鸟哥的Linux私房菜》 人民邮电出版社</p>\n<p>《大型网站技术架构》 电子工业出版社</p>\n"}],"Post":[{"layout":"post","date":"2016-07-18T04:48:55.000Z","title":"ANT的使用","_content":"\n>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和[Ant](http://ant.apache.org/)打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。\n\n## 教程\n\nAnt是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。\n\n[Ant Tutorial](http://www.tutorialspoint.com/ant/index.htm)\n\n[Ant 实践](http://www.uml.org.cn/j2ee/j2ee091302.htm#content)\n\n另外附上Ant常用命令：\n\n[Overview of Apache Ant Tasks](https://ant.apache.org/manual/tasksoverview.html)\n\n## 实践\n\n下面是自己写的build.xml。存在这里，以后用到可以参考。\n\n下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。\n\n- **build.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n    Oscar XcluseterHibernate Ant build file\n-->\n<project name=\"OSCAR-XCLUSETER-HIBERNATE\" default=\"usage\" basedir=\".\">\n\t<target name=\"build\" depends=\"clean\" />\n\n\t<target name=\"init\" description=\"default init\">\n\t\t<property file=\"build.properties\" />\n\n\t\t<!-- Project Properties -->\n\t\t<property name=\"project\" value=\"oscarXcluseterHibernate3\" />\n\t\t<property name=\"name\" value=\"OSCAR HIBERNATE\" />\n\t\t<tstamp>\n\t\t\t<format property=\"year\" pattern=\"yyyy\" locale=\"zh_CN\" />\n\t\t\t<format property=\"builddate\" pattern=\"yyMMdd\" locale=\"zh_CN\" />\n\t\t</tstamp>\n\t\t<property name=\"version\" value=\"${version.major}.${version.minor}.${version.revision}${version.suffix}\" />\n\t\t<property name=\"version.number\" value=\"${version.major}.${version.minor}.${version.revision}\" />\n\t\t<property name=\"version.major.minor\" value=\"${version.major}.${version.minor}\" />\n\n\t\t<property name=\"final.name\" value=\"${project}\" />\n\t\t<property name=\"vesrion.build\" value=\"build${builddate} ${version.subbuild} ${version.buildID} for ALL \" />\n\n\t\t<!-- Build Defaults -->\n\t\t<property name=\"src.dir\" value=\"${basedir}/src\" />\n\t\t<property name=\"lib.dir\" value=\"${basedir}/lib\" />\n\t\t<property name=\"build.home\" value=\"${basedir}\" />\n\t\t<property name=\"build.src\" value=\"${basedir}/build\" />\n\t\t<property name=\"build.dest\" value=\"${basedir}/antClasses\" />\n\t\t<property name=\"build.release\" value=\"${basedir}/release\" />\n\t\t<property name=\"build.tmp\" value=\"${basedir}/tmp\" />\n\n\t\t<!-- JAR artifacts -->\n\t\t<property name=\"hiberante3.jar\" value=\"${lib.dir}/hibernate3.jar\" />\n\n\t\t<!-- Version info filter set -->\n\t\t<tstamp>\n\t\t\t<format property=\"DSTAMP\" pattern=\"yyyyMMdd\" locale=\"zh_CN\" />\n\t\t\t<format property=\"TSTAMP\" pattern=\"hhmm\" />\n\t\t</tstamp>\n\t\t<filterset id=\"version.filters\">\n\t\t\t<filter token=\"VERSION_NUMBER\" value=\"${version.number}\" />\n\t\t\t<filter token=\"BUNDLE_NAME\" value=\"${vesrion.name}\" />\n\t\t\t<filter token=\"BUNDLE_VERSION\" value=\"${version}${DSTAMP}${TSTAMP}\" />\n\t\t\t<filter token=\"BUILD_VERSION\" value=\"${vesrion.build}\" />\n\t\t</filterset>\n\t\t<path id=\"classpath\">\n\t\t\t<pathelement location=\"${hiberante3.jar}\" />\n\t\t</path>\n\t</target>\n\n\t<target name=\"usage\" depends=\"init\">\n\t\t<echo message=\"${name} Build file\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" available targets are:\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"   package  --> generates oscarXcluseterHibernate file\" />\n\t\t<echo message=\"   build    --> compiles the source code\" />\n\t\t<echo message=\"   clean    --> cleans up the directory\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" See the comments inside the build.xml file for more details.\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"\" />\n\t</target>\n\n\t<!-- Just build -->\n\t<target name=\"compile-prepare\" depends=\"init\" description=\"Prepare for compile\">\n\n\t\t<!-- create directories -->\n\t\t<mkdir dir=\"${build.src}\" />\n\t\t<mkdir dir=\"${build.dest}\" />\n\n\t\t<!-- copy src files -->\n\t\t<copy todir=\"${build.src}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${src.dir}\">\n\t\t\t\t<exclude name=\"**/*.MF\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"compile\" depends=\"compile-prepare\" description=\"compile the project\">\n\n\t\t<!-- Compiles the source directory  -->\n\t\t<javac srcdir=\"${build.src}\" \n\t\t\tdestdir=\"${build.dest}\" \n\t\t\tdebug=\"${build.debug}\" \n\t\t\tdeprecation=\"${build.deprecation}\" \n\t\t\tsource=\"${build.source}\" \n\t\t\ttarget=\"${build.target}\" \n\t\t\tcompiler=\"${build.compiler}\" \n\t\t\toptimize=\"${build.optimize}\" \n\t\t\tincludes=\"**/*.java\" \n\t\t\texcludes=\"**/CVS/**,**/.svn/**\" \n\t\t\tencoding=\"GB18030\"\n\t\t\tincludeantruntime=\"false\"\n\t\t\texecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"\n\t\t\tfork=\"yes\">\n\t\t\t<classpath refid=\"classpath\" />\n\t\t</javac>\n\n\t\t<!-- copy src files exclude java file-->\n\t\t<copy todir=\"${build.dest}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${build.src}\">\n\t\t\t\t<exclude name=\"**/*.java\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"build-manifests\" depends=\"init,compile-prepare\">\n\t\t<!-- Filtering tokens for JAR manifests-->\n\t\t<filter token=\"source.jdk\" value=\"${build.source}\" />\n\t\t<filter token=\"target.jdk\" value=\"${build.target}\" />\n\t\t<mkdir dir=\"${build.tmp}\" />\n\t\t<copy todir=\"${build.tmp}\" overwrite=\"yes\" filtering=\"yes\" encoding=\"GB18030\">\n\t\t\t<filterset refid=\"version.filters\" />\n\t\t\t<fileset dir=\"src/META-INF\" includes=\"MANIFEST.MF\" />\n\t\t</copy>\n\t</target>\n\n\t<target name=\"package\" depends=\"compile,build-manifests\" description=\"create jar file\">\n\t\t<mkdir dir=\"${build.release}\" />\n\t\t<jar jarfile=\"${build.release}/${final.name}.jar\" manifest=\"${build.tmp}/MANIFEST.MF\" basedir=\"${build.dest}\" includes=\"**\" />\n\t</target>\n\n\t<target name=\"clean\" depends=\"package\">\n\t\t<delete dir=\"${build.src}\" />\n\t\t<delete dir=\"${build.dest}\" />\n\t\t<delete dir=\"${build.tmp}\" />\n\t</target>\n</project>\n\n```\n\n- **build.properties**\n\n```java\n\n# -----------------------------------------------------------------------------\n# build.properties\n#\n# This is an example \"build.properties\" file, used to customize building \n# OSCAR-JDBC for your local environment.  It defines the location of all external\n# modules that OSCAR-JDBC depends on.\n# -----------------------------------------------------------------------------\n\n# ----- Version Control Flags -----\nvesrion.name=Main\nversion.major=1\nversion.minor=0\nversion.revision=0\nversion.suffix=x\nversion.subbuild=001\nversion.buildID=00000000\n\nbuild.source=1.5\nbuild.target=1.5\nbuild.debug=false\nbuild.optimize=true\nbuild.compiler=javac1.5\n\n```","source":"_posts/Ant的使用.md","raw":"---\nlayout: post\ndate:   2016-07-18 12:48:55\ntitle:  \"ANT的使用\"\ncategories: 工具\ntags: \n- java\n- ant\n---\n\n>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和[Ant](http://ant.apache.org/)打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。\n\n## 教程\n\nAnt是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。\n\n[Ant Tutorial](http://www.tutorialspoint.com/ant/index.htm)\n\n[Ant 实践](http://www.uml.org.cn/j2ee/j2ee091302.htm#content)\n\n另外附上Ant常用命令：\n\n[Overview of Apache Ant Tasks](https://ant.apache.org/manual/tasksoverview.html)\n\n## 实践\n\n下面是自己写的build.xml。存在这里，以后用到可以参考。\n\n下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。\n\n- **build.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n    Oscar XcluseterHibernate Ant build file\n-->\n<project name=\"OSCAR-XCLUSETER-HIBERNATE\" default=\"usage\" basedir=\".\">\n\t<target name=\"build\" depends=\"clean\" />\n\n\t<target name=\"init\" description=\"default init\">\n\t\t<property file=\"build.properties\" />\n\n\t\t<!-- Project Properties -->\n\t\t<property name=\"project\" value=\"oscarXcluseterHibernate3\" />\n\t\t<property name=\"name\" value=\"OSCAR HIBERNATE\" />\n\t\t<tstamp>\n\t\t\t<format property=\"year\" pattern=\"yyyy\" locale=\"zh_CN\" />\n\t\t\t<format property=\"builddate\" pattern=\"yyMMdd\" locale=\"zh_CN\" />\n\t\t</tstamp>\n\t\t<property name=\"version\" value=\"${version.major}.${version.minor}.${version.revision}${version.suffix}\" />\n\t\t<property name=\"version.number\" value=\"${version.major}.${version.minor}.${version.revision}\" />\n\t\t<property name=\"version.major.minor\" value=\"${version.major}.${version.minor}\" />\n\n\t\t<property name=\"final.name\" value=\"${project}\" />\n\t\t<property name=\"vesrion.build\" value=\"build${builddate} ${version.subbuild} ${version.buildID} for ALL \" />\n\n\t\t<!-- Build Defaults -->\n\t\t<property name=\"src.dir\" value=\"${basedir}/src\" />\n\t\t<property name=\"lib.dir\" value=\"${basedir}/lib\" />\n\t\t<property name=\"build.home\" value=\"${basedir}\" />\n\t\t<property name=\"build.src\" value=\"${basedir}/build\" />\n\t\t<property name=\"build.dest\" value=\"${basedir}/antClasses\" />\n\t\t<property name=\"build.release\" value=\"${basedir}/release\" />\n\t\t<property name=\"build.tmp\" value=\"${basedir}/tmp\" />\n\n\t\t<!-- JAR artifacts -->\n\t\t<property name=\"hiberante3.jar\" value=\"${lib.dir}/hibernate3.jar\" />\n\n\t\t<!-- Version info filter set -->\n\t\t<tstamp>\n\t\t\t<format property=\"DSTAMP\" pattern=\"yyyyMMdd\" locale=\"zh_CN\" />\n\t\t\t<format property=\"TSTAMP\" pattern=\"hhmm\" />\n\t\t</tstamp>\n\t\t<filterset id=\"version.filters\">\n\t\t\t<filter token=\"VERSION_NUMBER\" value=\"${version.number}\" />\n\t\t\t<filter token=\"BUNDLE_NAME\" value=\"${vesrion.name}\" />\n\t\t\t<filter token=\"BUNDLE_VERSION\" value=\"${version}${DSTAMP}${TSTAMP}\" />\n\t\t\t<filter token=\"BUILD_VERSION\" value=\"${vesrion.build}\" />\n\t\t</filterset>\n\t\t<path id=\"classpath\">\n\t\t\t<pathelement location=\"${hiberante3.jar}\" />\n\t\t</path>\n\t</target>\n\n\t<target name=\"usage\" depends=\"init\">\n\t\t<echo message=\"${name} Build file\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" available targets are:\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"   package  --> generates oscarXcluseterHibernate file\" />\n\t\t<echo message=\"   build    --> compiles the source code\" />\n\t\t<echo message=\"   clean    --> cleans up the directory\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" See the comments inside the build.xml file for more details.\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"\" />\n\t</target>\n\n\t<!-- Just build -->\n\t<target name=\"compile-prepare\" depends=\"init\" description=\"Prepare for compile\">\n\n\t\t<!-- create directories -->\n\t\t<mkdir dir=\"${build.src}\" />\n\t\t<mkdir dir=\"${build.dest}\" />\n\n\t\t<!-- copy src files -->\n\t\t<copy todir=\"${build.src}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${src.dir}\">\n\t\t\t\t<exclude name=\"**/*.MF\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"compile\" depends=\"compile-prepare\" description=\"compile the project\">\n\n\t\t<!-- Compiles the source directory  -->\n\t\t<javac srcdir=\"${build.src}\" \n\t\t\tdestdir=\"${build.dest}\" \n\t\t\tdebug=\"${build.debug}\" \n\t\t\tdeprecation=\"${build.deprecation}\" \n\t\t\tsource=\"${build.source}\" \n\t\t\ttarget=\"${build.target}\" \n\t\t\tcompiler=\"${build.compiler}\" \n\t\t\toptimize=\"${build.optimize}\" \n\t\t\tincludes=\"**/*.java\" \n\t\t\texcludes=\"**/CVS/**,**/.svn/**\" \n\t\t\tencoding=\"GB18030\"\n\t\t\tincludeantruntime=\"false\"\n\t\t\texecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"\n\t\t\tfork=\"yes\">\n\t\t\t<classpath refid=\"classpath\" />\n\t\t</javac>\n\n\t\t<!-- copy src files exclude java file-->\n\t\t<copy todir=\"${build.dest}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${build.src}\">\n\t\t\t\t<exclude name=\"**/*.java\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"build-manifests\" depends=\"init,compile-prepare\">\n\t\t<!-- Filtering tokens for JAR manifests-->\n\t\t<filter token=\"source.jdk\" value=\"${build.source}\" />\n\t\t<filter token=\"target.jdk\" value=\"${build.target}\" />\n\t\t<mkdir dir=\"${build.tmp}\" />\n\t\t<copy todir=\"${build.tmp}\" overwrite=\"yes\" filtering=\"yes\" encoding=\"GB18030\">\n\t\t\t<filterset refid=\"version.filters\" />\n\t\t\t<fileset dir=\"src/META-INF\" includes=\"MANIFEST.MF\" />\n\t\t</copy>\n\t</target>\n\n\t<target name=\"package\" depends=\"compile,build-manifests\" description=\"create jar file\">\n\t\t<mkdir dir=\"${build.release}\" />\n\t\t<jar jarfile=\"${build.release}/${final.name}.jar\" manifest=\"${build.tmp}/MANIFEST.MF\" basedir=\"${build.dest}\" includes=\"**\" />\n\t</target>\n\n\t<target name=\"clean\" depends=\"package\">\n\t\t<delete dir=\"${build.src}\" />\n\t\t<delete dir=\"${build.dest}\" />\n\t\t<delete dir=\"${build.tmp}\" />\n\t</target>\n</project>\n\n```\n\n- **build.properties**\n\n```java\n\n# -----------------------------------------------------------------------------\n# build.properties\n#\n# This is an example \"build.properties\" file, used to customize building \n# OSCAR-JDBC for your local environment.  It defines the location of all external\n# modules that OSCAR-JDBC depends on.\n# -----------------------------------------------------------------------------\n\n# ----- Version Control Flags -----\nvesrion.name=Main\nversion.major=1\nversion.minor=0\nversion.revision=0\nversion.suffix=x\nversion.subbuild=001\nversion.buildID=00000000\n\nbuild.source=1.5\nbuild.target=1.5\nbuild.debug=false\nbuild.optimize=true\nbuild.compiler=javac1.5\n\n```","slug":"Ant的使用","published":1,"updated":"2017-02-19T13:08:11.028Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlov0000vegcb90zdb7n","content":"<blockquote>\n<p>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和<a href=\"http://ant.apache.org/\" target=\"_blank\" rel=\"external\">Ant</a>打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。</p>\n</blockquote>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><p>Ant是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。</p>\n<p><a href=\"http://www.tutorialspoint.com/ant/index.htm\" target=\"_blank\" rel=\"external\">Ant Tutorial</a></p>\n<p><a href=\"http://www.uml.org.cn/j2ee/j2ee091302.htm#content\" target=\"_blank\" rel=\"external\">Ant 实践</a></p>\n<p>另外附上Ant常用命令：</p>\n<p><a href=\"https://ant.apache.org/manual/tasksoverview.html\" target=\"_blank\" rel=\"external\">Overview of Apache Ant Tasks</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>下面是自己写的build.xml。存在这里，以后用到可以参考。</p>\n<p>下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。</p>\n<ul>\n<li><strong>build.xml</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"comment\">&lt;!--</span></div><div class=\"line\">    Oscar XcluseterHibernate Ant build file</div><div class=\"line\">--&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">name</span>=<span class=\"string\">\"OSCAR-XCLUSETER-HIBERNATE\"</span> <span class=\"attr\">default</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\".\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"clean\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"default init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">file</span>=<span class=\"string\">\"build.properties\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Project Properties --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"project\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"oscarXcluseterHibernate3\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"OSCAR HIBERNATE\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"year\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyy\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"builddate\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;$&#123;version.suffix&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.number\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.major.minor\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"final.name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;project&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"vesrion.build\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"build$&#123;builddate&#125; $&#123;version.subbuild&#125; $&#123;version.buildID&#125; for ALL \"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Build Defaults --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"src.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/src\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lib.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/lib\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.home\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.src\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/build\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.dest\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/antClasses\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.release\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/release\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.tmp\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/tmp\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- JAR artifacts --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hiberante3.jar\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;lib.dir&#125;/hibernate3.jar\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Version info filter set --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"DSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"TSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"hhmm\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">id</span>=<span class=\"string\">\"version.filters\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"VERSION_NUMBER\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.number&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_NAME\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.name&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version&#125;$&#123;DSTAMP&#125;$&#123;TSTAMP&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUILD_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.build&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">filterset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"classpath\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">pathelement</span> <span class=\"attr\">location</span>=<span class=\"string\">\"$&#123;hiberante3.jar&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"$&#123;name&#125; Build file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" available targets are:\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   package  --&gt; generates oscarXcluseterHibernate file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   build    --&gt; compiles the source code\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   clean    --&gt; cleans up the directory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" See the comments inside the build.xml file for more details.\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- Just build --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"Prepare for compile\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- create directories --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;src.dir&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"compile the project\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Compiles the source directory  --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">javac</span> <span class=\"attr\">srcdir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> </span></div><div class=\"line\">\t\t\t<span class=\"attr\">destdir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">debug</span>=<span class=\"string\">\"$&#123;build.debug&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">deprecation</span>=<span class=\"string\">\"$&#123;build.deprecation&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">source</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">target</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">compiler</span>=<span class=\"string\">\"$&#123;build.compiler&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">optimize</span>=<span class=\"string\">\"$&#123;build.optimize&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">includes</span>=<span class=\"string\">\"**/*.java\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">excludes</span>=<span class=\"string\">\"**/CVS/**,**/.svn/**\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">includeantruntime</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">executable</span>=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">fork</span>=<span class=\"string\">\"yes\"</span>&gt;</div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">classpath</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"classpath\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">javac</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files exclude java file--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.java\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build-manifests\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init,compile-prepare\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Filtering tokens for JAR manifests--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"source.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"target.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">filtering</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"version.filters\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"src/META-INF\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"MANIFEST.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"package\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile,build-manifests\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"create jar file\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.release&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">jar</span> <span class=\"attr\">jarfile</span>=<span class=\"string\">\"$&#123;build.release&#125;/$&#123;final.name&#125;.jar\"</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"$&#123;build.tmp&#125;/MANIFEST.MF\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"**\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"clean\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"package\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li><strong>build.properties</strong></li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"># build.properties</div><div class=\"line\">#</div><div class=\"line\"># This is an example \"build.properties\" file, used to customize building </div><div class=\"line\"># OSCAR-JDBC for your local environment.  It defines the location of all external</div><div class=\"line\"># modules that OSCAR-JDBC depends on.</div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\"># ----- Version Control Flags -----</div><div class=\"line\">vesrion.name=Main</div><div class=\"line\">version.major=1</div><div class=\"line\">version.minor=0</div><div class=\"line\">version.revision=0</div><div class=\"line\">version.suffix=x</div><div class=\"line\">version.subbuild=001</div><div class=\"line\">version.buildID=00000000</div><div class=\"line\"></div><div class=\"line\">build.source=1.5</div><div class=\"line\">build.target=1.5</div><div class=\"line\">build.debug=false</div><div class=\"line\">build.optimize=true</div><div class=\"line\">build.compiler=javac1.5</div></pre></td></tr></table></figure>","excerpt":"","more":"<blockquote>\n<p>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和<a href=\"http://ant.apache.org/\">Ant</a>打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。</p>\n</blockquote>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><p>Ant是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。</p>\n<p><a href=\"http://www.tutorialspoint.com/ant/index.htm\">Ant Tutorial</a></p>\n<p><a href=\"http://www.uml.org.cn/j2ee/j2ee091302.htm#content\">Ant 实践</a></p>\n<p>另外附上Ant常用命令：</p>\n<p><a href=\"https://ant.apache.org/manual/tasksoverview.html\">Overview of Apache Ant Tasks</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>下面是自己写的build.xml。存在这里，以后用到可以参考。</p>\n<p>下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。</p>\n<ul>\n<li><strong>build.xml</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"comment\">&lt;!--</div><div class=\"line\">    Oscar XcluseterHibernate Ant build file</div><div class=\"line\">--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">name</span>=<span class=\"string\">\"OSCAR-XCLUSETER-HIBERNATE\"</span> <span class=\"attr\">default</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\".\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"clean\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"default init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">file</span>=<span class=\"string\">\"build.properties\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Project Properties --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"project\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"oscarXcluseterHibernate3\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"OSCAR HIBERNATE\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"year\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyy\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"builddate\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;$&#123;version.suffix&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.number\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.major.minor\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"final.name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;project&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"vesrion.build\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"build$&#123;builddate&#125; $&#123;version.subbuild&#125; $&#123;version.buildID&#125; for ALL \"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Build Defaults --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"src.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/src\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lib.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/lib\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.home\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.src\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/build\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.dest\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/antClasses\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.release\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/release\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.tmp\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/tmp\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- JAR artifacts --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hiberante3.jar\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;lib.dir&#125;/hibernate3.jar\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Version info filter set --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"DSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"TSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"hhmm\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">id</span>=<span class=\"string\">\"version.filters\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"VERSION_NUMBER\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.number&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_NAME\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.name&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version&#125;$&#123;DSTAMP&#125;$&#123;TSTAMP&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUILD_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.build&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">filterset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"classpath\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">pathelement</span> <span class=\"attr\">location</span>=<span class=\"string\">\"$&#123;hiberante3.jar&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"$&#123;name&#125; Build file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" available targets are:\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   package  --&gt; generates oscarXcluseterHibernate file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   build    --&gt; compiles the source code\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   clean    --&gt; cleans up the directory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" See the comments inside the build.xml file for more details.\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- Just build --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"Prepare for compile\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- create directories --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;src.dir&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"compile the project\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Compiles the source directory  --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">javac</span> <span class=\"attr\">srcdir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">destdir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">debug</span>=<span class=\"string\">\"$&#123;build.debug&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">deprecation</span>=<span class=\"string\">\"$&#123;build.deprecation&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">source</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">target</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">compiler</span>=<span class=\"string\">\"$&#123;build.compiler&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">optimize</span>=<span class=\"string\">\"$&#123;build.optimize&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">includes</span>=<span class=\"string\">\"**/*.java\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">excludes</span>=<span class=\"string\">\"**/CVS/**,**/.svn/**\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">includeantruntime</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">executable</span>=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">fork</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">classpath</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"classpath\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">javac</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files exclude java file--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.java\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build-manifests\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init,compile-prepare\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Filtering tokens for JAR manifests--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"source.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"target.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">filtering</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"version.filters\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"src/META-INF\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"MANIFEST.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"package\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile,build-manifests\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"create jar file\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.release&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">jar</span> <span class=\"attr\">jarfile</span>=<span class=\"string\">\"$&#123;build.release&#125;/$&#123;final.name&#125;.jar\"</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"$&#123;build.tmp&#125;/MANIFEST.MF\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"**\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"clean\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"package\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li><strong>build.properties</strong></li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"># build.properties</div><div class=\"line\">#</div><div class=\"line\"># This is an example \"build.properties\" file, used to customize building </div><div class=\"line\"># OSCAR-JDBC for your local environment.  It defines the location of all external</div><div class=\"line\"># modules that OSCAR-JDBC depends on.</div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\"># ----- Version Control Flags -----</div><div class=\"line\">vesrion.name=Main</div><div class=\"line\">version.major=1</div><div class=\"line\">version.minor=0</div><div class=\"line\">version.revision=0</div><div class=\"line\">version.suffix=x</div><div class=\"line\">version.subbuild=001</div><div class=\"line\">version.buildID=00000000</div><div class=\"line\"></div><div class=\"line\">build.source=1.5</div><div class=\"line\">build.target=1.5</div><div class=\"line\">build.debug=false</div><div class=\"line\">build.optimize=true</div><div class=\"line\">build.compiler=javac1.5</div></pre></td></tr></table></figure>"},{"layout":"post","title":"Eclipse乱码问题终极解决方案","date":"2016-09-20T13:57:08.000Z","_content":"\n今天在Eclipse中导入一个新项目的时候，出现了乱码问题。研究一番...\n\n显示乱码的根本原因在于：**文件本身的编码和编辑器打开和编辑文件使用的编码不一致**。当编辑器以不同于文件的编码去解码该文件的时候，就会导致读出来乱码。大部分情况下英文显示正常是因为大部分编码都兼容ASCII，中文则会显示乱码。\n\n## 编辑器显示乱码问题\n\n在Eclipse中，设置编辑器显示和编辑文件所采用编码的方法有四种：\n\n1.Windows->Preference->General->Workspace ：修改整个工作空间\n\n{% asset_img 1.png 全局修改 %}\n\n2.右键Project->Properties->Resource ：修改某个工程\n\n{% asset_img 2.png 工程修改 %}\n\n3.右键文件->Properties ：修改某个文件\n\n{% asset_img 3.png 文件修改 %}\n\n4.Windows->Preference->General->Content types->Default encoding :全局修改某种类型的文件\n\n{% asset_img 4.png 全局文件修改 %}\n\n其中，3的优先级最高。也就是说某个文件被编辑器以哪种编码读取最终是由3中的Text file encoding决定的。一般情况下，如果我们不在3中显示指定编码(选择Other那一项)，Eclipse都会默认使用Default那一项的编码。那么，这个Default的编码又是如何决定的呢？\n\n{% asset_img 5.png 文件修改 %}\n\n注意上图中圈起来的部分：这部分表示了Default采用哪种编码是如何决定的。\n\n可能会出现三种情况：\n\n1.determined from content: xxx \n\n2.determined from content type: xxx\n\n3.inherit from container \n\n其中：\n\n1表示文件内容本身指定了编码，比如下图。\n\n{% asset_img 6.png 文件修改 %}\n\nEncoding Bit Order Mark，简写为BOM，表明文件本身指定了采用哪种编码方式。编辑器会优先采用这种编码。\n\n2表示采用了针对该文件类型的全局修改，也就是上面提到的第4种设置方式。\n\n3表示继承了上一级指定的编码，这个继承关系就是我们在上面提到的：修改某个文件->修改文件所属的工程->修改整个工作空间。->表示继承于。\n\n上面这3种情况的优先级：1>2>3 。也就是说如果文件本身表明了编码方式，Eclipse优先采用这种编码解码文件。若没有指定，Eclipse会查看该文件类型是否在上面的第4种方式设置中指定了编码，如有则采用该编码。如没有指定，则从下往上搜索继承关系链中指定的编码。（继承关系链：文件->工程->工作空间）\n\n通过上面的分析明白了Eclipse 编辑器选择显示文件所采用编码的原理，相信再次遇到编辑器中的乱码问题都可以找到合适的解决方案。上面的分析不仅仅适用于java文件，同样适用于xml等其他类型文件的乱码问题。\n\n另外一定要注意：**如果通过上面4中方式的某一种修改影响了某个文件的编码，则当你再次编辑完保存该文件时，则采用此时该文件在Eclipse中指定的编码方式保存到本地。**\n\n以上的对乱码问题的分析都是基于通过修改Eclipse编辑器显示文件内容采用的编码，使其与文件本身的编码一致的方式来解决的。还有另一种思路是反过来，修改文件编码与Eclipse显示文件内容所采用的编码一致来解决乱码问题。可以使用文件编码批量转换工具进行批量转换，比如UltraCodingSwitch等。\n\n## Console显示乱码问题\n\n右键要运行的类->Run As->Run Configuratios\n\n{% asset_img 6.png Console编码 %}\n\n可修改上图中Other中的编码来指定显示打印内容的编码。\n\n## 总结\n\n通过以上分析知道了如何在Eclipse中解决乱码的问题。其实文章一开始就说了，显示乱码的根本原因在于：**文件本身的编码和编辑器打开文件使用的编码不一致**。明白了这一点，就算在其他编辑器或编译器中或者任何能够显示文本内容的遇到乱码的情况都能够找到问题的根源，从而解决乱码问题。\n\n至于文件本身的编码，可以通过一定的手段去改变。如通过记事本等工具修改编码后另存为等方式。\n\nJava中输出一段内容到文件可以通过指定流的编码来指定输出字符的编码。\n\n以上","source":"_posts/Eclipse编码问题终极解决方案.md","raw":"---\nlayout: post\ntitle: Eclipse乱码问题终极解决方案\ndate: 2016-09-20 21:57:08\ncategories: 工具\ntags: \n- Eclipse\n---\n\n今天在Eclipse中导入一个新项目的时候，出现了乱码问题。研究一番...\n\n显示乱码的根本原因在于：**文件本身的编码和编辑器打开和编辑文件使用的编码不一致**。当编辑器以不同于文件的编码去解码该文件的时候，就会导致读出来乱码。大部分情况下英文显示正常是因为大部分编码都兼容ASCII，中文则会显示乱码。\n\n## 编辑器显示乱码问题\n\n在Eclipse中，设置编辑器显示和编辑文件所采用编码的方法有四种：\n\n1.Windows->Preference->General->Workspace ：修改整个工作空间\n\n{% asset_img 1.png 全局修改 %}\n\n2.右键Project->Properties->Resource ：修改某个工程\n\n{% asset_img 2.png 工程修改 %}\n\n3.右键文件->Properties ：修改某个文件\n\n{% asset_img 3.png 文件修改 %}\n\n4.Windows->Preference->General->Content types->Default encoding :全局修改某种类型的文件\n\n{% asset_img 4.png 全局文件修改 %}\n\n其中，3的优先级最高。也就是说某个文件被编辑器以哪种编码读取最终是由3中的Text file encoding决定的。一般情况下，如果我们不在3中显示指定编码(选择Other那一项)，Eclipse都会默认使用Default那一项的编码。那么，这个Default的编码又是如何决定的呢？\n\n{% asset_img 5.png 文件修改 %}\n\n注意上图中圈起来的部分：这部分表示了Default采用哪种编码是如何决定的。\n\n可能会出现三种情况：\n\n1.determined from content: xxx \n\n2.determined from content type: xxx\n\n3.inherit from container \n\n其中：\n\n1表示文件内容本身指定了编码，比如下图。\n\n{% asset_img 6.png 文件修改 %}\n\nEncoding Bit Order Mark，简写为BOM，表明文件本身指定了采用哪种编码方式。编辑器会优先采用这种编码。\n\n2表示采用了针对该文件类型的全局修改，也就是上面提到的第4种设置方式。\n\n3表示继承了上一级指定的编码，这个继承关系就是我们在上面提到的：修改某个文件->修改文件所属的工程->修改整个工作空间。->表示继承于。\n\n上面这3种情况的优先级：1>2>3 。也就是说如果文件本身表明了编码方式，Eclipse优先采用这种编码解码文件。若没有指定，Eclipse会查看该文件类型是否在上面的第4种方式设置中指定了编码，如有则采用该编码。如没有指定，则从下往上搜索继承关系链中指定的编码。（继承关系链：文件->工程->工作空间）\n\n通过上面的分析明白了Eclipse 编辑器选择显示文件所采用编码的原理，相信再次遇到编辑器中的乱码问题都可以找到合适的解决方案。上面的分析不仅仅适用于java文件，同样适用于xml等其他类型文件的乱码问题。\n\n另外一定要注意：**如果通过上面4中方式的某一种修改影响了某个文件的编码，则当你再次编辑完保存该文件时，则采用此时该文件在Eclipse中指定的编码方式保存到本地。**\n\n以上的对乱码问题的分析都是基于通过修改Eclipse编辑器显示文件内容采用的编码，使其与文件本身的编码一致的方式来解决的。还有另一种思路是反过来，修改文件编码与Eclipse显示文件内容所采用的编码一致来解决乱码问题。可以使用文件编码批量转换工具进行批量转换，比如UltraCodingSwitch等。\n\n## Console显示乱码问题\n\n右键要运行的类->Run As->Run Configuratios\n\n{% asset_img 6.png Console编码 %}\n\n可修改上图中Other中的编码来指定显示打印内容的编码。\n\n## 总结\n\n通过以上分析知道了如何在Eclipse中解决乱码的问题。其实文章一开始就说了，显示乱码的根本原因在于：**文件本身的编码和编辑器打开文件使用的编码不一致**。明白了这一点，就算在其他编辑器或编译器中或者任何能够显示文本内容的遇到乱码的情况都能够找到问题的根源，从而解决乱码问题。\n\n至于文件本身的编码，可以通过一定的手段去改变。如通过记事本等工具修改编码后另存为等方式。\n\nJava中输出一段内容到文件可以通过指定流的编码来指定输出字符的编码。\n\n以上","slug":"Eclipse编码问题终极解决方案","published":1,"updated":"2017-02-19T13:08:11.028Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlp70002vegcsiqckxxb","content":"<p>今天在Eclipse中导入一个新项目的时候，出现了乱码问题。研究一番…</p>\n<p>显示乱码的根本原因在于：<strong>文件本身的编码和编辑器打开和编辑文件使用的编码不一致</strong>。当编辑器以不同于文件的编码去解码该文件的时候，就会导致读出来乱码。大部分情况下英文显示正常是因为大部分编码都兼容ASCII，中文则会显示乱码。</p>\n<h2 id=\"编辑器显示乱码问题\"><a href=\"#编辑器显示乱码问题\" class=\"headerlink\" title=\"编辑器显示乱码问题\"></a>编辑器显示乱码问题</h2><p>在Eclipse中，设置编辑器显示和编辑文件所采用编码的方法有四种：</p>\n<p>1.Windows-&gt;Preference-&gt;General-&gt;Workspace ：修改整个工作空间</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/1.png\" alt=\"全局修改\" title=\"全局修改\">\n<p>2.右键Project-&gt;Properties-&gt;Resource ：修改某个工程</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/2.png\" alt=\"工程修改\" title=\"工程修改\">\n<p>3.右键文件-&gt;Properties ：修改某个文件</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/3.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>4.Windows-&gt;Preference-&gt;General-&gt;Content types-&gt;Default encoding :全局修改某种类型的文件</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/4.png\" alt=\"全局文件修改\" title=\"全局文件修改\">\n<p>其中，3的优先级最高。也就是说某个文件被编辑器以哪种编码读取最终是由3中的Text file encoding决定的。一般情况下，如果我们不在3中显示指定编码(选择Other那一项)，Eclipse都会默认使用Default那一项的编码。那么，这个Default的编码又是如何决定的呢？</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/5.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>注意上图中圈起来的部分：这部分表示了Default采用哪种编码是如何决定的。</p>\n<p>可能会出现三种情况：</p>\n<p>1.determined from content: xxx </p>\n<p>2.determined from content type: xxx</p>\n<p>3.inherit from container </p>\n<p>其中：</p>\n<p>1表示文件内容本身指定了编码，比如下图。</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/6.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>Encoding Bit Order Mark，简写为BOM，表明文件本身指定了采用哪种编码方式。编辑器会优先采用这种编码。</p>\n<p>2表示采用了针对该文件类型的全局修改，也就是上面提到的第4种设置方式。</p>\n<p>3表示继承了上一级指定的编码，这个继承关系就是我们在上面提到的：修改某个文件-&gt;修改文件所属的工程-&gt;修改整个工作空间。-&gt;表示继承于。</p>\n<p>上面这3种情况的优先级：1&gt;2&gt;3 。也就是说如果文件本身表明了编码方式，Eclipse优先采用这种编码解码文件。若没有指定，Eclipse会查看该文件类型是否在上面的第4种方式设置中指定了编码，如有则采用该编码。如没有指定，则从下往上搜索继承关系链中指定的编码。（继承关系链：文件-&gt;工程-&gt;工作空间）</p>\n<p>通过上面的分析明白了Eclipse 编辑器选择显示文件所采用编码的原理，相信再次遇到编辑器中的乱码问题都可以找到合适的解决方案。上面的分析不仅仅适用于java文件，同样适用于xml等其他类型文件的乱码问题。</p>\n<p>另外一定要注意：<strong>如果通过上面4中方式的某一种修改影响了某个文件的编码，则当你再次编辑完保存该文件时，则采用此时该文件在Eclipse中指定的编码方式保存到本地。</strong></p>\n<p>以上的对乱码问题的分析都是基于通过修改Eclipse编辑器显示文件内容采用的编码，使其与文件本身的编码一致的方式来解决的。还有另一种思路是反过来，修改文件编码与Eclipse显示文件内容所采用的编码一致来解决乱码问题。可以使用文件编码批量转换工具进行批量转换，比如UltraCodingSwitch等。</p>\n<h2 id=\"Console显示乱码问题\"><a href=\"#Console显示乱码问题\" class=\"headerlink\" title=\"Console显示乱码问题\"></a>Console显示乱码问题</h2><p>右键要运行的类-&gt;Run As-&gt;Run Configuratios</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/6.png\" alt=\"Console编码\" title=\"Console编码\">\n<p>可修改上图中Other中的编码来指定显示打印内容的编码。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过以上分析知道了如何在Eclipse中解决乱码的问题。其实文章一开始就说了，显示乱码的根本原因在于：<strong>文件本身的编码和编辑器打开文件使用的编码不一致</strong>。明白了这一点，就算在其他编辑器或编译器中或者任何能够显示文本内容的遇到乱码的情况都能够找到问题的根源，从而解决乱码问题。</p>\n<p>至于文件本身的编码，可以通过一定的手段去改变。如通过记事本等工具修改编码后另存为等方式。</p>\n<p>Java中输出一段内容到文件可以通过指定流的编码来指定输出字符的编码。</p>\n<p>以上</p>\n","excerpt":"","more":"<p>今天在Eclipse中导入一个新项目的时候，出现了乱码问题。研究一番…</p>\n<p>显示乱码的根本原因在于：<strong>文件本身的编码和编辑器打开和编辑文件使用的编码不一致</strong>。当编辑器以不同于文件的编码去解码该文件的时候，就会导致读出来乱码。大部分情况下英文显示正常是因为大部分编码都兼容ASCII，中文则会显示乱码。</p>\n<h2 id=\"编辑器显示乱码问题\"><a href=\"#编辑器显示乱码问题\" class=\"headerlink\" title=\"编辑器显示乱码问题\"></a>编辑器显示乱码问题</h2><p>在Eclipse中，设置编辑器显示和编辑文件所采用编码的方法有四种：</p>\n<p>1.Windows-&gt;Preference-&gt;General-&gt;Workspace ：修改整个工作空间</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/1.png\" alt=\"全局修改\" title=\"全局修改\">\n<p>2.右键Project-&gt;Properties-&gt;Resource ：修改某个工程</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/2.png\" alt=\"工程修改\" title=\"工程修改\">\n<p>3.右键文件-&gt;Properties ：修改某个文件</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/3.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>4.Windows-&gt;Preference-&gt;General-&gt;Content types-&gt;Default encoding :全局修改某种类型的文件</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/4.png\" alt=\"全局文件修改\" title=\"全局文件修改\">\n<p>其中，3的优先级最高。也就是说某个文件被编辑器以哪种编码读取最终是由3中的Text file encoding决定的。一般情况下，如果我们不在3中显示指定编码(选择Other那一项)，Eclipse都会默认使用Default那一项的编码。那么，这个Default的编码又是如何决定的呢？</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/5.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>注意上图中圈起来的部分：这部分表示了Default采用哪种编码是如何决定的。</p>\n<p>可能会出现三种情况：</p>\n<p>1.determined from content: xxx </p>\n<p>2.determined from content type: xxx</p>\n<p>3.inherit from container </p>\n<p>其中：</p>\n<p>1表示文件内容本身指定了编码，比如下图。</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/6.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>Encoding Bit Order Mark，简写为BOM，表明文件本身指定了采用哪种编码方式。编辑器会优先采用这种编码。</p>\n<p>2表示采用了针对该文件类型的全局修改，也就是上面提到的第4种设置方式。</p>\n<p>3表示继承了上一级指定的编码，这个继承关系就是我们在上面提到的：修改某个文件-&gt;修改文件所属的工程-&gt;修改整个工作空间。-&gt;表示继承于。</p>\n<p>上面这3种情况的优先级：1&gt;2&gt;3 。也就是说如果文件本身表明了编码方式，Eclipse优先采用这种编码解码文件。若没有指定，Eclipse会查看该文件类型是否在上面的第4种方式设置中指定了编码，如有则采用该编码。如没有指定，则从下往上搜索继承关系链中指定的编码。（继承关系链：文件-&gt;工程-&gt;工作空间）</p>\n<p>通过上面的分析明白了Eclipse 编辑器选择显示文件所采用编码的原理，相信再次遇到编辑器中的乱码问题都可以找到合适的解决方案。上面的分析不仅仅适用于java文件，同样适用于xml等其他类型文件的乱码问题。</p>\n<p>另外一定要注意：<strong>如果通过上面4中方式的某一种修改影响了某个文件的编码，则当你再次编辑完保存该文件时，则采用此时该文件在Eclipse中指定的编码方式保存到本地。</strong></p>\n<p>以上的对乱码问题的分析都是基于通过修改Eclipse编辑器显示文件内容采用的编码，使其与文件本身的编码一致的方式来解决的。还有另一种思路是反过来，修改文件编码与Eclipse显示文件内容所采用的编码一致来解决乱码问题。可以使用文件编码批量转换工具进行批量转换，比如UltraCodingSwitch等。</p>\n<h2 id=\"Console显示乱码问题\"><a href=\"#Console显示乱码问题\" class=\"headerlink\" title=\"Console显示乱码问题\"></a>Console显示乱码问题</h2><p>右键要运行的类-&gt;Run As-&gt;Run Configuratios</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/6.png\" alt=\"Console编码\" title=\"Console编码\">\n<p>可修改上图中Other中的编码来指定显示打印内容的编码。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过以上分析知道了如何在Eclipse中解决乱码的问题。其实文章一开始就说了，显示乱码的根本原因在于：<strong>文件本身的编码和编辑器打开文件使用的编码不一致</strong>。明白了这一点，就算在其他编辑器或编译器中或者任何能够显示文本内容的遇到乱码的情况都能够找到问题的根源，从而解决乱码问题。</p>\n<p>至于文件本身的编码，可以通过一定的手段去改变。如通过记事本等工具修改编码后另存为等方式。</p>\n<p>Java中输出一段内容到文件可以通过指定流的编码来指定输出字符的编码。</p>\n<p>以上</p>\n"},{"layout":"post","title":"java I/O总结","date":"2017-03-19T09:09:19.000Z","_content":"> 在平时维护JDBC驱动的过程中，经常会接触到IO相关的代码。总结梳理一下java中的IO~\n\n## IO\n\nIO，即Input和Output。流可以理解为字节序列的流动，可以从其中读入字节序列的对象称为输入流，可以向其中写入字节序列的对象称为输出流。\n这些字节序列的来源和目的地可以是文件，网络，或者内存等。\n\njava中的IO基本可以分为两大类：\n\n1.基于字节操作的 I/O 接口：InputStream 和 OutputStream\n\n2.基于字符操作的 I/O 接口：Writer 和 Reader\n\n不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符。但是我们的程序通常操作的数据都是以字符的形式存在，比如处理网页中的内容或者磁盘文件中的文本。\n为了操作方便，提供了直接操作字符的接口。操作字符的接口底层还是基于字节的，只不过封装了一些例如编码和解码等操作。\n\n下面是java.io包中的内容：[Package java.io](https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html)\n\n{% asset_img io.png java.io %}\n\njava.io 类图:\n\n{% asset_img javaio.png java.io %}\n\n## 字节接口\n\n{% asset_img stream.png 字节流 %}\n\n上图给出了InputStream和OutputStream的继承关系(不仅仅是java.io包)\n\n理解InputStream家族，首先要理解[装饰者模式](http://www.cnblogs.com/god_bless_you/archive/2010/06/10/1755212.html)：\n\n---\n{% asset_img decorator.jpg 装饰者模式 %}\n\n```\nComponent：\n\n定义一个对象接口，可以给这些对象动态地添加职责。\n\npublic interface Component\n{\n\tvoid operation();\n}\n \n\nConcrete Component：\n\n定义一个对象，可以给这个对象添加一些职责。动作的具体实施者。\n\npublic class ConcreteComponent implements Component\n{\n\tpublic void operation()\n\t{\n\t\t// Write your code here\n\t}\n}\n \n\nDecorator：\n\n维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。\n\npublic class Decorator implements Component\n{\n\tpublic Decorator(Component component)\n\t{\n\t\tthis.component = component;\n\t}\n\t\n\tpublic void operation()\n\t{\n\t\tcomponent.operation();\n\t}\n\t\n\tprivate Component component;\n}\n \n\nConcrete Decorator：\n\n在Concrete Component的行为之前或之后，加上自己的行为，以“贴上”附加的职责。\n\npublic class ConcreteDecorator extends Decorator\n{\n\tpublic void operation()\n\t{\n\t\t//addBehavior也可以在前面\n\t\t\n\t\tsuper.operation();\n\t\t\n\t\taddBehavior();\n\t}\n\t\n\tprivate void addBehavior()\n\t{\n\t\t//your code\n\t}\n}\n```\n使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。\n装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。\n\n---\n\nInputStream族与装饰者模式的对应关系：\n\nComponent: InputStream\n\nConcreteComponent: InputStream除FilterINputStream以外的直接子类，如FileInputStream，他们提供了最终的读取字节功能\n\nDecorator: FilterInputStream\n\nConcreteDecorator: FilterINputStream的直接子类，如BufferedInputStream，他们为读取字节附加了一些功能\n\n首先看一下InputStream为我们提供了哪些操作：\n\n```\nint\tavailable()\n返回不阻塞情况下可用的字节数\nvoid close()\n关闭这个输入流\nvoid mark(int readlimit)\n在流的当前位置打一个标记\nboolean\tmarkSupported()\n如果这个流支持打标记，则返回true\nabstract int read()\n从数据中读取一个字节，并返回该字节\nint\tread(byte[] b)\n读入一个字节数组，并返回读入的字节数\nint\tread(byte[] b, int off, int len)\n读入一个字节数组，并返回读入的字节数。b:数据读入的数组  off:第一个读入的字节在b中的偏移量  len:读入字节的最大数量\nvoid reset()\n返回最后的标记，随后对read的调用将重新读入这些字节\nlong skip(long n)\n在输入流中跳过n个字节，返回实际跳过数\n```\n\n其中：\nabstract int read()\nint\tread(byte[] b)\nint\tread(byte[] b, int off, int len)\n\n这三个方法提供了基本的读入功能。read方法在执行时将被阻塞，直到字节确实被读入。InputStream的子类实现或重写了这些方法的具体的操作，来完成对具体对象的读入功能。\n\n通过一个简单的例子来理解InputStream的组合过滤器功能。\n\n我们要从文件中读入数字，则首先必须有一个具体实现读取文件的FileInputStream实例： FileInputStream fin = new FileInputStream(\"test.dat\");\n\n流在默认情况下是不被缓冲区缓存的，也就是说，对于每一次的read的调用都会请求操作系统再分发一个字节。相比之下，一次请求一个数据块将其置于缓冲区显得更加高效。\n因此，我们为流添加缓冲功能，形成缓冲流： BufferedInputStream bin = new BufferedInputStream(fin);\n\ntest.dat文件中存储的是十进制数字的二进制序列。此时我们的流仅仅提供了读取字节序列的功能，为了实现将二进制序列转为十进制数字的功能，我们做进一步转换：\nDataInputStream din = new DataInputStream(bin);\n\n此时我们可以调用 din.readInt()方法依次读取文件中以二进制形式存储的十进制数字了。\n\n注意，我们将DataInputStream置于构造链的最后，这是因为我们最终希望使用DataInputStream的方法来读取十进制数字。\n\n观察一下上面提到的几个类的实现，就会对这种装饰者模式的工作机制有更加深刻的理解。理解了装饰者模式之后，再结合上面的类图，使用IO流就会更加得心应手。\n\n对于OutputStream，实现原理与InputStream是一样的，不再赘述。\n\n记录几个常用的stream：\n\nDataOutputStream: 将基本类型的数据以二进制流的形式写出\n\nDataInputStream: 将二进制流读入为基本类型数据\n\nObjectInputStream: 将Java对象以二进制流的形式写出 （序列化使用）\n\nObjectOutputStream: 将二进制流读入为java对象 （序列化时使用）\n\nPipedOutputStream和PipedInputStream分别是管道输出流和管道输入流，让多线程可以通过管道进行线程间的通讯\n\nZipOutputStream和ZipInputStream: 文件压缩与解压缩\n\nPushBackInputStream：回退流\n\n## 字符接口\n\n{% asset_img javaio2.bmp 字符流 %}\n\n在保存数据时，可以选择二进制格式保存或者文本格式保存。比如，整数12234可以存储成二进制，是由00 00 04 D2构成的字节序列。而存储成文本格式，则存储成为字符串“1234”。二进制格式的存储高效且节省空间，但是文本格式的存储方式更适宜人类阅读，应用也很广泛。\n\n与字节接口类似，字符接口族也是采用了装饰者模式的架构。\n\n在存储或读取文本字符串时，可以选择编码。比如：\n\nInputStreamReader reader = new InputStreamReader(new FileInputStream(\"test.dat\"),\"UTF-8\");\n\nreader将使用GBK编码读取文本test.dat的内容。如果构造器没有显示指定编码，将使用主机系统所使用的默认文字编码方式。\n\n与DataOutputStream对应，PrintWriter用来以文本的格式打印字符串和数字。\n\n与DataInputStream对应，可以使用Scanner类来读取文本格式的数据。\n\n## 字符集\n\n字符集规定了某个字符对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个字符（解码）的映射关系。\n\nJavaSE-1.4的java.nio包中引入了类Charset统一了对字符集的转换。\n\n{% asset_img decoder.jpg 字符集 %}\n\n{% asset_img encoder.jpg 字符集 %}\n\n通过观察InputStreamReader的源码（1.7），InputStreamReader 将字符的读取与解码委托给了类StreamDecoder实现。而在StreamDecoder中，又是通过传入的InputStream与指定的Charset配合完成了字节序列的读取和解码工作。\n\n可以通过调用静态的forName方法获取一个Charset：\n```\nCharset charset = Charset.forName(\"UTF-8\");\n```\n其中，传入的参数是某个字符集的官方名或者别名。\n\nSet<String> alias = charset.aliases(); //获取某个Charset的所有可用别名\nMap<String, Charset> charsets = Charset.availableCharsets(); //获取所用可用字符集的名字\n\n有了字符集Charset，就可以通过他将字节序列解码为字符序列或者将字符序列编码为字节序列：\n\n```\n//编码\nString str = \"hello\";\nByteBuffer bb = charset.encode(str);\nbyte[] bytes = bb.array();\n\n//解码\nbyte[] bytes = ....\nByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);\nCharBuffer cb = Charset.decode(bb);\nString str = cb.toString();\n```\n实际上，通过观察源码，得知InputStreamReader也是这么做的（还有String）。\n\n## 文件操作\n\nStream关心的是文件的内容，File类关心的是文件的存储。\n\n关于File的使用，网上有很多介绍，可以参考官网[Class File](https://docs.oracle.com/javase/7/docs/api/java/io/File.html)，不再赘述。\n\n要注意一个类RandomAccessFile，可以在文件的任何位置查找或者写入数据，RandomAccessFile同时实现了DataInput和DataOutput接口。\n\n我们可以使用RandomAccessFile随机读写的特性来完成大文件的上传或者下载。把文件分为n份，开启n个线程同时对这n个部分进行读写操作，提高了读写的效率。（让我想起了ConcurrentHashMap，分段锁的原理）同时，还具有了断点续传的功能。\n","source":"_posts/I-O总结.md","raw":"layout: post\ntitle: java I/O总结\ndate: 2017-03-19 17:09:19\ncategories: 编程\ntags: java io\n---\n> 在平时维护JDBC驱动的过程中，经常会接触到IO相关的代码。总结梳理一下java中的IO~\n\n## IO\n\nIO，即Input和Output。流可以理解为字节序列的流动，可以从其中读入字节序列的对象称为输入流，可以向其中写入字节序列的对象称为输出流。\n这些字节序列的来源和目的地可以是文件，网络，或者内存等。\n\njava中的IO基本可以分为两大类：\n\n1.基于字节操作的 I/O 接口：InputStream 和 OutputStream\n\n2.基于字符操作的 I/O 接口：Writer 和 Reader\n\n不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符。但是我们的程序通常操作的数据都是以字符的形式存在，比如处理网页中的内容或者磁盘文件中的文本。\n为了操作方便，提供了直接操作字符的接口。操作字符的接口底层还是基于字节的，只不过封装了一些例如编码和解码等操作。\n\n下面是java.io包中的内容：[Package java.io](https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html)\n\n{% asset_img io.png java.io %}\n\njava.io 类图:\n\n{% asset_img javaio.png java.io %}\n\n## 字节接口\n\n{% asset_img stream.png 字节流 %}\n\n上图给出了InputStream和OutputStream的继承关系(不仅仅是java.io包)\n\n理解InputStream家族，首先要理解[装饰者模式](http://www.cnblogs.com/god_bless_you/archive/2010/06/10/1755212.html)：\n\n---\n{% asset_img decorator.jpg 装饰者模式 %}\n\n```\nComponent：\n\n定义一个对象接口，可以给这些对象动态地添加职责。\n\npublic interface Component\n{\n\tvoid operation();\n}\n \n\nConcrete Component：\n\n定义一个对象，可以给这个对象添加一些职责。动作的具体实施者。\n\npublic class ConcreteComponent implements Component\n{\n\tpublic void operation()\n\t{\n\t\t// Write your code here\n\t}\n}\n \n\nDecorator：\n\n维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。\n\npublic class Decorator implements Component\n{\n\tpublic Decorator(Component component)\n\t{\n\t\tthis.component = component;\n\t}\n\t\n\tpublic void operation()\n\t{\n\t\tcomponent.operation();\n\t}\n\t\n\tprivate Component component;\n}\n \n\nConcrete Decorator：\n\n在Concrete Component的行为之前或之后，加上自己的行为，以“贴上”附加的职责。\n\npublic class ConcreteDecorator extends Decorator\n{\n\tpublic void operation()\n\t{\n\t\t//addBehavior也可以在前面\n\t\t\n\t\tsuper.operation();\n\t\t\n\t\taddBehavior();\n\t}\n\t\n\tprivate void addBehavior()\n\t{\n\t\t//your code\n\t}\n}\n```\n使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。\n装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。\n\n---\n\nInputStream族与装饰者模式的对应关系：\n\nComponent: InputStream\n\nConcreteComponent: InputStream除FilterINputStream以外的直接子类，如FileInputStream，他们提供了最终的读取字节功能\n\nDecorator: FilterInputStream\n\nConcreteDecorator: FilterINputStream的直接子类，如BufferedInputStream，他们为读取字节附加了一些功能\n\n首先看一下InputStream为我们提供了哪些操作：\n\n```\nint\tavailable()\n返回不阻塞情况下可用的字节数\nvoid close()\n关闭这个输入流\nvoid mark(int readlimit)\n在流的当前位置打一个标记\nboolean\tmarkSupported()\n如果这个流支持打标记，则返回true\nabstract int read()\n从数据中读取一个字节，并返回该字节\nint\tread(byte[] b)\n读入一个字节数组，并返回读入的字节数\nint\tread(byte[] b, int off, int len)\n读入一个字节数组，并返回读入的字节数。b:数据读入的数组  off:第一个读入的字节在b中的偏移量  len:读入字节的最大数量\nvoid reset()\n返回最后的标记，随后对read的调用将重新读入这些字节\nlong skip(long n)\n在输入流中跳过n个字节，返回实际跳过数\n```\n\n其中：\nabstract int read()\nint\tread(byte[] b)\nint\tread(byte[] b, int off, int len)\n\n这三个方法提供了基本的读入功能。read方法在执行时将被阻塞，直到字节确实被读入。InputStream的子类实现或重写了这些方法的具体的操作，来完成对具体对象的读入功能。\n\n通过一个简单的例子来理解InputStream的组合过滤器功能。\n\n我们要从文件中读入数字，则首先必须有一个具体实现读取文件的FileInputStream实例： FileInputStream fin = new FileInputStream(\"test.dat\");\n\n流在默认情况下是不被缓冲区缓存的，也就是说，对于每一次的read的调用都会请求操作系统再分发一个字节。相比之下，一次请求一个数据块将其置于缓冲区显得更加高效。\n因此，我们为流添加缓冲功能，形成缓冲流： BufferedInputStream bin = new BufferedInputStream(fin);\n\ntest.dat文件中存储的是十进制数字的二进制序列。此时我们的流仅仅提供了读取字节序列的功能，为了实现将二进制序列转为十进制数字的功能，我们做进一步转换：\nDataInputStream din = new DataInputStream(bin);\n\n此时我们可以调用 din.readInt()方法依次读取文件中以二进制形式存储的十进制数字了。\n\n注意，我们将DataInputStream置于构造链的最后，这是因为我们最终希望使用DataInputStream的方法来读取十进制数字。\n\n观察一下上面提到的几个类的实现，就会对这种装饰者模式的工作机制有更加深刻的理解。理解了装饰者模式之后，再结合上面的类图，使用IO流就会更加得心应手。\n\n对于OutputStream，实现原理与InputStream是一样的，不再赘述。\n\n记录几个常用的stream：\n\nDataOutputStream: 将基本类型的数据以二进制流的形式写出\n\nDataInputStream: 将二进制流读入为基本类型数据\n\nObjectInputStream: 将Java对象以二进制流的形式写出 （序列化使用）\n\nObjectOutputStream: 将二进制流读入为java对象 （序列化时使用）\n\nPipedOutputStream和PipedInputStream分别是管道输出流和管道输入流，让多线程可以通过管道进行线程间的通讯\n\nZipOutputStream和ZipInputStream: 文件压缩与解压缩\n\nPushBackInputStream：回退流\n\n## 字符接口\n\n{% asset_img javaio2.bmp 字符流 %}\n\n在保存数据时，可以选择二进制格式保存或者文本格式保存。比如，整数12234可以存储成二进制，是由00 00 04 D2构成的字节序列。而存储成文本格式，则存储成为字符串“1234”。二进制格式的存储高效且节省空间，但是文本格式的存储方式更适宜人类阅读，应用也很广泛。\n\n与字节接口类似，字符接口族也是采用了装饰者模式的架构。\n\n在存储或读取文本字符串时，可以选择编码。比如：\n\nInputStreamReader reader = new InputStreamReader(new FileInputStream(\"test.dat\"),\"UTF-8\");\n\nreader将使用GBK编码读取文本test.dat的内容。如果构造器没有显示指定编码，将使用主机系统所使用的默认文字编码方式。\n\n与DataOutputStream对应，PrintWriter用来以文本的格式打印字符串和数字。\n\n与DataInputStream对应，可以使用Scanner类来读取文本格式的数据。\n\n## 字符集\n\n字符集规定了某个字符对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个字符（解码）的映射关系。\n\nJavaSE-1.4的java.nio包中引入了类Charset统一了对字符集的转换。\n\n{% asset_img decoder.jpg 字符集 %}\n\n{% asset_img encoder.jpg 字符集 %}\n\n通过观察InputStreamReader的源码（1.7），InputStreamReader 将字符的读取与解码委托给了类StreamDecoder实现。而在StreamDecoder中，又是通过传入的InputStream与指定的Charset配合完成了字节序列的读取和解码工作。\n\n可以通过调用静态的forName方法获取一个Charset：\n```\nCharset charset = Charset.forName(\"UTF-8\");\n```\n其中，传入的参数是某个字符集的官方名或者别名。\n\nSet<String> alias = charset.aliases(); //获取某个Charset的所有可用别名\nMap<String, Charset> charsets = Charset.availableCharsets(); //获取所用可用字符集的名字\n\n有了字符集Charset，就可以通过他将字节序列解码为字符序列或者将字符序列编码为字节序列：\n\n```\n//编码\nString str = \"hello\";\nByteBuffer bb = charset.encode(str);\nbyte[] bytes = bb.array();\n\n//解码\nbyte[] bytes = ....\nByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);\nCharBuffer cb = Charset.decode(bb);\nString str = cb.toString();\n```\n实际上，通过观察源码，得知InputStreamReader也是这么做的（还有String）。\n\n## 文件操作\n\nStream关心的是文件的内容，File类关心的是文件的存储。\n\n关于File的使用，网上有很多介绍，可以参考官网[Class File](https://docs.oracle.com/javase/7/docs/api/java/io/File.html)，不再赘述。\n\n要注意一个类RandomAccessFile，可以在文件的任何位置查找或者写入数据，RandomAccessFile同时实现了DataInput和DataOutput接口。\n\n我们可以使用RandomAccessFile随机读写的特性来完成大文件的上传或者下载。把文件分为n份，开启n个线程同时对这n个部分进行读写操作，提高了读写的效率。（让我想起了ConcurrentHashMap，分段锁的原理）同时，还具有了断点续传的功能。\n","slug":"I-O总结","published":1,"updated":"2017-03-29T06:06:29.989Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlpg0005vegc5x3zlm3t","content":"<blockquote>\n<p>在平时维护JDBC驱动的过程中，经常会接触到IO相关的代码。总结梳理一下java中的IO~</p>\n</blockquote>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><p>IO，即Input和Output。流可以理解为字节序列的流动，可以从其中读入字节序列的对象称为输入流，可以向其中写入字节序列的对象称为输出流。<br>这些字节序列的来源和目的地可以是文件，网络，或者内存等。</p>\n<p>java中的IO基本可以分为两大类：</p>\n<p>1.基于字节操作的 I/O 接口：InputStream 和 OutputStream</p>\n<p>2.基于字符操作的 I/O 接口：Writer 和 Reader</p>\n<p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符。但是我们的程序通常操作的数据都是以字符的形式存在，比如处理网页中的内容或者磁盘文件中的文本。<br>为了操作方便，提供了直接操作字符的接口。操作字符的接口底层还是基于字节的，只不过封装了一些例如编码和解码等操作。</p>\n<p>下面是java.io包中的内容：<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html\" target=\"_blank\" rel=\"external\">Package java.io</a></p>\n<img src=\"/2017/03/19/I-O总结/io.png\" alt=\"java.io\" title=\"java.io\">\n<p>java.io 类图:</p>\n<img src=\"/2017/03/19/I-O总结/javaio.png\" alt=\"java.io\" title=\"java.io\">\n<h2 id=\"字节接口\"><a href=\"#字节接口\" class=\"headerlink\" title=\"字节接口\"></a>字节接口</h2><img src=\"/2017/03/19/I-O总结/stream.png\" alt=\"字节流\" title=\"字节流\">\n<p>上图给出了InputStream和OutputStream的继承关系(不仅仅是java.io包)</p>\n<p>理解InputStream家族，首先要理解<a href=\"http://www.cnblogs.com/god_bless_you/archive/2010/06/10/1755212.html\" target=\"_blank\" rel=\"external\">装饰者模式</a>：</p>\n<hr>\n<img src=\"/2017/03/19/I-O总结/decorator.jpg\" alt=\"装饰者模式\" title=\"装饰者模式\">\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">Component：</div><div class=\"line\"></div><div class=\"line\">定义一个对象接口，可以给这些对象动态地添加职责。</div><div class=\"line\"></div><div class=\"line\">public interface Component</div><div class=\"line\">&#123;</div><div class=\"line\">\tvoid operation();</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">Concrete Component：</div><div class=\"line\"></div><div class=\"line\">定义一个对象，可以给这个对象添加一些职责。动作的具体实施者。</div><div class=\"line\"></div><div class=\"line\">public class ConcreteComponent implements Component</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic void operation()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t// Write your code here</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">Decorator：</div><div class=\"line\"></div><div class=\"line\">维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。</div><div class=\"line\"></div><div class=\"line\">public class Decorator implements Component</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic Decorator(Component component)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tthis.component = component;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic void operation()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tcomponent.operation();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tprivate Component component;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">Concrete Decorator：</div><div class=\"line\"></div><div class=\"line\">在Concrete Component的行为之前或之后，加上自己的行为，以“贴上”附加的职责。</div><div class=\"line\"></div><div class=\"line\">public class ConcreteDecorator extends Decorator</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic void operation()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t//addBehavior也可以在前面</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsuper.operation();</div><div class=\"line\">\t\t</div><div class=\"line\">\t\taddBehavior();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tprivate void addBehavior()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t//your code</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。<br>装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</p>\n<hr>\n<p>InputStream族与装饰者模式的对应关系：</p>\n<p>Component: InputStream</p>\n<p>ConcreteComponent: InputStream除FilterINputStream以外的直接子类，如FileInputStream，他们提供了最终的读取字节功能</p>\n<p>Decorator: FilterInputStream</p>\n<p>ConcreteDecorator: FilterINputStream的直接子类，如BufferedInputStream，他们为读取字节附加了一些功能</p>\n<p>首先看一下InputStream为我们提供了哪些操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">int\tavailable()</div><div class=\"line\">返回不阻塞情况下可用的字节数</div><div class=\"line\">void close()</div><div class=\"line\">关闭这个输入流</div><div class=\"line\">void mark(int readlimit)</div><div class=\"line\">在流的当前位置打一个标记</div><div class=\"line\">boolean\tmarkSupported()</div><div class=\"line\">如果这个流支持打标记，则返回true</div><div class=\"line\">abstract int read()</div><div class=\"line\">从数据中读取一个字节，并返回该字节</div><div class=\"line\">int\tread(byte[] b)</div><div class=\"line\">读入一个字节数组，并返回读入的字节数</div><div class=\"line\">int\tread(byte[] b, int off, int len)</div><div class=\"line\">读入一个字节数组，并返回读入的字节数。b:数据读入的数组  off:第一个读入的字节在b中的偏移量  len:读入字节的最大数量</div><div class=\"line\">void reset()</div><div class=\"line\">返回最后的标记，随后对read的调用将重新读入这些字节</div><div class=\"line\">long skip(long n)</div><div class=\"line\">在输入流中跳过n个字节，返回实际跳过数</div></pre></td></tr></table></figure>\n<p>其中：<br>abstract int read()<br>int    read(byte[] b)<br>int    read(byte[] b, int off, int len)</p>\n<p>这三个方法提供了基本的读入功能。read方法在执行时将被阻塞，直到字节确实被读入。InputStream的子类实现或重写了这些方法的具体的操作，来完成对具体对象的读入功能。</p>\n<p>通过一个简单的例子来理解InputStream的组合过滤器功能。</p>\n<p>我们要从文件中读入数字，则首先必须有一个具体实现读取文件的FileInputStream实例： FileInputStream fin = new FileInputStream(“test.dat”);</p>\n<p>流在默认情况下是不被缓冲区缓存的，也就是说，对于每一次的read的调用都会请求操作系统再分发一个字节。相比之下，一次请求一个数据块将其置于缓冲区显得更加高效。<br>因此，我们为流添加缓冲功能，形成缓冲流： BufferedInputStream bin = new BufferedInputStream(fin);</p>\n<p>test.dat文件中存储的是十进制数字的二进制序列。此时我们的流仅仅提供了读取字节序列的功能，为了实现将二进制序列转为十进制数字的功能，我们做进一步转换：<br>DataInputStream din = new DataInputStream(bin);</p>\n<p>此时我们可以调用 din.readInt()方法依次读取文件中以二进制形式存储的十进制数字了。</p>\n<p>注意，我们将DataInputStream置于构造链的最后，这是因为我们最终希望使用DataInputStream的方法来读取十进制数字。</p>\n<p>观察一下上面提到的几个类的实现，就会对这种装饰者模式的工作机制有更加深刻的理解。理解了装饰者模式之后，再结合上面的类图，使用IO流就会更加得心应手。</p>\n<p>对于OutputStream，实现原理与InputStream是一样的，不再赘述。</p>\n<p>记录几个常用的stream：</p>\n<p>DataOutputStream: 将基本类型的数据以二进制流的形式写出</p>\n<p>DataInputStream: 将二进制流读入为基本类型数据</p>\n<p>ObjectInputStream: 将Java对象以二进制流的形式写出 （序列化使用）</p>\n<p>ObjectOutputStream: 将二进制流读入为java对象 （序列化时使用）</p>\n<p>PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流，让多线程可以通过管道进行线程间的通讯</p>\n<p>ZipOutputStream和ZipInputStream: 文件压缩与解压缩</p>\n<p>PushBackInputStream：回退流</p>\n<h2 id=\"字符接口\"><a href=\"#字符接口\" class=\"headerlink\" title=\"字符接口\"></a>字符接口</h2><img src=\"/2017/03/19/I-O总结/javaio2.bmp\" alt=\"字符流\" title=\"字符流\">\n<p>在保存数据时，可以选择二进制格式保存或者文本格式保存。比如，整数12234可以存储成二进制，是由00 00 04 D2构成的字节序列。而存储成文本格式，则存储成为字符串“1234”。二进制格式的存储高效且节省空间，但是文本格式的存储方式更适宜人类阅读，应用也很广泛。</p>\n<p>与字节接口类似，字符接口族也是采用了装饰者模式的架构。</p>\n<p>在存储或读取文本字符串时，可以选择编码。比如：</p>\n<p>InputStreamReader reader = new InputStreamReader(new FileInputStream(“test.dat”),”UTF-8”);</p>\n<p>reader将使用GBK编码读取文本test.dat的内容。如果构造器没有显示指定编码，将使用主机系统所使用的默认文字编码方式。</p>\n<p>与DataOutputStream对应，PrintWriter用来以文本的格式打印字符串和数字。</p>\n<p>与DataInputStream对应，可以使用Scanner类来读取文本格式的数据。</p>\n<h2 id=\"字符集\"><a href=\"#字符集\" class=\"headerlink\" title=\"字符集\"></a>字符集</h2><p>字符集规定了某个字符对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个字符（解码）的映射关系。</p>\n<p>JavaSE-1.4的java.nio包中引入了类Charset统一了对字符集的转换。</p>\n<img src=\"/2017/03/19/I-O总结/decoder.jpg\" alt=\"字符集\" title=\"字符集\">\n<img src=\"/2017/03/19/I-O总结/encoder.jpg\" alt=\"字符集\" title=\"字符集\">\n<p>通过观察InputStreamReader的源码（1.7），InputStreamReader 将字符的读取与解码委托给了类StreamDecoder实现。而在StreamDecoder中，又是通过传入的InputStream与指定的Charset配合完成了字节序列的读取和解码工作。</p>\n<p>可以通过调用静态的forName方法获取一个Charset：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(&quot;UTF-8&quot;);</div></pre></td></tr></table></figure></p>\n<p>其中，传入的参数是某个字符集的官方名或者别名。</p>\n<p>Set<string> alias = charset.aliases(); //获取某个Charset的所有可用别名<br>Map<string, charset=\"\"> charsets = Charset.availableCharsets(); //获取所用可用字符集的名字</string,></string></p>\n<p>有了字符集Charset，就可以通过他将字节序列解码为字符序列或者将字符序列编码为字节序列：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//编码</div><div class=\"line\">String str = &quot;hello&quot;;</div><div class=\"line\">ByteBuffer bb = charset.encode(str);</div><div class=\"line\">byte[] bytes = bb.array();</div><div class=\"line\"></div><div class=\"line\">//解码</div><div class=\"line\">byte[] bytes = ....</div><div class=\"line\">ByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);</div><div class=\"line\">CharBuffer cb = Charset.decode(bb);</div><div class=\"line\">String str = cb.toString();</div></pre></td></tr></table></figure>\n<p>实际上，通过观察源码，得知InputStreamReader也是这么做的（还有String）。</p>\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><p>Stream关心的是文件的内容，File类关心的是文件的存储。</p>\n<p>关于File的使用，网上有很多介绍，可以参考官网<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/File.html\" target=\"_blank\" rel=\"external\">Class File</a>，不再赘述。</p>\n<p>要注意一个类RandomAccessFile，可以在文件的任何位置查找或者写入数据，RandomAccessFile同时实现了DataInput和DataOutput接口。</p>\n<p>我们可以使用RandomAccessFile随机读写的特性来完成大文件的上传或者下载。把文件分为n份，开启n个线程同时对这n个部分进行读写操作，提高了读写的效率。（让我想起了ConcurrentHashMap，分段锁的原理）同时，还具有了断点续传的功能。</p>\n","excerpt":"","more":"<blockquote>\n<p>在平时维护JDBC驱动的过程中，经常会接触到IO相关的代码。总结梳理一下java中的IO~</p>\n</blockquote>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><p>IO，即Input和Output。流可以理解为字节序列的流动，可以从其中读入字节序列的对象称为输入流，可以向其中写入字节序列的对象称为输出流。<br>这些字节序列的来源和目的地可以是文件，网络，或者内存等。</p>\n<p>java中的IO基本可以分为两大类：</p>\n<p>1.基于字节操作的 I/O 接口：InputStream 和 OutputStream</p>\n<p>2.基于字符操作的 I/O 接口：Writer 和 Reader</p>\n<p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符。但是我们的程序通常操作的数据都是以字符的形式存在，比如处理网页中的内容或者磁盘文件中的文本。<br>为了操作方便，提供了直接操作字符的接口。操作字符的接口底层还是基于字节的，只不过封装了一些例如编码和解码等操作。</p>\n<p>下面是java.io包中的内容：<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html\">Package java.io</a></p>\n<img src=\"/2017/03/19/I-O总结/io.png\" alt=\"java.io\" title=\"java.io\">\n<p>java.io 类图:</p>\n<img src=\"/2017/03/19/I-O总结/javaio.png\" alt=\"java.io\" title=\"java.io\">\n<h2 id=\"字节接口\"><a href=\"#字节接口\" class=\"headerlink\" title=\"字节接口\"></a>字节接口</h2><img src=\"/2017/03/19/I-O总结/stream.png\" alt=\"字节流\" title=\"字节流\">\n<p>上图给出了InputStream和OutputStream的继承关系(不仅仅是java.io包)</p>\n<p>理解InputStream家族，首先要理解<a href=\"http://www.cnblogs.com/god_bless_you/archive/2010/06/10/1755212.html\">装饰者模式</a>：</p>\n<hr>\n<img src=\"/2017/03/19/I-O总结/decorator.jpg\" alt=\"装饰者模式\" title=\"装饰者模式\">\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">Component：</div><div class=\"line\"></div><div class=\"line\">定义一个对象接口，可以给这些对象动态地添加职责。</div><div class=\"line\"></div><div class=\"line\">public interface Component</div><div class=\"line\">&#123;</div><div class=\"line\">\tvoid operation();</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">Concrete Component：</div><div class=\"line\"></div><div class=\"line\">定义一个对象，可以给这个对象添加一些职责。动作的具体实施者。</div><div class=\"line\"></div><div class=\"line\">public class ConcreteComponent implements Component</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic void operation()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t// Write your code here</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">Decorator：</div><div class=\"line\"></div><div class=\"line\">维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。</div><div class=\"line\"></div><div class=\"line\">public class Decorator implements Component</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic Decorator(Component component)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tthis.component = component;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic void operation()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tcomponent.operation();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tprivate Component component;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">Concrete Decorator：</div><div class=\"line\"></div><div class=\"line\">在Concrete Component的行为之前或之后，加上自己的行为，以“贴上”附加的职责。</div><div class=\"line\"></div><div class=\"line\">public class ConcreteDecorator extends Decorator</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic void operation()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t//addBehavior也可以在前面</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsuper.operation();</div><div class=\"line\">\t\t</div><div class=\"line\">\t\taddBehavior();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tprivate void addBehavior()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t//your code</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。<br>装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</p>\n<hr>\n<p>InputStream族与装饰者模式的对应关系：</p>\n<p>Component: InputStream</p>\n<p>ConcreteComponent: InputStream除FilterINputStream以外的直接子类，如FileInputStream，他们提供了最终的读取字节功能</p>\n<p>Decorator: FilterInputStream</p>\n<p>ConcreteDecorator: FilterINputStream的直接子类，如BufferedInputStream，他们为读取字节附加了一些功能</p>\n<p>首先看一下InputStream为我们提供了哪些操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">int\tavailable()</div><div class=\"line\">返回不阻塞情况下可用的字节数</div><div class=\"line\">void close()</div><div class=\"line\">关闭这个输入流</div><div class=\"line\">void mark(int readlimit)</div><div class=\"line\">在流的当前位置打一个标记</div><div class=\"line\">boolean\tmarkSupported()</div><div class=\"line\">如果这个流支持打标记，则返回true</div><div class=\"line\">abstract int read()</div><div class=\"line\">从数据中读取一个字节，并返回该字节</div><div class=\"line\">int\tread(byte[] b)</div><div class=\"line\">读入一个字节数组，并返回读入的字节数</div><div class=\"line\">int\tread(byte[] b, int off, int len)</div><div class=\"line\">读入一个字节数组，并返回读入的字节数。b:数据读入的数组  off:第一个读入的字节在b中的偏移量  len:读入字节的最大数量</div><div class=\"line\">void reset()</div><div class=\"line\">返回最后的标记，随后对read的调用将重新读入这些字节</div><div class=\"line\">long skip(long n)</div><div class=\"line\">在输入流中跳过n个字节，返回实际跳过数</div></pre></td></tr></table></figure>\n<p>其中：<br>abstract int read()<br>int    read(byte[] b)<br>int    read(byte[] b, int off, int len)</p>\n<p>这三个方法提供了基本的读入功能。read方法在执行时将被阻塞，直到字节确实被读入。InputStream的子类实现或重写了这些方法的具体的操作，来完成对具体对象的读入功能。</p>\n<p>通过一个简单的例子来理解InputStream的组合过滤器功能。</p>\n<p>我们要从文件中读入数字，则首先必须有一个具体实现读取文件的FileInputStream实例： FileInputStream fin = new FileInputStream(“test.dat”);</p>\n<p>流在默认情况下是不被缓冲区缓存的，也就是说，对于每一次的read的调用都会请求操作系统再分发一个字节。相比之下，一次请求一个数据块将其置于缓冲区显得更加高效。<br>因此，我们为流添加缓冲功能，形成缓冲流： BufferedInputStream bin = new BufferedInputStream(fin);</p>\n<p>test.dat文件中存储的是十进制数字的二进制序列。此时我们的流仅仅提供了读取字节序列的功能，为了实现将二进制序列转为十进制数字的功能，我们做进一步转换：<br>DataInputStream din = new DataInputStream(bin);</p>\n<p>此时我们可以调用 din.readInt()方法依次读取文件中以二进制形式存储的十进制数字了。</p>\n<p>注意，我们将DataInputStream置于构造链的最后，这是因为我们最终希望使用DataInputStream的方法来读取十进制数字。</p>\n<p>观察一下上面提到的几个类的实现，就会对这种装饰者模式的工作机制有更加深刻的理解。理解了装饰者模式之后，再结合上面的类图，使用IO流就会更加得心应手。</p>\n<p>对于OutputStream，实现原理与InputStream是一样的，不再赘述。</p>\n<p>记录几个常用的stream：</p>\n<p>DataOutputStream: 将基本类型的数据以二进制流的形式写出</p>\n<p>DataInputStream: 将二进制流读入为基本类型数据</p>\n<p>ObjectInputStream: 将Java对象以二进制流的形式写出 （序列化使用）</p>\n<p>ObjectOutputStream: 将二进制流读入为java对象 （序列化时使用）</p>\n<p>PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流，让多线程可以通过管道进行线程间的通讯</p>\n<p>ZipOutputStream和ZipInputStream: 文件压缩与解压缩</p>\n<p>PushBackInputStream：回退流</p>\n<h2 id=\"字符接口\"><a href=\"#字符接口\" class=\"headerlink\" title=\"字符接口\"></a>字符接口</h2><img src=\"/2017/03/19/I-O总结/javaio2.bmp\" alt=\"字符流\" title=\"字符流\">\n<p>在保存数据时，可以选择二进制格式保存或者文本格式保存。比如，整数12234可以存储成二进制，是由00 00 04 D2构成的字节序列。而存储成文本格式，则存储成为字符串“1234”。二进制格式的存储高效且节省空间，但是文本格式的存储方式更适宜人类阅读，应用也很广泛。</p>\n<p>与字节接口类似，字符接口族也是采用了装饰者模式的架构。</p>\n<p>在存储或读取文本字符串时，可以选择编码。比如：</p>\n<p>InputStreamReader reader = new InputStreamReader(new FileInputStream(“test.dat”),”UTF-8”);</p>\n<p>reader将使用GBK编码读取文本test.dat的内容。如果构造器没有显示指定编码，将使用主机系统所使用的默认文字编码方式。</p>\n<p>与DataOutputStream对应，PrintWriter用来以文本的格式打印字符串和数字。</p>\n<p>与DataInputStream对应，可以使用Scanner类来读取文本格式的数据。</p>\n<h2 id=\"字符集\"><a href=\"#字符集\" class=\"headerlink\" title=\"字符集\"></a>字符集</h2><p>字符集规定了某个字符对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个字符（解码）的映射关系。</p>\n<p>JavaSE-1.4的java.nio包中引入了类Charset统一了对字符集的转换。</p>\n<img src=\"/2017/03/19/I-O总结/decoder.jpg\" alt=\"字符集\" title=\"字符集\">\n<img src=\"/2017/03/19/I-O总结/encoder.jpg\" alt=\"字符集\" title=\"字符集\">\n<p>通过观察InputStreamReader的源码（1.7），InputStreamReader 将字符的读取与解码委托给了类StreamDecoder实现。而在StreamDecoder中，又是通过传入的InputStream与指定的Charset配合完成了字节序列的读取和解码工作。</p>\n<p>可以通过调用静态的forName方法获取一个Charset：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(&quot;UTF-8&quot;);</div></pre></td></tr></table></figure></p>\n<p>其中，传入的参数是某个字符集的官方名或者别名。</p>\n<p>Set<String> alias = charset.aliases(); //获取某个Charset的所有可用别名<br>Map<String, Charset> charsets = Charset.availableCharsets(); //获取所用可用字符集的名字</p>\n<p>有了字符集Charset，就可以通过他将字节序列解码为字符序列或者将字符序列编码为字节序列：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//编码</div><div class=\"line\">String str = &quot;hello&quot;;</div><div class=\"line\">ByteBuffer bb = charset.encode(str);</div><div class=\"line\">byte[] bytes = bb.array();</div><div class=\"line\"></div><div class=\"line\">//解码</div><div class=\"line\">byte[] bytes = ....</div><div class=\"line\">ByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);</div><div class=\"line\">CharBuffer cb = Charset.decode(bb);</div><div class=\"line\">String str = cb.toString();</div></pre></td></tr></table></figure>\n<p>实际上，通过观察源码，得知InputStreamReader也是这么做的（还有String）。</p>\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><p>Stream关心的是文件的内容，File类关心的是文件的存储。</p>\n<p>关于File的使用，网上有很多介绍，可以参考官网<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/File.html\">Class File</a>，不再赘述。</p>\n<p>要注意一个类RandomAccessFile，可以在文件的任何位置查找或者写入数据，RandomAccessFile同时实现了DataInput和DataOutput接口。</p>\n<p>我们可以使用RandomAccessFile随机读写的特性来完成大文件的上传或者下载。把文件分为n份，开启n个线程同时对这n个部分进行读写操作，提高了读写的效率。（让我想起了ConcurrentHashMap，分段锁的原理）同时，还具有了断点续传的功能。</p>\n"},{"layout":"post","title":"Java集合框架学习总结","date":"2016-08-16T14:50:16.000Z","_content":"\n看Jdk的源码有大概一个月时间了，中间零零散散算是把[Java的集合](https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html)看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：[Java IO](https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description)\n\n## 框架\n\n{% asset_img collection.png 集合框架 %}\n\n上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。\n\n通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。\n\n## List\n\n### Iterator\n\n在总结List之前，先看一下Iterable这个接口,它只包含一个方法:\n\n```java\nIterator<T> iterator();\n```\n\n这个方法返回一个[Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。\n\n### [Collection](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)\n\nCollection 提供了集合的一些基本操作,Collection 接口提供的主要方法：\n\n```\nboolean add(Object o) 添加对象到集合；\nboolean remove(Object o) 删除指定的对象；\nint size() 返回当前集合中元素的数量；\nboolean contains(Object o) 查找集合中是否有指定的对象；\nboolean isEmpty() 判断集合是否为空；\nIterator iterator() 返回一个迭代器；\nboolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；\nboolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；\nvoid clear() 删除集合中所有元素；\nvoid removeAll(Collection c) 从集合中删除 C 集合中也有的元素；\nvoid retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。\n```\n没发现有什么好说的。\n\n### [List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)\n\nList\n\n\n\n","source":"_posts/Java集合框架学习总结.md","raw":"layout: post\ntitle: Java集合框架学习总结\ndate: 2016-08-16 22:50:16\ncategories: 编程 \ntags: \n- java\n- 源码\n---\n\n看Jdk的源码有大概一个月时间了，中间零零散散算是把[Java的集合](https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html)看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：[Java IO](https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description)\n\n## 框架\n\n{% asset_img collection.png 集合框架 %}\n\n上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。\n\n通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。\n\n## List\n\n### Iterator\n\n在总结List之前，先看一下Iterable这个接口,它只包含一个方法:\n\n```java\nIterator<T> iterator();\n```\n\n这个方法返回一个[Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。\n\n### [Collection](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)\n\nCollection 提供了集合的一些基本操作,Collection 接口提供的主要方法：\n\n```\nboolean add(Object o) 添加对象到集合；\nboolean remove(Object o) 删除指定的对象；\nint size() 返回当前集合中元素的数量；\nboolean contains(Object o) 查找集合中是否有指定的对象；\nboolean isEmpty() 判断集合是否为空；\nIterator iterator() 返回一个迭代器；\nboolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；\nboolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；\nvoid clear() 删除集合中所有元素；\nvoid removeAll(Collection c) 从集合中删除 C 集合中也有的元素；\nvoid retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。\n```\n没发现有什么好说的。\n\n### [List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)\n\nList\n\n\n\n","slug":"Java集合框架学习总结","published":1,"updated":"2017-02-19T13:08:11.031Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlpm0006vegcxzcgch5j","content":"<p>看Jdk的源码有大概一个月时间了，中间零零散散算是把<a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html\" target=\"_blank\" rel=\"external\">Java的集合</a>看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description\" target=\"_blank\" rel=\"external\">Java IO</a></p>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><img src=\"/2016/08/16/Java集合框架学习总结/collection.png\" alt=\"集合框架\" title=\"集合框架\">\n<p>上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。</p>\n<p>通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。</p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h3><p>在总结List之前，先看一下Iterable这个接口,它只包含一个方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Iterator&lt;T&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</div></pre></td></tr></table></figure>\n<p>这个方法返回一个<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\" target=\"_blank\" rel=\"external\">Iterator</a>，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。</p>\n<h3 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html\" target=\"_blank\" rel=\"external\">Collection</a></h3><p>Collection 提供了集合的一些基本操作,Collection 接口提供的主要方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean add(Object o) 添加对象到集合；</div><div class=\"line\">boolean remove(Object o) 删除指定的对象；</div><div class=\"line\">int size() 返回当前集合中元素的数量；</div><div class=\"line\">boolean contains(Object o) 查找集合中是否有指定的对象；</div><div class=\"line\">boolean isEmpty() 判断集合是否为空；</div><div class=\"line\">Iterator iterator() 返回一个迭代器；</div><div class=\"line\">boolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；</div><div class=\"line\">boolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；</div><div class=\"line\">void clear() 删除集合中所有元素；</div><div class=\"line\">void removeAll(Collection c) 从集合中删除 C 集合中也有的元素；</div><div class=\"line\">void retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。</div></pre></td></tr></table></figure>\n<p>没发现有什么好说的。</p>\n<h3 id=\"List-1\"><a href=\"#List-1\" class=\"headerlink\" title=\"List\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/List.html\" target=\"_blank\" rel=\"external\">List</a></h3><p>List</p>\n","excerpt":"","more":"<p>看Jdk的源码有大概一个月时间了，中间零零散散算是把<a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html\">Java的集合</a>看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description\">Java IO</a></p>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><img src=\"/2016/08/16/Java集合框架学习总结/collection.png\" alt=\"集合框架\" title=\"集合框架\">\n<p>上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。</p>\n<p>通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。</p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h3><p>在总结List之前，先看一下Iterable这个接口,它只包含一个方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Iterator&lt;T&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</div></pre></td></tr></table></figure>\n<p>这个方法返回一个<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\">Iterator</a>，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。</p>\n<h3 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html\">Collection</a></h3><p>Collection 提供了集合的一些基本操作,Collection 接口提供的主要方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean add(Object o) 添加对象到集合；</div><div class=\"line\">boolean remove(Object o) 删除指定的对象；</div><div class=\"line\">int size() 返回当前集合中元素的数量；</div><div class=\"line\">boolean contains(Object o) 查找集合中是否有指定的对象；</div><div class=\"line\">boolean isEmpty() 判断集合是否为空；</div><div class=\"line\">Iterator iterator() 返回一个迭代器；</div><div class=\"line\">boolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；</div><div class=\"line\">boolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；</div><div class=\"line\">void clear() 删除集合中所有元素；</div><div class=\"line\">void removeAll(Collection c) 从集合中删除 C 集合中也有的元素；</div><div class=\"line\">void retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。</div></pre></td></tr></table></figure>\n<p>没发现有什么好说的。</p>\n<h3 id=\"List-1\"><a href=\"#List-1\" class=\"headerlink\" title=\"List\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/List.html\">List</a></h3><p>List</p>\n"},{"layout":"post","title":"Linux的五个查找命令","date":"2017-02-26T01:17:33.000Z","_content":"> 最近一直在读[阮一峰老师的博客](http://www.ruanyifeng.com),今天读到一篇介绍Linux查找命令的文章。恰好最近在学习linux，所以转载过来，当作一篇备忘录。\n\n> 原文链接：[Linux的五个查找命令](http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html)\n\n使用电脑的时候，经常需要查找文件。\n\n在Linux中，有很多方法可以做到这一点。国外网站LinuxHaxor总结了五条命令，你可以看看自己知道几条。大多数程序员，可能经常使用其中的2到3条，对这5条命令都很熟悉的人应该是不多的。\n\n## find \n\nfind是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。\n\nfind的使用格式如下：\n```\n　　$ find <指定目录> <指定条件> <指定动作>\n　　- <指定目录>： 所要搜索的目录及其所有子目录。默认为当前目录。\n　　- <指定条件>： 所要搜索的文件的特征。\n　　- <指定动作>： 对搜索结果进行特定的处理。\n```\n如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。\n\nfind的使用实例：\n```\n　　$ find . -name 'my*'\n搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。\n　　$ find . -name 'my*' -ls\n搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。\n　　$ find . -type f -mmin -10\n搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。\n```\n\n## locate\n\nlocate命令其实是\"find -name\"的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。\n\nlocate命令的使用实例：\n```\n　　$ locate /etc/sh\n搜索etc目录下所有以sh开头的文件。\n　　$ locate ~/m\n搜索用户主目录下，所有以m开头的文件。\n　　$ locate -i ~/m\n搜索用户主目录下，所有以m开头的文件，并且忽略大小写。\n```\n\n## whereis\n\nwhereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。\n\nwhereis命令的使用实例：\n```\n　　$ whereis grep\n```\n\n## which\n\nwhich命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n\nwhich命令的使用实例：\n```\n　　$ which grep\n```\n\n## type\n\ntype命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。\n\ntype命令的使用实例：\n```\n　　$ type cd\n系统会提示，cd是shell的自带命令（build-in）。\n　　$ type grep\n系统会提示，grep是一个外部命令，并显示该命令的路径。\n　　$ type -p grep\n加上-p参数后，就相当于which命令。\n```","source":"_posts/Linux的五个查找命令.md","raw":"---\nlayout: post\ntitle: Linux的五个查找命令\ndate: 2017-02-26 09:17:33\ncategories: 工具\ntags: linux\n---\n> 最近一直在读[阮一峰老师的博客](http://www.ruanyifeng.com),今天读到一篇介绍Linux查找命令的文章。恰好最近在学习linux，所以转载过来，当作一篇备忘录。\n\n> 原文链接：[Linux的五个查找命令](http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html)\n\n使用电脑的时候，经常需要查找文件。\n\n在Linux中，有很多方法可以做到这一点。国外网站LinuxHaxor总结了五条命令，你可以看看自己知道几条。大多数程序员，可能经常使用其中的2到3条，对这5条命令都很熟悉的人应该是不多的。\n\n## find \n\nfind是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。\n\nfind的使用格式如下：\n```\n　　$ find <指定目录> <指定条件> <指定动作>\n　　- <指定目录>： 所要搜索的目录及其所有子目录。默认为当前目录。\n　　- <指定条件>： 所要搜索的文件的特征。\n　　- <指定动作>： 对搜索结果进行特定的处理。\n```\n如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。\n\nfind的使用实例：\n```\n　　$ find . -name 'my*'\n搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。\n　　$ find . -name 'my*' -ls\n搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。\n　　$ find . -type f -mmin -10\n搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。\n```\n\n## locate\n\nlocate命令其实是\"find -name\"的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。\n\nlocate命令的使用实例：\n```\n　　$ locate /etc/sh\n搜索etc目录下所有以sh开头的文件。\n　　$ locate ~/m\n搜索用户主目录下，所有以m开头的文件。\n　　$ locate -i ~/m\n搜索用户主目录下，所有以m开头的文件，并且忽略大小写。\n```\n\n## whereis\n\nwhereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。\n\nwhereis命令的使用实例：\n```\n　　$ whereis grep\n```\n\n## which\n\nwhich命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n\nwhich命令的使用实例：\n```\n　　$ which grep\n```\n\n## type\n\ntype命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。\n\ntype命令的使用实例：\n```\n　　$ type cd\n系统会提示，cd是shell的自带命令（build-in）。\n　　$ type grep\n系统会提示，grep是一个外部命令，并显示该命令的路径。\n　　$ type -p grep\n加上-p参数后，就相当于which命令。\n```","slug":"Linux的五个查找命令","published":1,"updated":"2017-02-26T01:26:01.000Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlpt0008vegcbeox4myi","content":"<blockquote>\n<p>最近一直在读<a href=\"http://www.ruanyifeng.com\" target=\"_blank\" rel=\"external\">阮一峰老师的博客</a>,今天读到一篇介绍Linux查找命令的文章。恰好最近在学习linux，所以转载过来，当作一篇备忘录。</p>\n<p>原文链接：<a href=\"http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html\" target=\"_blank\" rel=\"external\">Linux的五个查找命令</a></p>\n</blockquote>\n<p>使用电脑的时候，经常需要查找文件。</p>\n<p>在Linux中，有很多方法可以做到这一点。国外网站LinuxHaxor总结了五条命令，你可以看看自己知道几条。大多数程序员，可能经常使用其中的2到3条，对这5条命令都很熟悉的人应该是不多的。</p>\n<h2 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h2><p>find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。</p>\n<p>find的使用格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</div><div class=\"line\">　　- &lt;指定目录&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。</div><div class=\"line\">　　- &lt;指定条件&gt;： 所要搜索的文件的特征。</div><div class=\"line\">　　- &lt;指定动作&gt;： 对搜索结果进行特定的处理。</div></pre></td></tr></table></figure></p>\n<p>如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p>\n<p>find的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ find . -name &apos;my*&apos;</div><div class=\"line\">搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。</div><div class=\"line\">　　$ find . -name &apos;my*&apos; -ls</div><div class=\"line\">搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。</div><div class=\"line\">　　$ find . -type f -mmin -10</div><div class=\"line\">搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。</div></pre></td></tr></table></figure></p>\n<h2 id=\"locate\"><a href=\"#locate\" class=\"headerlink\" title=\"locate\"></a>locate</h2><p>locate命令其实是”find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</p>\n<p>locate命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ locate /etc/sh</div><div class=\"line\">搜索etc目录下所有以sh开头的文件。</div><div class=\"line\">　　$ locate ~/m</div><div class=\"line\">搜索用户主目录下，所有以m开头的文件。</div><div class=\"line\">　　$ locate -i ~/m</div><div class=\"line\">搜索用户主目录下，所有以m开头的文件，并且忽略大小写。</div></pre></td></tr></table></figure></p>\n<h2 id=\"whereis\"><a href=\"#whereis\" class=\"headerlink\" title=\"whereis\"></a>whereis</h2><p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>\n<p>whereis命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ whereis grep</div></pre></td></tr></table></figure></p>\n<h2 id=\"which\"><a href=\"#which\" class=\"headerlink\" title=\"which\"></a>which</h2><p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>\n<p>which命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ which grep</div></pre></td></tr></table></figure></p>\n<h2 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h2><p>type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。</p>\n<p>type命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ type cd</div><div class=\"line\">系统会提示，cd是shell的自带命令（build-in）。</div><div class=\"line\">　　$ type grep</div><div class=\"line\">系统会提示，grep是一个外部命令，并显示该命令的路径。</div><div class=\"line\">　　$ type -p grep</div><div class=\"line\">加上-p参数后，就相当于which命令。</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<blockquote>\n<p>最近一直在读<a href=\"http://www.ruanyifeng.com\">阮一峰老师的博客</a>,今天读到一篇介绍Linux查找命令的文章。恰好最近在学习linux，所以转载过来，当作一篇备忘录。</p>\n<p>原文链接：<a href=\"http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html\">Linux的五个查找命令</a></p>\n</blockquote>\n<p>使用电脑的时候，经常需要查找文件。</p>\n<p>在Linux中，有很多方法可以做到这一点。国外网站LinuxHaxor总结了五条命令，你可以看看自己知道几条。大多数程序员，可能经常使用其中的2到3条，对这5条命令都很熟悉的人应该是不多的。</p>\n<h2 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h2><p>find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。</p>\n<p>find的使用格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</div><div class=\"line\">　　- &lt;指定目录&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。</div><div class=\"line\">　　- &lt;指定条件&gt;： 所要搜索的文件的特征。</div><div class=\"line\">　　- &lt;指定动作&gt;： 对搜索结果进行特定的处理。</div></pre></td></tr></table></figure></p>\n<p>如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p>\n<p>find的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ find . -name &apos;my*&apos;</div><div class=\"line\">搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。</div><div class=\"line\">　　$ find . -name &apos;my*&apos; -ls</div><div class=\"line\">搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。</div><div class=\"line\">　　$ find . -type f -mmin -10</div><div class=\"line\">搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。</div></pre></td></tr></table></figure></p>\n<h2 id=\"locate\"><a href=\"#locate\" class=\"headerlink\" title=\"locate\"></a>locate</h2><p>locate命令其实是”find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</p>\n<p>locate命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ locate /etc/sh</div><div class=\"line\">搜索etc目录下所有以sh开头的文件。</div><div class=\"line\">　　$ locate ~/m</div><div class=\"line\">搜索用户主目录下，所有以m开头的文件。</div><div class=\"line\">　　$ locate -i ~/m</div><div class=\"line\">搜索用户主目录下，所有以m开头的文件，并且忽略大小写。</div></pre></td></tr></table></figure></p>\n<h2 id=\"whereis\"><a href=\"#whereis\" class=\"headerlink\" title=\"whereis\"></a>whereis</h2><p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>\n<p>whereis命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ whereis grep</div></pre></td></tr></table></figure></p>\n<h2 id=\"which\"><a href=\"#which\" class=\"headerlink\" title=\"which\"></a>which</h2><p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>\n<p>which命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ which grep</div></pre></td></tr></table></figure></p>\n<h2 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h2><p>type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。</p>\n<p>type命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ type cd</div><div class=\"line\">系统会提示，cd是shell的自带命令（build-in）。</div><div class=\"line\">　　$ type grep</div><div class=\"line\">系统会提示，grep是一个外部命令，并显示该命令的路径。</div><div class=\"line\">　　$ type -p grep</div><div class=\"line\">加上-p参数后，就相当于which命令。</div></pre></td></tr></table></figure></p>\n"},{"layout":"post","title":"记一次苦逼经历--关于spring项目打包为jar运行","date":"2016-09-19T13:41:48.000Z","_content":"\n上周二刚从外包那里接手了一个的项目，主要是实现了一个web服务器，客户端可以以http请求的方式通过该服务器获取一些数据库的信息，技术上主要是使用了SpringBoot和REST API。周三就来新的需求了，实现一个接口，大概看了下代码，感觉soeasy(虽然之前从没有接触过springboot和spring，说来惭愧。不过这也说明了使用框架的好处，可以快速上手)。\n\n中秋假期结束之后把这个接口弄完了。Eclipse里面跑起来完全没有问题。自信心爆棚。该服务器要求以jar包的方式运行，那就打个包吧。结果苦逼的经历开始了。\n\n由于项目没有使用任何工具构建，没有maven，也没有Gradle。想着就凑合着用Eclipse里面自带的export导出jar包的功能吧。于是:右键工程，选择export。然后java->JAR file\n\n{% asset_img 1.png export %}\n\njar包打好了。把依赖什么的都放到jar所在的同一个目录，紧接着使用 java -cp interfaceService.jar;lib/* com.XXX.Application  执行。\n\n服务器跑起来了。nice\n\n浏览器输入URL，回车，出现了这样的画面：\n\n{% asset_img 2.png 404 %}\n\nwhat? 404?赶紧看看服务器打印的日志，发现dispatcherServlet初始化完之后就没有其他动作了，也没有报错信息。跟在eclipse中正常执行的情况对比了一下，eclipse在打印完这几句Log之后就开始进入controller方法了。\n\n{% asset_img 3.png log %}\n\n初步怀疑是找不到对应的controller。\n\n输入关键字：springboot jar 和404页面的提示，谷歌之。\n\n找出来一堆答案，基本都是说没有正确添加注解那一类的意思。回头看看代码，该加注解的地方都加了。而且eclipse里跑着没问题啊，说明不是注解的问题。\n\n感觉应该是打包的问题。把没用的.classpath等文件都排除，重新打包。再次执行，结果一样。\n\n把lib和properties文件都打到包里，执行，还是没用。\n\n{% asset_img 4.png export %}\n\n然后，上图这几个勾选框吸引了我的目光，查了一下这几个框勾选之后的作用，感觉跟这个关系不大，但是也都选上试了一下，失败。\n\n接着又以各种姿势谷歌了一遍，毫无结果。此刻心情比较郁闷，上网刷会微博吧，有点晕...\n\n接下来重新振作精神，再打一次包。\n\n抱着随便试试的心情，把下面的的框也选上了。\n\n{% asset_img 5.png export %}\n\n结果，这次竟然成功了！服务器返回了正确的结果。激动...原来就因为Add Directory Entries这个单选框没勾选就浪费了我两个多小时！\n\n然后各种姿势测了一下，没问题了。\n\nAdd Directory Entries谷歌之。神了，出现了很多与我这个情况一样的描述和解决办法。看来还是有人掉过坑啊！\n\n浏览了一下大家的分析，结果就是：**当使用export方式打jar包来运行spring项目时，一定要记得把Add Directory Entries这个单选框勾选上！否则会扫描不到指定的controller**\n\n原因也很简单：当勾选Add Directory Entries这个选项时，生成的jar会添加文件夹信息。spring就可以扫描到相关的包信息。具体的解释看这篇文章：[spring 扫描包不起作用](http://www.voidcn.com/blog/wangjun5159/article/p-6159159.html)\n\n其实这次遇到的问题也不算是技术上的问题，但前前后后也花了将近三个小时才解决。有三点认识：\n\n1.搜索技巧很重要，如果早一点能用spring、扫描包等关键字去搜索的话，问题早已经解决了。\n\n2.打包尽量用构建工具，避免重复劳动还不易出错。Gradle使用学习中...\n\n3.应该从问题的根源上想才会得到解决方法。比如，如果知道了spring获取controller的实现方式，或许能更快解决这个问题。(spring真的是一点都不懂，需要学习)\n\n以上\n\n\n\n","source":"_posts/Spring项目打包为jar.md","raw":"layout: post\ntitle: 记一次苦逼经历--关于spring项目打包为jar运行\ndate: 2016-09-19 21:41:48\ncategories: 技术\ntags: \n- 服务器\n- spring\n---\n\n上周二刚从外包那里接手了一个的项目，主要是实现了一个web服务器，客户端可以以http请求的方式通过该服务器获取一些数据库的信息，技术上主要是使用了SpringBoot和REST API。周三就来新的需求了，实现一个接口，大概看了下代码，感觉soeasy(虽然之前从没有接触过springboot和spring，说来惭愧。不过这也说明了使用框架的好处，可以快速上手)。\n\n中秋假期结束之后把这个接口弄完了。Eclipse里面跑起来完全没有问题。自信心爆棚。该服务器要求以jar包的方式运行，那就打个包吧。结果苦逼的经历开始了。\n\n由于项目没有使用任何工具构建，没有maven，也没有Gradle。想着就凑合着用Eclipse里面自带的export导出jar包的功能吧。于是:右键工程，选择export。然后java->JAR file\n\n{% asset_img 1.png export %}\n\njar包打好了。把依赖什么的都放到jar所在的同一个目录，紧接着使用 java -cp interfaceService.jar;lib/* com.XXX.Application  执行。\n\n服务器跑起来了。nice\n\n浏览器输入URL，回车，出现了这样的画面：\n\n{% asset_img 2.png 404 %}\n\nwhat? 404?赶紧看看服务器打印的日志，发现dispatcherServlet初始化完之后就没有其他动作了，也没有报错信息。跟在eclipse中正常执行的情况对比了一下，eclipse在打印完这几句Log之后就开始进入controller方法了。\n\n{% asset_img 3.png log %}\n\n初步怀疑是找不到对应的controller。\n\n输入关键字：springboot jar 和404页面的提示，谷歌之。\n\n找出来一堆答案，基本都是说没有正确添加注解那一类的意思。回头看看代码，该加注解的地方都加了。而且eclipse里跑着没问题啊，说明不是注解的问题。\n\n感觉应该是打包的问题。把没用的.classpath等文件都排除，重新打包。再次执行，结果一样。\n\n把lib和properties文件都打到包里，执行，还是没用。\n\n{% asset_img 4.png export %}\n\n然后，上图这几个勾选框吸引了我的目光，查了一下这几个框勾选之后的作用，感觉跟这个关系不大，但是也都选上试了一下，失败。\n\n接着又以各种姿势谷歌了一遍，毫无结果。此刻心情比较郁闷，上网刷会微博吧，有点晕...\n\n接下来重新振作精神，再打一次包。\n\n抱着随便试试的心情，把下面的的框也选上了。\n\n{% asset_img 5.png export %}\n\n结果，这次竟然成功了！服务器返回了正确的结果。激动...原来就因为Add Directory Entries这个单选框没勾选就浪费了我两个多小时！\n\n然后各种姿势测了一下，没问题了。\n\nAdd Directory Entries谷歌之。神了，出现了很多与我这个情况一样的描述和解决办法。看来还是有人掉过坑啊！\n\n浏览了一下大家的分析，结果就是：**当使用export方式打jar包来运行spring项目时，一定要记得把Add Directory Entries这个单选框勾选上！否则会扫描不到指定的controller**\n\n原因也很简单：当勾选Add Directory Entries这个选项时，生成的jar会添加文件夹信息。spring就可以扫描到相关的包信息。具体的解释看这篇文章：[spring 扫描包不起作用](http://www.voidcn.com/blog/wangjun5159/article/p-6159159.html)\n\n其实这次遇到的问题也不算是技术上的问题，但前前后后也花了将近三个小时才解决。有三点认识：\n\n1.搜索技巧很重要，如果早一点能用spring、扫描包等关键字去搜索的话，问题早已经解决了。\n\n2.打包尽量用构建工具，避免重复劳动还不易出错。Gradle使用学习中...\n\n3.应该从问题的根源上想才会得到解决方法。比如，如果知道了spring获取controller的实现方式，或许能更快解决这个问题。(spring真的是一点都不懂，需要学习)\n\n以上\n\n\n\n","slug":"Spring项目打包为jar","published":1,"updated":"2017-02-19T13:08:11.031Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlpw000avegc3nld2wru","content":"<p>上周二刚从外包那里接手了一个的项目，主要是实现了一个web服务器，客户端可以以http请求的方式通过该服务器获取一些数据库的信息，技术上主要是使用了SpringBoot和REST API。周三就来新的需求了，实现一个接口，大概看了下代码，感觉soeasy(虽然之前从没有接触过springboot和spring，说来惭愧。不过这也说明了使用框架的好处，可以快速上手)。</p>\n<p>中秋假期结束之后把这个接口弄完了。Eclipse里面跑起来完全没有问题。自信心爆棚。该服务器要求以jar包的方式运行，那就打个包吧。结果苦逼的经历开始了。</p>\n<p>由于项目没有使用任何工具构建，没有maven，也没有Gradle。想着就凑合着用Eclipse里面自带的export导出jar包的功能吧。于是:右键工程，选择export。然后java-&gt;JAR file</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/1.png\" alt=\"export\" title=\"export\">\n<p>jar包打好了。把依赖什么的都放到jar所在的同一个目录，紧接着使用 java -cp interfaceService.jar;lib/* com.XXX.Application  执行。</p>\n<p>服务器跑起来了。nice</p>\n<p>浏览器输入URL，回车，出现了这样的画面：</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/2.png\" alt=\"404\" title=\"404\">\n<p>what? 404?赶紧看看服务器打印的日志，发现dispatcherServlet初始化完之后就没有其他动作了，也没有报错信息。跟在eclipse中正常执行的情况对比了一下，eclipse在打印完这几句Log之后就开始进入controller方法了。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/3.png\" alt=\"log\" title=\"log\">\n<p>初步怀疑是找不到对应的controller。</p>\n<p>输入关键字：springboot jar 和404页面的提示，谷歌之。</p>\n<p>找出来一堆答案，基本都是说没有正确添加注解那一类的意思。回头看看代码，该加注解的地方都加了。而且eclipse里跑着没问题啊，说明不是注解的问题。</p>\n<p>感觉应该是打包的问题。把没用的.classpath等文件都排除，重新打包。再次执行，结果一样。</p>\n<p>把lib和properties文件都打到包里，执行，还是没用。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/4.png\" alt=\"export\" title=\"export\">\n<p>然后，上图这几个勾选框吸引了我的目光，查了一下这几个框勾选之后的作用，感觉跟这个关系不大，但是也都选上试了一下，失败。</p>\n<p>接着又以各种姿势谷歌了一遍，毫无结果。此刻心情比较郁闷，上网刷会微博吧，有点晕…</p>\n<p>接下来重新振作精神，再打一次包。</p>\n<p>抱着随便试试的心情，把下面的的框也选上了。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/5.png\" alt=\"export\" title=\"export\">\n<p>结果，这次竟然成功了！服务器返回了正确的结果。激动…原来就因为Add Directory Entries这个单选框没勾选就浪费了我两个多小时！</p>\n<p>然后各种姿势测了一下，没问题了。</p>\n<p>Add Directory Entries谷歌之。神了，出现了很多与我这个情况一样的描述和解决办法。看来还是有人掉过坑啊！</p>\n<p>浏览了一下大家的分析，结果就是：<strong>当使用export方式打jar包来运行spring项目时，一定要记得把Add Directory Entries这个单选框勾选上！否则会扫描不到指定的controller</strong></p>\n<p>原因也很简单：当勾选Add Directory Entries这个选项时，生成的jar会添加文件夹信息。spring就可以扫描到相关的包信息。具体的解释看这篇文章：<a href=\"http://www.voidcn.com/blog/wangjun5159/article/p-6159159.html\" target=\"_blank\" rel=\"external\">spring 扫描包不起作用</a></p>\n<p>其实这次遇到的问题也不算是技术上的问题，但前前后后也花了将近三个小时才解决。有三点认识：</p>\n<p>1.搜索技巧很重要，如果早一点能用spring、扫描包等关键字去搜索的话，问题早已经解决了。</p>\n<p>2.打包尽量用构建工具，避免重复劳动还不易出错。Gradle使用学习中…</p>\n<p>3.应该从问题的根源上想才会得到解决方法。比如，如果知道了spring获取controller的实现方式，或许能更快解决这个问题。(spring真的是一点都不懂，需要学习)</p>\n<p>以上</p>\n","excerpt":"","more":"<p>上周二刚从外包那里接手了一个的项目，主要是实现了一个web服务器，客户端可以以http请求的方式通过该服务器获取一些数据库的信息，技术上主要是使用了SpringBoot和REST API。周三就来新的需求了，实现一个接口，大概看了下代码，感觉soeasy(虽然之前从没有接触过springboot和spring，说来惭愧。不过这也说明了使用框架的好处，可以快速上手)。</p>\n<p>中秋假期结束之后把这个接口弄完了。Eclipse里面跑起来完全没有问题。自信心爆棚。该服务器要求以jar包的方式运行，那就打个包吧。结果苦逼的经历开始了。</p>\n<p>由于项目没有使用任何工具构建，没有maven，也没有Gradle。想着就凑合着用Eclipse里面自带的export导出jar包的功能吧。于是:右键工程，选择export。然后java-&gt;JAR file</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/1.png\" alt=\"export\" title=\"export\">\n<p>jar包打好了。把依赖什么的都放到jar所在的同一个目录，紧接着使用 java -cp interfaceService.jar;lib/* com.XXX.Application  执行。</p>\n<p>服务器跑起来了。nice</p>\n<p>浏览器输入URL，回车，出现了这样的画面：</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/2.png\" alt=\"404\" title=\"404\">\n<p>what? 404?赶紧看看服务器打印的日志，发现dispatcherServlet初始化完之后就没有其他动作了，也没有报错信息。跟在eclipse中正常执行的情况对比了一下，eclipse在打印完这几句Log之后就开始进入controller方法了。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/3.png\" alt=\"log\" title=\"log\">\n<p>初步怀疑是找不到对应的controller。</p>\n<p>输入关键字：springboot jar 和404页面的提示，谷歌之。</p>\n<p>找出来一堆答案，基本都是说没有正确添加注解那一类的意思。回头看看代码，该加注解的地方都加了。而且eclipse里跑着没问题啊，说明不是注解的问题。</p>\n<p>感觉应该是打包的问题。把没用的.classpath等文件都排除，重新打包。再次执行，结果一样。</p>\n<p>把lib和properties文件都打到包里，执行，还是没用。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/4.png\" alt=\"export\" title=\"export\">\n<p>然后，上图这几个勾选框吸引了我的目光，查了一下这几个框勾选之后的作用，感觉跟这个关系不大，但是也都选上试了一下，失败。</p>\n<p>接着又以各种姿势谷歌了一遍，毫无结果。此刻心情比较郁闷，上网刷会微博吧，有点晕…</p>\n<p>接下来重新振作精神，再打一次包。</p>\n<p>抱着随便试试的心情，把下面的的框也选上了。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/5.png\" alt=\"export\" title=\"export\">\n<p>结果，这次竟然成功了！服务器返回了正确的结果。激动…原来就因为Add Directory Entries这个单选框没勾选就浪费了我两个多小时！</p>\n<p>然后各种姿势测了一下，没问题了。</p>\n<p>Add Directory Entries谷歌之。神了，出现了很多与我这个情况一样的描述和解决办法。看来还是有人掉过坑啊！</p>\n<p>浏览了一下大家的分析，结果就是：<strong>当使用export方式打jar包来运行spring项目时，一定要记得把Add Directory Entries这个单选框勾选上！否则会扫描不到指定的controller</strong></p>\n<p>原因也很简单：当勾选Add Directory Entries这个选项时，生成的jar会添加文件夹信息。spring就可以扫描到相关的包信息。具体的解释看这篇文章：<a href=\"http://www.voidcn.com/blog/wangjun5159/article/p-6159159.html\">spring 扫描包不起作用</a></p>\n<p>其实这次遇到的问题也不算是技术上的问题，但前前后后也花了将近三个小时才解决。有三点认识：</p>\n<p>1.搜索技巧很重要，如果早一点能用spring、扫描包等关键字去搜索的话，问题早已经解决了。</p>\n<p>2.打包尽量用构建工具，避免重复劳动还不易出错。Gradle使用学习中…</p>\n<p>3.应该从问题的根源上想才会得到解决方法。比如，如果知道了spring获取controller的实现方式，或许能更快解决这个问题。(spring真的是一点都不懂，需要学习)</p>\n<p>以上</p>\n"},{"layout":"post","title":"Vps使用笔记","date":"2017-02-07T13:34:16.000Z","_content":"> 今天折腾了一天，总算是把翻墙的梯子搭起来了，租了国外的vps，然后在上面搭建了shadowsocks服务，手机和电脑就可以使用shadowsocks客户端的方式科学上网了。\n> Shadowsocks 是一个由很多人参与的开源项目，感谢shadowsocks作者[@clowwindy](https://github.com/clowwindy/shadowsocks).关于shadowssocks和vpn等等翻墙方式的区别,不再一一赘述，本文只是记录梯子搭建的过程\n\n## 购买VPS\n\nVPS的概念我也不是特别清楚，就把他当成主机好了，类似于阿里云等等。\n\n购买之后，会分配给你root账户密码，你就拥有了一台国外机房的主机。\n\nVPS 可以参考 [有哪些便宜稳定，速度也不错的Linux VPS 推荐？](https://www.zhihu.com/question/20800554),我买了Vultr 日本机房的vps,充了5美刀先试试。具体的购买方法自行谷歌\n\n## 搭建shadowsocks服务\n\n### 升级内核\n\n我选择了Centos7的Linux发型版本作为操作系统。\n\n使用MobaXterm(或者是其他ssh工具)连接到分配给你的主机(root密码购买成功时会给出),\n\n首先升级一下内核：wget -O- https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh | bash\n\n完成之后，重启：\n\nreboot\n\n重新登录，查看内核版本：\n\nuname -r\n\n不出意外已经更新到了最新版本。接着执行：\n\nsysctl -a|grep congestion_control\n\n如果输出选项包含：net.ipv4.tcp_congestion_control = bbr 表示安装成功，否则需要手动开启bbr模式：\n\n```\necho \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\necho \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\nsysctl -p\nsysctl\nnet.ipv4.tcp_available_congestion_control\n```\n\n再次查看：\n\nsysctl -a|grep congestion_control\n\n### 搭建服务\n\n搭建服务可以选择使用别人写好的现成的脚本，也可以自己搭建，下面介绍这两种方法：\n\n#### 使用现成脚本\n\n执行以下命令：\n\n```wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n\n首先会提示你输入密码和端口，然后开始安装。安装完成后代表shadowsocks服务已经开启了。此时可以使用shadowsocks客户端去连接这个服务器了。\n\n脚本可用的命令：\n\n启动：/etc/init.d/shadowsocks start\n\n停止：/etc/init.d/shadowsocks stop\n\n重启：/etc/init.d/shadowsocks restart\n\n状态：/etc/init.d/shadowsocks status\n\n卸载：./shadowsocks.sh uninstall\n\n支持多用户的方法：修改配置文件:/etc/shadowsocks.json\n\n```\n{    \n    \"server\":\"0.0.0.0\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{\n         \"8989\":\"password0\",\n         \"9001\":\"password1\",\n         \"9002\":\"password2\",\n         \"9003\":\"password3\",\n         \"9004\":\"password4\"\n    },\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}```\n\n#### 自行搭建\n\n首先安装shadowsocks服务：\n\n```\nyum install python-setuptools && easy_install pip\npip install shadowsocks\n```\n\n显示 “Successfully installed shadowsocks-2.6.10″。意味着Shadowsocks已经成功安装。\n\n接着，创建一个Shadowsocks配置文件。输入以下命令：\n\nvi /etc/shadowsocks.json\n\n然后在该文件中输入：\n\n```\n{\n    \"server\":\"your_server_ip\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"auooo.com\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n上面各项配置的含义已经很明显了，除了server(vps的ip)、server_port和password之外，其他默认即可。保存该文件。执行：\n\nssserver -c /etc/shadowsocks.json -d start\n\n服务就启动了，如果想要关闭，执行：\n\nssserver -c /etc/shadowsocks.json -d stop\n\n支持多用户的方法与上面的类似\n\n#### 端口问题\n\n有时候服务正常启动了，但是发现客户端还是没有办法翻墙。这时要注意检查vps开放的端口：\n\nCentos升级到7之后，使用firewalld代替了原来的iptables作为防火墙。\n\n启动：systemctl start  firewalld\n\n重启：firewall-cmd --reload\n\n查看状态：systemctl status firewalld 或者 firewall-cmd --state  \n\n查看开放的端口：firewall-cmd --list-ports\n\n增加开放端口：firewall-cmd --add-port=9001/tcp --permanent   (重启生效)\n\n9001：要开放的端口\n\ntcp：协议\n\n--permanent：永久生效，没有此参数重启后失效其他命令自行查找\n\n## 锐速加速\n\n[锐速破解版linux一键自动安装包（8月7日更新）](https://www.91yun.org/archives/683)\n\n文章开头的更新内核使用bbr加速或者锐速加速都可以，没试过哪种方式效果更好一些\n\n## vps使用ssh密钥登录\n\n使用ssh root账户和密码登录的方式是vps一开始会给出的登录主机的方式，这种方式比较简单，但是容易被别人暴力破解登录密码，控制我们的主机。\n\n所以，应该使用ssh密钥登录的方式来增强安全性。\n\n### 修改root密码\n\n第一步应该先把默认的root密码修改为自己的密码，最好复杂一点。\n\n确保自己记住了这个密码。\n\npasswd\n\n### 创建用户\n\n可以先创建一个非root用户：\n\n```\nuseradd yukai\n```\n\n创建账户密码：\n\n```\npasswd yukai \n```\n\n给予账户sudo权限：\n\n```\nvisudo\n```\n\n在 root ALL=(ALL)  ALL 下新增一行：\n\nyukai ALL=(ALL)  ALL\n\n切换到yukai这个账户：\n\nsu - yukai \n\n### 创建密钥\n\n```\nssh-keygen -t rsa\n```\n\n在 /home/yukai 下生成了一个隐藏目录：.ssh, 执行：\n\n```\ncd ~/.sshcat id_rsa.pub >> authorized_keys\nchmod 600 authorized_keys\n```\n\n将 id_rsa文件下载下来保存到本地(使用MobaXterm等工具)\n\n### 使用密钥认证登录\n\n打开MobaXterm工具，新建一个session，选择ssh，在Advanced SSH settings选项中选择 use private keygen复选框，并把上一步下载好的id_rsa选择进来。\n\n以用户yukai登录，提示输入密钥文件的密码，输入生成密钥时所填的密码，如果能够登录，则设置正确了\n\n### 禁用root用户登录和密码登录\n\n确保自己记住了root密码，并且上一步密钥认证方式登录成功。\n\n```\nsudo vi /etc/ssh/sshd_config\n```\n找到以下几项，进行如下设置：\n\n```\nRSAAuthentication yes\nPubkeyAuthentication yes\nPermitRootLogin no\nPasswordAuthentication no\n```\n\n重启ssh服务：\n\n```\nservice sshd restart\n```\n\n### 多台主机管理\n\n可以将生成的密钥文件authorized_keys保存到多个主机的相同位置：~/.ssh\n\n然后进行上面的配置。此时就可以使用一份私钥文件id_rsa登录多个主机了。\n\n## ss多用户管理\n\n前端使用ss-panel，后台使用shadowsocks-manyuser\n\n教程参见：\n\n[可能是最好的 ss-panel 部署教程](https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/)\n\n[ShadowSocks多用户管理系统搭建（moeSS+manyuser）](https://blog.linuxeye.com/426.html)\n\n## 在Linux上使用shadowsocks服务翻墙\n\n### 开启shadowsocks客户端\n\n确认安装了shadowsocks服务并从配置好的shadowsocks服务器端获得配置文件: /etc/shadowsocks/config.json\n\n```\n{\n        \"server\":\"remote-shadowsocks-server-ip-addr\",\n        \"server_port\":443,\n        \"local_address\":\"127.0.0.1\",\n        \"local_port\":1080,\n        \"password\":\"your-passwd\",\n        \"timeout\":300,\n        \"method\":\"aes-256-cfb\",\n        \"fast_open\":false,\n        \"workers\":1\n}\n```\n在config.json所在目录下运行sslocal即可：\n\nsslocal -c /etc/shadowsocks/config.json\n\n也可以手动指定参数运行：\n\nsslocal -s 服务器地址 -p 服务器端口 -l 本地端端口 -k 密码 -m 加密方法\n\n### 使用chrome代理\n\n在chrome应用商店中查找 Proxy SwitchyOmega,并安装该扩展\n\n新建情景模式，代理协议选择SOCKS5，代理服务器选择 127.0.0.1， 代理端口选择上一步中的local_port,即1080\n\n启用该扩展程序，此时可顺利使用google了 \n\n## 附录\n\n### 安装vim\n\nvim编辑器需要安装三个包：\n\n```\nvim-enhanced-7.0.109-7.el5\nvim-minimal-7.0.109-7.el5\nvim-common-7.0.109-7.el5\n```\n\n输入  `rpm -qa|grep vim` 这个命令，如何vim已经正确安装，则会显示上面三个包的名称\n\n如果缺少了其中某个，比如说： vim-enhanced这个包少了，执行：`yum -y install vim-enhanced` 命令，它会自动下载安装\n\n如果上面三个包一个都没有显示，则直接输入命令：\n\n```\nyum -y install vim*\n```\n\n### 安装net-tools\n\n```\nyum install net-tools\n```\n\n### 更改文件所有者\n\nchown -R www.www ./    将本路径下所有文件所有者改为www组的www\n\n## 参考\n\n[Shadowsocks Python版一键安装脚本](https://teddysun.com/342.html)\n\n[使用 Shadowsocks 自建翻墙服务器，实现全平台 100% 翻墙无障碍](https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/)\n\n[http://shadowsocks.org/](http://shadowsocks.org/en/download/clients.html)\n\n[shadowsocks（影梭）不完全指南](http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/)\n","source":"_posts/Vps使用笔记.md","raw":"---\nlayout: post\ntitle: Vps使用笔记\ndate: 2017-02-07 21:34:16\ncategories: 工具\ntags: linux\n---\n> 今天折腾了一天，总算是把翻墙的梯子搭起来了，租了国外的vps，然后在上面搭建了shadowsocks服务，手机和电脑就可以使用shadowsocks客户端的方式科学上网了。\n> Shadowsocks 是一个由很多人参与的开源项目，感谢shadowsocks作者[@clowwindy](https://github.com/clowwindy/shadowsocks).关于shadowssocks和vpn等等翻墙方式的区别,不再一一赘述，本文只是记录梯子搭建的过程\n\n## 购买VPS\n\nVPS的概念我也不是特别清楚，就把他当成主机好了，类似于阿里云等等。\n\n购买之后，会分配给你root账户密码，你就拥有了一台国外机房的主机。\n\nVPS 可以参考 [有哪些便宜稳定，速度也不错的Linux VPS 推荐？](https://www.zhihu.com/question/20800554),我买了Vultr 日本机房的vps,充了5美刀先试试。具体的购买方法自行谷歌\n\n## 搭建shadowsocks服务\n\n### 升级内核\n\n我选择了Centos7的Linux发型版本作为操作系统。\n\n使用MobaXterm(或者是其他ssh工具)连接到分配给你的主机(root密码购买成功时会给出),\n\n首先升级一下内核：wget -O- https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh | bash\n\n完成之后，重启：\n\nreboot\n\n重新登录，查看内核版本：\n\nuname -r\n\n不出意外已经更新到了最新版本。接着执行：\n\nsysctl -a|grep congestion_control\n\n如果输出选项包含：net.ipv4.tcp_congestion_control = bbr 表示安装成功，否则需要手动开启bbr模式：\n\n```\necho \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\necho \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\nsysctl -p\nsysctl\nnet.ipv4.tcp_available_congestion_control\n```\n\n再次查看：\n\nsysctl -a|grep congestion_control\n\n### 搭建服务\n\n搭建服务可以选择使用别人写好的现成的脚本，也可以自己搭建，下面介绍这两种方法：\n\n#### 使用现成脚本\n\n执行以下命令：\n\n```wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n\n首先会提示你输入密码和端口，然后开始安装。安装完成后代表shadowsocks服务已经开启了。此时可以使用shadowsocks客户端去连接这个服务器了。\n\n脚本可用的命令：\n\n启动：/etc/init.d/shadowsocks start\n\n停止：/etc/init.d/shadowsocks stop\n\n重启：/etc/init.d/shadowsocks restart\n\n状态：/etc/init.d/shadowsocks status\n\n卸载：./shadowsocks.sh uninstall\n\n支持多用户的方法：修改配置文件:/etc/shadowsocks.json\n\n```\n{    \n    \"server\":\"0.0.0.0\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{\n         \"8989\":\"password0\",\n         \"9001\":\"password1\",\n         \"9002\":\"password2\",\n         \"9003\":\"password3\",\n         \"9004\":\"password4\"\n    },\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}```\n\n#### 自行搭建\n\n首先安装shadowsocks服务：\n\n```\nyum install python-setuptools && easy_install pip\npip install shadowsocks\n```\n\n显示 “Successfully installed shadowsocks-2.6.10″。意味着Shadowsocks已经成功安装。\n\n接着，创建一个Shadowsocks配置文件。输入以下命令：\n\nvi /etc/shadowsocks.json\n\n然后在该文件中输入：\n\n```\n{\n    \"server\":\"your_server_ip\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"auooo.com\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n上面各项配置的含义已经很明显了，除了server(vps的ip)、server_port和password之外，其他默认即可。保存该文件。执行：\n\nssserver -c /etc/shadowsocks.json -d start\n\n服务就启动了，如果想要关闭，执行：\n\nssserver -c /etc/shadowsocks.json -d stop\n\n支持多用户的方法与上面的类似\n\n#### 端口问题\n\n有时候服务正常启动了，但是发现客户端还是没有办法翻墙。这时要注意检查vps开放的端口：\n\nCentos升级到7之后，使用firewalld代替了原来的iptables作为防火墙。\n\n启动：systemctl start  firewalld\n\n重启：firewall-cmd --reload\n\n查看状态：systemctl status firewalld 或者 firewall-cmd --state  \n\n查看开放的端口：firewall-cmd --list-ports\n\n增加开放端口：firewall-cmd --add-port=9001/tcp --permanent   (重启生效)\n\n9001：要开放的端口\n\ntcp：协议\n\n--permanent：永久生效，没有此参数重启后失效其他命令自行查找\n\n## 锐速加速\n\n[锐速破解版linux一键自动安装包（8月7日更新）](https://www.91yun.org/archives/683)\n\n文章开头的更新内核使用bbr加速或者锐速加速都可以，没试过哪种方式效果更好一些\n\n## vps使用ssh密钥登录\n\n使用ssh root账户和密码登录的方式是vps一开始会给出的登录主机的方式，这种方式比较简单，但是容易被别人暴力破解登录密码，控制我们的主机。\n\n所以，应该使用ssh密钥登录的方式来增强安全性。\n\n### 修改root密码\n\n第一步应该先把默认的root密码修改为自己的密码，最好复杂一点。\n\n确保自己记住了这个密码。\n\npasswd\n\n### 创建用户\n\n可以先创建一个非root用户：\n\n```\nuseradd yukai\n```\n\n创建账户密码：\n\n```\npasswd yukai \n```\n\n给予账户sudo权限：\n\n```\nvisudo\n```\n\n在 root ALL=(ALL)  ALL 下新增一行：\n\nyukai ALL=(ALL)  ALL\n\n切换到yukai这个账户：\n\nsu - yukai \n\n### 创建密钥\n\n```\nssh-keygen -t rsa\n```\n\n在 /home/yukai 下生成了一个隐藏目录：.ssh, 执行：\n\n```\ncd ~/.sshcat id_rsa.pub >> authorized_keys\nchmod 600 authorized_keys\n```\n\n将 id_rsa文件下载下来保存到本地(使用MobaXterm等工具)\n\n### 使用密钥认证登录\n\n打开MobaXterm工具，新建一个session，选择ssh，在Advanced SSH settings选项中选择 use private keygen复选框，并把上一步下载好的id_rsa选择进来。\n\n以用户yukai登录，提示输入密钥文件的密码，输入生成密钥时所填的密码，如果能够登录，则设置正确了\n\n### 禁用root用户登录和密码登录\n\n确保自己记住了root密码，并且上一步密钥认证方式登录成功。\n\n```\nsudo vi /etc/ssh/sshd_config\n```\n找到以下几项，进行如下设置：\n\n```\nRSAAuthentication yes\nPubkeyAuthentication yes\nPermitRootLogin no\nPasswordAuthentication no\n```\n\n重启ssh服务：\n\n```\nservice sshd restart\n```\n\n### 多台主机管理\n\n可以将生成的密钥文件authorized_keys保存到多个主机的相同位置：~/.ssh\n\n然后进行上面的配置。此时就可以使用一份私钥文件id_rsa登录多个主机了。\n\n## ss多用户管理\n\n前端使用ss-panel，后台使用shadowsocks-manyuser\n\n教程参见：\n\n[可能是最好的 ss-panel 部署教程](https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/)\n\n[ShadowSocks多用户管理系统搭建（moeSS+manyuser）](https://blog.linuxeye.com/426.html)\n\n## 在Linux上使用shadowsocks服务翻墙\n\n### 开启shadowsocks客户端\n\n确认安装了shadowsocks服务并从配置好的shadowsocks服务器端获得配置文件: /etc/shadowsocks/config.json\n\n```\n{\n        \"server\":\"remote-shadowsocks-server-ip-addr\",\n        \"server_port\":443,\n        \"local_address\":\"127.0.0.1\",\n        \"local_port\":1080,\n        \"password\":\"your-passwd\",\n        \"timeout\":300,\n        \"method\":\"aes-256-cfb\",\n        \"fast_open\":false,\n        \"workers\":1\n}\n```\n在config.json所在目录下运行sslocal即可：\n\nsslocal -c /etc/shadowsocks/config.json\n\n也可以手动指定参数运行：\n\nsslocal -s 服务器地址 -p 服务器端口 -l 本地端端口 -k 密码 -m 加密方法\n\n### 使用chrome代理\n\n在chrome应用商店中查找 Proxy SwitchyOmega,并安装该扩展\n\n新建情景模式，代理协议选择SOCKS5，代理服务器选择 127.0.0.1， 代理端口选择上一步中的local_port,即1080\n\n启用该扩展程序，此时可顺利使用google了 \n\n## 附录\n\n### 安装vim\n\nvim编辑器需要安装三个包：\n\n```\nvim-enhanced-7.0.109-7.el5\nvim-minimal-7.0.109-7.el5\nvim-common-7.0.109-7.el5\n```\n\n输入  `rpm -qa|grep vim` 这个命令，如何vim已经正确安装，则会显示上面三个包的名称\n\n如果缺少了其中某个，比如说： vim-enhanced这个包少了，执行：`yum -y install vim-enhanced` 命令，它会自动下载安装\n\n如果上面三个包一个都没有显示，则直接输入命令：\n\n```\nyum -y install vim*\n```\n\n### 安装net-tools\n\n```\nyum install net-tools\n```\n\n### 更改文件所有者\n\nchown -R www.www ./    将本路径下所有文件所有者改为www组的www\n\n## 参考\n\n[Shadowsocks Python版一键安装脚本](https://teddysun.com/342.html)\n\n[使用 Shadowsocks 自建翻墙服务器，实现全平台 100% 翻墙无障碍](https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/)\n\n[http://shadowsocks.org/](http://shadowsocks.org/en/download/clients.html)\n\n[shadowsocks（影梭）不完全指南](http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/)\n","slug":"Vps使用笔记","published":1,"updated":"2017-02-19T13:08:11.032Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlq1000cvegcjhdbx91v","content":"<blockquote>\n<p>今天折腾了一天，总算是把翻墙的梯子搭起来了，租了国外的vps，然后在上面搭建了shadowsocks服务，手机和电脑就可以使用shadowsocks客户端的方式科学上网了。<br>Shadowsocks 是一个由很多人参与的开源项目，感谢shadowsocks作者<a href=\"https://github.com/clowwindy/shadowsocks\" target=\"_blank\" rel=\"external\">@clowwindy</a>.关于shadowssocks和vpn等等翻墙方式的区别,不再一一赘述，本文只是记录梯子搭建的过程</p>\n</blockquote>\n<h2 id=\"购买VPS\"><a href=\"#购买VPS\" class=\"headerlink\" title=\"购买VPS\"></a>购买VPS</h2><p>VPS的概念我也不是特别清楚，就把他当成主机好了，类似于阿里云等等。</p>\n<p>购买之后，会分配给你root账户密码，你就拥有了一台国外机房的主机。</p>\n<p>VPS 可以参考 <a href=\"https://www.zhihu.com/question/20800554\" target=\"_blank\" rel=\"external\">有哪些便宜稳定，速度也不错的Linux VPS 推荐？</a>,我买了Vultr 日本机房的vps,充了5美刀先试试。具体的购买方法自行谷歌</p>\n<h2 id=\"搭建shadowsocks服务\"><a href=\"#搭建shadowsocks服务\" class=\"headerlink\" title=\"搭建shadowsocks服务\"></a>搭建shadowsocks服务</h2><h3 id=\"升级内核\"><a href=\"#升级内核\" class=\"headerlink\" title=\"升级内核\"></a>升级内核</h3><p>我选择了Centos7的Linux发型版本作为操作系统。</p>\n<p>使用MobaXterm(或者是其他ssh工具)连接到分配给你的主机(root密码购买成功时会给出),</p>\n<p>首先升级一下内核：wget -O- <a href=\"https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh\" target=\"_blank\" rel=\"external\">https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh</a> | bash</p>\n<p>完成之后，重启：</p>\n<p>reboot</p>\n<p>重新登录，查看内核版本：</p>\n<p>uname -r</p>\n<p>不出意外已经更新到了最新版本。接着执行：</p>\n<p>sysctl -a|grep congestion_control</p>\n<p>如果输出选项包含：net.ipv4.tcp_congestion_control = bbr 表示安装成功，否则需要手动开启bbr模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">sysctl -p</div><div class=\"line\">sysctl</div><div class=\"line\">net.ipv4.tcp_available_congestion_control</div></pre></td></tr></table></figure>\n<p>再次查看：</p>\n<p>sysctl -a|grep congestion_control</p>\n<h3 id=\"搭建服务\"><a href=\"#搭建服务\" class=\"headerlink\" title=\"搭建服务\"></a>搭建服务</h3><p>搭建服务可以选择使用别人写好的现成的脚本，也可以自己搭建，下面介绍这两种方法：</p>\n<h4 id=\"使用现成脚本\"><a href=\"#使用现成脚本\" class=\"headerlink\" title=\"使用现成脚本\"></a>使用现成脚本</h4><p>执行以下命令：</p>\n<figure class=\"highlight plain\"><figcaption><span>--no-check-certificate</span><a href=\"https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\" target=\"_blank\" rel=\"external\">link</a></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x shadowsocks.sh</div><div class=\"line\">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</div></pre></td></tr></table></figure>\n<p>首先会提示你输入密码和端口，然后开始安装。安装完成后代表shadowsocks服务已经开启了。此时可以使用shadowsocks客户端去连接这个服务器了。</p>\n<p>脚本可用的命令：</p>\n<p>启动：/etc/init.d/shadowsocks start</p>\n<p>停止：/etc/init.d/shadowsocks stop</p>\n<p>重启：/etc/init.d/shadowsocks restart</p>\n<p>状态：/etc/init.d/shadowsocks status</p>\n<p>卸载：./shadowsocks.sh uninstall</p>\n<p>支持多用户的方法：修改配置文件:/etc/shadowsocks.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;    </div><div class=\"line\">    &quot;server&quot;:&quot;0.0.0.0&quot;,</div><div class=\"line\">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;port_password&quot;:&#123;</div><div class=\"line\">         &quot;8989&quot;:&quot;password0&quot;,</div><div class=\"line\">         &quot;9001&quot;:&quot;password1&quot;,</div><div class=\"line\">         &quot;9002&quot;:&quot;password2&quot;,</div><div class=\"line\">         &quot;9003&quot;:&quot;password3&quot;,</div><div class=\"line\">         &quot;9004&quot;:&quot;password4&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"自行搭建\"><a href=\"#自行搭建\" class=\"headerlink\" title=\"自行搭建\"></a>自行搭建</h4><p>首先安装shadowsocks服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</div><div class=\"line\">pip install shadowsocks</div></pre></td></tr></table></figure>\n<p>显示 “Successfully installed shadowsocks-2.6.10″。意味着Shadowsocks已经成功安装。</p>\n<p>接着，创建一个Shadowsocks配置文件。输入以下命令：</p>\n<p>vi /etc/shadowsocks.json</p>\n<p>然后在该文件中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;server&quot;:&quot;your_server_ip&quot;,</div><div class=\"line\">    &quot;server_port&quot;:8388,</div><div class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;password&quot;:&quot;auooo.com&quot;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面各项配置的含义已经很明显了，除了server(vps的ip)、server_port和password之外，其他默认即可。保存该文件。执行：</p>\n<p>ssserver -c /etc/shadowsocks.json -d start</p>\n<p>服务就启动了，如果想要关闭，执行：</p>\n<p>ssserver -c /etc/shadowsocks.json -d stop</p>\n<p>支持多用户的方法与上面的类似</p>\n<h4 id=\"端口问题\"><a href=\"#端口问题\" class=\"headerlink\" title=\"端口问题\"></a>端口问题</h4><p>有时候服务正常启动了，但是发现客户端还是没有办法翻墙。这时要注意检查vps开放的端口：</p>\n<p>Centos升级到7之后，使用firewalld代替了原来的iptables作为防火墙。</p>\n<p>启动：systemctl start  firewalld</p>\n<p>重启：firewall-cmd –reload</p>\n<p>查看状态：systemctl status firewalld 或者 firewall-cmd –state  </p>\n<p>查看开放的端口：firewall-cmd –list-ports</p>\n<p>增加开放端口：firewall-cmd –add-port=9001/tcp –permanent   (重启生效)</p>\n<p>9001：要开放的端口</p>\n<p>tcp：协议</p>\n<p>–permanent：永久生效，没有此参数重启后失效其他命令自行查找</p>\n<h2 id=\"锐速加速\"><a href=\"#锐速加速\" class=\"headerlink\" title=\"锐速加速\"></a>锐速加速</h2><p><a href=\"https://www.91yun.org/archives/683\" target=\"_blank\" rel=\"external\">锐速破解版linux一键自动安装包（8月7日更新）</a></p>\n<p>文章开头的更新内核使用bbr加速或者锐速加速都可以，没试过哪种方式效果更好一些</p>\n<h2 id=\"vps使用ssh密钥登录\"><a href=\"#vps使用ssh密钥登录\" class=\"headerlink\" title=\"vps使用ssh密钥登录\"></a>vps使用ssh密钥登录</h2><p>使用ssh root账户和密码登录的方式是vps一开始会给出的登录主机的方式，这种方式比较简单，但是容易被别人暴力破解登录密码，控制我们的主机。</p>\n<p>所以，应该使用ssh密钥登录的方式来增强安全性。</p>\n<h3 id=\"修改root密码\"><a href=\"#修改root密码\" class=\"headerlink\" title=\"修改root密码\"></a>修改root密码</h3><p>第一步应该先把默认的root密码修改为自己的密码，最好复杂一点。</p>\n<p>确保自己记住了这个密码。</p>\n<p>passwd</p>\n<h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><p>可以先创建一个非root用户：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">useradd yukai</div></pre></td></tr></table></figure>\n<p>创建账户密码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">passwd yukai</div></pre></td></tr></table></figure>\n<p>给予账户sudo权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">visudo</div></pre></td></tr></table></figure>\n<p>在 root ALL=(ALL)  ALL 下新增一行：</p>\n<p>yukai ALL=(ALL)  ALL</p>\n<p>切换到yukai这个账户：</p>\n<p>su - yukai </p>\n<h3 id=\"创建密钥\"><a href=\"#创建密钥\" class=\"headerlink\" title=\"创建密钥\"></a>创建密钥</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen -t rsa</div></pre></td></tr></table></figure>\n<p>在 /home/yukai 下生成了一个隐藏目录：.ssh, 执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~/.sshcat id_rsa.pub &gt;&gt; authorized_keys</div><div class=\"line\">chmod 600 authorized_keys</div></pre></td></tr></table></figure>\n<p>将 id_rsa文件下载下来保存到本地(使用MobaXterm等工具)</p>\n<h3 id=\"使用密钥认证登录\"><a href=\"#使用密钥认证登录\" class=\"headerlink\" title=\"使用密钥认证登录\"></a>使用密钥认证登录</h3><p>打开MobaXterm工具，新建一个session，选择ssh，在Advanced SSH settings选项中选择 use private keygen复选框，并把上一步下载好的id_rsa选择进来。</p>\n<p>以用户yukai登录，提示输入密钥文件的密码，输入生成密钥时所填的密码，如果能够登录，则设置正确了</p>\n<h3 id=\"禁用root用户登录和密码登录\"><a href=\"#禁用root用户登录和密码登录\" class=\"headerlink\" title=\"禁用root用户登录和密码登录\"></a>禁用root用户登录和密码登录</h3><p>确保自己记住了root密码，并且上一步密钥认证方式登录成功。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo vi /etc/ssh/sshd_config</div></pre></td></tr></table></figure>\n<p>找到以下几项，进行如下设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">RSAAuthentication yes</div><div class=\"line\">PubkeyAuthentication yes</div><div class=\"line\">PermitRootLogin no</div><div class=\"line\">PasswordAuthentication no</div></pre></td></tr></table></figure>\n<p>重启ssh服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service sshd restart</div></pre></td></tr></table></figure>\n<h3 id=\"多台主机管理\"><a href=\"#多台主机管理\" class=\"headerlink\" title=\"多台主机管理\"></a>多台主机管理</h3><p>可以将生成的密钥文件authorized_keys保存到多个主机的相同位置：~/.ssh</p>\n<p>然后进行上面的配置。此时就可以使用一份私钥文件id_rsa登录多个主机了。</p>\n<h2 id=\"ss多用户管理\"><a href=\"#ss多用户管理\" class=\"headerlink\" title=\"ss多用户管理\"></a>ss多用户管理</h2><p>前端使用ss-panel，后台使用shadowsocks-manyuser</p>\n<p>教程参见：</p>\n<p><a href=\"https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/\" target=\"_blank\" rel=\"external\">可能是最好的 ss-panel 部署教程</a></p>\n<p><a href=\"https://blog.linuxeye.com/426.html\" target=\"_blank\" rel=\"external\">ShadowSocks多用户管理系统搭建（moeSS+manyuser）</a></p>\n<h2 id=\"在Linux上使用shadowsocks服务翻墙\"><a href=\"#在Linux上使用shadowsocks服务翻墙\" class=\"headerlink\" title=\"在Linux上使用shadowsocks服务翻墙\"></a>在Linux上使用shadowsocks服务翻墙</h2><h3 id=\"开启shadowsocks客户端\"><a href=\"#开启shadowsocks客户端\" class=\"headerlink\" title=\"开启shadowsocks客户端\"></a>开启shadowsocks客户端</h3><p>确认安装了shadowsocks服务并从配置好的shadowsocks服务器端获得配置文件: /etc/shadowsocks/config.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">        &quot;server&quot;:&quot;remote-shadowsocks-server-ip-addr&quot;,</div><div class=\"line\">        &quot;server_port&quot;:443,</div><div class=\"line\">        &quot;local_address&quot;:&quot;127.0.0.1&quot;,</div><div class=\"line\">        &quot;local_port&quot;:1080,</div><div class=\"line\">        &quot;password&quot;:&quot;your-passwd&quot;,</div><div class=\"line\">        &quot;timeout&quot;:300,</div><div class=\"line\">        &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">        &quot;fast_open&quot;:false,</div><div class=\"line\">        &quot;workers&quot;:1</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在config.json所在目录下运行sslocal即可：</p>\n<p>sslocal -c /etc/shadowsocks/config.json</p>\n<p>也可以手动指定参数运行：</p>\n<p>sslocal -s 服务器地址 -p 服务器端口 -l 本地端端口 -k 密码 -m 加密方法</p>\n<h3 id=\"使用chrome代理\"><a href=\"#使用chrome代理\" class=\"headerlink\" title=\"使用chrome代理\"></a>使用chrome代理</h3><p>在chrome应用商店中查找 Proxy SwitchyOmega,并安装该扩展</p>\n<p>新建情景模式，代理协议选择SOCKS5，代理服务器选择 127.0.0.1， 代理端口选择上一步中的local_port,即1080</p>\n<p>启用该扩展程序，此时可顺利使用google了 </p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"安装vim\"><a href=\"#安装vim\" class=\"headerlink\" title=\"安装vim\"></a>安装vim</h3><p>vim编辑器需要安装三个包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim-enhanced-7.0.109-7.el5</div><div class=\"line\">vim-minimal-7.0.109-7.el5</div><div class=\"line\">vim-common-7.0.109-7.el5</div></pre></td></tr></table></figure>\n<p>输入  <code>rpm -qa|grep vim</code> 这个命令，如何vim已经正确安装，则会显示上面三个包的名称</p>\n<p>如果缺少了其中某个，比如说： vim-enhanced这个包少了，执行：<code>yum -y install vim-enhanced</code> 命令，它会自动下载安装</p>\n<p>如果上面三个包一个都没有显示，则直接输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum -y install vim*</div></pre></td></tr></table></figure>\n<h3 id=\"安装net-tools\"><a href=\"#安装net-tools\" class=\"headerlink\" title=\"安装net-tools\"></a>安装net-tools</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install net-tools</div></pre></td></tr></table></figure>\n<h3 id=\"更改文件所有者\"><a href=\"#更改文件所有者\" class=\"headerlink\" title=\"更改文件所有者\"></a>更改文件所有者</h3><p>chown -R www.www ./    将本路径下所有文件所有者改为www组的www</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://teddysun.com/342.html\" target=\"_blank\" rel=\"external\">Shadowsocks Python版一键安装脚本</a></p>\n<p><a href=\"https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/\" target=\"_blank\" rel=\"external\">使用 Shadowsocks 自建翻墙服务器，实现全平台 100% 翻墙无障碍</a></p>\n<p><a href=\"http://shadowsocks.org/en/download/clients.html\" target=\"_blank\" rel=\"external\">http://shadowsocks.org/</a></p>\n<p><a href=\"http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/\" target=\"_blank\" rel=\"external\">shadowsocks（影梭）不完全指南</a></p>\n","excerpt":"","more":"<blockquote>\n<p>今天折腾了一天，总算是把翻墙的梯子搭起来了，租了国外的vps，然后在上面搭建了shadowsocks服务，手机和电脑就可以使用shadowsocks客户端的方式科学上网了。<br>Shadowsocks 是一个由很多人参与的开源项目，感谢shadowsocks作者<a href=\"https://github.com/clowwindy/shadowsocks\">@clowwindy</a>.关于shadowssocks和vpn等等翻墙方式的区别,不再一一赘述，本文只是记录梯子搭建的过程</p>\n</blockquote>\n<h2 id=\"购买VPS\"><a href=\"#购买VPS\" class=\"headerlink\" title=\"购买VPS\"></a>购买VPS</h2><p>VPS的概念我也不是特别清楚，就把他当成主机好了，类似于阿里云等等。</p>\n<p>购买之后，会分配给你root账户密码，你就拥有了一台国外机房的主机。</p>\n<p>VPS 可以参考 <a href=\"https://www.zhihu.com/question/20800554\">有哪些便宜稳定，速度也不错的Linux VPS 推荐？</a>,我买了Vultr 日本机房的vps,充了5美刀先试试。具体的购买方法自行谷歌</p>\n<h2 id=\"搭建shadowsocks服务\"><a href=\"#搭建shadowsocks服务\" class=\"headerlink\" title=\"搭建shadowsocks服务\"></a>搭建shadowsocks服务</h2><h3 id=\"升级内核\"><a href=\"#升级内核\" class=\"headerlink\" title=\"升级内核\"></a>升级内核</h3><p>我选择了Centos7的Linux发型版本作为操作系统。</p>\n<p>使用MobaXterm(或者是其他ssh工具)连接到分配给你的主机(root密码购买成功时会给出),</p>\n<p>首先升级一下内核：wget -O- <a href=\"https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh\">https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh</a> | bash</p>\n<p>完成之后，重启：</p>\n<p>reboot</p>\n<p>重新登录，查看内核版本：</p>\n<p>uname -r</p>\n<p>不出意外已经更新到了最新版本。接着执行：</p>\n<p>sysctl -a|grep congestion_control</p>\n<p>如果输出选项包含：net.ipv4.tcp_congestion_control = bbr 表示安装成功，否则需要手动开启bbr模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">sysctl -p</div><div class=\"line\">sysctl</div><div class=\"line\">net.ipv4.tcp_available_congestion_control</div></pre></td></tr></table></figure>\n<p>再次查看：</p>\n<p>sysctl -a|grep congestion_control</p>\n<h3 id=\"搭建服务\"><a href=\"#搭建服务\" class=\"headerlink\" title=\"搭建服务\"></a>搭建服务</h3><p>搭建服务可以选择使用别人写好的现成的脚本，也可以自己搭建，下面介绍这两种方法：</p>\n<h4 id=\"使用现成脚本\"><a href=\"#使用现成脚本\" class=\"headerlink\" title=\"使用现成脚本\"></a>使用现成脚本</h4><p>执行以下命令：</p>\n<figure class=\"highlight plain\"><figcaption><span>--no-check-certificate</span><a href=\"https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\">link</a></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x shadowsocks.sh</div><div class=\"line\">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</div></pre></td></tr></table></figure>\n<p>首先会提示你输入密码和端口，然后开始安装。安装完成后代表shadowsocks服务已经开启了。此时可以使用shadowsocks客户端去连接这个服务器了。</p>\n<p>脚本可用的命令：</p>\n<p>启动：/etc/init.d/shadowsocks start</p>\n<p>停止：/etc/init.d/shadowsocks stop</p>\n<p>重启：/etc/init.d/shadowsocks restart</p>\n<p>状态：/etc/init.d/shadowsocks status</p>\n<p>卸载：./shadowsocks.sh uninstall</p>\n<p>支持多用户的方法：修改配置文件:/etc/shadowsocks.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;    </div><div class=\"line\">    &quot;server&quot;:&quot;0.0.0.0&quot;,</div><div class=\"line\">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;port_password&quot;:&#123;</div><div class=\"line\">         &quot;8989&quot;:&quot;password0&quot;,</div><div class=\"line\">         &quot;9001&quot;:&quot;password1&quot;,</div><div class=\"line\">         &quot;9002&quot;:&quot;password2&quot;,</div><div class=\"line\">         &quot;9003&quot;:&quot;password3&quot;,</div><div class=\"line\">         &quot;9004&quot;:&quot;password4&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"自行搭建\"><a href=\"#自行搭建\" class=\"headerlink\" title=\"自行搭建\"></a>自行搭建</h4><p>首先安装shadowsocks服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</div><div class=\"line\">pip install shadowsocks</div></pre></td></tr></table></figure>\n<p>显示 “Successfully installed shadowsocks-2.6.10″。意味着Shadowsocks已经成功安装。</p>\n<p>接着，创建一个Shadowsocks配置文件。输入以下命令：</p>\n<p>vi /etc/shadowsocks.json</p>\n<p>然后在该文件中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;server&quot;:&quot;your_server_ip&quot;,</div><div class=\"line\">    &quot;server_port&quot;:8388,</div><div class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;password&quot;:&quot;auooo.com&quot;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面各项配置的含义已经很明显了，除了server(vps的ip)、server_port和password之外，其他默认即可。保存该文件。执行：</p>\n<p>ssserver -c /etc/shadowsocks.json -d start</p>\n<p>服务就启动了，如果想要关闭，执行：</p>\n<p>ssserver -c /etc/shadowsocks.json -d stop</p>\n<p>支持多用户的方法与上面的类似</p>\n<h4 id=\"端口问题\"><a href=\"#端口问题\" class=\"headerlink\" title=\"端口问题\"></a>端口问题</h4><p>有时候服务正常启动了，但是发现客户端还是没有办法翻墙。这时要注意检查vps开放的端口：</p>\n<p>Centos升级到7之后，使用firewalld代替了原来的iptables作为防火墙。</p>\n<p>启动：systemctl start  firewalld</p>\n<p>重启：firewall-cmd –reload</p>\n<p>查看状态：systemctl status firewalld 或者 firewall-cmd –state  </p>\n<p>查看开放的端口：firewall-cmd –list-ports</p>\n<p>增加开放端口：firewall-cmd –add-port=9001/tcp –permanent   (重启生效)</p>\n<p>9001：要开放的端口</p>\n<p>tcp：协议</p>\n<p>–permanent：永久生效，没有此参数重启后失效其他命令自行查找</p>\n<h2 id=\"锐速加速\"><a href=\"#锐速加速\" class=\"headerlink\" title=\"锐速加速\"></a>锐速加速</h2><p><a href=\"https://www.91yun.org/archives/683\">锐速破解版linux一键自动安装包（8月7日更新）</a></p>\n<p>文章开头的更新内核使用bbr加速或者锐速加速都可以，没试过哪种方式效果更好一些</p>\n<h2 id=\"vps使用ssh密钥登录\"><a href=\"#vps使用ssh密钥登录\" class=\"headerlink\" title=\"vps使用ssh密钥登录\"></a>vps使用ssh密钥登录</h2><p>使用ssh root账户和密码登录的方式是vps一开始会给出的登录主机的方式，这种方式比较简单，但是容易被别人暴力破解登录密码，控制我们的主机。</p>\n<p>所以，应该使用ssh密钥登录的方式来增强安全性。</p>\n<h3 id=\"修改root密码\"><a href=\"#修改root密码\" class=\"headerlink\" title=\"修改root密码\"></a>修改root密码</h3><p>第一步应该先把默认的root密码修改为自己的密码，最好复杂一点。</p>\n<p>确保自己记住了这个密码。</p>\n<p>passwd</p>\n<h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><p>可以先创建一个非root用户：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">useradd yukai</div></pre></td></tr></table></figure>\n<p>创建账户密码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">passwd yukai</div></pre></td></tr></table></figure>\n<p>给予账户sudo权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">visudo</div></pre></td></tr></table></figure>\n<p>在 root ALL=(ALL)  ALL 下新增一行：</p>\n<p>yukai ALL=(ALL)  ALL</p>\n<p>切换到yukai这个账户：</p>\n<p>su - yukai </p>\n<h3 id=\"创建密钥\"><a href=\"#创建密钥\" class=\"headerlink\" title=\"创建密钥\"></a>创建密钥</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen -t rsa</div></pre></td></tr></table></figure>\n<p>在 /home/yukai 下生成了一个隐藏目录：.ssh, 执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~/.sshcat id_rsa.pub &gt;&gt; authorized_keys</div><div class=\"line\">chmod 600 authorized_keys</div></pre></td></tr></table></figure>\n<p>将 id_rsa文件下载下来保存到本地(使用MobaXterm等工具)</p>\n<h3 id=\"使用密钥认证登录\"><a href=\"#使用密钥认证登录\" class=\"headerlink\" title=\"使用密钥认证登录\"></a>使用密钥认证登录</h3><p>打开MobaXterm工具，新建一个session，选择ssh，在Advanced SSH settings选项中选择 use private keygen复选框，并把上一步下载好的id_rsa选择进来。</p>\n<p>以用户yukai登录，提示输入密钥文件的密码，输入生成密钥时所填的密码，如果能够登录，则设置正确了</p>\n<h3 id=\"禁用root用户登录和密码登录\"><a href=\"#禁用root用户登录和密码登录\" class=\"headerlink\" title=\"禁用root用户登录和密码登录\"></a>禁用root用户登录和密码登录</h3><p>确保自己记住了root密码，并且上一步密钥认证方式登录成功。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo vi /etc/ssh/sshd_config</div></pre></td></tr></table></figure>\n<p>找到以下几项，进行如下设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">RSAAuthentication yes</div><div class=\"line\">PubkeyAuthentication yes</div><div class=\"line\">PermitRootLogin no</div><div class=\"line\">PasswordAuthentication no</div></pre></td></tr></table></figure>\n<p>重启ssh服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service sshd restart</div></pre></td></tr></table></figure>\n<h3 id=\"多台主机管理\"><a href=\"#多台主机管理\" class=\"headerlink\" title=\"多台主机管理\"></a>多台主机管理</h3><p>可以将生成的密钥文件authorized_keys保存到多个主机的相同位置：~/.ssh</p>\n<p>然后进行上面的配置。此时就可以使用一份私钥文件id_rsa登录多个主机了。</p>\n<h2 id=\"ss多用户管理\"><a href=\"#ss多用户管理\" class=\"headerlink\" title=\"ss多用户管理\"></a>ss多用户管理</h2><p>前端使用ss-panel，后台使用shadowsocks-manyuser</p>\n<p>教程参见：</p>\n<p><a href=\"https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/\">可能是最好的 ss-panel 部署教程</a></p>\n<p><a href=\"https://blog.linuxeye.com/426.html\">ShadowSocks多用户管理系统搭建（moeSS+manyuser）</a></p>\n<h2 id=\"在Linux上使用shadowsocks服务翻墙\"><a href=\"#在Linux上使用shadowsocks服务翻墙\" class=\"headerlink\" title=\"在Linux上使用shadowsocks服务翻墙\"></a>在Linux上使用shadowsocks服务翻墙</h2><h3 id=\"开启shadowsocks客户端\"><a href=\"#开启shadowsocks客户端\" class=\"headerlink\" title=\"开启shadowsocks客户端\"></a>开启shadowsocks客户端</h3><p>确认安装了shadowsocks服务并从配置好的shadowsocks服务器端获得配置文件: /etc/shadowsocks/config.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">        &quot;server&quot;:&quot;remote-shadowsocks-server-ip-addr&quot;,</div><div class=\"line\">        &quot;server_port&quot;:443,</div><div class=\"line\">        &quot;local_address&quot;:&quot;127.0.0.1&quot;,</div><div class=\"line\">        &quot;local_port&quot;:1080,</div><div class=\"line\">        &quot;password&quot;:&quot;your-passwd&quot;,</div><div class=\"line\">        &quot;timeout&quot;:300,</div><div class=\"line\">        &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">        &quot;fast_open&quot;:false,</div><div class=\"line\">        &quot;workers&quot;:1</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在config.json所在目录下运行sslocal即可：</p>\n<p>sslocal -c /etc/shadowsocks/config.json</p>\n<p>也可以手动指定参数运行：</p>\n<p>sslocal -s 服务器地址 -p 服务器端口 -l 本地端端口 -k 密码 -m 加密方法</p>\n<h3 id=\"使用chrome代理\"><a href=\"#使用chrome代理\" class=\"headerlink\" title=\"使用chrome代理\"></a>使用chrome代理</h3><p>在chrome应用商店中查找 Proxy SwitchyOmega,并安装该扩展</p>\n<p>新建情景模式，代理协议选择SOCKS5，代理服务器选择 127.0.0.1， 代理端口选择上一步中的local_port,即1080</p>\n<p>启用该扩展程序，此时可顺利使用google了 </p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"安装vim\"><a href=\"#安装vim\" class=\"headerlink\" title=\"安装vim\"></a>安装vim</h3><p>vim编辑器需要安装三个包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim-enhanced-7.0.109-7.el5</div><div class=\"line\">vim-minimal-7.0.109-7.el5</div><div class=\"line\">vim-common-7.0.109-7.el5</div></pre></td></tr></table></figure>\n<p>输入  <code>rpm -qa|grep vim</code> 这个命令，如何vim已经正确安装，则会显示上面三个包的名称</p>\n<p>如果缺少了其中某个，比如说： vim-enhanced这个包少了，执行：<code>yum -y install vim-enhanced</code> 命令，它会自动下载安装</p>\n<p>如果上面三个包一个都没有显示，则直接输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum -y install vim*</div></pre></td></tr></table></figure>\n<h3 id=\"安装net-tools\"><a href=\"#安装net-tools\" class=\"headerlink\" title=\"安装net-tools\"></a>安装net-tools</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install net-tools</div></pre></td></tr></table></figure>\n<h3 id=\"更改文件所有者\"><a href=\"#更改文件所有者\" class=\"headerlink\" title=\"更改文件所有者\"></a>更改文件所有者</h3><p>chown -R www.www ./    将本路径下所有文件所有者改为www组的www</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://teddysun.com/342.html\">Shadowsocks Python版一键安装脚本</a></p>\n<p><a href=\"https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/\">使用 Shadowsocks 自建翻墙服务器，实现全平台 100% 翻墙无障碍</a></p>\n<p><a href=\"http://shadowsocks.org/en/download/clients.html\">http://shadowsocks.org/</a></p>\n<p><a href=\"http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/\">shadowsocks（影梭）不完全指南</a></p>\n"},{"layout":"post","title":"ANT编译java工程经jdk路径的设置","date":"2016-04-25T04:48:55.000Z","_content":"\n> 今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。\n\n打包过程中总是报：\n\n```java\n[javac] 警告: [options] 未与 -source 1.5 一起设置引导类路径\n[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:50: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()\n[javac] public class Driver implements java.sql.Driver {\n....\n```\n\n类似这样的一堆错误。\n\n没有过多的思考，百度之...出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。\n\n严重的浪费时间和影响心情，遂放弃。\n\n静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。\n\n后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。\n\n重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。\n\n等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’\n\n果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加\n\n```java\nexecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"\nfork=\"yes\"\n```\n\nBuild Successfull.\n\n这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：\n\n1.不要用百度\n\n2.先思考问题原因，再寻找解决方案\n\n3.学习英语，尽量用英文搜索\n\n## 参考\n\n[Change JDK for running <ANT> task from within build xml](http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml)\n\n\n","source":"_posts/ant编译java工程jdk路径的设置.md","raw":"---\nlayout: post\ntitle:  \"ANT编译java工程经jdk路径的设置\"\ncategories: 工具\ntags: \n- java\n- ant\ndate:   2016-04-25 12:48:55\n---\n\n> 今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。\n\n打包过程中总是报：\n\n```java\n[javac] 警告: [options] 未与 -source 1.5 一起设置引导类路径\n[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:50: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()\n[javac] public class Driver implements java.sql.Driver {\n....\n```\n\n类似这样的一堆错误。\n\n没有过多的思考，百度之...出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。\n\n严重的浪费时间和影响心情，遂放弃。\n\n静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。\n\n后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。\n\n重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。\n\n等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’\n\n果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加\n\n```java\nexecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"\nfork=\"yes\"\n```\n\nBuild Successfull.\n\n这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：\n\n1.不要用百度\n\n2.先思考问题原因，再寻找解决方案\n\n3.学习英语，尽量用英文搜索\n\n## 参考\n\n[Change JDK for running <ANT> task from within build xml](http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml)\n\n\n","slug":"ant编译java工程jdk路径的设置","published":1,"updated":"2017-02-19T13:08:11.032Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlqb000hvegcnc8ipmnz","content":"<blockquote>\n<p>今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。</p>\n</blockquote>\n<p>打包过程中总是报：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[javac] 警告: [options] 未与 -source <span class=\"number\">1.5</span> 一起设置引导类路径</div><div class=\"line\">[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:<span class=\"number\">50</span>: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()</div><div class=\"line\">[javac] <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>类似这样的一堆错误。</p>\n<p>没有过多的思考，百度之…出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。</p>\n<p>严重的浪费时间和影响心情，遂放弃。</p>\n<p>静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。</p>\n<p>后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。</p>\n<p>重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。</p>\n<p>等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’</p>\n<p>果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">executable=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"</span></div><div class=\"line\">fork=<span class=\"string\">\"yes\"</span></div></pre></td></tr></table></figure>\n<p>Build Successfull.</p>\n<p>这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：</p>\n<p>1.不要用百度</p>\n<p>2.先思考问题原因，再寻找解决方案</p>\n<p>3.学习英语，尽量用英文搜索</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml\" target=\"_blank\" rel=\"external\">Change JDK for running <ant> task from within build xml</ant></a></p>\n","excerpt":"","more":"<blockquote>\n<p>今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。</p>\n</blockquote>\n<p>打包过程中总是报：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[javac] 警告: [options] 未与 -source <span class=\"number\">1.5</span> 一起设置引导类路径</div><div class=\"line\">[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:<span class=\"number\">50</span>: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()</div><div class=\"line\">[javac] <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>类似这样的一堆错误。</p>\n<p>没有过多的思考，百度之…出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。</p>\n<p>严重的浪费时间和影响心情，遂放弃。</p>\n<p>静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。</p>\n<p>后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。</p>\n<p>重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。</p>\n<p>等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’</p>\n<p>果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">executable=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"</span></div><div class=\"line\">fork=<span class=\"string\">\"yes\"</span></div></pre></td></tr></table></figure>\n<p>Build Successfull.</p>\n<p>这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：</p>\n<p>1.不要用百度</p>\n<p>2.先思考问题原因，再寻找解决方案</p>\n<p>3.学习英语，尽量用英文搜索</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml\">Change JDK for running <ANT> task from within build xml</a></p>\n"},{"layout":"post","title":"centos7BCM驱动安装","date":"2017-02-25T03:22:45.000Z","_content":"> 前段时间安装了centos后，一直使用网线上网。今天是周末，安装了一下无线驱动，可以愉快的使用无线wifi上网啦～\n\n## 查看无线驱动\n\n```\niwconfig\n```\n如果没有iwconfig命令，则先安装：\n\n```\nsudo yum install wireless-tools\n```\n\n{% asset_img iwconfig.png iwconfig %}\n\n如上图显示有类似wlp7s0这样的信息，则表示无线驱动已经安装好了。若没有，则全部为no wireless extensions.\n\n没有安装无线驱动，进行下面的操作。\n\n## 查看网卡型号\n\n```\nlspci |grep -i network \n```\n\n显示：\n\n```\n07:00.0 Network controller: Broadcom Limited BCM43142 802.11b/g/n (rev 01)\n```\n\n表示是BCM的网卡\n\n## 查看内核信息\n\n```\nuname -r\n```\n显示内核信息：\n```\n3.10.0-514.6.1.el7.x86_64\n```\n注意上面的发行版版本为el6,后面64为64位操作系统\n\n## 编译安装驱动程序\n\n下面只针对el7 64的情况，其他配置的系统参考：[wl-kmod](http://elrepo.org/tiki/wl-kmod)\n\n1.安装工具\n```\nyum group install 'Development Tools'\n\nyum install redhat-lsb kernel-abi-whitelists\n\nyum install kernel-devel-$(uname -r)\n```\n\n2.切换到普通用户，配置构建树\n```\nmkdir -p ~/rpmbuild/{BUILD,RPMS,SPECS,SOURCES,SRPMS}\n\necho -e \"%_topdir $(echo $HOME)/rpmbuild\\n%dist .el$(lsb_release -s -r|cut -d\".\" -f1).local\" >> ~/.rpmmacros\n```\n\n3.下载 wl-kmod*nosrc.rpm 到任意目录，比如 ～/package\n[http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm](http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm)\n\n4.下载合适的驱动\n[http://www.broadcom.com/support/802.11]( http://www.broadcom.com/support/802.11)\n\n选择64位的驱动，下载到~/rpmbuild/SOURCES/目录\n\n5.构建kmod-wl\n```\n rpmbuild --rebuild --target=`uname -m` --define 'packager yukai' ~/package/wl-kmod*nosrc.rpm\n```\n\n其中，yukai是当前登陆用户，~/package/是第三步下载的rpm文件位置\n\n6.安装kmod-wl\n\n```\nrpm -Uvh /home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm\n```\n\n第五步构建完成之后,在～/rpmbuild/RPMS/x86_64目录会有kmod-wl*rpm文件生成，安装它即可\n\n7.删除不用的文件\n\n保存/home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm文件，然后删除～/rpmbuild/\n\n```\nrm -rf ～/rpmbuild/\n```\n\n8.重启即可\n\n{% asset_img demo.png demo %}","source":"_posts/centos7BCM驱动安装.md","raw":"---\nlayout: post\ntitle: centos7BCM驱动安装\ndate: 2017-02-25 11:22:45\ncategories: 工具\ntags: linux\n---\n> 前段时间安装了centos后，一直使用网线上网。今天是周末，安装了一下无线驱动，可以愉快的使用无线wifi上网啦～\n\n## 查看无线驱动\n\n```\niwconfig\n```\n如果没有iwconfig命令，则先安装：\n\n```\nsudo yum install wireless-tools\n```\n\n{% asset_img iwconfig.png iwconfig %}\n\n如上图显示有类似wlp7s0这样的信息，则表示无线驱动已经安装好了。若没有，则全部为no wireless extensions.\n\n没有安装无线驱动，进行下面的操作。\n\n## 查看网卡型号\n\n```\nlspci |grep -i network \n```\n\n显示：\n\n```\n07:00.0 Network controller: Broadcom Limited BCM43142 802.11b/g/n (rev 01)\n```\n\n表示是BCM的网卡\n\n## 查看内核信息\n\n```\nuname -r\n```\n显示内核信息：\n```\n3.10.0-514.6.1.el7.x86_64\n```\n注意上面的发行版版本为el6,后面64为64位操作系统\n\n## 编译安装驱动程序\n\n下面只针对el7 64的情况，其他配置的系统参考：[wl-kmod](http://elrepo.org/tiki/wl-kmod)\n\n1.安装工具\n```\nyum group install 'Development Tools'\n\nyum install redhat-lsb kernel-abi-whitelists\n\nyum install kernel-devel-$(uname -r)\n```\n\n2.切换到普通用户，配置构建树\n```\nmkdir -p ~/rpmbuild/{BUILD,RPMS,SPECS,SOURCES,SRPMS}\n\necho -e \"%_topdir $(echo $HOME)/rpmbuild\\n%dist .el$(lsb_release -s -r|cut -d\".\" -f1).local\" >> ~/.rpmmacros\n```\n\n3.下载 wl-kmod*nosrc.rpm 到任意目录，比如 ～/package\n[http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm](http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm)\n\n4.下载合适的驱动\n[http://www.broadcom.com/support/802.11]( http://www.broadcom.com/support/802.11)\n\n选择64位的驱动，下载到~/rpmbuild/SOURCES/目录\n\n5.构建kmod-wl\n```\n rpmbuild --rebuild --target=`uname -m` --define 'packager yukai' ~/package/wl-kmod*nosrc.rpm\n```\n\n其中，yukai是当前登陆用户，~/package/是第三步下载的rpm文件位置\n\n6.安装kmod-wl\n\n```\nrpm -Uvh /home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm\n```\n\n第五步构建完成之后,在～/rpmbuild/RPMS/x86_64目录会有kmod-wl*rpm文件生成，安装它即可\n\n7.删除不用的文件\n\n保存/home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm文件，然后删除～/rpmbuild/\n\n```\nrm -rf ～/rpmbuild/\n```\n\n8.重启即可\n\n{% asset_img demo.png demo %}","slug":"centos7BCM驱动安装","published":1,"updated":"2017-02-25T07:12:20.292Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlqh000kvegcxxkkimbc","content":"<blockquote>\n<p>前段时间安装了centos后，一直使用网线上网。今天是周末，安装了一下无线驱动，可以愉快的使用无线wifi上网啦～</p>\n</blockquote>\n<h2 id=\"查看无线驱动\"><a href=\"#查看无线驱动\" class=\"headerlink\" title=\"查看无线驱动\"></a>查看无线驱动</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">iwconfig</div></pre></td></tr></table></figure>\n<p>如果没有iwconfig命令，则先安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo yum install wireless-tools</div></pre></td></tr></table></figure>\n<img src=\"/2017/02/25/centos7BCM驱动安装/iwconfig.png\" alt=\"iwconfig\" title=\"iwconfig\">\n<p>如上图显示有类似wlp7s0这样的信息，则表示无线驱动已经安装好了。若没有，则全部为no wireless extensions.</p>\n<p>没有安装无线驱动，进行下面的操作。</p>\n<h2 id=\"查看网卡型号\"><a href=\"#查看网卡型号\" class=\"headerlink\" title=\"查看网卡型号\"></a>查看网卡型号</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lspci |grep -i network</div></pre></td></tr></table></figure>\n<p>显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">07:00.0 Network controller: Broadcom Limited BCM43142 802.11b/g/n (rev 01)</div></pre></td></tr></table></figure>\n<p>表示是BCM的网卡</p>\n<h2 id=\"查看内核信息\"><a href=\"#查看内核信息\" class=\"headerlink\" title=\"查看内核信息\"></a>查看内核信息</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">uname -r</div></pre></td></tr></table></figure>\n<p>显示内核信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">3.10.0-514.6.1.el7.x86_64</div></pre></td></tr></table></figure></p>\n<p>注意上面的发行版版本为el6,后面64为64位操作系统</p>\n<h2 id=\"编译安装驱动程序\"><a href=\"#编译安装驱动程序\" class=\"headerlink\" title=\"编译安装驱动程序\"></a>编译安装驱动程序</h2><p>下面只针对el7 64的情况，其他配置的系统参考：<a href=\"http://elrepo.org/tiki/wl-kmod\" target=\"_blank\" rel=\"external\">wl-kmod</a></p>\n<p>1.安装工具<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum group install &apos;Development Tools&apos;</div><div class=\"line\"></div><div class=\"line\">yum install redhat-lsb kernel-abi-whitelists</div><div class=\"line\"></div><div class=\"line\">yum install kernel-devel-$(uname -r)</div></pre></td></tr></table></figure></p>\n<p>2.切换到普通用户，配置构建树<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir -p ~/rpmbuild/&#123;BUILD,RPMS,SPECS,SOURCES,SRPMS&#125;</div><div class=\"line\"></div><div class=\"line\">echo -e &quot;%_topdir $(echo $HOME)/rpmbuild\\n%dist .el$(lsb_release -s -r|cut -d&quot;.&quot; -f1).local&quot; &gt;&gt; ~/.rpmmacros</div></pre></td></tr></table></figure></p>\n<p>3.下载 wl-kmod*nosrc.rpm 到任意目录，比如 ～/package<br><a href=\"http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm\" target=\"_blank\" rel=\"external\">http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm</a></p>\n<p>4.下载合适的驱动<br><a href=\"http://www.broadcom.com/support/802.11\" target=\"_blank\" rel=\"external\">http://www.broadcom.com/support/802.11</a></p>\n<p>选择64位的驱动，下载到~/rpmbuild/SOURCES/目录</p>\n<p>5.构建kmod-wl<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rpmbuild --rebuild --target=`uname -m` --define &apos;packager yukai&apos; ~/package/wl-kmod*nosrc.rpm</div></pre></td></tr></table></figure></p>\n<p>其中，yukai是当前登陆用户，~/package/是第三步下载的rpm文件位置</p>\n<p>6.安装kmod-wl</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rpm -Uvh /home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm</div></pre></td></tr></table></figure>\n<p>第五步构建完成之后,在～/rpmbuild/RPMS/x86_64目录会有kmod-wl*rpm文件生成，安装它即可</p>\n<p>7.删除不用的文件</p>\n<p>保存/home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm文件，然后删除～/rpmbuild/</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm -rf ～/rpmbuild/</div></pre></td></tr></table></figure>\n<p>8.重启即可</p>\n<img src=\"/2017/02/25/centos7BCM驱动安装/demo.png\" alt=\"demo\" title=\"demo\">","excerpt":"","more":"<blockquote>\n<p>前段时间安装了centos后，一直使用网线上网。今天是周末，安装了一下无线驱动，可以愉快的使用无线wifi上网啦～</p>\n</blockquote>\n<h2 id=\"查看无线驱动\"><a href=\"#查看无线驱动\" class=\"headerlink\" title=\"查看无线驱动\"></a>查看无线驱动</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">iwconfig</div></pre></td></tr></table></figure>\n<p>如果没有iwconfig命令，则先安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo yum install wireless-tools</div></pre></td></tr></table></figure>\n<img src=\"/2017/02/25/centos7BCM驱动安装/iwconfig.png\" alt=\"iwconfig\" title=\"iwconfig\">\n<p>如上图显示有类似wlp7s0这样的信息，则表示无线驱动已经安装好了。若没有，则全部为no wireless extensions.</p>\n<p>没有安装无线驱动，进行下面的操作。</p>\n<h2 id=\"查看网卡型号\"><a href=\"#查看网卡型号\" class=\"headerlink\" title=\"查看网卡型号\"></a>查看网卡型号</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lspci |grep -i network</div></pre></td></tr></table></figure>\n<p>显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">07:00.0 Network controller: Broadcom Limited BCM43142 802.11b/g/n (rev 01)</div></pre></td></tr></table></figure>\n<p>表示是BCM的网卡</p>\n<h2 id=\"查看内核信息\"><a href=\"#查看内核信息\" class=\"headerlink\" title=\"查看内核信息\"></a>查看内核信息</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">uname -r</div></pre></td></tr></table></figure>\n<p>显示内核信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">3.10.0-514.6.1.el7.x86_64</div></pre></td></tr></table></figure></p>\n<p>注意上面的发行版版本为el6,后面64为64位操作系统</p>\n<h2 id=\"编译安装驱动程序\"><a href=\"#编译安装驱动程序\" class=\"headerlink\" title=\"编译安装驱动程序\"></a>编译安装驱动程序</h2><p>下面只针对el7 64的情况，其他配置的系统参考：<a href=\"http://elrepo.org/tiki/wl-kmod\">wl-kmod</a></p>\n<p>1.安装工具<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum group install &apos;Development Tools&apos;</div><div class=\"line\"></div><div class=\"line\">yum install redhat-lsb kernel-abi-whitelists</div><div class=\"line\"></div><div class=\"line\">yum install kernel-devel-$(uname -r)</div></pre></td></tr></table></figure></p>\n<p>2.切换到普通用户，配置构建树<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir -p ~/rpmbuild/&#123;BUILD,RPMS,SPECS,SOURCES,SRPMS&#125;</div><div class=\"line\"></div><div class=\"line\">echo -e &quot;%_topdir $(echo $HOME)/rpmbuild\\n%dist .el$(lsb_release -s -r|cut -d&quot;.&quot; -f1).local&quot; &gt;&gt; ~/.rpmmacros</div></pre></td></tr></table></figure></p>\n<p>3.下载 wl-kmod*nosrc.rpm 到任意目录，比如 ～/package<br><a href=\"http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm\">http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm</a></p>\n<p>4.下载合适的驱动<br><a href=\"http://www.broadcom.com/support/802.11\">http://www.broadcom.com/support/802.11</a></p>\n<p>选择64位的驱动，下载到~/rpmbuild/SOURCES/目录</p>\n<p>5.构建kmod-wl<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rpmbuild --rebuild --target=`uname -m` --define &apos;packager yukai&apos; ~/package/wl-kmod*nosrc.rpm</div></pre></td></tr></table></figure></p>\n<p>其中，yukai是当前登陆用户，~/package/是第三步下载的rpm文件位置</p>\n<p>6.安装kmod-wl</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rpm -Uvh /home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm</div></pre></td></tr></table></figure>\n<p>第五步构建完成之后,在～/rpmbuild/RPMS/x86_64目录会有kmod-wl*rpm文件生成，安装它即可</p>\n<p>7.删除不用的文件</p>\n<p>保存/home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm文件，然后删除～/rpmbuild/</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm -rf ～/rpmbuild/</div></pre></td></tr></table></figure>\n<p>8.重启即可</p>\n<img src=\"/2017/02/25/centos7BCM驱动安装/demo.png\" alt=\"demo\" title=\"demo\">"},{"layout":"post","title":"java编程技巧","date":"2016-07-24T04:48:55.000Z","_content":"\n>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~\n\n **1**. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层\n\n **2**. if语句中,判断条件尽量不要使用if(!...)的形式，这样只会使代码更加难以理解\n\n **3**. 循环内不要不断创建对象引用，而应该：\n\n```java\n     Object obj = null;\n     for (int i = 0; i <= count; i++) { \n      obj = new Object(); \n     }\n```\n\n **4**. 不要在循环条件中重复计算变量，比如：\n\n```java\n    for (int i = 0; i <= obj.size(); i++){...}\n```\n\n **5**. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字\n\n **6**. 尽量采用懒加载的策略，即在需要的时候才创建,例如：\n\n```java\n    String str = \"aaa\";\n    if (i == 1) { \n       list.add(str);\n    }\n```\n\n建议替换为：\n\n```java\n\n\tif (i == 1) { \n     String str = \"aaa\"; list.add(str);\n   }\n```\n\n\n **7**. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码\n\n **8**. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能\n\n **9**. 使用&& ,\\|\\| 操作符时，将首先需要满足的条件置于操作符之前。因为&& 和 \\|\\| 具有短路性。另外，体会if(e. key==k\\|\\|k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用\\|\\|将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）\n\n **10**. 尽量用for each语句代替for循环\n\n **11**. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。\n\n **12**. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。\n       \n```java\n    if(\"hello\".equals(variable)){...}\n```\n\n **13**. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：\n\n```java\n    if(string.indexof(character) != -1){...}`\n```\n\n应改为：\n\n```java\n    if(string.indexof(character) >0 ){...}\n```\n\n **14**. 避免意外的赋值，比如：\n \n```java\n    if(variable == 5){...}`\n```\n\n应改为：\n\n```java\n    if(5 == variable){...}\n```\n\n避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出`if(variable = 5)`这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~\n\n **15**. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：\n\n```java\n\tif(array.length > 0){...}\n```\n\n应改为：\n\n```java\n\tif(array != null && array.length > 0){...}\n```\n\n\n **16**. 确保只有一个退出点。比如：\n\n```java\n    private boolean isEligible(int age){\n\n    \tif(age > 18) {\n\n    \t\treturn true;\n\n    \t} else {\n\n            return false;\n    \t}\n\n    }\n```\n\n应改为：\n\n```java\n    private boolean isEligible(int age){\n    \tboolean result;\n\n    \tif(age > 18) {\n\n    \t\tresult = true;\n\n    \t} else {\n\n            result = false;\n    \t}\n\n    \treturn result;\n    }\n```\n\n **17**. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。\n\n```java\n \tprivate boolean isEligible(final int age){...}\n```\n\n **18**. 把多个if语句组合成单一if语句。比如：\n\n```java\n\tif(age > 18){\n\t\tif(!man){...}\n\t}\n```\n\n应改为：\n\n```java\n\tif(age > 18 && !man){...}\n```\n\n **19**.  尽量不返回null\n\n null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。\n\n **20**. if嵌套不超过三层。\n\n **21**. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)\n\n实现RandomAccess接口的代表类：ArrayList\n未实现RandomAccess接口的代表类：LinkedList\n\n\n\n","source":"_posts/java_Tips.md","raw":"---\nlayout: post\ntitle: \"java编程技巧\"\ncategories: 编程\ntags: \n- java\ndate:   2016-7-24 12:48:55\n---\n\n>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~\n\n **1**. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层\n\n **2**. if语句中,判断条件尽量不要使用if(!...)的形式，这样只会使代码更加难以理解\n\n **3**. 循环内不要不断创建对象引用，而应该：\n\n```java\n     Object obj = null;\n     for (int i = 0; i <= count; i++) { \n      obj = new Object(); \n     }\n```\n\n **4**. 不要在循环条件中重复计算变量，比如：\n\n```java\n    for (int i = 0; i <= obj.size(); i++){...}\n```\n\n **5**. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字\n\n **6**. 尽量采用懒加载的策略，即在需要的时候才创建,例如：\n\n```java\n    String str = \"aaa\";\n    if (i == 1) { \n       list.add(str);\n    }\n```\n\n建议替换为：\n\n```java\n\n\tif (i == 1) { \n     String str = \"aaa\"; list.add(str);\n   }\n```\n\n\n **7**. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码\n\n **8**. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能\n\n **9**. 使用&& ,\\|\\| 操作符时，将首先需要满足的条件置于操作符之前。因为&& 和 \\|\\| 具有短路性。另外，体会if(e. key==k\\|\\|k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用\\|\\|将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）\n\n **10**. 尽量用for each语句代替for循环\n\n **11**. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。\n\n **12**. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。\n       \n```java\n    if(\"hello\".equals(variable)){...}\n```\n\n **13**. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：\n\n```java\n    if(string.indexof(character) != -1){...}`\n```\n\n应改为：\n\n```java\n    if(string.indexof(character) >0 ){...}\n```\n\n **14**. 避免意外的赋值，比如：\n \n```java\n    if(variable == 5){...}`\n```\n\n应改为：\n\n```java\n    if(5 == variable){...}\n```\n\n避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出`if(variable = 5)`这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~\n\n **15**. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：\n\n```java\n\tif(array.length > 0){...}\n```\n\n应改为：\n\n```java\n\tif(array != null && array.length > 0){...}\n```\n\n\n **16**. 确保只有一个退出点。比如：\n\n```java\n    private boolean isEligible(int age){\n\n    \tif(age > 18) {\n\n    \t\treturn true;\n\n    \t} else {\n\n            return false;\n    \t}\n\n    }\n```\n\n应改为：\n\n```java\n    private boolean isEligible(int age){\n    \tboolean result;\n\n    \tif(age > 18) {\n\n    \t\tresult = true;\n\n    \t} else {\n\n            result = false;\n    \t}\n\n    \treturn result;\n    }\n```\n\n **17**. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。\n\n```java\n \tprivate boolean isEligible(final int age){...}\n```\n\n **18**. 把多个if语句组合成单一if语句。比如：\n\n```java\n\tif(age > 18){\n\t\tif(!man){...}\n\t}\n```\n\n应改为：\n\n```java\n\tif(age > 18 && !man){...}\n```\n\n **19**.  尽量不返回null\n\n null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。\n\n **20**. if嵌套不超过三层。\n\n **21**. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)\n\n实现RandomAccess接口的代表类：ArrayList\n未实现RandomAccess接口的代表类：LinkedList\n\n\n\n","slug":"java_Tips","published":1,"updated":"2017-02-19T13:08:11.033Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlql000pvegcy8uodrcr","content":"<blockquote>\n<p>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~</p>\n</blockquote>\n<p> <strong>1</strong>. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层</p>\n<p> <strong>2</strong>. if语句中,判断条件尽量不要使用if(!…)的形式，这样只会使代码更加难以理解</p>\n<p> <strong>3</strong>. 循环内不要不断创建对象引用，而应该：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= count; i++) &#123; </div><div class=\"line\"> obj = <span class=\"keyword\">new</span> Object(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>4</strong>. 不要在循环条件中重复计算变量，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= obj.size(); i++)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>5</strong>. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字</p>\n<p> <strong>6</strong>. 尽量采用懒加载的策略，即在需要的时候才创建,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str = <span class=\"string\">\"aaa\"</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">   list.add(str);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>建议替换为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">    String str = <span class=\"string\">\"aaa\"</span>; list.add(str);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p> <strong>7</strong>. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码</p>\n<p> <strong>8</strong>. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能</p>\n<p> <strong>9</strong>. 使用&amp;&amp; ,|| 操作符时，将首先需要满足的条件置于操作符之前。因为&amp;&amp; 和 || 具有短路性。另外，体会if(e. key==k||k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用||将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）</p>\n<p> <strong>10</strong>. 尽量用for each语句代替for循环</p>\n<p> <strong>11</strong>. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。</p>\n<p> <strong>12</strong>. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">\"hello\"</span>.equals(variable))&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>13</strong>. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) != -<span class=\"number\">1</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) &gt;<span class=\"number\">0</span> )&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>14</strong>. 避免意外的赋值，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(variable == <span class=\"number\">5</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">5</span> == variable)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出<code>if(variable = 5)</code>这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~</p>\n<p> <strong>15</strong>. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array != <span class=\"keyword\">null</span> &amp;&amp; array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>16</strong>. 确保只有一个退出点。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">boolean</span> result;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tresult = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        result = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>17</strong>. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>18</strong>. 把多个if语句组合成单一if语句。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>)&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(!man)&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span> &amp;&amp; !man)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>19</strong>.  尽量不返回null</p>\n<p> null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。</p>\n<p> <strong>20</strong>. if嵌套不超过三层。</p>\n<p> <strong>21</strong>. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)</p>\n<p>实现RandomAccess接口的代表类：ArrayList<br>未实现RandomAccess接口的代表类：LinkedList</p>\n","excerpt":"","more":"<blockquote>\n<p>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~</p>\n</blockquote>\n<p> <strong>1</strong>. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层</p>\n<p> <strong>2</strong>. if语句中,判断条件尽量不要使用if(!…)的形式，这样只会使代码更加难以理解</p>\n<p> <strong>3</strong>. 循环内不要不断创建对象引用，而应该：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= count; i++) &#123; </div><div class=\"line\"> obj = <span class=\"keyword\">new</span> Object(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>4</strong>. 不要在循环条件中重复计算变量，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= obj.size(); i++)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>5</strong>. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字</p>\n<p> <strong>6</strong>. 尽量采用懒加载的策略，即在需要的时候才创建,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str = <span class=\"string\">\"aaa\"</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">   list.add(str);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>建议替换为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">    String str = <span class=\"string\">\"aaa\"</span>; list.add(str);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p> <strong>7</strong>. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码</p>\n<p> <strong>8</strong>. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能</p>\n<p> <strong>9</strong>. 使用&amp;&amp; ,|| 操作符时，将首先需要满足的条件置于操作符之前。因为&amp;&amp; 和 || 具有短路性。另外，体会if(e. key==k||k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用||将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）</p>\n<p> <strong>10</strong>. 尽量用for each语句代替for循环</p>\n<p> <strong>11</strong>. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。</p>\n<p> <strong>12</strong>. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">\"hello\"</span>.equals(variable))&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>13</strong>. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) != -<span class=\"number\">1</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) &gt;<span class=\"number\">0</span> )&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>14</strong>. 避免意外的赋值，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(variable == <span class=\"number\">5</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">5</span> == variable)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出<code>if(variable = 5)</code>这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~</p>\n<p> <strong>15</strong>. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array != <span class=\"keyword\">null</span> &amp;&amp; array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>16</strong>. 确保只有一个退出点。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">boolean</span> result;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tresult = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        result = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>17</strong>. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>18</strong>. 把多个if语句组合成单一if语句。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>)&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(!man)&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span> &amp;&amp; !man)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>19</strong>.  尽量不返回null</p>\n<p> null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。</p>\n<p> <strong>20</strong>. if嵌套不超过三层。</p>\n<p> <strong>21</strong>. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)</p>\n<p>实现RandomAccess接口的代表类：ArrayList<br>未实现RandomAccess接口的代表类：LinkedList</p>\n"},{"layout":"post","title":"java中的ThreadLocal","date":"2016-06-21T04:48:55.000Z","_content":"\n> 今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal...\n\n## **问题背景**：\n\n每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：\n\n```java\nLsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());\n```\n\n其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。\n\n遂改之：\n\n```java\nLsnVo lv = ((DispatchConnection) conn).getLsnVo();\n```\n\n将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。\n\n曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。\n\n后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！\n\nPS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29\n\nso,按照上面的改法问题解决了。\n\n那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。\n\n这就是ThreadLocal的一个典型应用场景。\n\n## **ThreadLocal原理**：\n\n使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。\n\nThreadLocal的set和get方法：\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n}\n\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            return (T)map.get(this);\n\n        // Maps are constructed lazily.  if the map for this thread\n        // doesn't exist, create it, with this ThreadLocal and its\n        // initial value as its only entry.\n        T value = initialValue();\n        createMap(t, value);\n        return value;\n}\n```\n\n可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。\n\n很容易明白他的工作原理。\n\n## **应用场景**\n\n之前看了网上很多资料说ThreadLocal的应用场景：\n\n1.解决了多线程共享对象的问题，\n\n2.实现线程间的数据隔离，每个线程都有他自己的变量副本。\n\n对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。\n\n对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。\n\n我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：\n\n1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。\n\n2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。\n\n所以，使用ThreadLocal的场景应该是这样：**这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。**\n\nPS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。\n\n另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。\n\n我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。\n\n## **2016/11/01更新**\n\n今天在地铁上看到了一篇不错的文章，介绍ThreadLocal内存泄漏的实例–ThreadLocal 内存泄露的实例分析.\n\n另外，该作者的另一篇blog，讲解ThreadLocal的原理，也很清晰深入分析 ThreadLocal 内存泄漏问题\n\n拜读完作者的文章后，回家又翻了一遍ThreadLocal的源码，认为和作者所要解释的一致，并且对ThreadLocal的理解更加深了。\n\n> ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread\n\n上面的话出自java doc\n\noracle鼓励我们将ThreadLocal对象声明为一个private static类型的变量A。结合上述文章和源码来看，A的生命周期将变得和保存他的类对象一样长，这样ThreadLocalMap中设置的A的弱引用就失去了弱引用的作用，该键A对应的value也不会得到释放，直到此线程销毁。这样一来，如果是使用了线程池的话，当该线程复用时，很有可能会取得错误的值，造成业务逻辑混乱。\n\n解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\n--------------------\n另外，有一个例子展示了ThreadLocal的应用场景，现在贴过来。同样来自java doc。例子虽然很简单，但是我觉得很生动的展示了Threadlocal的一个应用场景，让人豁然开朗。\n\n试想如果不采用ThreadLocal的话，我自己的做法应该会在创建的线程类里面增加一个字段，用来标明线程的id。但是这么做有两点问题：\n\n第一，增加了字段，挺low。\n\n第二，有很大的限制，你只能为自己实现的线程类里面加字段。但是往往有些线程不是我们自己定义的。\n\n这个例子很好的说明了怎么实现一个线程变量。\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\npublic class ThreadId {\n     // Atomic integer containing the next thread ID to be assigned\n     private static final AtomicInteger nextId = new AtomicInteger(0);\n     // Thread local variable containing each thread's ID\n     private static final ThreadLocal<Integer> threadId =\n         new ThreadLocal<Integer>() {\n             @Override protected Integer initialValue() {\n                 return nextId.getAndIncrement();\n         }\n     };\n     // Returns the current thread's unique ID, assigning it if necessary\n     public static int get() {\n         return threadId.get();\n     }\n}\n```\n","source":"_posts/java中的ThreadLocal.md","raw":"---\nlayout: post\ntitle:  \"java中的ThreadLocal\"\ncategories: 编程\ntags: \n- java\n- 多线程\ndate:   2016-06-21 12:48:55\n---\n\n> 今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal...\n\n## **问题背景**：\n\n每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：\n\n```java\nLsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());\n```\n\n其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。\n\n遂改之：\n\n```java\nLsnVo lv = ((DispatchConnection) conn).getLsnVo();\n```\n\n将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。\n\n曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。\n\n后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！\n\nPS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29\n\nso,按照上面的改法问题解决了。\n\n那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。\n\n这就是ThreadLocal的一个典型应用场景。\n\n## **ThreadLocal原理**：\n\n使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。\n\nThreadLocal的set和get方法：\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n}\n\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            return (T)map.get(this);\n\n        // Maps are constructed lazily.  if the map for this thread\n        // doesn't exist, create it, with this ThreadLocal and its\n        // initial value as its only entry.\n        T value = initialValue();\n        createMap(t, value);\n        return value;\n}\n```\n\n可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。\n\n很容易明白他的工作原理。\n\n## **应用场景**\n\n之前看了网上很多资料说ThreadLocal的应用场景：\n\n1.解决了多线程共享对象的问题，\n\n2.实现线程间的数据隔离，每个线程都有他自己的变量副本。\n\n对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。\n\n对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。\n\n我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：\n\n1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。\n\n2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。\n\n所以，使用ThreadLocal的场景应该是这样：**这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。**\n\nPS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。\n\n另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。\n\n我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。\n\n## **2016/11/01更新**\n\n今天在地铁上看到了一篇不错的文章，介绍ThreadLocal内存泄漏的实例–ThreadLocal 内存泄露的实例分析.\n\n另外，该作者的另一篇blog，讲解ThreadLocal的原理，也很清晰深入分析 ThreadLocal 内存泄漏问题\n\n拜读完作者的文章后，回家又翻了一遍ThreadLocal的源码，认为和作者所要解释的一致，并且对ThreadLocal的理解更加深了。\n\n> ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread\n\n上面的话出自java doc\n\noracle鼓励我们将ThreadLocal对象声明为一个private static类型的变量A。结合上述文章和源码来看，A的生命周期将变得和保存他的类对象一样长，这样ThreadLocalMap中设置的A的弱引用就失去了弱引用的作用，该键A对应的value也不会得到释放，直到此线程销毁。这样一来，如果是使用了线程池的话，当该线程复用时，很有可能会取得错误的值，造成业务逻辑混乱。\n\n解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\n--------------------\n另外，有一个例子展示了ThreadLocal的应用场景，现在贴过来。同样来自java doc。例子虽然很简单，但是我觉得很生动的展示了Threadlocal的一个应用场景，让人豁然开朗。\n\n试想如果不采用ThreadLocal的话，我自己的做法应该会在创建的线程类里面增加一个字段，用来标明线程的id。但是这么做有两点问题：\n\n第一，增加了字段，挺low。\n\n第二，有很大的限制，你只能为自己实现的线程类里面加字段。但是往往有些线程不是我们自己定义的。\n\n这个例子很好的说明了怎么实现一个线程变量。\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\npublic class ThreadId {\n     // Atomic integer containing the next thread ID to be assigned\n     private static final AtomicInteger nextId = new AtomicInteger(0);\n     // Thread local variable containing each thread's ID\n     private static final ThreadLocal<Integer> threadId =\n         new ThreadLocal<Integer>() {\n             @Override protected Integer initialValue() {\n                 return nextId.getAndIncrement();\n         }\n     };\n     // Returns the current thread's unique ID, assigning it if necessary\n     public static int get() {\n         return threadId.get();\n     }\n}\n```\n","slug":"java中的ThreadLocal","published":1,"updated":"2017-02-19T13:08:11.033Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlqo000svegc8exom9cy","content":"<blockquote>\n<p>今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal…</p>\n</blockquote>\n<h2 id=\"问题背景：\"><a href=\"#问题背景：\" class=\"headerlink\" title=\"问题背景：\"></a><strong>问题背景</strong>：</h2><p>每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());</div></pre></td></tr></table></figure>\n<p>其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。</p>\n<p>遂改之：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((DispatchConnection) conn).getLsnVo();</div></pre></td></tr></table></figure>\n<p>将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。</p>\n<p>曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。</p>\n<p>后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！</p>\n<p>PS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29</p>\n<p>so,按照上面的改法问题解决了。</p>\n<p>那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。</p>\n<p>这就是ThreadLocal的一个典型应用场景。</p>\n<h2 id=\"ThreadLocal原理：\"><a href=\"#ThreadLocal原理：\" class=\"headerlink\" title=\"ThreadLocal原理：\"></a><strong>ThreadLocal原理</strong>：</h2><p>使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。</p>\n<p>ThreadLocal的set和get方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> (T)map.get(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Maps are constructed lazily.  if the map for this thread</span></div><div class=\"line\">        <span class=\"comment\">// doesn't exist, create it, with this ThreadLocal and its</span></div><div class=\"line\">        <span class=\"comment\">// initial value as its only entry.</span></div><div class=\"line\">        T value = initialValue();</div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。</p>\n<p>很容易明白他的工作原理。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h2><p>之前看了网上很多资料说ThreadLocal的应用场景：</p>\n<p>1.解决了多线程共享对象的问题，</p>\n<p>2.实现线程间的数据隔离，每个线程都有他自己的变量副本。</p>\n<p>对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。</p>\n<p>对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。</p>\n<p>我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：</p>\n<p>1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。</p>\n<p>2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。</p>\n<p>所以，使用ThreadLocal的场景应该是这样：<strong>这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。</strong></p>\n<p>PS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。</p>\n<p>另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。</p>\n<p>我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。</p>\n<h2 id=\"2016-11-01更新\"><a href=\"#2016-11-01更新\" class=\"headerlink\" title=\"2016/11/01更新\"></a><strong>2016/11/01更新</strong></h2><p>今天在地铁上看到了一篇不错的文章，介绍ThreadLocal内存泄漏的实例–ThreadLocal 内存泄露的实例分析.</p>\n<p>另外，该作者的另一篇blog，讲解ThreadLocal的原理，也很清晰深入分析 ThreadLocal 内存泄漏问题</p>\n<p>拜读完作者的文章后，回家又翻了一遍ThreadLocal的源码，认为和作者所要解释的一致，并且对ThreadLocal的理解更加深了。</p>\n<blockquote>\n<p>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread</p>\n</blockquote>\n<p>上面的话出自java doc</p>\n<p>oracle鼓励我们将ThreadLocal对象声明为一个private static类型的变量A。结合上述文章和源码来看，A的生命周期将变得和保存他的类对象一样长，这样ThreadLocalMap中设置的A的弱引用就失去了弱引用的作用，该键A对应的value也不会得到释放，直到此线程销毁。这样一来，如果是使用了线程池的话，当该线程复用时，很有可能会取得错误的值，造成业务逻辑混乱。</p>\n<h2 id=\"解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\"><a href=\"#解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\" class=\"headerlink\" title=\"解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\"></a>解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。</h2><p>另外，有一个例子展示了ThreadLocal的应用场景，现在贴过来。同样来自java doc。例子虽然很简单，但是我觉得很生动的展示了Threadlocal的一个应用场景，让人豁然开朗。</p>\n<p>试想如果不采用ThreadLocal的话，我自己的做法应该会在创建的线程类里面增加一个字段，用来标明线程的id。但是这么做有两点问题：</p>\n<p>第一，增加了字段，挺low。</p>\n<p>第二，有很大的限制，你只能为自己实现的线程类里面加字段。但是往往有些线程不是我们自己定义的。</p>\n<p>这个例子很好的说明了怎么实现一个线程变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadId</span> </span>&#123;</div><div class=\"line\">     <span class=\"comment\">// Atomic integer containing the next thread ID to be assigned</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicInteger nextId = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</div><div class=\"line\">     <span class=\"comment\">// Thread local variable containing each thread's ID</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Integer&gt; threadId =</div><div class=\"line\">         <span class=\"keyword\">new</span> ThreadLocal&lt;Integer&gt;() &#123;</div><div class=\"line\">             <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                 <span class=\"keyword\">return</span> nextId.getAndIncrement();</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;;</div><div class=\"line\">     <span class=\"comment\">// Returns the current thread's unique ID, assigning it if necessary</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> threadId.get();</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<blockquote>\n<p>今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal…</p>\n</blockquote>\n<h2 id=\"问题背景：\"><a href=\"#问题背景：\" class=\"headerlink\" title=\"问题背景：\"></a><strong>问题背景</strong>：</h2><p>每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());</div></pre></td></tr></table></figure>\n<p>其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。</p>\n<p>遂改之：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((DispatchConnection) conn).getLsnVo();</div></pre></td></tr></table></figure>\n<p>将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。</p>\n<p>曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。</p>\n<p>后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！</p>\n<p>PS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29</p>\n<p>so,按照上面的改法问题解决了。</p>\n<p>那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。</p>\n<p>这就是ThreadLocal的一个典型应用场景。</p>\n<h2 id=\"ThreadLocal原理：\"><a href=\"#ThreadLocal原理：\" class=\"headerlink\" title=\"ThreadLocal原理：\"></a><strong>ThreadLocal原理</strong>：</h2><p>使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。</p>\n<p>ThreadLocal的set和get方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> (T)map.get(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Maps are constructed lazily.  if the map for this thread</span></div><div class=\"line\">        <span class=\"comment\">// doesn't exist, create it, with this ThreadLocal and its</span></div><div class=\"line\">        <span class=\"comment\">// initial value as its only entry.</span></div><div class=\"line\">        T value = initialValue();</div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。</p>\n<p>很容易明白他的工作原理。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h2><p>之前看了网上很多资料说ThreadLocal的应用场景：</p>\n<p>1.解决了多线程共享对象的问题，</p>\n<p>2.实现线程间的数据隔离，每个线程都有他自己的变量副本。</p>\n<p>对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。</p>\n<p>对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。</p>\n<p>我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：</p>\n<p>1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。</p>\n<p>2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。</p>\n<p>所以，使用ThreadLocal的场景应该是这样：<strong>这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。</strong></p>\n<p>PS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。</p>\n<p>另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。</p>\n<p>我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。</p>\n<h2 id=\"2016-11-01更新\"><a href=\"#2016-11-01更新\" class=\"headerlink\" title=\"2016/11/01更新\"></a><strong>2016/11/01更新</strong></h2><p>今天在地铁上看到了一篇不错的文章，介绍ThreadLocal内存泄漏的实例–ThreadLocal 内存泄露的实例分析.</p>\n<p>另外，该作者的另一篇blog，讲解ThreadLocal的原理，也很清晰深入分析 ThreadLocal 内存泄漏问题</p>\n<p>拜读完作者的文章后，回家又翻了一遍ThreadLocal的源码，认为和作者所要解释的一致，并且对ThreadLocal的理解更加深了。</p>\n<blockquote>\n<p>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread</p>\n</blockquote>\n<p>上面的话出自java doc</p>\n<p>oracle鼓励我们将ThreadLocal对象声明为一个private static类型的变量A。结合上述文章和源码来看，A的生命周期将变得和保存他的类对象一样长，这样ThreadLocalMap中设置的A的弱引用就失去了弱引用的作用，该键A对应的value也不会得到释放，直到此线程销毁。这样一来，如果是使用了线程池的话，当该线程复用时，很有可能会取得错误的值，造成业务逻辑混乱。</p>\n<h2 id=\"解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\"><a href=\"#解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\" class=\"headerlink\" title=\"解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\"></a>解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。</h2><p>另外，有一个例子展示了ThreadLocal的应用场景，现在贴过来。同样来自java doc。例子虽然很简单，但是我觉得很生动的展示了Threadlocal的一个应用场景，让人豁然开朗。</p>\n<p>试想如果不采用ThreadLocal的话，我自己的做法应该会在创建的线程类里面增加一个字段，用来标明线程的id。但是这么做有两点问题：</p>\n<p>第一，增加了字段，挺low。</p>\n<p>第二，有很大的限制，你只能为自己实现的线程类里面加字段。但是往往有些线程不是我们自己定义的。</p>\n<p>这个例子很好的说明了怎么实现一个线程变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadId</span> </span>&#123;</div><div class=\"line\">     <span class=\"comment\">// Atomic integer containing the next thread ID to be assigned</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicInteger nextId = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</div><div class=\"line\">     <span class=\"comment\">// Thread local variable containing each thread's ID</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Integer&gt; threadId =</div><div class=\"line\">         <span class=\"keyword\">new</span> ThreadLocal&lt;Integer&gt;() &#123;</div><div class=\"line\">             <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                 <span class=\"keyword\">return</span> nextId.getAndIncrement();</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;;</div><div class=\"line\">     <span class=\"comment\">// Returns the current thread's unique ID, assigning it if necessary</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> threadId.get();</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"通过HashMap认识equals与hashcode","date":"2016-04-28T04:48:55.000Z","_content":"\n>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。\n\n## 什么是hashcode,hashcode的作用是什么\n\nhashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。\n\n理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，根据hashcode可以找到记录的位置。\n\n按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。\n\nhashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。\n\n注：以下代码均来自jdk1.7\n\nString中hashCode()方法的实现：\n\n```java\npublic int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            char val[] = value;\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n}\n```\n\n## 什么是equals(Object obj)方法\n\nequals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：\n\n```java\npublic boolean equals(Object obj) {\n        return (this == obj);\n}\n```\n\n也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。\n\n这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。\n\nString中equals(Object obj)方法的实现：\n\n```java\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String) anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                            return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n}\n```\n\n## 在java中hashcode方法与equals方法的作用\n\n首先看一下HashMap中的put方法：\n\n```java\npublic V put(K key, V value) {\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n        if (key == null)\n            return putForNullKey(value);\n        int hash = hash(key);//得到hash值\n        int i = indexFor(hash, table.length);//找到槽\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n\n        modCount++;\n        addEntry(hash, key, value, i);\n        return null;\n    }\n\n```\n\n我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。\n\n首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：\n\n```java\nfinal int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n可以看到，这个方法里调用了key本身的hashCode方法，得到了key的hashcode，然后对该hashcode进行了一些移位操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，通过他可以找到记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？\n\n其实这样做的目的是为下面的函数做准备的，我们看接下来要执行的代码：\n\n`int i = indexFor(hash, table.length);`找到所谓的槽，也就是记录存在的位置。\n\n```\n/**\n  * Returns index for hash code h.\n  */\nstatic int indexFor(int h, int length) {\n     // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";\n    return h & (length-1);\n}\n```\n可以看到，indexFor(int h, int length)如何通过hashcode得到记录的位置。indexFor方法内部是一个取模运算，h是我们通过上面的hash方法得到的，length是散列表的长度。HashMap中的散列表是一个数组，通过取模运算能保证indexFor方法的返回值(记录的位置)一定在这个数组内，没有超过其长度。因为h往往是一个很大的数字(int可以表示40亿这么大的数字)，而散列表的初始长度是可以由我们指定的(默认是16),另一方面，就算给他这么大的数组，内存也是放不下的。所以取模运算是必须的。经过取模运算得到的才是真正的槽值。\n\n回到上一个问题，**为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？而不是直接使用key的hashcode的**？\n\n想明白这个问题，参考[JDK 源码中 HashMap 的 hash 方法原理是什么？](https://www.zhihu.com/question/20733617)。我们上面也说了这样做的目的是为indexFor方法做准备的，总的来说就是为了让取模运算不会出现一种极端情况：**大量的不同的h经过取模后返回同样的槽值**。这样会带来严重的性能问题，也就是严重的冲突情况导致性能下降。关于冲突，看下文。\n\n要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。\n\n散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？\n\n比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？也就是说，无限多的元素通过散列函数映射到有穷集合上，一定会产生冲突。这也是我们理解hashcode的一个重要的点：**不同的对象(equals返回false)可以有相同的hashcode**。\n\n那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：\n\n{% asset_img entry.png 冲突 %}\n\n其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3....为散列表的索引位置。\n\n接下来的代码  `for (Entry<K,V> e = table[i]; e != null; e = e.next)`就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：`addEntry(hash, key, value, i);`.\n\n那么，怎么判断两个关键码在逻辑上是否相同呢？\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`\n\n可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：·`e.hash == hash `。为什么要加这样的判断？回头看看indexFor方法，经过取模运算后，不同的hashcode可以被散列在同一个槽中。通过这句代码可以将那些因为取模运算散列到同一个槽里的不同对象排除。\n\n我们知道**不同的对象(equals返回false)可以有相同的hashcode**。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：**相同的对象(equals返回true)hashcode一定相等**。\n\n`e.hash == hash && ((k = e.key) == key`：这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断**关键码是否相等**，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。\n\n`key.equals(k)`：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`这句代码中其实包含了一种短路思想，\\|\\| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。\n\n至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。\n\n## 总结\n\n通过上面的分析，我们知道了hashcode与equals的几个关键：\n\n#### 1.**不同的对象(equals返回false)可以有相同的hashcode**\n\n#### 2.**相同的对象(equals返回true)hashcode一定相等**\n\n#### 3.**若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义**（对1、2的遵守）\n\n[关于如何重写equals方法与hashCode方法](http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java)\n\n## equals与==\n\n\"==\" 比较的是两个对象的内存地址，是物理意义上的相等\n\nequals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等\n\n两个对象进行比较：\n\n**== 返回true，则equals一定返回true**；\n\n**equals返回true，== 不一定返回true**。\n\n\n\n\n\n\n\n","source":"_posts/java中的equals与hashcode.md","raw":"---\nlayout: post\ntitle:  \"通过HashMap认识equals与hashcode\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-28 12:48:55\n---\n\n>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。\n\n## 什么是hashcode,hashcode的作用是什么\n\nhashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。\n\n理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，根据hashcode可以找到记录的位置。\n\n按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。\n\nhashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。\n\n注：以下代码均来自jdk1.7\n\nString中hashCode()方法的实现：\n\n```java\npublic int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            char val[] = value;\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n}\n```\n\n## 什么是equals(Object obj)方法\n\nequals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：\n\n```java\npublic boolean equals(Object obj) {\n        return (this == obj);\n}\n```\n\n也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。\n\n这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。\n\nString中equals(Object obj)方法的实现：\n\n```java\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String) anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                            return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n}\n```\n\n## 在java中hashcode方法与equals方法的作用\n\n首先看一下HashMap中的put方法：\n\n```java\npublic V put(K key, V value) {\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n        if (key == null)\n            return putForNullKey(value);\n        int hash = hash(key);//得到hash值\n        int i = indexFor(hash, table.length);//找到槽\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n\n        modCount++;\n        addEntry(hash, key, value, i);\n        return null;\n    }\n\n```\n\n我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。\n\n首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：\n\n```java\nfinal int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n可以看到，这个方法里调用了key本身的hashCode方法，得到了key的hashcode，然后对该hashcode进行了一些移位操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，通过他可以找到记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？\n\n其实这样做的目的是为下面的函数做准备的，我们看接下来要执行的代码：\n\n`int i = indexFor(hash, table.length);`找到所谓的槽，也就是记录存在的位置。\n\n```\n/**\n  * Returns index for hash code h.\n  */\nstatic int indexFor(int h, int length) {\n     // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";\n    return h & (length-1);\n}\n```\n可以看到，indexFor(int h, int length)如何通过hashcode得到记录的位置。indexFor方法内部是一个取模运算，h是我们通过上面的hash方法得到的，length是散列表的长度。HashMap中的散列表是一个数组，通过取模运算能保证indexFor方法的返回值(记录的位置)一定在这个数组内，没有超过其长度。因为h往往是一个很大的数字(int可以表示40亿这么大的数字)，而散列表的初始长度是可以由我们指定的(默认是16),另一方面，就算给他这么大的数组，内存也是放不下的。所以取模运算是必须的。经过取模运算得到的才是真正的槽值。\n\n回到上一个问题，**为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？而不是直接使用key的hashcode的**？\n\n想明白这个问题，参考[JDK 源码中 HashMap 的 hash 方法原理是什么？](https://www.zhihu.com/question/20733617)。我们上面也说了这样做的目的是为indexFor方法做准备的，总的来说就是为了让取模运算不会出现一种极端情况：**大量的不同的h经过取模后返回同样的槽值**。这样会带来严重的性能问题，也就是严重的冲突情况导致性能下降。关于冲突，看下文。\n\n要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。\n\n散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？\n\n比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？也就是说，无限多的元素通过散列函数映射到有穷集合上，一定会产生冲突。这也是我们理解hashcode的一个重要的点：**不同的对象(equals返回false)可以有相同的hashcode**。\n\n那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：\n\n{% asset_img entry.png 冲突 %}\n\n其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3....为散列表的索引位置。\n\n接下来的代码  `for (Entry<K,V> e = table[i]; e != null; e = e.next)`就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：`addEntry(hash, key, value, i);`.\n\n那么，怎么判断两个关键码在逻辑上是否相同呢？\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`\n\n可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：·`e.hash == hash `。为什么要加这样的判断？回头看看indexFor方法，经过取模运算后，不同的hashcode可以被散列在同一个槽中。通过这句代码可以将那些因为取模运算散列到同一个槽里的不同对象排除。\n\n我们知道**不同的对象(equals返回false)可以有相同的hashcode**。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：**相同的对象(equals返回true)hashcode一定相等**。\n\n`e.hash == hash && ((k = e.key) == key`：这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断**关键码是否相等**，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。\n\n`key.equals(k)`：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`这句代码中其实包含了一种短路思想，\\|\\| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。\n\n至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。\n\n## 总结\n\n通过上面的分析，我们知道了hashcode与equals的几个关键：\n\n#### 1.**不同的对象(equals返回false)可以有相同的hashcode**\n\n#### 2.**相同的对象(equals返回true)hashcode一定相等**\n\n#### 3.**若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义**（对1、2的遵守）\n\n[关于如何重写equals方法与hashCode方法](http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java)\n\n## equals与==\n\n\"==\" 比较的是两个对象的内存地址，是物理意义上的相等\n\nequals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等\n\n两个对象进行比较：\n\n**== 返回true，则equals一定返回true**；\n\n**equals返回true，== 不一定返回true**。\n\n\n\n\n\n\n\n","slug":"java中的equals与hashcode","published":1,"updated":"2017-02-19T13:08:11.033Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlqq000xvegcadtqlue0","content":"<blockquote>\n<p>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。</p>\n</blockquote>\n<h2 id=\"什么是hashcode-hashcode的作用是什么\"><a href=\"#什么是hashcode-hashcode的作用是什么\" class=\"headerlink\" title=\"什么是hashcode,hashcode的作用是什么\"></a>什么是hashcode,hashcode的作用是什么</h2><p>hashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。</p>\n<p>理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，根据hashcode可以找到记录的位置。</p>\n<p>按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。</p>\n<p>hashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。</p>\n<p>注：以下代码均来自jdk1.7</p>\n<p>String中hashCode()方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hash;</div><div class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">char</span> val[] = value;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</div><div class=\"line\">                h = <span class=\"number\">31</span> * h + val[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            hash = h;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> h;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"什么是equals-Object-obj-方法\"><a href=\"#什么是equals-Object-obj-方法\" class=\"headerlink\" title=\"什么是equals(Object obj)方法\"></a>什么是equals(Object obj)方法</h2><p>equals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。</p>\n<p>这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。</p>\n<p>String中equals(Object obj)方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            String anotherString = (String) anObject;</div><div class=\"line\">            <span class=\"keyword\">int</span> n = value.length;</div><div class=\"line\">            <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> v1[] = value;</div><div class=\"line\">                <span class=\"keyword\">char</span> v2[] = anotherString.value;</div><div class=\"line\">                <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (v1[i] != v2[i])</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                    i++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"在java中hashcode方法与equals方法的作用\"><a href=\"#在java中hashcode方法与equals方法的作用\" class=\"headerlink\" title=\"在java中hashcode方法与equals方法的作用\"></a>在java中hashcode方法与equals方法的作用</h2><p>首先看一下HashMap中的put方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</div><div class=\"line\">            inflateTable(threshold);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> putForNullKey(value);</div><div class=\"line\">        <span class=\"keyword\">int</span> hash = hash(key);<span class=\"comment\">//得到hash值</span></div><div class=\"line\">        <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//找到槽</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\">            Object k;</div><div class=\"line\">            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class=\"line\">                V oldValue = e.value;</div><div class=\"line\">                e.value = value;</div><div class=\"line\">                e.recordAccess(<span class=\"keyword\">this</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        modCount++;</div><div class=\"line\">        addEntry(hash, key, value, i);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。</p>\n<p>首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hashSeed;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != h &amp;&amp; k <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        h ^= k.hashCode();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></div><div class=\"line\">        <span class=\"comment\">// constant multiples at each bit position have a bounded</span></div><div class=\"line\">        <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></div><div class=\"line\">        h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这个方法里调用了key本身的hashCode方法，得到了key的hashcode，然后对该hashcode进行了一些移位操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，通过他可以找到记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？</p>\n<p>其实这样做的目的是为下面的函数做准备的，我们看接下来要执行的代码：</p>\n<p><code>int i = indexFor(hash, table.length);</code>找到所谓的槽，也就是记录存在的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">  * Returns index for hash code h.</div><div class=\"line\">  */</div><div class=\"line\">static int indexFor(int h, int length) &#123;</div><div class=\"line\">     // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</div><div class=\"line\">    return h &amp; (length-1);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，indexFor(int h, int length)如何通过hashcode得到记录的位置。indexFor方法内部是一个取模运算，h是我们通过上面的hash方法得到的，length是散列表的长度。HashMap中的散列表是一个数组，通过取模运算能保证indexFor方法的返回值(记录的位置)一定在这个数组内，没有超过其长度。因为h往往是一个很大的数字(int可以表示40亿这么大的数字)，而散列表的初始长度是可以由我们指定的(默认是16),另一方面，就算给他这么大的数组，内存也是放不下的。所以取模运算是必须的。经过取模运算得到的才是真正的槽值。</p>\n<p>回到上一个问题，<strong>为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？而不是直接使用key的hashcode的</strong>？</p>\n<p>想明白这个问题，参考<a href=\"https://www.zhihu.com/question/20733617\" target=\"_blank\" rel=\"external\">JDK 源码中 HashMap 的 hash 方法原理是什么？</a>。我们上面也说了这样做的目的是为indexFor方法做准备的，总的来说就是为了让取模运算不会出现一种极端情况：<strong>大量的不同的h经过取模后返回同样的槽值</strong>。这样会带来严重的性能问题，也就是严重的冲突情况导致性能下降。关于冲突，看下文。</p>\n<p>要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。</p>\n<p>散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？</p>\n<p>比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？也就是说，无限多的元素通过散列函数映射到有穷集合上，一定会产生冲突。这也是我们理解hashcode的一个重要的点：<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。</p>\n<p>那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：</p>\n<img src=\"/2016/04/28/java中的equals与hashcode/entry.png\" alt=\"冲突\" title=\"冲突\">\n<p>其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3….为散列表的索引位置。</p>\n<p>接下来的代码  <code>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next)</code>就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：<code>addEntry(hash, key, value, i);</code>.</p>\n<p>那么，怎么判断两个关键码在逻辑上是否相同呢？</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code></p>\n<p>可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：·<code>e.hash == hash</code>。为什么要加这样的判断？回头看看indexFor方法，经过取模运算后，不同的hashcode可以被散列在同一个槽中。通过这句代码可以将那些因为取模运算散列到同一个槽里的不同对象排除。</p>\n<p>我们知道<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：<strong>相同的对象(equals返回true)hashcode一定相等</strong>。</p>\n<p><code>e.hash == hash &amp;&amp; ((k = e.key) == key</code>：这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断<strong>关键码是否相等</strong>，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。</p>\n<p><code>key.equals(k)</code>：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>这句代码中其实包含了一种短路思想，|| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。</p>\n<p>至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面的分析，我们知道了hashcode与equals的几个关键：</p>\n<h4 id=\"1-不同的对象-equals返回false-可以有相同的hashcode\"><a href=\"#1-不同的对象-equals返回false-可以有相同的hashcode\" class=\"headerlink\" title=\"1.不同的对象(equals返回false)可以有相同的hashcode\"></a>1.<strong>不同的对象(equals返回false)可以有相同的hashcode</strong></h4><h4 id=\"2-相同的对象-equals返回true-hashcode一定相等\"><a href=\"#2-相同的对象-equals返回true-hashcode一定相等\" class=\"headerlink\" title=\"2.相同的对象(equals返回true)hashcode一定相等\"></a>2.<strong>相同的对象(equals返回true)hashcode一定相等</strong></h4><h4 id=\"3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"><a href=\"#3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\" class=\"headerlink\" title=\"3.若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"></a>3.<strong>若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义</strong>（对1、2的遵守）</h4><p><a href=\"http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java\" target=\"_blank\" rel=\"external\">关于如何重写equals方法与hashCode方法</a></p>\n<h2 id=\"equals与\"><a href=\"#equals与\" class=\"headerlink\" title=\"equals与==\"></a>equals与==</h2><p>“==” 比较的是两个对象的内存地址，是物理意义上的相等</p>\n<p>equals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等</p>\n<p>两个对象进行比较：</p>\n<p><strong>== 返回true，则equals一定返回true</strong>；</p>\n<p><strong>equals返回true，== 不一定返回true</strong>。</p>\n","excerpt":"","more":"<blockquote>\n<p>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。</p>\n</blockquote>\n<h2 id=\"什么是hashcode-hashcode的作用是什么\"><a href=\"#什么是hashcode-hashcode的作用是什么\" class=\"headerlink\" title=\"什么是hashcode,hashcode的作用是什么\"></a>什么是hashcode,hashcode的作用是什么</h2><p>hashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。</p>\n<p>理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，根据hashcode可以找到记录的位置。</p>\n<p>按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。</p>\n<p>hashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。</p>\n<p>注：以下代码均来自jdk1.7</p>\n<p>String中hashCode()方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hash;</div><div class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">char</span> val[] = value;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</div><div class=\"line\">                h = <span class=\"number\">31</span> * h + val[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            hash = h;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> h;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"什么是equals-Object-obj-方法\"><a href=\"#什么是equals-Object-obj-方法\" class=\"headerlink\" title=\"什么是equals(Object obj)方法\"></a>什么是equals(Object obj)方法</h2><p>equals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。</p>\n<p>这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。</p>\n<p>String中equals(Object obj)方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            String anotherString = (String) anObject;</div><div class=\"line\">            <span class=\"keyword\">int</span> n = value.length;</div><div class=\"line\">            <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> v1[] = value;</div><div class=\"line\">                <span class=\"keyword\">char</span> v2[] = anotherString.value;</div><div class=\"line\">                <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (v1[i] != v2[i])</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                    i++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"在java中hashcode方法与equals方法的作用\"><a href=\"#在java中hashcode方法与equals方法的作用\" class=\"headerlink\" title=\"在java中hashcode方法与equals方法的作用\"></a>在java中hashcode方法与equals方法的作用</h2><p>首先看一下HashMap中的put方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</div><div class=\"line\">            inflateTable(threshold);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> putForNullKey(value);</div><div class=\"line\">        <span class=\"keyword\">int</span> hash = hash(key);<span class=\"comment\">//得到hash值</span></div><div class=\"line\">        <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//找到槽</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\">            Object k;</div><div class=\"line\">            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class=\"line\">                V oldValue = e.value;</div><div class=\"line\">                e.value = value;</div><div class=\"line\">                e.recordAccess(<span class=\"keyword\">this</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        modCount++;</div><div class=\"line\">        addEntry(hash, key, value, i);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。</p>\n<p>首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hashSeed;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != h &amp;&amp; k <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        h ^= k.hashCode();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></div><div class=\"line\">        <span class=\"comment\">// constant multiples at each bit position have a bounded</span></div><div class=\"line\">        <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></div><div class=\"line\">        h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这个方法里调用了key本身的hashCode方法，得到了key的hashcode，然后对该hashcode进行了一些移位操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，通过他可以找到记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？</p>\n<p>其实这样做的目的是为下面的函数做准备的，我们看接下来要执行的代码：</p>\n<p><code>int i = indexFor(hash, table.length);</code>找到所谓的槽，也就是记录存在的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">  * Returns index for hash code h.</div><div class=\"line\">  */</div><div class=\"line\">static int indexFor(int h, int length) &#123;</div><div class=\"line\">     // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</div><div class=\"line\">    return h &amp; (length-1);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，indexFor(int h, int length)如何通过hashcode得到记录的位置。indexFor方法内部是一个取模运算，h是我们通过上面的hash方法得到的，length是散列表的长度。HashMap中的散列表是一个数组，通过取模运算能保证indexFor方法的返回值(记录的位置)一定在这个数组内，没有超过其长度。因为h往往是一个很大的数字(int可以表示40亿这么大的数字)，而散列表的初始长度是可以由我们指定的(默认是16),另一方面，就算给他这么大的数组，内存也是放不下的。所以取模运算是必须的。经过取模运算得到的才是真正的槽值。</p>\n<p>回到上一个问题，<strong>为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？而不是直接使用key的hashcode的</strong>？</p>\n<p>想明白这个问题，参考<a href=\"https://www.zhihu.com/question/20733617\">JDK 源码中 HashMap 的 hash 方法原理是什么？</a>。我们上面也说了这样做的目的是为indexFor方法做准备的，总的来说就是为了让取模运算不会出现一种极端情况：<strong>大量的不同的h经过取模后返回同样的槽值</strong>。这样会带来严重的性能问题，也就是严重的冲突情况导致性能下降。关于冲突，看下文。</p>\n<p>要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。</p>\n<p>散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？</p>\n<p>比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？也就是说，无限多的元素通过散列函数映射到有穷集合上，一定会产生冲突。这也是我们理解hashcode的一个重要的点：<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。</p>\n<p>那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：</p>\n<img src=\"/2016/04/28/java中的equals与hashcode/entry.png\" alt=\"冲突\" title=\"冲突\">\n<p>其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3….为散列表的索引位置。</p>\n<p>接下来的代码  <code>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next)</code>就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：<code>addEntry(hash, key, value, i);</code>.</p>\n<p>那么，怎么判断两个关键码在逻辑上是否相同呢？</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code></p>\n<p>可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：·<code>e.hash == hash</code>。为什么要加这样的判断？回头看看indexFor方法，经过取模运算后，不同的hashcode可以被散列在同一个槽中。通过这句代码可以将那些因为取模运算散列到同一个槽里的不同对象排除。</p>\n<p>我们知道<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：<strong>相同的对象(equals返回true)hashcode一定相等</strong>。</p>\n<p><code>e.hash == hash &amp;&amp; ((k = e.key) == key</code>：这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断<strong>关键码是否相等</strong>，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。</p>\n<p><code>key.equals(k)</code>：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>这句代码中其实包含了一种短路思想，|| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。</p>\n<p>至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面的分析，我们知道了hashcode与equals的几个关键：</p>\n<h4 id=\"1-不同的对象-equals返回false-可以有相同的hashcode\"><a href=\"#1-不同的对象-equals返回false-可以有相同的hashcode\" class=\"headerlink\" title=\"1.不同的对象(equals返回false)可以有相同的hashcode\"></a>1.<strong>不同的对象(equals返回false)可以有相同的hashcode</strong></h4><h4 id=\"2-相同的对象-equals返回true-hashcode一定相等\"><a href=\"#2-相同的对象-equals返回true-hashcode一定相等\" class=\"headerlink\" title=\"2.相同的对象(equals返回true)hashcode一定相等\"></a>2.<strong>相同的对象(equals返回true)hashcode一定相等</strong></h4><h4 id=\"3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"><a href=\"#3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\" class=\"headerlink\" title=\"3.若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"></a>3.<strong>若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义</strong>（对1、2的遵守）</h4><p><a href=\"http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java\">关于如何重写equals方法与hashCode方法</a></p>\n<h2 id=\"equals与\"><a href=\"#equals与\" class=\"headerlink\" title=\"equals与==\"></a>equals与==</h2><p>“==” 比较的是两个对象的内存地址，是物理意义上的相等</p>\n<p>equals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等</p>\n<p>两个对象进行比较：</p>\n<p><strong>== 返回true，则equals一定返回true</strong>；</p>\n<p><strong>equals返回true，== 不一定返回true</strong>。</p>\n"},{"layout":"post","title":"java 中的int/byte转换","date":"2016-11-24T14:48:55.000Z","_content":"\n## 前言\n\n好久没有动博客了，看了下，将近两个月了吧。最近的两个月里面变懒了，没有了记录的动力。。。最近好像也没啥收获，惭愧。之前电脑中病毒之后(cryptolcker)，还好没有神马重要的东西，索性把硬盘重新格式化一遍，重做了系统。保留一套windows（实在受不了win10的自动更新了...）,又装了一套opensuse的系统。希望可以坚持学点linux。\n\n这段时间没有怎么看书，说一下读书情况。《重构》这本还是没有看完，读了大半。《深入理解jvm虚拟机》这本算是大致上浏览了一遍，发现确实是一本挺好的java书籍，日后还需多加翻阅理解。《大话设计模式》也是浏览了一遍，其中比较常见的模式有时候也可以用到，需要的时候再看吧。双十一买了一本《java并发编程实战》，看了大半，似懂非懂，但也是有收获的。不得不吐槽一下该书的翻译，实在是不敢恭维，但是想想自己的英语水平，目前还是忍了。。\n\n必须要振作起精神来了，总觉得自己每天无所事事呢。接下来的计划.....还是把并发编程这块看完吧，虽然没有什么实战的机会，总比不看强。要多写总结了，不然看了跟不看差不多。异常、反射、动态代理、注解等等这些也要学习然后做一个记录。网络、io、并发这三块，并发还在看，也要做好记录，然后网络这部分把大学课本重读一遍，至于io不知道有什么好的书籍，放到最后规划学习把。\n\n嗯，又想起来最近还写了一个自动打卡的程序，增加了短信通知的功能。总觉得有些不诚信的感觉呢，但是没有迟到早退过呀，好玩罢了。读了webmagic的core部分的源码，感觉理解起来轻松许多。记得大学那会看这个的时候还是一头雾水，结果现在两个小时就把代码搞清楚了（主要是代码量也不大拉）。嗯，说明自己还是在进步的麻，哈哈哈。下载了junit的源码都没有看过，有空研究把。\n\n终于要进入正题了。这次的记录很短很简单，是关于java中int和byte之间的转换的。虽然简单，但是以前就是拿来即用，没有搞清楚其中的原理，在byte这块就很纠结（只能说基础比较差），今天来学习一下。\n\n--------------------------------------------------\n\n## 正文\n\njava中:\n\nbyte: 1字节    int: 4字节\n\n```java\nint i = -123\nbyte x = (byte)i; //-123\n```\nps：([]代表几进制，()代表前面的内容重复几次)\n\nps:\n\n-123[2] = 11111111(3)10000101\n\nint 强转为 byte，直接截取低8位即10000101\n\njava把byte当做有符号处理，故此时x=-123\n\n```java\nint j = (int)x; //-123\n```\nps:\n\nbyte强转为int，高24位补1(自动扩展)\n\n此时，j[2]=11111111(3)11101010\n\n即，j=-123\n\n负数似乎没有问题...\n\n--------------------------------------------------\n```java\nint i = 234;\nbyte x = (byte)i; //-22\n```\nps:\n\n234[2] = 00000000(3)11101010\n\nint 强转为 byte，直接截取低8位即11101010\n\njava把byte当做有符号处理，故此时x=-22\n\n```java\nint j = (int)x; //-22\n```\nps:\n\nbyte强转为int，高24位补1（自动扩展）\n\n此时，j[2]=11111111(3)11101010\n\n即，j=-22\n\n可见，byte单纯的强转为int是行不通的。(注意，示例中int强转为一个byte,如果int值超过255,发生数据丢失，正确的int转为4字节byte方法见下文)\n\n--------------------------------------------------\n```java\nint i = 234;\nbyte x = (byte)i; //-22\nint j = x & 0xFF; //j=234\n```\nps:\n\nx & 0xFF = 00000000(3)11101010\n\n即，j=234\n\n可见0xFF的作用...\n\n--------------------------------------------------\n\n- http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/\n\nbyte short char 他们三者在计算时，首先会转换为int类型,故下面几个表达式进行|运算时，是int类型之间的|运算，存在自动扩展(移位操作也会出现这种情况,即int转byte的时候),不进行& 0xFF的运算，则有可能造成第一种情况的出现。\n\n- java字节序\n\njava为大端字节序（bigendian）：高字节数据存放在低地址处，低字节数据存放在高地址处。\n\n0x01020304\n\n故b[0]=0x01,b[1]=0x02,b[2]=0x03,b[3]=0x04\n\n```java\n//byte 数组与 int 的相互转换  \npublic static int byteArrayToInt(byte[] b) {  \n    return   b[3] & 0xFF |  \n            (b[2] & 0xFF) << 8 |  \n            (b[1] & 0xFF) << 16 |  \n            (b[0] & 0xFF) << 24;  \n}  \n  \npublic static byte[] intToByteArray(int a) {  \n    return new byte[] {  \n        (byte) ((a >> 24) & 0xFF),  \n        (byte) ((a >> 16) & 0xFF),     \n        (byte) ((a >> 8) & 0xFF),     \n        (byte) (a & 0xFF)  \n    };  \n}  \n```\n","source":"_posts/java中的int\\byte互转.md","raw":"---\nlayout: post\ntitle:  \"java 中的int/byte转换\"\ncategories: 编程\ntags: \n- java\ndate:   2016-11-24 22:48:55\n---\n\n## 前言\n\n好久没有动博客了，看了下，将近两个月了吧。最近的两个月里面变懒了，没有了记录的动力。。。最近好像也没啥收获，惭愧。之前电脑中病毒之后(cryptolcker)，还好没有神马重要的东西，索性把硬盘重新格式化一遍，重做了系统。保留一套windows（实在受不了win10的自动更新了...）,又装了一套opensuse的系统。希望可以坚持学点linux。\n\n这段时间没有怎么看书，说一下读书情况。《重构》这本还是没有看完，读了大半。《深入理解jvm虚拟机》这本算是大致上浏览了一遍，发现确实是一本挺好的java书籍，日后还需多加翻阅理解。《大话设计模式》也是浏览了一遍，其中比较常见的模式有时候也可以用到，需要的时候再看吧。双十一买了一本《java并发编程实战》，看了大半，似懂非懂，但也是有收获的。不得不吐槽一下该书的翻译，实在是不敢恭维，但是想想自己的英语水平，目前还是忍了。。\n\n必须要振作起精神来了，总觉得自己每天无所事事呢。接下来的计划.....还是把并发编程这块看完吧，虽然没有什么实战的机会，总比不看强。要多写总结了，不然看了跟不看差不多。异常、反射、动态代理、注解等等这些也要学习然后做一个记录。网络、io、并发这三块，并发还在看，也要做好记录，然后网络这部分把大学课本重读一遍，至于io不知道有什么好的书籍，放到最后规划学习把。\n\n嗯，又想起来最近还写了一个自动打卡的程序，增加了短信通知的功能。总觉得有些不诚信的感觉呢，但是没有迟到早退过呀，好玩罢了。读了webmagic的core部分的源码，感觉理解起来轻松许多。记得大学那会看这个的时候还是一头雾水，结果现在两个小时就把代码搞清楚了（主要是代码量也不大拉）。嗯，说明自己还是在进步的麻，哈哈哈。下载了junit的源码都没有看过，有空研究把。\n\n终于要进入正题了。这次的记录很短很简单，是关于java中int和byte之间的转换的。虽然简单，但是以前就是拿来即用，没有搞清楚其中的原理，在byte这块就很纠结（只能说基础比较差），今天来学习一下。\n\n--------------------------------------------------\n\n## 正文\n\njava中:\n\nbyte: 1字节    int: 4字节\n\n```java\nint i = -123\nbyte x = (byte)i; //-123\n```\nps：([]代表几进制，()代表前面的内容重复几次)\n\nps:\n\n-123[2] = 11111111(3)10000101\n\nint 强转为 byte，直接截取低8位即10000101\n\njava把byte当做有符号处理，故此时x=-123\n\n```java\nint j = (int)x; //-123\n```\nps:\n\nbyte强转为int，高24位补1(自动扩展)\n\n此时，j[2]=11111111(3)11101010\n\n即，j=-123\n\n负数似乎没有问题...\n\n--------------------------------------------------\n```java\nint i = 234;\nbyte x = (byte)i; //-22\n```\nps:\n\n234[2] = 00000000(3)11101010\n\nint 强转为 byte，直接截取低8位即11101010\n\njava把byte当做有符号处理，故此时x=-22\n\n```java\nint j = (int)x; //-22\n```\nps:\n\nbyte强转为int，高24位补1（自动扩展）\n\n此时，j[2]=11111111(3)11101010\n\n即，j=-22\n\n可见，byte单纯的强转为int是行不通的。(注意，示例中int强转为一个byte,如果int值超过255,发生数据丢失，正确的int转为4字节byte方法见下文)\n\n--------------------------------------------------\n```java\nint i = 234;\nbyte x = (byte)i; //-22\nint j = x & 0xFF; //j=234\n```\nps:\n\nx & 0xFF = 00000000(3)11101010\n\n即，j=234\n\n可见0xFF的作用...\n\n--------------------------------------------------\n\n- http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/\n\nbyte short char 他们三者在计算时，首先会转换为int类型,故下面几个表达式进行|运算时，是int类型之间的|运算，存在自动扩展(移位操作也会出现这种情况,即int转byte的时候),不进行& 0xFF的运算，则有可能造成第一种情况的出现。\n\n- java字节序\n\njava为大端字节序（bigendian）：高字节数据存放在低地址处，低字节数据存放在高地址处。\n\n0x01020304\n\n故b[0]=0x01,b[1]=0x02,b[2]=0x03,b[3]=0x04\n\n```java\n//byte 数组与 int 的相互转换  \npublic static int byteArrayToInt(byte[] b) {  \n    return   b[3] & 0xFF |  \n            (b[2] & 0xFF) << 8 |  \n            (b[1] & 0xFF) << 16 |  \n            (b[0] & 0xFF) << 24;  \n}  \n  \npublic static byte[] intToByteArray(int a) {  \n    return new byte[] {  \n        (byte) ((a >> 24) & 0xFF),  \n        (byte) ((a >> 16) & 0xFF),     \n        (byte) ((a >> 8) & 0xFF),     \n        (byte) (a & 0xFF)  \n    };  \n}  \n```\n","slug":"java中的int\\byte互转","published":1,"updated":"2017-02-19T13:08:11.033Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlqs0010vegctqj1ztrj","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>好久没有动博客了，看了下，将近两个月了吧。最近的两个月里面变懒了，没有了记录的动力。。。最近好像也没啥收获，惭愧。之前电脑中病毒之后(cryptolcker)，还好没有神马重要的东西，索性把硬盘重新格式化一遍，重做了系统。保留一套windows（实在受不了win10的自动更新了…）,又装了一套opensuse的系统。希望可以坚持学点linux。</p>\n<p>这段时间没有怎么看书，说一下读书情况。《重构》这本还是没有看完，读了大半。《深入理解jvm虚拟机》这本算是大致上浏览了一遍，发现确实是一本挺好的java书籍，日后还需多加翻阅理解。《大话设计模式》也是浏览了一遍，其中比较常见的模式有时候也可以用到，需要的时候再看吧。双十一买了一本《java并发编程实战》，看了大半，似懂非懂，但也是有收获的。不得不吐槽一下该书的翻译，实在是不敢恭维，但是想想自己的英语水平，目前还是忍了。。</p>\n<p>必须要振作起精神来了，总觉得自己每天无所事事呢。接下来的计划…..还是把并发编程这块看完吧，虽然没有什么实战的机会，总比不看强。要多写总结了，不然看了跟不看差不多。异常、反射、动态代理、注解等等这些也要学习然后做一个记录。网络、io、并发这三块，并发还在看，也要做好记录，然后网络这部分把大学课本重读一遍，至于io不知道有什么好的书籍，放到最后规划学习把。</p>\n<p>嗯，又想起来最近还写了一个自动打卡的程序，增加了短信通知的功能。总觉得有些不诚信的感觉呢，但是没有迟到早退过呀，好玩罢了。读了webmagic的core部分的源码，感觉理解起来轻松许多。记得大学那会看这个的时候还是一头雾水，结果现在两个小时就把代码搞清楚了（主要是代码量也不大拉）。嗯，说明自己还是在进步的麻，哈哈哈。下载了junit的源码都没有看过，有空研究把。</p>\n<p>终于要进入正题了。这次的记录很短很简单，是关于java中int和byte之间的转换的。虽然简单，但是以前就是拿来即用，没有搞清楚其中的原理，在byte这块就很纠结（只能说基础比较差），今天来学习一下。</p>\n<hr>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>java中:</p>\n<p>byte: 1字节    int: 4字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = -<span class=\"number\">123</span></div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-123</span></div></pre></td></tr></table></figure>\n<p>ps：([]代表几进制，()代表前面的内容重复几次)</p>\n<p>ps:</p>\n<p>-123[2] = 11111111(3)10000101</p>\n<p>int 强转为 byte，直接截取低8位即10000101</p>\n<p>java把byte当做有符号处理，故此时x=-123</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j = (<span class=\"keyword\">int</span>)x; <span class=\"comment\">//-123</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>byte强转为int，高24位补1(自动扩展)</p>\n<p>此时，j[2]=11111111(3)11101010</p>\n<p>即，j=-123</p>\n<p>负数似乎没有问题…</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">234</span>;</div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-22</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>234[2] = 00000000(3)11101010</p>\n<p>int 强转为 byte，直接截取低8位即11101010</p>\n<p>java把byte当做有符号处理，故此时x=-22</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j = (<span class=\"keyword\">int</span>)x; <span class=\"comment\">//-22</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>byte强转为int，高24位补1（自动扩展）</p>\n<p>此时，j[2]=11111111(3)11101010</p>\n<p>即，j=-22</p>\n<p>可见，byte单纯的强转为int是行不通的。(注意，示例中int强转为一个byte,如果int值超过255,发生数据丢失，正确的int转为4字节byte方法见下文)</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">234</span>;</div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-22</span></div><div class=\"line\"><span class=\"keyword\">int</span> j = x &amp; <span class=\"number\">0xFF</span>; <span class=\"comment\">//j=234</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>x &amp; 0xFF = 00000000(3)11101010</p>\n<p>即，j=234</p>\n<p>可见0xFF的作用…</p>\n<hr>\n<ul>\n<li><a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/\">http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</a></li>\n</ul>\n<p>byte short char 他们三者在计算时，首先会转换为int类型,故下面几个表达式进行|运算时，是int类型之间的|运算，存在自动扩展(移位操作也会出现这种情况,即int转byte的时候),不进行&amp; 0xFF的运算，则有可能造成第一种情况的出现。</p>\n<ul>\n<li>java字节序</li>\n</ul>\n<p>java为大端字节序（bigendian）：高字节数据存放在低地址处，低字节数据存放在高地址处。</p>\n<p>0x01020304</p>\n<p>故b[0]=0x01,b[1]=0x02,b[2]=0x03,b[3]=0x04</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//byte 数组与 int 的相互转换  </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">byteArrayToInt</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span>   b[<span class=\"number\">3</span>] &amp; <span class=\"number\">0xFF</span> |  </div><div class=\"line\">            (b[<span class=\"number\">2</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">8</span> |  </div><div class=\"line\">            (b[<span class=\"number\">1</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">16</span> |  </div><div class=\"line\">            (b[<span class=\"number\">0</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">24</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] intToByteArray(<span class=\"keyword\">int</span> a) &#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[] &#123;  </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">24</span>) &amp; <span class=\"number\">0xFF</span>),  </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>),     </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xFF</span>),     </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) (a &amp; <span class=\"number\">0xFF</span>)  </div><div class=\"line\">    &#125;;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>好久没有动博客了，看了下，将近两个月了吧。最近的两个月里面变懒了，没有了记录的动力。。。最近好像也没啥收获，惭愧。之前电脑中病毒之后(cryptolcker)，还好没有神马重要的东西，索性把硬盘重新格式化一遍，重做了系统。保留一套windows（实在受不了win10的自动更新了…）,又装了一套opensuse的系统。希望可以坚持学点linux。</p>\n<p>这段时间没有怎么看书，说一下读书情况。《重构》这本还是没有看完，读了大半。《深入理解jvm虚拟机》这本算是大致上浏览了一遍，发现确实是一本挺好的java书籍，日后还需多加翻阅理解。《大话设计模式》也是浏览了一遍，其中比较常见的模式有时候也可以用到，需要的时候再看吧。双十一买了一本《java并发编程实战》，看了大半，似懂非懂，但也是有收获的。不得不吐槽一下该书的翻译，实在是不敢恭维，但是想想自己的英语水平，目前还是忍了。。</p>\n<p>必须要振作起精神来了，总觉得自己每天无所事事呢。接下来的计划…..还是把并发编程这块看完吧，虽然没有什么实战的机会，总比不看强。要多写总结了，不然看了跟不看差不多。异常、反射、动态代理、注解等等这些也要学习然后做一个记录。网络、io、并发这三块，并发还在看，也要做好记录，然后网络这部分把大学课本重读一遍，至于io不知道有什么好的书籍，放到最后规划学习把。</p>\n<p>嗯，又想起来最近还写了一个自动打卡的程序，增加了短信通知的功能。总觉得有些不诚信的感觉呢，但是没有迟到早退过呀，好玩罢了。读了webmagic的core部分的源码，感觉理解起来轻松许多。记得大学那会看这个的时候还是一头雾水，结果现在两个小时就把代码搞清楚了（主要是代码量也不大拉）。嗯，说明自己还是在进步的麻，哈哈哈。下载了junit的源码都没有看过，有空研究把。</p>\n<p>终于要进入正题了。这次的记录很短很简单，是关于java中int和byte之间的转换的。虽然简单，但是以前就是拿来即用，没有搞清楚其中的原理，在byte这块就很纠结（只能说基础比较差），今天来学习一下。</p>\n<hr>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>java中:</p>\n<p>byte: 1字节    int: 4字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = -<span class=\"number\">123</span></div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-123</span></div></pre></td></tr></table></figure>\n<p>ps：([]代表几进制，()代表前面的内容重复几次)</p>\n<p>ps:</p>\n<p>-123[2] = 11111111(3)10000101</p>\n<p>int 强转为 byte，直接截取低8位即10000101</p>\n<p>java把byte当做有符号处理，故此时x=-123</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j = (<span class=\"keyword\">int</span>)x; <span class=\"comment\">//-123</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>byte强转为int，高24位补1(自动扩展)</p>\n<p>此时，j[2]=11111111(3)11101010</p>\n<p>即，j=-123</p>\n<p>负数似乎没有问题…</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">234</span>;</div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-22</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>234[2] = 00000000(3)11101010</p>\n<p>int 强转为 byte，直接截取低8位即11101010</p>\n<p>java把byte当做有符号处理，故此时x=-22</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j = (<span class=\"keyword\">int</span>)x; <span class=\"comment\">//-22</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>byte强转为int，高24位补1（自动扩展）</p>\n<p>此时，j[2]=11111111(3)11101010</p>\n<p>即，j=-22</p>\n<p>可见，byte单纯的强转为int是行不通的。(注意，示例中int强转为一个byte,如果int值超过255,发生数据丢失，正确的int转为4字节byte方法见下文)</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">234</span>;</div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-22</span></div><div class=\"line\"><span class=\"keyword\">int</span> j = x &amp; <span class=\"number\">0xFF</span>; <span class=\"comment\">//j=234</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>x &amp; 0xFF = 00000000(3)11101010</p>\n<p>即，j=234</p>\n<p>可见0xFF的作用…</p>\n<hr>\n<ul>\n<li><a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/\">http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</a></li>\n</ul>\n<p>byte short char 他们三者在计算时，首先会转换为int类型,故下面几个表达式进行|运算时，是int类型之间的|运算，存在自动扩展(移位操作也会出现这种情况,即int转byte的时候),不进行&amp; 0xFF的运算，则有可能造成第一种情况的出现。</p>\n<ul>\n<li>java字节序</li>\n</ul>\n<p>java为大端字节序（bigendian）：高字节数据存放在低地址处，低字节数据存放在高地址处。</p>\n<p>0x01020304</p>\n<p>故b[0]=0x01,b[1]=0x02,b[2]=0x03,b[3]=0x04</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//byte 数组与 int 的相互转换  </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">byteArrayToInt</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span>   b[<span class=\"number\">3</span>] &amp; <span class=\"number\">0xFF</span> |  </div><div class=\"line\">            (b[<span class=\"number\">2</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">8</span> |  </div><div class=\"line\">            (b[<span class=\"number\">1</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">16</span> |  </div><div class=\"line\">            (b[<span class=\"number\">0</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">24</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] intToByteArray(<span class=\"keyword\">int</span> a) &#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[] &#123;  </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">24</span>) &amp; <span class=\"number\">0xFF</span>),  </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>),     </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xFF</span>),     </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) (a &amp; <span class=\"number\">0xFF</span>)  </div><div class=\"line\">    &#125;;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"java中的枚举","date":"2016-06-30T04:48:55.000Z","_content":"\n> 已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。\n\nJava中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。\n  \n## 使用场景：\n\n每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。\n\n## 与 public static final 的常量定义方式进行比较：\n\n在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：\n\n```java\npublic class State {\n\tpublic static final int Normal = 0;//正常\n\tpublic static final int Update = 1;//已更新\n\tpublic static final int Delete = 2;//已删除\n}\n```\n\n使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：\n\n```java\npublic void doSomething(int state){\n\tswitch(state){\n\t\tcase State.Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Update:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n1. 在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。\n\n2. 另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。\n\n3. 因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。\n\n那如果换成枚举常量呢？\n\n```java\npublic enum State {\n\tNormal,Update,Delete\n}\n```\n\n类型安全检查：\n\n```java\npublic void doSomething(State state){\n\tswitch(state){\n\t\tcase Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase Update:\n\t\t  ...\n\t\t  break;\n\t\tcase Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。\n\n另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。\n\n## 枚举类型的使用\n\n- **常量**：\n\n```java\npublic enum State{\n\tNormal,Update,Delete\n}\n```\n\n遍历枚举常量：\n\n```java\n   for(State state:State.values()){\n   \t\tSystem.out.println(state);\n   }\n```\n\n- **自定义属性、方法**：\n\n```java\npublic enum State{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }    \n}\n\npublic void test(){\n\tfor (State state : State.values()) {\n\t    //输出：正常:0 已更新:1 已删除:2\n\t\tSystem.out.println(state);\n\t}\n}\n```\n\n实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。\n其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。\n\n因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。\n\n- **实现接口**\n\n```java\npublic interface HandleState{\n\tvoid printState();\n}\n\npublic enum State implements HandleState{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }  \n\n    public void printState() {\n\t\tSystem.out.println(this);\n\t}\n}\n```\n\n可以看到，枚举和一般的类一样都可以实现接口。\n\n- **Enum 相关工具类**\n\nJDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。\n\n## 参考\n\n[java enum的用法详解[转]](https://hacpai.com/article/1437056657634)\n\n[Java 语言中Enum类型的使用介绍](https://www.ibm.com/developerworks/cn/java/j-lo-enum/)","source":"_posts/java中的枚举.md","raw":"---\nlayout: post\ntitle:  \"java中的枚举\"\ncategories: 编程\ntags: \n- java\ndate:   2016-06-30 12:48:55\n---\n\n> 已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。\n\nJava中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。\n  \n## 使用场景：\n\n每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。\n\n## 与 public static final 的常量定义方式进行比较：\n\n在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：\n\n```java\npublic class State {\n\tpublic static final int Normal = 0;//正常\n\tpublic static final int Update = 1;//已更新\n\tpublic static final int Delete = 2;//已删除\n}\n```\n\n使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：\n\n```java\npublic void doSomething(int state){\n\tswitch(state){\n\t\tcase State.Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Update:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n1. 在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。\n\n2. 另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。\n\n3. 因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。\n\n那如果换成枚举常量呢？\n\n```java\npublic enum State {\n\tNormal,Update,Delete\n}\n```\n\n类型安全检查：\n\n```java\npublic void doSomething(State state){\n\tswitch(state){\n\t\tcase Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase Update:\n\t\t  ...\n\t\t  break;\n\t\tcase Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。\n\n另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。\n\n## 枚举类型的使用\n\n- **常量**：\n\n```java\npublic enum State{\n\tNormal,Update,Delete\n}\n```\n\n遍历枚举常量：\n\n```java\n   for(State state:State.values()){\n   \t\tSystem.out.println(state);\n   }\n```\n\n- **自定义属性、方法**：\n\n```java\npublic enum State{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }    \n}\n\npublic void test(){\n\tfor (State state : State.values()) {\n\t    //输出：正常:0 已更新:1 已删除:2\n\t\tSystem.out.println(state);\n\t}\n}\n```\n\n实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。\n其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。\n\n因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。\n\n- **实现接口**\n\n```java\npublic interface HandleState{\n\tvoid printState();\n}\n\npublic enum State implements HandleState{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }  \n\n    public void printState() {\n\t\tSystem.out.println(this);\n\t}\n}\n```\n\n可以看到，枚举和一般的类一样都可以实现接口。\n\n- **Enum 相关工具类**\n\nJDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。\n\n## 参考\n\n[java enum的用法详解[转]](https://hacpai.com/article/1437056657634)\n\n[Java 语言中Enum类型的使用介绍](https://www.ibm.com/developerworks/cn/java/j-lo-enum/)","slug":"java中的枚举","published":1,"updated":"2017-02-19T13:08:11.033Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlqv0014vegc2pnjsf8e","content":"<blockquote>\n<p>已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。</p>\n</blockquote>\n<p>Java中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。</p>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><p>每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。</p>\n<h2 id=\"与-public-static-final-的常量定义方式进行比较：\"><a href=\"#与-public-static-final-的常量定义方式进行比较：\" class=\"headerlink\" title=\"与 public static final 的常量定义方式进行比较：\"></a>与 public static final 的常量定义方式进行比较：</h2><p>在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">State</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Normal = <span class=\"number\">0</span>;<span class=\"comment\">//正常</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Update = <span class=\"number\">1</span>;<span class=\"comment\">//已更新</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Delete = <span class=\"number\">2</span>;<span class=\"comment\">//已删除</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。</p>\n</li>\n<li><p>另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。</p>\n</li>\n<li><p>因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。</p>\n</li>\n</ol>\n<p>那如果换成枚举常量呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类型安全检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(State state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。</p>\n<p>另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。</p>\n<h2 id=\"枚举类型的使用\"><a href=\"#枚举类型的使用\" class=\"headerlink\" title=\"枚举类型的使用\"></a>枚举类型的使用</h2><ul>\n<li><strong>常量</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遍历枚举常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(State state:State.values())&#123;</div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>自定义属性、方法</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (State state : State.values()) &#123;</div><div class=\"line\">\t    <span class=\"comment\">//输出：正常:0 已更新:1 已删除:2</span></div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。<br>其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(“正常”,0),Update(“已更新”,1),Delete(“已删除”,2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。</p>\n<p>因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。</p>\n<ul>\n<li><strong>实现接口</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandleState</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State implements HandleState&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，枚举和一般的类一样都可以实现接口。</p>\n<ul>\n<li><strong>Enum 相关工具类</strong></li>\n</ul>\n<p>JDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://hacpai.com/article/1437056657634\" target=\"_blank\" rel=\"external\">java enum的用法详解[转]</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-enum/\" target=\"_blank\" rel=\"external\">Java 语言中Enum类型的使用介绍</a></p>\n","excerpt":"","more":"<blockquote>\n<p>已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。</p>\n</blockquote>\n<p>Java中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。</p>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><p>每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。</p>\n<h2 id=\"与-public-static-final-的常量定义方式进行比较：\"><a href=\"#与-public-static-final-的常量定义方式进行比较：\" class=\"headerlink\" title=\"与 public static final 的常量定义方式进行比较：\"></a>与 public static final 的常量定义方式进行比较：</h2><p>在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">State</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Normal = <span class=\"number\">0</span>;<span class=\"comment\">//正常</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Update = <span class=\"number\">1</span>;<span class=\"comment\">//已更新</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Delete = <span class=\"number\">2</span>;<span class=\"comment\">//已删除</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。</p>\n</li>\n<li><p>另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。</p>\n</li>\n<li><p>因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。</p>\n</li>\n</ol>\n<p>那如果换成枚举常量呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类型安全检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(State state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。</p>\n<p>另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。</p>\n<h2 id=\"枚举类型的使用\"><a href=\"#枚举类型的使用\" class=\"headerlink\" title=\"枚举类型的使用\"></a>枚举类型的使用</h2><ul>\n<li><strong>常量</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遍历枚举常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(State state:State.values())&#123;</div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>自定义属性、方法</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (State state : State.values()) &#123;</div><div class=\"line\">\t    <span class=\"comment\">//输出：正常:0 已更新:1 已删除:2</span></div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。<br>其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(“正常”,0),Update(“已更新”,1),Delete(“已删除”,2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。</p>\n<p>因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。</p>\n<ul>\n<li><strong>实现接口</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandleState</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State implements HandleState&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，枚举和一般的类一样都可以实现接口。</p>\n<ul>\n<li><strong>Enum 相关工具类</strong></li>\n</ul>\n<p>JDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://hacpai.com/article/1437056657634\">java enum的用法详解[转]</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-enum/\">Java 语言中Enum类型的使用介绍</a></p>\n"},{"layout":"post","title":"java中的类型转换","date":"2016-04-28T04:48:55.000Z","_content":"\n>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：\n\n## **基本类型**\n\n- **基本类型优先级**\n\n首先来看java中的基本类型有哪些：\n\nbyte：byte数据类型是一个8位有符号二进制补码整数。\n\nshort：short数据类型为16位有符号二进制补码整数。\n\nint：int数据类型是一个32位有符号二进制补码整数\n\nlong: long数据类型是一个64位二进制补码整数\n\nfloat: float数据类型是单精度、32位、符合IEEE 754标准的浮点数\n\nboolean: boolean数据类型只有两个可能的值：true和false\n\ndouble: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；\n\nchar: char数据类型是一个16位的Unicode字符\n\n基本类型优先级由低到高排序：\n\n(byte short char) int long float double\n\n其中，byte short char 平级\n\n- **转换规则**\n\n1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算\n\n3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。\n\n2.byte short char 他们三者在计算时，首先会转换为int类型\n\n3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。\n\n4.boolean不能与其他类型转换\n\n\n## **类类型**\n\n类类型之间的转换有以下几个规则：\n\n1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。\n\n2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。\n\n3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。\n  \n说的比较拗口，用代码来解释吧。\n\n```java\npublic class Test {\n\n    class Father {}\n\t\n    class Son extends Father{}\n\t\n    class Daughter extends Father {}\n\n    @org.junit.Test\n    public void test(){\n        Father fatherApp;\n        Son sonApp;\n        Daughter daughterApp;\n        Father fatherIns=new Father();\n        Son sonIns=new Son();\n        Daughter daughterIns=new Daughter();\n\t\t\n        //目标类型为父类，源类型为子类，自动转换\n        fatherApp=sonIns;   \n        //源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。\n        sonApp=(Son) fatherIns;\n        //源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        \n        sonApp=(Son) fatherApp;\n        //目标类型与源类型不存在父子关系，编译无法通过\n        daughterApp=sonIns;  \n\t\t\n    }\t\n}\n```\n\n\n\n## **参考**\n\n[Java 7之基础类型第1篇 - Java数据类型](http://blog.csdn.net/mazhimazh/article/details/16799925)\n\n[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)\n\n[ Java中的类型转换](http://blog.csdn.net/darxin/article/details/5163043)\n","source":"_posts/java中的类型转换.md","raw":"---\nlayout: post\ntitle:  \"java中的类型转换\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-28 12:48:55\n---\n\n>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：\n\n## **基本类型**\n\n- **基本类型优先级**\n\n首先来看java中的基本类型有哪些：\n\nbyte：byte数据类型是一个8位有符号二进制补码整数。\n\nshort：short数据类型为16位有符号二进制补码整数。\n\nint：int数据类型是一个32位有符号二进制补码整数\n\nlong: long数据类型是一个64位二进制补码整数\n\nfloat: float数据类型是单精度、32位、符合IEEE 754标准的浮点数\n\nboolean: boolean数据类型只有两个可能的值：true和false\n\ndouble: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；\n\nchar: char数据类型是一个16位的Unicode字符\n\n基本类型优先级由低到高排序：\n\n(byte short char) int long float double\n\n其中，byte short char 平级\n\n- **转换规则**\n\n1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算\n\n3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。\n\n2.byte short char 他们三者在计算时，首先会转换为int类型\n\n3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。\n\n4.boolean不能与其他类型转换\n\n\n## **类类型**\n\n类类型之间的转换有以下几个规则：\n\n1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。\n\n2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。\n\n3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。\n  \n说的比较拗口，用代码来解释吧。\n\n```java\npublic class Test {\n\n    class Father {}\n\t\n    class Son extends Father{}\n\t\n    class Daughter extends Father {}\n\n    @org.junit.Test\n    public void test(){\n        Father fatherApp;\n        Son sonApp;\n        Daughter daughterApp;\n        Father fatherIns=new Father();\n        Son sonIns=new Son();\n        Daughter daughterIns=new Daughter();\n\t\t\n        //目标类型为父类，源类型为子类，自动转换\n        fatherApp=sonIns;   \n        //源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。\n        sonApp=(Son) fatherIns;\n        //源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        \n        sonApp=(Son) fatherApp;\n        //目标类型与源类型不存在父子关系，编译无法通过\n        daughterApp=sonIns;  \n\t\t\n    }\t\n}\n```\n\n\n\n## **参考**\n\n[Java 7之基础类型第1篇 - Java数据类型](http://blog.csdn.net/mazhimazh/article/details/16799925)\n\n[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)\n\n[ Java中的类型转换](http://blog.csdn.net/darxin/article/details/5163043)\n","slug":"java中的类型转换","published":1,"updated":"2017-02-19T13:08:11.033Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlqy0017vegcbcz5j44p","content":"<blockquote>\n<p>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：</p>\n</blockquote>\n<h2 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a><strong>基本类型</strong></h2><ul>\n<li><strong>基本类型优先级</strong></li>\n</ul>\n<p>首先来看java中的基本类型有哪些：</p>\n<p>byte：byte数据类型是一个8位有符号二进制补码整数。</p>\n<p>short：short数据类型为16位有符号二进制补码整数。</p>\n<p>int：int数据类型是一个32位有符号二进制补码整数</p>\n<p>long: long数据类型是一个64位二进制补码整数</p>\n<p>float: float数据类型是单精度、32位、符合IEEE 754标准的浮点数</p>\n<p>boolean: boolean数据类型只有两个可能的值：true和false</p>\n<p>double: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</p>\n<p>char: char数据类型是一个16位的Unicode字符</p>\n<p>基本类型优先级由低到高排序：</p>\n<p>(byte short char) int long float double</p>\n<p>其中，byte short char 平级</p>\n<ul>\n<li><strong>转换规则</strong></li>\n</ul>\n<p>1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算</p>\n<p>3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。</p>\n<p>2.byte short char 他们三者在计算时，首先会转换为int类型</p>\n<p>3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。</p>\n<p>4.boolean不能与其他类型转换</p>\n<h2 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a><strong>类类型</strong></h2><p>类类型之间的转换有以下几个规则：</p>\n<p>1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。</p>\n<p>2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。</p>\n<p>3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。</p>\n<p>说的比较拗口，用代码来解释吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@org</span>.junit.<span class=\"function\">Test</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span>&#123;</div><div class=\"line\">        Father fatherApp;</div><div class=\"line\">        Son sonApp;</div><div class=\"line\">        Daughter daughterApp;</div><div class=\"line\">        Father fatherIns=<span class=\"keyword\">new</span> Father();</div><div class=\"line\">        Son sonIns=<span class=\"keyword\">new</span> Son();</div><div class=\"line\">        Daughter daughterIns=<span class=\"keyword\">new</span> Daughter();</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\">//目标类型为父类，源类型为子类，自动转换</span></div><div class=\"line\">        fatherApp=sonIns;   </div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。</span></div><div class=\"line\">        sonApp=(Son) fatherIns;</div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        </span></div><div class=\"line\">        sonApp=(Son) fatherApp;</div><div class=\"line\">        <span class=\"comment\">//目标类型与源类型不存在父子关系，编译无法通过</span></div><div class=\"line\">        daughterApp=sonIns;  </div><div class=\"line\">\t\t</div><div class=\"line\">    &#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://blog.csdn.net/mazhimazh/article/details/16799925\" target=\"_blank\" rel=\"external\">Java 7之基础类型第1篇 - Java数据类型</a></p>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\" target=\"_blank\" rel=\"external\">The Java™ Tutorials</a></p>\n<p><a href=\"http://blog.csdn.net/darxin/article/details/5163043\" target=\"_blank\" rel=\"external\"> Java中的类型转换</a></p>\n","excerpt":"","more":"<blockquote>\n<p>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：</p>\n</blockquote>\n<h2 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a><strong>基本类型</strong></h2><ul>\n<li><strong>基本类型优先级</strong></li>\n</ul>\n<p>首先来看java中的基本类型有哪些：</p>\n<p>byte：byte数据类型是一个8位有符号二进制补码整数。</p>\n<p>short：short数据类型为16位有符号二进制补码整数。</p>\n<p>int：int数据类型是一个32位有符号二进制补码整数</p>\n<p>long: long数据类型是一个64位二进制补码整数</p>\n<p>float: float数据类型是单精度、32位、符合IEEE 754标准的浮点数</p>\n<p>boolean: boolean数据类型只有两个可能的值：true和false</p>\n<p>double: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</p>\n<p>char: char数据类型是一个16位的Unicode字符</p>\n<p>基本类型优先级由低到高排序：</p>\n<p>(byte short char) int long float double</p>\n<p>其中，byte short char 平级</p>\n<ul>\n<li><strong>转换规则</strong></li>\n</ul>\n<p>1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算</p>\n<p>3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。</p>\n<p>2.byte short char 他们三者在计算时，首先会转换为int类型</p>\n<p>3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。</p>\n<p>4.boolean不能与其他类型转换</p>\n<h2 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a><strong>类类型</strong></h2><p>类类型之间的转换有以下几个规则：</p>\n<p>1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。</p>\n<p>2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。</p>\n<p>3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。</p>\n<p>说的比较拗口，用代码来解释吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@org</span>.junit.<span class=\"function\">Test</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        Father fatherApp;</div><div class=\"line\">        Son sonApp;</div><div class=\"line\">        Daughter daughterApp;</div><div class=\"line\">        Father fatherIns=<span class=\"keyword\">new</span> Father();</div><div class=\"line\">        Son sonIns=<span class=\"keyword\">new</span> Son();</div><div class=\"line\">        Daughter daughterIns=<span class=\"keyword\">new</span> Daughter();</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\">//目标类型为父类，源类型为子类，自动转换</span></div><div class=\"line\">        fatherApp=sonIns;   </div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。</span></div><div class=\"line\">        sonApp=(Son) fatherIns;</div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        </span></div><div class=\"line\">        sonApp=(Son) fatherApp;</div><div class=\"line\">        <span class=\"comment\">//目标类型与源类型不存在父子关系，编译无法通过</span></div><div class=\"line\">        daughterApp=sonIns;  </div><div class=\"line\">\t\t</div><div class=\"line\">    &#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://blog.csdn.net/mazhimazh/article/details/16799925\">Java 7之基础类型第1篇 - Java数据类型</a></p>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\">The Java™ Tutorials</a></p>\n<p><a href=\"http://blog.csdn.net/darxin/article/details/5163043\"> Java中的类型转换</a></p>\n"},{"layout":"post","title":"java中的编码问题","date":"2016-04-20T04:48:55.000Z","_content":"\n>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。\n\n2016/9/11 更新：今天在网上看到一篇讲解有关编码的文章 [Java中字符编码和字符串所占字节数](http://blog.csdn.net/zklth/article/details/7016886),个人认为作者写的十分清晰明了。把文章中的例子看懂的话再遇到乱码的情况解决起来应该不难！\n\n## 编码\n什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。\n\n- #### **[Ascii编码](http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&fromid=99077&type=syn)**\n\n标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。\n\n- #### **[GB2312](http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&fromid=483170&type=syn)**\n\nGB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。\n\n- #### **[UTF-8](http://baike.baidu.com/view/25412.htm)**\n\n事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是[Unicode编码](http://baike.baidu.com/item/unicode)\n事实上，Unicode也是一套字符集。\n\n**字符集**简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字\"严\"。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？\n\n这是因为：\n\n比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n\n**字符编码**就是用来解决以上所说的如何存储字符对应二进制编码问题的。\n\nUTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8的编码规则很简单，只有两条： \n\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 \n\n2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n\n下面以utf-8为例，看下编码的过程。\n\n{% asset_img utf8.png utf-8 %}\n\n根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。\n\n以汉字”严”为例，演示如何实现UTF-8编码。\n\n已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。\n\n还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。\n\n## java 中的编码\n\n- #### **class文件与内存中的编码**\n\n{% asset_img javaencode.jpg %}\n\n上图说明了java编码转换的过程\n\n首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。\n\njava程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。\n\n**总结**:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。\n\n- #### **InputStreamReader与OutputStreamWriter**\n\n{% asset_img reader.png %}\n{% asset_img writer.png %}\n\nReader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。\n\n写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。\n\n```java\n String file = \"c:/stream.txt\"; \n String charset = \"UTF-8\"; \n // 写字符换转成字节流\n FileOutputStream outputStream = new FileOutputStream(file); \n OutputStreamWriter writer = new OutputStreamWriter( \n outputStream, charset); \n try { \n    writer.write(\"这是要保存的中文字符\"); \n } finally { \n    writer.close(); \n } \n // 读取字节转换成字符\n FileInputStream inputStream = new FileInputStream(file); \n InputStreamReader reader = new InputStreamReader( \n inputStream, charset); \n StringBuffer buffer = new StringBuffer(); \n char[] buf = new char[64]; \n int count = 0; \n try { \n    while ((count = reader.read(buf)) != -1) { \n        buffer.append(buf, 0, count); \n    } \n } finally { \n    reader.close(); \n }\n```\n\n- #### **String与byte[]**\n\n利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。\n\n```java\nString str=\"中\";  \n// 将内存中的str(utf-16)转换为系统默认编码的字节数组\nbyte[] bytes1 = str.getBytes();  \n// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 \nbyte[] bytes2 = str.getBytes(\"ISO-8859-1\");\n// 正常显示中    \nSystem.out.println(new String(bytes1));  \n// 输出\"?\"      \nSystem.out.println(new String(bytes2));      \n```\n\n利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。\n\n```java\n// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”\nbyte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31};  \n// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符\nString str1 = new String(bytes);                      \n// 将bytes按照ISO-8859-1解码，产生Unicode字符\nString str2= new String(bytes,\"ISO-8859-1\");          \n// 中1  将Unicode字符转换为GBK编码输出\nSystem.out.println(str1);                             \n\n/*\n *在ISO-8859-1编码方式中没有对应0xD6和0xD0\n *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”\n *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。\n */ \nSystem.out.println(str2);    // ??1                             \n```\n\n- #### **CharSet**\n\n从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。\n\n```java\nCharset charset = Charset.forName(\"UTF-8\");   \nByteBuffer byteBuffer = charset.encode(string);   \nCharBuffer charBuffer = charset.decode(byteBuffer); \n```\n\n## 延伸 byte\n\n字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。\n\n无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。\n\n有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.\n\n## 参考\n\n[十分钟搞清字符集和字符编码](http://cenalulu.github.io/linux/character-encoding/)\n\n[字符编码笔记：ASCII，Unicode和UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n[java编码转换过程](http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html)\n\n[Java 7之基础 - 编码与解码](http://blog.csdn.net/mazhimazh/article/details/19327421)\n\n[深入分析 Java 中的中文编码问题](https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/)","source":"_posts/java中的编码问题.md","raw":"---\nlayout: post\ntitle:  \"java中的编码问题\"\ncategories: 编程\ntags: \n- java\n- 编码\ndate:   2016-04-20 12:48:55\n---\n\n>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。\n\n2016/9/11 更新：今天在网上看到一篇讲解有关编码的文章 [Java中字符编码和字符串所占字节数](http://blog.csdn.net/zklth/article/details/7016886),个人认为作者写的十分清晰明了。把文章中的例子看懂的话再遇到乱码的情况解决起来应该不难！\n\n## 编码\n什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。\n\n- #### **[Ascii编码](http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&fromid=99077&type=syn)**\n\n标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。\n\n- #### **[GB2312](http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&fromid=483170&type=syn)**\n\nGB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。\n\n- #### **[UTF-8](http://baike.baidu.com/view/25412.htm)**\n\n事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是[Unicode编码](http://baike.baidu.com/item/unicode)\n事实上，Unicode也是一套字符集。\n\n**字符集**简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字\"严\"。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？\n\n这是因为：\n\n比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n\n**字符编码**就是用来解决以上所说的如何存储字符对应二进制编码问题的。\n\nUTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8的编码规则很简单，只有两条： \n\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 \n\n2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n\n下面以utf-8为例，看下编码的过程。\n\n{% asset_img utf8.png utf-8 %}\n\n根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。\n\n以汉字”严”为例，演示如何实现UTF-8编码。\n\n已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。\n\n还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。\n\n## java 中的编码\n\n- #### **class文件与内存中的编码**\n\n{% asset_img javaencode.jpg %}\n\n上图说明了java编码转换的过程\n\n首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。\n\njava程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。\n\n**总结**:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。\n\n- #### **InputStreamReader与OutputStreamWriter**\n\n{% asset_img reader.png %}\n{% asset_img writer.png %}\n\nReader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。\n\n写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。\n\n```java\n String file = \"c:/stream.txt\"; \n String charset = \"UTF-8\"; \n // 写字符换转成字节流\n FileOutputStream outputStream = new FileOutputStream(file); \n OutputStreamWriter writer = new OutputStreamWriter( \n outputStream, charset); \n try { \n    writer.write(\"这是要保存的中文字符\"); \n } finally { \n    writer.close(); \n } \n // 读取字节转换成字符\n FileInputStream inputStream = new FileInputStream(file); \n InputStreamReader reader = new InputStreamReader( \n inputStream, charset); \n StringBuffer buffer = new StringBuffer(); \n char[] buf = new char[64]; \n int count = 0; \n try { \n    while ((count = reader.read(buf)) != -1) { \n        buffer.append(buf, 0, count); \n    } \n } finally { \n    reader.close(); \n }\n```\n\n- #### **String与byte[]**\n\n利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。\n\n```java\nString str=\"中\";  \n// 将内存中的str(utf-16)转换为系统默认编码的字节数组\nbyte[] bytes1 = str.getBytes();  \n// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 \nbyte[] bytes2 = str.getBytes(\"ISO-8859-1\");\n// 正常显示中    \nSystem.out.println(new String(bytes1));  \n// 输出\"?\"      \nSystem.out.println(new String(bytes2));      \n```\n\n利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。\n\n```java\n// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”\nbyte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31};  \n// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符\nString str1 = new String(bytes);                      \n// 将bytes按照ISO-8859-1解码，产生Unicode字符\nString str2= new String(bytes,\"ISO-8859-1\");          \n// 中1  将Unicode字符转换为GBK编码输出\nSystem.out.println(str1);                             \n\n/*\n *在ISO-8859-1编码方式中没有对应0xD6和0xD0\n *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”\n *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。\n */ \nSystem.out.println(str2);    // ??1                             \n```\n\n- #### **CharSet**\n\n从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。\n\n```java\nCharset charset = Charset.forName(\"UTF-8\");   \nByteBuffer byteBuffer = charset.encode(string);   \nCharBuffer charBuffer = charset.decode(byteBuffer); \n```\n\n## 延伸 byte\n\n字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。\n\n无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。\n\n有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.\n\n## 参考\n\n[十分钟搞清字符集和字符编码](http://cenalulu.github.io/linux/character-encoding/)\n\n[字符编码笔记：ASCII，Unicode和UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n[java编码转换过程](http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html)\n\n[Java 7之基础 - 编码与解码](http://blog.csdn.net/mazhimazh/article/details/19327421)\n\n[深入分析 Java 中的中文编码问题](https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/)","slug":"java中的编码问题","published":1,"updated":"2017-02-19T13:08:11.033Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlr0001avegcj62aofj5","content":"<blockquote>\n<p>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。</p>\n</blockquote>\n<p>2016/9/11 更新：今天在网上看到一篇讲解有关编码的文章 <a href=\"http://blog.csdn.net/zklth/article/details/7016886\" target=\"_blank\" rel=\"external\">Java中字符编码和字符串所占字节数</a>,个人认为作者写的十分清晰明了。把文章中的例子看懂的话再遇到乱码的情况解决起来应该不难！</p>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。</p>\n<ul>\n<li><h4 id=\"Ascii编码\"><a href=\"#Ascii编码\" class=\"headerlink\" title=\"Ascii编码\"></a><strong><a href=\"http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&amp;fromid=99077&amp;type=syn\" target=\"_blank\" rel=\"external\">Ascii编码</a></strong></h4></li>\n</ul>\n<p>标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。</p>\n<ul>\n<li><h4 id=\"GB2312\"><a href=\"#GB2312\" class=\"headerlink\" title=\"GB2312\"></a><strong><a href=\"http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&amp;fromid=483170&amp;type=syn\" target=\"_blank\" rel=\"external\">GB2312</a></strong></h4></li>\n</ul>\n<p>GB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p>\n<ul>\n<li><h4 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a><strong><a href=\"http://baike.baidu.com/view/25412.htm\" target=\"_blank\" rel=\"external\">UTF-8</a></strong></h4></li>\n</ul>\n<p>事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是<a href=\"http://baike.baidu.com/item/unicode\" target=\"_blank\" rel=\"external\">Unicode编码</a><br>事实上，Unicode也是一套字符集。</p>\n<p><strong>字符集</strong>简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？</p>\n<p>这是因为：</p>\n<p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。<br>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>\n<p><strong>字符编码</strong>就是用来解决以上所说的如何存储字符对应二进制编码问题的。</p>\n<p>UTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<p>UTF-8的编码规则很简单，只有两条： </p>\n<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </p>\n<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>\n<p>下面以utf-8为例，看下编码的过程。</p>\n<img src=\"/2016/04/20/java中的编码问题/utf8.png\" alt=\"utf-8\" title=\"utf-8\">\n<p>根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。</p>\n<p>以汉字”严”为例，演示如何实现UTF-8编码。</p>\n<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。</p>\n<p>还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。</p>\n<h2 id=\"java-中的编码\"><a href=\"#java-中的编码\" class=\"headerlink\" title=\"java 中的编码\"></a>java 中的编码</h2><ul>\n<li><h4 id=\"class文件与内存中的编码\"><a href=\"#class文件与内存中的编码\" class=\"headerlink\" title=\"class文件与内存中的编码\"></a><strong>class文件与内存中的编码</strong></h4></li>\n</ul>\n\n<p>上图说明了java编码转换的过程</p>\n<p>首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。</p>\n<p>java程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。</p>\n<p><strong>总结</strong>:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。</p>\n<ul>\n<li><h4 id=\"InputStreamReader与OutputStreamWriter\"><a href=\"#InputStreamReader与OutputStreamWriter\" class=\"headerlink\" title=\"InputStreamReader与OutputStreamWriter\"></a><strong>InputStreamReader与OutputStreamWriter</strong></h4></li>\n</ul>\n<img src=\"/2016/04/20/java中的编码问题/reader.png\" alt=\"reader.png\" title=\"\">\n<img src=\"/2016/04/20/java中的编码问题/writer.png\" alt=\"writer.png\" title=\"\">\n<p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。</p>\n<p>写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">String file = <span class=\"string\">\"c:/stream.txt\"</span>; </div><div class=\"line\">String charset = <span class=\"string\">\"UTF-8\"</span>; </div><div class=\"line\"><span class=\"comment\">// 写字符换转成字节流</span></div><div class=\"line\">FileOutputStream outputStream = <span class=\"keyword\">new</span> FileOutputStream(file); </div><div class=\"line\">OutputStreamWriter writer = <span class=\"keyword\">new</span> OutputStreamWriter( </div><div class=\"line\">outputStream, charset); </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   writer.write(<span class=\"string\">\"这是要保存的中文字符\"</span>); </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   writer.close(); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"comment\">// 读取字节转换成字符</span></div><div class=\"line\">FileInputStream inputStream = <span class=\"keyword\">new</span> FileInputStream(file); </div><div class=\"line\">InputStreamReader reader = <span class=\"keyword\">new</span> InputStreamReader( </div><div class=\"line\">inputStream, charset); </div><div class=\"line\">StringBuffer buffer = <span class=\"keyword\">new</span> StringBuffer(); </div><div class=\"line\"><span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>]; </div><div class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   <span class=\"keyword\">while</span> ((count = reader.read(buf)) != -<span class=\"number\">1</span>) &#123; </div><div class=\"line\">       buffer.append(buf, <span class=\"number\">0</span>, count); </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   reader.close(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"String与byte\"><a href=\"#String与byte\" class=\"headerlink\" title=\"String与byte[]\"></a><strong>String与byte[]</strong></h4></li>\n</ul>\n<p>利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"string\">\"中\"</span>;  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为系统默认编码的字节数组</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = str.getBytes();  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 </span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = str.getBytes(<span class=\"string\">\"ISO-8859-1\"</span>);</div><div class=\"line\"><span class=\"comment\">// 正常显示中    </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes1));  </div><div class=\"line\"><span class=\"comment\">// 输出\"?\"      </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes2));</div></pre></td></tr></table></figure>\n<p>利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes = &#123;(<span class=\"keyword\">byte</span>)<span class=\"number\">0xD6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0xD0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0x31</span>&#125;;  </div><div class=\"line\"><span class=\"comment\">// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符</span></div><div class=\"line\">String str1 = <span class=\"keyword\">new</span> String(bytes);                      </div><div class=\"line\"><span class=\"comment\">// 将bytes按照ISO-8859-1解码，产生Unicode字符</span></div><div class=\"line\">String str2= <span class=\"keyword\">new</span> String(bytes,<span class=\"string\">\"ISO-8859-1\"</span>);          </div><div class=\"line\"><span class=\"comment\">// 中1  将Unicode字符转换为GBK编码输出</span></div><div class=\"line\">System.out.println(str1);                             </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> *在ISO-8859-1编码方式中没有对应0xD6和0xD0</div><div class=\"line\"> *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”</div><div class=\"line\"> *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。</div><div class=\"line\"> */ </div><div class=\"line\">System.out.println(str2);    <span class=\"comment\">// ??1</span></div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"CharSet\"><a href=\"#CharSet\" class=\"headerlink\" title=\"CharSet\"></a><strong>CharSet</strong></h4></li>\n</ul>\n<p>从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(<span class=\"string\">\"UTF-8\"</span>);   </div><div class=\"line\">ByteBuffer byteBuffer = charset.encode(string);   </div><div class=\"line\">CharBuffer charBuffer = charset.decode(byteBuffer);</div></pre></td></tr></table></figure>\n<h2 id=\"延伸-byte\"><a href=\"#延伸-byte\" class=\"headerlink\" title=\"延伸 byte\"></a>延伸 byte</h2><p>字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。</p>\n<p>无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。</p>\n<p>有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://cenalulu.github.io/linux/character-encoding/\" target=\"_blank\" rel=\"external\">十分钟搞清字符集和字符编码</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\" target=\"_blank\" rel=\"external\">字符编码笔记：ASCII，Unicode和UTF-8</a></p>\n<p><a href=\"http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html\" target=\"_blank\" rel=\"external\">java编码转换过程</a></p>\n<p><a href=\"http://blog.csdn.net/mazhimazh/article/details/19327421\" target=\"_blank\" rel=\"external\">Java 7之基础 - 编码与解码</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/\" target=\"_blank\" rel=\"external\">深入分析 Java 中的中文编码问题</a></p>\n","excerpt":"","more":"<blockquote>\n<p>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。</p>\n</blockquote>\n<p>2016/9/11 更新：今天在网上看到一篇讲解有关编码的文章 <a href=\"http://blog.csdn.net/zklth/article/details/7016886\">Java中字符编码和字符串所占字节数</a>,个人认为作者写的十分清晰明了。把文章中的例子看懂的话再遇到乱码的情况解决起来应该不难！</p>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。</p>\n<ul>\n<li><h4 id=\"Ascii编码\"><a href=\"#Ascii编码\" class=\"headerlink\" title=\"Ascii编码\"></a><strong><a href=\"http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&amp;fromid=99077&amp;type=syn\">Ascii编码</a></strong></h4></li>\n</ul>\n<p>标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。</p>\n<ul>\n<li><h4 id=\"GB2312\"><a href=\"#GB2312\" class=\"headerlink\" title=\"GB2312\"></a><strong><a href=\"http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&amp;fromid=483170&amp;type=syn\">GB2312</a></strong></h4></li>\n</ul>\n<p>GB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p>\n<ul>\n<li><h4 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a><strong><a href=\"http://baike.baidu.com/view/25412.htm\">UTF-8</a></strong></h4></li>\n</ul>\n<p>事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是<a href=\"http://baike.baidu.com/item/unicode\">Unicode编码</a><br>事实上，Unicode也是一套字符集。</p>\n<p><strong>字符集</strong>简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？</p>\n<p>这是因为：</p>\n<p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。<br>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>\n<p><strong>字符编码</strong>就是用来解决以上所说的如何存储字符对应二进制编码问题的。</p>\n<p>UTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<p>UTF-8的编码规则很简单，只有两条： </p>\n<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </p>\n<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>\n<p>下面以utf-8为例，看下编码的过程。</p>\n<img src=\"/2016/04/20/java中的编码问题/utf8.png\" alt=\"utf-8\" title=\"utf-8\">\n<p>根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。</p>\n<p>以汉字”严”为例，演示如何实现UTF-8编码。</p>\n<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。</p>\n<p>还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。</p>\n<h2 id=\"java-中的编码\"><a href=\"#java-中的编码\" class=\"headerlink\" title=\"java 中的编码\"></a>java 中的编码</h2><ul>\n<li><h4 id=\"class文件与内存中的编码\"><a href=\"#class文件与内存中的编码\" class=\"headerlink\" title=\"class文件与内存中的编码\"></a><strong>class文件与内存中的编码</strong></h4></li>\n</ul>\n\n<p>上图说明了java编码转换的过程</p>\n<p>首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。</p>\n<p>java程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。</p>\n<p><strong>总结</strong>:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。</p>\n<ul>\n<li><h4 id=\"InputStreamReader与OutputStreamWriter\"><a href=\"#InputStreamReader与OutputStreamWriter\" class=\"headerlink\" title=\"InputStreamReader与OutputStreamWriter\"></a><strong>InputStreamReader与OutputStreamWriter</strong></h4></li>\n</ul>\n<img src=\"/2016/04/20/java中的编码问题/reader.png\" alt=\"reader.png\" title=\"\">\n<img src=\"/2016/04/20/java中的编码问题/writer.png\" alt=\"writer.png\" title=\"\">\n<p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。</p>\n<p>写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">String file = <span class=\"string\">\"c:/stream.txt\"</span>; </div><div class=\"line\">String charset = <span class=\"string\">\"UTF-8\"</span>; </div><div class=\"line\"><span class=\"comment\">// 写字符换转成字节流</span></div><div class=\"line\">FileOutputStream outputStream = <span class=\"keyword\">new</span> FileOutputStream(file); </div><div class=\"line\">OutputStreamWriter writer = <span class=\"keyword\">new</span> OutputStreamWriter( </div><div class=\"line\">outputStream, charset); </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   writer.write(<span class=\"string\">\"这是要保存的中文字符\"</span>); </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   writer.close(); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"comment\">// 读取字节转换成字符</span></div><div class=\"line\">FileInputStream inputStream = <span class=\"keyword\">new</span> FileInputStream(file); </div><div class=\"line\">InputStreamReader reader = <span class=\"keyword\">new</span> InputStreamReader( </div><div class=\"line\">inputStream, charset); </div><div class=\"line\">StringBuffer buffer = <span class=\"keyword\">new</span> StringBuffer(); </div><div class=\"line\"><span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>]; </div><div class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   <span class=\"keyword\">while</span> ((count = reader.read(buf)) != -<span class=\"number\">1</span>) &#123; </div><div class=\"line\">       buffer.append(buf, <span class=\"number\">0</span>, count); </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   reader.close(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"String与byte\"><a href=\"#String与byte\" class=\"headerlink\" title=\"String与byte[]\"></a><strong>String与byte[]</strong></h4></li>\n</ul>\n<p>利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"string\">\"中\"</span>;  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为系统默认编码的字节数组</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = str.getBytes();  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 </span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = str.getBytes(<span class=\"string\">\"ISO-8859-1\"</span>);</div><div class=\"line\"><span class=\"comment\">// 正常显示中    </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes1));  </div><div class=\"line\"><span class=\"comment\">// 输出\"?\"      </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes2));</div></pre></td></tr></table></figure>\n<p>利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes = &#123;(<span class=\"keyword\">byte</span>)<span class=\"number\">0xD6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0xD0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0x31</span>&#125;;  </div><div class=\"line\"><span class=\"comment\">// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符</span></div><div class=\"line\">String str1 = <span class=\"keyword\">new</span> String(bytes);                      </div><div class=\"line\"><span class=\"comment\">// 将bytes按照ISO-8859-1解码，产生Unicode字符</span></div><div class=\"line\">String str2= <span class=\"keyword\">new</span> String(bytes,<span class=\"string\">\"ISO-8859-1\"</span>);          </div><div class=\"line\"><span class=\"comment\">// 中1  将Unicode字符转换为GBK编码输出</span></div><div class=\"line\">System.out.println(str1);                             </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\"> *在ISO-8859-1编码方式中没有对应0xD6和0xD0</div><div class=\"line\"> *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”</div><div class=\"line\"> *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。</div><div class=\"line\"> */</span> </div><div class=\"line\">System.out.println(str2);    <span class=\"comment\">// ??1</span></div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"CharSet\"><a href=\"#CharSet\" class=\"headerlink\" title=\"CharSet\"></a><strong>CharSet</strong></h4></li>\n</ul>\n<p>从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(<span class=\"string\">\"UTF-8\"</span>);   </div><div class=\"line\">ByteBuffer byteBuffer = charset.encode(string);   </div><div class=\"line\">CharBuffer charBuffer = charset.decode(byteBuffer);</div></pre></td></tr></table></figure>\n<h2 id=\"延伸-byte\"><a href=\"#延伸-byte\" class=\"headerlink\" title=\"延伸 byte\"></a>延伸 byte</h2><p>字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。</p>\n<p>无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。</p>\n<p>有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://cenalulu.github.io/linux/character-encoding/\">十分钟搞清字符集和字符编码</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\">字符编码笔记：ASCII，Unicode和UTF-8</a></p>\n<p><a href=\"http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html\">java编码转换过程</a></p>\n<p><a href=\"http://blog.csdn.net/mazhimazh/article/details/19327421\">Java 7之基础 - 编码与解码</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/\">深入分析 Java 中的中文编码问题</a></p>\n"},{"layout":"post","title":"java中的路径","date":"2016-12-04T11:03:00.000Z","_content":"\n>每次写java代码的时候，免不了需要加载一些外部资源，比如配置文件等等。每当需要读取这些文件时，都是去网上谷歌，写过就忘。于是今天来总结一些java中有关路径的一些用法。\n\n## 绝对路径\n\n无论是在linux还是windows中，路径都分为绝对路径和相对路径两种。\n\n绝对路径就是系统中唯一能够定位资源的某个URI，即完整的描述文件的路径就是绝对路径。比如：\n\nlinux中的绝对路径：/home/yukai/test.txt\n\nwindows中的绝对路径：E:\\yukai\\test.txt\n\n绝对路径都是以根目录起始的。\n\n## 相对路径\n\n相对路径即目标文件相对与某个基准目录的路径。比如:\n\n存在文件： \n\nA: /home/yukai/test.txt \n\nB: /home/yukai/test1.txt \n\nC: /home/yukai/test/test.txt\n\n那么：\n\n若基准目录为A, B的路径表示为\"test1.txt\"\n\n若基准目录为B, C的路径表示为\"test/test.txt\"\n\n若基准目录为C, B的路径表示为\"../test1.txt\"\n\n另外，“./”表示当前目录，“../”表示上级目录\n\n## java io定位文件资源\n\n那么，我们在java中如何读取某个文件？上代码：\n\n```\n// 目录结构\nsrc\n |\n |--test\n |   |\n |   |--PathTest.java \n |\nresource\n |\n |--data.txt\n```\n\n```java\npublic class PathTest {\n\n\tpublic static String  dataFilePath = \"resource/data.txty\";\n\t\n\tpublic static String getUserDir() {\n\t\t//打印运行程序的目录，即启动java程序的目录\n\t\tString userDir = System.getProperty(\"user.dir\");\n\t\tSystem.out.println(\"运行java的工作目录 System.getProperty(\\\"user.dir\\\")： \" + userDir);\n\t\treturn userDir;\n\t}\n\t\n\tpublic static void testDataPath1() {\n\t\tString msg = \">> Path = System.getProperty(\\\"user.dir\\\") + \\\"resource/data.txt\\\"\";\n\t\tString userDir = getUserDir();\n\t\t//等同于 \"resource/data.txt\"\n\t\tString filePath = userDir + System.getProperty(\"file.separator\") + dataFilePath;\n\t\tprintFileContent(filePath ,msg);\n\t}\n\t\n\tpublic static void testDataPath2() {\n\t\tString msg = \"Path = \\\"resource/data.txt\\\"\";\n\t\tString filePath = dataFilePath;\n\t\tprintFileContent(filePath, msg);\n\t}\n\t\n\tpublic static void testDataPath3() {\n\t\tString msg = \"Path = \\\"./resource/data.txt\\\"\";\n\t\tString filePath = \"./resource/data.txt\";\n\t\tprintFileContent(filePath, msg);\n\t}\n\t\n\tprivate static void printFileContent(String filePath, String msg) {\n\t\tSystem.out.println(\"****************************\");\n\t\tSystem.out.println(msg);\n\t\tFile file = new File(filePath);\n\t\tInputStream stream;\n\t\ttry {\n\t\t\tstream = new FileInputStream(file);\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\t\tString line = null;\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tSystem.out.println(\"****************************\");\n\t\t} \n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttestDataPath1();\n\t\ttestDataPath2();\n\t\ttestDataPath3();\n\t}\n\n}\n```\n其中`testDataPath2`、`testDataPath1`、`testDataPath3`这三个方法的效果是一样的。\n\n`System.getProperty(\"user.dir\")`这个方法获取了当前的工作目录，也就是启动jvm的目录。例如：\n\nps: 更多关于System.getProperty()的介绍：[System Properties](http://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html)\n\n你的java程序位于：/home/yukai/code/test.jar \n\n若你在目录/home/yukai下使用命令 `java -cp code/test.jar test.PathTest` 启动java程序时，目录/home/yukai就是你的工作目录。\n\n在`testDataPath2`当中，直接使用\"resource/data.txty\"来作为文件读取路径时，java会默认为基准目录为当前的工作目录，\"resource/data.txty\"此时就是相对于这个基准目录的路径。\n也就是说，java会把工作目录与\"resource/data.txty\"拼接起来，作为一个绝对路径去读取文件，也就是`testDataPath1`中的例子。\n\n有Eclipse中启动你的java工程的目录就是工程根目录，工程根目录也就是工作目录，如果你读取文件的方式类似于`testDataPath2`的话，他会在工程根目录下找你的文件。\n有时候我们会遇到，在Eclipse中读取文件没有问题，但是打成jar包之后运行(像上面运行jar包的例子)就会报找不到文件的错误。那么此时就要检查你的当前工作目录下(/home/yukai)是否有这些文件的存在了。\n\n## File.getPath & File.getAbsolutePath & File.getCanonicalPath\n\n```java\npublic static void testGetPath() {\n\t\tFile file = new File(\"./resource/data.txt\");\n\t\tSystem.out.println(\"File.getPath(): \" + file.getPath());\n\t\tSystem.out.println(\"File.getAbsolutePath(): \"+ file.getAbsolutePath());\n\t\ttry {\n\t\t\tSystem.out.println(\"File.getCanonicalPath(): \" + file.getCanonicalPath());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n上述代码运行结果：\n\n```\nFile.getPath(): ./resource/data.txt\nFile.getAbsolutePath(): /home/yukai/workspace/test/./resource/data.txt\nFile.getCanonicalPath(): /home/yukai/workspace/test/resource/data.txt\n```\n摘抄一段[stackoverflow](http://stackoverflow.com/questions/1099300/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath)上的答案:\n\n```\ngetPath() gets the path string that the File object was constructed with, and it may be relative current directory.\n\ngetAbsolutePath() gets the path string after resolving it against the current directory if it's relative, resulting in a fully qualified path.\n\ngetCanonicalPath() gets the path string after resolving any relative path against current directory, and removes any relative pathing (. and ..), and any file system links to return a path which the file system considers the canonical means to reference the file system object to which it points.\n```\n\n## 读取classpath下的文件\n\n```java\npublic static void getClassPath() {\n\t\tSystem.out.println(\"PathTest.class.getResource(\\\"/\\\"): \" + PathTest.class.getResource(\"/\"));\n\t\tSystem.out.println(\"PathTest.class.getResource(\\\"\\\"): \" + PathTest.class.getResource(\"\"));\n\t\t\n\t\tSystem.out.println(\"PathTest.class.getClassLoader().getResource(\\\"/\\\"): \" + PathTest.class.getClassLoader().getResource(\"/\"));\n\t\tSystem.out.println(\"PathTest.class.getClassLoader().getResource(\\\"\\\"): \" + PathTest.class.getClassLoader().getResource(\"\"));\n}\n```\n\n运行结果(Eclipse)：\n\n```\n//以“/”开头，表示相对于package根目录\nPathTest.class.getResource(\"/\"): file:/home/yukai/workspace/test/bin/\n//不以“/”开头，表示相对于class文件所在目录\nPathTest.class.getResource(\"\"): file:/home/yukai/workspace/test/bin/test/\n//\nPathTest.class.getClassLoader().getResource(\"/\"): null\n//getClassLoader().getResource(\"\")不以“/”开头，相对于package根目录\nPathTest.class.getClassLoader().getResource(\"\"): file:/home/yukai/workspace/test/bin/\n```\n## 获取jar包路径\n\njava开发中常常需要取得程序生成的jar包所在的路径，比如生成一些log文件的时候，需要把该程序生成的log放到jar包的的同级目录下。\n此时，我们需要知道jar包所在的位置，注意，不是启动jvm实例的位置。\n\n```\nURL url = Config.class.getProtectionDomain().getCodeSource().getLocation();\nString path = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null).getPath(); \nif (path != null) {   \n   if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {      \n          path = path.substring(0, path.length() - 1);    \n   }    \n   if (path.endsWith(\".jar\")) {        \n          int index = path.lastIndexOf(\"/\");\n          if (index != -1) {           \n                path = path.substring(0, index);\n          }\n          defultLogPath = path + File.separator + \"log\";\n   } else { \n       defultLogPath = path + File.separator + \"..\" + File.separator + \"log\" ;\n   }\n}\n```\n\n## Path.java\n\njdk1.7之后，新增了一个类File,位于java.nio.file下，该类提供了一些路径的操作。\n\n具体的使用不一一介绍，用到时可查找oracle的官方手册，已经写的很详细了：[Path Operations](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html)\n","source":"_posts/java中的路径.md","raw":"---\nlayout: post\ntitle: \"java中的路径\"\ncategories: 编程\ndate: 2016-12-04 19:03:00\n---\n\n>每次写java代码的时候，免不了需要加载一些外部资源，比如配置文件等等。每当需要读取这些文件时，都是去网上谷歌，写过就忘。于是今天来总结一些java中有关路径的一些用法。\n\n## 绝对路径\n\n无论是在linux还是windows中，路径都分为绝对路径和相对路径两种。\n\n绝对路径就是系统中唯一能够定位资源的某个URI，即完整的描述文件的路径就是绝对路径。比如：\n\nlinux中的绝对路径：/home/yukai/test.txt\n\nwindows中的绝对路径：E:\\yukai\\test.txt\n\n绝对路径都是以根目录起始的。\n\n## 相对路径\n\n相对路径即目标文件相对与某个基准目录的路径。比如:\n\n存在文件： \n\nA: /home/yukai/test.txt \n\nB: /home/yukai/test1.txt \n\nC: /home/yukai/test/test.txt\n\n那么：\n\n若基准目录为A, B的路径表示为\"test1.txt\"\n\n若基准目录为B, C的路径表示为\"test/test.txt\"\n\n若基准目录为C, B的路径表示为\"../test1.txt\"\n\n另外，“./”表示当前目录，“../”表示上级目录\n\n## java io定位文件资源\n\n那么，我们在java中如何读取某个文件？上代码：\n\n```\n// 目录结构\nsrc\n |\n |--test\n |   |\n |   |--PathTest.java \n |\nresource\n |\n |--data.txt\n```\n\n```java\npublic class PathTest {\n\n\tpublic static String  dataFilePath = \"resource/data.txty\";\n\t\n\tpublic static String getUserDir() {\n\t\t//打印运行程序的目录，即启动java程序的目录\n\t\tString userDir = System.getProperty(\"user.dir\");\n\t\tSystem.out.println(\"运行java的工作目录 System.getProperty(\\\"user.dir\\\")： \" + userDir);\n\t\treturn userDir;\n\t}\n\t\n\tpublic static void testDataPath1() {\n\t\tString msg = \">> Path = System.getProperty(\\\"user.dir\\\") + \\\"resource/data.txt\\\"\";\n\t\tString userDir = getUserDir();\n\t\t//等同于 \"resource/data.txt\"\n\t\tString filePath = userDir + System.getProperty(\"file.separator\") + dataFilePath;\n\t\tprintFileContent(filePath ,msg);\n\t}\n\t\n\tpublic static void testDataPath2() {\n\t\tString msg = \"Path = \\\"resource/data.txt\\\"\";\n\t\tString filePath = dataFilePath;\n\t\tprintFileContent(filePath, msg);\n\t}\n\t\n\tpublic static void testDataPath3() {\n\t\tString msg = \"Path = \\\"./resource/data.txt\\\"\";\n\t\tString filePath = \"./resource/data.txt\";\n\t\tprintFileContent(filePath, msg);\n\t}\n\t\n\tprivate static void printFileContent(String filePath, String msg) {\n\t\tSystem.out.println(\"****************************\");\n\t\tSystem.out.println(msg);\n\t\tFile file = new File(filePath);\n\t\tInputStream stream;\n\t\ttry {\n\t\t\tstream = new FileInputStream(file);\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\t\tString line = null;\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tSystem.out.println(\"****************************\");\n\t\t} \n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttestDataPath1();\n\t\ttestDataPath2();\n\t\ttestDataPath3();\n\t}\n\n}\n```\n其中`testDataPath2`、`testDataPath1`、`testDataPath3`这三个方法的效果是一样的。\n\n`System.getProperty(\"user.dir\")`这个方法获取了当前的工作目录，也就是启动jvm的目录。例如：\n\nps: 更多关于System.getProperty()的介绍：[System Properties](http://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html)\n\n你的java程序位于：/home/yukai/code/test.jar \n\n若你在目录/home/yukai下使用命令 `java -cp code/test.jar test.PathTest` 启动java程序时，目录/home/yukai就是你的工作目录。\n\n在`testDataPath2`当中，直接使用\"resource/data.txty\"来作为文件读取路径时，java会默认为基准目录为当前的工作目录，\"resource/data.txty\"此时就是相对于这个基准目录的路径。\n也就是说，java会把工作目录与\"resource/data.txty\"拼接起来，作为一个绝对路径去读取文件，也就是`testDataPath1`中的例子。\n\n有Eclipse中启动你的java工程的目录就是工程根目录，工程根目录也就是工作目录，如果你读取文件的方式类似于`testDataPath2`的话，他会在工程根目录下找你的文件。\n有时候我们会遇到，在Eclipse中读取文件没有问题，但是打成jar包之后运行(像上面运行jar包的例子)就会报找不到文件的错误。那么此时就要检查你的当前工作目录下(/home/yukai)是否有这些文件的存在了。\n\n## File.getPath & File.getAbsolutePath & File.getCanonicalPath\n\n```java\npublic static void testGetPath() {\n\t\tFile file = new File(\"./resource/data.txt\");\n\t\tSystem.out.println(\"File.getPath(): \" + file.getPath());\n\t\tSystem.out.println(\"File.getAbsolutePath(): \"+ file.getAbsolutePath());\n\t\ttry {\n\t\t\tSystem.out.println(\"File.getCanonicalPath(): \" + file.getCanonicalPath());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n上述代码运行结果：\n\n```\nFile.getPath(): ./resource/data.txt\nFile.getAbsolutePath(): /home/yukai/workspace/test/./resource/data.txt\nFile.getCanonicalPath(): /home/yukai/workspace/test/resource/data.txt\n```\n摘抄一段[stackoverflow](http://stackoverflow.com/questions/1099300/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath)上的答案:\n\n```\ngetPath() gets the path string that the File object was constructed with, and it may be relative current directory.\n\ngetAbsolutePath() gets the path string after resolving it against the current directory if it's relative, resulting in a fully qualified path.\n\ngetCanonicalPath() gets the path string after resolving any relative path against current directory, and removes any relative pathing (. and ..), and any file system links to return a path which the file system considers the canonical means to reference the file system object to which it points.\n```\n\n## 读取classpath下的文件\n\n```java\npublic static void getClassPath() {\n\t\tSystem.out.println(\"PathTest.class.getResource(\\\"/\\\"): \" + PathTest.class.getResource(\"/\"));\n\t\tSystem.out.println(\"PathTest.class.getResource(\\\"\\\"): \" + PathTest.class.getResource(\"\"));\n\t\t\n\t\tSystem.out.println(\"PathTest.class.getClassLoader().getResource(\\\"/\\\"): \" + PathTest.class.getClassLoader().getResource(\"/\"));\n\t\tSystem.out.println(\"PathTest.class.getClassLoader().getResource(\\\"\\\"): \" + PathTest.class.getClassLoader().getResource(\"\"));\n}\n```\n\n运行结果(Eclipse)：\n\n```\n//以“/”开头，表示相对于package根目录\nPathTest.class.getResource(\"/\"): file:/home/yukai/workspace/test/bin/\n//不以“/”开头，表示相对于class文件所在目录\nPathTest.class.getResource(\"\"): file:/home/yukai/workspace/test/bin/test/\n//\nPathTest.class.getClassLoader().getResource(\"/\"): null\n//getClassLoader().getResource(\"\")不以“/”开头，相对于package根目录\nPathTest.class.getClassLoader().getResource(\"\"): file:/home/yukai/workspace/test/bin/\n```\n## 获取jar包路径\n\njava开发中常常需要取得程序生成的jar包所在的路径，比如生成一些log文件的时候，需要把该程序生成的log放到jar包的的同级目录下。\n此时，我们需要知道jar包所在的位置，注意，不是启动jvm实例的位置。\n\n```\nURL url = Config.class.getProtectionDomain().getCodeSource().getLocation();\nString path = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null).getPath(); \nif (path != null) {   \n   if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {      \n          path = path.substring(0, path.length() - 1);    \n   }    \n   if (path.endsWith(\".jar\")) {        \n          int index = path.lastIndexOf(\"/\");\n          if (index != -1) {           \n                path = path.substring(0, index);\n          }\n          defultLogPath = path + File.separator + \"log\";\n   } else { \n       defultLogPath = path + File.separator + \"..\" + File.separator + \"log\" ;\n   }\n}\n```\n\n## Path.java\n\njdk1.7之后，新增了一个类File,位于java.nio.file下，该类提供了一些路径的操作。\n\n具体的使用不一一介绍，用到时可查找oracle的官方手册，已经写的很详细了：[Path Operations](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html)\n","slug":"java中的路径","published":1,"updated":"2017-03-29T06:07:48.031Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlr6001evegc6b2vn5pg","content":"<blockquote>\n<p>每次写java代码的时候，免不了需要加载一些外部资源，比如配置文件等等。每当需要读取这些文件时，都是去网上谷歌，写过就忘。于是今天来总结一些java中有关路径的一些用法。</p>\n</blockquote>\n<h2 id=\"绝对路径\"><a href=\"#绝对路径\" class=\"headerlink\" title=\"绝对路径\"></a>绝对路径</h2><p>无论是在linux还是windows中，路径都分为绝对路径和相对路径两种。</p>\n<p>绝对路径就是系统中唯一能够定位资源的某个URI，即完整的描述文件的路径就是绝对路径。比如：</p>\n<p>linux中的绝对路径：/home/yukai/test.txt</p>\n<p>windows中的绝对路径：E:\\yukai\\test.txt</p>\n<p>绝对路径都是以根目录起始的。</p>\n<h2 id=\"相对路径\"><a href=\"#相对路径\" class=\"headerlink\" title=\"相对路径\"></a>相对路径</h2><p>相对路径即目标文件相对与某个基准目录的路径。比如:</p>\n<p>存在文件： </p>\n<p>A: /home/yukai/test.txt </p>\n<p>B: /home/yukai/test1.txt </p>\n<p>C: /home/yukai/test/test.txt</p>\n<p>那么：</p>\n<p>若基准目录为A, B的路径表示为”test1.txt”</p>\n<p>若基准目录为B, C的路径表示为”test/test.txt”</p>\n<p>若基准目录为C, B的路径表示为”../test1.txt”</p>\n<p>另外，“./”表示当前目录，“../”表示上级目录</p>\n<h2 id=\"java-io定位文件资源\"><a href=\"#java-io定位文件资源\" class=\"headerlink\" title=\"java io定位文件资源\"></a>java io定位文件资源</h2><p>那么，我们在java中如何读取某个文件？上代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 目录结构</div><div class=\"line\">src</div><div class=\"line\"> |</div><div class=\"line\"> |--test</div><div class=\"line\"> |   |</div><div class=\"line\"> |   |--PathTest.java </div><div class=\"line\"> |</div><div class=\"line\">resource</div><div class=\"line\"> |</div><div class=\"line\"> |--data.txt</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PathTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String  dataFilePath = <span class=\"string\">\"resource/data.txty\"</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getUserDir</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//打印运行程序的目录，即启动java程序的目录</span></div><div class=\"line\">\t\tString userDir = System.getProperty(<span class=\"string\">\"user.dir\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行java的工作目录 System.getProperty(\\\"user.dir\\\")： \"</span> + userDir);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> userDir;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"&gt;&gt; Path = System.getProperty(\\\"user.dir\\\") + \\\"resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString userDir = getUserDir();</div><div class=\"line\">\t\t<span class=\"comment\">//等同于 \"resource/data.txt\"</span></div><div class=\"line\">\t\tString filePath = userDir + System.getProperty(<span class=\"string\">\"file.separator\"</span>) + dataFilePath;</div><div class=\"line\">\t\tprintFileContent(filePath ,msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"Path = \\\"resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString filePath = dataFilePath;</div><div class=\"line\">\t\tprintFileContent(filePath, msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath3</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"Path = \\\"./resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString filePath = <span class=\"string\">\"./resource/data.txt\"</span>;</div><div class=\"line\">\t\tprintFileContent(filePath, msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printFileContent</span><span class=\"params\">(String filePath, String msg)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"****************************\"</span>);</div><div class=\"line\">\t\tSystem.out.println(msg);</div><div class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(filePath);</div><div class=\"line\">\t\tInputStream stream;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tstream = <span class=\"keyword\">new</span> FileInputStream(file);</div><div class=\"line\">\t\t\tBufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(stream));</div><div class=\"line\">\t\t\tString line = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> ((line = reader.readLine()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"****************************\"</span>);</div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\ttestDataPath1();</div><div class=\"line\">\t\ttestDataPath2();</div><div class=\"line\">\t\ttestDataPath3();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中<code>testDataPath2</code>、<code>testDataPath1</code>、<code>testDataPath3</code>这三个方法的效果是一样的。</p>\n<p><code>System.getProperty(&quot;user.dir&quot;)</code>这个方法获取了当前的工作目录，也就是启动jvm的目录。例如：</p>\n<p>ps: 更多关于System.getProperty()的介绍：<a href=\"http://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html\" target=\"_blank\" rel=\"external\">System Properties</a></p>\n<p>你的java程序位于：/home/yukai/code/test.jar </p>\n<p>若你在目录/home/yukai下使用命令 <code>java -cp code/test.jar test.PathTest</code> 启动java程序时，目录/home/yukai就是你的工作目录。</p>\n<p>在<code>testDataPath2</code>当中，直接使用”resource/data.txty”来作为文件读取路径时，java会默认为基准目录为当前的工作目录，”resource/data.txty”此时就是相对于这个基准目录的路径。<br>也就是说，java会把工作目录与”resource/data.txty”拼接起来，作为一个绝对路径去读取文件，也就是<code>testDataPath1</code>中的例子。</p>\n<p>有Eclipse中启动你的java工程的目录就是工程根目录，工程根目录也就是工作目录，如果你读取文件的方式类似于<code>testDataPath2</code>的话，他会在工程根目录下找你的文件。<br>有时候我们会遇到，在Eclipse中读取文件没有问题，但是打成jar包之后运行(像上面运行jar包的例子)就会报找不到文件的错误。那么此时就要检查你的当前工作目录下(/home/yukai)是否有这些文件的存在了。</p>\n<h2 id=\"File-getPath-amp-File-getAbsolutePath-amp-File-getCanonicalPath\"><a href=\"#File-getPath-amp-File-getAbsolutePath-amp-File-getCanonicalPath\" class=\"headerlink\" title=\"File.getPath &amp; File.getAbsolutePath &amp; File.getCanonicalPath\"></a>File.getPath &amp; File.getAbsolutePath &amp; File.getCanonicalPath</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGetPath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"./resource/data.txt\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"File.getPath(): \"</span> + file.getPath());</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"File.getAbsolutePath(): \"</span>+ file.getAbsolutePath());</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"File.getCanonicalPath(): \"</span> + file.getCanonicalPath());</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">File.getPath(): ./resource/data.txt</div><div class=\"line\">File.getAbsolutePath(): /home/yukai/workspace/test/./resource/data.txt</div><div class=\"line\">File.getCanonicalPath(): /home/yukai/workspace/test/resource/data.txt</div></pre></td></tr></table></figure>\n<p>摘抄一段<a href=\"http://stackoverflow.com/questions/1099300/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath\" target=\"_blank\" rel=\"external\">stackoverflow</a>上的答案:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">getPath() gets the path string that the File object was constructed with, and it may be relative current directory.</div><div class=\"line\"></div><div class=\"line\">getAbsolutePath() gets the path string after resolving it against the current directory if it&apos;s relative, resulting in a fully qualified path.</div><div class=\"line\"></div><div class=\"line\">getCanonicalPath() gets the path string after resolving any relative path against current directory, and removes any relative pathing (. and ..), and any file system links to return a path which the file system considers the canonical means to reference the file system object to which it points.</div></pre></td></tr></table></figure>\n<h2 id=\"读取classpath下的文件\"><a href=\"#读取classpath下的文件\" class=\"headerlink\" title=\"读取classpath下的文件\"></a>读取classpath下的文件</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getClassPath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getResource(\\\"/\\\"): \"</span> + PathTest.class.getResource(<span class=\"string\">\"/\"</span>));</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getResource(\\\"\\\"): \"</span> + PathTest.class.getResource(<span class=\"string\">\"\"</span>));</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getClassLoader().getResource(\\\"/\\\"): \"</span> + PathTest.class.getClassLoader().getResource(<span class=\"string\">\"/\"</span>));</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getClassLoader().getResource(\\\"\\\"): \"</span> + PathTest.class.getClassLoader().getResource(<span class=\"string\">\"\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果(Eclipse)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以“/”开头，表示相对于package根目录</div><div class=\"line\">PathTest.class.getResource(&quot;/&quot;): file:/home/yukai/workspace/test/bin/</div><div class=\"line\">//不以“/”开头，表示相对于class文件所在目录</div><div class=\"line\">PathTest.class.getResource(&quot;&quot;): file:/home/yukai/workspace/test/bin/test/</div><div class=\"line\">//</div><div class=\"line\">PathTest.class.getClassLoader().getResource(&quot;/&quot;): null</div><div class=\"line\">//getClassLoader().getResource(&quot;&quot;)不以“/”开头，相对于package根目录</div><div class=\"line\">PathTest.class.getClassLoader().getResource(&quot;&quot;): file:/home/yukai/workspace/test/bin/</div></pre></td></tr></table></figure>\n<h2 id=\"获取jar包路径\"><a href=\"#获取jar包路径\" class=\"headerlink\" title=\"获取jar包路径\"></a>获取jar包路径</h2><p>java开发中常常需要取得程序生成的jar包所在的路径，比如生成一些log文件的时候，需要把该程序生成的log放到jar包的的同级目录下。<br>此时，我们需要知道jar包所在的位置，注意，不是启动jvm实例的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">URL url = Config.class.getProtectionDomain().getCodeSource().getLocation();</div><div class=\"line\">String path = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null).getPath(); </div><div class=\"line\">if (path != null) &#123;   </div><div class=\"line\">   if (path.endsWith(&quot;/&quot;) || path.endsWith(&quot;\\\\&quot;)) &#123;      </div><div class=\"line\">          path = path.substring(0, path.length() - 1);    </div><div class=\"line\">   &#125;    </div><div class=\"line\">   if (path.endsWith(&quot;.jar&quot;)) &#123;        </div><div class=\"line\">          int index = path.lastIndexOf(&quot;/&quot;);</div><div class=\"line\">          if (index != -1) &#123;           </div><div class=\"line\">                path = path.substring(0, index);</div><div class=\"line\">          &#125;</div><div class=\"line\">          defultLogPath = path + File.separator + &quot;log&quot;;</div><div class=\"line\">   &#125; else &#123; </div><div class=\"line\">       defultLogPath = path + File.separator + &quot;..&quot; + File.separator + &quot;log&quot; ;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Path-java\"><a href=\"#Path-java\" class=\"headerlink\" title=\"Path.java\"></a>Path.java</h2><p>jdk1.7之后，新增了一个类File,位于java.nio.file下，该类提供了一些路径的操作。</p>\n<p>具体的使用不一一介绍，用到时可查找oracle的官方手册，已经写的很详细了：<a href=\"https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html\" target=\"_blank\" rel=\"external\">Path Operations</a></p>\n","excerpt":"","more":"<blockquote>\n<p>每次写java代码的时候，免不了需要加载一些外部资源，比如配置文件等等。每当需要读取这些文件时，都是去网上谷歌，写过就忘。于是今天来总结一些java中有关路径的一些用法。</p>\n</blockquote>\n<h2 id=\"绝对路径\"><a href=\"#绝对路径\" class=\"headerlink\" title=\"绝对路径\"></a>绝对路径</h2><p>无论是在linux还是windows中，路径都分为绝对路径和相对路径两种。</p>\n<p>绝对路径就是系统中唯一能够定位资源的某个URI，即完整的描述文件的路径就是绝对路径。比如：</p>\n<p>linux中的绝对路径：/home/yukai/test.txt</p>\n<p>windows中的绝对路径：E:\\yukai\\test.txt</p>\n<p>绝对路径都是以根目录起始的。</p>\n<h2 id=\"相对路径\"><a href=\"#相对路径\" class=\"headerlink\" title=\"相对路径\"></a>相对路径</h2><p>相对路径即目标文件相对与某个基准目录的路径。比如:</p>\n<p>存在文件： </p>\n<p>A: /home/yukai/test.txt </p>\n<p>B: /home/yukai/test1.txt </p>\n<p>C: /home/yukai/test/test.txt</p>\n<p>那么：</p>\n<p>若基准目录为A, B的路径表示为”test1.txt”</p>\n<p>若基准目录为B, C的路径表示为”test/test.txt”</p>\n<p>若基准目录为C, B的路径表示为”../test1.txt”</p>\n<p>另外，“./”表示当前目录，“../”表示上级目录</p>\n<h2 id=\"java-io定位文件资源\"><a href=\"#java-io定位文件资源\" class=\"headerlink\" title=\"java io定位文件资源\"></a>java io定位文件资源</h2><p>那么，我们在java中如何读取某个文件？上代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 目录结构</div><div class=\"line\">src</div><div class=\"line\"> |</div><div class=\"line\"> |--test</div><div class=\"line\"> |   |</div><div class=\"line\"> |   |--PathTest.java </div><div class=\"line\"> |</div><div class=\"line\">resource</div><div class=\"line\"> |</div><div class=\"line\"> |--data.txt</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PathTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String  dataFilePath = <span class=\"string\">\"resource/data.txty\"</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getUserDir</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//打印运行程序的目录，即启动java程序的目录</span></div><div class=\"line\">\t\tString userDir = System.getProperty(<span class=\"string\">\"user.dir\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行java的工作目录 System.getProperty(\\\"user.dir\\\")： \"</span> + userDir);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> userDir;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"&gt;&gt; Path = System.getProperty(\\\"user.dir\\\") + \\\"resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString userDir = getUserDir();</div><div class=\"line\">\t\t<span class=\"comment\">//等同于 \"resource/data.txt\"</span></div><div class=\"line\">\t\tString filePath = userDir + System.getProperty(<span class=\"string\">\"file.separator\"</span>) + dataFilePath;</div><div class=\"line\">\t\tprintFileContent(filePath ,msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"Path = \\\"resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString filePath = dataFilePath;</div><div class=\"line\">\t\tprintFileContent(filePath, msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath3</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"Path = \\\"./resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString filePath = <span class=\"string\">\"./resource/data.txt\"</span>;</div><div class=\"line\">\t\tprintFileContent(filePath, msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printFileContent</span><span class=\"params\">(String filePath, String msg)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"****************************\"</span>);</div><div class=\"line\">\t\tSystem.out.println(msg);</div><div class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(filePath);</div><div class=\"line\">\t\tInputStream stream;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tstream = <span class=\"keyword\">new</span> FileInputStream(file);</div><div class=\"line\">\t\t\tBufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(stream));</div><div class=\"line\">\t\t\tString line = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> ((line = reader.readLine()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"****************************\"</span>);</div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\ttestDataPath1();</div><div class=\"line\">\t\ttestDataPath2();</div><div class=\"line\">\t\ttestDataPath3();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中<code>testDataPath2</code>、<code>testDataPath1</code>、<code>testDataPath3</code>这三个方法的效果是一样的。</p>\n<p><code>System.getProperty(&quot;user.dir&quot;)</code>这个方法获取了当前的工作目录，也就是启动jvm的目录。例如：</p>\n<p>ps: 更多关于System.getProperty()的介绍：<a href=\"http://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html\">System Properties</a></p>\n<p>你的java程序位于：/home/yukai/code/test.jar </p>\n<p>若你在目录/home/yukai下使用命令 <code>java -cp code/test.jar test.PathTest</code> 启动java程序时，目录/home/yukai就是你的工作目录。</p>\n<p>在<code>testDataPath2</code>当中，直接使用”resource/data.txty”来作为文件读取路径时，java会默认为基准目录为当前的工作目录，”resource/data.txty”此时就是相对于这个基准目录的路径。<br>也就是说，java会把工作目录与”resource/data.txty”拼接起来，作为一个绝对路径去读取文件，也就是<code>testDataPath1</code>中的例子。</p>\n<p>有Eclipse中启动你的java工程的目录就是工程根目录，工程根目录也就是工作目录，如果你读取文件的方式类似于<code>testDataPath2</code>的话，他会在工程根目录下找你的文件。<br>有时候我们会遇到，在Eclipse中读取文件没有问题，但是打成jar包之后运行(像上面运行jar包的例子)就会报找不到文件的错误。那么此时就要检查你的当前工作目录下(/home/yukai)是否有这些文件的存在了。</p>\n<h2 id=\"File-getPath-amp-File-getAbsolutePath-amp-File-getCanonicalPath\"><a href=\"#File-getPath-amp-File-getAbsolutePath-amp-File-getCanonicalPath\" class=\"headerlink\" title=\"File.getPath &amp; File.getAbsolutePath &amp; File.getCanonicalPath\"></a>File.getPath &amp; File.getAbsolutePath &amp; File.getCanonicalPath</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGetPath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"./resource/data.txt\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"File.getPath(): \"</span> + file.getPath());</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"File.getAbsolutePath(): \"</span>+ file.getAbsolutePath());</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"File.getCanonicalPath(): \"</span> + file.getCanonicalPath());</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">File.getPath(): ./resource/data.txt</div><div class=\"line\">File.getAbsolutePath(): /home/yukai/workspace/test/./resource/data.txt</div><div class=\"line\">File.getCanonicalPath(): /home/yukai/workspace/test/resource/data.txt</div></pre></td></tr></table></figure>\n<p>摘抄一段<a href=\"http://stackoverflow.com/questions/1099300/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath\">stackoverflow</a>上的答案:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">getPath() gets the path string that the File object was constructed with, and it may be relative current directory.</div><div class=\"line\"></div><div class=\"line\">getAbsolutePath() gets the path string after resolving it against the current directory if it&apos;s relative, resulting in a fully qualified path.</div><div class=\"line\"></div><div class=\"line\">getCanonicalPath() gets the path string after resolving any relative path against current directory, and removes any relative pathing (. and ..), and any file system links to return a path which the file system considers the canonical means to reference the file system object to which it points.</div></pre></td></tr></table></figure>\n<h2 id=\"读取classpath下的文件\"><a href=\"#读取classpath下的文件\" class=\"headerlink\" title=\"读取classpath下的文件\"></a>读取classpath下的文件</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getClassPath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getResource(\\\"/\\\"): \"</span> + PathTest.class.getResource(<span class=\"string\">\"/\"</span>));</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getResource(\\\"\\\"): \"</span> + PathTest.class.getResource(<span class=\"string\">\"\"</span>));</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getClassLoader().getResource(\\\"/\\\"): \"</span> + PathTest.class.getClassLoader().getResource(<span class=\"string\">\"/\"</span>));</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getClassLoader().getResource(\\\"\\\"): \"</span> + PathTest.class.getClassLoader().getResource(<span class=\"string\">\"\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果(Eclipse)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以“/”开头，表示相对于package根目录</div><div class=\"line\">PathTest.class.getResource(&quot;/&quot;): file:/home/yukai/workspace/test/bin/</div><div class=\"line\">//不以“/”开头，表示相对于class文件所在目录</div><div class=\"line\">PathTest.class.getResource(&quot;&quot;): file:/home/yukai/workspace/test/bin/test/</div><div class=\"line\">//</div><div class=\"line\">PathTest.class.getClassLoader().getResource(&quot;/&quot;): null</div><div class=\"line\">//getClassLoader().getResource(&quot;&quot;)不以“/”开头，相对于package根目录</div><div class=\"line\">PathTest.class.getClassLoader().getResource(&quot;&quot;): file:/home/yukai/workspace/test/bin/</div></pre></td></tr></table></figure>\n<h2 id=\"获取jar包路径\"><a href=\"#获取jar包路径\" class=\"headerlink\" title=\"获取jar包路径\"></a>获取jar包路径</h2><p>java开发中常常需要取得程序生成的jar包所在的路径，比如生成一些log文件的时候，需要把该程序生成的log放到jar包的的同级目录下。<br>此时，我们需要知道jar包所在的位置，注意，不是启动jvm实例的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">URL url = Config.class.getProtectionDomain().getCodeSource().getLocation();</div><div class=\"line\">String path = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null).getPath(); </div><div class=\"line\">if (path != null) &#123;   </div><div class=\"line\">   if (path.endsWith(&quot;/&quot;) || path.endsWith(&quot;\\\\&quot;)) &#123;      </div><div class=\"line\">          path = path.substring(0, path.length() - 1);    </div><div class=\"line\">   &#125;    </div><div class=\"line\">   if (path.endsWith(&quot;.jar&quot;)) &#123;        </div><div class=\"line\">          int index = path.lastIndexOf(&quot;/&quot;);</div><div class=\"line\">          if (index != -1) &#123;           </div><div class=\"line\">                path = path.substring(0, index);</div><div class=\"line\">          &#125;</div><div class=\"line\">          defultLogPath = path + File.separator + &quot;log&quot;;</div><div class=\"line\">   &#125; else &#123; </div><div class=\"line\">       defultLogPath = path + File.separator + &quot;..&quot; + File.separator + &quot;log&quot; ;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Path-java\"><a href=\"#Path-java\" class=\"headerlink\" title=\"Path.java\"></a>Path.java</h2><p>jdk1.7之后，新增了一个类File,位于java.nio.file下，该类提供了一些路径的操作。</p>\n<p>具体的使用不一一介绍，用到时可查找oracle的官方手册，已经写的很详细了：<a href=\"https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html\">Path Operations</a></p>\n"},{"layout":"post","title":"java代理机制","date":"2017-03-28T08:15:35.000Z","_content":"## 代理模式\n\n代理模式，顾名思义，即一个客户不想或者不能直接访问一个对象，需要通过一个称为代理的第三方对象来实现间接引用。代理对象的作用就是客户端和目标对象\n之间的一个中介，通过代理对象可以隐藏不让用户看到的内容或实现额外的服务。\n\n代理机制应用的场景有很多：比如在代理对象中实现缓存，验证，权限控制等功能，真正的业务逻辑封装在真实对象中。RMI远程方法调用也用到了代理。当你调用一个远程方法的时候，相当于调用这个方法的代理对象，\n在代理对象中封装了网络请求等部分，真实对象存在于另一个进程上。重构老旧代码的时候也常常会用到代理模式。\n\n代理分两种：静态代理和动态代理\n\n## 静态代理\n\n静态代理即在代码中手动实现代理模式。代理模式涉及到三个角色：\n\n真实对象RealSubject、抽象主题Subject、代理对象Proxy\n\n{% asset_img Proxy.jpg Proxy %}\n\n{% asset_img seq_Proxy.jpg seq_Proxy %}\n\n```\npublic class ProxyTest {\n\tpublic static void main(String[] args) {\n\t\tnew Proxy(\"hello\").request();\n\t}\n}\ninterface Subject {\n\tvoid request();\n}\nclass Proxy implements Subject{\n\tString str;\n\tRealSubject subject;\n\tpublic Proxy(String string) {\n\t\tstr = string;\n\t\tsubject = new RealSubject(str);\n\t}\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"代理对象验证机制....\");\n\t\tsubject.request();\n\t}\n\t\n}\n\nclass RealSubject implements Subject{\n\tString str;\n\tpublic RealSubject(String string) {\n\t\tstr = string;\n\t}\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"真实对象打印str: \" + str);\n\t}\n\t\n}\n```\n输出：\n```\n代理对象验证机制....\n真实对象打印str: hello\n```\n上面的代码模拟了一个代理对象实现验证机制的过程。可以看到，代码很简单，代理模式也很好理解。\n（我们在真实生活中不也有代理么,,比如黄牛，帮你买到你买不到的火车票）\n\n## JDK动态代理实现\n\n动态代理时较为高级的一种代理模式。典型的应用有Spring AOP，RMI。\n\n在上面的静态代理模式中，真实对象是事先存在的，并且作为代理对象的内部成员属性。一个真实的对象必须对应一个代理对象，如果真实对象很多的话会导致类膨胀。\n\n另外，如何在事先不知道真实对象的情况下使用代理代理对象，这都是动态代理需要解决的问题。\n\n比如有n个类需要在执行前打印几行日志，而这n个类是无法通过源代码修改的(从jar包中引入的)。通过静态代理实现的话将会有n个新的代理类产生，而使用动态代理的话，只需一个类即可。\n\n动态代理的实现方式有很多，我们只讨论JDK中的动态代理实现。\n\n```\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class DynamicProxyTest {\n\tpublic static void main(String[] args) {\n\t\tSubject subject = (Subject) new DynamicProxy().bind(new RealSubject(\"hello\"));\n\t\tsubject.request();\n\t}\n}\n\ninterface Subject {\n\tvoid request();\n}\n\nclass RealSubject implements Subject{\n\tString str;\n\tpublic RealSubject(String string) {\n\t\tstr = string;\n\t}\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"真实对象打印str: \" + str);\n\t}\n}\n\nclass DynamicProxy implements InvocationHandler {\n\tObject object;\n\tpublic Object bind(Object object) {\n\t\tthis.object = object;\n\t\treturn Proxy.newProxyInstance(object.getClass().getClassLoader(), \n\t\t\t\tobject.getClass().getInterfaces(), this);\n\t}\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\tSystem.out.println(\"代理对象验证...\");\n\t\treturn method.invoke(object, args);\n\t}\n}\n```\n输出：\n```\n代理对象验证...\n真实对象打印str: hello\n```\n可以看到，动态代理实现了与静态代理一样的功能，但他的优点在于代理的真实对象不是确定的，可以在运行时指定，增大了灵活性。如果我们有很多的真实对象需要代理访问，并且他们代理对象中的内容\n都实现了相同的功能，那么我们只需要一个动态代理类即可。\n\n## 动态代理原理\n\n我们通过观察java.lang.reflect.Proxy的源码来了解动态代理的原理。下面的代码截取自openjdk7-b147 (安利一个不错的搜索java源码的网站:http://grepcode.com)\n\n{% asset_img 1.png Proxy %}\n\n上面的方法截取自Proxy.newProxyInstance，可以看到，调用getProxyClass方法获取到一个代理类class对象，然后使用该class对象通过反射方法实例化一个对象返回。\n\n接下来观察getProxyClass方法。\n\n{% asset_img 2.png Proxy %}\n\n这部分代码截取自getProxyClass，先从缓存中查询是否已经生成过对应的class，若有，则直接返回该对象，没有，则继续下一步生成class\n\n{% asset_img 3.png Proxy %}\n\n这部分代码是代理类class对象的生成过程。其中：\n\n`byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);`这行代码调用ProxyGenerator.generateProxyClass返回了代理类class对象的字节码byte序列，\n`proxyClass = defineClass0(loader, proxyName,proxyClassFile, 0, proxyClassFile.length);`这一行则进行了类加载的工作，最终生成了代理类class对象。\n\n{% asset_img 4.png Proxy %}\n\ngenerateProxyClass，其中的gen.generateClassFile()方法实现了字节码的生成。\n\n{% asset_img 5.png Proxy %}\n\ngenerateClassFile方法的实现。开头调用的三个addProxyMethod方法将object类中的hashcode、equals、toString方法重写，故对这三个方法的调用会传递到InvocationHandler.invoke方法当中。\n注意，除了上述三个方法之外，调用代理类中Object定义的其他方法不会传递到invoke方法当中，也就是说，调用这些方法会执行Object中的默认实现。\n\n如果想要查看ProxyGenerator.generateProxyClass这个方法在运行时产生的代理类中写了些什么，可以在main方法中加入：\n\n```\nSystem.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");\n```\n\n运行时会将生成的class文件保存到硬盘当中：$Proxy0.class\n\n```\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\n\npublic final class $Proxy0\n  extends Proxy\n  implements Subject\n{\n  private static Method m1;\n  private static Method m3;\n  private static Method m0;\n  private static Method m2;\n  \n  public $Proxy0(InvocationHandler paramInvocationHandler)\n  {\n    super(paramInvocationHandler);\n  }\n  \n  public final boolean equals(Object paramObject)\n  {\n    try\n    {\n      return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue();\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final void request()\n  {\n    try\n    {\n      this.h.invoke(this, m3, null);\n      return;\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final int hashCode()\n  {\n    try\n    {\n      return ((Integer)this.h.invoke(this, m0, null)).intValue();\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final String toString()\n  {\n    try\n    {\n      return (String)this.h.invoke(this, m2, null);\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  static\n  {\n    try\n    {\n      m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] { Class.forName(\"java.lang.Object\") });\n      m3 = Class.forName(\"Subject\").getMethod(\"request\", new Class[0]);\n      m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]);\n      m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]);\n      return;\n    }\n    catch (NoSuchMethodException localNoSuchMethodException)\n    {\n      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());\n    }\n    catch (ClassNotFoundException localClassNotFoundException)\n    {\n      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());\n    }\n  }\n}\n```\n上面的代码很好理解。可以看到equals、hashCode、toString以及我们Subject接口request方法的实现中都是调用了InvocationHandler.invoke方法，而这个InvocationHandler实例就是我们在Proxy.newProxyInstance中传入的对象。\n\n综上，可以看到实现动态代理的几个步骤：\n\n1.实现InvocationHandler\n\n2.获得动态代理类，这一步又涉及到运行时代理类字节码的生成和类加载\n\n3.通过反射机制（getConstructor(InvocationHandler.class)）获取代理类的实例并返回该对象\n\n4.调用代理对象的目标方法（也就是request方法，代理类也实现了Subject这个接口），调用转发到InvocationHandler.invoke方法当中，执行invoke的逻辑（我们自己的InvocationHandler实现）\n\n至此，我们就了解了动态代理的运行原理。动态代理的机制也有一些缺陷，比如他代理的必须是接口方法。看一下我们上面生成的$Proxy0.class，可知这个代理类已经默认继承了类Proxy，所以，他只能通过实现我们提供的接口来代理我们的方法。在invoke方法中，我们可以通过对传入的代理类、方法和参数来进行判断，对不同的方法实现不同的业务逻辑。\n","source":"_posts/java代理机制.md","raw":"---\nlayout: post\ntitle: java代理机制\ndate: 2017-03-28 16:15:35\ncategories: 编程\ntags: java\n---\n## 代理模式\n\n代理模式，顾名思义，即一个客户不想或者不能直接访问一个对象，需要通过一个称为代理的第三方对象来实现间接引用。代理对象的作用就是客户端和目标对象\n之间的一个中介，通过代理对象可以隐藏不让用户看到的内容或实现额外的服务。\n\n代理机制应用的场景有很多：比如在代理对象中实现缓存，验证，权限控制等功能，真正的业务逻辑封装在真实对象中。RMI远程方法调用也用到了代理。当你调用一个远程方法的时候，相当于调用这个方法的代理对象，\n在代理对象中封装了网络请求等部分，真实对象存在于另一个进程上。重构老旧代码的时候也常常会用到代理模式。\n\n代理分两种：静态代理和动态代理\n\n## 静态代理\n\n静态代理即在代码中手动实现代理模式。代理模式涉及到三个角色：\n\n真实对象RealSubject、抽象主题Subject、代理对象Proxy\n\n{% asset_img Proxy.jpg Proxy %}\n\n{% asset_img seq_Proxy.jpg seq_Proxy %}\n\n```\npublic class ProxyTest {\n\tpublic static void main(String[] args) {\n\t\tnew Proxy(\"hello\").request();\n\t}\n}\ninterface Subject {\n\tvoid request();\n}\nclass Proxy implements Subject{\n\tString str;\n\tRealSubject subject;\n\tpublic Proxy(String string) {\n\t\tstr = string;\n\t\tsubject = new RealSubject(str);\n\t}\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"代理对象验证机制....\");\n\t\tsubject.request();\n\t}\n\t\n}\n\nclass RealSubject implements Subject{\n\tString str;\n\tpublic RealSubject(String string) {\n\t\tstr = string;\n\t}\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"真实对象打印str: \" + str);\n\t}\n\t\n}\n```\n输出：\n```\n代理对象验证机制....\n真实对象打印str: hello\n```\n上面的代码模拟了一个代理对象实现验证机制的过程。可以看到，代码很简单，代理模式也很好理解。\n（我们在真实生活中不也有代理么,,比如黄牛，帮你买到你买不到的火车票）\n\n## JDK动态代理实现\n\n动态代理时较为高级的一种代理模式。典型的应用有Spring AOP，RMI。\n\n在上面的静态代理模式中，真实对象是事先存在的，并且作为代理对象的内部成员属性。一个真实的对象必须对应一个代理对象，如果真实对象很多的话会导致类膨胀。\n\n另外，如何在事先不知道真实对象的情况下使用代理代理对象，这都是动态代理需要解决的问题。\n\n比如有n个类需要在执行前打印几行日志，而这n个类是无法通过源代码修改的(从jar包中引入的)。通过静态代理实现的话将会有n个新的代理类产生，而使用动态代理的话，只需一个类即可。\n\n动态代理的实现方式有很多，我们只讨论JDK中的动态代理实现。\n\n```\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class DynamicProxyTest {\n\tpublic static void main(String[] args) {\n\t\tSubject subject = (Subject) new DynamicProxy().bind(new RealSubject(\"hello\"));\n\t\tsubject.request();\n\t}\n}\n\ninterface Subject {\n\tvoid request();\n}\n\nclass RealSubject implements Subject{\n\tString str;\n\tpublic RealSubject(String string) {\n\t\tstr = string;\n\t}\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"真实对象打印str: \" + str);\n\t}\n}\n\nclass DynamicProxy implements InvocationHandler {\n\tObject object;\n\tpublic Object bind(Object object) {\n\t\tthis.object = object;\n\t\treturn Proxy.newProxyInstance(object.getClass().getClassLoader(), \n\t\t\t\tobject.getClass().getInterfaces(), this);\n\t}\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\tSystem.out.println(\"代理对象验证...\");\n\t\treturn method.invoke(object, args);\n\t}\n}\n```\n输出：\n```\n代理对象验证...\n真实对象打印str: hello\n```\n可以看到，动态代理实现了与静态代理一样的功能，但他的优点在于代理的真实对象不是确定的，可以在运行时指定，增大了灵活性。如果我们有很多的真实对象需要代理访问，并且他们代理对象中的内容\n都实现了相同的功能，那么我们只需要一个动态代理类即可。\n\n## 动态代理原理\n\n我们通过观察java.lang.reflect.Proxy的源码来了解动态代理的原理。下面的代码截取自openjdk7-b147 (安利一个不错的搜索java源码的网站:http://grepcode.com)\n\n{% asset_img 1.png Proxy %}\n\n上面的方法截取自Proxy.newProxyInstance，可以看到，调用getProxyClass方法获取到一个代理类class对象，然后使用该class对象通过反射方法实例化一个对象返回。\n\n接下来观察getProxyClass方法。\n\n{% asset_img 2.png Proxy %}\n\n这部分代码截取自getProxyClass，先从缓存中查询是否已经生成过对应的class，若有，则直接返回该对象，没有，则继续下一步生成class\n\n{% asset_img 3.png Proxy %}\n\n这部分代码是代理类class对象的生成过程。其中：\n\n`byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);`这行代码调用ProxyGenerator.generateProxyClass返回了代理类class对象的字节码byte序列，\n`proxyClass = defineClass0(loader, proxyName,proxyClassFile, 0, proxyClassFile.length);`这一行则进行了类加载的工作，最终生成了代理类class对象。\n\n{% asset_img 4.png Proxy %}\n\ngenerateProxyClass，其中的gen.generateClassFile()方法实现了字节码的生成。\n\n{% asset_img 5.png Proxy %}\n\ngenerateClassFile方法的实现。开头调用的三个addProxyMethod方法将object类中的hashcode、equals、toString方法重写，故对这三个方法的调用会传递到InvocationHandler.invoke方法当中。\n注意，除了上述三个方法之外，调用代理类中Object定义的其他方法不会传递到invoke方法当中，也就是说，调用这些方法会执行Object中的默认实现。\n\n如果想要查看ProxyGenerator.generateProxyClass这个方法在运行时产生的代理类中写了些什么，可以在main方法中加入：\n\n```\nSystem.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");\n```\n\n运行时会将生成的class文件保存到硬盘当中：$Proxy0.class\n\n```\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\n\npublic final class $Proxy0\n  extends Proxy\n  implements Subject\n{\n  private static Method m1;\n  private static Method m3;\n  private static Method m0;\n  private static Method m2;\n  \n  public $Proxy0(InvocationHandler paramInvocationHandler)\n  {\n    super(paramInvocationHandler);\n  }\n  \n  public final boolean equals(Object paramObject)\n  {\n    try\n    {\n      return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue();\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final void request()\n  {\n    try\n    {\n      this.h.invoke(this, m3, null);\n      return;\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final int hashCode()\n  {\n    try\n    {\n      return ((Integer)this.h.invoke(this, m0, null)).intValue();\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final String toString()\n  {\n    try\n    {\n      return (String)this.h.invoke(this, m2, null);\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  static\n  {\n    try\n    {\n      m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] { Class.forName(\"java.lang.Object\") });\n      m3 = Class.forName(\"Subject\").getMethod(\"request\", new Class[0]);\n      m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]);\n      m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]);\n      return;\n    }\n    catch (NoSuchMethodException localNoSuchMethodException)\n    {\n      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());\n    }\n    catch (ClassNotFoundException localClassNotFoundException)\n    {\n      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());\n    }\n  }\n}\n```\n上面的代码很好理解。可以看到equals、hashCode、toString以及我们Subject接口request方法的实现中都是调用了InvocationHandler.invoke方法，而这个InvocationHandler实例就是我们在Proxy.newProxyInstance中传入的对象。\n\n综上，可以看到实现动态代理的几个步骤：\n\n1.实现InvocationHandler\n\n2.获得动态代理类，这一步又涉及到运行时代理类字节码的生成和类加载\n\n3.通过反射机制（getConstructor(InvocationHandler.class)）获取代理类的实例并返回该对象\n\n4.调用代理对象的目标方法（也就是request方法，代理类也实现了Subject这个接口），调用转发到InvocationHandler.invoke方法当中，执行invoke的逻辑（我们自己的InvocationHandler实现）\n\n至此，我们就了解了动态代理的运行原理。动态代理的机制也有一些缺陷，比如他代理的必须是接口方法。看一下我们上面生成的$Proxy0.class，可知这个代理类已经默认继承了类Proxy，所以，他只能通过实现我们提供的接口来代理我们的方法。在invoke方法中，我们可以通过对传入的代理类、方法和参数来进行判断，对不同的方法实现不同的业务逻辑。\n","slug":"java代理机制","published":1,"updated":"2017-03-29T03:23:00.399Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlra001hvegcahn5vkpb","content":"<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>代理模式，顾名思义，即一个客户不想或者不能直接访问一个对象，需要通过一个称为代理的第三方对象来实现间接引用。代理对象的作用就是客户端和目标对象<br>之间的一个中介，通过代理对象可以隐藏不让用户看到的内容或实现额外的服务。</p>\n<p>代理机制应用的场景有很多：比如在代理对象中实现缓存，验证，权限控制等功能，真正的业务逻辑封装在真实对象中。RMI远程方法调用也用到了代理。当你调用一个远程方法的时候，相当于调用这个方法的代理对象，<br>在代理对象中封装了网络请求等部分，真实对象存在于另一个进程上。重构老旧代码的时候也常常会用到代理模式。</p>\n<p>代理分两种：静态代理和动态代理</p>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><p>静态代理即在代码中手动实现代理模式。代理模式涉及到三个角色：</p>\n<p>真实对象RealSubject、抽象主题Subject、代理对象Proxy</p>\n<img src=\"/2017/03/28/java代理机制/Proxy.jpg\" alt=\"Proxy\" title=\"Proxy\">\n<img src=\"/2017/03/28/java代理机制/seq_Proxy.jpg\" alt=\"seq_Proxy\" title=\"seq_Proxy\">\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ProxyTest &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tnew Proxy(&quot;hello&quot;).request();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">interface Subject &#123;</div><div class=\"line\">\tvoid request();</div><div class=\"line\">&#125;</div><div class=\"line\">class Proxy implements Subject&#123;</div><div class=\"line\">\tString str;</div><div class=\"line\">\tRealSubject subject;</div><div class=\"line\">\tpublic Proxy(String string) &#123;</div><div class=\"line\">\t\tstr = string;</div><div class=\"line\">\t\tsubject = new RealSubject(str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void request() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;代理对象验证机制....&quot;);</div><div class=\"line\">\t\tsubject.request();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class RealSubject implements Subject&#123;</div><div class=\"line\">\tString str;</div><div class=\"line\">\tpublic RealSubject(String string) &#123;</div><div class=\"line\">\t\tstr = string;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void request() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;真实对象打印str: &quot; + str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">代理对象验证机制....</div><div class=\"line\">真实对象打印str: hello</div></pre></td></tr></table></figure></p>\n<p>上面的代码模拟了一个代理对象实现验证机制的过程。可以看到，代码很简单，代理模式也很好理解。<br>（我们在真实生活中不也有代理么,,比如黄牛，帮你买到你买不到的火车票）</p>\n<h2 id=\"JDK动态代理实现\"><a href=\"#JDK动态代理实现\" class=\"headerlink\" title=\"JDK动态代理实现\"></a>JDK动态代理实现</h2><p>动态代理时较为高级的一种代理模式。典型的应用有Spring AOP，RMI。</p>\n<p>在上面的静态代理模式中，真实对象是事先存在的，并且作为代理对象的内部成员属性。一个真实的对象必须对应一个代理对象，如果真实对象很多的话会导致类膨胀。</p>\n<p>另外，如何在事先不知道真实对象的情况下使用代理代理对象，这都是动态代理需要解决的问题。</p>\n<p>比如有n个类需要在执行前打印几行日志，而这n个类是无法通过源代码修改的(从jar包中引入的)。通过静态代理实现的话将会有n个新的代理类产生，而使用动态代理的话，只需一个类即可。</p>\n<p>动态代理的实现方式有很多，我们只讨论JDK中的动态代理实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">import java.lang.reflect.InvocationHandler;</div><div class=\"line\">import java.lang.reflect.Method;</div><div class=\"line\">import java.lang.reflect.Proxy;</div><div class=\"line\"></div><div class=\"line\">public class DynamicProxyTest &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tSubject subject = (Subject) new DynamicProxy().bind(new RealSubject(&quot;hello&quot;));</div><div class=\"line\">\t\tsubject.request();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">interface Subject &#123;</div><div class=\"line\">\tvoid request();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class RealSubject implements Subject&#123;</div><div class=\"line\">\tString str;</div><div class=\"line\">\tpublic RealSubject(String string) &#123;</div><div class=\"line\">\t\tstr = string;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void request() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;真实对象打印str: &quot; + str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class DynamicProxy implements InvocationHandler &#123;</div><div class=\"line\">\tObject object;</div><div class=\"line\">\tpublic Object bind(Object object) &#123;</div><div class=\"line\">\t\tthis.object = object;</div><div class=\"line\">\t\treturn Proxy.newProxyInstance(object.getClass().getClassLoader(), </div><div class=\"line\">\t\t\t\tobject.getClass().getInterfaces(), this);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic Object invoke(Object proxy, Method method, Object[] args)</div><div class=\"line\">\t\t\tthrows Throwable &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;代理对象验证...&quot;);</div><div class=\"line\">\t\treturn method.invoke(object, args);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">代理对象验证...</div><div class=\"line\">真实对象打印str: hello</div></pre></td></tr></table></figure></p>\n<p>可以看到，动态代理实现了与静态代理一样的功能，但他的优点在于代理的真实对象不是确定的，可以在运行时指定，增大了灵活性。如果我们有很多的真实对象需要代理访问，并且他们代理对象中的内容<br>都实现了相同的功能，那么我们只需要一个动态代理类即可。</p>\n<h2 id=\"动态代理原理\"><a href=\"#动态代理原理\" class=\"headerlink\" title=\"动态代理原理\"></a>动态代理原理</h2><p>我们通过观察java.lang.reflect.Proxy的源码来了解动态代理的原理。下面的代码截取自openjdk7-b147 (安利一个不错的搜索java源码的网站:<a href=\"http://grepcode.com\" target=\"_blank\" rel=\"external\">http://grepcode.com</a>)</p>\n<img src=\"/2017/03/28/java代理机制/1.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>上面的方法截取自Proxy.newProxyInstance，可以看到，调用getProxyClass方法获取到一个代理类class对象，然后使用该class对象通过反射方法实例化一个对象返回。</p>\n<p>接下来观察getProxyClass方法。</p>\n<img src=\"/2017/03/28/java代理机制/2.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>这部分代码截取自getProxyClass，先从缓存中查询是否已经生成过对应的class，若有，则直接返回该对象，没有，则继续下一步生成class</p>\n<img src=\"/2017/03/28/java代理机制/3.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>这部分代码是代理类class对象的生成过程。其中：</p>\n<p><code>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);</code>这行代码调用ProxyGenerator.generateProxyClass返回了代理类class对象的字节码byte序列，<br><code>proxyClass = defineClass0(loader, proxyName,proxyClassFile, 0, proxyClassFile.length);</code>这一行则进行了类加载的工作，最终生成了代理类class对象。</p>\n<img src=\"/2017/03/28/java代理机制/4.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>generateProxyClass，其中的gen.generateClassFile()方法实现了字节码的生成。</p>\n<img src=\"/2017/03/28/java代理机制/5.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>generateClassFile方法的实现。开头调用的三个addProxyMethod方法将object类中的hashcode、equals、toString方法重写，故对这三个方法的调用会传递到InvocationHandler.invoke方法当中。<br>注意，除了上述三个方法之外，调用代理类中Object定义的其他方法不会传递到invoke方法当中，也就是说，调用这些方法会执行Object中的默认实现。</p>\n<p>如果想要查看ProxyGenerator.generateProxyClass这个方法在运行时产生的代理类中写了些什么，可以在main方法中加入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</div></pre></td></tr></table></figure>\n<p>运行时会将生成的class文件保存到硬盘当中：$Proxy0.class</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div></pre></td><td class=\"code\"><pre><div class=\"line\">import java.lang.reflect.InvocationHandler;</div><div class=\"line\">import java.lang.reflect.Method;</div><div class=\"line\">import java.lang.reflect.Proxy;</div><div class=\"line\">import java.lang.reflect.UndeclaredThrowableException;</div><div class=\"line\"></div><div class=\"line\">public final class $Proxy0</div><div class=\"line\">  extends Proxy</div><div class=\"line\">  implements Subject</div><div class=\"line\">&#123;</div><div class=\"line\">  private static Method m1;</div><div class=\"line\">  private static Method m3;</div><div class=\"line\">  private static Method m0;</div><div class=\"line\">  private static Method m2;</div><div class=\"line\">  </div><div class=\"line\">  public $Proxy0(InvocationHandler paramInvocationHandler)</div><div class=\"line\">  &#123;</div><div class=\"line\">    super(paramInvocationHandler);</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final boolean equals(Object paramObject)</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final void request()</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      this.h.invoke(this, m3, null);</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final int hashCode()</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      return ((Integer)this.h.invoke(this, m0, null)).intValue();</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final String toString()</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      return (String)this.h.invoke(this, m2, null);</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  static</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</div><div class=\"line\">      m3 = Class.forName(&quot;Subject&quot;).getMethod(&quot;request&quot;, new Class[0]);</div><div class=\"line\">      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</div><div class=\"line\">      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (NoSuchMethodException localNoSuchMethodException)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (ClassNotFoundException localClassNotFoundException)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码很好理解。可以看到equals、hashCode、toString以及我们Subject接口request方法的实现中都是调用了InvocationHandler.invoke方法，而这个InvocationHandler实例就是我们在Proxy.newProxyInstance中传入的对象。</p>\n<p>综上，可以看到实现动态代理的几个步骤：</p>\n<p>1.实现InvocationHandler</p>\n<p>2.获得动态代理类，这一步又涉及到运行时代理类字节码的生成和类加载</p>\n<p>3.通过反射机制（getConstructor(InvocationHandler.class)）获取代理类的实例并返回该对象</p>\n<p>4.调用代理对象的目标方法（也就是request方法，代理类也实现了Subject这个接口），调用转发到InvocationHandler.invoke方法当中，执行invoke的逻辑（我们自己的InvocationHandler实现）</p>\n<p>至此，我们就了解了动态代理的运行原理。动态代理的机制也有一些缺陷，比如他代理的必须是接口方法。看一下我们上面生成的$Proxy0.class，可知这个代理类已经默认继承了类Proxy，所以，他只能通过实现我们提供的接口来代理我们的方法。在invoke方法中，我们可以通过对传入的代理类、方法和参数来进行判断，对不同的方法实现不同的业务逻辑。</p>\n","excerpt":"","more":"<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>代理模式，顾名思义，即一个客户不想或者不能直接访问一个对象，需要通过一个称为代理的第三方对象来实现间接引用。代理对象的作用就是客户端和目标对象<br>之间的一个中介，通过代理对象可以隐藏不让用户看到的内容或实现额外的服务。</p>\n<p>代理机制应用的场景有很多：比如在代理对象中实现缓存，验证，权限控制等功能，真正的业务逻辑封装在真实对象中。RMI远程方法调用也用到了代理。当你调用一个远程方法的时候，相当于调用这个方法的代理对象，<br>在代理对象中封装了网络请求等部分，真实对象存在于另一个进程上。重构老旧代码的时候也常常会用到代理模式。</p>\n<p>代理分两种：静态代理和动态代理</p>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><p>静态代理即在代码中手动实现代理模式。代理模式涉及到三个角色：</p>\n<p>真实对象RealSubject、抽象主题Subject、代理对象Proxy</p>\n<img src=\"/2017/03/28/java代理机制/Proxy.jpg\" alt=\"Proxy\" title=\"Proxy\">\n<img src=\"/2017/03/28/java代理机制/seq_Proxy.jpg\" alt=\"seq_Proxy\" title=\"seq_Proxy\">\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ProxyTest &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tnew Proxy(&quot;hello&quot;).request();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">interface Subject &#123;</div><div class=\"line\">\tvoid request();</div><div class=\"line\">&#125;</div><div class=\"line\">class Proxy implements Subject&#123;</div><div class=\"line\">\tString str;</div><div class=\"line\">\tRealSubject subject;</div><div class=\"line\">\tpublic Proxy(String string) &#123;</div><div class=\"line\">\t\tstr = string;</div><div class=\"line\">\t\tsubject = new RealSubject(str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void request() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;代理对象验证机制....&quot;);</div><div class=\"line\">\t\tsubject.request();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class RealSubject implements Subject&#123;</div><div class=\"line\">\tString str;</div><div class=\"line\">\tpublic RealSubject(String string) &#123;</div><div class=\"line\">\t\tstr = string;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void request() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;真实对象打印str: &quot; + str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">代理对象验证机制....</div><div class=\"line\">真实对象打印str: hello</div></pre></td></tr></table></figure></p>\n<p>上面的代码模拟了一个代理对象实现验证机制的过程。可以看到，代码很简单，代理模式也很好理解。<br>（我们在真实生活中不也有代理么,,比如黄牛，帮你买到你买不到的火车票）</p>\n<h2 id=\"JDK动态代理实现\"><a href=\"#JDK动态代理实现\" class=\"headerlink\" title=\"JDK动态代理实现\"></a>JDK动态代理实现</h2><p>动态代理时较为高级的一种代理模式。典型的应用有Spring AOP，RMI。</p>\n<p>在上面的静态代理模式中，真实对象是事先存在的，并且作为代理对象的内部成员属性。一个真实的对象必须对应一个代理对象，如果真实对象很多的话会导致类膨胀。</p>\n<p>另外，如何在事先不知道真实对象的情况下使用代理代理对象，这都是动态代理需要解决的问题。</p>\n<p>比如有n个类需要在执行前打印几行日志，而这n个类是无法通过源代码修改的(从jar包中引入的)。通过静态代理实现的话将会有n个新的代理类产生，而使用动态代理的话，只需一个类即可。</p>\n<p>动态代理的实现方式有很多，我们只讨论JDK中的动态代理实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">import java.lang.reflect.InvocationHandler;</div><div class=\"line\">import java.lang.reflect.Method;</div><div class=\"line\">import java.lang.reflect.Proxy;</div><div class=\"line\"></div><div class=\"line\">public class DynamicProxyTest &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tSubject subject = (Subject) new DynamicProxy().bind(new RealSubject(&quot;hello&quot;));</div><div class=\"line\">\t\tsubject.request();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">interface Subject &#123;</div><div class=\"line\">\tvoid request();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class RealSubject implements Subject&#123;</div><div class=\"line\">\tString str;</div><div class=\"line\">\tpublic RealSubject(String string) &#123;</div><div class=\"line\">\t\tstr = string;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void request() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;真实对象打印str: &quot; + str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class DynamicProxy implements InvocationHandler &#123;</div><div class=\"line\">\tObject object;</div><div class=\"line\">\tpublic Object bind(Object object) &#123;</div><div class=\"line\">\t\tthis.object = object;</div><div class=\"line\">\t\treturn Proxy.newProxyInstance(object.getClass().getClassLoader(), </div><div class=\"line\">\t\t\t\tobject.getClass().getInterfaces(), this);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic Object invoke(Object proxy, Method method, Object[] args)</div><div class=\"line\">\t\t\tthrows Throwable &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;代理对象验证...&quot;);</div><div class=\"line\">\t\treturn method.invoke(object, args);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">代理对象验证...</div><div class=\"line\">真实对象打印str: hello</div></pre></td></tr></table></figure></p>\n<p>可以看到，动态代理实现了与静态代理一样的功能，但他的优点在于代理的真实对象不是确定的，可以在运行时指定，增大了灵活性。如果我们有很多的真实对象需要代理访问，并且他们代理对象中的内容<br>都实现了相同的功能，那么我们只需要一个动态代理类即可。</p>\n<h2 id=\"动态代理原理\"><a href=\"#动态代理原理\" class=\"headerlink\" title=\"动态代理原理\"></a>动态代理原理</h2><p>我们通过观察java.lang.reflect.Proxy的源码来了解动态代理的原理。下面的代码截取自openjdk7-b147 (安利一个不错的搜索java源码的网站:<a href=\"http://grepcode.com\">http://grepcode.com</a>)</p>\n<img src=\"/2017/03/28/java代理机制/1.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>上面的方法截取自Proxy.newProxyInstance，可以看到，调用getProxyClass方法获取到一个代理类class对象，然后使用该class对象通过反射方法实例化一个对象返回。</p>\n<p>接下来观察getProxyClass方法。</p>\n<img src=\"/2017/03/28/java代理机制/2.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>这部分代码截取自getProxyClass，先从缓存中查询是否已经生成过对应的class，若有，则直接返回该对象，没有，则继续下一步生成class</p>\n<img src=\"/2017/03/28/java代理机制/3.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>这部分代码是代理类class对象的生成过程。其中：</p>\n<p><code>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);</code>这行代码调用ProxyGenerator.generateProxyClass返回了代理类class对象的字节码byte序列，<br><code>proxyClass = defineClass0(loader, proxyName,proxyClassFile, 0, proxyClassFile.length);</code>这一行则进行了类加载的工作，最终生成了代理类class对象。</p>\n<img src=\"/2017/03/28/java代理机制/4.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>generateProxyClass，其中的gen.generateClassFile()方法实现了字节码的生成。</p>\n<img src=\"/2017/03/28/java代理机制/5.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>generateClassFile方法的实现。开头调用的三个addProxyMethod方法将object类中的hashcode、equals、toString方法重写，故对这三个方法的调用会传递到InvocationHandler.invoke方法当中。<br>注意，除了上述三个方法之外，调用代理类中Object定义的其他方法不会传递到invoke方法当中，也就是说，调用这些方法会执行Object中的默认实现。</p>\n<p>如果想要查看ProxyGenerator.generateProxyClass这个方法在运行时产生的代理类中写了些什么，可以在main方法中加入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</div></pre></td></tr></table></figure>\n<p>运行时会将生成的class文件保存到硬盘当中：$Proxy0.class</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div></pre></td><td class=\"code\"><pre><div class=\"line\">import java.lang.reflect.InvocationHandler;</div><div class=\"line\">import java.lang.reflect.Method;</div><div class=\"line\">import java.lang.reflect.Proxy;</div><div class=\"line\">import java.lang.reflect.UndeclaredThrowableException;</div><div class=\"line\"></div><div class=\"line\">public final class $Proxy0</div><div class=\"line\">  extends Proxy</div><div class=\"line\">  implements Subject</div><div class=\"line\">&#123;</div><div class=\"line\">  private static Method m1;</div><div class=\"line\">  private static Method m3;</div><div class=\"line\">  private static Method m0;</div><div class=\"line\">  private static Method m2;</div><div class=\"line\">  </div><div class=\"line\">  public $Proxy0(InvocationHandler paramInvocationHandler)</div><div class=\"line\">  &#123;</div><div class=\"line\">    super(paramInvocationHandler);</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final boolean equals(Object paramObject)</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final void request()</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      this.h.invoke(this, m3, null);</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final int hashCode()</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      return ((Integer)this.h.invoke(this, m0, null)).intValue();</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final String toString()</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      return (String)this.h.invoke(this, m2, null);</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  static</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</div><div class=\"line\">      m3 = Class.forName(&quot;Subject&quot;).getMethod(&quot;request&quot;, new Class[0]);</div><div class=\"line\">      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</div><div class=\"line\">      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (NoSuchMethodException localNoSuchMethodException)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (ClassNotFoundException localClassNotFoundException)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码很好理解。可以看到equals、hashCode、toString以及我们Subject接口request方法的实现中都是调用了InvocationHandler.invoke方法，而这个InvocationHandler实例就是我们在Proxy.newProxyInstance中传入的对象。</p>\n<p>综上，可以看到实现动态代理的几个步骤：</p>\n<p>1.实现InvocationHandler</p>\n<p>2.获得动态代理类，这一步又涉及到运行时代理类字节码的生成和类加载</p>\n<p>3.通过反射机制（getConstructor(InvocationHandler.class)）获取代理类的实例并返回该对象</p>\n<p>4.调用代理对象的目标方法（也就是request方法，代理类也实现了Subject这个接口），调用转发到InvocationHandler.invoke方法当中，执行invoke的逻辑（我们自己的InvocationHandler实现）</p>\n<p>至此，我们就了解了动态代理的运行原理。动态代理的机制也有一些缺陷，比如他代理的必须是接口方法。看一下我们上面生成的$Proxy0.class，可知这个代理类已经默认继承了类Proxy，所以，他只能通过实现我们提供的接口来代理我们的方法。在invoke方法中，我们可以通过对传入的代理类、方法和参数来进行判断，对不同的方法实现不同的业务逻辑。</p>\n"},{"layout":"post","title":"java同步锁锁什么","date":"2015-12-17T06:10:55.000Z","_content":"\n在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：\n情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;\nThreadTest中的成员变量 j 被赋值为 i \n在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;\n在synchronized块中，我改变了这个 j 的值。代码大概是这样的：\n\n```\t\t\t\t\t   \nInteger j;\nThreadTest(Integer i){\n\t\tj=i;\n}\npublic void run() {\n\t\tsynchronized(j){\n\t\t  j++;\n\t\t}\n}\n\n```\n\n1. 一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。\n\n2. 另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。\n\n苦逼了。结果不对\n后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，\n即 void test(Object  i){\n\t\ti.dosomething()......\n   }\n函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。\n这样就解释了出错的 原因：\nInteger 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。\n所以 \n\n对于 1. \n\n当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望\n\n对于 2. \n\n使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步\n\t\t\t\t\t\t\t\n上面的情况也证明了，**synchronized 锁的是内存 ，而不是指向内存的引用**。\n\t\t\t\t\t\t\t\n这样的情况也说明了另外一种情况的问题，那就是**在函数中给实参分配内存,实际在函数体外是得不到这个对象的**。\n\t\t\t\t\t\t\t\n解决的办法：\n放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，\n各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。","source":"_posts/java同步锁锁什么.md","raw":"---\nlayout: post\ntitle:  \"java同步锁锁什么\"\ndate:   2015-12-17 14:10:55\ncategories: 编程\ntags: \n- java\n- 多线程\n---\n\n在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：\n情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;\nThreadTest中的成员变量 j 被赋值为 i \n在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;\n在synchronized块中，我改变了这个 j 的值。代码大概是这样的：\n\n```\t\t\t\t\t   \nInteger j;\nThreadTest(Integer i){\n\t\tj=i;\n}\npublic void run() {\n\t\tsynchronized(j){\n\t\t  j++;\n\t\t}\n}\n\n```\n\n1. 一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。\n\n2. 另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。\n\n苦逼了。结果不对\n后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，\n即 void test(Object  i){\n\t\ti.dosomething()......\n   }\n函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。\n这样就解释了出错的 原因：\nInteger 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。\n所以 \n\n对于 1. \n\n当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望\n\n对于 2. \n\n使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步\n\t\t\t\t\t\t\t\n上面的情况也证明了，**synchronized 锁的是内存 ，而不是指向内存的引用**。\n\t\t\t\t\t\t\t\n这样的情况也说明了另外一种情况的问题，那就是**在函数中给实参分配内存,实际在函数体外是得不到这个对象的**。\n\t\t\t\t\t\t\t\n解决的办法：\n放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，\n各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。","slug":"java同步锁锁什么","published":1,"updated":"2017-02-19T13:08:11.034Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlrc001lvegc5pxbuqk7","content":"<p>在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：<br>情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;<br>ThreadTest中的成员变量 j 被赋值为 i<br>在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;<br>在synchronized块中，我改变了这个 j 的值。代码大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer j;</div><div class=\"line\">ThreadTest(Integer i)&#123;</div><div class=\"line\">\t\tj=i;</div><div class=\"line\">&#125;</div><div class=\"line\">public void run() &#123;</div><div class=\"line\">\t\tsynchronized(j)&#123;</div><div class=\"line\">\t\t  j++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。</p>\n</li>\n<li><p>另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。</p>\n</li>\n</ol>\n<p>苦逼了。结果不对<br>后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，<br>即 void test(Object  i){<br>        i.dosomething()……<br>   }<br>函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。<br>这样就解释了出错的 原因：<br>Integer 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。<br>所以 </p>\n<p>对于 1. </p>\n<p>当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望</p>\n<p>对于 2. </p>\n<p>使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步</p>\n<p>上面的情况也证明了，<strong>synchronized 锁的是内存 ，而不是指向内存的引用</strong>。</p>\n<p>这样的情况也说明了另外一种情况的问题，那就是<strong>在函数中给实参分配内存,实际在函数体外是得不到这个对象的</strong>。</p>\n<p>解决的办法：<br>放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，<br>各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。</p>\n","excerpt":"","more":"<p>在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：<br>情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;<br>ThreadTest中的成员变量 j 被赋值为 i<br>在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;<br>在synchronized块中，我改变了这个 j 的值。代码大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer j;</div><div class=\"line\">ThreadTest(Integer i)&#123;</div><div class=\"line\">\t\tj=i;</div><div class=\"line\">&#125;</div><div class=\"line\">public void run() &#123;</div><div class=\"line\">\t\tsynchronized(j)&#123;</div><div class=\"line\">\t\t  j++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。</p>\n</li>\n<li><p>另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。</p>\n</li>\n</ol>\n<p>苦逼了。结果不对<br>后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，<br>即 void test(Object  i){<br>        i.dosomething()……<br>   }<br>函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。<br>这样就解释了出错的 原因：<br>Integer 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。<br>所以 </p>\n<p>对于 1. </p>\n<p>当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望</p>\n<p>对于 2. </p>\n<p>使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步</p>\n<p>上面的情况也证明了，<strong>synchronized 锁的是内存 ，而不是指向内存的引用</strong>。</p>\n<p>这样的情况也说明了另外一种情况的问题，那就是<strong>在函数中给实参分配内存,实际在函数体外是得不到这个对象的</strong>。</p>\n<p>解决的办法：<br>放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，<br>各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。</p>\n"},{"layout":"post","title":"java国际化","date":"2017-02-19T11:32:40.000Z","_content":"\n> 使用java编写一个带GUI程序或者其他需要给用户传递文字信息的程序的时候，就很有可能需要用到国际化的知识，来总结一下。\n\n所谓的国际化，就是使编写的程序可以适应不同的语言环境，比如，在中文环境下，可以与用户使用中文交互，在英文环境下则切换为英文。而这个切换过程不需要修改代码或者仅仅修改少量的代码。java给我们提供了这样的实现。\n\n## java文件国际化\n\n我们通过将与界面显示有关系的资源提取出来到资源文件中，然后读取不同的资源文件来达到国际化的目的。在java中，这些是通过ResourceBundle这个类来实现的。\n\nResourceBundle分为两种，一种是ListResourceBundle,另一种是PropertyResourceBundle。下面介绍这两种ResourceBundle的使用方法：\n\n首先列出demo工程的代码结构：\n\n```\nTestResourceBundle\n|\n|--src\n    |\n    |--kyu\n        |\n        |--bundle\n        |    |\n        |    |--ListResourceTranslator.java\n        |    |\n        |    |--PropertyResourceTranslator.java\n        |    |\n        |    |--ResourceTranslator.java\n        |\n        |--test\n        |   |\n        |   |--App.java\n        |\n        |--Errors_en_Us.java\n        |\n        |--Errors_zh_CN.java\n        |\n        |--Errors.java\n        |\n        |--Errors_en_Us.properties\n        |\n        |--Errors_zh_CN.properties\n        |\n        |--Errors.properties\n        \n```\n\n### PropertyResourceBundle\n\n1. 首先需要建立若干语言的properties文件： 自定义名_语言代码_国别代码.properties\n\n比如：errors_en_US.properties, errors_zh_CN.properties\n\n其中的语言代码和国别代码，分别是你要国际化的语言。需要几种语言，就添加几个properties文件。\n\n[国别代码](https://worldwide.espacenet.com/help?locale=cn_EP&method=handleHelpTopic&topic=countrycodes)\n\n[语言代码](http://www.lingoes.cn/zh/translator/langcode.htm)\n\n通过打印java所支持的语言和国家查看：\n\n```\nprivate static void printLocal() {\n\t\tLocale[] localeList = Locale.getAvailableLocales();\n\t\tfor (int i = 0; i < localeList.length; i++) {\n\t\t\tSystem.out.println(localeList[i].getDisplayCountry() + \": \" + localeList[i].getCountry());\n\t\t\tSystem.out.println(localeList[i].getDisplayLanguage() + \": \" + localeList[i].getLanguage());\n\t\t}\n}\n```\n\n2. 建立默认语言的properties文件：自定义名.properties\n\n比如：errors.properties\n\n当所需语言的properties文件不存在的时候就会默认读取这个文件中的内容\n\n注意，资源文件都必须是ISO-8859-1编码，对于中文等非西方语系，可通过JDK自带的工具native2ascii进行处理，在Eclipse中也可以安装插件SimplePropertiesEditor来处理这类文件。\n\n3. 使用\n\nResourceTranslator.java\n\n```\npackage kyu.bundle;\n\nimport java.util.Locale;\nimport java.util.ResourceBundle;\n\npublic abstract class ResourceTranslator {\n\tprotected ResourceBundle bundle;\n\tprotected Locale lc;\n\tprotected static final String PROP_FILE = \"kyu.errors\";\n\n    public String translate(String id) {\n        return bundle.getString(id);\n    }\n}\n```\n\nPropertyResourceTranslator.java\n\n```\npackage kyu.bundle;\n\nimport java.util.Locale;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\n\npublic class PropertyResourceTranslator extends ResourceTranslator{\n    public PropertyResourceTranslator() {\n        lc = Locale.getDefault();\n        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);\n    }\n    \n    public PropertyResourceTranslator(String language, String country) {\n    \tlc = new Locale(language, country);\n        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);\n    }\n\n}\n```\n\nApp.java\n\n```\npackage kyu.test;\n\nimport kyu.bundle.ListResourceTranslator;\nimport kyu.bundle.PropertyResourceTranslator;\n\npublic class App {\n\tpublic static void main(String[] args) {\n\t\ttestPropertyResource();\n\t}\n\n\tprivate static void testPropertyResource() {\n\t\tPropertyResourceTranslator translatorDefault = new PropertyResourceTranslator();\n\t\tPropertyResourceTranslator translatorZH = new PropertyResourceTranslator(\"zh\", \"CN\");\n\t\tPropertyResourceTranslator translatorEN = new PropertyResourceTranslator(\"en\", \"US\");\n\t\tString def = translatorDefault.translate(\"ERROR-001\");\n\t\tString zh = translatorZH.translate(\"ERROR-001\");\n\t\tString en = translatorEN.translate(\"ERROR-001\");\n\t\t\n\t\tSystem.out.println(\"test PropertyResourceBundle>>>>>>\");\n\t\tSystem.out.println(\"default: \" + def);\n\t\tSystem.out.println(\"zh: \" + zh);\n\t\tSystem.out.println(\"en: \" + en);\n\t}\t\n\t\n}\n```\n.properties文件内容：\n\n```\nErrors_en_Us.properties:\nERROR-001=error password\n\nErrors.properties\nERROR-001=error password\n\nErrors_zh_CN.properties\nERROR-001=密码错误\n```\n\n执行App.java的测试结果：\n\n```\ntest PropertyResourceBundle>>>>>>\ndefault: 密码错误\nzh: 密码错误\nen: error password\n```\n\n可以看到，通过指定Local构造函数的语言和国别代码，就能自动找到对应的.properties，并匹配其中的内容。\n\n当使用Locale.getDefault()时，自动检测当前的系统环境，从而选择对应的语言。\n\n还有一点要注意的是： \n\nPropertyResourceBundle.getBundle(PROP_FILE, lc); \n\n其中PROP_FILE，为properties文件的路径，此路径为properties文件的完整路径，即 所在完整包名.自定义名称\n\n### ListResourceBundle\n\nListResourceBundle的使用与PropertyResourceBundle的使用大同小异，不过是将properties文件换成了.java文件\n\nListResourceTranslator.java\n\n```\npackage kyu.bundle;\n\nimport java.util.ListResourceBundle;\nimport java.util.Locale;\n\npublic class ListResourceTranslator extends ResourceTranslator{\n\tpublic ListResourceTranslator() {\n        lc = Locale.getDefault();\n        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);\n    }\n    \n    public ListResourceTranslator(String language, String country) {\n    \tlc = new Locale(language, country);\n        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);\n    }\n}\n\n```\n\nERRORS_en_US.java\n\n```\npackage kyu;\n\nimport java.util.ListResourceBundle;\n\npublic class ERRORS_en_US extends ListResourceBundle{\n\tstatic final Object[][] contents = new String[][] { \n\t\t{ \"ERROR-001\", \"error password\" } \n\t};\n\n\tpublic Object[][] getContents() {\n\t\treturn contents;\n\t}\n}\n\n```\n\nERRORS_zh_CN.java\n\n```\npackage kyu;\n\nimport java.util.ListResourceBundle;\n\npublic class ERRORS_zh_CN extends ListResourceBundle {\n\tstatic final Object[][] contents = new String[][] { \n\t\t{ \"ERROR-001\", \"密码错误\" } \n\t};\n\n\tpublic Object[][] getContents() {\n\t\treturn contents;\n\t}\n}\n\n```\n\n继承了ListResourceBundle的类就相当于前面的properties文件，需要提供一个getContents()方法，返回对应的键值对。\n\n同样的，要注意ListResourceBundle子类的命名规则，与properties文件相同，路径也与properties文件相同。\n\n通过App.java的测试(将对应的bundle替换)，可以得到相同的测试结果。\n\n### 使用Eclipse对java文件进行国际化\n\n在需要国际化的类文件上点击右键->Source->Externalize Strings...\n\n出现窗口，Eclipse会自动检测类文件中的字符串，在窗口中可以选择相应的字符串，最后自动生成类似于上面的PropertyResourceTranslator.java和properties文件，完成国际化。\n\n其原理与以上所讲的相同，故不再详细说明。\n\n## Eclipse RCP国际化\n\n> 最近在使用Eclipse RCP这项技术开发程序，其中也有国际化相关的东西，总结下来。\n\n[Eclipse RCP and Plugin Internationalization - Tutorial](http://www.vogella.com/tutorials/EclipseInternationalization/article.html)\n\n上面这篇文章详细的说明了Eclipse RCP工程中的国际化问题，可以作为一个备忘录。下面介绍一下eclipse rcp中比较常用到的国际化方式：\n\n### plugin.xml文件国际化\n\nplugin.xml文件中保存了扩展点等相关的信息，当扩展点与界面UI相关时，就需要用到国际化\n\n1. 在工程的根目录下面建立一个plugin.properties资源文件，此文件类似于我们上面提到的errors.properties。当然，也可以建立plugin_zh.properties等文件，这些文件名中的plugin是可以自由定义的。\n\n2. 在 MANIFEST.MF文件中增加代码行：Bundle-Localization: plugin\n\n   注意，这个plugin与上面的properties文件名保持一致。\n\n3. plugin.xml配置文件对资源文件进行引用时, 在引用的key前面加一个%，比如：\n\n```\n<view\n    id=\"org.jkiss.dbeaver.core.databaseNavigator\"\n    category=\"org.jkiss.dbeaver.core.category\"\n    class=\"org.jkiss.dbeaver.ui.navigator.database.DatabaseNavigatorView\"\n    allowMultiple=\"false\"\n    icon=\"icons/databases.png\"\n    name=\"%view.database.navigator.title\"/>\n<view\n```\n\n### 类文件国际化\n\n与前面所介绍的java类文件国际化相同，也可以通过选择类文件点击右键->Source->Externalize Strings...\n\nEclipse IDE会自动帮你完成国际化的一些工作，同样也生成了相关的类和properties文件，但不同的是，生成的类文件内容类似于：\n\n```\npackage test;\n\nimport org.eclipse.osgi.util.NLS;\n\npublic class Messages extends NLS {\n        private static final String BUNDLE_NAME\n                = \"test.messages\"; //$NON-NLS-1$\n        public static String View_0;\n        public static String View_1;\n        static {\n                // initialize resource bundle\n                NLS.initializeMessages(BUNDLE_NAME, Messages.class);\n        }\n\n        private Messages() {\n        }\n}\n```\n\n当然，我们也可以手动建立这些文件进行国际化操作~~不再详细说明，可以通过观察IDE的行为进行我们手动的国际化操作~","source":"_posts/java国际化.md","raw":"---\nlayout: post\ntitle: java国际化\ndate: 2017-02-19 19:32:40\ncategories: 技术\ntags: java\n---\n\n> 使用java编写一个带GUI程序或者其他需要给用户传递文字信息的程序的时候，就很有可能需要用到国际化的知识，来总结一下。\n\n所谓的国际化，就是使编写的程序可以适应不同的语言环境，比如，在中文环境下，可以与用户使用中文交互，在英文环境下则切换为英文。而这个切换过程不需要修改代码或者仅仅修改少量的代码。java给我们提供了这样的实现。\n\n## java文件国际化\n\n我们通过将与界面显示有关系的资源提取出来到资源文件中，然后读取不同的资源文件来达到国际化的目的。在java中，这些是通过ResourceBundle这个类来实现的。\n\nResourceBundle分为两种，一种是ListResourceBundle,另一种是PropertyResourceBundle。下面介绍这两种ResourceBundle的使用方法：\n\n首先列出demo工程的代码结构：\n\n```\nTestResourceBundle\n|\n|--src\n    |\n    |--kyu\n        |\n        |--bundle\n        |    |\n        |    |--ListResourceTranslator.java\n        |    |\n        |    |--PropertyResourceTranslator.java\n        |    |\n        |    |--ResourceTranslator.java\n        |\n        |--test\n        |   |\n        |   |--App.java\n        |\n        |--Errors_en_Us.java\n        |\n        |--Errors_zh_CN.java\n        |\n        |--Errors.java\n        |\n        |--Errors_en_Us.properties\n        |\n        |--Errors_zh_CN.properties\n        |\n        |--Errors.properties\n        \n```\n\n### PropertyResourceBundle\n\n1. 首先需要建立若干语言的properties文件： 自定义名_语言代码_国别代码.properties\n\n比如：errors_en_US.properties, errors_zh_CN.properties\n\n其中的语言代码和国别代码，分别是你要国际化的语言。需要几种语言，就添加几个properties文件。\n\n[国别代码](https://worldwide.espacenet.com/help?locale=cn_EP&method=handleHelpTopic&topic=countrycodes)\n\n[语言代码](http://www.lingoes.cn/zh/translator/langcode.htm)\n\n通过打印java所支持的语言和国家查看：\n\n```\nprivate static void printLocal() {\n\t\tLocale[] localeList = Locale.getAvailableLocales();\n\t\tfor (int i = 0; i < localeList.length; i++) {\n\t\t\tSystem.out.println(localeList[i].getDisplayCountry() + \": \" + localeList[i].getCountry());\n\t\t\tSystem.out.println(localeList[i].getDisplayLanguage() + \": \" + localeList[i].getLanguage());\n\t\t}\n}\n```\n\n2. 建立默认语言的properties文件：自定义名.properties\n\n比如：errors.properties\n\n当所需语言的properties文件不存在的时候就会默认读取这个文件中的内容\n\n注意，资源文件都必须是ISO-8859-1编码，对于中文等非西方语系，可通过JDK自带的工具native2ascii进行处理，在Eclipse中也可以安装插件SimplePropertiesEditor来处理这类文件。\n\n3. 使用\n\nResourceTranslator.java\n\n```\npackage kyu.bundle;\n\nimport java.util.Locale;\nimport java.util.ResourceBundle;\n\npublic abstract class ResourceTranslator {\n\tprotected ResourceBundle bundle;\n\tprotected Locale lc;\n\tprotected static final String PROP_FILE = \"kyu.errors\";\n\n    public String translate(String id) {\n        return bundle.getString(id);\n    }\n}\n```\n\nPropertyResourceTranslator.java\n\n```\npackage kyu.bundle;\n\nimport java.util.Locale;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\n\npublic class PropertyResourceTranslator extends ResourceTranslator{\n    public PropertyResourceTranslator() {\n        lc = Locale.getDefault();\n        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);\n    }\n    \n    public PropertyResourceTranslator(String language, String country) {\n    \tlc = new Locale(language, country);\n        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);\n    }\n\n}\n```\n\nApp.java\n\n```\npackage kyu.test;\n\nimport kyu.bundle.ListResourceTranslator;\nimport kyu.bundle.PropertyResourceTranslator;\n\npublic class App {\n\tpublic static void main(String[] args) {\n\t\ttestPropertyResource();\n\t}\n\n\tprivate static void testPropertyResource() {\n\t\tPropertyResourceTranslator translatorDefault = new PropertyResourceTranslator();\n\t\tPropertyResourceTranslator translatorZH = new PropertyResourceTranslator(\"zh\", \"CN\");\n\t\tPropertyResourceTranslator translatorEN = new PropertyResourceTranslator(\"en\", \"US\");\n\t\tString def = translatorDefault.translate(\"ERROR-001\");\n\t\tString zh = translatorZH.translate(\"ERROR-001\");\n\t\tString en = translatorEN.translate(\"ERROR-001\");\n\t\t\n\t\tSystem.out.println(\"test PropertyResourceBundle>>>>>>\");\n\t\tSystem.out.println(\"default: \" + def);\n\t\tSystem.out.println(\"zh: \" + zh);\n\t\tSystem.out.println(\"en: \" + en);\n\t}\t\n\t\n}\n```\n.properties文件内容：\n\n```\nErrors_en_Us.properties:\nERROR-001=error password\n\nErrors.properties\nERROR-001=error password\n\nErrors_zh_CN.properties\nERROR-001=密码错误\n```\n\n执行App.java的测试结果：\n\n```\ntest PropertyResourceBundle>>>>>>\ndefault: 密码错误\nzh: 密码错误\nen: error password\n```\n\n可以看到，通过指定Local构造函数的语言和国别代码，就能自动找到对应的.properties，并匹配其中的内容。\n\n当使用Locale.getDefault()时，自动检测当前的系统环境，从而选择对应的语言。\n\n还有一点要注意的是： \n\nPropertyResourceBundle.getBundle(PROP_FILE, lc); \n\n其中PROP_FILE，为properties文件的路径，此路径为properties文件的完整路径，即 所在完整包名.自定义名称\n\n### ListResourceBundle\n\nListResourceBundle的使用与PropertyResourceBundle的使用大同小异，不过是将properties文件换成了.java文件\n\nListResourceTranslator.java\n\n```\npackage kyu.bundle;\n\nimport java.util.ListResourceBundle;\nimport java.util.Locale;\n\npublic class ListResourceTranslator extends ResourceTranslator{\n\tpublic ListResourceTranslator() {\n        lc = Locale.getDefault();\n        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);\n    }\n    \n    public ListResourceTranslator(String language, String country) {\n    \tlc = new Locale(language, country);\n        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);\n    }\n}\n\n```\n\nERRORS_en_US.java\n\n```\npackage kyu;\n\nimport java.util.ListResourceBundle;\n\npublic class ERRORS_en_US extends ListResourceBundle{\n\tstatic final Object[][] contents = new String[][] { \n\t\t{ \"ERROR-001\", \"error password\" } \n\t};\n\n\tpublic Object[][] getContents() {\n\t\treturn contents;\n\t}\n}\n\n```\n\nERRORS_zh_CN.java\n\n```\npackage kyu;\n\nimport java.util.ListResourceBundle;\n\npublic class ERRORS_zh_CN extends ListResourceBundle {\n\tstatic final Object[][] contents = new String[][] { \n\t\t{ \"ERROR-001\", \"密码错误\" } \n\t};\n\n\tpublic Object[][] getContents() {\n\t\treturn contents;\n\t}\n}\n\n```\n\n继承了ListResourceBundle的类就相当于前面的properties文件，需要提供一个getContents()方法，返回对应的键值对。\n\n同样的，要注意ListResourceBundle子类的命名规则，与properties文件相同，路径也与properties文件相同。\n\n通过App.java的测试(将对应的bundle替换)，可以得到相同的测试结果。\n\n### 使用Eclipse对java文件进行国际化\n\n在需要国际化的类文件上点击右键->Source->Externalize Strings...\n\n出现窗口，Eclipse会自动检测类文件中的字符串，在窗口中可以选择相应的字符串，最后自动生成类似于上面的PropertyResourceTranslator.java和properties文件，完成国际化。\n\n其原理与以上所讲的相同，故不再详细说明。\n\n## Eclipse RCP国际化\n\n> 最近在使用Eclipse RCP这项技术开发程序，其中也有国际化相关的东西，总结下来。\n\n[Eclipse RCP and Plugin Internationalization - Tutorial](http://www.vogella.com/tutorials/EclipseInternationalization/article.html)\n\n上面这篇文章详细的说明了Eclipse RCP工程中的国际化问题，可以作为一个备忘录。下面介绍一下eclipse rcp中比较常用到的国际化方式：\n\n### plugin.xml文件国际化\n\nplugin.xml文件中保存了扩展点等相关的信息，当扩展点与界面UI相关时，就需要用到国际化\n\n1. 在工程的根目录下面建立一个plugin.properties资源文件，此文件类似于我们上面提到的errors.properties。当然，也可以建立plugin_zh.properties等文件，这些文件名中的plugin是可以自由定义的。\n\n2. 在 MANIFEST.MF文件中增加代码行：Bundle-Localization: plugin\n\n   注意，这个plugin与上面的properties文件名保持一致。\n\n3. plugin.xml配置文件对资源文件进行引用时, 在引用的key前面加一个%，比如：\n\n```\n<view\n    id=\"org.jkiss.dbeaver.core.databaseNavigator\"\n    category=\"org.jkiss.dbeaver.core.category\"\n    class=\"org.jkiss.dbeaver.ui.navigator.database.DatabaseNavigatorView\"\n    allowMultiple=\"false\"\n    icon=\"icons/databases.png\"\n    name=\"%view.database.navigator.title\"/>\n<view\n```\n\n### 类文件国际化\n\n与前面所介绍的java类文件国际化相同，也可以通过选择类文件点击右键->Source->Externalize Strings...\n\nEclipse IDE会自动帮你完成国际化的一些工作，同样也生成了相关的类和properties文件，但不同的是，生成的类文件内容类似于：\n\n```\npackage test;\n\nimport org.eclipse.osgi.util.NLS;\n\npublic class Messages extends NLS {\n        private static final String BUNDLE_NAME\n                = \"test.messages\"; //$NON-NLS-1$\n        public static String View_0;\n        public static String View_1;\n        static {\n                // initialize resource bundle\n                NLS.initializeMessages(BUNDLE_NAME, Messages.class);\n        }\n\n        private Messages() {\n        }\n}\n```\n\n当然，我们也可以手动建立这些文件进行国际化操作~~不再详细说明，可以通过观察IDE的行为进行我们手动的国际化操作~","slug":"java国际化","published":1,"updated":"2017-02-19T13:15:17.719Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlre001ovegcqrg9t6fj","content":"<blockquote>\n<p>使用java编写一个带GUI程序或者其他需要给用户传递文字信息的程序的时候，就很有可能需要用到国际化的知识，来总结一下。</p>\n</blockquote>\n<p>所谓的国际化，就是使编写的程序可以适应不同的语言环境，比如，在中文环境下，可以与用户使用中文交互，在英文环境下则切换为英文。而这个切换过程不需要修改代码或者仅仅修改少量的代码。java给我们提供了这样的实现。</p>\n<h2 id=\"java文件国际化\"><a href=\"#java文件国际化\" class=\"headerlink\" title=\"java文件国际化\"></a>java文件国际化</h2><p>我们通过将与界面显示有关系的资源提取出来到资源文件中，然后读取不同的资源文件来达到国际化的目的。在java中，这些是通过ResourceBundle这个类来实现的。</p>\n<p>ResourceBundle分为两种，一种是ListResourceBundle,另一种是PropertyResourceBundle。下面介绍这两种ResourceBundle的使用方法：</p>\n<p>首先列出demo工程的代码结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">TestResourceBundle</div><div class=\"line\">|</div><div class=\"line\">|--src</div><div class=\"line\">    |</div><div class=\"line\">    |--kyu</div><div class=\"line\">        |</div><div class=\"line\">        |--bundle</div><div class=\"line\">        |    |</div><div class=\"line\">        |    |--ListResourceTranslator.java</div><div class=\"line\">        |    |</div><div class=\"line\">        |    |--PropertyResourceTranslator.java</div><div class=\"line\">        |    |</div><div class=\"line\">        |    |--ResourceTranslator.java</div><div class=\"line\">        |</div><div class=\"line\">        |--test</div><div class=\"line\">        |   |</div><div class=\"line\">        |   |--App.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_en_Us.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_zh_CN.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_en_Us.properties</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_zh_CN.properties</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors.properties</div></pre></td></tr></table></figure>\n<h3 id=\"PropertyResourceBundle\"><a href=\"#PropertyResourceBundle\" class=\"headerlink\" title=\"PropertyResourceBundle\"></a>PropertyResourceBundle</h3><ol>\n<li>首先需要建立若干语言的properties文件： 自定义名<em>语言代码</em>国别代码.properties</li>\n</ol>\n<p>比如：errors_en_US.properties, errors_zh_CN.properties</p>\n<p>其中的语言代码和国别代码，分别是你要国际化的语言。需要几种语言，就添加几个properties文件。</p>\n<p><a href=\"https://worldwide.espacenet.com/help?locale=cn_EP&amp;method=handleHelpTopic&amp;topic=countrycodes\" target=\"_blank\" rel=\"external\">国别代码</a></p>\n<p><a href=\"http://www.lingoes.cn/zh/translator/langcode.htm\" target=\"_blank\" rel=\"external\">语言代码</a></p>\n<p>通过打印java所支持的语言和国家查看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void printLocal() &#123;</div><div class=\"line\">\t\tLocale[] localeList = Locale.getAvailableLocales();</div><div class=\"line\">\t\tfor (int i = 0; i &lt; localeList.length; i++) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(localeList[i].getDisplayCountry() + &quot;: &quot; + localeList[i].getCountry());</div><div class=\"line\">\t\t\tSystem.out.println(localeList[i].getDisplayLanguage() + &quot;: &quot; + localeList[i].getLanguage());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>建立默认语言的properties文件：自定义名.properties</li>\n</ol>\n<p>比如：errors.properties</p>\n<p>当所需语言的properties文件不存在的时候就会默认读取这个文件中的内容</p>\n<p>注意，资源文件都必须是ISO-8859-1编码，对于中文等非西方语系，可通过JDK自带的工具native2ascii进行处理，在Eclipse中也可以安装插件SimplePropertiesEditor来处理这类文件。</p>\n<ol>\n<li>使用</li>\n</ol>\n<p>ResourceTranslator.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.bundle;</div><div class=\"line\"></div><div class=\"line\">import java.util.Locale;</div><div class=\"line\">import java.util.ResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public abstract class ResourceTranslator &#123;</div><div class=\"line\">\tprotected ResourceBundle bundle;</div><div class=\"line\">\tprotected Locale lc;</div><div class=\"line\">\tprotected static final String PROP_FILE = &quot;kyu.errors&quot;;</div><div class=\"line\"></div><div class=\"line\">    public String translate(String id) &#123;</div><div class=\"line\">        return bundle.getString(id);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>PropertyResourceTranslator.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.bundle;</div><div class=\"line\"></div><div class=\"line\">import java.util.Locale;</div><div class=\"line\">import java.util.PropertyResourceBundle;</div><div class=\"line\">import java.util.ResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public class PropertyResourceTranslator extends ResourceTranslator&#123;</div><div class=\"line\">    public PropertyResourceTranslator() &#123;</div><div class=\"line\">        lc = Locale.getDefault();</div><div class=\"line\">        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    public PropertyResourceTranslator(String language, String country) &#123;</div><div class=\"line\">    \tlc = new Locale(language, country);</div><div class=\"line\">        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>App.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.test;</div><div class=\"line\"></div><div class=\"line\">import kyu.bundle.ListResourceTranslator;</div><div class=\"line\">import kyu.bundle.PropertyResourceTranslator;</div><div class=\"line\"></div><div class=\"line\">public class App &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\ttestPropertyResource();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tprivate static void testPropertyResource() &#123;</div><div class=\"line\">\t\tPropertyResourceTranslator translatorDefault = new PropertyResourceTranslator();</div><div class=\"line\">\t\tPropertyResourceTranslator translatorZH = new PropertyResourceTranslator(&quot;zh&quot;, &quot;CN&quot;);</div><div class=\"line\">\t\tPropertyResourceTranslator translatorEN = new PropertyResourceTranslator(&quot;en&quot;, &quot;US&quot;);</div><div class=\"line\">\t\tString def = translatorDefault.translate(&quot;ERROR-001&quot;);</div><div class=\"line\">\t\tString zh = translatorZH.translate(&quot;ERROR-001&quot;);</div><div class=\"line\">\t\tString en = translatorEN.translate(&quot;ERROR-001&quot;);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(&quot;test PropertyResourceBundle&gt;&gt;&gt;&gt;&gt;&gt;&quot;);</div><div class=\"line\">\t\tSystem.out.println(&quot;default: &quot; + def);</div><div class=\"line\">\t\tSystem.out.println(&quot;zh: &quot; + zh);</div><div class=\"line\">\t\tSystem.out.println(&quot;en: &quot; + en);</div><div class=\"line\">\t&#125;\t</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>.properties文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Errors_en_Us.properties:</div><div class=\"line\">ERROR-001=error password</div><div class=\"line\"></div><div class=\"line\">Errors.properties</div><div class=\"line\">ERROR-001=error password</div><div class=\"line\"></div><div class=\"line\">Errors_zh_CN.properties</div><div class=\"line\">ERROR-001=密码错误</div></pre></td></tr></table></figure>\n<p>执行App.java的测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">test PropertyResourceBundle&gt;&gt;&gt;&gt;&gt;&gt;</div><div class=\"line\">default: 密码错误</div><div class=\"line\">zh: 密码错误</div><div class=\"line\">en: error password</div></pre></td></tr></table></figure>\n<p>可以看到，通过指定Local构造函数的语言和国别代码，就能自动找到对应的.properties，并匹配其中的内容。</p>\n<p>当使用Locale.getDefault()时，自动检测当前的系统环境，从而选择对应的语言。</p>\n<p>还有一点要注意的是： </p>\n<p>PropertyResourceBundle.getBundle(PROP_FILE, lc); </p>\n<p>其中PROP_FILE，为properties文件的路径，此路径为properties文件的完整路径，即 所在完整包名.自定义名称</p>\n<h3 id=\"ListResourceBundle\"><a href=\"#ListResourceBundle\" class=\"headerlink\" title=\"ListResourceBundle\"></a>ListResourceBundle</h3><p>ListResourceBundle的使用与PropertyResourceBundle的使用大同小异，不过是将properties文件换成了.java文件</p>\n<p>ListResourceTranslator.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.bundle;</div><div class=\"line\"></div><div class=\"line\">import java.util.ListResourceBundle;</div><div class=\"line\">import java.util.Locale;</div><div class=\"line\"></div><div class=\"line\">public class ListResourceTranslator extends ResourceTranslator&#123;</div><div class=\"line\">\tpublic ListResourceTranslator() &#123;</div><div class=\"line\">        lc = Locale.getDefault();</div><div class=\"line\">        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    public ListResourceTranslator(String language, String country) &#123;</div><div class=\"line\">    \tlc = new Locale(language, country);</div><div class=\"line\">        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ERRORS_en_US.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu;</div><div class=\"line\"></div><div class=\"line\">import java.util.ListResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public class ERRORS_en_US extends ListResourceBundle&#123;</div><div class=\"line\">\tstatic final Object[][] contents = new String[][] &#123; </div><div class=\"line\">\t\t&#123; &quot;ERROR-001&quot;, &quot;error password&quot; &#125; </div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\tpublic Object[][] getContents() &#123;</div><div class=\"line\">\t\treturn contents;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ERRORS_zh_CN.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu;</div><div class=\"line\"></div><div class=\"line\">import java.util.ListResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public class ERRORS_zh_CN extends ListResourceBundle &#123;</div><div class=\"line\">\tstatic final Object[][] contents = new String[][] &#123; </div><div class=\"line\">\t\t&#123; &quot;ERROR-001&quot;, &quot;密码错误&quot; &#125; </div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\tpublic Object[][] getContents() &#123;</div><div class=\"line\">\t\treturn contents;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>继承了ListResourceBundle的类就相当于前面的properties文件，需要提供一个getContents()方法，返回对应的键值对。</p>\n<p>同样的，要注意ListResourceBundle子类的命名规则，与properties文件相同，路径也与properties文件相同。</p>\n<p>通过App.java的测试(将对应的bundle替换)，可以得到相同的测试结果。</p>\n<h3 id=\"使用Eclipse对java文件进行国际化\"><a href=\"#使用Eclipse对java文件进行国际化\" class=\"headerlink\" title=\"使用Eclipse对java文件进行国际化\"></a>使用Eclipse对java文件进行国际化</h3><p>在需要国际化的类文件上点击右键-&gt;Source-&gt;Externalize Strings…</p>\n<p>出现窗口，Eclipse会自动检测类文件中的字符串，在窗口中可以选择相应的字符串，最后自动生成类似于上面的PropertyResourceTranslator.java和properties文件，完成国际化。</p>\n<p>其原理与以上所讲的相同，故不再详细说明。</p>\n<h2 id=\"Eclipse-RCP国际化\"><a href=\"#Eclipse-RCP国际化\" class=\"headerlink\" title=\"Eclipse RCP国际化\"></a>Eclipse RCP国际化</h2><blockquote>\n<p>最近在使用Eclipse RCP这项技术开发程序，其中也有国际化相关的东西，总结下来。</p>\n</blockquote>\n<p><a href=\"http://www.vogella.com/tutorials/EclipseInternationalization/article.html\" target=\"_blank\" rel=\"external\">Eclipse RCP and Plugin Internationalization - Tutorial</a></p>\n<p>上面这篇文章详细的说明了Eclipse RCP工程中的国际化问题，可以作为一个备忘录。下面介绍一下eclipse rcp中比较常用到的国际化方式：</p>\n<h3 id=\"plugin-xml文件国际化\"><a href=\"#plugin-xml文件国际化\" class=\"headerlink\" title=\"plugin.xml文件国际化\"></a>plugin.xml文件国际化</h3><p>plugin.xml文件中保存了扩展点等相关的信息，当扩展点与界面UI相关时，就需要用到国际化</p>\n<ol>\n<li><p>在工程的根目录下面建立一个plugin.properties资源文件，此文件类似于我们上面提到的errors.properties。当然，也可以建立plugin_zh.properties等文件，这些文件名中的plugin是可以自由定义的。</p>\n</li>\n<li><p>在 MANIFEST.MF文件中增加代码行：Bundle-Localization: plugin</p>\n<p>注意，这个plugin与上面的properties文件名保持一致。</p>\n</li>\n<li><p>plugin.xml配置文件对资源文件进行引用时, 在引用的key前面加一个%，比如：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view</div><div class=\"line\">    id=&quot;org.jkiss.dbeaver.core.databaseNavigator&quot;</div><div class=\"line\">    category=&quot;org.jkiss.dbeaver.core.category&quot;</div><div class=\"line\">    class=&quot;org.jkiss.dbeaver.ui.navigator.database.DatabaseNavigatorView&quot;</div><div class=\"line\">    allowMultiple=&quot;false&quot;</div><div class=\"line\">    icon=&quot;icons/databases.png&quot;</div><div class=\"line\">    name=&quot;%view.database.navigator.title&quot;/&gt;</div><div class=\"line\">&lt;view</div></pre></td></tr></table></figure>\n<h3 id=\"类文件国际化\"><a href=\"#类文件国际化\" class=\"headerlink\" title=\"类文件国际化\"></a>类文件国际化</h3><p>与前面所介绍的java类文件国际化相同，也可以通过选择类文件点击右键-&gt;Source-&gt;Externalize Strings…</p>\n<p>Eclipse IDE会自动帮你完成国际化的一些工作，同样也生成了相关的类和properties文件，但不同的是，生成的类文件内容类似于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">package test;</div><div class=\"line\"></div><div class=\"line\">import org.eclipse.osgi.util.NLS;</div><div class=\"line\"></div><div class=\"line\">public class Messages extends NLS &#123;</div><div class=\"line\">        private static final String BUNDLE_NAME</div><div class=\"line\">                = &quot;test.messages&quot;; //$NON-NLS-1$</div><div class=\"line\">        public static String View_0;</div><div class=\"line\">        public static String View_1;</div><div class=\"line\">        static &#123;</div><div class=\"line\">                // initialize resource bundle</div><div class=\"line\">                NLS.initializeMessages(BUNDLE_NAME, Messages.class);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        private Messages() &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当然，我们也可以手动建立这些文件进行国际化操作~~不再详细说明，可以通过观察IDE的行为进行我们手动的国际化操作~</p>\n","excerpt":"","more":"<blockquote>\n<p>使用java编写一个带GUI程序或者其他需要给用户传递文字信息的程序的时候，就很有可能需要用到国际化的知识，来总结一下。</p>\n</blockquote>\n<p>所谓的国际化，就是使编写的程序可以适应不同的语言环境，比如，在中文环境下，可以与用户使用中文交互，在英文环境下则切换为英文。而这个切换过程不需要修改代码或者仅仅修改少量的代码。java给我们提供了这样的实现。</p>\n<h2 id=\"java文件国际化\"><a href=\"#java文件国际化\" class=\"headerlink\" title=\"java文件国际化\"></a>java文件国际化</h2><p>我们通过将与界面显示有关系的资源提取出来到资源文件中，然后读取不同的资源文件来达到国际化的目的。在java中，这些是通过ResourceBundle这个类来实现的。</p>\n<p>ResourceBundle分为两种，一种是ListResourceBundle,另一种是PropertyResourceBundle。下面介绍这两种ResourceBundle的使用方法：</p>\n<p>首先列出demo工程的代码结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">TestResourceBundle</div><div class=\"line\">|</div><div class=\"line\">|--src</div><div class=\"line\">    |</div><div class=\"line\">    |--kyu</div><div class=\"line\">        |</div><div class=\"line\">        |--bundle</div><div class=\"line\">        |    |</div><div class=\"line\">        |    |--ListResourceTranslator.java</div><div class=\"line\">        |    |</div><div class=\"line\">        |    |--PropertyResourceTranslator.java</div><div class=\"line\">        |    |</div><div class=\"line\">        |    |--ResourceTranslator.java</div><div class=\"line\">        |</div><div class=\"line\">        |--test</div><div class=\"line\">        |   |</div><div class=\"line\">        |   |--App.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_en_Us.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_zh_CN.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_en_Us.properties</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_zh_CN.properties</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors.properties</div></pre></td></tr></table></figure>\n<h3 id=\"PropertyResourceBundle\"><a href=\"#PropertyResourceBundle\" class=\"headerlink\" title=\"PropertyResourceBundle\"></a>PropertyResourceBundle</h3><ol>\n<li>首先需要建立若干语言的properties文件： 自定义名<em>语言代码</em>国别代码.properties</li>\n</ol>\n<p>比如：errors_en_US.properties, errors_zh_CN.properties</p>\n<p>其中的语言代码和国别代码，分别是你要国际化的语言。需要几种语言，就添加几个properties文件。</p>\n<p><a href=\"https://worldwide.espacenet.com/help?locale=cn_EP&amp;method=handleHelpTopic&amp;topic=countrycodes\">国别代码</a></p>\n<p><a href=\"http://www.lingoes.cn/zh/translator/langcode.htm\">语言代码</a></p>\n<p>通过打印java所支持的语言和国家查看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void printLocal() &#123;</div><div class=\"line\">\t\tLocale[] localeList = Locale.getAvailableLocales();</div><div class=\"line\">\t\tfor (int i = 0; i &lt; localeList.length; i++) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(localeList[i].getDisplayCountry() + &quot;: &quot; + localeList[i].getCountry());</div><div class=\"line\">\t\t\tSystem.out.println(localeList[i].getDisplayLanguage() + &quot;: &quot; + localeList[i].getLanguage());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>建立默认语言的properties文件：自定义名.properties</li>\n</ol>\n<p>比如：errors.properties</p>\n<p>当所需语言的properties文件不存在的时候就会默认读取这个文件中的内容</p>\n<p>注意，资源文件都必须是ISO-8859-1编码，对于中文等非西方语系，可通过JDK自带的工具native2ascii进行处理，在Eclipse中也可以安装插件SimplePropertiesEditor来处理这类文件。</p>\n<ol>\n<li>使用</li>\n</ol>\n<p>ResourceTranslator.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.bundle;</div><div class=\"line\"></div><div class=\"line\">import java.util.Locale;</div><div class=\"line\">import java.util.ResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public abstract class ResourceTranslator &#123;</div><div class=\"line\">\tprotected ResourceBundle bundle;</div><div class=\"line\">\tprotected Locale lc;</div><div class=\"line\">\tprotected static final String PROP_FILE = &quot;kyu.errors&quot;;</div><div class=\"line\"></div><div class=\"line\">    public String translate(String id) &#123;</div><div class=\"line\">        return bundle.getString(id);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>PropertyResourceTranslator.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.bundle;</div><div class=\"line\"></div><div class=\"line\">import java.util.Locale;</div><div class=\"line\">import java.util.PropertyResourceBundle;</div><div class=\"line\">import java.util.ResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public class PropertyResourceTranslator extends ResourceTranslator&#123;</div><div class=\"line\">    public PropertyResourceTranslator() &#123;</div><div class=\"line\">        lc = Locale.getDefault();</div><div class=\"line\">        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    public PropertyResourceTranslator(String language, String country) &#123;</div><div class=\"line\">    \tlc = new Locale(language, country);</div><div class=\"line\">        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>App.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.test;</div><div class=\"line\"></div><div class=\"line\">import kyu.bundle.ListResourceTranslator;</div><div class=\"line\">import kyu.bundle.PropertyResourceTranslator;</div><div class=\"line\"></div><div class=\"line\">public class App &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\ttestPropertyResource();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tprivate static void testPropertyResource() &#123;</div><div class=\"line\">\t\tPropertyResourceTranslator translatorDefault = new PropertyResourceTranslator();</div><div class=\"line\">\t\tPropertyResourceTranslator translatorZH = new PropertyResourceTranslator(&quot;zh&quot;, &quot;CN&quot;);</div><div class=\"line\">\t\tPropertyResourceTranslator translatorEN = new PropertyResourceTranslator(&quot;en&quot;, &quot;US&quot;);</div><div class=\"line\">\t\tString def = translatorDefault.translate(&quot;ERROR-001&quot;);</div><div class=\"line\">\t\tString zh = translatorZH.translate(&quot;ERROR-001&quot;);</div><div class=\"line\">\t\tString en = translatorEN.translate(&quot;ERROR-001&quot;);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(&quot;test PropertyResourceBundle&gt;&gt;&gt;&gt;&gt;&gt;&quot;);</div><div class=\"line\">\t\tSystem.out.println(&quot;default: &quot; + def);</div><div class=\"line\">\t\tSystem.out.println(&quot;zh: &quot; + zh);</div><div class=\"line\">\t\tSystem.out.println(&quot;en: &quot; + en);</div><div class=\"line\">\t&#125;\t</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>.properties文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Errors_en_Us.properties:</div><div class=\"line\">ERROR-001=error password</div><div class=\"line\"></div><div class=\"line\">Errors.properties</div><div class=\"line\">ERROR-001=error password</div><div class=\"line\"></div><div class=\"line\">Errors_zh_CN.properties</div><div class=\"line\">ERROR-001=密码错误</div></pre></td></tr></table></figure>\n<p>执行App.java的测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">test PropertyResourceBundle&gt;&gt;&gt;&gt;&gt;&gt;</div><div class=\"line\">default: 密码错误</div><div class=\"line\">zh: 密码错误</div><div class=\"line\">en: error password</div></pre></td></tr></table></figure>\n<p>可以看到，通过指定Local构造函数的语言和国别代码，就能自动找到对应的.properties，并匹配其中的内容。</p>\n<p>当使用Locale.getDefault()时，自动检测当前的系统环境，从而选择对应的语言。</p>\n<p>还有一点要注意的是： </p>\n<p>PropertyResourceBundle.getBundle(PROP_FILE, lc); </p>\n<p>其中PROP_FILE，为properties文件的路径，此路径为properties文件的完整路径，即 所在完整包名.自定义名称</p>\n<h3 id=\"ListResourceBundle\"><a href=\"#ListResourceBundle\" class=\"headerlink\" title=\"ListResourceBundle\"></a>ListResourceBundle</h3><p>ListResourceBundle的使用与PropertyResourceBundle的使用大同小异，不过是将properties文件换成了.java文件</p>\n<p>ListResourceTranslator.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.bundle;</div><div class=\"line\"></div><div class=\"line\">import java.util.ListResourceBundle;</div><div class=\"line\">import java.util.Locale;</div><div class=\"line\"></div><div class=\"line\">public class ListResourceTranslator extends ResourceTranslator&#123;</div><div class=\"line\">\tpublic ListResourceTranslator() &#123;</div><div class=\"line\">        lc = Locale.getDefault();</div><div class=\"line\">        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    public ListResourceTranslator(String language, String country) &#123;</div><div class=\"line\">    \tlc = new Locale(language, country);</div><div class=\"line\">        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ERRORS_en_US.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu;</div><div class=\"line\"></div><div class=\"line\">import java.util.ListResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public class ERRORS_en_US extends ListResourceBundle&#123;</div><div class=\"line\">\tstatic final Object[][] contents = new String[][] &#123; </div><div class=\"line\">\t\t&#123; &quot;ERROR-001&quot;, &quot;error password&quot; &#125; </div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\tpublic Object[][] getContents() &#123;</div><div class=\"line\">\t\treturn contents;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ERRORS_zh_CN.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu;</div><div class=\"line\"></div><div class=\"line\">import java.util.ListResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public class ERRORS_zh_CN extends ListResourceBundle &#123;</div><div class=\"line\">\tstatic final Object[][] contents = new String[][] &#123; </div><div class=\"line\">\t\t&#123; &quot;ERROR-001&quot;, &quot;密码错误&quot; &#125; </div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\tpublic Object[][] getContents() &#123;</div><div class=\"line\">\t\treturn contents;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>继承了ListResourceBundle的类就相当于前面的properties文件，需要提供一个getContents()方法，返回对应的键值对。</p>\n<p>同样的，要注意ListResourceBundle子类的命名规则，与properties文件相同，路径也与properties文件相同。</p>\n<p>通过App.java的测试(将对应的bundle替换)，可以得到相同的测试结果。</p>\n<h3 id=\"使用Eclipse对java文件进行国际化\"><a href=\"#使用Eclipse对java文件进行国际化\" class=\"headerlink\" title=\"使用Eclipse对java文件进行国际化\"></a>使用Eclipse对java文件进行国际化</h3><p>在需要国际化的类文件上点击右键-&gt;Source-&gt;Externalize Strings…</p>\n<p>出现窗口，Eclipse会自动检测类文件中的字符串，在窗口中可以选择相应的字符串，最后自动生成类似于上面的PropertyResourceTranslator.java和properties文件，完成国际化。</p>\n<p>其原理与以上所讲的相同，故不再详细说明。</p>\n<h2 id=\"Eclipse-RCP国际化\"><a href=\"#Eclipse-RCP国际化\" class=\"headerlink\" title=\"Eclipse RCP国际化\"></a>Eclipse RCP国际化</h2><blockquote>\n<p>最近在使用Eclipse RCP这项技术开发程序，其中也有国际化相关的东西，总结下来。</p>\n</blockquote>\n<p><a href=\"http://www.vogella.com/tutorials/EclipseInternationalization/article.html\">Eclipse RCP and Plugin Internationalization - Tutorial</a></p>\n<p>上面这篇文章详细的说明了Eclipse RCP工程中的国际化问题，可以作为一个备忘录。下面介绍一下eclipse rcp中比较常用到的国际化方式：</p>\n<h3 id=\"plugin-xml文件国际化\"><a href=\"#plugin-xml文件国际化\" class=\"headerlink\" title=\"plugin.xml文件国际化\"></a>plugin.xml文件国际化</h3><p>plugin.xml文件中保存了扩展点等相关的信息，当扩展点与界面UI相关时，就需要用到国际化</p>\n<ol>\n<li><p>在工程的根目录下面建立一个plugin.properties资源文件，此文件类似于我们上面提到的errors.properties。当然，也可以建立plugin_zh.properties等文件，这些文件名中的plugin是可以自由定义的。</p>\n</li>\n<li><p>在 MANIFEST.MF文件中增加代码行：Bundle-Localization: plugin</p>\n<p>注意，这个plugin与上面的properties文件名保持一致。</p>\n</li>\n<li><p>plugin.xml配置文件对资源文件进行引用时, 在引用的key前面加一个%，比如：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view</div><div class=\"line\">    id=&quot;org.jkiss.dbeaver.core.databaseNavigator&quot;</div><div class=\"line\">    category=&quot;org.jkiss.dbeaver.core.category&quot;</div><div class=\"line\">    class=&quot;org.jkiss.dbeaver.ui.navigator.database.DatabaseNavigatorView&quot;</div><div class=\"line\">    allowMultiple=&quot;false&quot;</div><div class=\"line\">    icon=&quot;icons/databases.png&quot;</div><div class=\"line\">    name=&quot;%view.database.navigator.title&quot;/&gt;</div><div class=\"line\">&lt;view</div></pre></td></tr></table></figure>\n<h3 id=\"类文件国际化\"><a href=\"#类文件国际化\" class=\"headerlink\" title=\"类文件国际化\"></a>类文件国际化</h3><p>与前面所介绍的java类文件国际化相同，也可以通过选择类文件点击右键-&gt;Source-&gt;Externalize Strings…</p>\n<p>Eclipse IDE会自动帮你完成国际化的一些工作，同样也生成了相关的类和properties文件，但不同的是，生成的类文件内容类似于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">package test;</div><div class=\"line\"></div><div class=\"line\">import org.eclipse.osgi.util.NLS;</div><div class=\"line\"></div><div class=\"line\">public class Messages extends NLS &#123;</div><div class=\"line\">        private static final String BUNDLE_NAME</div><div class=\"line\">                = &quot;test.messages&quot;; //$NON-NLS-1$</div><div class=\"line\">        public static String View_0;</div><div class=\"line\">        public static String View_1;</div><div class=\"line\">        static &#123;</div><div class=\"line\">                // initialize resource bundle</div><div class=\"line\">                NLS.initializeMessages(BUNDLE_NAME, Messages.class);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        private Messages() &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当然，我们也可以手动建立这些文件进行国际化操作~~不再详细说明，可以通过观察IDE的行为进行我们手动的国际化操作~</p>\n"},{"layout":"post","title":"java序列化与反序列化","date":"2017-03-22T12:14:46.000Z","_content":"\n## 什么是序列化\n\n所谓的序列化，即把java对象以二进制形式保存到内存、文件或者进行网络传输。从二进制的形式恢复成为java对象，即反序列化。\n\n通过序列化可以将对象持久化，或者从一个地方传输到另一个地方。这方面的应用有RMI，远程方法调用。\n\njava中实现序列化有两种方式，实现Serializable接口或者Externalizable接口。这篇总结只讨论Serializable的情况。\n\n```\npublic class SerializeTest implements Serializable{\n\t    private static final long serialVersionUID = 1L;\n\t\tpublic String str;\n\t\tpublic SerializeTest(String str) {\n\t\t\t   this.str = str;\n\t\t}\n\t\t\n\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t\t   SerializeTest test = new SerializeTest(\"hello\");\n\t\t\t   ByteArrayOutputStream oStream = new ByteArrayOutputStream();\n\t\t\t   ObjectOutputStream objectOutputStream = new ObjectOutputStream(oStream);\n\t\t\t   objectOutputStream.writeObject(test);//序列化\n\t\t\t   \n\t\t\t   ObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(oStream.toByteArray()));\n\t\t\t   SerializeTest obj = (SerializeTest) inputStream.readObject();//反序列化\n\t\t\t   System.out.println(obj.str);\n\t\t}\n}\n```\n上面的代码演示了类SerializeTest实现序列化和反序列化的过程。\n\n所有的序列化和反序列化过程都是java默认实现的，你只需要实现接口Serializable，就能得到一个实现了序列化的类。\n通过ObjectOutputStream和ObjectInputStream分别将序列化对象输出或者写入到某个流当中。流的目的地可以是内存字节数组(上例)、文件、或者网络。\n\n下面研究一下序列化过程中的几个问题：\n\n## 静态变量如何序列化\n\n```\npublic class SeriaUtil {\n\t    ByteArrayInputStream bInputStream;\n\t    ByteArrayOutputStream byOutputStream;\n\t    ObjectOutputStream outputStream ;\n\t    ObjectInputStream inputStream;\n\t    \n        public void seria(Object test) throws IOException {\n        \tif (byOutputStream == null) {\n        \t\tbyOutputStream = new ByteArrayOutputStream();\n\t\t\t}\n        \tif (outputStream == null) {\n        \t\toutputStream = new ObjectOutputStream(byOutputStream);\n\t\t\t}\n\t\t    outputStream.writeObject(test);\n//\t\t   System.out.println(byOutputStream.toByteArray().length); \n        }\n        \n        public Object  reSeria() throws IOException, ClassNotFoundException {\n\t        \tif (bInputStream == null) {\n\t\t\t\t\t  bInputStream = new ByteArrayInputStream(byOutputStream.toByteArray());\n\t\t\t\t}\n\t        \tif (inputStream == null) {\n\t        \t\tinputStream = new ObjectInputStream(bInputStream);\n\t\t\t\t}\n\t\t\t    Object obj =  inputStream.readObject();\n\t\t\t    return obj;\n        }\n}\n\npublic class StaticTest implements Serializable{\n\tprivate static final long serialVersionUID = 1L;\n\tpublic static int A = 0;\n\tpublic static String B = \"hello\";\n\t\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t    //先序列化类，此时 A=0 B = hello\n\t\t    SeriaUtil seriaUtil = new SeriaUtil();\n\t\t    StaticTest test = new StaticTest();\n\t\t    seriaUtil.seria(test);\n\t\t    //修改 静态变量的值\n\t\t    StaticTest.A = 1;\n\t\t    StaticTest.B = \"world\";\n\t\t    \n\t\t    StaticTest obj = (StaticTest) seriaUtil.reSeria();\n\t\t    //输出 A = 1 B = world\n\t\t    System.out.println(obj.A);\n\t\t    System.out.println(obj.B);\n\t}\n}\n```\n上面的代码说明了，静态变量不会被序列化。\n\n序列化StaticTest实例test时，静态变量 A=0 B=\"hello\"，序列化之后，修改StaticTest类的静态变量值，A=1 B=\"world\"，\n此时反序列化得到之前序列化的实例对象赋给obj，发现obj的静态变量变为A=1 B=\"world\"，说明静态变量并未序列化成功。\n\n事实上，在序列化对象时，会忽略对象中的静态变量。很好理解，静态变量是属于类的，而不是某个对象的状态。我们序列化面向的是对象，是想要将对象的状态保存下来，所以\n静态变量不会被序列化。反序列化得到的对象中的静态变量的值是当前jvm中静态变量的值。静态变量对于同一个jvm中同一个类加载器加载的类来说，是一样的。对于同一个静态变量，不会存在同一个类的不同实例拥有不同的值。\n\n## 同一对象序列化两次，反序列化后得到的两个对象是否相等\n\n这个问题提到的相等，是指是否为同一对象，即==关系\n\n在某些情况下，确保这种关系是很重要的。比如王经理和李经理拥有同一个办公室，即存在引用关系：\n\n```\npublic class Manager{\n    Room room;\n    public Manager(Room r){\n        room = r;\n    }\n}\n\npublic class Room{}\n\npublic class APP{\n    public void main(String args[]){\n        Room room = new Room();\n        Manager wang = new Manager(room);\n        Manager li = new Manager(room);\n    }\n}\n```\n反序列化之后，wang，li，room的这种引用关系不应该发生变化。通过代码验证一下：\n\n```\npublic class ReferenceTest implements Serializable{\n\t\tpublic String a;\n\t\tpublic ReferenceTest() {\n\t\t\ta = \"hah\";\n\t\t}\n\t\tpublic static void main(String[] args) throws Exception {\n\t\t\t  System.out.println(\"构造对象********************\");\n\t\t\t  ReferenceTest test = new ReferenceTest();\n\t\t\t  System.out.println(\"序列化**********************\");\n\t\t\t  SeriaUtil util = new SeriaUtil();\n\t\t\t  util.seria(test);\n\t\t\t  util.seria(test);//第二次序列化该对象\n\t\t\t  System.out.println(\"反序列化**********************\");\n\t\t\t  ReferenceTest obj = (ReferenceTest) util.reSeria();\n\t\t\t  ReferenceTest obj1 = (ReferenceTest) util.reSeria();\n\t\t\t  System.out.println(obj == obj1);//true\n\t\t\t  System.out.println(obj == test);//false\n\t\t}\n}\n```\n上面的例子证明（System.out.println(obj == obj1);//true），同一对象序列化多次之后，反序列化得到的多个对象相等，即内存地址一致。\n\n使用同一个ObjectOutputStream对象序列化某个实例时，如果该实例还没有被序列化过，则序列化，若之前已经序列化过，则不再进行序列化，只是做一个标记而已。\n所以在反序列化时，可以保持原有的引用关系。\n\nSystem.out.println(obj == test);//false   也可以理解，反序列化之后重建了该对象，内存地址必然是新分配的，故obj != test\n\n## 父类没有实现Serializable，父类中的变量如何序列化\n\n```\npublic class SuperTest{\n       public String superB;\n       public SuperTest() {\n    \t   superB = \"hehe\";\n    \t   System.out.println(\"super 无参构造函数\");\n       }\n       \n       public SuperTest(String b){\n    \t   System.out.println(\"super 有参构造函数\");\n    \t   superB = b;\n       }\n\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t\t  System.out.println(\"构造对象*******************\");\n\t\t\t  SonTest sonTest = new SonTest(\"son\", \"super\");\n\t\t\t  System.out.println(\"序列化*********************\");\n\t\t\t  SeriaUtil  seriaUtil = new SeriaUtil();\n\t\t\t  seriaUtil.seria(sonTest);\n\t\t\t  System.out.println(\"反序列化******************\");\n\t\t\t  SonTest obj = (SonTest) seriaUtil.reSeria();\n\t\t\t  System.out.println(obj.sonA);\n\t\t\t  System.out.println(obj.superB);\n\t\t}\n}\n\nclass SonTest extends SuperTest  implements Serializable{\n\t private static final long serialVersionUID = 1L;\n\t public String sonA;\n\t public SonTest() {\n\t\t System.out.println(\"son 无参构造函数\");\n\t }\n\t \n\t public SonTest(String a, String b) {\n\t\t super(b);\n\t\t System.out.println(\"son 有参构造函数\");\n\t\t sonA = a;\n\t }\n}\n```\n输出：\n\n构造对象*******************\nsuper 有参构造函数\nson 有参构造函数\n序列化*********************\n反序列化******************\nsuper 无参构造函数\nson\nhehe\n\n通过上面的代码可以看出，父类如果没有实现serializable，反序列化时会调用父类的无参构造函数初始化父类当中的变量。\n\n所以，我们可以通过显示声明父类的无参构造函数，并在其中初始化变量值来控制反序列化后父类变量的值。\n\n## transient使用\n\n实现了serializable接口的类在序列化时默认会将所有的非静态变量进行序列化。我们可以控制某些字段不被默认的序列化机制序列化。\n\n比如，有些字段是跟当前系统环境相关的或者涉及到隐私的，需要保密的。这些字段是不可以被序列化到文件中或者通过网络传输的。我们可以通过为这些字段声明\ntransient关键字，保证其不被序列化。\n\n被关键字transient声明的变量不会被序列化，反序列化时该变量会被自动填充为null（int 为0）。我们也可以为这些字段实现自己的序列化机制。\n\n```\npublic class TransientTest implements Serializable{\n\t   private static final long serialVersionUID = 1L;\n\t\tpublic transient String  str;\n\t    public TransientTest() {\n\t    \tstr = \"hello\";\n\t    }\n\t    \n\t    private void writeObject(ObjectOutputStream out) throws IOException {\n\t        out.defaultWriteObject();\n\t        String encryption = \"key\" + str;\n\t        out.writeObject(encryption);\n\t    }\n\n\t    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n\t        in.defaultReadObject();\n\t       String encryption =  (String) in.readObject();\n\t       str = encryption.substring(\"key\".length(), encryption.length());\n\t    }\n\t    \n\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t\t  TransientTest test = new TransientTest();\n\t\t\t  SeriaUtil util = new SeriaUtil();\n\t\t\t  util.seria(test);\n\t\t\t  TransientTest reSeria = (TransientTest) util.reSeria();\n\t\t\t  System.out.println(reSeria.str);//hello\n\t\t}\n}\n```\n通过实现writeObject和readObject实现自己的序列化机制。上面的代码模拟了一个加密的序列化过程。\n\n## 成员变量没有实现序列化\n\n序列化某个实例时，如果这个实例含有对象类型的成员变量，那么同时会触发该变量的序列化机制。这时就要求这个成员变量也实现Serializable接口，如果没有实现该接口，抛出异常。\n\n```\npublic class VariableTest implements Serializable{\n\tVariable variable ;\n\tpublic VariableTest() {\n\t\tvariable = new Variable();\n\t}\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t    System.out.println(\"构造对象*************\");\n\t\t    VariableTest variableTest = new VariableTest();\n\t\t    System.out.println(\"序列化**************\");\n\t\t    SeriaUtil util = new SeriaUtil();\n\t\t    //抛出异常：java.io.NotSerializableException\n\t\t    util.seria(variableTest);\n\t\t    System.out.println(\"反序列化****************\");\n\t\t    VariableTest obj = (VariableTest) util.reSeria();\n\t\t    System.out.println(obj.variable.a);//抛出异常：Exception in thread \"main\" java.io.NotSerializableException: space.kyu.Variable\n\t}\n}\nclass Variable {\n\tpublic String a;\n\tpublic Variable(){\n\t\ta = \"hehe\";\n\t}\n}\n```\n\n## 单例模式下的序列化\n\n```\npublic class SingleTest implements Serializable{\n\tpublic static SingleTest instance = new SingleTest();\n\tprivate SingleTest(){}\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\tSingleTest test = SingleTest.instance;\n\t\tSeriaUtil util = new SeriaUtil();\n\t\tutil.seria(test);\n\t\tSingleTest reSeria = (SingleTest) util.reSeria();\n\t\tSystem.out.println(reSeria == SingleTest.instance);//false\n\t}\n}\n```\n\n由上面的代码可以看出，有两个SingleTest实例同时存在，通过反序列化破坏了单例模式。反序列化时会开辟新的内存空间重新实例化对象，所以单例模式被破坏。\n\n为了解决这种问题，可以实现readResolve()方法。\n\n```\npublic class SingleTest implements Serializable{\n\tpublic static SingleTest instance = new SingleTest();\n\tprivate SingleTest(){}\n\tprivate Object readResolve() {\n        return SingleTest.instance;\n    }\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\tSingleTest test = SingleTest.instance;\n\t\tSeriaUtil util = new SeriaUtil();\n\t\tutil.seria(test);\n\t\tSingleTest reSeria = (SingleTest) util.reSeria();\n\t\tSystem.out.println(reSeria == SingleTest.instance);//true\n\t}\n}\n```\n\n## 序列化版本\n\n代码是在不断的演化的。1.1版本的类可以读取1.0版本的序列化文件吗？这就涉及到序列化的版本管理。\n\n每个序列化版本都有其唯一的ID，他是数据域类型和方法签名的指纹。当类的定义产生变化时，他的指纹也会跟着产生变化，对象流将拒绝读入具有不同指纹的对象。\n如果想保持早期版本的兼容，首先要获取这个类早期版本的指纹。\n\n我们可以使用 jdk自带的工具 serialver 获得这个指纹：serialver Test\n```\nstaic final long serialVersionUID = -1423859403827594712L\n```\n然后将1.1版本中Test类的serialVersionUID常量定义为上面的值，即可序列化老版本的代码。\n\n如果一个类具有名为serialVersionUID的常量，那么java就不会再主动计算这个值，而是直接将其作为这个版本类的指纹。没有特殊要求的话，一般都显示的声明serialVersionUID：`private static final long serialVersionUID = 1L;`来保证兼容性\n\n如果对象流中的对象具有在当前版本中没有的数据域，那么对象流会忽略这些数据；如果当前版本具有对象流中所没有的数据域，那么这些新加的域将被设为默认值。\n\n## 序列化与克隆\n\n反序列化重新构建对象的机制提供了一种克隆对象的简便途径，只要对应的类可序列化即可。\n\n做法很简单：直接将对象序列化到输出流当中，然后将其读回。这样产生的对象是对现有对象的一个深拷贝。\n\n```\npublic class CloneTest implements Serializable, Cloneable {\n\tpublic String str;\n\tpublic CloneTest(String str) {\n\t\tthis.str =str;\n\t}\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\tSeriaUtil util = new SeriaUtil();\n\t\ttry {\n\t\t\tutil.seria(this);\n\t\t\tCloneTest reSeria = (CloneTest) util.reSeria();\n\t\t\treturn reSeria;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t} \n\t\t\n\t}\n\tpublic static void main(String[] args) throws CloneNotSupportedException {\n\t\tCloneTest test = new CloneTest(\"hi\");\n\t\tCloneTest clone = (CloneTest) test.clone();\n\t\tSystem.out.println(clone.str);//hi\n\t\tSystem.out.println(clone == test);//false\n\t}\n}\n\n```\n这样克隆对象的优点是简单，缺点是比普通的克隆实现要慢的多。","source":"_posts/java序列化与反序列化.md","raw":"---\nlayout: post\ntitle: java序列化与反序列化\ndate: 2017-03-22 20:14:46\ncategories: 编程\ntags: java\n---\n\n## 什么是序列化\n\n所谓的序列化，即把java对象以二进制形式保存到内存、文件或者进行网络传输。从二进制的形式恢复成为java对象，即反序列化。\n\n通过序列化可以将对象持久化，或者从一个地方传输到另一个地方。这方面的应用有RMI，远程方法调用。\n\njava中实现序列化有两种方式，实现Serializable接口或者Externalizable接口。这篇总结只讨论Serializable的情况。\n\n```\npublic class SerializeTest implements Serializable{\n\t    private static final long serialVersionUID = 1L;\n\t\tpublic String str;\n\t\tpublic SerializeTest(String str) {\n\t\t\t   this.str = str;\n\t\t}\n\t\t\n\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t\t   SerializeTest test = new SerializeTest(\"hello\");\n\t\t\t   ByteArrayOutputStream oStream = new ByteArrayOutputStream();\n\t\t\t   ObjectOutputStream objectOutputStream = new ObjectOutputStream(oStream);\n\t\t\t   objectOutputStream.writeObject(test);//序列化\n\t\t\t   \n\t\t\t   ObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(oStream.toByteArray()));\n\t\t\t   SerializeTest obj = (SerializeTest) inputStream.readObject();//反序列化\n\t\t\t   System.out.println(obj.str);\n\t\t}\n}\n```\n上面的代码演示了类SerializeTest实现序列化和反序列化的过程。\n\n所有的序列化和反序列化过程都是java默认实现的，你只需要实现接口Serializable，就能得到一个实现了序列化的类。\n通过ObjectOutputStream和ObjectInputStream分别将序列化对象输出或者写入到某个流当中。流的目的地可以是内存字节数组(上例)、文件、或者网络。\n\n下面研究一下序列化过程中的几个问题：\n\n## 静态变量如何序列化\n\n```\npublic class SeriaUtil {\n\t    ByteArrayInputStream bInputStream;\n\t    ByteArrayOutputStream byOutputStream;\n\t    ObjectOutputStream outputStream ;\n\t    ObjectInputStream inputStream;\n\t    \n        public void seria(Object test) throws IOException {\n        \tif (byOutputStream == null) {\n        \t\tbyOutputStream = new ByteArrayOutputStream();\n\t\t\t}\n        \tif (outputStream == null) {\n        \t\toutputStream = new ObjectOutputStream(byOutputStream);\n\t\t\t}\n\t\t    outputStream.writeObject(test);\n//\t\t   System.out.println(byOutputStream.toByteArray().length); \n        }\n        \n        public Object  reSeria() throws IOException, ClassNotFoundException {\n\t        \tif (bInputStream == null) {\n\t\t\t\t\t  bInputStream = new ByteArrayInputStream(byOutputStream.toByteArray());\n\t\t\t\t}\n\t        \tif (inputStream == null) {\n\t        \t\tinputStream = new ObjectInputStream(bInputStream);\n\t\t\t\t}\n\t\t\t    Object obj =  inputStream.readObject();\n\t\t\t    return obj;\n        }\n}\n\npublic class StaticTest implements Serializable{\n\tprivate static final long serialVersionUID = 1L;\n\tpublic static int A = 0;\n\tpublic static String B = \"hello\";\n\t\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t    //先序列化类，此时 A=0 B = hello\n\t\t    SeriaUtil seriaUtil = new SeriaUtil();\n\t\t    StaticTest test = new StaticTest();\n\t\t    seriaUtil.seria(test);\n\t\t    //修改 静态变量的值\n\t\t    StaticTest.A = 1;\n\t\t    StaticTest.B = \"world\";\n\t\t    \n\t\t    StaticTest obj = (StaticTest) seriaUtil.reSeria();\n\t\t    //输出 A = 1 B = world\n\t\t    System.out.println(obj.A);\n\t\t    System.out.println(obj.B);\n\t}\n}\n```\n上面的代码说明了，静态变量不会被序列化。\n\n序列化StaticTest实例test时，静态变量 A=0 B=\"hello\"，序列化之后，修改StaticTest类的静态变量值，A=1 B=\"world\"，\n此时反序列化得到之前序列化的实例对象赋给obj，发现obj的静态变量变为A=1 B=\"world\"，说明静态变量并未序列化成功。\n\n事实上，在序列化对象时，会忽略对象中的静态变量。很好理解，静态变量是属于类的，而不是某个对象的状态。我们序列化面向的是对象，是想要将对象的状态保存下来，所以\n静态变量不会被序列化。反序列化得到的对象中的静态变量的值是当前jvm中静态变量的值。静态变量对于同一个jvm中同一个类加载器加载的类来说，是一样的。对于同一个静态变量，不会存在同一个类的不同实例拥有不同的值。\n\n## 同一对象序列化两次，反序列化后得到的两个对象是否相等\n\n这个问题提到的相等，是指是否为同一对象，即==关系\n\n在某些情况下，确保这种关系是很重要的。比如王经理和李经理拥有同一个办公室，即存在引用关系：\n\n```\npublic class Manager{\n    Room room;\n    public Manager(Room r){\n        room = r;\n    }\n}\n\npublic class Room{}\n\npublic class APP{\n    public void main(String args[]){\n        Room room = new Room();\n        Manager wang = new Manager(room);\n        Manager li = new Manager(room);\n    }\n}\n```\n反序列化之后，wang，li，room的这种引用关系不应该发生变化。通过代码验证一下：\n\n```\npublic class ReferenceTest implements Serializable{\n\t\tpublic String a;\n\t\tpublic ReferenceTest() {\n\t\t\ta = \"hah\";\n\t\t}\n\t\tpublic static void main(String[] args) throws Exception {\n\t\t\t  System.out.println(\"构造对象********************\");\n\t\t\t  ReferenceTest test = new ReferenceTest();\n\t\t\t  System.out.println(\"序列化**********************\");\n\t\t\t  SeriaUtil util = new SeriaUtil();\n\t\t\t  util.seria(test);\n\t\t\t  util.seria(test);//第二次序列化该对象\n\t\t\t  System.out.println(\"反序列化**********************\");\n\t\t\t  ReferenceTest obj = (ReferenceTest) util.reSeria();\n\t\t\t  ReferenceTest obj1 = (ReferenceTest) util.reSeria();\n\t\t\t  System.out.println(obj == obj1);//true\n\t\t\t  System.out.println(obj == test);//false\n\t\t}\n}\n```\n上面的例子证明（System.out.println(obj == obj1);//true），同一对象序列化多次之后，反序列化得到的多个对象相等，即内存地址一致。\n\n使用同一个ObjectOutputStream对象序列化某个实例时，如果该实例还没有被序列化过，则序列化，若之前已经序列化过，则不再进行序列化，只是做一个标记而已。\n所以在反序列化时，可以保持原有的引用关系。\n\nSystem.out.println(obj == test);//false   也可以理解，反序列化之后重建了该对象，内存地址必然是新分配的，故obj != test\n\n## 父类没有实现Serializable，父类中的变量如何序列化\n\n```\npublic class SuperTest{\n       public String superB;\n       public SuperTest() {\n    \t   superB = \"hehe\";\n    \t   System.out.println(\"super 无参构造函数\");\n       }\n       \n       public SuperTest(String b){\n    \t   System.out.println(\"super 有参构造函数\");\n    \t   superB = b;\n       }\n\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t\t  System.out.println(\"构造对象*******************\");\n\t\t\t  SonTest sonTest = new SonTest(\"son\", \"super\");\n\t\t\t  System.out.println(\"序列化*********************\");\n\t\t\t  SeriaUtil  seriaUtil = new SeriaUtil();\n\t\t\t  seriaUtil.seria(sonTest);\n\t\t\t  System.out.println(\"反序列化******************\");\n\t\t\t  SonTest obj = (SonTest) seriaUtil.reSeria();\n\t\t\t  System.out.println(obj.sonA);\n\t\t\t  System.out.println(obj.superB);\n\t\t}\n}\n\nclass SonTest extends SuperTest  implements Serializable{\n\t private static final long serialVersionUID = 1L;\n\t public String sonA;\n\t public SonTest() {\n\t\t System.out.println(\"son 无参构造函数\");\n\t }\n\t \n\t public SonTest(String a, String b) {\n\t\t super(b);\n\t\t System.out.println(\"son 有参构造函数\");\n\t\t sonA = a;\n\t }\n}\n```\n输出：\n\n构造对象*******************\nsuper 有参构造函数\nson 有参构造函数\n序列化*********************\n反序列化******************\nsuper 无参构造函数\nson\nhehe\n\n通过上面的代码可以看出，父类如果没有实现serializable，反序列化时会调用父类的无参构造函数初始化父类当中的变量。\n\n所以，我们可以通过显示声明父类的无参构造函数，并在其中初始化变量值来控制反序列化后父类变量的值。\n\n## transient使用\n\n实现了serializable接口的类在序列化时默认会将所有的非静态变量进行序列化。我们可以控制某些字段不被默认的序列化机制序列化。\n\n比如，有些字段是跟当前系统环境相关的或者涉及到隐私的，需要保密的。这些字段是不可以被序列化到文件中或者通过网络传输的。我们可以通过为这些字段声明\ntransient关键字，保证其不被序列化。\n\n被关键字transient声明的变量不会被序列化，反序列化时该变量会被自动填充为null（int 为0）。我们也可以为这些字段实现自己的序列化机制。\n\n```\npublic class TransientTest implements Serializable{\n\t   private static final long serialVersionUID = 1L;\n\t\tpublic transient String  str;\n\t    public TransientTest() {\n\t    \tstr = \"hello\";\n\t    }\n\t    \n\t    private void writeObject(ObjectOutputStream out) throws IOException {\n\t        out.defaultWriteObject();\n\t        String encryption = \"key\" + str;\n\t        out.writeObject(encryption);\n\t    }\n\n\t    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n\t        in.defaultReadObject();\n\t       String encryption =  (String) in.readObject();\n\t       str = encryption.substring(\"key\".length(), encryption.length());\n\t    }\n\t    \n\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t\t  TransientTest test = new TransientTest();\n\t\t\t  SeriaUtil util = new SeriaUtil();\n\t\t\t  util.seria(test);\n\t\t\t  TransientTest reSeria = (TransientTest) util.reSeria();\n\t\t\t  System.out.println(reSeria.str);//hello\n\t\t}\n}\n```\n通过实现writeObject和readObject实现自己的序列化机制。上面的代码模拟了一个加密的序列化过程。\n\n## 成员变量没有实现序列化\n\n序列化某个实例时，如果这个实例含有对象类型的成员变量，那么同时会触发该变量的序列化机制。这时就要求这个成员变量也实现Serializable接口，如果没有实现该接口，抛出异常。\n\n```\npublic class VariableTest implements Serializable{\n\tVariable variable ;\n\tpublic VariableTest() {\n\t\tvariable = new Variable();\n\t}\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t    System.out.println(\"构造对象*************\");\n\t\t    VariableTest variableTest = new VariableTest();\n\t\t    System.out.println(\"序列化**************\");\n\t\t    SeriaUtil util = new SeriaUtil();\n\t\t    //抛出异常：java.io.NotSerializableException\n\t\t    util.seria(variableTest);\n\t\t    System.out.println(\"反序列化****************\");\n\t\t    VariableTest obj = (VariableTest) util.reSeria();\n\t\t    System.out.println(obj.variable.a);//抛出异常：Exception in thread \"main\" java.io.NotSerializableException: space.kyu.Variable\n\t}\n}\nclass Variable {\n\tpublic String a;\n\tpublic Variable(){\n\t\ta = \"hehe\";\n\t}\n}\n```\n\n## 单例模式下的序列化\n\n```\npublic class SingleTest implements Serializable{\n\tpublic static SingleTest instance = new SingleTest();\n\tprivate SingleTest(){}\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\tSingleTest test = SingleTest.instance;\n\t\tSeriaUtil util = new SeriaUtil();\n\t\tutil.seria(test);\n\t\tSingleTest reSeria = (SingleTest) util.reSeria();\n\t\tSystem.out.println(reSeria == SingleTest.instance);//false\n\t}\n}\n```\n\n由上面的代码可以看出，有两个SingleTest实例同时存在，通过反序列化破坏了单例模式。反序列化时会开辟新的内存空间重新实例化对象，所以单例模式被破坏。\n\n为了解决这种问题，可以实现readResolve()方法。\n\n```\npublic class SingleTest implements Serializable{\n\tpublic static SingleTest instance = new SingleTest();\n\tprivate SingleTest(){}\n\tprivate Object readResolve() {\n        return SingleTest.instance;\n    }\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\tSingleTest test = SingleTest.instance;\n\t\tSeriaUtil util = new SeriaUtil();\n\t\tutil.seria(test);\n\t\tSingleTest reSeria = (SingleTest) util.reSeria();\n\t\tSystem.out.println(reSeria == SingleTest.instance);//true\n\t}\n}\n```\n\n## 序列化版本\n\n代码是在不断的演化的。1.1版本的类可以读取1.0版本的序列化文件吗？这就涉及到序列化的版本管理。\n\n每个序列化版本都有其唯一的ID，他是数据域类型和方法签名的指纹。当类的定义产生变化时，他的指纹也会跟着产生变化，对象流将拒绝读入具有不同指纹的对象。\n如果想保持早期版本的兼容，首先要获取这个类早期版本的指纹。\n\n我们可以使用 jdk自带的工具 serialver 获得这个指纹：serialver Test\n```\nstaic final long serialVersionUID = -1423859403827594712L\n```\n然后将1.1版本中Test类的serialVersionUID常量定义为上面的值，即可序列化老版本的代码。\n\n如果一个类具有名为serialVersionUID的常量，那么java就不会再主动计算这个值，而是直接将其作为这个版本类的指纹。没有特殊要求的话，一般都显示的声明serialVersionUID：`private static final long serialVersionUID = 1L;`来保证兼容性\n\n如果对象流中的对象具有在当前版本中没有的数据域，那么对象流会忽略这些数据；如果当前版本具有对象流中所没有的数据域，那么这些新加的域将被设为默认值。\n\n## 序列化与克隆\n\n反序列化重新构建对象的机制提供了一种克隆对象的简便途径，只要对应的类可序列化即可。\n\n做法很简单：直接将对象序列化到输出流当中，然后将其读回。这样产生的对象是对现有对象的一个深拷贝。\n\n```\npublic class CloneTest implements Serializable, Cloneable {\n\tpublic String str;\n\tpublic CloneTest(String str) {\n\t\tthis.str =str;\n\t}\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\tSeriaUtil util = new SeriaUtil();\n\t\ttry {\n\t\t\tutil.seria(this);\n\t\t\tCloneTest reSeria = (CloneTest) util.reSeria();\n\t\t\treturn reSeria;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t} \n\t\t\n\t}\n\tpublic static void main(String[] args) throws CloneNotSupportedException {\n\t\tCloneTest test = new CloneTest(\"hi\");\n\t\tCloneTest clone = (CloneTest) test.clone();\n\t\tSystem.out.println(clone.str);//hi\n\t\tSystem.out.println(clone == test);//false\n\t}\n}\n\n```\n这样克隆对象的优点是简单，缺点是比普通的克隆实现要慢的多。","slug":"java序列化与反序列化","published":1,"updated":"2017-03-29T03:18:29.497Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlrh001svegcoq71j4df","content":"<h2 id=\"什么是序列化\"><a href=\"#什么是序列化\" class=\"headerlink\" title=\"什么是序列化\"></a>什么是序列化</h2><p>所谓的序列化，即把java对象以二进制形式保存到内存、文件或者进行网络传输。从二进制的形式恢复成为java对象，即反序列化。</p>\n<p>通过序列化可以将对象持久化，或者从一个地方传输到另一个地方。这方面的应用有RMI，远程方法调用。</p>\n<p>java中实现序列化有两种方式，实现Serializable接口或者Externalizable接口。这篇总结只讨论Serializable的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SerializeTest implements Serializable&#123;</div><div class=\"line\">\t    private static final long serialVersionUID = 1L;</div><div class=\"line\">\t\tpublic String str;</div><div class=\"line\">\t\tpublic SerializeTest(String str) &#123;</div><div class=\"line\">\t\t\t   this.str = str;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t\t   SerializeTest test = new SerializeTest(&quot;hello&quot;);</div><div class=\"line\">\t\t\t   ByteArrayOutputStream oStream = new ByteArrayOutputStream();</div><div class=\"line\">\t\t\t   ObjectOutputStream objectOutputStream = new ObjectOutputStream(oStream);</div><div class=\"line\">\t\t\t   objectOutputStream.writeObject(test);//序列化</div><div class=\"line\">\t\t\t   </div><div class=\"line\">\t\t\t   ObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(oStream.toByteArray()));</div><div class=\"line\">\t\t\t   SerializeTest obj = (SerializeTest) inputStream.readObject();//反序列化</div><div class=\"line\">\t\t\t   System.out.println(obj.str);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码演示了类SerializeTest实现序列化和反序列化的过程。</p>\n<p>所有的序列化和反序列化过程都是java默认实现的，你只需要实现接口Serializable，就能得到一个实现了序列化的类。<br>通过ObjectOutputStream和ObjectInputStream分别将序列化对象输出或者写入到某个流当中。流的目的地可以是内存字节数组(上例)、文件、或者网络。</p>\n<p>下面研究一下序列化过程中的几个问题：</p>\n<h2 id=\"静态变量如何序列化\"><a href=\"#静态变量如何序列化\" class=\"headerlink\" title=\"静态变量如何序列化\"></a>静态变量如何序列化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SeriaUtil &#123;</div><div class=\"line\">\t    ByteArrayInputStream bInputStream;</div><div class=\"line\">\t    ByteArrayOutputStream byOutputStream;</div><div class=\"line\">\t    ObjectOutputStream outputStream ;</div><div class=\"line\">\t    ObjectInputStream inputStream;</div><div class=\"line\">\t    </div><div class=\"line\">        public void seria(Object test) throws IOException &#123;</div><div class=\"line\">        \tif (byOutputStream == null) &#123;</div><div class=\"line\">        \t\tbyOutputStream = new ByteArrayOutputStream();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">        \tif (outputStream == null) &#123;</div><div class=\"line\">        \t\toutputStream = new ObjectOutputStream(byOutputStream);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t    outputStream.writeObject(test);</div><div class=\"line\">//\t\t   System.out.println(byOutputStream.toByteArray().length); </div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        public Object  reSeria() throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t        \tif (bInputStream == null) &#123;</div><div class=\"line\">\t\t\t\t\t  bInputStream = new ByteArrayInputStream(byOutputStream.toByteArray());</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t        \tif (inputStream == null) &#123;</div><div class=\"line\">\t        \t\tinputStream = new ObjectInputStream(bInputStream);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t    Object obj =  inputStream.readObject();</div><div class=\"line\">\t\t\t    return obj;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class StaticTest implements Serializable&#123;</div><div class=\"line\">\tprivate static final long serialVersionUID = 1L;</div><div class=\"line\">\tpublic static int A = 0;</div><div class=\"line\">\tpublic static String B = &quot;hello&quot;;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t    //先序列化类，此时 A=0 B = hello</div><div class=\"line\">\t\t    SeriaUtil seriaUtil = new SeriaUtil();</div><div class=\"line\">\t\t    StaticTest test = new StaticTest();</div><div class=\"line\">\t\t    seriaUtil.seria(test);</div><div class=\"line\">\t\t    //修改 静态变量的值</div><div class=\"line\">\t\t    StaticTest.A = 1;</div><div class=\"line\">\t\t    StaticTest.B = &quot;world&quot;;</div><div class=\"line\">\t\t    </div><div class=\"line\">\t\t    StaticTest obj = (StaticTest) seriaUtil.reSeria();</div><div class=\"line\">\t\t    //输出 A = 1 B = world</div><div class=\"line\">\t\t    System.out.println(obj.A);</div><div class=\"line\">\t\t    System.out.println(obj.B);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码说明了，静态变量不会被序列化。</p>\n<p>序列化StaticTest实例test时，静态变量 A=0 B=”hello”，序列化之后，修改StaticTest类的静态变量值，A=1 B=”world”，<br>此时反序列化得到之前序列化的实例对象赋给obj，发现obj的静态变量变为A=1 B=”world”，说明静态变量并未序列化成功。</p>\n<p>事实上，在序列化对象时，会忽略对象中的静态变量。很好理解，静态变量是属于类的，而不是某个对象的状态。我们序列化面向的是对象，是想要将对象的状态保存下来，所以<br>静态变量不会被序列化。反序列化得到的对象中的静态变量的值是当前jvm中静态变量的值。静态变量对于同一个jvm中同一个类加载器加载的类来说，是一样的。对于同一个静态变量，不会存在同一个类的不同实例拥有不同的值。</p>\n<h2 id=\"同一对象序列化两次，反序列化后得到的两个对象是否相等\"><a href=\"#同一对象序列化两次，反序列化后得到的两个对象是否相等\" class=\"headerlink\" title=\"同一对象序列化两次，反序列化后得到的两个对象是否相等\"></a>同一对象序列化两次，反序列化后得到的两个对象是否相等</h2><p>这个问题提到的相等，是指是否为同一对象，即==关系</p>\n<p>在某些情况下，确保这种关系是很重要的。比如王经理和李经理拥有同一个办公室，即存在引用关系：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Manager&#123;</div><div class=\"line\">    Room room;</div><div class=\"line\">    public Manager(Room r)&#123;</div><div class=\"line\">        room = r;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class Room&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">public class APP&#123;</div><div class=\"line\">    public void main(String args[])&#123;</div><div class=\"line\">        Room room = new Room();</div><div class=\"line\">        Manager wang = new Manager(room);</div><div class=\"line\">        Manager li = new Manager(room);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>反序列化之后，wang，li，room的这种引用关系不应该发生变化。通过代码验证一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ReferenceTest implements Serializable&#123;</div><div class=\"line\">\t\tpublic String a;</div><div class=\"line\">\t\tpublic ReferenceTest() &#123;</div><div class=\"line\">\t\t\ta = &quot;hah&quot;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tpublic static void main(String[] args) throws Exception &#123;</div><div class=\"line\">\t\t\t  System.out.println(&quot;构造对象********************&quot;);</div><div class=\"line\">\t\t\t  ReferenceTest test = new ReferenceTest();</div><div class=\"line\">\t\t\t  System.out.println(&quot;序列化**********************&quot;);</div><div class=\"line\">\t\t\t  SeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\t\t  util.seria(test);</div><div class=\"line\">\t\t\t  util.seria(test);//第二次序列化该对象</div><div class=\"line\">\t\t\t  System.out.println(&quot;反序列化**********************&quot;);</div><div class=\"line\">\t\t\t  ReferenceTest obj = (ReferenceTest) util.reSeria();</div><div class=\"line\">\t\t\t  ReferenceTest obj1 = (ReferenceTest) util.reSeria();</div><div class=\"line\">\t\t\t  System.out.println(obj == obj1);//true</div><div class=\"line\">\t\t\t  System.out.println(obj == test);//false</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的例子证明（System.out.println(obj == obj1);//true），同一对象序列化多次之后，反序列化得到的多个对象相等，即内存地址一致。</p>\n<p>使用同一个ObjectOutputStream对象序列化某个实例时，如果该实例还没有被序列化过，则序列化，若之前已经序列化过，则不再进行序列化，只是做一个标记而已。<br>所以在反序列化时，可以保持原有的引用关系。</p>\n<p>System.out.println(obj == test);//false   也可以理解，反序列化之后重建了该对象，内存地址必然是新分配的，故obj != test</p>\n<h2 id=\"父类没有实现Serializable，父类中的变量如何序列化\"><a href=\"#父类没有实现Serializable，父类中的变量如何序列化\" class=\"headerlink\" title=\"父类没有实现Serializable，父类中的变量如何序列化\"></a>父类没有实现Serializable，父类中的变量如何序列化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SuperTest&#123;</div><div class=\"line\">       public String superB;</div><div class=\"line\">       public SuperTest() &#123;</div><div class=\"line\">    \t   superB = &quot;hehe&quot;;</div><div class=\"line\">    \t   System.out.println(&quot;super 无参构造函数&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       public SuperTest(String b)&#123;</div><div class=\"line\">    \t   System.out.println(&quot;super 有参构造函数&quot;);</div><div class=\"line\">    \t   superB = b;</div><div class=\"line\">       &#125;</div><div class=\"line\">\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t\t  System.out.println(&quot;构造对象*******************&quot;);</div><div class=\"line\">\t\t\t  SonTest sonTest = new SonTest(&quot;son&quot;, &quot;super&quot;);</div><div class=\"line\">\t\t\t  System.out.println(&quot;序列化*********************&quot;);</div><div class=\"line\">\t\t\t  SeriaUtil  seriaUtil = new SeriaUtil();</div><div class=\"line\">\t\t\t  seriaUtil.seria(sonTest);</div><div class=\"line\">\t\t\t  System.out.println(&quot;反序列化******************&quot;);</div><div class=\"line\">\t\t\t  SonTest obj = (SonTest) seriaUtil.reSeria();</div><div class=\"line\">\t\t\t  System.out.println(obj.sonA);</div><div class=\"line\">\t\t\t  System.out.println(obj.superB);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class SonTest extends SuperTest  implements Serializable&#123;</div><div class=\"line\">\t private static final long serialVersionUID = 1L;</div><div class=\"line\">\t public String sonA;</div><div class=\"line\">\t public SonTest() &#123;</div><div class=\"line\">\t\t System.out.println(&quot;son 无参构造函数&quot;);</div><div class=\"line\">\t &#125;</div><div class=\"line\">\t </div><div class=\"line\">\t public SonTest(String a, String b) &#123;</div><div class=\"line\">\t\t super(b);</div><div class=\"line\">\t\t System.out.println(&quot;son 有参构造函数&quot;);</div><div class=\"line\">\t\t sonA = a;</div><div class=\"line\">\t &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：</p>\n<p>构造对象<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong><br>super 有参构造函数<br>son 有参构造函数<br>序列化<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong><br>反序列化<strong><strong><strong><strong>**</strong></strong></strong></strong><br>super 无参构造函数<br>son<br>hehe</p>\n<p>通过上面的代码可以看出，父类如果没有实现serializable，反序列化时会调用父类的无参构造函数初始化父类当中的变量。</p>\n<p>所以，我们可以通过显示声明父类的无参构造函数，并在其中初始化变量值来控制反序列化后父类变量的值。</p>\n<h2 id=\"transient使用\"><a href=\"#transient使用\" class=\"headerlink\" title=\"transient使用\"></a>transient使用</h2><p>实现了serializable接口的类在序列化时默认会将所有的非静态变量进行序列化。我们可以控制某些字段不被默认的序列化机制序列化。</p>\n<p>比如，有些字段是跟当前系统环境相关的或者涉及到隐私的，需要保密的。这些字段是不可以被序列化到文件中或者通过网络传输的。我们可以通过为这些字段声明<br>transient关键字，保证其不被序列化。</p>\n<p>被关键字transient声明的变量不会被序列化，反序列化时该变量会被自动填充为null（int 为0）。我们也可以为这些字段实现自己的序列化机制。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TransientTest implements Serializable&#123;</div><div class=\"line\">\t   private static final long serialVersionUID = 1L;</div><div class=\"line\">\t\tpublic transient String  str;</div><div class=\"line\">\t    public TransientTest() &#123;</div><div class=\"line\">\t    \tstr = &quot;hello&quot;;</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    </div><div class=\"line\">\t    private void writeObject(ObjectOutputStream out) throws IOException &#123;</div><div class=\"line\">\t        out.defaultWriteObject();</div><div class=\"line\">\t        String encryption = &quot;key&quot; + str;</div><div class=\"line\">\t        out.writeObject(encryption);</div><div class=\"line\">\t    &#125;</div><div class=\"line\"></div><div class=\"line\">\t    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t        in.defaultReadObject();</div><div class=\"line\">\t       String encryption =  (String) in.readObject();</div><div class=\"line\">\t       str = encryption.substring(&quot;key&quot;.length(), encryption.length());</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    </div><div class=\"line\">\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t\t  TransientTest test = new TransientTest();</div><div class=\"line\">\t\t\t  SeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\t\t  util.seria(test);</div><div class=\"line\">\t\t\t  TransientTest reSeria = (TransientTest) util.reSeria();</div><div class=\"line\">\t\t\t  System.out.println(reSeria.str);//hello</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过实现writeObject和readObject实现自己的序列化机制。上面的代码模拟了一个加密的序列化过程。</p>\n<h2 id=\"成员变量没有实现序列化\"><a href=\"#成员变量没有实现序列化\" class=\"headerlink\" title=\"成员变量没有实现序列化\"></a>成员变量没有实现序列化</h2><p>序列化某个实例时，如果这个实例含有对象类型的成员变量，那么同时会触发该变量的序列化机制。这时就要求这个成员变量也实现Serializable接口，如果没有实现该接口，抛出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class VariableTest implements Serializable&#123;</div><div class=\"line\">\tVariable variable ;</div><div class=\"line\">\tpublic VariableTest() &#123;</div><div class=\"line\">\t\tvariable = new Variable();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t    System.out.println(&quot;构造对象*************&quot;);</div><div class=\"line\">\t\t    VariableTest variableTest = new VariableTest();</div><div class=\"line\">\t\t    System.out.println(&quot;序列化**************&quot;);</div><div class=\"line\">\t\t    SeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\t    //抛出异常：java.io.NotSerializableException</div><div class=\"line\">\t\t    util.seria(variableTest);</div><div class=\"line\">\t\t    System.out.println(&quot;反序列化****************&quot;);</div><div class=\"line\">\t\t    VariableTest obj = (VariableTest) util.reSeria();</div><div class=\"line\">\t\t    System.out.println(obj.variable.a);//抛出异常：Exception in thread &quot;main&quot; java.io.NotSerializableException: space.kyu.Variable</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class Variable &#123;</div><div class=\"line\">\tpublic String a;</div><div class=\"line\">\tpublic Variable()&#123;</div><div class=\"line\">\t\ta = &quot;hehe&quot;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"单例模式下的序列化\"><a href=\"#单例模式下的序列化\" class=\"headerlink\" title=\"单例模式下的序列化\"></a>单例模式下的序列化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SingleTest implements Serializable&#123;</div><div class=\"line\">\tpublic static SingleTest instance = new SingleTest();</div><div class=\"line\">\tprivate SingleTest()&#123;&#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\tSingleTest test = SingleTest.instance;</div><div class=\"line\">\t\tSeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\tutil.seria(test);</div><div class=\"line\">\t\tSingleTest reSeria = (SingleTest) util.reSeria();</div><div class=\"line\">\t\tSystem.out.println(reSeria == SingleTest.instance);//false</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由上面的代码可以看出，有两个SingleTest实例同时存在，通过反序列化破坏了单例模式。反序列化时会开辟新的内存空间重新实例化对象，所以单例模式被破坏。</p>\n<p>为了解决这种问题，可以实现readResolve()方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SingleTest implements Serializable&#123;</div><div class=\"line\">\tpublic static SingleTest instance = new SingleTest();</div><div class=\"line\">\tprivate SingleTest()&#123;&#125;</div><div class=\"line\">\tprivate Object readResolve() &#123;</div><div class=\"line\">        return SingleTest.instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\tSingleTest test = SingleTest.instance;</div><div class=\"line\">\t\tSeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\tutil.seria(test);</div><div class=\"line\">\t\tSingleTest reSeria = (SingleTest) util.reSeria();</div><div class=\"line\">\t\tSystem.out.println(reSeria == SingleTest.instance);//true</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"序列化版本\"><a href=\"#序列化版本\" class=\"headerlink\" title=\"序列化版本\"></a>序列化版本</h2><p>代码是在不断的演化的。1.1版本的类可以读取1.0版本的序列化文件吗？这就涉及到序列化的版本管理。</p>\n<p>每个序列化版本都有其唯一的ID，他是数据域类型和方法签名的指纹。当类的定义产生变化时，他的指纹也会跟着产生变化，对象流将拒绝读入具有不同指纹的对象。<br>如果想保持早期版本的兼容，首先要获取这个类早期版本的指纹。</p>\n<p>我们可以使用 jdk自带的工具 serialver 获得这个指纹：serialver Test<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">staic final long serialVersionUID = -1423859403827594712L</div></pre></td></tr></table></figure></p>\n<p>然后将1.1版本中Test类的serialVersionUID常量定义为上面的值，即可序列化老版本的代码。</p>\n<p>如果一个类具有名为serialVersionUID的常量，那么java就不会再主动计算这个值，而是直接将其作为这个版本类的指纹。没有特殊要求的话，一般都显示的声明serialVersionUID：<code>private static final long serialVersionUID = 1L;</code>来保证兼容性</p>\n<p>如果对象流中的对象具有在当前版本中没有的数据域，那么对象流会忽略这些数据；如果当前版本具有对象流中所没有的数据域，那么这些新加的域将被设为默认值。</p>\n<h2 id=\"序列化与克隆\"><a href=\"#序列化与克隆\" class=\"headerlink\" title=\"序列化与克隆\"></a>序列化与克隆</h2><p>反序列化重新构建对象的机制提供了一种克隆对象的简便途径，只要对应的类可序列化即可。</p>\n<p>做法很简单：直接将对象序列化到输出流当中，然后将其读回。这样产生的对象是对现有对象的一个深拷贝。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CloneTest implements Serializable, Cloneable &#123;</div><div class=\"line\">\tpublic String str;</div><div class=\"line\">\tpublic CloneTest(String str) &#123;</div><div class=\"line\">\t\tthis.str =str;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tprotected Object clone() throws CloneNotSupportedException &#123;</div><div class=\"line\">\t\tSeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tutil.seria(this);</div><div class=\"line\">\t\t\tCloneTest reSeria = (CloneTest) util.reSeria();</div><div class=\"line\">\t\t\treturn reSeria;</div><div class=\"line\">\t\t&#125; catch (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\treturn null;</div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws CloneNotSupportedException &#123;</div><div class=\"line\">\t\tCloneTest test = new CloneTest(&quot;hi&quot;);</div><div class=\"line\">\t\tCloneTest clone = (CloneTest) test.clone();</div><div class=\"line\">\t\tSystem.out.println(clone.str);//hi</div><div class=\"line\">\t\tSystem.out.println(clone == test);//false</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样克隆对象的优点是简单，缺点是比普通的克隆实现要慢的多。</p>\n","excerpt":"","more":"<h2 id=\"什么是序列化\"><a href=\"#什么是序列化\" class=\"headerlink\" title=\"什么是序列化\"></a>什么是序列化</h2><p>所谓的序列化，即把java对象以二进制形式保存到内存、文件或者进行网络传输。从二进制的形式恢复成为java对象，即反序列化。</p>\n<p>通过序列化可以将对象持久化，或者从一个地方传输到另一个地方。这方面的应用有RMI，远程方法调用。</p>\n<p>java中实现序列化有两种方式，实现Serializable接口或者Externalizable接口。这篇总结只讨论Serializable的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SerializeTest implements Serializable&#123;</div><div class=\"line\">\t    private static final long serialVersionUID = 1L;</div><div class=\"line\">\t\tpublic String str;</div><div class=\"line\">\t\tpublic SerializeTest(String str) &#123;</div><div class=\"line\">\t\t\t   this.str = str;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t\t   SerializeTest test = new SerializeTest(&quot;hello&quot;);</div><div class=\"line\">\t\t\t   ByteArrayOutputStream oStream = new ByteArrayOutputStream();</div><div class=\"line\">\t\t\t   ObjectOutputStream objectOutputStream = new ObjectOutputStream(oStream);</div><div class=\"line\">\t\t\t   objectOutputStream.writeObject(test);//序列化</div><div class=\"line\">\t\t\t   </div><div class=\"line\">\t\t\t   ObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(oStream.toByteArray()));</div><div class=\"line\">\t\t\t   SerializeTest obj = (SerializeTest) inputStream.readObject();//反序列化</div><div class=\"line\">\t\t\t   System.out.println(obj.str);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码演示了类SerializeTest实现序列化和反序列化的过程。</p>\n<p>所有的序列化和反序列化过程都是java默认实现的，你只需要实现接口Serializable，就能得到一个实现了序列化的类。<br>通过ObjectOutputStream和ObjectInputStream分别将序列化对象输出或者写入到某个流当中。流的目的地可以是内存字节数组(上例)、文件、或者网络。</p>\n<p>下面研究一下序列化过程中的几个问题：</p>\n<h2 id=\"静态变量如何序列化\"><a href=\"#静态变量如何序列化\" class=\"headerlink\" title=\"静态变量如何序列化\"></a>静态变量如何序列化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SeriaUtil &#123;</div><div class=\"line\">\t    ByteArrayInputStream bInputStream;</div><div class=\"line\">\t    ByteArrayOutputStream byOutputStream;</div><div class=\"line\">\t    ObjectOutputStream outputStream ;</div><div class=\"line\">\t    ObjectInputStream inputStream;</div><div class=\"line\">\t    </div><div class=\"line\">        public void seria(Object test) throws IOException &#123;</div><div class=\"line\">        \tif (byOutputStream == null) &#123;</div><div class=\"line\">        \t\tbyOutputStream = new ByteArrayOutputStream();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">        \tif (outputStream == null) &#123;</div><div class=\"line\">        \t\toutputStream = new ObjectOutputStream(byOutputStream);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t    outputStream.writeObject(test);</div><div class=\"line\">//\t\t   System.out.println(byOutputStream.toByteArray().length); </div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        public Object  reSeria() throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t        \tif (bInputStream == null) &#123;</div><div class=\"line\">\t\t\t\t\t  bInputStream = new ByteArrayInputStream(byOutputStream.toByteArray());</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t        \tif (inputStream == null) &#123;</div><div class=\"line\">\t        \t\tinputStream = new ObjectInputStream(bInputStream);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t    Object obj =  inputStream.readObject();</div><div class=\"line\">\t\t\t    return obj;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class StaticTest implements Serializable&#123;</div><div class=\"line\">\tprivate static final long serialVersionUID = 1L;</div><div class=\"line\">\tpublic static int A = 0;</div><div class=\"line\">\tpublic static String B = &quot;hello&quot;;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t    //先序列化类，此时 A=0 B = hello</div><div class=\"line\">\t\t    SeriaUtil seriaUtil = new SeriaUtil();</div><div class=\"line\">\t\t    StaticTest test = new StaticTest();</div><div class=\"line\">\t\t    seriaUtil.seria(test);</div><div class=\"line\">\t\t    //修改 静态变量的值</div><div class=\"line\">\t\t    StaticTest.A = 1;</div><div class=\"line\">\t\t    StaticTest.B = &quot;world&quot;;</div><div class=\"line\">\t\t    </div><div class=\"line\">\t\t    StaticTest obj = (StaticTest) seriaUtil.reSeria();</div><div class=\"line\">\t\t    //输出 A = 1 B = world</div><div class=\"line\">\t\t    System.out.println(obj.A);</div><div class=\"line\">\t\t    System.out.println(obj.B);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码说明了，静态变量不会被序列化。</p>\n<p>序列化StaticTest实例test时，静态变量 A=0 B=”hello”，序列化之后，修改StaticTest类的静态变量值，A=1 B=”world”，<br>此时反序列化得到之前序列化的实例对象赋给obj，发现obj的静态变量变为A=1 B=”world”，说明静态变量并未序列化成功。</p>\n<p>事实上，在序列化对象时，会忽略对象中的静态变量。很好理解，静态变量是属于类的，而不是某个对象的状态。我们序列化面向的是对象，是想要将对象的状态保存下来，所以<br>静态变量不会被序列化。反序列化得到的对象中的静态变量的值是当前jvm中静态变量的值。静态变量对于同一个jvm中同一个类加载器加载的类来说，是一样的。对于同一个静态变量，不会存在同一个类的不同实例拥有不同的值。</p>\n<h2 id=\"同一对象序列化两次，反序列化后得到的两个对象是否相等\"><a href=\"#同一对象序列化两次，反序列化后得到的两个对象是否相等\" class=\"headerlink\" title=\"同一对象序列化两次，反序列化后得到的两个对象是否相等\"></a>同一对象序列化两次，反序列化后得到的两个对象是否相等</h2><p>这个问题提到的相等，是指是否为同一对象，即==关系</p>\n<p>在某些情况下，确保这种关系是很重要的。比如王经理和李经理拥有同一个办公室，即存在引用关系：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Manager&#123;</div><div class=\"line\">    Room room;</div><div class=\"line\">    public Manager(Room r)&#123;</div><div class=\"line\">        room = r;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class Room&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">public class APP&#123;</div><div class=\"line\">    public void main(String args[])&#123;</div><div class=\"line\">        Room room = new Room();</div><div class=\"line\">        Manager wang = new Manager(room);</div><div class=\"line\">        Manager li = new Manager(room);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>反序列化之后，wang，li，room的这种引用关系不应该发生变化。通过代码验证一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ReferenceTest implements Serializable&#123;</div><div class=\"line\">\t\tpublic String a;</div><div class=\"line\">\t\tpublic ReferenceTest() &#123;</div><div class=\"line\">\t\t\ta = &quot;hah&quot;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tpublic static void main(String[] args) throws Exception &#123;</div><div class=\"line\">\t\t\t  System.out.println(&quot;构造对象********************&quot;);</div><div class=\"line\">\t\t\t  ReferenceTest test = new ReferenceTest();</div><div class=\"line\">\t\t\t  System.out.println(&quot;序列化**********************&quot;);</div><div class=\"line\">\t\t\t  SeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\t\t  util.seria(test);</div><div class=\"line\">\t\t\t  util.seria(test);//第二次序列化该对象</div><div class=\"line\">\t\t\t  System.out.println(&quot;反序列化**********************&quot;);</div><div class=\"line\">\t\t\t  ReferenceTest obj = (ReferenceTest) util.reSeria();</div><div class=\"line\">\t\t\t  ReferenceTest obj1 = (ReferenceTest) util.reSeria();</div><div class=\"line\">\t\t\t  System.out.println(obj == obj1);//true</div><div class=\"line\">\t\t\t  System.out.println(obj == test);//false</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的例子证明（System.out.println(obj == obj1);//true），同一对象序列化多次之后，反序列化得到的多个对象相等，即内存地址一致。</p>\n<p>使用同一个ObjectOutputStream对象序列化某个实例时，如果该实例还没有被序列化过，则序列化，若之前已经序列化过，则不再进行序列化，只是做一个标记而已。<br>所以在反序列化时，可以保持原有的引用关系。</p>\n<p>System.out.println(obj == test);//false   也可以理解，反序列化之后重建了该对象，内存地址必然是新分配的，故obj != test</p>\n<h2 id=\"父类没有实现Serializable，父类中的变量如何序列化\"><a href=\"#父类没有实现Serializable，父类中的变量如何序列化\" class=\"headerlink\" title=\"父类没有实现Serializable，父类中的变量如何序列化\"></a>父类没有实现Serializable，父类中的变量如何序列化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SuperTest&#123;</div><div class=\"line\">       public String superB;</div><div class=\"line\">       public SuperTest() &#123;</div><div class=\"line\">    \t   superB = &quot;hehe&quot;;</div><div class=\"line\">    \t   System.out.println(&quot;super 无参构造函数&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       public SuperTest(String b)&#123;</div><div class=\"line\">    \t   System.out.println(&quot;super 有参构造函数&quot;);</div><div class=\"line\">    \t   superB = b;</div><div class=\"line\">       &#125;</div><div class=\"line\">\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t\t  System.out.println(&quot;构造对象*******************&quot;);</div><div class=\"line\">\t\t\t  SonTest sonTest = new SonTest(&quot;son&quot;, &quot;super&quot;);</div><div class=\"line\">\t\t\t  System.out.println(&quot;序列化*********************&quot;);</div><div class=\"line\">\t\t\t  SeriaUtil  seriaUtil = new SeriaUtil();</div><div class=\"line\">\t\t\t  seriaUtil.seria(sonTest);</div><div class=\"line\">\t\t\t  System.out.println(&quot;反序列化******************&quot;);</div><div class=\"line\">\t\t\t  SonTest obj = (SonTest) seriaUtil.reSeria();</div><div class=\"line\">\t\t\t  System.out.println(obj.sonA);</div><div class=\"line\">\t\t\t  System.out.println(obj.superB);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class SonTest extends SuperTest  implements Serializable&#123;</div><div class=\"line\">\t private static final long serialVersionUID = 1L;</div><div class=\"line\">\t public String sonA;</div><div class=\"line\">\t public SonTest() &#123;</div><div class=\"line\">\t\t System.out.println(&quot;son 无参构造函数&quot;);</div><div class=\"line\">\t &#125;</div><div class=\"line\">\t </div><div class=\"line\">\t public SonTest(String a, String b) &#123;</div><div class=\"line\">\t\t super(b);</div><div class=\"line\">\t\t System.out.println(&quot;son 有参构造函数&quot;);</div><div class=\"line\">\t\t sonA = a;</div><div class=\"line\">\t &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：</p>\n<p>构造对象<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong><br>super 有参构造函数<br>son 有参构造函数<br>序列化<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong><br>反序列化<strong><strong><strong><strong>**</strong></strong></strong></strong><br>super 无参构造函数<br>son<br>hehe</p>\n<p>通过上面的代码可以看出，父类如果没有实现serializable，反序列化时会调用父类的无参构造函数初始化父类当中的变量。</p>\n<p>所以，我们可以通过显示声明父类的无参构造函数，并在其中初始化变量值来控制反序列化后父类变量的值。</p>\n<h2 id=\"transient使用\"><a href=\"#transient使用\" class=\"headerlink\" title=\"transient使用\"></a>transient使用</h2><p>实现了serializable接口的类在序列化时默认会将所有的非静态变量进行序列化。我们可以控制某些字段不被默认的序列化机制序列化。</p>\n<p>比如，有些字段是跟当前系统环境相关的或者涉及到隐私的，需要保密的。这些字段是不可以被序列化到文件中或者通过网络传输的。我们可以通过为这些字段声明<br>transient关键字，保证其不被序列化。</p>\n<p>被关键字transient声明的变量不会被序列化，反序列化时该变量会被自动填充为null（int 为0）。我们也可以为这些字段实现自己的序列化机制。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TransientTest implements Serializable&#123;</div><div class=\"line\">\t   private static final long serialVersionUID = 1L;</div><div class=\"line\">\t\tpublic transient String  str;</div><div class=\"line\">\t    public TransientTest() &#123;</div><div class=\"line\">\t    \tstr = &quot;hello&quot;;</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    </div><div class=\"line\">\t    private void writeObject(ObjectOutputStream out) throws IOException &#123;</div><div class=\"line\">\t        out.defaultWriteObject();</div><div class=\"line\">\t        String encryption = &quot;key&quot; + str;</div><div class=\"line\">\t        out.writeObject(encryption);</div><div class=\"line\">\t    &#125;</div><div class=\"line\"></div><div class=\"line\">\t    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t        in.defaultReadObject();</div><div class=\"line\">\t       String encryption =  (String) in.readObject();</div><div class=\"line\">\t       str = encryption.substring(&quot;key&quot;.length(), encryption.length());</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    </div><div class=\"line\">\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t\t  TransientTest test = new TransientTest();</div><div class=\"line\">\t\t\t  SeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\t\t  util.seria(test);</div><div class=\"line\">\t\t\t  TransientTest reSeria = (TransientTest) util.reSeria();</div><div class=\"line\">\t\t\t  System.out.println(reSeria.str);//hello</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过实现writeObject和readObject实现自己的序列化机制。上面的代码模拟了一个加密的序列化过程。</p>\n<h2 id=\"成员变量没有实现序列化\"><a href=\"#成员变量没有实现序列化\" class=\"headerlink\" title=\"成员变量没有实现序列化\"></a>成员变量没有实现序列化</h2><p>序列化某个实例时，如果这个实例含有对象类型的成员变量，那么同时会触发该变量的序列化机制。这时就要求这个成员变量也实现Serializable接口，如果没有实现该接口，抛出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class VariableTest implements Serializable&#123;</div><div class=\"line\">\tVariable variable ;</div><div class=\"line\">\tpublic VariableTest() &#123;</div><div class=\"line\">\t\tvariable = new Variable();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t    System.out.println(&quot;构造对象*************&quot;);</div><div class=\"line\">\t\t    VariableTest variableTest = new VariableTest();</div><div class=\"line\">\t\t    System.out.println(&quot;序列化**************&quot;);</div><div class=\"line\">\t\t    SeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\t    //抛出异常：java.io.NotSerializableException</div><div class=\"line\">\t\t    util.seria(variableTest);</div><div class=\"line\">\t\t    System.out.println(&quot;反序列化****************&quot;);</div><div class=\"line\">\t\t    VariableTest obj = (VariableTest) util.reSeria();</div><div class=\"line\">\t\t    System.out.println(obj.variable.a);//抛出异常：Exception in thread &quot;main&quot; java.io.NotSerializableException: space.kyu.Variable</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class Variable &#123;</div><div class=\"line\">\tpublic String a;</div><div class=\"line\">\tpublic Variable()&#123;</div><div class=\"line\">\t\ta = &quot;hehe&quot;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"单例模式下的序列化\"><a href=\"#单例模式下的序列化\" class=\"headerlink\" title=\"单例模式下的序列化\"></a>单例模式下的序列化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SingleTest implements Serializable&#123;</div><div class=\"line\">\tpublic static SingleTest instance = new SingleTest();</div><div class=\"line\">\tprivate SingleTest()&#123;&#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\tSingleTest test = SingleTest.instance;</div><div class=\"line\">\t\tSeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\tutil.seria(test);</div><div class=\"line\">\t\tSingleTest reSeria = (SingleTest) util.reSeria();</div><div class=\"line\">\t\tSystem.out.println(reSeria == SingleTest.instance);//false</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由上面的代码可以看出，有两个SingleTest实例同时存在，通过反序列化破坏了单例模式。反序列化时会开辟新的内存空间重新实例化对象，所以单例模式被破坏。</p>\n<p>为了解决这种问题，可以实现readResolve()方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SingleTest implements Serializable&#123;</div><div class=\"line\">\tpublic static SingleTest instance = new SingleTest();</div><div class=\"line\">\tprivate SingleTest()&#123;&#125;</div><div class=\"line\">\tprivate Object readResolve() &#123;</div><div class=\"line\">        return SingleTest.instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\tSingleTest test = SingleTest.instance;</div><div class=\"line\">\t\tSeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\tutil.seria(test);</div><div class=\"line\">\t\tSingleTest reSeria = (SingleTest) util.reSeria();</div><div class=\"line\">\t\tSystem.out.println(reSeria == SingleTest.instance);//true</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"序列化版本\"><a href=\"#序列化版本\" class=\"headerlink\" title=\"序列化版本\"></a>序列化版本</h2><p>代码是在不断的演化的。1.1版本的类可以读取1.0版本的序列化文件吗？这就涉及到序列化的版本管理。</p>\n<p>每个序列化版本都有其唯一的ID，他是数据域类型和方法签名的指纹。当类的定义产生变化时，他的指纹也会跟着产生变化，对象流将拒绝读入具有不同指纹的对象。<br>如果想保持早期版本的兼容，首先要获取这个类早期版本的指纹。</p>\n<p>我们可以使用 jdk自带的工具 serialver 获得这个指纹：serialver Test<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">staic final long serialVersionUID = -1423859403827594712L</div></pre></td></tr></table></figure></p>\n<p>然后将1.1版本中Test类的serialVersionUID常量定义为上面的值，即可序列化老版本的代码。</p>\n<p>如果一个类具有名为serialVersionUID的常量，那么java就不会再主动计算这个值，而是直接将其作为这个版本类的指纹。没有特殊要求的话，一般都显示的声明serialVersionUID：<code>private static final long serialVersionUID = 1L;</code>来保证兼容性</p>\n<p>如果对象流中的对象具有在当前版本中没有的数据域，那么对象流会忽略这些数据；如果当前版本具有对象流中所没有的数据域，那么这些新加的域将被设为默认值。</p>\n<h2 id=\"序列化与克隆\"><a href=\"#序列化与克隆\" class=\"headerlink\" title=\"序列化与克隆\"></a>序列化与克隆</h2><p>反序列化重新构建对象的机制提供了一种克隆对象的简便途径，只要对应的类可序列化即可。</p>\n<p>做法很简单：直接将对象序列化到输出流当中，然后将其读回。这样产生的对象是对现有对象的一个深拷贝。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CloneTest implements Serializable, Cloneable &#123;</div><div class=\"line\">\tpublic String str;</div><div class=\"line\">\tpublic CloneTest(String str) &#123;</div><div class=\"line\">\t\tthis.str =str;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tprotected Object clone() throws CloneNotSupportedException &#123;</div><div class=\"line\">\t\tSeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tutil.seria(this);</div><div class=\"line\">\t\t\tCloneTest reSeria = (CloneTest) util.reSeria();</div><div class=\"line\">\t\t\treturn reSeria;</div><div class=\"line\">\t\t&#125; catch (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\treturn null;</div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws CloneNotSupportedException &#123;</div><div class=\"line\">\t\tCloneTest test = new CloneTest(&quot;hi&quot;);</div><div class=\"line\">\t\tCloneTest clone = (CloneTest) test.clone();</div><div class=\"line\">\t\tSystem.out.println(clone.str);//hi</div><div class=\"line\">\t\tSystem.out.println(clone == test);//false</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样克隆对象的优点是简单，缺点是比普通的克隆实现要慢的多。</p>\n"},{"layout":"post","title":"java异常的学习","date":"2016-12-13T13:46:52.000Z","_content":"\n>最近的写代码的过程中，遇到很多异常的处理，以前上大学的时候写代码，遇到异常直接给个try catch了事，只是停留在看懂异常能够找出异常抛出点的水平。真正写代码的时候，不了解java的异常机制给自己编程带来很多不便，基础知识很重要！学习之～～\n\n## 异常分类\n\n{% asset_img java.png java异常体系 %}\n\njava异常中的异常大体上可分为两类：Error 与 Exception，他们都继承自Throwable\n\n### Error：\n\nError表示一些无法恢复的错误，会导致应用程序中断。比如我们喜闻乐见的OutOfMemoryError(内存溢出)， StackOverflowError(堆栈溢出)等，就是一种Error类型的异常。面对这种类型的异常在我们的应用程序中一般是无法挽救的，将直接导致程序错误退出。因此我们在代码中一般不必去特别关心这种类型的异常。\n\n[Error类型的异常及其子类](https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html)\n\n### Exception:\n\nException是一般常见的异常，我们的应用程序可以处理这些异常，比如NullPointerException、IndexOutOfBoundsException等等。发生这些异常时，可以选择通过捕获这些异常进行处理，使程序可以继续往下执行。\n\nException又可以分为CheckException(检测型异常)与UncheckException(非检测型异常)。\n\n在Exception的子类当中，非检测型异常为RuntimeException及其子类，剩下的异常则为检测型异常。\n\n#### 检测型异常\n\n所谓检测型异常，表示其接受编译器的检测，比如\n\n```\npublic void readFile(String filePath){\n        //编译无法通过\n\t\tFile file = new File(filePath);\n\t\tFileReader fileReader = new FileReader(file);//FileNotFoundException\n\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\tString line = null;\n\t\twhile ((line = bReader.readLine()) != null) {//IOException\n\t\t\tSystem.out.println(line);\n\t\t}\n}\n```\n编译上述代码，编译器会报错，编译无法通过。\n如果是用Eclipse等ide去写这段代码，ide通常就会告诉你这段代码有错误。原因是上述代码会抛出检测型异常IOException。有以下两种修复错误的方法：\n\n```\n//第一种\npublic void readFile(String filePath) throws IOException{\n\t\tFile file = new File(filePath);\n\t\tFileReader fileReader = new FileReader(file);\n\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\tString line = null;\n\t\twhile ((line = bReader.readLine()) != null) {\n\t\t\tSystem.out.println(line);\n\t\t}\n}\n//第二种\npublic void readFile(String filePath) {\n\t\tFile file = new File(filePath);\n\t\ttry {\n\t\t\tFileReader fileReader = new FileReader(file);\n\t\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\t\tString line = null;\n\t\t\twhile ((line = bReader.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t// TODO: handle exception\n\t\t}\n}\n```\n\n第一种方式通过声明throws关键字将该异常继续向上抛出，这种方式下，该方法就抛出了检测型异常，他的调用者就会遇到一样的问题，调用者可以选择使用这种方式继续向调用链上层抛出，或者采用第二种方式处理异常。\n\n第二种方式通过将抛出异常的代码使用try..catch块包裹起来，处理该异常。这种方式下他的调用者无需再次处理该异常。\n\n上面这种类型的异常就是检测型异常，我们必须显示的去处理他，代表的有SQLException、IOException等等。\n\n#### 非检测型异常\n\n与检测型异常相对的，编译阶段不会检测这种类型的异常，当代码中有这种类型的异常抛出时，我们不需要像上面那样显示的处理他，比如：\n\n```\npublic void test() {\n        //编译可以通过\n\t\tthrow new NullPointerException();\n}\n```\n通过throw关键字抛出了一个NullPointerException异常，该异常是RunTimeException的子类，是一个非检测类型的异常。这种类型的异常一般是由程序逻辑错误引起的，比如空指针或者数组越界等等。\n\n对于非检测类型的异常，我们也可以去使用try..catch捕获他，从而进行一些处理。如果我们没有捕获处理这个异常，系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，**这个线程也就退出了**。如果是主程序抛出的异常，**那么这整个程序也就退出了**。\n\nError实际上也是一种非检测型异常。\n\n## 异常处理\n\n### 关键字\n\n了解了异常的分类，我们就可以愉快的处理异常了。记得上大学的时候写的代码，由于不理解java的异常机制，每当遇到检测型异常时，ide会要求在代码中处理这种情况。于是简单的try..catch解决，并在catch块中 e.printStackTrace()，就解决了IDE的报警问题。现在想来，这种代码如果运行在生产环境中，将会多么可怕。\n\n通过上面的总结，我们已经了解了四个关键字：try catch throw throws.\n\nthrow表示将要抛出一个异常，后面跟一个Throwable的实例，throws置于函数的声明当中，表示该函数将会抛出何种类型的异常。\n\ntry catch 一般配合使用，还有一个关键字finally,也是与try catch 配合使用的。有这三种使用方式：\n\ntry..catch  try..finally try..catch..finally\n\ncatch 可以有多个，try只能有一个，finally可选。\n\nfinally用于保证一些资源的释放，因为一般情况下，finally中的语句总会在方法返回之前得到执行。\n\n### try catch finally执行顺序\n\ntry catch finally的执行顺序为 try->catch->finally。\n\n有多个catch时，按照catch块的先后顺序进行匹配，一旦一个异常与一个catch块匹配，则不会再与后面的catch块进行匹配。\n因此，如果我们使用多个catch块捕获异常时，如果多个catch块捕获的异常具有继承关系，注意把继承链中低层次(也就是子类)的放在前面，把继承链中高层次的(也就是父类)放在后面。\n这样做的目的很简单，就是尽量使异常被适合的catch所捕获，这样处理起来比较明确。\n\nfinally块中的代码一般是在try与catch内的控制转移语句执行之前执行的，用来做一些资源释放的操作。控制转移语句包括：return、throw、break 和 continue。\n\n关于finally块的详细解析，参考[关于 Java 中 finally 语句块的深度辨析](https://www.ibm.com/developerworks/cn/java/j-lo-finally/)\n\n另外有一点需要注意：不要在finally中return，因为finally中的return会覆盖已有的返回值，比如try或者catch中的返回值。比如：\n\n```\npublic class TestException {\n    public static void main(String[] args) {\n        String str = new TestException().readFile();\n        System.out.println(str);\n    }\n \n    public String readFile() {\n        try {\n            FileInputStream inputStream = new FileInputStream(\"D:/test.txt\");\n            int ch = inputStream.read();\n            return \"try\";\n        } catch (FileNotFoundException e) {\n            System.out.println(\"file not found\");\n            return \"FileNotFoundException\";\n        }catch (IOException e) {\n            System.out.println(\"io exception\");\n            return \"IOException\";\n        }finally{\n            System.out.println(\"finally block\");\n            //return \"finally\";\n        }\n    }\n}\n```\nD:/test.txt 并不存在，执行结果为:file not found    finally block   FileNotFoundException\n去掉finally中的注释，执行结果为：file not found    finally block   finally\n\n\n## 一些建议\n\n了解了异常机制的基本原理，不一定能够很好的处理异常。当我们遇到异常需要处理的时候，需要遵循几个原则，才能写出更好的代码：\n\n### 不要使用空的catch块\n\n正如前面所说，上学的时候遇到异常时，直接try..catch了事，只是简单地e.printStackTrace(),把堆栈打印出来了。这样可能对定位异常比较有帮助，但是对异常的处理却没有帮助，既没有处理异常，上层代码也无法得知异常的抛出，\n程序会继续运行，有可能出现无法预料的结果。当然，如果程序的逻辑容忍异常可以不用处理，那么可以不处理异常，简单的输出到日志记录即可。处理还需视实际情况而定。\n\n### 在能够处理异常的地方处理异常\n\n换句话说，就是在高层代码中处理异常。尽量将异常抛给上层调用者，由上层调用者统一进行处理。这样会使得程序流程比较清晰。\n\n### 日志打印\n\n只在必要的地方打印日志，如只在异常发生的地方输出日志，然后将异常抛到上层。这样比较容易定位异常，避免每次向上抛出异常时都打印日志，反复打印同一个异常会使得日志变得混乱\n\n### 检测异常与非检测异常的选择\n\n为可恢复的条件使用检查型异常，为编程错误使用运行时异常\n\n在web项目中，我们经常把代码层次分为controller，service,dao等几层。在dao层中一搬会抛出SQLException,这就使得他的调用者必须显示的捕获该异常或者继续抛出。这样提高了代码的耦合性，污染了上层代码。\n在比如接口的声明当中，我们为方法声明了一个检测型异常，那么他的所有实现类都必须作出同样的声明，即使实现类不会抛出异常。而且，所有的调用者都必须显示的捕获异常或者抛出异常，异常就会扩散开来，会使代码变得混乱。\n所以我们应该正确的选择检测型异常和非检测型异常。个人认为，检测型异常的意义就在于提醒用户进行处理，比如一些资源的释放等等。如果该异常出现的很普遍，需要提醒调用者进行处理，那么就是用检测型异常，否则，就使用非检测型异常。\n\n对于已经抛出的检测型异常，我们可以进行封装处理，比如对于第一种情况，污染上层代码的问题：\n\n```\n//处理前\npublic Data getDataById(Long id) throw SQLException {\n //根据 ID 查询数据库\n}\n\n//处理后\npublic Data getDataById(Long id) {\n     try{\n            //根据 ID 查询数据库\n     }catch(SQLException e){\n            //利用非检测异常封装检测异常，降低层次耦合\n            throw new RuntimeException(SQLErrorCode, e);\n     }finally{\n            //关闭连接，清理资源\n     }\n}\n\n```\n我们将一个检测型异常封装成了非检测型异常向上抛出。\n\n### 不要使用Exception捕捉所有潜在的异常\n\n针对具体的异常进行处理，而不是使用Exception捕获所有的异常。这样不利于异常情况的处理，并且如果再次向上抛出时可能会丢书原有的异常信息。 \n\n### 抛出与抽象相适应的异常\n\n换句话说，一个方法所抛出的异常应该在一个抽象层次上定义，该抽象层次与该方法做什么相一致，而不一定与方法的底层实现细节相一致。例如，一个从文件、数据库或者 JNDI 装载资源的方法在不能找到资源时，应该抛出某种 ResourceNotFound 异常（通常使用异常链来保存隐含的原因），而不是更底层的 IOException 、 SQLException 或者 NamingException 。\n\n我们有时候在捕获一个异常后抛出另一个封装后的异常信息，并且希望将原始的异常信息也保持起来，\nthrow抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？\n在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。\n\n### 多线程中的异常\n\n在java多线程程序中，所有线程都不允许抛出未捕获的检测型异常（比如sleep时的InterruptedException),\n也就是说各个线程需要自己把自己的检测型处理掉。\n这一点是通过java.lang.Runnable.run()方法声明(因为此方法声明上没有throw exception部分)进行了约束。\n但是线程依然有可能抛出非检测型异常，当此类异常跑抛出时，线程就会终结，\n而对于主线程和其他线程完全不受影响，且完全感知不到某个线程抛出的异常(也是说完全无法catch到这个异常)。\n\n如果我们不考虑线程内可能出现的异常而导致线程的终结，那么就有可能造成意想不到的后果。如果是使用线程池的话，就有可能导致线程泄漏，这样的错误可能难以察觉，\n最终导致程序挂掉或者内存溢出等等意想不到的问题，但是往往不好追踪问题出现的原因。\n[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章很好的展示了一个多线程发生异常后产生的一系列后果。\n\n对于线程可以自己处理的异常，比较好解决。我们可以在线程内部捕获异常，作一些处理，防止线程退出。比如，[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章中的一个示例：\n\n```\nprivate class SaferPoolWorker extends Thread {\n    public void run() {\n        IncomingResponse ir;\n        while (true) {\n            ir = (IncomingResponse) queue.getNext();\n            PlugIn plugIn = findPlugIn(ir.getResponseId());\n            if (plugIn != null) {\n        try {\n                    plugIn.handleMessage(ir.getResponse());\n                }\n                catch (RuntimeException e) {\n                    // Take some sort of action; \n                    // - log the exception and move on\n                    // - log the exception and restart the worker thread\n                    // - log the exception and unload the offending plug-in\n                }\n            }\n            else\n                log(\"Unknown plug-in for response \" + ir.getResponseId());\n        }\n    }\n}\n```\n但是，当子线程发生异常时，我们需要父线程或者主线程可以感知子线程的异常，也就是得到子线程产生的异常，然后做一些处理。[Java线程池异常处理最佳实践](http://blog.onlycatch.com/post/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)这篇文章给出了很好的总结，\n摘抄其总结如下：\n```\n处理线程池中的异常有两种思路： \n1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池 \n2）由线程池统一处理\n对于execute方法提交的线程，有两种处理方式 \n1）自定义线程池并实现afterExecute方法 \n2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。\n对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。\n```\n\n## 其他\n\n还发现了一个比较有趣的异常处理情况，虽然可能很少碰到，但是碰到了可以参考作者的思路。\n\n[技巧：当不能抛出异常时](https://www.ibm.com/developerworks/cn/java/j-ce/)这篇文章介绍了一种不是很常见的情况：即不能处理，也不能抛出异常(包括非检测型异常)时怎么办？\n\n## 参考\n\n[Java 异常处理的误区和经验总结](http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/)\n\n[Java异常处理和设计](http://www.importnew.com/18994.html)\n\n[Java 理论与实践: 关于异常的争论](https://www.ibm.com/developerworks/cn/java/j-jtp05254/)\n\n","source":"_posts/java异常的学习.md","raw":"---\nlayout: post\ntitle: java异常的学习\ndate: 2016-12-13 21:46:52\ntags: java\n---\n\n>最近的写代码的过程中，遇到很多异常的处理，以前上大学的时候写代码，遇到异常直接给个try catch了事，只是停留在看懂异常能够找出异常抛出点的水平。真正写代码的时候，不了解java的异常机制给自己编程带来很多不便，基础知识很重要！学习之～～\n\n## 异常分类\n\n{% asset_img java.png java异常体系 %}\n\njava异常中的异常大体上可分为两类：Error 与 Exception，他们都继承自Throwable\n\n### Error：\n\nError表示一些无法恢复的错误，会导致应用程序中断。比如我们喜闻乐见的OutOfMemoryError(内存溢出)， StackOverflowError(堆栈溢出)等，就是一种Error类型的异常。面对这种类型的异常在我们的应用程序中一般是无法挽救的，将直接导致程序错误退出。因此我们在代码中一般不必去特别关心这种类型的异常。\n\n[Error类型的异常及其子类](https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html)\n\n### Exception:\n\nException是一般常见的异常，我们的应用程序可以处理这些异常，比如NullPointerException、IndexOutOfBoundsException等等。发生这些异常时，可以选择通过捕获这些异常进行处理，使程序可以继续往下执行。\n\nException又可以分为CheckException(检测型异常)与UncheckException(非检测型异常)。\n\n在Exception的子类当中，非检测型异常为RuntimeException及其子类，剩下的异常则为检测型异常。\n\n#### 检测型异常\n\n所谓检测型异常，表示其接受编译器的检测，比如\n\n```\npublic void readFile(String filePath){\n        //编译无法通过\n\t\tFile file = new File(filePath);\n\t\tFileReader fileReader = new FileReader(file);//FileNotFoundException\n\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\tString line = null;\n\t\twhile ((line = bReader.readLine()) != null) {//IOException\n\t\t\tSystem.out.println(line);\n\t\t}\n}\n```\n编译上述代码，编译器会报错，编译无法通过。\n如果是用Eclipse等ide去写这段代码，ide通常就会告诉你这段代码有错误。原因是上述代码会抛出检测型异常IOException。有以下两种修复错误的方法：\n\n```\n//第一种\npublic void readFile(String filePath) throws IOException{\n\t\tFile file = new File(filePath);\n\t\tFileReader fileReader = new FileReader(file);\n\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\tString line = null;\n\t\twhile ((line = bReader.readLine()) != null) {\n\t\t\tSystem.out.println(line);\n\t\t}\n}\n//第二种\npublic void readFile(String filePath) {\n\t\tFile file = new File(filePath);\n\t\ttry {\n\t\t\tFileReader fileReader = new FileReader(file);\n\t\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\t\tString line = null;\n\t\t\twhile ((line = bReader.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t// TODO: handle exception\n\t\t}\n}\n```\n\n第一种方式通过声明throws关键字将该异常继续向上抛出，这种方式下，该方法就抛出了检测型异常，他的调用者就会遇到一样的问题，调用者可以选择使用这种方式继续向调用链上层抛出，或者采用第二种方式处理异常。\n\n第二种方式通过将抛出异常的代码使用try..catch块包裹起来，处理该异常。这种方式下他的调用者无需再次处理该异常。\n\n上面这种类型的异常就是检测型异常，我们必须显示的去处理他，代表的有SQLException、IOException等等。\n\n#### 非检测型异常\n\n与检测型异常相对的，编译阶段不会检测这种类型的异常，当代码中有这种类型的异常抛出时，我们不需要像上面那样显示的处理他，比如：\n\n```\npublic void test() {\n        //编译可以通过\n\t\tthrow new NullPointerException();\n}\n```\n通过throw关键字抛出了一个NullPointerException异常，该异常是RunTimeException的子类，是一个非检测类型的异常。这种类型的异常一般是由程序逻辑错误引起的，比如空指针或者数组越界等等。\n\n对于非检测类型的异常，我们也可以去使用try..catch捕获他，从而进行一些处理。如果我们没有捕获处理这个异常，系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，**这个线程也就退出了**。如果是主程序抛出的异常，**那么这整个程序也就退出了**。\n\nError实际上也是一种非检测型异常。\n\n## 异常处理\n\n### 关键字\n\n了解了异常的分类，我们就可以愉快的处理异常了。记得上大学的时候写的代码，由于不理解java的异常机制，每当遇到检测型异常时，ide会要求在代码中处理这种情况。于是简单的try..catch解决，并在catch块中 e.printStackTrace()，就解决了IDE的报警问题。现在想来，这种代码如果运行在生产环境中，将会多么可怕。\n\n通过上面的总结，我们已经了解了四个关键字：try catch throw throws.\n\nthrow表示将要抛出一个异常，后面跟一个Throwable的实例，throws置于函数的声明当中，表示该函数将会抛出何种类型的异常。\n\ntry catch 一般配合使用，还有一个关键字finally,也是与try catch 配合使用的。有这三种使用方式：\n\ntry..catch  try..finally try..catch..finally\n\ncatch 可以有多个，try只能有一个，finally可选。\n\nfinally用于保证一些资源的释放，因为一般情况下，finally中的语句总会在方法返回之前得到执行。\n\n### try catch finally执行顺序\n\ntry catch finally的执行顺序为 try->catch->finally。\n\n有多个catch时，按照catch块的先后顺序进行匹配，一旦一个异常与一个catch块匹配，则不会再与后面的catch块进行匹配。\n因此，如果我们使用多个catch块捕获异常时，如果多个catch块捕获的异常具有继承关系，注意把继承链中低层次(也就是子类)的放在前面，把继承链中高层次的(也就是父类)放在后面。\n这样做的目的很简单，就是尽量使异常被适合的catch所捕获，这样处理起来比较明确。\n\nfinally块中的代码一般是在try与catch内的控制转移语句执行之前执行的，用来做一些资源释放的操作。控制转移语句包括：return、throw、break 和 continue。\n\n关于finally块的详细解析，参考[关于 Java 中 finally 语句块的深度辨析](https://www.ibm.com/developerworks/cn/java/j-lo-finally/)\n\n另外有一点需要注意：不要在finally中return，因为finally中的return会覆盖已有的返回值，比如try或者catch中的返回值。比如：\n\n```\npublic class TestException {\n    public static void main(String[] args) {\n        String str = new TestException().readFile();\n        System.out.println(str);\n    }\n \n    public String readFile() {\n        try {\n            FileInputStream inputStream = new FileInputStream(\"D:/test.txt\");\n            int ch = inputStream.read();\n            return \"try\";\n        } catch (FileNotFoundException e) {\n            System.out.println(\"file not found\");\n            return \"FileNotFoundException\";\n        }catch (IOException e) {\n            System.out.println(\"io exception\");\n            return \"IOException\";\n        }finally{\n            System.out.println(\"finally block\");\n            //return \"finally\";\n        }\n    }\n}\n```\nD:/test.txt 并不存在，执行结果为:file not found    finally block   FileNotFoundException\n去掉finally中的注释，执行结果为：file not found    finally block   finally\n\n\n## 一些建议\n\n了解了异常机制的基本原理，不一定能够很好的处理异常。当我们遇到异常需要处理的时候，需要遵循几个原则，才能写出更好的代码：\n\n### 不要使用空的catch块\n\n正如前面所说，上学的时候遇到异常时，直接try..catch了事，只是简单地e.printStackTrace(),把堆栈打印出来了。这样可能对定位异常比较有帮助，但是对异常的处理却没有帮助，既没有处理异常，上层代码也无法得知异常的抛出，\n程序会继续运行，有可能出现无法预料的结果。当然，如果程序的逻辑容忍异常可以不用处理，那么可以不处理异常，简单的输出到日志记录即可。处理还需视实际情况而定。\n\n### 在能够处理异常的地方处理异常\n\n换句话说，就是在高层代码中处理异常。尽量将异常抛给上层调用者，由上层调用者统一进行处理。这样会使得程序流程比较清晰。\n\n### 日志打印\n\n只在必要的地方打印日志，如只在异常发生的地方输出日志，然后将异常抛到上层。这样比较容易定位异常，避免每次向上抛出异常时都打印日志，反复打印同一个异常会使得日志变得混乱\n\n### 检测异常与非检测异常的选择\n\n为可恢复的条件使用检查型异常，为编程错误使用运行时异常\n\n在web项目中，我们经常把代码层次分为controller，service,dao等几层。在dao层中一搬会抛出SQLException,这就使得他的调用者必须显示的捕获该异常或者继续抛出。这样提高了代码的耦合性，污染了上层代码。\n在比如接口的声明当中，我们为方法声明了一个检测型异常，那么他的所有实现类都必须作出同样的声明，即使实现类不会抛出异常。而且，所有的调用者都必须显示的捕获异常或者抛出异常，异常就会扩散开来，会使代码变得混乱。\n所以我们应该正确的选择检测型异常和非检测型异常。个人认为，检测型异常的意义就在于提醒用户进行处理，比如一些资源的释放等等。如果该异常出现的很普遍，需要提醒调用者进行处理，那么就是用检测型异常，否则，就使用非检测型异常。\n\n对于已经抛出的检测型异常，我们可以进行封装处理，比如对于第一种情况，污染上层代码的问题：\n\n```\n//处理前\npublic Data getDataById(Long id) throw SQLException {\n //根据 ID 查询数据库\n}\n\n//处理后\npublic Data getDataById(Long id) {\n     try{\n            //根据 ID 查询数据库\n     }catch(SQLException e){\n            //利用非检测异常封装检测异常，降低层次耦合\n            throw new RuntimeException(SQLErrorCode, e);\n     }finally{\n            //关闭连接，清理资源\n     }\n}\n\n```\n我们将一个检测型异常封装成了非检测型异常向上抛出。\n\n### 不要使用Exception捕捉所有潜在的异常\n\n针对具体的异常进行处理，而不是使用Exception捕获所有的异常。这样不利于异常情况的处理，并且如果再次向上抛出时可能会丢书原有的异常信息。 \n\n### 抛出与抽象相适应的异常\n\n换句话说，一个方法所抛出的异常应该在一个抽象层次上定义，该抽象层次与该方法做什么相一致，而不一定与方法的底层实现细节相一致。例如，一个从文件、数据库或者 JNDI 装载资源的方法在不能找到资源时，应该抛出某种 ResourceNotFound 异常（通常使用异常链来保存隐含的原因），而不是更底层的 IOException 、 SQLException 或者 NamingException 。\n\n我们有时候在捕获一个异常后抛出另一个封装后的异常信息，并且希望将原始的异常信息也保持起来，\nthrow抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？\n在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。\n\n### 多线程中的异常\n\n在java多线程程序中，所有线程都不允许抛出未捕获的检测型异常（比如sleep时的InterruptedException),\n也就是说各个线程需要自己把自己的检测型处理掉。\n这一点是通过java.lang.Runnable.run()方法声明(因为此方法声明上没有throw exception部分)进行了约束。\n但是线程依然有可能抛出非检测型异常，当此类异常跑抛出时，线程就会终结，\n而对于主线程和其他线程完全不受影响，且完全感知不到某个线程抛出的异常(也是说完全无法catch到这个异常)。\n\n如果我们不考虑线程内可能出现的异常而导致线程的终结，那么就有可能造成意想不到的后果。如果是使用线程池的话，就有可能导致线程泄漏，这样的错误可能难以察觉，\n最终导致程序挂掉或者内存溢出等等意想不到的问题，但是往往不好追踪问题出现的原因。\n[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章很好的展示了一个多线程发生异常后产生的一系列后果。\n\n对于线程可以自己处理的异常，比较好解决。我们可以在线程内部捕获异常，作一些处理，防止线程退出。比如，[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章中的一个示例：\n\n```\nprivate class SaferPoolWorker extends Thread {\n    public void run() {\n        IncomingResponse ir;\n        while (true) {\n            ir = (IncomingResponse) queue.getNext();\n            PlugIn plugIn = findPlugIn(ir.getResponseId());\n            if (plugIn != null) {\n        try {\n                    plugIn.handleMessage(ir.getResponse());\n                }\n                catch (RuntimeException e) {\n                    // Take some sort of action; \n                    // - log the exception and move on\n                    // - log the exception and restart the worker thread\n                    // - log the exception and unload the offending plug-in\n                }\n            }\n            else\n                log(\"Unknown plug-in for response \" + ir.getResponseId());\n        }\n    }\n}\n```\n但是，当子线程发生异常时，我们需要父线程或者主线程可以感知子线程的异常，也就是得到子线程产生的异常，然后做一些处理。[Java线程池异常处理最佳实践](http://blog.onlycatch.com/post/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)这篇文章给出了很好的总结，\n摘抄其总结如下：\n```\n处理线程池中的异常有两种思路： \n1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池 \n2）由线程池统一处理\n对于execute方法提交的线程，有两种处理方式 \n1）自定义线程池并实现afterExecute方法 \n2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。\n对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。\n```\n\n## 其他\n\n还发现了一个比较有趣的异常处理情况，虽然可能很少碰到，但是碰到了可以参考作者的思路。\n\n[技巧：当不能抛出异常时](https://www.ibm.com/developerworks/cn/java/j-ce/)这篇文章介绍了一种不是很常见的情况：即不能处理，也不能抛出异常(包括非检测型异常)时怎么办？\n\n## 参考\n\n[Java 异常处理的误区和经验总结](http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/)\n\n[Java异常处理和设计](http://www.importnew.com/18994.html)\n\n[Java 理论与实践: 关于异常的争论](https://www.ibm.com/developerworks/cn/java/j-jtp05254/)\n\n","slug":"java异常的学习","published":1,"updated":"2017-02-19T13:08:11.034Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlrk001vvegc54kc1ps7","content":"<blockquote>\n<p>最近的写代码的过程中，遇到很多异常的处理，以前上大学的时候写代码，遇到异常直接给个try catch了事，只是停留在看懂异常能够找出异常抛出点的水平。真正写代码的时候，不了解java的异常机制给自己编程带来很多不便，基础知识很重要！学习之～～</p>\n</blockquote>\n<h2 id=\"异常分类\"><a href=\"#异常分类\" class=\"headerlink\" title=\"异常分类\"></a>异常分类</h2><img src=\"/2016/12/13/java异常的学习/java.png\" alt=\"java异常体系\" title=\"java异常体系\">\n<p>java异常中的异常大体上可分为两类：Error 与 Exception，他们都继承自Throwable</p>\n<h3 id=\"Error：\"><a href=\"#Error：\" class=\"headerlink\" title=\"Error：\"></a>Error：</h3><p>Error表示一些无法恢复的错误，会导致应用程序中断。比如我们喜闻乐见的OutOfMemoryError(内存溢出)， StackOverflowError(堆栈溢出)等，就是一种Error类型的异常。面对这种类型的异常在我们的应用程序中一般是无法挽救的，将直接导致程序错误退出。因此我们在代码中一般不必去特别关心这种类型的异常。</p>\n<p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html\" target=\"_blank\" rel=\"external\">Error类型的异常及其子类</a></p>\n<h3 id=\"Exception\"><a href=\"#Exception\" class=\"headerlink\" title=\"Exception:\"></a>Exception:</h3><p>Exception是一般常见的异常，我们的应用程序可以处理这些异常，比如NullPointerException、IndexOutOfBoundsException等等。发生这些异常时，可以选择通过捕获这些异常进行处理，使程序可以继续往下执行。</p>\n<p>Exception又可以分为CheckException(检测型异常)与UncheckException(非检测型异常)。</p>\n<p>在Exception的子类当中，非检测型异常为RuntimeException及其子类，剩下的异常则为检测型异常。</p>\n<h4 id=\"检测型异常\"><a href=\"#检测型异常\" class=\"headerlink\" title=\"检测型异常\"></a>检测型异常</h4><p>所谓检测型异常，表示其接受编译器的检测，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void readFile(String filePath)&#123;</div><div class=\"line\">        //编译无法通过</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\tFileReader fileReader = new FileReader(file);//FileNotFoundException</div><div class=\"line\">\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\tString line = null;</div><div class=\"line\">\t\twhile ((line = bReader.readLine()) != null) &#123;//IOException</div><div class=\"line\">\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>编译上述代码，编译器会报错，编译无法通过。<br>如果是用Eclipse等ide去写这段代码，ide通常就会告诉你这段代码有错误。原因是上述代码会抛出检测型异常IOException。有以下两种修复错误的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//第一种</div><div class=\"line\">public void readFile(String filePath) throws IOException&#123;</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\tFileReader fileReader = new FileReader(file);</div><div class=\"line\">\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\tString line = null;</div><div class=\"line\">\t\twhile ((line = bReader.readLine()) != null) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//第二种</div><div class=\"line\">public void readFile(String filePath) &#123;</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tFileReader fileReader = new FileReader(file);</div><div class=\"line\">\t\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\t\tString line = null;</div><div class=\"line\">\t\t\twhile ((line = bReader.readLine()) != null) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; catch (IOException e) &#123;</div><div class=\"line\">\t\t\t// TODO: handle exception</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一种方式通过声明throws关键字将该异常继续向上抛出，这种方式下，该方法就抛出了检测型异常，他的调用者就会遇到一样的问题，调用者可以选择使用这种方式继续向调用链上层抛出，或者采用第二种方式处理异常。</p>\n<p>第二种方式通过将抛出异常的代码使用try..catch块包裹起来，处理该异常。这种方式下他的调用者无需再次处理该异常。</p>\n<p>上面这种类型的异常就是检测型异常，我们必须显示的去处理他，代表的有SQLException、IOException等等。</p>\n<h4 id=\"非检测型异常\"><a href=\"#非检测型异常\" class=\"headerlink\" title=\"非检测型异常\"></a>非检测型异常</h4><p>与检测型异常相对的，编译阶段不会检测这种类型的异常，当代码中有这种类型的异常抛出时，我们不需要像上面那样显示的处理他，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void test() &#123;</div><div class=\"line\">        //编译可以通过</div><div class=\"line\">\t\tthrow new NullPointerException();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过throw关键字抛出了一个NullPointerException异常，该异常是RunTimeException的子类，是一个非检测类型的异常。这种类型的异常一般是由程序逻辑错误引起的，比如空指针或者数组越界等等。</p>\n<p>对于非检测类型的异常，我们也可以去使用try..catch捕获他，从而进行一些处理。如果我们没有捕获处理这个异常，系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，<strong>这个线程也就退出了</strong>。如果是主程序抛出的异常，<strong>那么这整个程序也就退出了</strong>。</p>\n<p>Error实际上也是一种非检测型异常。</p>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><p>了解了异常的分类，我们就可以愉快的处理异常了。记得上大学的时候写的代码，由于不理解java的异常机制，每当遇到检测型异常时，ide会要求在代码中处理这种情况。于是简单的try..catch解决，并在catch块中 e.printStackTrace()，就解决了IDE的报警问题。现在想来，这种代码如果运行在生产环境中，将会多么可怕。</p>\n<p>通过上面的总结，我们已经了解了四个关键字：try catch throw throws.</p>\n<p>throw表示将要抛出一个异常，后面跟一个Throwable的实例，throws置于函数的声明当中，表示该函数将会抛出何种类型的异常。</p>\n<p>try catch 一般配合使用，还有一个关键字finally,也是与try catch 配合使用的。有这三种使用方式：</p>\n<p>try..catch  try..finally try..catch..finally</p>\n<p>catch 可以有多个，try只能有一个，finally可选。</p>\n<p>finally用于保证一些资源的释放，因为一般情况下，finally中的语句总会在方法返回之前得到执行。</p>\n<h3 id=\"try-catch-finally执行顺序\"><a href=\"#try-catch-finally执行顺序\" class=\"headerlink\" title=\"try catch finally执行顺序\"></a>try catch finally执行顺序</h3><p>try catch finally的执行顺序为 try-&gt;catch-&gt;finally。</p>\n<p>有多个catch时，按照catch块的先后顺序进行匹配，一旦一个异常与一个catch块匹配，则不会再与后面的catch块进行匹配。<br>因此，如果我们使用多个catch块捕获异常时，如果多个catch块捕获的异常具有继承关系，注意把继承链中低层次(也就是子类)的放在前面，把继承链中高层次的(也就是父类)放在后面。<br>这样做的目的很简单，就是尽量使异常被适合的catch所捕获，这样处理起来比较明确。</p>\n<p>finally块中的代码一般是在try与catch内的控制转移语句执行之前执行的，用来做一些资源释放的操作。控制转移语句包括：return、throw、break 和 continue。</p>\n<p>关于finally块的详细解析，参考<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-finally/\" target=\"_blank\" rel=\"external\">关于 Java 中 finally 语句块的深度辨析</a></p>\n<p>另外有一点需要注意：不要在finally中return，因为finally中的return会覆盖已有的返回值，比如try或者catch中的返回值。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TestException &#123;</div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        String str = new TestException().readFile();</div><div class=\"line\">        System.out.println(str);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    public String readFile() &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            FileInputStream inputStream = new FileInputStream(&quot;D:/test.txt&quot;);</div><div class=\"line\">            int ch = inputStream.read();</div><div class=\"line\">            return &quot;try&quot;;</div><div class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</div><div class=\"line\">            System.out.println(&quot;file not found&quot;);</div><div class=\"line\">            return &quot;FileNotFoundException&quot;;</div><div class=\"line\">        &#125;catch (IOException e) &#123;</div><div class=\"line\">            System.out.println(&quot;io exception&quot;);</div><div class=\"line\">            return &quot;IOException&quot;;</div><div class=\"line\">        &#125;finally&#123;</div><div class=\"line\">            System.out.println(&quot;finally block&quot;);</div><div class=\"line\">            //return &quot;finally&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>D:/test.txt 并不存在，执行结果为:file not found    finally block   FileNotFoundException<br>去掉finally中的注释，执行结果为：file not found    finally block   finally</p>\n<h2 id=\"一些建议\"><a href=\"#一些建议\" class=\"headerlink\" title=\"一些建议\"></a>一些建议</h2><p>了解了异常机制的基本原理，不一定能够很好的处理异常。当我们遇到异常需要处理的时候，需要遵循几个原则，才能写出更好的代码：</p>\n<h3 id=\"不要使用空的catch块\"><a href=\"#不要使用空的catch块\" class=\"headerlink\" title=\"不要使用空的catch块\"></a>不要使用空的catch块</h3><p>正如前面所说，上学的时候遇到异常时，直接try..catch了事，只是简单地e.printStackTrace(),把堆栈打印出来了。这样可能对定位异常比较有帮助，但是对异常的处理却没有帮助，既没有处理异常，上层代码也无法得知异常的抛出，<br>程序会继续运行，有可能出现无法预料的结果。当然，如果程序的逻辑容忍异常可以不用处理，那么可以不处理异常，简单的输出到日志记录即可。处理还需视实际情况而定。</p>\n<h3 id=\"在能够处理异常的地方处理异常\"><a href=\"#在能够处理异常的地方处理异常\" class=\"headerlink\" title=\"在能够处理异常的地方处理异常\"></a>在能够处理异常的地方处理异常</h3><p>换句话说，就是在高层代码中处理异常。尽量将异常抛给上层调用者，由上层调用者统一进行处理。这样会使得程序流程比较清晰。</p>\n<h3 id=\"日志打印\"><a href=\"#日志打印\" class=\"headerlink\" title=\"日志打印\"></a>日志打印</h3><p>只在必要的地方打印日志，如只在异常发生的地方输出日志，然后将异常抛到上层。这样比较容易定位异常，避免每次向上抛出异常时都打印日志，反复打印同一个异常会使得日志变得混乱</p>\n<h3 id=\"检测异常与非检测异常的选择\"><a href=\"#检测异常与非检测异常的选择\" class=\"headerlink\" title=\"检测异常与非检测异常的选择\"></a>检测异常与非检测异常的选择</h3><p>为可恢复的条件使用检查型异常，为编程错误使用运行时异常</p>\n<p>在web项目中，我们经常把代码层次分为controller，service,dao等几层。在dao层中一搬会抛出SQLException,这就使得他的调用者必须显示的捕获该异常或者继续抛出。这样提高了代码的耦合性，污染了上层代码。<br>在比如接口的声明当中，我们为方法声明了一个检测型异常，那么他的所有实现类都必须作出同样的声明，即使实现类不会抛出异常。而且，所有的调用者都必须显示的捕获异常或者抛出异常，异常就会扩散开来，会使代码变得混乱。<br>所以我们应该正确的选择检测型异常和非检测型异常。个人认为，检测型异常的意义就在于提醒用户进行处理，比如一些资源的释放等等。如果该异常出现的很普遍，需要提醒调用者进行处理，那么就是用检测型异常，否则，就使用非检测型异常。</p>\n<p>对于已经抛出的检测型异常，我们可以进行封装处理，比如对于第一种情况，污染上层代码的问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//处理前</div><div class=\"line\">public Data getDataById(Long id) throw SQLException &#123;</div><div class=\"line\"> //根据 ID 查询数据库</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//处理后</div><div class=\"line\">public Data getDataById(Long id) &#123;</div><div class=\"line\">     try&#123;</div><div class=\"line\">            //根据 ID 查询数据库</div><div class=\"line\">     &#125;catch(SQLException e)&#123;</div><div class=\"line\">            //利用非检测异常封装检测异常，降低层次耦合</div><div class=\"line\">            throw new RuntimeException(SQLErrorCode, e);</div><div class=\"line\">     &#125;finally&#123;</div><div class=\"line\">            //关闭连接，清理资源</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们将一个检测型异常封装成了非检测型异常向上抛出。</p>\n<h3 id=\"不要使用Exception捕捉所有潜在的异常\"><a href=\"#不要使用Exception捕捉所有潜在的异常\" class=\"headerlink\" title=\"不要使用Exception捕捉所有潜在的异常\"></a>不要使用Exception捕捉所有潜在的异常</h3><p>针对具体的异常进行处理，而不是使用Exception捕获所有的异常。这样不利于异常情况的处理，并且如果再次向上抛出时可能会丢书原有的异常信息。 </p>\n<h3 id=\"抛出与抽象相适应的异常\"><a href=\"#抛出与抽象相适应的异常\" class=\"headerlink\" title=\"抛出与抽象相适应的异常\"></a>抛出与抽象相适应的异常</h3><p>换句话说，一个方法所抛出的异常应该在一个抽象层次上定义，该抽象层次与该方法做什么相一致，而不一定与方法的底层实现细节相一致。例如，一个从文件、数据库或者 JNDI 装载资源的方法在不能找到资源时，应该抛出某种 ResourceNotFound 异常（通常使用异常链来保存隐含的原因），而不是更底层的 IOException 、 SQLException 或者 NamingException 。</p>\n<p>我们有时候在捕获一个异常后抛出另一个封装后的异常信息，并且希望将原始的异常信息也保持起来，<br>throw抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？<br>在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。</p>\n<h3 id=\"多线程中的异常\"><a href=\"#多线程中的异常\" class=\"headerlink\" title=\"多线程中的异常\"></a>多线程中的异常</h3><p>在java多线程程序中，所有线程都不允许抛出未捕获的检测型异常（比如sleep时的InterruptedException),<br>也就是说各个线程需要自己把自己的检测型处理掉。<br>这一点是通过java.lang.Runnable.run()方法声明(因为此方法声明上没有throw exception部分)进行了约束。<br>但是线程依然有可能抛出非检测型异常，当此类异常跑抛出时，线程就会终结，<br>而对于主线程和其他线程完全不受影响，且完全感知不到某个线程抛出的异常(也是说完全无法catch到这个异常)。</p>\n<p>如果我们不考虑线程内可能出现的异常而导致线程的终结，那么就有可能造成意想不到的后果。如果是使用线程池的话，就有可能导致线程泄漏，这样的错误可能难以察觉，<br>最终导致程序挂掉或者内存溢出等等意想不到的问题，但是往往不好追踪问题出现的原因。<br><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\" target=\"_blank\" rel=\"external\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章很好的展示了一个多线程发生异常后产生的一系列后果。</p>\n<p>对于线程可以自己处理的异常，比较好解决。我们可以在线程内部捕获异常，作一些处理，防止线程退出。比如，<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\" target=\"_blank\" rel=\"external\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章中的一个示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">private class SaferPoolWorker extends Thread &#123;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        IncomingResponse ir;</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\">            ir = (IncomingResponse) queue.getNext();</div><div class=\"line\">            PlugIn plugIn = findPlugIn(ir.getResponseId());</div><div class=\"line\">            if (plugIn != null) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">                    plugIn.handleMessage(ir.getResponse());</div><div class=\"line\">                &#125;</div><div class=\"line\">                catch (RuntimeException e) &#123;</div><div class=\"line\">                    // Take some sort of action; </div><div class=\"line\">                    // - log the exception and move on</div><div class=\"line\">                    // - log the exception and restart the worker thread</div><div class=\"line\">                    // - log the exception and unload the offending plug-in</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            else</div><div class=\"line\">                log(&quot;Unknown plug-in for response &quot; + ir.getResponseId());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是，当子线程发生异常时，我们需要父线程或者主线程可以感知子线程的异常，也就是得到子线程产生的异常，然后做一些处理。<a href=\"http://blog.onlycatch.com/post/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\" target=\"_blank\" rel=\"external\">Java线程池异常处理最佳实践</a>这篇文章给出了很好的总结，<br>摘抄其总结如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">处理线程池中的异常有两种思路： </div><div class=\"line\">1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池 </div><div class=\"line\">2）由线程池统一处理</div><div class=\"line\">对于execute方法提交的线程，有两种处理方式 </div><div class=\"line\">1）自定义线程池并实现afterExecute方法 </div><div class=\"line\">2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。</div><div class=\"line\">对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。</div></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>还发现了一个比较有趣的异常处理情况，虽然可能很少碰到，但是碰到了可以参考作者的思路。</p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-ce/\" target=\"_blank\" rel=\"external\">技巧：当不能抛出异常时</a>这篇文章介绍了一种不是很常见的情况：即不能处理，也不能抛出异常(包括非检测型异常)时怎么办？</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/\" target=\"_blank\" rel=\"external\">Java 异常处理的误区和经验总结</a></p>\n<p><a href=\"http://www.importnew.com/18994.html\" target=\"_blank\" rel=\"external\">Java异常处理和设计</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp05254/\" target=\"_blank\" rel=\"external\">Java 理论与实践: 关于异常的争论</a></p>\n","excerpt":"","more":"<blockquote>\n<p>最近的写代码的过程中，遇到很多异常的处理，以前上大学的时候写代码，遇到异常直接给个try catch了事，只是停留在看懂异常能够找出异常抛出点的水平。真正写代码的时候，不了解java的异常机制给自己编程带来很多不便，基础知识很重要！学习之～～</p>\n</blockquote>\n<h2 id=\"异常分类\"><a href=\"#异常分类\" class=\"headerlink\" title=\"异常分类\"></a>异常分类</h2><img src=\"/2016/12/13/java异常的学习/java.png\" alt=\"java异常体系\" title=\"java异常体系\">\n<p>java异常中的异常大体上可分为两类：Error 与 Exception，他们都继承自Throwable</p>\n<h3 id=\"Error：\"><a href=\"#Error：\" class=\"headerlink\" title=\"Error：\"></a>Error：</h3><p>Error表示一些无法恢复的错误，会导致应用程序中断。比如我们喜闻乐见的OutOfMemoryError(内存溢出)， StackOverflowError(堆栈溢出)等，就是一种Error类型的异常。面对这种类型的异常在我们的应用程序中一般是无法挽救的，将直接导致程序错误退出。因此我们在代码中一般不必去特别关心这种类型的异常。</p>\n<p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html\">Error类型的异常及其子类</a></p>\n<h3 id=\"Exception\"><a href=\"#Exception\" class=\"headerlink\" title=\"Exception:\"></a>Exception:</h3><p>Exception是一般常见的异常，我们的应用程序可以处理这些异常，比如NullPointerException、IndexOutOfBoundsException等等。发生这些异常时，可以选择通过捕获这些异常进行处理，使程序可以继续往下执行。</p>\n<p>Exception又可以分为CheckException(检测型异常)与UncheckException(非检测型异常)。</p>\n<p>在Exception的子类当中，非检测型异常为RuntimeException及其子类，剩下的异常则为检测型异常。</p>\n<h4 id=\"检测型异常\"><a href=\"#检测型异常\" class=\"headerlink\" title=\"检测型异常\"></a>检测型异常</h4><p>所谓检测型异常，表示其接受编译器的检测，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void readFile(String filePath)&#123;</div><div class=\"line\">        //编译无法通过</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\tFileReader fileReader = new FileReader(file);//FileNotFoundException</div><div class=\"line\">\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\tString line = null;</div><div class=\"line\">\t\twhile ((line = bReader.readLine()) != null) &#123;//IOException</div><div class=\"line\">\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>编译上述代码，编译器会报错，编译无法通过。<br>如果是用Eclipse等ide去写这段代码，ide通常就会告诉你这段代码有错误。原因是上述代码会抛出检测型异常IOException。有以下两种修复错误的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//第一种</div><div class=\"line\">public void readFile(String filePath) throws IOException&#123;</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\tFileReader fileReader = new FileReader(file);</div><div class=\"line\">\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\tString line = null;</div><div class=\"line\">\t\twhile ((line = bReader.readLine()) != null) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//第二种</div><div class=\"line\">public void readFile(String filePath) &#123;</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tFileReader fileReader = new FileReader(file);</div><div class=\"line\">\t\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\t\tString line = null;</div><div class=\"line\">\t\t\twhile ((line = bReader.readLine()) != null) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; catch (IOException e) &#123;</div><div class=\"line\">\t\t\t// TODO: handle exception</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一种方式通过声明throws关键字将该异常继续向上抛出，这种方式下，该方法就抛出了检测型异常，他的调用者就会遇到一样的问题，调用者可以选择使用这种方式继续向调用链上层抛出，或者采用第二种方式处理异常。</p>\n<p>第二种方式通过将抛出异常的代码使用try..catch块包裹起来，处理该异常。这种方式下他的调用者无需再次处理该异常。</p>\n<p>上面这种类型的异常就是检测型异常，我们必须显示的去处理他，代表的有SQLException、IOException等等。</p>\n<h4 id=\"非检测型异常\"><a href=\"#非检测型异常\" class=\"headerlink\" title=\"非检测型异常\"></a>非检测型异常</h4><p>与检测型异常相对的，编译阶段不会检测这种类型的异常，当代码中有这种类型的异常抛出时，我们不需要像上面那样显示的处理他，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void test() &#123;</div><div class=\"line\">        //编译可以通过</div><div class=\"line\">\t\tthrow new NullPointerException();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过throw关键字抛出了一个NullPointerException异常，该异常是RunTimeException的子类，是一个非检测类型的异常。这种类型的异常一般是由程序逻辑错误引起的，比如空指针或者数组越界等等。</p>\n<p>对于非检测类型的异常，我们也可以去使用try..catch捕获他，从而进行一些处理。如果我们没有捕获处理这个异常，系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，<strong>这个线程也就退出了</strong>。如果是主程序抛出的异常，<strong>那么这整个程序也就退出了</strong>。</p>\n<p>Error实际上也是一种非检测型异常。</p>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><p>了解了异常的分类，我们就可以愉快的处理异常了。记得上大学的时候写的代码，由于不理解java的异常机制，每当遇到检测型异常时，ide会要求在代码中处理这种情况。于是简单的try..catch解决，并在catch块中 e.printStackTrace()，就解决了IDE的报警问题。现在想来，这种代码如果运行在生产环境中，将会多么可怕。</p>\n<p>通过上面的总结，我们已经了解了四个关键字：try catch throw throws.</p>\n<p>throw表示将要抛出一个异常，后面跟一个Throwable的实例，throws置于函数的声明当中，表示该函数将会抛出何种类型的异常。</p>\n<p>try catch 一般配合使用，还有一个关键字finally,也是与try catch 配合使用的。有这三种使用方式：</p>\n<p>try..catch  try..finally try..catch..finally</p>\n<p>catch 可以有多个，try只能有一个，finally可选。</p>\n<p>finally用于保证一些资源的释放，因为一般情况下，finally中的语句总会在方法返回之前得到执行。</p>\n<h3 id=\"try-catch-finally执行顺序\"><a href=\"#try-catch-finally执行顺序\" class=\"headerlink\" title=\"try catch finally执行顺序\"></a>try catch finally执行顺序</h3><p>try catch finally的执行顺序为 try-&gt;catch-&gt;finally。</p>\n<p>有多个catch时，按照catch块的先后顺序进行匹配，一旦一个异常与一个catch块匹配，则不会再与后面的catch块进行匹配。<br>因此，如果我们使用多个catch块捕获异常时，如果多个catch块捕获的异常具有继承关系，注意把继承链中低层次(也就是子类)的放在前面，把继承链中高层次的(也就是父类)放在后面。<br>这样做的目的很简单，就是尽量使异常被适合的catch所捕获，这样处理起来比较明确。</p>\n<p>finally块中的代码一般是在try与catch内的控制转移语句执行之前执行的，用来做一些资源释放的操作。控制转移语句包括：return、throw、break 和 continue。</p>\n<p>关于finally块的详细解析，参考<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-finally/\">关于 Java 中 finally 语句块的深度辨析</a></p>\n<p>另外有一点需要注意：不要在finally中return，因为finally中的return会覆盖已有的返回值，比如try或者catch中的返回值。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TestException &#123;</div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        String str = new TestException().readFile();</div><div class=\"line\">        System.out.println(str);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    public String readFile() &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            FileInputStream inputStream = new FileInputStream(&quot;D:/test.txt&quot;);</div><div class=\"line\">            int ch = inputStream.read();</div><div class=\"line\">            return &quot;try&quot;;</div><div class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</div><div class=\"line\">            System.out.println(&quot;file not found&quot;);</div><div class=\"line\">            return &quot;FileNotFoundException&quot;;</div><div class=\"line\">        &#125;catch (IOException e) &#123;</div><div class=\"line\">            System.out.println(&quot;io exception&quot;);</div><div class=\"line\">            return &quot;IOException&quot;;</div><div class=\"line\">        &#125;finally&#123;</div><div class=\"line\">            System.out.println(&quot;finally block&quot;);</div><div class=\"line\">            //return &quot;finally&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>D:/test.txt 并不存在，执行结果为:file not found    finally block   FileNotFoundException<br>去掉finally中的注释，执行结果为：file not found    finally block   finally</p>\n<h2 id=\"一些建议\"><a href=\"#一些建议\" class=\"headerlink\" title=\"一些建议\"></a>一些建议</h2><p>了解了异常机制的基本原理，不一定能够很好的处理异常。当我们遇到异常需要处理的时候，需要遵循几个原则，才能写出更好的代码：</p>\n<h3 id=\"不要使用空的catch块\"><a href=\"#不要使用空的catch块\" class=\"headerlink\" title=\"不要使用空的catch块\"></a>不要使用空的catch块</h3><p>正如前面所说，上学的时候遇到异常时，直接try..catch了事，只是简单地e.printStackTrace(),把堆栈打印出来了。这样可能对定位异常比较有帮助，但是对异常的处理却没有帮助，既没有处理异常，上层代码也无法得知异常的抛出，<br>程序会继续运行，有可能出现无法预料的结果。当然，如果程序的逻辑容忍异常可以不用处理，那么可以不处理异常，简单的输出到日志记录即可。处理还需视实际情况而定。</p>\n<h3 id=\"在能够处理异常的地方处理异常\"><a href=\"#在能够处理异常的地方处理异常\" class=\"headerlink\" title=\"在能够处理异常的地方处理异常\"></a>在能够处理异常的地方处理异常</h3><p>换句话说，就是在高层代码中处理异常。尽量将异常抛给上层调用者，由上层调用者统一进行处理。这样会使得程序流程比较清晰。</p>\n<h3 id=\"日志打印\"><a href=\"#日志打印\" class=\"headerlink\" title=\"日志打印\"></a>日志打印</h3><p>只在必要的地方打印日志，如只在异常发生的地方输出日志，然后将异常抛到上层。这样比较容易定位异常，避免每次向上抛出异常时都打印日志，反复打印同一个异常会使得日志变得混乱</p>\n<h3 id=\"检测异常与非检测异常的选择\"><a href=\"#检测异常与非检测异常的选择\" class=\"headerlink\" title=\"检测异常与非检测异常的选择\"></a>检测异常与非检测异常的选择</h3><p>为可恢复的条件使用检查型异常，为编程错误使用运行时异常</p>\n<p>在web项目中，我们经常把代码层次分为controller，service,dao等几层。在dao层中一搬会抛出SQLException,这就使得他的调用者必须显示的捕获该异常或者继续抛出。这样提高了代码的耦合性，污染了上层代码。<br>在比如接口的声明当中，我们为方法声明了一个检测型异常，那么他的所有实现类都必须作出同样的声明，即使实现类不会抛出异常。而且，所有的调用者都必须显示的捕获异常或者抛出异常，异常就会扩散开来，会使代码变得混乱。<br>所以我们应该正确的选择检测型异常和非检测型异常。个人认为，检测型异常的意义就在于提醒用户进行处理，比如一些资源的释放等等。如果该异常出现的很普遍，需要提醒调用者进行处理，那么就是用检测型异常，否则，就使用非检测型异常。</p>\n<p>对于已经抛出的检测型异常，我们可以进行封装处理，比如对于第一种情况，污染上层代码的问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//处理前</div><div class=\"line\">public Data getDataById(Long id) throw SQLException &#123;</div><div class=\"line\"> //根据 ID 查询数据库</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//处理后</div><div class=\"line\">public Data getDataById(Long id) &#123;</div><div class=\"line\">     try&#123;</div><div class=\"line\">            //根据 ID 查询数据库</div><div class=\"line\">     &#125;catch(SQLException e)&#123;</div><div class=\"line\">            //利用非检测异常封装检测异常，降低层次耦合</div><div class=\"line\">            throw new RuntimeException(SQLErrorCode, e);</div><div class=\"line\">     &#125;finally&#123;</div><div class=\"line\">            //关闭连接，清理资源</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们将一个检测型异常封装成了非检测型异常向上抛出。</p>\n<h3 id=\"不要使用Exception捕捉所有潜在的异常\"><a href=\"#不要使用Exception捕捉所有潜在的异常\" class=\"headerlink\" title=\"不要使用Exception捕捉所有潜在的异常\"></a>不要使用Exception捕捉所有潜在的异常</h3><p>针对具体的异常进行处理，而不是使用Exception捕获所有的异常。这样不利于异常情况的处理，并且如果再次向上抛出时可能会丢书原有的异常信息。 </p>\n<h3 id=\"抛出与抽象相适应的异常\"><a href=\"#抛出与抽象相适应的异常\" class=\"headerlink\" title=\"抛出与抽象相适应的异常\"></a>抛出与抽象相适应的异常</h3><p>换句话说，一个方法所抛出的异常应该在一个抽象层次上定义，该抽象层次与该方法做什么相一致，而不一定与方法的底层实现细节相一致。例如，一个从文件、数据库或者 JNDI 装载资源的方法在不能找到资源时，应该抛出某种 ResourceNotFound 异常（通常使用异常链来保存隐含的原因），而不是更底层的 IOException 、 SQLException 或者 NamingException 。</p>\n<p>我们有时候在捕获一个异常后抛出另一个封装后的异常信息，并且希望将原始的异常信息也保持起来，<br>throw抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？<br>在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。</p>\n<h3 id=\"多线程中的异常\"><a href=\"#多线程中的异常\" class=\"headerlink\" title=\"多线程中的异常\"></a>多线程中的异常</h3><p>在java多线程程序中，所有线程都不允许抛出未捕获的检测型异常（比如sleep时的InterruptedException),<br>也就是说各个线程需要自己把自己的检测型处理掉。<br>这一点是通过java.lang.Runnable.run()方法声明(因为此方法声明上没有throw exception部分)进行了约束。<br>但是线程依然有可能抛出非检测型异常，当此类异常跑抛出时，线程就会终结，<br>而对于主线程和其他线程完全不受影响，且完全感知不到某个线程抛出的异常(也是说完全无法catch到这个异常)。</p>\n<p>如果我们不考虑线程内可能出现的异常而导致线程的终结，那么就有可能造成意想不到的后果。如果是使用线程池的话，就有可能导致线程泄漏，这样的错误可能难以察觉，<br>最终导致程序挂掉或者内存溢出等等意想不到的问题，但是往往不好追踪问题出现的原因。<br><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章很好的展示了一个多线程发生异常后产生的一系列后果。</p>\n<p>对于线程可以自己处理的异常，比较好解决。我们可以在线程内部捕获异常，作一些处理，防止线程退出。比如，<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章中的一个示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">private class SaferPoolWorker extends Thread &#123;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        IncomingResponse ir;</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\">            ir = (IncomingResponse) queue.getNext();</div><div class=\"line\">            PlugIn plugIn = findPlugIn(ir.getResponseId());</div><div class=\"line\">            if (plugIn != null) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">                    plugIn.handleMessage(ir.getResponse());</div><div class=\"line\">                &#125;</div><div class=\"line\">                catch (RuntimeException e) &#123;</div><div class=\"line\">                    // Take some sort of action; </div><div class=\"line\">                    // - log the exception and move on</div><div class=\"line\">                    // - log the exception and restart the worker thread</div><div class=\"line\">                    // - log the exception and unload the offending plug-in</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            else</div><div class=\"line\">                log(&quot;Unknown plug-in for response &quot; + ir.getResponseId());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是，当子线程发生异常时，我们需要父线程或者主线程可以感知子线程的异常，也就是得到子线程产生的异常，然后做一些处理。<a href=\"http://blog.onlycatch.com/post/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">Java线程池异常处理最佳实践</a>这篇文章给出了很好的总结，<br>摘抄其总结如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">处理线程池中的异常有两种思路： </div><div class=\"line\">1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池 </div><div class=\"line\">2）由线程池统一处理</div><div class=\"line\">对于execute方法提交的线程，有两种处理方式 </div><div class=\"line\">1）自定义线程池并实现afterExecute方法 </div><div class=\"line\">2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。</div><div class=\"line\">对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。</div></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>还发现了一个比较有趣的异常处理情况，虽然可能很少碰到，但是碰到了可以参考作者的思路。</p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-ce/\">技巧：当不能抛出异常时</a>这篇文章介绍了一种不是很常见的情况：即不能处理，也不能抛出异常(包括非检测型异常)时怎么办？</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/\">Java 异常处理的误区和经验总结</a></p>\n<p><a href=\"http://www.importnew.com/18994.html\">Java异常处理和设计</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp05254/\">Java 理论与实践: 关于异常的争论</a></p>\n"},{"layout":"post","date":"2017-02-21T04:48:55.000Z","title":"java日志框架的使用","_content":"\n> 之前在web项目中用到了日志，日志在web应用中很重要，特别是对于程序员追查bug而言。但是由于对混乱的日志框架体系不是十分清楚，导致各种jar包冲突和日志不正常输出。今天来总结一下日志框架的使用\n> 主要介绍日志门面slf4j结合日志实现log4j。关于其他的日志框架介绍和使用，参考链接里列出了前辈总结的很好的资料，相信读完之后一定会有收获。\n\n## 日志门面和实际日志框架\n\n日志框架有：jdk自带的logging(jul)，log4j1、log4j2、logback\n日志门面有：apache commons-logging、slf4j\n\n日志框架很好理解，就是提供日志api，使我们可以很轻易的，有组织有规范的输出日志。日志门面的作用是在日志记录实现的基础上提供一个封装的 API 层次，\n对日志记录 API 的使用者提供一个统一的接口，使得可以自由切换不同的日志记录实现。日志门面就好比java中的jdbc规范接口，各个数据库厂家实现的jdbc驱动程序就是实际的日志框架，\n他们遵循了这个规范，使得我们在编写java程序时不用考虑底层驱动的不同，只需调用jdbc规范接口即可。这是典型的面向对象思想。\n\n##  slf4j的使用\n\n### 简介\n\n![slf4j使用](https://www.slf4j.org/images/concrete-bindings.png)\n\n上图来自slf4j官网\n\nslf4j-api.jar包含了slf4j的抽象层API，我们在代码中调用这个jar包中的接口。API层\n\nslf4j-log412.jar、slf4j-jdk14.jar等是slf4j通向具体日志实现框架的桥梁。中间层\n\nlog4j.jar等则是具体的日志实现框架。实现层\n\n\n>SLF4J does not rely on any special class loader machinery. In fact, each SLF4J binding is hardwired at compile time to use one and only one specific logging framework. For example, the slf4j-log4j12-1.7.23.jar binding is bound at compile time to use log4j. In your code, in addition to slf4j-api-1.7.23.jar, you simply drop one and only one binding of your choice onto the appropriate class path location. Do not place more than one binding on your class path. Here is a graphical illustration of the general idea.\n\n上面这段话的意思大概是，我们不应该在classpath中绑定多于一个的中间层，否则会导致jar包冲突或者输出混乱。\n\n>To switch logging frameworks, just replace slf4j bindings on your class path. For example, to switch from java.util.logging to log4j, just replace slf4j-jdk14-1.7.23.jar with slf4j-log4j12-1.7.23.jar.\n\n当我们需要将日志实现由jul切换到log4j时，仅仅把中间层替换，同时切换实现层即可，并不需要修改代码。这就是日志门面的好处。不过实际应用中，需要切换日志实现的场景貌似不是很多。\n\n### slf4j结合log4j\n\n#### 依赖\n\n需要的jar包：slf4j-api.jar、slf4j-log4j12.jar、log4j.jar\n\n对应的maven依赖：\n\n```\n<dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>slf4j-api</artifactId>\n    <version>1.7.23</version>\n</dependency>\n<dependency> \n  <groupId>org.slf4j</groupId>\n  <artifactId>slf4j-log4j12</artifactId>\n  <version>1.7.23</version>\n</dependency>\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n</dependency>\n```\n#### 使用\n\n编写log4j.properties配置文件，放到类路径下\n\n```\nlog4j.rootLogger=INFO,stdout\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.out\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n\n\n```\njava代码\n\n```\npackage space.kyu.LogTest.log4j;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Test {\n\tpublic static Logger logger = LoggerFactory.getLogger(Test.class);\n\t\n\tpublic void test() {\n\t\tlogger.info(\"info\");\n\t\tlogger.debug(\"debug\");\n\t\tlogger.warn(\"warn\");\n\t\tlogger.error(\"error\");\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Test().test();\n\t}\n}\n```\n输出\n\n```\n[INFO ] 2017-02-21 14:52:28,083 method:space.kyu.LogTest.log4j.Test.test(Test.java:10)\ninfo\n[WARN ] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:12)\nwarn\n[ERROR] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)\nerror\n```\n\n#### 原理\n\nslf4j-api.jar: org.slf4j.LoggerFactory\n```\n public static Logger getLogger(String name) {\n    ILoggerFactory iLoggerFactory = getILoggerFactory();\n     return iLoggerFactory.getLogger(name);\n }\n```\n可以看到，主要分为两部分，获取ILoggerFactory，使用ILoggerFactory获取logger.\n\nslf4j-api.jar: org.slf4j.LoggerFactory\n```\npublic static ILoggerFactory getILoggerFactory() {\n        if (INITIALIZATION_STATE == UNINITIALIZED) {\n            synchronized (LoggerFactory.class) {\n                if (INITIALIZATION_STATE == UNINITIALIZED) {\n                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n                    performInitialization();\n                }\n            }\n        }\n        switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return StaticLoggerBinder.getSingleton().getLoggerFactory();\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_FACTORY;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n        case ONGOING_INITIALIZATION:\n            // support re-entrant behavior.\n            // See also http://jira.qos.ch/browse/SLF4J-97\n            return SUBST_FACTORY;\n        }\n        throw new IllegalStateException(\"Unreachable code\");\n}\n```\n注意`return StaticLoggerBinder.getSingleton().getLoggerFactory();`这行，StaticLoggerBinder是slf4j-log4j12.jar中的类\n\nslf4j-log4j12.jar: org.slf4j.impl.StaticLoggerBinder\n```\nprivate StaticLoggerBinder() {\n        loggerFactory = new Log4jLoggerFactory();\n        try {\n            @SuppressWarnings(\"unused\")\n            Level level = Level.TRACE;\n        } catch (NoSuchFieldError nsfe) {\n            Util.report(\"This version of SLF4J requires log4j version 1.2.12 or later. See also http://www.slf4j.org/codes.html#log4j_version\");\n        }\n}\n\n```\nslf4j-log4j12.jar: org.slf4j.impl.Log4jLoggerFactory\n```\npublic Log4jLoggerFactory() {\n        loggerMap = new ConcurrentHashMap<String, Logger>();\n        // force log4j to initialize\n        org.apache.log4j.LogManager.getRootLogger();\n}\n```\n注意`org.apache.log4j.LogManager.getRootLogger();`初始化了log4j为具体的日志实现\n\n追踪源代码还可以发现，我们在代码中调用的`LoggerFactory.getLogger(Test.class);`最终返回的是org.apache.log4j.Logger实例，也就是说，日志实现最终托付给了log4j\n\n## log4j的使用\n\n### 日志组件\n\nLoggers：Logger负责捕捉事件并将其发送给合适的Appender。\n\nAppenders：也被称为Handlers，负责将日志事件记录到目标位置。在将日志事件输出之前，Appenders使用Layouts来对事件进行格式化处理。\n\nLayouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的最终形式。\n\n当Logger记录一个事件时，它将事件转发给适当的Appender。然后Appender使用Layout来对日志记录进行格式化，并将其发送给控制台、文件或者其它目标位置。\n\n### 日志级别\n\n每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：\n\norg.apache.log4j.Level\n```\n  public final static int OFF_INT = Integer.MAX_VALUE;\n  public final static int FATAL_INT = 50000;\n  public final static int ERROR_INT = 40000;\n  public final static int WARN_INT  = 30000;\n  public final static int INFO_INT  = 20000;\n  public final static int DEBUG_INT = 10000;\n    //public final static int FINE_INT = DEBUG_INT;\n  public final static int ALL_INT = Integer.MIN_VALUE;\n```\nA：off 最高等级，用于关闭所有日志记录。\n\nB：fatal 指出每个严重的错误事件将会导致应用程序的退出。\n\nC：error 指出虽然发生错误事件，但仍然不影响系统的继续运行。\n\nD：warm 表明会出现潜在的错误情形。\n\nE：info 一般和在粗粒度级别上，强调应用程序的运行全程。\n\nF：debug 一般用于细粒度级别上，对调试应用程序非常有帮助。\n\nG：all 最低等级，用于打开所有日志记录。\n\n我们一般只是用error,warn,info和debug就够了。\n\n### 配置文件编写\n\n了解了组件和日志级别，我们可以编写自己的配置文件，log4j.properties放到类路径下，如果缺少了配置文件，log4j会报错。我们也可以使用`PropertyConfigurator.configure ( String configFilename)`来指定配置文件\n\n#### 配置logger\n\n配置根logger：`log4j.rootLogger = [ level ] , appenderName, appenderName, …`\n\n比如：`log4j.rootLogger=INFO,stdout`\n\nlevel为日志级别，表示这个logger只打印级别大于等于level的日志。\n\nappenderName定义了如何处理日志，即把日志输出到哪个地方，如何输出。\n\n可以看出，一个logger可以根据appender同时输出到多个地方，logger与appender是一对多的关系。\n\n我们也可以定义自己的logger：`log4j.logger.yukai=DEBUG,stdout`\n\n#### 配置appender\n\nappender定义了日志输出的目的地：`log4j.appender.appenderName = fully.qualified.name.of.appender.class `\n\n其中，Log4j提供的常用的appender：\n\norg.apache.log4j.ConsoleAppender（控制台），\n\norg.apache.log4j.FileAppender（文件），\n\norg.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），\n\norg.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），\n\norg.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）\n\n我们还可以设置appender的属性，比如针对ConsoleAppender\n\n```\n属性\t                  描述\nlayout\t    Appender 使用 Layout 对象和与之关联的模式来格式化日志信息。\ntarget\t    目的地可以是控制台、文件，或依赖于 appender 的对象。\nlevel\t    级别用来控制过滤日志信息。\nthreshold\tAppender 可脱离于日志级别定义一个阀值级别，Appender 对象会忽略所有级别低于阀值级别的日志。\nfilter\t    Filter 对象可在级别基础之上分析日志信息，来决定 Appender 对象是否处理或忽略一条日志记录。\n```\n\n#### 配置layout\n\n一个appender可以关联某一个layout，用来格式化日志的输出。可用的layout有以下几种：\n\norg.apache.log4j.HTMLLayout（以HTML表格形式布局）， \n\norg.apache.log4j.PatternLayout（可以灵活地指定布局模式）， \n\norg.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， \n\norg.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）\n\n可用的格式：\n\n%m 输出代码中指定的消息 \n\n%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL \n\n%r 输出自应用启动到输出该log信息耗费的毫秒数 \n\n%c 输出所属的类目，通常就是所在类的全名 \n\n%t 输出产生该日志事件的线程名 \n\n%n 输出一个回车换行符，Windows平台为\"rn\"，Unix平台为\"n\" \n\n%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 \n\n%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(Test Log4.java:10)\n\n比如：\n\n```\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n\n```\n\n打印的信息：\n\n```\n[ERROR] 2017-02-21 16:41:25,563 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)\ninfo\n```\n\n#### logger的继承关系\n\n我们可以定义自己的logger：`log4j.logger.yukai=DEBUG,stdout`\n\n其中，yukai指定了这个logger的名字，可以在代码中使用它：\n\n```\npublic static Logger logger = LoggerFactory.getLogger(\"yukai\");\n```\n\n假如我们同时定义这样一个logger：`log4j.logger.yukai.child=DEBUG,stdout`\n\n就表示yukai.child这个logger继承了yukai这个logger，更java中的包有些类似\n\n在代码中使用：\n\n```\npublic static Logger logger = LoggerFactory.getLogger(\"yukai.child\");\n```\n\n使用了该logger会默认实现自身的设定和父Logger的设定。比如使用该logger打印了一条debug信息，同样的打印动作会执行两次，因为父logger的打印动作也会实现。\n\n上面提到的rootlogger就是所有looger的根logger。\n\n我们经常在代码中使用 `public static Logger logger = LoggerFactory.getLogger(Test.calss);`这样的方式，因此我们可以通过指定包名的logger来控制某个包下面所有的logger输出。比如：\n\n我们指定：`log4j.logger.space.kyu=DEBUG,stdout`,就表示space.kyu包下面的所有logger(以LoggerFactory.getLogger(Test.calss);这种方式获取的)都继承该logger的设定。这在分层的应用或功能性应用中有可以用到。\n\n可以通过配置log4j.additivity.XXX=ture/false来打开或关闭继承功能；若为 false,表示Logger 的 appender 不继承它的父Logger； 若为true，则继承，这样就兼有自身的设定和父Logger的设定。\n\n### MDC的使用\n\n> 在一个高访问量的 Web 应用中，经常要在同一时刻处理大量的用户请求。Web 服务器会为每一个请求分配一个线程，每一个线程都会向日志系统输入一些信息，通常日志系统都是按照时间顺序而不是用户顺序排列这些信息的，这些线程的交替运行会让所有用户的处理信息交错在一起，让人很难分辨出那些记录是同一个用户产生的。另外，高可用性的网站经常会使用负载均衡系统平衡网络流量，这样一个用户的操作记录很可能会分布在多个 Web 服务器上，如果我们没有一种方法来标示一条记录是哪个用户产生的，从这众多的日志信息中筛选出对我们有用的东西将是一项艰巨的工作。\n\nNDC或MDC就是用来解决这个问题的。\n\nMDC 可以看成是一个与当前线程绑定的哈希表，可以往其中添加键值对。\nMDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。\n当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。\n对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。\n\n```\npublic class App {\n\tprivate static final Logger logger = LoggerFactory.getLogger(App.class);\n\n\tpublic static void main(String[] args) {\n\t\tnew App().log(\"main thread\");\n\t\tnew Thread(){\n\t\t\tpublic void run() {\n\t\t\t\tnew App().log(\"sub thread\");\n\t\t\t};\n\t\t}.start();\n\t}\n\n\tpublic void log(String arg) {\n\t\tMDC.put(\"username\", \"Yukai\");\n\t\tlogger.info(\"This message from : {}\", arg);\n\t}\n}\n```\n\n设置appender: `log4j.appender.stdout.layout.ConversionPattern=%X{username} %d{yyyy-MM-dd HH:mm:ss} [%p] %c - %m%n`\n\n输出\n\nYukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : main thread\nYukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : sub thread\n\n## 参考\n\n[SLF4J user manual](https://www.slf4j.org/manual.html)\n\n[JDK Logging深入分析](http://blog.csdn.net/qingkangxu/article/details/7514770)\n\n[jdk-logging、log4j、logback日志介绍及原理](http://my.oschina.net/pingpangkuangmo/blog/406618)\n\n[commons-logging与jdk-logging、log4j1、log4j2、logback的集成原理](http://my.oschina.net/pingpangkuangmo/blog/407895)\n\n[slf4j与jdk-logging、log4j1、log4j2、logback的集成原理](http://my.oschina.net/pingpangkuangmo/blog/408382)\n\n[slf4j、jcl、jul、log4j1、log4j2、logback大总结](http://my.oschina.net/pingpangkuangmo/blog/410224)\n\n[Java 日志管理最佳实践](https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/)","source":"_posts/java日志使用.md","raw":"---\nlayout: post\ndate:   2017-02-21 12:48:55\ntitle:  \"java日志框架的使用\"\ncategories: 工具\ntags: \n- java\n---\n\n> 之前在web项目中用到了日志，日志在web应用中很重要，特别是对于程序员追查bug而言。但是由于对混乱的日志框架体系不是十分清楚，导致各种jar包冲突和日志不正常输出。今天来总结一下日志框架的使用\n> 主要介绍日志门面slf4j结合日志实现log4j。关于其他的日志框架介绍和使用，参考链接里列出了前辈总结的很好的资料，相信读完之后一定会有收获。\n\n## 日志门面和实际日志框架\n\n日志框架有：jdk自带的logging(jul)，log4j1、log4j2、logback\n日志门面有：apache commons-logging、slf4j\n\n日志框架很好理解，就是提供日志api，使我们可以很轻易的，有组织有规范的输出日志。日志门面的作用是在日志记录实现的基础上提供一个封装的 API 层次，\n对日志记录 API 的使用者提供一个统一的接口，使得可以自由切换不同的日志记录实现。日志门面就好比java中的jdbc规范接口，各个数据库厂家实现的jdbc驱动程序就是实际的日志框架，\n他们遵循了这个规范，使得我们在编写java程序时不用考虑底层驱动的不同，只需调用jdbc规范接口即可。这是典型的面向对象思想。\n\n##  slf4j的使用\n\n### 简介\n\n![slf4j使用](https://www.slf4j.org/images/concrete-bindings.png)\n\n上图来自slf4j官网\n\nslf4j-api.jar包含了slf4j的抽象层API，我们在代码中调用这个jar包中的接口。API层\n\nslf4j-log412.jar、slf4j-jdk14.jar等是slf4j通向具体日志实现框架的桥梁。中间层\n\nlog4j.jar等则是具体的日志实现框架。实现层\n\n\n>SLF4J does not rely on any special class loader machinery. In fact, each SLF4J binding is hardwired at compile time to use one and only one specific logging framework. For example, the slf4j-log4j12-1.7.23.jar binding is bound at compile time to use log4j. In your code, in addition to slf4j-api-1.7.23.jar, you simply drop one and only one binding of your choice onto the appropriate class path location. Do not place more than one binding on your class path. Here is a graphical illustration of the general idea.\n\n上面这段话的意思大概是，我们不应该在classpath中绑定多于一个的中间层，否则会导致jar包冲突或者输出混乱。\n\n>To switch logging frameworks, just replace slf4j bindings on your class path. For example, to switch from java.util.logging to log4j, just replace slf4j-jdk14-1.7.23.jar with slf4j-log4j12-1.7.23.jar.\n\n当我们需要将日志实现由jul切换到log4j时，仅仅把中间层替换，同时切换实现层即可，并不需要修改代码。这就是日志门面的好处。不过实际应用中，需要切换日志实现的场景貌似不是很多。\n\n### slf4j结合log4j\n\n#### 依赖\n\n需要的jar包：slf4j-api.jar、slf4j-log4j12.jar、log4j.jar\n\n对应的maven依赖：\n\n```\n<dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>slf4j-api</artifactId>\n    <version>1.7.23</version>\n</dependency>\n<dependency> \n  <groupId>org.slf4j</groupId>\n  <artifactId>slf4j-log4j12</artifactId>\n  <version>1.7.23</version>\n</dependency>\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n</dependency>\n```\n#### 使用\n\n编写log4j.properties配置文件，放到类路径下\n\n```\nlog4j.rootLogger=INFO,stdout\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.out\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n\n\n```\njava代码\n\n```\npackage space.kyu.LogTest.log4j;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Test {\n\tpublic static Logger logger = LoggerFactory.getLogger(Test.class);\n\t\n\tpublic void test() {\n\t\tlogger.info(\"info\");\n\t\tlogger.debug(\"debug\");\n\t\tlogger.warn(\"warn\");\n\t\tlogger.error(\"error\");\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Test().test();\n\t}\n}\n```\n输出\n\n```\n[INFO ] 2017-02-21 14:52:28,083 method:space.kyu.LogTest.log4j.Test.test(Test.java:10)\ninfo\n[WARN ] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:12)\nwarn\n[ERROR] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)\nerror\n```\n\n#### 原理\n\nslf4j-api.jar: org.slf4j.LoggerFactory\n```\n public static Logger getLogger(String name) {\n    ILoggerFactory iLoggerFactory = getILoggerFactory();\n     return iLoggerFactory.getLogger(name);\n }\n```\n可以看到，主要分为两部分，获取ILoggerFactory，使用ILoggerFactory获取logger.\n\nslf4j-api.jar: org.slf4j.LoggerFactory\n```\npublic static ILoggerFactory getILoggerFactory() {\n        if (INITIALIZATION_STATE == UNINITIALIZED) {\n            synchronized (LoggerFactory.class) {\n                if (INITIALIZATION_STATE == UNINITIALIZED) {\n                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n                    performInitialization();\n                }\n            }\n        }\n        switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return StaticLoggerBinder.getSingleton().getLoggerFactory();\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_FACTORY;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n        case ONGOING_INITIALIZATION:\n            // support re-entrant behavior.\n            // See also http://jira.qos.ch/browse/SLF4J-97\n            return SUBST_FACTORY;\n        }\n        throw new IllegalStateException(\"Unreachable code\");\n}\n```\n注意`return StaticLoggerBinder.getSingleton().getLoggerFactory();`这行，StaticLoggerBinder是slf4j-log4j12.jar中的类\n\nslf4j-log4j12.jar: org.slf4j.impl.StaticLoggerBinder\n```\nprivate StaticLoggerBinder() {\n        loggerFactory = new Log4jLoggerFactory();\n        try {\n            @SuppressWarnings(\"unused\")\n            Level level = Level.TRACE;\n        } catch (NoSuchFieldError nsfe) {\n            Util.report(\"This version of SLF4J requires log4j version 1.2.12 or later. See also http://www.slf4j.org/codes.html#log4j_version\");\n        }\n}\n\n```\nslf4j-log4j12.jar: org.slf4j.impl.Log4jLoggerFactory\n```\npublic Log4jLoggerFactory() {\n        loggerMap = new ConcurrentHashMap<String, Logger>();\n        // force log4j to initialize\n        org.apache.log4j.LogManager.getRootLogger();\n}\n```\n注意`org.apache.log4j.LogManager.getRootLogger();`初始化了log4j为具体的日志实现\n\n追踪源代码还可以发现，我们在代码中调用的`LoggerFactory.getLogger(Test.class);`最终返回的是org.apache.log4j.Logger实例，也就是说，日志实现最终托付给了log4j\n\n## log4j的使用\n\n### 日志组件\n\nLoggers：Logger负责捕捉事件并将其发送给合适的Appender。\n\nAppenders：也被称为Handlers，负责将日志事件记录到目标位置。在将日志事件输出之前，Appenders使用Layouts来对事件进行格式化处理。\n\nLayouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的最终形式。\n\n当Logger记录一个事件时，它将事件转发给适当的Appender。然后Appender使用Layout来对日志记录进行格式化，并将其发送给控制台、文件或者其它目标位置。\n\n### 日志级别\n\n每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：\n\norg.apache.log4j.Level\n```\n  public final static int OFF_INT = Integer.MAX_VALUE;\n  public final static int FATAL_INT = 50000;\n  public final static int ERROR_INT = 40000;\n  public final static int WARN_INT  = 30000;\n  public final static int INFO_INT  = 20000;\n  public final static int DEBUG_INT = 10000;\n    //public final static int FINE_INT = DEBUG_INT;\n  public final static int ALL_INT = Integer.MIN_VALUE;\n```\nA：off 最高等级，用于关闭所有日志记录。\n\nB：fatal 指出每个严重的错误事件将会导致应用程序的退出。\n\nC：error 指出虽然发生错误事件，但仍然不影响系统的继续运行。\n\nD：warm 表明会出现潜在的错误情形。\n\nE：info 一般和在粗粒度级别上，强调应用程序的运行全程。\n\nF：debug 一般用于细粒度级别上，对调试应用程序非常有帮助。\n\nG：all 最低等级，用于打开所有日志记录。\n\n我们一般只是用error,warn,info和debug就够了。\n\n### 配置文件编写\n\n了解了组件和日志级别，我们可以编写自己的配置文件，log4j.properties放到类路径下，如果缺少了配置文件，log4j会报错。我们也可以使用`PropertyConfigurator.configure ( String configFilename)`来指定配置文件\n\n#### 配置logger\n\n配置根logger：`log4j.rootLogger = [ level ] , appenderName, appenderName, …`\n\n比如：`log4j.rootLogger=INFO,stdout`\n\nlevel为日志级别，表示这个logger只打印级别大于等于level的日志。\n\nappenderName定义了如何处理日志，即把日志输出到哪个地方，如何输出。\n\n可以看出，一个logger可以根据appender同时输出到多个地方，logger与appender是一对多的关系。\n\n我们也可以定义自己的logger：`log4j.logger.yukai=DEBUG,stdout`\n\n#### 配置appender\n\nappender定义了日志输出的目的地：`log4j.appender.appenderName = fully.qualified.name.of.appender.class `\n\n其中，Log4j提供的常用的appender：\n\norg.apache.log4j.ConsoleAppender（控制台），\n\norg.apache.log4j.FileAppender（文件），\n\norg.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），\n\norg.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），\n\norg.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）\n\n我们还可以设置appender的属性，比如针对ConsoleAppender\n\n```\n属性\t                  描述\nlayout\t    Appender 使用 Layout 对象和与之关联的模式来格式化日志信息。\ntarget\t    目的地可以是控制台、文件，或依赖于 appender 的对象。\nlevel\t    级别用来控制过滤日志信息。\nthreshold\tAppender 可脱离于日志级别定义一个阀值级别，Appender 对象会忽略所有级别低于阀值级别的日志。\nfilter\t    Filter 对象可在级别基础之上分析日志信息，来决定 Appender 对象是否处理或忽略一条日志记录。\n```\n\n#### 配置layout\n\n一个appender可以关联某一个layout，用来格式化日志的输出。可用的layout有以下几种：\n\norg.apache.log4j.HTMLLayout（以HTML表格形式布局）， \n\norg.apache.log4j.PatternLayout（可以灵活地指定布局模式）， \n\norg.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， \n\norg.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）\n\n可用的格式：\n\n%m 输出代码中指定的消息 \n\n%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL \n\n%r 输出自应用启动到输出该log信息耗费的毫秒数 \n\n%c 输出所属的类目，通常就是所在类的全名 \n\n%t 输出产生该日志事件的线程名 \n\n%n 输出一个回车换行符，Windows平台为\"rn\"，Unix平台为\"n\" \n\n%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 \n\n%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(Test Log4.java:10)\n\n比如：\n\n```\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n\n```\n\n打印的信息：\n\n```\n[ERROR] 2017-02-21 16:41:25,563 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)\ninfo\n```\n\n#### logger的继承关系\n\n我们可以定义自己的logger：`log4j.logger.yukai=DEBUG,stdout`\n\n其中，yukai指定了这个logger的名字，可以在代码中使用它：\n\n```\npublic static Logger logger = LoggerFactory.getLogger(\"yukai\");\n```\n\n假如我们同时定义这样一个logger：`log4j.logger.yukai.child=DEBUG,stdout`\n\n就表示yukai.child这个logger继承了yukai这个logger，更java中的包有些类似\n\n在代码中使用：\n\n```\npublic static Logger logger = LoggerFactory.getLogger(\"yukai.child\");\n```\n\n使用了该logger会默认实现自身的设定和父Logger的设定。比如使用该logger打印了一条debug信息，同样的打印动作会执行两次，因为父logger的打印动作也会实现。\n\n上面提到的rootlogger就是所有looger的根logger。\n\n我们经常在代码中使用 `public static Logger logger = LoggerFactory.getLogger(Test.calss);`这样的方式，因此我们可以通过指定包名的logger来控制某个包下面所有的logger输出。比如：\n\n我们指定：`log4j.logger.space.kyu=DEBUG,stdout`,就表示space.kyu包下面的所有logger(以LoggerFactory.getLogger(Test.calss);这种方式获取的)都继承该logger的设定。这在分层的应用或功能性应用中有可以用到。\n\n可以通过配置log4j.additivity.XXX=ture/false来打开或关闭继承功能；若为 false,表示Logger 的 appender 不继承它的父Logger； 若为true，则继承，这样就兼有自身的设定和父Logger的设定。\n\n### MDC的使用\n\n> 在一个高访问量的 Web 应用中，经常要在同一时刻处理大量的用户请求。Web 服务器会为每一个请求分配一个线程，每一个线程都会向日志系统输入一些信息，通常日志系统都是按照时间顺序而不是用户顺序排列这些信息的，这些线程的交替运行会让所有用户的处理信息交错在一起，让人很难分辨出那些记录是同一个用户产生的。另外，高可用性的网站经常会使用负载均衡系统平衡网络流量，这样一个用户的操作记录很可能会分布在多个 Web 服务器上，如果我们没有一种方法来标示一条记录是哪个用户产生的，从这众多的日志信息中筛选出对我们有用的东西将是一项艰巨的工作。\n\nNDC或MDC就是用来解决这个问题的。\n\nMDC 可以看成是一个与当前线程绑定的哈希表，可以往其中添加键值对。\nMDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。\n当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。\n对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。\n\n```\npublic class App {\n\tprivate static final Logger logger = LoggerFactory.getLogger(App.class);\n\n\tpublic static void main(String[] args) {\n\t\tnew App().log(\"main thread\");\n\t\tnew Thread(){\n\t\t\tpublic void run() {\n\t\t\t\tnew App().log(\"sub thread\");\n\t\t\t};\n\t\t}.start();\n\t}\n\n\tpublic void log(String arg) {\n\t\tMDC.put(\"username\", \"Yukai\");\n\t\tlogger.info(\"This message from : {}\", arg);\n\t}\n}\n```\n\n设置appender: `log4j.appender.stdout.layout.ConversionPattern=%X{username} %d{yyyy-MM-dd HH:mm:ss} [%p] %c - %m%n`\n\n输出\n\nYukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : main thread\nYukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : sub thread\n\n## 参考\n\n[SLF4J user manual](https://www.slf4j.org/manual.html)\n\n[JDK Logging深入分析](http://blog.csdn.net/qingkangxu/article/details/7514770)\n\n[jdk-logging、log4j、logback日志介绍及原理](http://my.oschina.net/pingpangkuangmo/blog/406618)\n\n[commons-logging与jdk-logging、log4j1、log4j2、logback的集成原理](http://my.oschina.net/pingpangkuangmo/blog/407895)\n\n[slf4j与jdk-logging、log4j1、log4j2、logback的集成原理](http://my.oschina.net/pingpangkuangmo/blog/408382)\n\n[slf4j、jcl、jul、log4j1、log4j2、logback大总结](http://my.oschina.net/pingpangkuangmo/blog/410224)\n\n[Java 日志管理最佳实践](https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/)","slug":"java日志使用","published":1,"updated":"2017-02-22T13:22:35.571Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlrm001zvegcq79km8xo","content":"<blockquote>\n<p>之前在web项目中用到了日志，日志在web应用中很重要，特别是对于程序员追查bug而言。但是由于对混乱的日志框架体系不是十分清楚，导致各种jar包冲突和日志不正常输出。今天来总结一下日志框架的使用<br>主要介绍日志门面slf4j结合日志实现log4j。关于其他的日志框架介绍和使用，参考链接里列出了前辈总结的很好的资料，相信读完之后一定会有收获。</p>\n</blockquote>\n<h2 id=\"日志门面和实际日志框架\"><a href=\"#日志门面和实际日志框架\" class=\"headerlink\" title=\"日志门面和实际日志框架\"></a>日志门面和实际日志框架</h2><p>日志框架有：jdk自带的logging(jul)，log4j1、log4j2、logback<br>日志门面有：apache commons-logging、slf4j</p>\n<p>日志框架很好理解，就是提供日志api，使我们可以很轻易的，有组织有规范的输出日志。日志门面的作用是在日志记录实现的基础上提供一个封装的 API 层次，<br>对日志记录 API 的使用者提供一个统一的接口，使得可以自由切换不同的日志记录实现。日志门面就好比java中的jdbc规范接口，各个数据库厂家实现的jdbc驱动程序就是实际的日志框架，<br>他们遵循了这个规范，使得我们在编写java程序时不用考虑底层驱动的不同，只需调用jdbc规范接口即可。这是典型的面向对象思想。</p>\n<h2 id=\"slf4j的使用\"><a href=\"#slf4j的使用\" class=\"headerlink\" title=\"slf4j的使用\"></a>slf4j的使用</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><img src=\"https://www.slf4j.org/images/concrete-bindings.png\" alt=\"slf4j使用\"></p>\n<p>上图来自slf4j官网</p>\n<p>slf4j-api.jar包含了slf4j的抽象层API，我们在代码中调用这个jar包中的接口。API层</p>\n<p>slf4j-log412.jar、slf4j-jdk14.jar等是slf4j通向具体日志实现框架的桥梁。中间层</p>\n<p>log4j.jar等则是具体的日志实现框架。实现层</p>\n<blockquote>\n<p>SLF4J does not rely on any special class loader machinery. In fact, each SLF4J binding is hardwired at compile time to use one and only one specific logging framework. For example, the slf4j-log4j12-1.7.23.jar binding is bound at compile time to use log4j. In your code, in addition to slf4j-api-1.7.23.jar, you simply drop one and only one binding of your choice onto the appropriate class path location. Do not place more than one binding on your class path. Here is a graphical illustration of the general idea.</p>\n</blockquote>\n<p>上面这段话的意思大概是，我们不应该在classpath中绑定多于一个的中间层，否则会导致jar包冲突或者输出混乱。</p>\n<blockquote>\n<p>To switch logging frameworks, just replace slf4j bindings on your class path. For example, to switch from java.util.logging to log4j, just replace slf4j-jdk14-1.7.23.jar with slf4j-log4j12-1.7.23.jar.</p>\n</blockquote>\n<p>当我们需要将日志实现由jul切换到log4j时，仅仅把中间层替换，同时切换实现层即可，并不需要修改代码。这就是日志门面的好处。不过实际应用中，需要切换日志实现的场景貌似不是很多。</p>\n<h3 id=\"slf4j结合log4j\"><a href=\"#slf4j结合log4j\" class=\"headerlink\" title=\"slf4j结合log4j\"></a>slf4j结合log4j</h3><h4 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h4><p>需要的jar包：slf4j-api.jar、slf4j-log4j12.jar、log4j.jar</p>\n<p>对应的maven依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;1.7.23&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div><div class=\"line\">&lt;dependency&gt; </div><div class=\"line\">  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class=\"line\">  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</div><div class=\"line\">  &lt;version&gt;1.7.23&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;log4j&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;1.2.17&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>编写log4j.properties配置文件，放到类路径下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">log4j.rootLogger=INFO,stdout</div><div class=\"line\"></div><div class=\"line\">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</div><div class=\"line\">log4j.appender.stdout.Target=System.out</div><div class=\"line\">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</div><div class=\"line\">log4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</div></pre></td></tr></table></figure>\n<p>java代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">package space.kyu.LogTest.log4j;</div><div class=\"line\"></div><div class=\"line\">import org.slf4j.Logger;</div><div class=\"line\">import org.slf4j.LoggerFactory;</div><div class=\"line\"></div><div class=\"line\">public class Test &#123;</div><div class=\"line\">\tpublic static Logger logger = LoggerFactory.getLogger(Test.class);</div><div class=\"line\">\t</div><div class=\"line\">\tpublic void test() &#123;</div><div class=\"line\">\t\tlogger.info(&quot;info&quot;);</div><div class=\"line\">\t\tlogger.debug(&quot;debug&quot;);</div><div class=\"line\">\t\tlogger.warn(&quot;warn&quot;);</div><div class=\"line\">\t\tlogger.error(&quot;error&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tnew Test().test();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[INFO ] 2017-02-21 14:52:28,083 method:space.kyu.LogTest.log4j.Test.test(Test.java:10)</div><div class=\"line\">info</div><div class=\"line\">[WARN ] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:12)</div><div class=\"line\">warn</div><div class=\"line\">[ERROR] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)</div><div class=\"line\">error</div></pre></td></tr></table></figure>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>slf4j-api.jar: org.slf4j.LoggerFactory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Logger getLogger(String name) &#123;</div><div class=\"line\">   ILoggerFactory iLoggerFactory = getILoggerFactory();</div><div class=\"line\">    return iLoggerFactory.getLogger(name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到，主要分为两部分，获取ILoggerFactory，使用ILoggerFactory获取logger.</p>\n<p>slf4j-api.jar: org.slf4j.LoggerFactory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static ILoggerFactory getILoggerFactory() &#123;</div><div class=\"line\">        if (INITIALIZATION_STATE == UNINITIALIZED) &#123;</div><div class=\"line\">            synchronized (LoggerFactory.class) &#123;</div><div class=\"line\">                if (INITIALIZATION_STATE == UNINITIALIZED) &#123;</div><div class=\"line\">                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;</div><div class=\"line\">                    performInitialization();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        switch (INITIALIZATION_STATE) &#123;</div><div class=\"line\">        case SUCCESSFUL_INITIALIZATION:</div><div class=\"line\">            return StaticLoggerBinder.getSingleton().getLoggerFactory();</div><div class=\"line\">        case NOP_FALLBACK_INITIALIZATION:</div><div class=\"line\">            return NOP_FALLBACK_FACTORY;</div><div class=\"line\">        case FAILED_INITIALIZATION:</div><div class=\"line\">            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);</div><div class=\"line\">        case ONGOING_INITIALIZATION:</div><div class=\"line\">            // support re-entrant behavior.</div><div class=\"line\">            // See also http://jira.qos.ch/browse/SLF4J-97</div><div class=\"line\">            return SUBST_FACTORY;</div><div class=\"line\">        &#125;</div><div class=\"line\">        throw new IllegalStateException(&quot;Unreachable code&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意<code>return StaticLoggerBinder.getSingleton().getLoggerFactory();</code>这行，StaticLoggerBinder是slf4j-log4j12.jar中的类</p>\n<p>slf4j-log4j12.jar: org.slf4j.impl.StaticLoggerBinder<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private StaticLoggerBinder() &#123;</div><div class=\"line\">        loggerFactory = new Log4jLoggerFactory();</div><div class=\"line\">        try &#123;</div><div class=\"line\">            @SuppressWarnings(&quot;unused&quot;)</div><div class=\"line\">            Level level = Level.TRACE;</div><div class=\"line\">        &#125; catch (NoSuchFieldError nsfe) &#123;</div><div class=\"line\">            Util.report(&quot;This version of SLF4J requires log4j version 1.2.12 or later. See also http://www.slf4j.org/codes.html#log4j_version&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>slf4j-log4j12.jar: org.slf4j.impl.Log4jLoggerFactory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Log4jLoggerFactory() &#123;</div><div class=\"line\">        loggerMap = new ConcurrentHashMap&lt;String, Logger&gt;();</div><div class=\"line\">        // force log4j to initialize</div><div class=\"line\">        org.apache.log4j.LogManager.getRootLogger();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意<code>org.apache.log4j.LogManager.getRootLogger();</code>初始化了log4j为具体的日志实现</p>\n<p>追踪源代码还可以发现，我们在代码中调用的<code>LoggerFactory.getLogger(Test.class);</code>最终返回的是org.apache.log4j.Logger实例，也就是说，日志实现最终托付给了log4j</p>\n<h2 id=\"log4j的使用\"><a href=\"#log4j的使用\" class=\"headerlink\" title=\"log4j的使用\"></a>log4j的使用</h2><h3 id=\"日志组件\"><a href=\"#日志组件\" class=\"headerlink\" title=\"日志组件\"></a>日志组件</h3><p>Loggers：Logger负责捕捉事件并将其发送给合适的Appender。</p>\n<p>Appenders：也被称为Handlers，负责将日志事件记录到目标位置。在将日志事件输出之前，Appenders使用Layouts来对事件进行格式化处理。</p>\n<p>Layouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的最终形式。</p>\n<p>当Logger记录一个事件时，它将事件转发给适当的Appender。然后Appender使用Layout来对日志记录进行格式化，并将其发送给控制台、文件或者其它目标位置。</p>\n<h3 id=\"日志级别\"><a href=\"#日志级别\" class=\"headerlink\" title=\"日志级别\"></a>日志级别</h3><p>每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：</p>\n<p>org.apache.log4j.Level<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final static int OFF_INT = Integer.MAX_VALUE;</div><div class=\"line\">public final static int FATAL_INT = 50000;</div><div class=\"line\">public final static int ERROR_INT = 40000;</div><div class=\"line\">public final static int WARN_INT  = 30000;</div><div class=\"line\">public final static int INFO_INT  = 20000;</div><div class=\"line\">public final static int DEBUG_INT = 10000;</div><div class=\"line\">  //public final static int FINE_INT = DEBUG_INT;</div><div class=\"line\">public final static int ALL_INT = Integer.MIN_VALUE;</div></pre></td></tr></table></figure></p>\n<p>A：off 最高等级，用于关闭所有日志记录。</p>\n<p>B：fatal 指出每个严重的错误事件将会导致应用程序的退出。</p>\n<p>C：error 指出虽然发生错误事件，但仍然不影响系统的继续运行。</p>\n<p>D：warm 表明会出现潜在的错误情形。</p>\n<p>E：info 一般和在粗粒度级别上，强调应用程序的运行全程。</p>\n<p>F：debug 一般用于细粒度级别上，对调试应用程序非常有帮助。</p>\n<p>G：all 最低等级，用于打开所有日志记录。</p>\n<p>我们一般只是用error,warn,info和debug就够了。</p>\n<h3 id=\"配置文件编写\"><a href=\"#配置文件编写\" class=\"headerlink\" title=\"配置文件编写\"></a>配置文件编写</h3><p>了解了组件和日志级别，我们可以编写自己的配置文件，log4j.properties放到类路径下，如果缺少了配置文件，log4j会报错。我们也可以使用<code>PropertyConfigurator.configure ( String configFilename)</code>来指定配置文件</p>\n<h4 id=\"配置logger\"><a href=\"#配置logger\" class=\"headerlink\" title=\"配置logger\"></a>配置logger</h4><p>配置根logger：<code>log4j.rootLogger = [ level ] , appenderName, appenderName, …</code></p>\n<p>比如：<code>log4j.rootLogger=INFO,stdout</code></p>\n<p>level为日志级别，表示这个logger只打印级别大于等于level的日志。</p>\n<p>appenderName定义了如何处理日志，即把日志输出到哪个地方，如何输出。</p>\n<p>可以看出，一个logger可以根据appender同时输出到多个地方，logger与appender是一对多的关系。</p>\n<p>我们也可以定义自己的logger：<code>log4j.logger.yukai=DEBUG,stdout</code></p>\n<h4 id=\"配置appender\"><a href=\"#配置appender\" class=\"headerlink\" title=\"配置appender\"></a>配置appender</h4><p>appender定义了日志输出的目的地：<code>log4j.appender.appenderName = fully.qualified.name.of.appender.class</code></p>\n<p>其中，Log4j提供的常用的appender：</p>\n<p>org.apache.log4j.ConsoleAppender（控制台），</p>\n<p>org.apache.log4j.FileAppender（文件），</p>\n<p>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</p>\n<p>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），</p>\n<p>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</p>\n<p>我们还可以设置appender的属性，比如针对ConsoleAppender</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">属性\t                  描述</div><div class=\"line\">layout\t    Appender 使用 Layout 对象和与之关联的模式来格式化日志信息。</div><div class=\"line\">target\t    目的地可以是控制台、文件，或依赖于 appender 的对象。</div><div class=\"line\">level\t    级别用来控制过滤日志信息。</div><div class=\"line\">threshold\tAppender 可脱离于日志级别定义一个阀值级别，Appender 对象会忽略所有级别低于阀值级别的日志。</div><div class=\"line\">filter\t    Filter 对象可在级别基础之上分析日志信息，来决定 Appender 对象是否处理或忽略一条日志记录。</div></pre></td></tr></table></figure>\n<h4 id=\"配置layout\"><a href=\"#配置layout\" class=\"headerlink\" title=\"配置layout\"></a>配置layout</h4><p>一个appender可以关联某一个layout，用来格式化日志的输出。可用的layout有以下几种：</p>\n<p>org.apache.log4j.HTMLLayout（以HTML表格形式布局）， </p>\n<p>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， </p>\n<p>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， </p>\n<p>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</p>\n<p>可用的格式：</p>\n<p>%m 输出代码中指定的消息 </p>\n<p>%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL </p>\n<p>%r 输出自应用启动到输出该log信息耗费的毫秒数 </p>\n<p>%c 输出所属的类目，通常就是所在类的全名 </p>\n<p>%t 输出产生该日志事件的线程名 </p>\n<p>%n 输出一个回车换行符，Windows平台为”rn”，Unix平台为”n” </p>\n<p>%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 </p>\n<p>%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(Test Log4.java:10)</p>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</div><div class=\"line\">log4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</div></pre></td></tr></table></figure>\n<p>打印的信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ERROR] 2017-02-21 16:41:25,563 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)</div><div class=\"line\">info</div></pre></td></tr></table></figure>\n<h4 id=\"logger的继承关系\"><a href=\"#logger的继承关系\" class=\"headerlink\" title=\"logger的继承关系\"></a>logger的继承关系</h4><p>我们可以定义自己的logger：<code>log4j.logger.yukai=DEBUG,stdout</code></p>\n<p>其中，yukai指定了这个logger的名字，可以在代码中使用它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Logger logger = LoggerFactory.getLogger(&quot;yukai&quot;);</div></pre></td></tr></table></figure>\n<p>假如我们同时定义这样一个logger：<code>log4j.logger.yukai.child=DEBUG,stdout</code></p>\n<p>就表示yukai.child这个logger继承了yukai这个logger，更java中的包有些类似</p>\n<p>在代码中使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Logger logger = LoggerFactory.getLogger(&quot;yukai.child&quot;);</div></pre></td></tr></table></figure>\n<p>使用了该logger会默认实现自身的设定和父Logger的设定。比如使用该logger打印了一条debug信息，同样的打印动作会执行两次，因为父logger的打印动作也会实现。</p>\n<p>上面提到的rootlogger就是所有looger的根logger。</p>\n<p>我们经常在代码中使用 <code>public static Logger logger = LoggerFactory.getLogger(Test.calss);</code>这样的方式，因此我们可以通过指定包名的logger来控制某个包下面所有的logger输出。比如：</p>\n<p>我们指定：<code>log4j.logger.space.kyu=DEBUG,stdout</code>,就表示space.kyu包下面的所有logger(以LoggerFactory.getLogger(Test.calss);这种方式获取的)都继承该logger的设定。这在分层的应用或功能性应用中有可以用到。</p>\n<p>可以通过配置log4j.additivity.XXX=ture/false来打开或关闭继承功能；若为 false,表示Logger 的 appender 不继承它的父Logger； 若为true，则继承，这样就兼有自身的设定和父Logger的设定。</p>\n<h3 id=\"MDC的使用\"><a href=\"#MDC的使用\" class=\"headerlink\" title=\"MDC的使用\"></a>MDC的使用</h3><blockquote>\n<p>在一个高访问量的 Web 应用中，经常要在同一时刻处理大量的用户请求。Web 服务器会为每一个请求分配一个线程，每一个线程都会向日志系统输入一些信息，通常日志系统都是按照时间顺序而不是用户顺序排列这些信息的，这些线程的交替运行会让所有用户的处理信息交错在一起，让人很难分辨出那些记录是同一个用户产生的。另外，高可用性的网站经常会使用负载均衡系统平衡网络流量，这样一个用户的操作记录很可能会分布在多个 Web 服务器上，如果我们没有一种方法来标示一条记录是哪个用户产生的，从这众多的日志信息中筛选出对我们有用的东西将是一项艰巨的工作。</p>\n</blockquote>\n<p>NDC或MDC就是用来解决这个问题的。</p>\n<p>MDC 可以看成是一个与当前线程绑定的哈希表，可以往其中添加键值对。<br>MDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。<br>当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。<br>对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class App &#123;</div><div class=\"line\">\tprivate static final Logger logger = LoggerFactory.getLogger(App.class);</div><div class=\"line\"></div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tnew App().log(&quot;main thread&quot;);</div><div class=\"line\">\t\tnew Thread()&#123;</div><div class=\"line\">\t\t\tpublic void run() &#123;</div><div class=\"line\">\t\t\t\tnew App().log(&quot;sub thread&quot;);</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t&#125;.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic void log(String arg) &#123;</div><div class=\"line\">\t\tMDC.put(&quot;username&quot;, &quot;Yukai&quot;);</div><div class=\"line\">\t\tlogger.info(&quot;This message from : &#123;&#125;&quot;, arg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>设置appender: <code>log4j.appender.stdout.layout.ConversionPattern=%X{username} %d{yyyy-MM-dd HH:mm:ss} [%p] %c - %m%n</code></p>\n<p>输出</p>\n<p>Yukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : main thread<br>Yukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : sub thread</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.slf4j.org/manual.html\" target=\"_blank\" rel=\"external\">SLF4J user manual</a></p>\n<p><a href=\"http://blog.csdn.net/qingkangxu/article/details/7514770\" target=\"_blank\" rel=\"external\">JDK Logging深入分析</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/406618\" target=\"_blank\" rel=\"external\">jdk-logging、log4j、logback日志介绍及原理</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/407895\" target=\"_blank\" rel=\"external\">commons-logging与jdk-logging、log4j1、log4j2、logback的集成原理</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/408382\" target=\"_blank\" rel=\"external\">slf4j与jdk-logging、log4j1、log4j2、logback的集成原理</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/410224\" target=\"_blank\" rel=\"external\">slf4j、jcl、jul、log4j1、log4j2、logback大总结</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/\" target=\"_blank\" rel=\"external\">Java 日志管理最佳实践</a></p>\n","excerpt":"","more":"<blockquote>\n<p>之前在web项目中用到了日志，日志在web应用中很重要，特别是对于程序员追查bug而言。但是由于对混乱的日志框架体系不是十分清楚，导致各种jar包冲突和日志不正常输出。今天来总结一下日志框架的使用<br>主要介绍日志门面slf4j结合日志实现log4j。关于其他的日志框架介绍和使用，参考链接里列出了前辈总结的很好的资料，相信读完之后一定会有收获。</p>\n</blockquote>\n<h2 id=\"日志门面和实际日志框架\"><a href=\"#日志门面和实际日志框架\" class=\"headerlink\" title=\"日志门面和实际日志框架\"></a>日志门面和实际日志框架</h2><p>日志框架有：jdk自带的logging(jul)，log4j1、log4j2、logback<br>日志门面有：apache commons-logging、slf4j</p>\n<p>日志框架很好理解，就是提供日志api，使我们可以很轻易的，有组织有规范的输出日志。日志门面的作用是在日志记录实现的基础上提供一个封装的 API 层次，<br>对日志记录 API 的使用者提供一个统一的接口，使得可以自由切换不同的日志记录实现。日志门面就好比java中的jdbc规范接口，各个数据库厂家实现的jdbc驱动程序就是实际的日志框架，<br>他们遵循了这个规范，使得我们在编写java程序时不用考虑底层驱动的不同，只需调用jdbc规范接口即可。这是典型的面向对象思想。</p>\n<h2 id=\"slf4j的使用\"><a href=\"#slf4j的使用\" class=\"headerlink\" title=\"slf4j的使用\"></a>slf4j的使用</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><img src=\"https://www.slf4j.org/images/concrete-bindings.png\" alt=\"slf4j使用\"></p>\n<p>上图来自slf4j官网</p>\n<p>slf4j-api.jar包含了slf4j的抽象层API，我们在代码中调用这个jar包中的接口。API层</p>\n<p>slf4j-log412.jar、slf4j-jdk14.jar等是slf4j通向具体日志实现框架的桥梁。中间层</p>\n<p>log4j.jar等则是具体的日志实现框架。实现层</p>\n<blockquote>\n<p>SLF4J does not rely on any special class loader machinery. In fact, each SLF4J binding is hardwired at compile time to use one and only one specific logging framework. For example, the slf4j-log4j12-1.7.23.jar binding is bound at compile time to use log4j. In your code, in addition to slf4j-api-1.7.23.jar, you simply drop one and only one binding of your choice onto the appropriate class path location. Do not place more than one binding on your class path. Here is a graphical illustration of the general idea.</p>\n</blockquote>\n<p>上面这段话的意思大概是，我们不应该在classpath中绑定多于一个的中间层，否则会导致jar包冲突或者输出混乱。</p>\n<blockquote>\n<p>To switch logging frameworks, just replace slf4j bindings on your class path. For example, to switch from java.util.logging to log4j, just replace slf4j-jdk14-1.7.23.jar with slf4j-log4j12-1.7.23.jar.</p>\n</blockquote>\n<p>当我们需要将日志实现由jul切换到log4j时，仅仅把中间层替换，同时切换实现层即可，并不需要修改代码。这就是日志门面的好处。不过实际应用中，需要切换日志实现的场景貌似不是很多。</p>\n<h3 id=\"slf4j结合log4j\"><a href=\"#slf4j结合log4j\" class=\"headerlink\" title=\"slf4j结合log4j\"></a>slf4j结合log4j</h3><h4 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h4><p>需要的jar包：slf4j-api.jar、slf4j-log4j12.jar、log4j.jar</p>\n<p>对应的maven依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;1.7.23&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div><div class=\"line\">&lt;dependency&gt; </div><div class=\"line\">  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class=\"line\">  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</div><div class=\"line\">  &lt;version&gt;1.7.23&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;log4j&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;1.2.17&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>编写log4j.properties配置文件，放到类路径下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">log4j.rootLogger=INFO,stdout</div><div class=\"line\"></div><div class=\"line\">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</div><div class=\"line\">log4j.appender.stdout.Target=System.out</div><div class=\"line\">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</div><div class=\"line\">log4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</div></pre></td></tr></table></figure>\n<p>java代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">package space.kyu.LogTest.log4j;</div><div class=\"line\"></div><div class=\"line\">import org.slf4j.Logger;</div><div class=\"line\">import org.slf4j.LoggerFactory;</div><div class=\"line\"></div><div class=\"line\">public class Test &#123;</div><div class=\"line\">\tpublic static Logger logger = LoggerFactory.getLogger(Test.class);</div><div class=\"line\">\t</div><div class=\"line\">\tpublic void test() &#123;</div><div class=\"line\">\t\tlogger.info(&quot;info&quot;);</div><div class=\"line\">\t\tlogger.debug(&quot;debug&quot;);</div><div class=\"line\">\t\tlogger.warn(&quot;warn&quot;);</div><div class=\"line\">\t\tlogger.error(&quot;error&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tnew Test().test();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[INFO ] 2017-02-21 14:52:28,083 method:space.kyu.LogTest.log4j.Test.test(Test.java:10)</div><div class=\"line\">info</div><div class=\"line\">[WARN ] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:12)</div><div class=\"line\">warn</div><div class=\"line\">[ERROR] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)</div><div class=\"line\">error</div></pre></td></tr></table></figure>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>slf4j-api.jar: org.slf4j.LoggerFactory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Logger getLogger(String name) &#123;</div><div class=\"line\">   ILoggerFactory iLoggerFactory = getILoggerFactory();</div><div class=\"line\">    return iLoggerFactory.getLogger(name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到，主要分为两部分，获取ILoggerFactory，使用ILoggerFactory获取logger.</p>\n<p>slf4j-api.jar: org.slf4j.LoggerFactory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static ILoggerFactory getILoggerFactory() &#123;</div><div class=\"line\">        if (INITIALIZATION_STATE == UNINITIALIZED) &#123;</div><div class=\"line\">            synchronized (LoggerFactory.class) &#123;</div><div class=\"line\">                if (INITIALIZATION_STATE == UNINITIALIZED) &#123;</div><div class=\"line\">                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;</div><div class=\"line\">                    performInitialization();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        switch (INITIALIZATION_STATE) &#123;</div><div class=\"line\">        case SUCCESSFUL_INITIALIZATION:</div><div class=\"line\">            return StaticLoggerBinder.getSingleton().getLoggerFactory();</div><div class=\"line\">        case NOP_FALLBACK_INITIALIZATION:</div><div class=\"line\">            return NOP_FALLBACK_FACTORY;</div><div class=\"line\">        case FAILED_INITIALIZATION:</div><div class=\"line\">            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);</div><div class=\"line\">        case ONGOING_INITIALIZATION:</div><div class=\"line\">            // support re-entrant behavior.</div><div class=\"line\">            // See also http://jira.qos.ch/browse/SLF4J-97</div><div class=\"line\">            return SUBST_FACTORY;</div><div class=\"line\">        &#125;</div><div class=\"line\">        throw new IllegalStateException(&quot;Unreachable code&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意<code>return StaticLoggerBinder.getSingleton().getLoggerFactory();</code>这行，StaticLoggerBinder是slf4j-log4j12.jar中的类</p>\n<p>slf4j-log4j12.jar: org.slf4j.impl.StaticLoggerBinder<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private StaticLoggerBinder() &#123;</div><div class=\"line\">        loggerFactory = new Log4jLoggerFactory();</div><div class=\"line\">        try &#123;</div><div class=\"line\">            @SuppressWarnings(&quot;unused&quot;)</div><div class=\"line\">            Level level = Level.TRACE;</div><div class=\"line\">        &#125; catch (NoSuchFieldError nsfe) &#123;</div><div class=\"line\">            Util.report(&quot;This version of SLF4J requires log4j version 1.2.12 or later. See also http://www.slf4j.org/codes.html#log4j_version&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>slf4j-log4j12.jar: org.slf4j.impl.Log4jLoggerFactory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Log4jLoggerFactory() &#123;</div><div class=\"line\">        loggerMap = new ConcurrentHashMap&lt;String, Logger&gt;();</div><div class=\"line\">        // force log4j to initialize</div><div class=\"line\">        org.apache.log4j.LogManager.getRootLogger();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意<code>org.apache.log4j.LogManager.getRootLogger();</code>初始化了log4j为具体的日志实现</p>\n<p>追踪源代码还可以发现，我们在代码中调用的<code>LoggerFactory.getLogger(Test.class);</code>最终返回的是org.apache.log4j.Logger实例，也就是说，日志实现最终托付给了log4j</p>\n<h2 id=\"log4j的使用\"><a href=\"#log4j的使用\" class=\"headerlink\" title=\"log4j的使用\"></a>log4j的使用</h2><h3 id=\"日志组件\"><a href=\"#日志组件\" class=\"headerlink\" title=\"日志组件\"></a>日志组件</h3><p>Loggers：Logger负责捕捉事件并将其发送给合适的Appender。</p>\n<p>Appenders：也被称为Handlers，负责将日志事件记录到目标位置。在将日志事件输出之前，Appenders使用Layouts来对事件进行格式化处理。</p>\n<p>Layouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的最终形式。</p>\n<p>当Logger记录一个事件时，它将事件转发给适当的Appender。然后Appender使用Layout来对日志记录进行格式化，并将其发送给控制台、文件或者其它目标位置。</p>\n<h3 id=\"日志级别\"><a href=\"#日志级别\" class=\"headerlink\" title=\"日志级别\"></a>日志级别</h3><p>每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：</p>\n<p>org.apache.log4j.Level<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final static int OFF_INT = Integer.MAX_VALUE;</div><div class=\"line\">public final static int FATAL_INT = 50000;</div><div class=\"line\">public final static int ERROR_INT = 40000;</div><div class=\"line\">public final static int WARN_INT  = 30000;</div><div class=\"line\">public final static int INFO_INT  = 20000;</div><div class=\"line\">public final static int DEBUG_INT = 10000;</div><div class=\"line\">  //public final static int FINE_INT = DEBUG_INT;</div><div class=\"line\">public final static int ALL_INT = Integer.MIN_VALUE;</div></pre></td></tr></table></figure></p>\n<p>A：off 最高等级，用于关闭所有日志记录。</p>\n<p>B：fatal 指出每个严重的错误事件将会导致应用程序的退出。</p>\n<p>C：error 指出虽然发生错误事件，但仍然不影响系统的继续运行。</p>\n<p>D：warm 表明会出现潜在的错误情形。</p>\n<p>E：info 一般和在粗粒度级别上，强调应用程序的运行全程。</p>\n<p>F：debug 一般用于细粒度级别上，对调试应用程序非常有帮助。</p>\n<p>G：all 最低等级，用于打开所有日志记录。</p>\n<p>我们一般只是用error,warn,info和debug就够了。</p>\n<h3 id=\"配置文件编写\"><a href=\"#配置文件编写\" class=\"headerlink\" title=\"配置文件编写\"></a>配置文件编写</h3><p>了解了组件和日志级别，我们可以编写自己的配置文件，log4j.properties放到类路径下，如果缺少了配置文件，log4j会报错。我们也可以使用<code>PropertyConfigurator.configure ( String configFilename)</code>来指定配置文件</p>\n<h4 id=\"配置logger\"><a href=\"#配置logger\" class=\"headerlink\" title=\"配置logger\"></a>配置logger</h4><p>配置根logger：<code>log4j.rootLogger = [ level ] , appenderName, appenderName, …</code></p>\n<p>比如：<code>log4j.rootLogger=INFO,stdout</code></p>\n<p>level为日志级别，表示这个logger只打印级别大于等于level的日志。</p>\n<p>appenderName定义了如何处理日志，即把日志输出到哪个地方，如何输出。</p>\n<p>可以看出，一个logger可以根据appender同时输出到多个地方，logger与appender是一对多的关系。</p>\n<p>我们也可以定义自己的logger：<code>log4j.logger.yukai=DEBUG,stdout</code></p>\n<h4 id=\"配置appender\"><a href=\"#配置appender\" class=\"headerlink\" title=\"配置appender\"></a>配置appender</h4><p>appender定义了日志输出的目的地：<code>log4j.appender.appenderName = fully.qualified.name.of.appender.class</code></p>\n<p>其中，Log4j提供的常用的appender：</p>\n<p>org.apache.log4j.ConsoleAppender（控制台），</p>\n<p>org.apache.log4j.FileAppender（文件），</p>\n<p>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</p>\n<p>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），</p>\n<p>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</p>\n<p>我们还可以设置appender的属性，比如针对ConsoleAppender</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">属性\t                  描述</div><div class=\"line\">layout\t    Appender 使用 Layout 对象和与之关联的模式来格式化日志信息。</div><div class=\"line\">target\t    目的地可以是控制台、文件，或依赖于 appender 的对象。</div><div class=\"line\">level\t    级别用来控制过滤日志信息。</div><div class=\"line\">threshold\tAppender 可脱离于日志级别定义一个阀值级别，Appender 对象会忽略所有级别低于阀值级别的日志。</div><div class=\"line\">filter\t    Filter 对象可在级别基础之上分析日志信息，来决定 Appender 对象是否处理或忽略一条日志记录。</div></pre></td></tr></table></figure>\n<h4 id=\"配置layout\"><a href=\"#配置layout\" class=\"headerlink\" title=\"配置layout\"></a>配置layout</h4><p>一个appender可以关联某一个layout，用来格式化日志的输出。可用的layout有以下几种：</p>\n<p>org.apache.log4j.HTMLLayout（以HTML表格形式布局）， </p>\n<p>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， </p>\n<p>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， </p>\n<p>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</p>\n<p>可用的格式：</p>\n<p>%m 输出代码中指定的消息 </p>\n<p>%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL </p>\n<p>%r 输出自应用启动到输出该log信息耗费的毫秒数 </p>\n<p>%c 输出所属的类目，通常就是所在类的全名 </p>\n<p>%t 输出产生该日志事件的线程名 </p>\n<p>%n 输出一个回车换行符，Windows平台为”rn”，Unix平台为”n” </p>\n<p>%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 </p>\n<p>%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(Test Log4.java:10)</p>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</div><div class=\"line\">log4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</div></pre></td></tr></table></figure>\n<p>打印的信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ERROR] 2017-02-21 16:41:25,563 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)</div><div class=\"line\">info</div></pre></td></tr></table></figure>\n<h4 id=\"logger的继承关系\"><a href=\"#logger的继承关系\" class=\"headerlink\" title=\"logger的继承关系\"></a>logger的继承关系</h4><p>我们可以定义自己的logger：<code>log4j.logger.yukai=DEBUG,stdout</code></p>\n<p>其中，yukai指定了这个logger的名字，可以在代码中使用它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Logger logger = LoggerFactory.getLogger(&quot;yukai&quot;);</div></pre></td></tr></table></figure>\n<p>假如我们同时定义这样一个logger：<code>log4j.logger.yukai.child=DEBUG,stdout</code></p>\n<p>就表示yukai.child这个logger继承了yukai这个logger，更java中的包有些类似</p>\n<p>在代码中使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Logger logger = LoggerFactory.getLogger(&quot;yukai.child&quot;);</div></pre></td></tr></table></figure>\n<p>使用了该logger会默认实现自身的设定和父Logger的设定。比如使用该logger打印了一条debug信息，同样的打印动作会执行两次，因为父logger的打印动作也会实现。</p>\n<p>上面提到的rootlogger就是所有looger的根logger。</p>\n<p>我们经常在代码中使用 <code>public static Logger logger = LoggerFactory.getLogger(Test.calss);</code>这样的方式，因此我们可以通过指定包名的logger来控制某个包下面所有的logger输出。比如：</p>\n<p>我们指定：<code>log4j.logger.space.kyu=DEBUG,stdout</code>,就表示space.kyu包下面的所有logger(以LoggerFactory.getLogger(Test.calss);这种方式获取的)都继承该logger的设定。这在分层的应用或功能性应用中有可以用到。</p>\n<p>可以通过配置log4j.additivity.XXX=ture/false来打开或关闭继承功能；若为 false,表示Logger 的 appender 不继承它的父Logger； 若为true，则继承，这样就兼有自身的设定和父Logger的设定。</p>\n<h3 id=\"MDC的使用\"><a href=\"#MDC的使用\" class=\"headerlink\" title=\"MDC的使用\"></a>MDC的使用</h3><blockquote>\n<p>在一个高访问量的 Web 应用中，经常要在同一时刻处理大量的用户请求。Web 服务器会为每一个请求分配一个线程，每一个线程都会向日志系统输入一些信息，通常日志系统都是按照时间顺序而不是用户顺序排列这些信息的，这些线程的交替运行会让所有用户的处理信息交错在一起，让人很难分辨出那些记录是同一个用户产生的。另外，高可用性的网站经常会使用负载均衡系统平衡网络流量，这样一个用户的操作记录很可能会分布在多个 Web 服务器上，如果我们没有一种方法来标示一条记录是哪个用户产生的，从这众多的日志信息中筛选出对我们有用的东西将是一项艰巨的工作。</p>\n</blockquote>\n<p>NDC或MDC就是用来解决这个问题的。</p>\n<p>MDC 可以看成是一个与当前线程绑定的哈希表，可以往其中添加键值对。<br>MDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。<br>当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。<br>对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class App &#123;</div><div class=\"line\">\tprivate static final Logger logger = LoggerFactory.getLogger(App.class);</div><div class=\"line\"></div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tnew App().log(&quot;main thread&quot;);</div><div class=\"line\">\t\tnew Thread()&#123;</div><div class=\"line\">\t\t\tpublic void run() &#123;</div><div class=\"line\">\t\t\t\tnew App().log(&quot;sub thread&quot;);</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t&#125;.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic void log(String arg) &#123;</div><div class=\"line\">\t\tMDC.put(&quot;username&quot;, &quot;Yukai&quot;);</div><div class=\"line\">\t\tlogger.info(&quot;This message from : &#123;&#125;&quot;, arg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>设置appender: <code>log4j.appender.stdout.layout.ConversionPattern=%X{username} %d{yyyy-MM-dd HH:mm:ss} [%p] %c - %m%n</code></p>\n<p>输出</p>\n<p>Yukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : main thread<br>Yukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : sub thread</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.slf4j.org/manual.html\">SLF4J user manual</a></p>\n<p><a href=\"http://blog.csdn.net/qingkangxu/article/details/7514770\">JDK Logging深入分析</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/406618\">jdk-logging、log4j、logback日志介绍及原理</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/407895\">commons-logging与jdk-logging、log4j1、log4j2、logback的集成原理</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/408382\">slf4j与jdk-logging、log4j1、log4j2、logback的集成原理</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/410224\">slf4j、jcl、jul、log4j1、log4j2、logback大总结</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/\">Java 日志管理最佳实践</a></p>\n"},{"layout":"post","title":"java泛型学习","date":"2016-10-10T12:05:03.000Z","_content":"\n有一段时间没有更新博客了，过了国庆之后，好像变得更懒了~~前两天开发了一个用于记账的公众号，功能很简单，就是普通的增删查改...由于是个人开发者，无法进行公众号的认证，所以没什么高级的接口权限，只能搞的简陋一点了...下一步计划再丰富丰富，目前想到了这几个功能：配合有道或者金山词霸的Api进行中英互译（API怎么用，可不可以用目前还不清楚），配合微博的Api接口整点微博热门什么的，配合豆瓣的Api接口做一个电影或者书籍查询的功能等等....公众号的服务器代码目前还部署在自己的电脑上，用nat123做了一下公网ip的映射，接下来考虑是不是要换成云服务器更为妥当....\n\n公众号在这里：\n\n{% asset_img easybill.jpg EasyBill %}\n\n目前，公众号已经开源：[WechatSubscriptionNumber](https://github.com/Hikyu/WechatSubscriptionNumber)\n\n好了，言归正传。今天学习了java的泛型知识，不总结一下老是觉得跟没学一样...\n\n## 泛型的好处\n\n使用泛型的好处我觉得有两点：1：类型安全  2：减少类型强转\n\n下面通过一个例子说明:\n\n假设有一个Test类，通用的实现是:\n\n```java\nclass Test {\n\tprivate Object o;\n\n\tpublic Test(Object o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic Object getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(Object o) {\n\t\tthis.o = o;\n\t}\n}\n```\n我们可以这样使用它：\n\n```java\npublic static void main(String[] args) {\n\tTest test = new Test(new Integer(1));\n\t//编译时不报错\n\t//运行时报  java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\n\tString o = (String) test.getObject();\n}\n```\n\n看一个使用泛型的例子：\n\n```java\nclass Test<T> {\n\tprivate T o;\n\n\tpublic Test(T o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic T getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(T o) {\n\t\tthis.o = o;\n\t}\n}\n\npublic static void main(String[] args) {\n\tTest1<Integer> test = new Test1<Integer>(new Integer(1));\n\t//编译时报错，无法通过编译\n\t//String o = test.getObject();\n\n\t//正常运行\n\tInteger o = test.getObject();\n}\n```\n从上面的对比中能够看出两点：\n\n1.使用泛型之后在编译时报错而非运行时，减少了出错的几率；\n\n2.使用泛型之后编译器不再要求强转\n\n## 定义泛型\n\n泛型的机制能够在定义类、接口、方法时把类型参数化，也就是类似于方法的形参一样，把类型当做参数使用。\n\n泛型参数部分使用`<>`包裹起来，比如`<T>`，T声明了一种类型，习惯上，这个类型参数使用单个大写字母来表示，指示所定义的参数类型。有如下惯例：\n\nE：表示元素\n\nT：表示类型\n\nK：表示键\n\nV：表示值\n\nN：表示数字\n\n### 定义泛型类\n\n上面的例子就是一个很好的演示\n\n```java\nclass Test<T> {\n\tprivate T o;\n\n\tpublic Test(T o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic T getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(T o) {\n\t\tthis.o = o;\n\t}\n}\n```\n\n使用泛型定义类之后，泛型参数 T 可以运用到该类中：可以声明成员变量类型、可以声明成员函数返回值类型、可以声明成员函数参数类型。\n\n要注意：泛型参数T不能用于声明静态变量，同时也不能用于new一个对象比如：T o = new T();\n\n下面的类型擦除会说到原因。\n\n### 定义泛型接口\n\n```java\ninterface Test<T> {\n\tpublic T test(T t);\n}\n```\n使用泛型定义接口之后，泛型参数 T 可以运用到该接口中：可以声明接口函数返回值类型、可以声明接口函数参数类型。\n\n\n### 定义泛型方法\n\n可以单独给方法使用泛型，而不是泛化整个类：\n\n```java\npublic static <T> T getT(T t){\n\treturn t;\n}\n```\n使用泛型定义方法后，泛型参数 T 可以声明该方法的返回值类型、可以声明该方法的参数类型。\n\n要注意，定义方法所用的泛型参数需要在修饰符之后添加。\n\n### 定义多个泛型参数\n\n以接口为例：\n\n```java\ninterface Test<T, S> {\n\tpublic T testT(T t);\n\tpublic S testS(S s);\n}\n\npublic static void main(String[] args) {\n    //编译时报错\n\t//getT(\"s\");\n}\n```\n多个泛型参数在尖括号中使用逗号隔开。类的泛化与方法的泛化类似。\n\n### 泛型参数的界限\n\n定义泛型参数界限有这样两种意义：\n\n1.有时候我们希望限定这个泛型参数的类型为某个类的子类或者超类；\n\n2.上面的例子中可以看到，我们定义了泛型参数，向方法中传入某种类型，这种类型是未知的，因此我们无法使用这种类型定义的变量，不能够调用它的方法。\n\n```java\npublic static <T extends Number> Integer getT(T t) {\n\treturn  new Integer(t.intValue());\n}\n```\n上面例子中，`<T extends A>`表示T是A或A的子类，他限定了传入泛型方法参数的类型必须为A或A的子类，同时，在方法体中我们也可以使用t这个实参就像使用A的实例一样，调用Number具有的public方法。\n\n除了`<T extends A>`限定T是A或A的子类外，还可以使用`<T super A> `这种方式来限定T是A或A的超类。\n\nA可以是某个类或者接口。\n\n除此以外，还可以为泛型参数限定多个限制范围，如`<T extends A & B & C>`，限定范围中最多只能有一个类(某个类只能有一个父类~~)，并且他必须是限定列表中的第一个。\n\n```java\nClass A { // }\ninterface B { // }\ninterface C { // }\n\n//正确\nclass D <T extends A & B & C> { // }\n//编译时报错\nclass D <T extends A & B & C> { // }\n```\n\n### 泛型的继承\n\n看一下jdk中List的泛型继承例子：\n\n```java\npublic interface List<E> extends Collection<E>{//...}\n```\n`List<String>` 就是 `Collection<String>` 的子类。\n\n假如定义自己的接口：\n\n```java\ninterface MyList<E,P> extends List<E> {\n  void setPay(E e,P p);\n  //...\n}\n```\n\n`MyList<String,String>`、`MyList<String,Integer>`、`MyList<String,Exception>`都是`List<String>`的子类。\n\n## 使用泛型\n\n上面的例子中已经列举了一些使用泛化类或者泛化函数的例子，但是还有一些问题需要指出：\n\n1.泛型参数只接受引用类型，不适用于基本类型\n\n比如：\n\n```java\nclass Test<T> {}\n\npublic static void main(String[] args) {\n    //无法通过编译，不接受int类型的泛化参数\n\t//Test<int> test = new Test();\n}\n```\n\n而我们使用泛化函数时：\n\n```java\npublic static void main(String[] args) {\n\tgetT(1);\n}\npublic static <T> void getT(T t) {\n}\n```\n是没有问题的，通过查看生成的字节码，发现getT(1)这个方法的字节码中1被自动装箱为Integer类型。\n\n2.通配符的使用\n\n考虑下面的情况：\n\n```java\nclass Test<T> {}\npublic static void getT(Test<Number> t) {\n}\n\npublic static void main(String[] args) {\n\tTest<Double> test = new Test();\n\t//编译时报错\n\t//getT(test);\n}\n```\n报错的原因很好理解，虽然Double是Number的子类，但Test<Double>并不是Test<Number>的子类，故类型检查无法通过。这一点一定要明白。\n\n那么如果我们确实想要传入一个Test<Double>类型的形参呢？可以使用通配符：\n\n```java\nclass Test<T> {}\npublic static void main(String[] args) {\n\t\tTest<Double> test = new Test();\n\t\t//正常运行\n\t\tgetT(test);\n}\npublic static void getT(Test<? extends Number> t) {\n}\n```\n`Test<? extends Number>`扩展了形参的类型，可以是`Test<Double>`、`Test<Integer>`等，尖括号中的类型必须是Number或继承于Number。同样的，通配符也适用于super，如`Test<? super A>`。\n\n如果类型参数中既没有extends 关键字，也没有super关键字，只有一个?，代表无限定通配符。\n\n`Test<?>`与`Test<Object>`并不相同，无论T是什么类型，`Test<T>` 是 `Test<?>`的子类，但是，`Test<T>` 不是 `Test<Object>` 的子类，想想上面的例子。\n\n通常在两种情况下会使用无限定通配符：\n\n1. 如果正在编写一个方法，可以使用Object类中提供的功能来实现\n\n2. 代码实现的功能与类型参数无关，比如List.clear()与List.size()方法，还有经常使用的`Class<?>`方法，其实现的功能都与类型参数无关。\n\n一般情况下，通配符`<? extends Number>`只是出现在使用泛型的时候，而不是定义泛型的时候，就像上面的例子那样。而`<T extends Number>`这种形式出现在定义泛型的时候，而不是使用泛型的时候，不要搞混了。\n\n结合泛型的继承和通配符的使用，理解一下泛型的类型系统，也就是泛型类的继承关系：\n\n以下内容来自：[Java深度历险（五）——Java泛型](http://www.infoq.com/cn/articles/cf-java-generics)\n\n***\n引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 `List<String>`和`List<Object>`这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：\n\n相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即`List<String>`是`Collection<String>` 的子类型，`List<String>`可以替换`Collection<String>`。这种情况也适用于带有上下界的类型声明。\n当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对`Collection<? extends Number>`来说，其子类型可以在Collection这个维度上展开，即`List<? extends Number>`和`Set<? extends Number>`等；也可以在Number这个层次上展开，即`Collection<Double>`和 `Collection<Integer>`等。如此循环下去，`ArrayList<Long>`和 `HashSet<Double>`等也都算是`Collection<? extends Number>`的子类型。\n如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。\n***\n\n关于通配符的理解可以参考[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)\n\n\n## 类型擦除\n\n类型擦除发生在编译阶段，对于运行期的JVM来说，`List<int>`与`List<String>`就是同一个类，因为在编译结束之后，生成的字节码文件中，他们都是List类型。\n\n1.java编译器会在编译前进行类型检查\n\njava编译器承担了所有泛型的类型安全检查工作。\n\n2.类型擦除后保留的原始类型\n\n原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。\n\n3.自动类型转换\n\n因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？\n\n比如：\n\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        ArrayList<Date> list=new ArrayList<Date>();  \n        list.add(new Date());  \n        Date myDate=list.get(0);  \n    }\n}  \n```\n`Date myDate=list.get(0);`这里我们并没有对其返回值进行强转就可以直接获取Date类型的返回值。原因在于在字节码当中，有checkcast这么一个操作帮助我们进行了强转，这是java自动进行的。\n\n更多的关于类型擦除的知识，参考[ java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题](http://blog.csdn.net/lonelyroamer/article/details/7868820)\n\n\n## 实践\n\n最近在重构公众号服务器的过程中，用到了泛型编程的知识。\n\n```java\npublic interface BaseServiceContext<T extends ReqBaseMessage, R> {\n\tpublic void selectService(T reqMeg);\n\n\tpublic R executeRequest();\n}\n```\n上面是一个选择service的上下文接口，接收到用户请求后通过这个接口选择对应的service并且执行service。这个接口相当于一个工厂和策略模式的结合体。下面是这个接口的一种实现：\n\n```java\n//请求为文本类型，返回string类型的处理结果\npublic class TextServiceContext implements BaseServiceContext<ReqTextMessage,String> {\n\n\t@Override\n\tpublic void selectService(ReqTextMessage reqMeg) {\n\t\t//.....\n\t}\n\n\t@Override\n\tpublic String executeRequest() {\n\t\t//.....\n\t}\n}\n```\n可以看到，BaseServiceContext<ReqTextMessage,String>限定了selectService方法的参数类型和executeRequest方法的返回值类型，使其能够灵活的支持各种类型的参数和返回值。\n\n看一下在没有学习泛型之前，这个接口是怎么实现的：\n\n```java\npublic interface BaseServiceContext {\n\tpublic void selectService(ReqBaseMessage reqMeg);\n\n\tpublic Object executeRequest();\n}\n\npublic class TextServiceContext implements BaseServiceContext {\n\n\t@Override\n\tpublic void selectService(ReqBaseMessage reqMeg) {\n\t\t//根据业务逻辑对reqMeg进行强转，需要程序员自己判断\n\t\t//很有可能强转失败\n\t}\n\n\t@Override\n\tpublic Object executeRequest() {\n\t\t//返回类型为object，在调用方法的外部强转为需要的类型\n\t\t//很有可能强转失败\n\t}\n}\n```\n可以看到没有使用泛型接口的情况下，类型不安全且增大了强转失败的风险。同时也需要程序员根据业务逻辑去判断该强转成什么类型。使用泛型接口之后就没有了这些问题，只需要在使用接口时声明好他的泛型参数就o了。\n\n上面只是我在开发过程中体会到泛型的一个好处，类似的例子还有很多。\n\n## 注意事项\n\n\n\n## 参考\n\n[java 泛型编程（一）](http://peiquan.blog.51cto.com/7518552/1302898)\n\n[泛型：工作原理及其重要性](http://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html)\n\n[Java深度历险（五）——Java泛型](http://www.infoq.com/cn/articles/cf-java-generics)\n\n[java泛型详解](http://blog.csdn.net/u012152619/article/details/47253811)\n\n[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)\n\n","source":"_posts/java泛型学习.md","raw":"---\nlayout: post\ntitle: java泛型学习\ndate: 2016-10-10 20:05:03\ncategories: 编程 \ntags:\n- java\n---\n\n有一段时间没有更新博客了，过了国庆之后，好像变得更懒了~~前两天开发了一个用于记账的公众号，功能很简单，就是普通的增删查改...由于是个人开发者，无法进行公众号的认证，所以没什么高级的接口权限，只能搞的简陋一点了...下一步计划再丰富丰富，目前想到了这几个功能：配合有道或者金山词霸的Api进行中英互译（API怎么用，可不可以用目前还不清楚），配合微博的Api接口整点微博热门什么的，配合豆瓣的Api接口做一个电影或者书籍查询的功能等等....公众号的服务器代码目前还部署在自己的电脑上，用nat123做了一下公网ip的映射，接下来考虑是不是要换成云服务器更为妥当....\n\n公众号在这里：\n\n{% asset_img easybill.jpg EasyBill %}\n\n目前，公众号已经开源：[WechatSubscriptionNumber](https://github.com/Hikyu/WechatSubscriptionNumber)\n\n好了，言归正传。今天学习了java的泛型知识，不总结一下老是觉得跟没学一样...\n\n## 泛型的好处\n\n使用泛型的好处我觉得有两点：1：类型安全  2：减少类型强转\n\n下面通过一个例子说明:\n\n假设有一个Test类，通用的实现是:\n\n```java\nclass Test {\n\tprivate Object o;\n\n\tpublic Test(Object o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic Object getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(Object o) {\n\t\tthis.o = o;\n\t}\n}\n```\n我们可以这样使用它：\n\n```java\npublic static void main(String[] args) {\n\tTest test = new Test(new Integer(1));\n\t//编译时不报错\n\t//运行时报  java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\n\tString o = (String) test.getObject();\n}\n```\n\n看一个使用泛型的例子：\n\n```java\nclass Test<T> {\n\tprivate T o;\n\n\tpublic Test(T o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic T getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(T o) {\n\t\tthis.o = o;\n\t}\n}\n\npublic static void main(String[] args) {\n\tTest1<Integer> test = new Test1<Integer>(new Integer(1));\n\t//编译时报错，无法通过编译\n\t//String o = test.getObject();\n\n\t//正常运行\n\tInteger o = test.getObject();\n}\n```\n从上面的对比中能够看出两点：\n\n1.使用泛型之后在编译时报错而非运行时，减少了出错的几率；\n\n2.使用泛型之后编译器不再要求强转\n\n## 定义泛型\n\n泛型的机制能够在定义类、接口、方法时把类型参数化，也就是类似于方法的形参一样，把类型当做参数使用。\n\n泛型参数部分使用`<>`包裹起来，比如`<T>`，T声明了一种类型，习惯上，这个类型参数使用单个大写字母来表示，指示所定义的参数类型。有如下惯例：\n\nE：表示元素\n\nT：表示类型\n\nK：表示键\n\nV：表示值\n\nN：表示数字\n\n### 定义泛型类\n\n上面的例子就是一个很好的演示\n\n```java\nclass Test<T> {\n\tprivate T o;\n\n\tpublic Test(T o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic T getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(T o) {\n\t\tthis.o = o;\n\t}\n}\n```\n\n使用泛型定义类之后，泛型参数 T 可以运用到该类中：可以声明成员变量类型、可以声明成员函数返回值类型、可以声明成员函数参数类型。\n\n要注意：泛型参数T不能用于声明静态变量，同时也不能用于new一个对象比如：T o = new T();\n\n下面的类型擦除会说到原因。\n\n### 定义泛型接口\n\n```java\ninterface Test<T> {\n\tpublic T test(T t);\n}\n```\n使用泛型定义接口之后，泛型参数 T 可以运用到该接口中：可以声明接口函数返回值类型、可以声明接口函数参数类型。\n\n\n### 定义泛型方法\n\n可以单独给方法使用泛型，而不是泛化整个类：\n\n```java\npublic static <T> T getT(T t){\n\treturn t;\n}\n```\n使用泛型定义方法后，泛型参数 T 可以声明该方法的返回值类型、可以声明该方法的参数类型。\n\n要注意，定义方法所用的泛型参数需要在修饰符之后添加。\n\n### 定义多个泛型参数\n\n以接口为例：\n\n```java\ninterface Test<T, S> {\n\tpublic T testT(T t);\n\tpublic S testS(S s);\n}\n\npublic static void main(String[] args) {\n    //编译时报错\n\t//getT(\"s\");\n}\n```\n多个泛型参数在尖括号中使用逗号隔开。类的泛化与方法的泛化类似。\n\n### 泛型参数的界限\n\n定义泛型参数界限有这样两种意义：\n\n1.有时候我们希望限定这个泛型参数的类型为某个类的子类或者超类；\n\n2.上面的例子中可以看到，我们定义了泛型参数，向方法中传入某种类型，这种类型是未知的，因此我们无法使用这种类型定义的变量，不能够调用它的方法。\n\n```java\npublic static <T extends Number> Integer getT(T t) {\n\treturn  new Integer(t.intValue());\n}\n```\n上面例子中，`<T extends A>`表示T是A或A的子类，他限定了传入泛型方法参数的类型必须为A或A的子类，同时，在方法体中我们也可以使用t这个实参就像使用A的实例一样，调用Number具有的public方法。\n\n除了`<T extends A>`限定T是A或A的子类外，还可以使用`<T super A> `这种方式来限定T是A或A的超类。\n\nA可以是某个类或者接口。\n\n除此以外，还可以为泛型参数限定多个限制范围，如`<T extends A & B & C>`，限定范围中最多只能有一个类(某个类只能有一个父类~~)，并且他必须是限定列表中的第一个。\n\n```java\nClass A { // }\ninterface B { // }\ninterface C { // }\n\n//正确\nclass D <T extends A & B & C> { // }\n//编译时报错\nclass D <T extends A & B & C> { // }\n```\n\n### 泛型的继承\n\n看一下jdk中List的泛型继承例子：\n\n```java\npublic interface List<E> extends Collection<E>{//...}\n```\n`List<String>` 就是 `Collection<String>` 的子类。\n\n假如定义自己的接口：\n\n```java\ninterface MyList<E,P> extends List<E> {\n  void setPay(E e,P p);\n  //...\n}\n```\n\n`MyList<String,String>`、`MyList<String,Integer>`、`MyList<String,Exception>`都是`List<String>`的子类。\n\n## 使用泛型\n\n上面的例子中已经列举了一些使用泛化类或者泛化函数的例子，但是还有一些问题需要指出：\n\n1.泛型参数只接受引用类型，不适用于基本类型\n\n比如：\n\n```java\nclass Test<T> {}\n\npublic static void main(String[] args) {\n    //无法通过编译，不接受int类型的泛化参数\n\t//Test<int> test = new Test();\n}\n```\n\n而我们使用泛化函数时：\n\n```java\npublic static void main(String[] args) {\n\tgetT(1);\n}\npublic static <T> void getT(T t) {\n}\n```\n是没有问题的，通过查看生成的字节码，发现getT(1)这个方法的字节码中1被自动装箱为Integer类型。\n\n2.通配符的使用\n\n考虑下面的情况：\n\n```java\nclass Test<T> {}\npublic static void getT(Test<Number> t) {\n}\n\npublic static void main(String[] args) {\n\tTest<Double> test = new Test();\n\t//编译时报错\n\t//getT(test);\n}\n```\n报错的原因很好理解，虽然Double是Number的子类，但Test<Double>并不是Test<Number>的子类，故类型检查无法通过。这一点一定要明白。\n\n那么如果我们确实想要传入一个Test<Double>类型的形参呢？可以使用通配符：\n\n```java\nclass Test<T> {}\npublic static void main(String[] args) {\n\t\tTest<Double> test = new Test();\n\t\t//正常运行\n\t\tgetT(test);\n}\npublic static void getT(Test<? extends Number> t) {\n}\n```\n`Test<? extends Number>`扩展了形参的类型，可以是`Test<Double>`、`Test<Integer>`等，尖括号中的类型必须是Number或继承于Number。同样的，通配符也适用于super，如`Test<? super A>`。\n\n如果类型参数中既没有extends 关键字，也没有super关键字，只有一个?，代表无限定通配符。\n\n`Test<?>`与`Test<Object>`并不相同，无论T是什么类型，`Test<T>` 是 `Test<?>`的子类，但是，`Test<T>` 不是 `Test<Object>` 的子类，想想上面的例子。\n\n通常在两种情况下会使用无限定通配符：\n\n1. 如果正在编写一个方法，可以使用Object类中提供的功能来实现\n\n2. 代码实现的功能与类型参数无关，比如List.clear()与List.size()方法，还有经常使用的`Class<?>`方法，其实现的功能都与类型参数无关。\n\n一般情况下，通配符`<? extends Number>`只是出现在使用泛型的时候，而不是定义泛型的时候，就像上面的例子那样。而`<T extends Number>`这种形式出现在定义泛型的时候，而不是使用泛型的时候，不要搞混了。\n\n结合泛型的继承和通配符的使用，理解一下泛型的类型系统，也就是泛型类的继承关系：\n\n以下内容来自：[Java深度历险（五）——Java泛型](http://www.infoq.com/cn/articles/cf-java-generics)\n\n***\n引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 `List<String>`和`List<Object>`这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：\n\n相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即`List<String>`是`Collection<String>` 的子类型，`List<String>`可以替换`Collection<String>`。这种情况也适用于带有上下界的类型声明。\n当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对`Collection<? extends Number>`来说，其子类型可以在Collection这个维度上展开，即`List<? extends Number>`和`Set<? extends Number>`等；也可以在Number这个层次上展开，即`Collection<Double>`和 `Collection<Integer>`等。如此循环下去，`ArrayList<Long>`和 `HashSet<Double>`等也都算是`Collection<? extends Number>`的子类型。\n如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。\n***\n\n关于通配符的理解可以参考[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)\n\n\n## 类型擦除\n\n类型擦除发生在编译阶段，对于运行期的JVM来说，`List<int>`与`List<String>`就是同一个类，因为在编译结束之后，生成的字节码文件中，他们都是List类型。\n\n1.java编译器会在编译前进行类型检查\n\njava编译器承担了所有泛型的类型安全检查工作。\n\n2.类型擦除后保留的原始类型\n\n原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。\n\n3.自动类型转换\n\n因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？\n\n比如：\n\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        ArrayList<Date> list=new ArrayList<Date>();  \n        list.add(new Date());  \n        Date myDate=list.get(0);  \n    }\n}  \n```\n`Date myDate=list.get(0);`这里我们并没有对其返回值进行强转就可以直接获取Date类型的返回值。原因在于在字节码当中，有checkcast这么一个操作帮助我们进行了强转，这是java自动进行的。\n\n更多的关于类型擦除的知识，参考[ java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题](http://blog.csdn.net/lonelyroamer/article/details/7868820)\n\n\n## 实践\n\n最近在重构公众号服务器的过程中，用到了泛型编程的知识。\n\n```java\npublic interface BaseServiceContext<T extends ReqBaseMessage, R> {\n\tpublic void selectService(T reqMeg);\n\n\tpublic R executeRequest();\n}\n```\n上面是一个选择service的上下文接口，接收到用户请求后通过这个接口选择对应的service并且执行service。这个接口相当于一个工厂和策略模式的结合体。下面是这个接口的一种实现：\n\n```java\n//请求为文本类型，返回string类型的处理结果\npublic class TextServiceContext implements BaseServiceContext<ReqTextMessage,String> {\n\n\t@Override\n\tpublic void selectService(ReqTextMessage reqMeg) {\n\t\t//.....\n\t}\n\n\t@Override\n\tpublic String executeRequest() {\n\t\t//.....\n\t}\n}\n```\n可以看到，BaseServiceContext<ReqTextMessage,String>限定了selectService方法的参数类型和executeRequest方法的返回值类型，使其能够灵活的支持各种类型的参数和返回值。\n\n看一下在没有学习泛型之前，这个接口是怎么实现的：\n\n```java\npublic interface BaseServiceContext {\n\tpublic void selectService(ReqBaseMessage reqMeg);\n\n\tpublic Object executeRequest();\n}\n\npublic class TextServiceContext implements BaseServiceContext {\n\n\t@Override\n\tpublic void selectService(ReqBaseMessage reqMeg) {\n\t\t//根据业务逻辑对reqMeg进行强转，需要程序员自己判断\n\t\t//很有可能强转失败\n\t}\n\n\t@Override\n\tpublic Object executeRequest() {\n\t\t//返回类型为object，在调用方法的外部强转为需要的类型\n\t\t//很有可能强转失败\n\t}\n}\n```\n可以看到没有使用泛型接口的情况下，类型不安全且增大了强转失败的风险。同时也需要程序员根据业务逻辑去判断该强转成什么类型。使用泛型接口之后就没有了这些问题，只需要在使用接口时声明好他的泛型参数就o了。\n\n上面只是我在开发过程中体会到泛型的一个好处，类似的例子还有很多。\n\n## 注意事项\n\n\n\n## 参考\n\n[java 泛型编程（一）](http://peiquan.blog.51cto.com/7518552/1302898)\n\n[泛型：工作原理及其重要性](http://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html)\n\n[Java深度历险（五）——Java泛型](http://www.infoq.com/cn/articles/cf-java-generics)\n\n[java泛型详解](http://blog.csdn.net/u012152619/article/details/47253811)\n\n[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)\n\n","slug":"java泛型学习","published":1,"updated":"2017-02-19T13:08:11.034Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlro0022vegcq3i35rx0","content":"<p>有一段时间没有更新博客了，过了国庆之后，好像变得更懒了~~前两天开发了一个用于记账的公众号，功能很简单，就是普通的增删查改…由于是个人开发者，无法进行公众号的认证，所以没什么高级的接口权限，只能搞的简陋一点了…下一步计划再丰富丰富，目前想到了这几个功能：配合有道或者金山词霸的Api进行中英互译（API怎么用，可不可以用目前还不清楚），配合微博的Api接口整点微博热门什么的，配合豆瓣的Api接口做一个电影或者书籍查询的功能等等….公众号的服务器代码目前还部署在自己的电脑上，用nat123做了一下公网ip的映射，接下来考虑是不是要换成云服务器更为妥当….</p>\n<p>公众号在这里：</p>\n<img src=\"/2016/10/10/java泛型学习/easybill.jpg\" alt=\"EasyBill\" title=\"EasyBill\">\n<p>目前，公众号已经开源：<a href=\"https://github.com/Hikyu/WechatSubscriptionNumber\" target=\"_blank\" rel=\"external\">WechatSubscriptionNumber</a></p>\n<p>好了，言归正传。今天学习了java的泛型知识，不总结一下老是觉得跟没学一样…</p>\n<h2 id=\"泛型的好处\"><a href=\"#泛型的好处\" class=\"headerlink\" title=\"泛型的好处\"></a>泛型的好处</h2><p>使用泛型的好处我觉得有两点：1：类型安全  2：减少类型强转</p>\n<p>下面通过一个例子说明:</p>\n<p>假设有一个Test类，通用的实现是:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Object o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以这样使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest test = <span class=\"keyword\">new</span> Test(<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div><div class=\"line\">\t<span class=\"comment\">//编译时不报错</span></div><div class=\"line\">\t<span class=\"comment\">//运行时报  java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span></div><div class=\"line\">\tString o = (String) test.getObject();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一个使用泛型的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> T o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest1&lt;Integer&gt; test = <span class=\"keyword\">new</span> Test1&lt;Integer&gt;(<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div><div class=\"line\">\t<span class=\"comment\">//编译时报错，无法通过编译</span></div><div class=\"line\">\t<span class=\"comment\">//String o = test.getObject();</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//正常运行</span></div><div class=\"line\">\tInteger o = test.getObject();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的对比中能够看出两点：</p>\n<p>1.使用泛型之后在编译时报错而非运行时，减少了出错的几率；</p>\n<p>2.使用泛型之后编译器不再要求强转</p>\n<h2 id=\"定义泛型\"><a href=\"#定义泛型\" class=\"headerlink\" title=\"定义泛型\"></a>定义泛型</h2><p>泛型的机制能够在定义类、接口、方法时把类型参数化，也就是类似于方法的形参一样，把类型当做参数使用。</p>\n<p>泛型参数部分使用<code>&lt;&gt;</code>包裹起来，比如<code>&lt;T&gt;</code>，T声明了一种类型，习惯上，这个类型参数使用单个大写字母来表示，指示所定义的参数类型。有如下惯例：</p>\n<p>E：表示元素</p>\n<p>T：表示类型</p>\n<p>K：表示键</p>\n<p>V：表示值</p>\n<p>N：表示数字</p>\n<h3 id=\"定义泛型类\"><a href=\"#定义泛型类\" class=\"headerlink\" title=\"定义泛型类\"></a>定义泛型类</h3><p>上面的例子就是一个很好的演示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> T o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义类之后，泛型参数 T 可以运用到该类中：可以声明成员变量类型、可以声明成员函数返回值类型、可以声明成员函数参数类型。</p>\n<p>要注意：泛型参数T不能用于声明静态变量，同时也不能用于new一个对象比如：T o = new T();</p>\n<p>下面的类型擦除会说到原因。</p>\n<h3 id=\"定义泛型接口\"><a href=\"#定义泛型接口\" class=\"headerlink\" title=\"定义泛型接口\"></a>定义泛型接口</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">test</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义接口之后，泛型参数 T 可以运用到该接口中：可以声明接口函数返回值类型、可以声明接口函数参数类型。</p>\n<h3 id=\"定义泛型方法\"><a href=\"#定义泛型方法\" class=\"headerlink\" title=\"定义泛型方法\"></a>定义泛型方法</h3><p>可以单独给方法使用泛型，而不是泛化整个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getT</span><span class=\"params\">(T t)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> t;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义方法后，泛型参数 T 可以声明该方法的返回值类型、可以声明该方法的参数类型。</p>\n<p>要注意，定义方法所用的泛型参数需要在修饰符之后添加。</p>\n<h3 id=\"定义多个泛型参数\"><a href=\"#定义多个泛型参数\" class=\"headerlink\" title=\"定义多个泛型参数\"></a>定义多个泛型参数</h3><p>以接口为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">S</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">testT</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> S <span class=\"title\">testS</span><span class=\"params\">(S s)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//编译时报错</span></div><div class=\"line\">\t<span class=\"comment\">//getT(\"s\");</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>多个泛型参数在尖括号中使用逗号隔开。类的泛化与方法的泛化类似。</p>\n<h3 id=\"泛型参数的界限\"><a href=\"#泛型参数的界限\" class=\"headerlink\" title=\"泛型参数的界限\"></a>泛型参数的界限</h3><p>定义泛型参数界限有这样两种意义：</p>\n<p>1.有时候我们希望限定这个泛型参数的类型为某个类的子类或者超类；</p>\n<p>2.上面的例子中可以看到，我们定义了泛型参数，向方法中传入某种类型，这种类型是未知的，因此我们无法使用这种类型定义的变量，不能够调用它的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T extends Number&gt; <span class=\"function\">Integer <span class=\"title\">getT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> Integer(t.intValue());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面例子中，<code>&lt;T extends A&gt;</code>表示T是A或A的子类，他限定了传入泛型方法参数的类型必须为A或A的子类，同时，在方法体中我们也可以使用t这个实参就像使用A的实例一样，调用Number具有的public方法。</p>\n<p>除了<code>&lt;T extends A&gt;</code>限定T是A或A的子类外，还可以使用<code>&lt;T super A&gt;</code>这种方式来限定T是A或A的超类。</p>\n<p>A可以是某个类或者接口。</p>\n<p>除此以外，还可以为泛型参数限定多个限制范围，如<code>&lt;T extends A &amp; B &amp; C&gt;</code>，限定范围中最多只能有一个类(某个类只能有一个父类~~)，并且他必须是限定列表中的第一个。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class A &#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">B</span> </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">C</span> </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//正确</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> &lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> &amp; <span class=\"title\">B</span> &amp; <span class=\"title\">C</span>&gt; </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"comment\">//编译时报错</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> &lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> &amp; <span class=\"title\">B</span> &amp; <span class=\"title\">C</span>&gt; </span>&#123; <span class=\"comment\">// &#125;</span></div></pre></td></tr></table></figure>\n<h3 id=\"泛型的继承\"><a href=\"#泛型的继承\" class=\"headerlink\" title=\"泛型的继承\"></a>泛型的继承</h3><p>看一下jdk中List的泛型继承例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;<span class=\"comment\">//...&#125;</span></div></pre></td></tr></table></figure>\n<p><code>List&lt;String&gt;</code> 就是 <code>Collection&lt;String&gt;</code> 的子类。</p>\n<p>假如定义自己的接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyList</span>&lt;<span class=\"title\">E</span>,<span class=\"title\">P</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setPay</span><span class=\"params\">(E e,P p)</span></span>;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>MyList&lt;String,String&gt;</code>、<code>MyList&lt;String,Integer&gt;</code>、<code>MyList&lt;String,Exception&gt;</code>都是<code>List&lt;String&gt;</code>的子类。</p>\n<h2 id=\"使用泛型\"><a href=\"#使用泛型\" class=\"headerlink\" title=\"使用泛型\"></a>使用泛型</h2><p>上面的例子中已经列举了一些使用泛化类或者泛化函数的例子，但是还有一些问题需要指出：</p>\n<p>1.泛型参数只接受引用类型，不适用于基本类型</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//无法通过编译，不接受int类型的泛化参数</span></div><div class=\"line\">\t<span class=\"comment\">//Test&lt;int&gt; test = new Test();</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而我们使用泛化函数时：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tgetT(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>是没有问题的，通过查看生成的字节码，发现getT(1)这个方法的字节码中1被自动装箱为Integer类型。</p>\n<p>2.通配符的使用</p>\n<p>考虑下面的情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(Test&lt;Number&gt; t)</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest&lt;Double&gt; test = <span class=\"keyword\">new</span> Test();</div><div class=\"line\">\t<span class=\"comment\">//编译时报错</span></div><div class=\"line\">\t<span class=\"comment\">//getT(test);</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>报错的原因很好理解，虽然Double是Number的子类，但Test<double>并不是Test<number>的子类，故类型检查无法通过。这一点一定要明白。</number></double></p>\n<p>那么如果我们确实想要传入一个Test<double>类型的形参呢？可以使用通配符：</double></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tTest&lt;Double&gt; test = <span class=\"keyword\">new</span> Test();</div><div class=\"line\">\t\t<span class=\"comment\">//正常运行</span></div><div class=\"line\">\t\tgetT(test);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(Test&lt;? extends Number&gt; t)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Test&lt;? extends Number&gt;</code>扩展了形参的类型，可以是<code>Test&lt;Double&gt;</code>、<code>Test&lt;Integer&gt;</code>等，尖括号中的类型必须是Number或继承于Number。同样的，通配符也适用于super，如<code>Test&lt;? super A&gt;</code>。</p>\n<p>如果类型参数中既没有extends 关键字，也没有super关键字，只有一个?，代表无限定通配符。</p>\n<p><code>Test&lt;?&gt;</code>与<code>Test&lt;Object&gt;</code>并不相同，无论T是什么类型，<code>Test&lt;T&gt;</code> 是 <code>Test&lt;?&gt;</code>的子类，但是，<code>Test&lt;T&gt;</code> 不是 <code>Test&lt;Object&gt;</code> 的子类，想想上面的例子。</p>\n<p>通常在两种情况下会使用无限定通配符：</p>\n<ol>\n<li><p>如果正在编写一个方法，可以使用Object类中提供的功能来实现</p>\n</li>\n<li><p>代码实现的功能与类型参数无关，比如List.clear()与List.size()方法，还有经常使用的<code>Class&lt;?&gt;</code>方法，其实现的功能都与类型参数无关。</p>\n</li>\n</ol>\n<p>一般情况下，通配符<code>&lt;? extends Number&gt;</code>只是出现在使用泛型的时候，而不是定义泛型的时候，就像上面的例子那样。而<code>&lt;T extends Number&gt;</code>这种形式出现在定义泛型的时候，而不是使用泛型的时候，不要搞混了。</p>\n<p>结合泛型的继承和通配符的使用，理解一下泛型的类型系统，也就是泛型类的继承关系：</p>\n<p>以下内容来自：<a href=\"http://www.infoq.com/cn/articles/cf-java-generics\" target=\"_blank\" rel=\"external\">Java深度历险（五）——Java泛型</a></p>\n<hr>\n<p>引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 <code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：</p>\n<p>相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code> 的子类型，<code>List&lt;String&gt;</code>可以替换<code>Collection&lt;String&gt;</code>。这种情况也适用于带有上下界的类型声明。<br>当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对<code>Collection&lt;? extends Number&gt;</code>来说，其子类型可以在Collection这个维度上展开，即<code>List&lt;? extends Number&gt;</code>和<code>Set&lt;? extends Number&gt;</code>等；也可以在Number这个层次上展开，即<code>Collection&lt;Double&gt;</code>和 <code>Collection&lt;Integer&gt;</code>等。如此循环下去，<code>ArrayList&lt;Long&gt;</code>和 <code>HashSet&lt;Double&gt;</code>等也都算是<code>Collection&lt;? extends Number&gt;</code>的子类型。<br>如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。</p>\n<hr>\n<p>关于通配符的理解可以参考<a href=\"https://www.zhihu.com/question/20400700\" target=\"_blank\" rel=\"external\">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></p>\n<h2 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h2><p>类型擦除发生在编译阶段，对于运行期的JVM来说，<code>List&lt;int&gt;</code>与<code>List&lt;String&gt;</code>就是同一个类，因为在编译结束之后，生成的字节码文件中，他们都是List类型。</p>\n<p>1.java编译器会在编译前进行类型检查</p>\n<p>java编译器承担了所有泛型的类型安全检查工作。</p>\n<p>2.类型擦除后保留的原始类型</p>\n<p>原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。</p>\n<p>3.自动类型转换</p>\n<p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        ArrayList&lt;Date&gt; list=<span class=\"keyword\">new</span> ArrayList&lt;Date&gt;();  </div><div class=\"line\">        list.add(<span class=\"keyword\">new</span> Date());  </div><div class=\"line\">        Date myDate=list.get(<span class=\"number\">0</span>);  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Date myDate=list.get(0);</code>这里我们并没有对其返回值进行强转就可以直接获取Date类型的返回值。原因在于在字节码当中，有checkcast这么一个操作帮助我们进行了强转，这是java自动进行的。</p>\n<p>更多的关于类型擦除的知识，参考<a href=\"http://blog.csdn.net/lonelyroamer/article/details/7868820\" target=\"_blank\" rel=\"external\"> java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>最近在重构公众号服务器的过程中，用到了泛型编程的知识。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseServiceContext</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReqBaseMessage</span>, <span class=\"title\">R</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(T reqMeg)</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> R <span class=\"title\">executeRequest</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面是一个选择service的上下文接口，接收到用户请求后通过这个接口选择对应的service并且执行service。这个接口相当于一个工厂和策略模式的结合体。下面是这个接口的一种实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//请求为文本类型，返回string类型的处理结果</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextServiceContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseServiceContext</span>&lt;<span class=\"title\">ReqTextMessage</span>,<span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqTextMessage reqMeg)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//.....</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">executeRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//.....</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，BaseServiceContext<reqtextmessage,string>限定了selectService方法的参数类型和executeRequest方法的返回值类型，使其能够灵活的支持各种类型的参数和返回值。</reqtextmessage,string></p>\n<p>看一下在没有学习泛型之前，这个接口是怎么实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseServiceContext</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqBaseMessage reqMeg)</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">executeRequest</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextServiceContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseServiceContext</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqBaseMessage reqMeg)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//根据业务逻辑对reqMeg进行强转，需要程序员自己判断</span></div><div class=\"line\">\t\t<span class=\"comment\">//很有可能强转失败</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">executeRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//返回类型为object，在调用方法的外部强转为需要的类型</span></div><div class=\"line\">\t\t<span class=\"comment\">//很有可能强转失败</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到没有使用泛型接口的情况下，类型不安全且增大了强转失败的风险。同时也需要程序员根据业务逻辑去判断该强转成什么类型。使用泛型接口之后就没有了这些问题，只需要在使用接口时声明好他的泛型参数就o了。</p>\n<p>上面只是我在开发过程中体会到泛型的一个好处，类似的例子还有很多。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://peiquan.blog.51cto.com/7518552/1302898\" target=\"_blank\" rel=\"external\">java 泛型编程（一）</a></p>\n<p><a href=\"http://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html\" target=\"_blank\" rel=\"external\">泛型：工作原理及其重要性</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/cf-java-generics\" target=\"_blank\" rel=\"external\">Java深度历险（五）——Java泛型</a></p>\n<p><a href=\"http://blog.csdn.net/u012152619/article/details/47253811\" target=\"_blank\" rel=\"external\">java泛型详解</a></p>\n<p><a href=\"https://www.zhihu.com/question/20400700\" target=\"_blank\" rel=\"external\">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></p>\n","excerpt":"","more":"<p>有一段时间没有更新博客了，过了国庆之后，好像变得更懒了~~前两天开发了一个用于记账的公众号，功能很简单，就是普通的增删查改…由于是个人开发者，无法进行公众号的认证，所以没什么高级的接口权限，只能搞的简陋一点了…下一步计划再丰富丰富，目前想到了这几个功能：配合有道或者金山词霸的Api进行中英互译（API怎么用，可不可以用目前还不清楚），配合微博的Api接口整点微博热门什么的，配合豆瓣的Api接口做一个电影或者书籍查询的功能等等….公众号的服务器代码目前还部署在自己的电脑上，用nat123做了一下公网ip的映射，接下来考虑是不是要换成云服务器更为妥当….</p>\n<p>公众号在这里：</p>\n<img src=\"/2016/10/10/java泛型学习/easybill.jpg\" alt=\"EasyBill\" title=\"EasyBill\">\n<p>目前，公众号已经开源：<a href=\"https://github.com/Hikyu/WechatSubscriptionNumber\">WechatSubscriptionNumber</a></p>\n<p>好了，言归正传。今天学习了java的泛型知识，不总结一下老是觉得跟没学一样…</p>\n<h2 id=\"泛型的好处\"><a href=\"#泛型的好处\" class=\"headerlink\" title=\"泛型的好处\"></a>泛型的好处</h2><p>使用泛型的好处我觉得有两点：1：类型安全  2：减少类型强转</p>\n<p>下面通过一个例子说明:</p>\n<p>假设有一个Test类，通用的实现是:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Object o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以这样使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest test = <span class=\"keyword\">new</span> Test(<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div><div class=\"line\">\t<span class=\"comment\">//编译时不报错</span></div><div class=\"line\">\t<span class=\"comment\">//运行时报  java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span></div><div class=\"line\">\tString o = (String) test.getObject();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一个使用泛型的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> T o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest1&lt;Integer&gt; test = <span class=\"keyword\">new</span> Test1&lt;Integer&gt;(<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div><div class=\"line\">\t<span class=\"comment\">//编译时报错，无法通过编译</span></div><div class=\"line\">\t<span class=\"comment\">//String o = test.getObject();</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//正常运行</span></div><div class=\"line\">\tInteger o = test.getObject();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的对比中能够看出两点：</p>\n<p>1.使用泛型之后在编译时报错而非运行时，减少了出错的几率；</p>\n<p>2.使用泛型之后编译器不再要求强转</p>\n<h2 id=\"定义泛型\"><a href=\"#定义泛型\" class=\"headerlink\" title=\"定义泛型\"></a>定义泛型</h2><p>泛型的机制能够在定义类、接口、方法时把类型参数化，也就是类似于方法的形参一样，把类型当做参数使用。</p>\n<p>泛型参数部分使用<code>&lt;&gt;</code>包裹起来，比如<code>&lt;T&gt;</code>，T声明了一种类型，习惯上，这个类型参数使用单个大写字母来表示，指示所定义的参数类型。有如下惯例：</p>\n<p>E：表示元素</p>\n<p>T：表示类型</p>\n<p>K：表示键</p>\n<p>V：表示值</p>\n<p>N：表示数字</p>\n<h3 id=\"定义泛型类\"><a href=\"#定义泛型类\" class=\"headerlink\" title=\"定义泛型类\"></a>定义泛型类</h3><p>上面的例子就是一个很好的演示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> T o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义类之后，泛型参数 T 可以运用到该类中：可以声明成员变量类型、可以声明成员函数返回值类型、可以声明成员函数参数类型。</p>\n<p>要注意：泛型参数T不能用于声明静态变量，同时也不能用于new一个对象比如：T o = new T();</p>\n<p>下面的类型擦除会说到原因。</p>\n<h3 id=\"定义泛型接口\"><a href=\"#定义泛型接口\" class=\"headerlink\" title=\"定义泛型接口\"></a>定义泛型接口</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">test</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义接口之后，泛型参数 T 可以运用到该接口中：可以声明接口函数返回值类型、可以声明接口函数参数类型。</p>\n<h3 id=\"定义泛型方法\"><a href=\"#定义泛型方法\" class=\"headerlink\" title=\"定义泛型方法\"></a>定义泛型方法</h3><p>可以单独给方法使用泛型，而不是泛化整个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getT</span><span class=\"params\">(T t)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> t;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义方法后，泛型参数 T 可以声明该方法的返回值类型、可以声明该方法的参数类型。</p>\n<p>要注意，定义方法所用的泛型参数需要在修饰符之后添加。</p>\n<h3 id=\"定义多个泛型参数\"><a href=\"#定义多个泛型参数\" class=\"headerlink\" title=\"定义多个泛型参数\"></a>定义多个泛型参数</h3><p>以接口为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">S</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">testT</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> S <span class=\"title\">testS</span><span class=\"params\">(S s)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//编译时报错</span></div><div class=\"line\">\t<span class=\"comment\">//getT(\"s\");</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>多个泛型参数在尖括号中使用逗号隔开。类的泛化与方法的泛化类似。</p>\n<h3 id=\"泛型参数的界限\"><a href=\"#泛型参数的界限\" class=\"headerlink\" title=\"泛型参数的界限\"></a>泛型参数的界限</h3><p>定义泛型参数界限有这样两种意义：</p>\n<p>1.有时候我们希望限定这个泛型参数的类型为某个类的子类或者超类；</p>\n<p>2.上面的例子中可以看到，我们定义了泛型参数，向方法中传入某种类型，这种类型是未知的，因此我们无法使用这种类型定义的变量，不能够调用它的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T extends Number&gt; <span class=\"function\">Integer <span class=\"title\">getT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> Integer(t.intValue());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面例子中，<code>&lt;T extends A&gt;</code>表示T是A或A的子类，他限定了传入泛型方法参数的类型必须为A或A的子类，同时，在方法体中我们也可以使用t这个实参就像使用A的实例一样，调用Number具有的public方法。</p>\n<p>除了<code>&lt;T extends A&gt;</code>限定T是A或A的子类外，还可以使用<code>&lt;T super A&gt;</code>这种方式来限定T是A或A的超类。</p>\n<p>A可以是某个类或者接口。</p>\n<p>除此以外，还可以为泛型参数限定多个限制范围，如<code>&lt;T extends A &amp; B &amp; C&gt;</code>，限定范围中最多只能有一个类(某个类只能有一个父类~~)，并且他必须是限定列表中的第一个。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class A &#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">B</span> </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">C</span> </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//正确</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> &lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> &amp; <span class=\"title\">B</span> &amp; <span class=\"title\">C</span>&gt; </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"comment\">//编译时报错</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> &lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> &amp; <span class=\"title\">B</span> &amp; <span class=\"title\">C</span>&gt; </span>&#123; <span class=\"comment\">// &#125;</span></div></pre></td></tr></table></figure>\n<h3 id=\"泛型的继承\"><a href=\"#泛型的继承\" class=\"headerlink\" title=\"泛型的继承\"></a>泛型的继承</h3><p>看一下jdk中List的泛型继承例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;<span class=\"comment\">//...&#125;</span></div></pre></td></tr></table></figure>\n<p><code>List&lt;String&gt;</code> 就是 <code>Collection&lt;String&gt;</code> 的子类。</p>\n<p>假如定义自己的接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyList</span>&lt;<span class=\"title\">E</span>,<span class=\"title\">P</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setPay</span><span class=\"params\">(E e,P p)</span></span>;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>MyList&lt;String,String&gt;</code>、<code>MyList&lt;String,Integer&gt;</code>、<code>MyList&lt;String,Exception&gt;</code>都是<code>List&lt;String&gt;</code>的子类。</p>\n<h2 id=\"使用泛型\"><a href=\"#使用泛型\" class=\"headerlink\" title=\"使用泛型\"></a>使用泛型</h2><p>上面的例子中已经列举了一些使用泛化类或者泛化函数的例子，但是还有一些问题需要指出：</p>\n<p>1.泛型参数只接受引用类型，不适用于基本类型</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//无法通过编译，不接受int类型的泛化参数</span></div><div class=\"line\">\t<span class=\"comment\">//Test&lt;int&gt; test = new Test();</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而我们使用泛化函数时：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tgetT(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>是没有问题的，通过查看生成的字节码，发现getT(1)这个方法的字节码中1被自动装箱为Integer类型。</p>\n<p>2.通配符的使用</p>\n<p>考虑下面的情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(Test&lt;Number&gt; t)</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest&lt;Double&gt; test = <span class=\"keyword\">new</span> Test();</div><div class=\"line\">\t<span class=\"comment\">//编译时报错</span></div><div class=\"line\">\t<span class=\"comment\">//getT(test);</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>报错的原因很好理解，虽然Double是Number的子类，但Test<Double>并不是Test<Number>的子类，故类型检查无法通过。这一点一定要明白。</p>\n<p>那么如果我们确实想要传入一个Test<Double>类型的形参呢？可以使用通配符：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tTest&lt;Double&gt; test = <span class=\"keyword\">new</span> Test();</div><div class=\"line\">\t\t<span class=\"comment\">//正常运行</span></div><div class=\"line\">\t\tgetT(test);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(Test&lt;? extends Number&gt; t)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Test&lt;? extends Number&gt;</code>扩展了形参的类型，可以是<code>Test&lt;Double&gt;</code>、<code>Test&lt;Integer&gt;</code>等，尖括号中的类型必须是Number或继承于Number。同样的，通配符也适用于super，如<code>Test&lt;? super A&gt;</code>。</p>\n<p>如果类型参数中既没有extends 关键字，也没有super关键字，只有一个?，代表无限定通配符。</p>\n<p><code>Test&lt;?&gt;</code>与<code>Test&lt;Object&gt;</code>并不相同，无论T是什么类型，<code>Test&lt;T&gt;</code> 是 <code>Test&lt;?&gt;</code>的子类，但是，<code>Test&lt;T&gt;</code> 不是 <code>Test&lt;Object&gt;</code> 的子类，想想上面的例子。</p>\n<p>通常在两种情况下会使用无限定通配符：</p>\n<ol>\n<li><p>如果正在编写一个方法，可以使用Object类中提供的功能来实现</p>\n</li>\n<li><p>代码实现的功能与类型参数无关，比如List.clear()与List.size()方法，还有经常使用的<code>Class&lt;?&gt;</code>方法，其实现的功能都与类型参数无关。</p>\n</li>\n</ol>\n<p>一般情况下，通配符<code>&lt;? extends Number&gt;</code>只是出现在使用泛型的时候，而不是定义泛型的时候，就像上面的例子那样。而<code>&lt;T extends Number&gt;</code>这种形式出现在定义泛型的时候，而不是使用泛型的时候，不要搞混了。</p>\n<p>结合泛型的继承和通配符的使用，理解一下泛型的类型系统，也就是泛型类的继承关系：</p>\n<p>以下内容来自：<a href=\"http://www.infoq.com/cn/articles/cf-java-generics\">Java深度历险（五）——Java泛型</a></p>\n<hr>\n<p>引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 <code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：</p>\n<p>相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code> 的子类型，<code>List&lt;String&gt;</code>可以替换<code>Collection&lt;String&gt;</code>。这种情况也适用于带有上下界的类型声明。<br>当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对<code>Collection&lt;? extends Number&gt;</code>来说，其子类型可以在Collection这个维度上展开，即<code>List&lt;? extends Number&gt;</code>和<code>Set&lt;? extends Number&gt;</code>等；也可以在Number这个层次上展开，即<code>Collection&lt;Double&gt;</code>和 <code>Collection&lt;Integer&gt;</code>等。如此循环下去，<code>ArrayList&lt;Long&gt;</code>和 <code>HashSet&lt;Double&gt;</code>等也都算是<code>Collection&lt;? extends Number&gt;</code>的子类型。<br>如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。</p>\n<hr>\n<p>关于通配符的理解可以参考<a href=\"https://www.zhihu.com/question/20400700\">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></p>\n<h2 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h2><p>类型擦除发生在编译阶段，对于运行期的JVM来说，<code>List&lt;int&gt;</code>与<code>List&lt;String&gt;</code>就是同一个类，因为在编译结束之后，生成的字节码文件中，他们都是List类型。</p>\n<p>1.java编译器会在编译前进行类型检查</p>\n<p>java编译器承担了所有泛型的类型安全检查工作。</p>\n<p>2.类型擦除后保留的原始类型</p>\n<p>原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。</p>\n<p>3.自动类型转换</p>\n<p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        ArrayList&lt;Date&gt; list=<span class=\"keyword\">new</span> ArrayList&lt;Date&gt;();  </div><div class=\"line\">        list.add(<span class=\"keyword\">new</span> Date());  </div><div class=\"line\">        Date myDate=list.get(<span class=\"number\">0</span>);  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Date myDate=list.get(0);</code>这里我们并没有对其返回值进行强转就可以直接获取Date类型的返回值。原因在于在字节码当中，有checkcast这么一个操作帮助我们进行了强转，这是java自动进行的。</p>\n<p>更多的关于类型擦除的知识，参考<a href=\"http://blog.csdn.net/lonelyroamer/article/details/7868820\"> java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>最近在重构公众号服务器的过程中，用到了泛型编程的知识。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseServiceContext</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReqBaseMessage</span>, <span class=\"title\">R</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(T reqMeg)</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> R <span class=\"title\">executeRequest</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面是一个选择service的上下文接口，接收到用户请求后通过这个接口选择对应的service并且执行service。这个接口相当于一个工厂和策略模式的结合体。下面是这个接口的一种实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//请求为文本类型，返回string类型的处理结果</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextServiceContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseServiceContext</span>&lt;<span class=\"title\">ReqTextMessage</span>,<span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqTextMessage reqMeg)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//.....</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">executeRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//.....</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，BaseServiceContext<ReqTextMessage,String>限定了selectService方法的参数类型和executeRequest方法的返回值类型，使其能够灵活的支持各种类型的参数和返回值。</p>\n<p>看一下在没有学习泛型之前，这个接口是怎么实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseServiceContext</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqBaseMessage reqMeg)</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">executeRequest</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextServiceContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseServiceContext</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqBaseMessage reqMeg)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//根据业务逻辑对reqMeg进行强转，需要程序员自己判断</span></div><div class=\"line\">\t\t<span class=\"comment\">//很有可能强转失败</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">executeRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//返回类型为object，在调用方法的外部强转为需要的类型</span></div><div class=\"line\">\t\t<span class=\"comment\">//很有可能强转失败</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到没有使用泛型接口的情况下，类型不安全且增大了强转失败的风险。同时也需要程序员根据业务逻辑去判断该强转成什么类型。使用泛型接口之后就没有了这些问题，只需要在使用接口时声明好他的泛型参数就o了。</p>\n<p>上面只是我在开发过程中体会到泛型的一个好处，类似的例子还有很多。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://peiquan.blog.51cto.com/7518552/1302898\">java 泛型编程（一）</a></p>\n<p><a href=\"http://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html\">泛型：工作原理及其重要性</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/cf-java-generics\">Java深度历险（五）——Java泛型</a></p>\n<p><a href=\"http://blog.csdn.net/u012152619/article/details/47253811\">java泛型详解</a></p>\n<p><a href=\"https://www.zhihu.com/question/20400700\">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></p>\n"},{"layout":"post","title":"java注解","date":"2017-03-31T13:07:33.000Z","_content":"> 在写java代码的过程中，经常会遇到注解，但是没有去理解注解背后的原理，也没有实现过注解。网上关于java注解的文章已经有很多了，参考了一些资料，整理一下注解这方面的知识~\n\n## 什么是注解\n注解其实很常见。比如@override、Deprecated等。在使用Junit或Spring boot等一些框架的时候，注解更是无处不在了。那么，到底什么是注解呢？\n\n```\nAnnotations, a form of metadata, provide data about a program that is not part of the program itself. \nAnnotations have no direct effect on the operation of the code they annotate.   \n>>[https://docs.oracle.com/javase/tutorial/java/annotations/]\n```\n注解是元数据的一种，提供了关于程序的一些描述信息，但这些信息并不属于这个程序本身的一部分。注解并不会直接影响到代码的执行。\n\n翻译起来有点拗口。实际上，注解是那些插入到源代码中用于某种工具进行处理的标签。注解不会改变对编写的程序的编译方式，对于包含和不包含注解的代码，java编译器都会生成相同的虚拟机指令。\n\n一句话来说，注解只是描述代码的标签。注解本身不会做什么事情，为了使注解起到作用来实现一些黑科技，我们还需要用于处理注解的工具(编写代码处理这些注解)。\n\n我们使用注解可以：\n\n- 生成文档\n\n- 在编译时进行检查。比如@override\n\n- 替代配置文件，实现自动配置。比如 Springboot\n\n注解Annotation是在jdk1.5之后引进的，jdk1.8之后又增加了一些新的特性。接下来的讨论基于jdk1.7。\n\n## 注解的使用\n\n在java中，注解是当做一个修饰符(比如public或static之类的关键词)来使用的。注解可以存在于：\n\n包 | 类(包括enum) | 接口(包括注解接口) | 方法 | 构造器 | 成员变量 | 本地变量 | 方法参数\n\n注意：\n\n1.对于包的注解，需要在[package-info.java](http://strong-life-126-com.iteye.com/blog/806246)中声明。\n\n2.对于本地变量的注解，只能在源码级别上进行处理。所有的本地变量注解在类编译完之后会被遗弃掉。\n\n假如有这样一个注解：(注解的定义见下文)\n\n```\n@interface Result {\n\tString name() default \"\";\n\tint value() default -1;\n    String res() default \"\";\n}\n```\n\n我们可以这样使用它：\n\n`@Result(name=\"res1\",value=1)`\n\n括号中元素的顺序无关紧要\n\n`@Result(value=1,name=\"res1\")等价于@Result(name=\"res1\",value=1)`\n\n如果元素值没有指定，则使用默认值：(没有声明默认值时必须指定元素值)\n\n`@Result等价于@Result(name=\"\",value=-1,\"\")`\n\n如果元素的名字为特殊值value，那么可以忽略这个元素名和等号：\n\n`@Result(1)等价于@Result(name=\"\",value=1,\"\")`\n\n如果元素是数组，那么他的值要用括号括起来：\n\n`@Result(res={\"a\",\"b\"})`\n\n如果数组是单值，可以忽略这些括号：\n\n`@Result(res=\"a\")`\n\n## 注解分类\n\n根据注解的用途和使用方式，注解可以分为以下几类：\n\n元注解：注解注解的注解。也就是用来描述注解定义的注解\n\n预定义注解：jdk内置的一些注解\n\n自定义注解：我们自己定义的注解\n\n- 元注解\n\n元注解包含下面几个：\n\n**@Target: 指定这个注解可以应用于哪些项**\n\n```\npublic enum ElementType {\n    /** Class, interface (including annotation type), or enum declaration */\n    TYPE,\n\n    /** Field declaration (includes enum constants) */\n    FIELD,\n\n    /** Method declaration */\n    METHOD,\n\n    /** Parameter declaration */\n    PARAMETER,\n\n    /** Constructor declaration */\n    CONSTRUCTOR,\n\n    /** Local variable declaration */\n    LOCAL_VARIABLE,\n\n    /** Annotation type declaration */\n    ANNOTATION_TYPE,\n\n    /** Package declaration */\n    PACKAGE\n}\n```\n比如，我们定义了一个注解Bug，该注解只能应用于方法或成员变量：\n\n```\n@Target({ElementType.METHOD,ElementType.FIELD})\n@interface Bug{\n\tint value() default -1;\n}\n```\n注解Bug则只能用于类方法或成员变量，如果注解了其他项比如类或者包，编译则不会通过。\n\n对于一个没有声明@Target的注解，可以应用到任何项上。\n\n**@Retention: 指定这个注解可以保留多久**\n\n```\npublic enum RetentionPolicy {\n    /**\n     * Annotations are to be discarded by the compiler.\n     */\n    SOURCE,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler\n     * but need not be retained by the VM at run time.  This is the default\n     * behavior.\n     */\n    CLASS,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler and\n     * retained by the VM at run time, so they may be read reflectively.\n     *\n     * @see java.lang.reflect.AnnotatedElement\n     */\n    RUNTIME\n}\n```\nSOURCE：只存在于源代码，编译成.class之后就没了\n\nCLASS: 保留到类文件中，但是虚拟机不会载入\n\nRUNTIME：保留到类文件中，并且虚拟机会载入。这意味着通过反射可以获取到这些注解和注解元素值\n\n默认情况下(没有声明@Retention)，注解保留级别为CLASS\n\n**@Document：指定这个注解应该包含在文档中**\n\n文档化的注解意味着像javadoc这样的工具生成的文档中会包含这些注解。比如：\n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})\npublic @interface Deprecated {\n}\n```\n@Deprecated是文档化的注解，URLDecoder.decode(String s)方法应用了这个注解：\n\n{% asset_img decode.jpg decode %}\n\n{% asset_img doc.jpg doc %}\n\n可以在文档中看到Deprecated的出现。\n\n**@Inherited: 指定一个注解，当他应用于一个类的时候，能够自动被其子类继承**\n\n@Inherited只能应用于对类的注解。如果一个类具有继承注解，那么他的所有子类都自动具有同样的注解。\n\n比如，定义了一个继承注解@Secret表示一个类是隐私的不可被序列化传输的，那么该类的子类会被自动注解为不可序列化传输的。\n\n```\n@Inherited\n@interface Secret{\n}\n\n@Secret class A{}\n\nclass B extends A{} //同样是@Secret的\n```\n当注解工具去获取声明了@Secret的对象时，他能够获取到A的对象和B的对象。\n\n- 预定义注解\n\n常用的有三个：@override、@Deprecated、@SuppressWarnings，具体的作用可以查文档或者源码，不再赘述。\n\n## 注解的定义\n\n上面的讨论中已经涉及到了注解的定义。一个注解是由一个注解接口来定义的：\n\n```\n@interface Result {\n\tString name();\n\tint value() default -1;\n}\n```\n每个元素的声明有两种形式，有默认值和没有默认值的，就像上面那样。注解的元素可以是下面之一：\n\n基本类型|String|Class类型|enum|注解类型|由前面所述类型构成的数组\n\n```\n@interface BugReport{\n\tenum Status{FIXED,OPEN,NEW,CLOSE};\n\tboolean isIgnore() default false;\n\tString id();\n\tClass<?> testCase() default Void.class;\n\tStatus status() default Status.NEW;\n\tAuthor author() default @Author;\n\tString[] reportMsg() default \"\";\n}\n```\n注意，虽然注解元素可以是另一个注解，但是不能在注解中引入循环依赖，比如@BugReport依赖@Author，而@Author又依赖@BugReport。同时，注解元素也不可以为null，元素的值必须是编译期常量。\n\n我们可以通过在注解的定义前声明之前提到的元注解来定制我们的注解，比如：\n\n```\n@Target({ ElementType.METHOD, ElementType.FIELD })\n@Inherited\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@interface Result {\n\tString name() default \"\";\n\tint value() default -1;\n\tString[] reportMsg() default \"\";\n}\n```\n所有的注解接口隐式的继承自java.lang.annotation.Annotation接口。这是一个正常的接口，而不是注解接口。\n```\npublic interface Annotation {\n    boolean equals(Object obj);\n    int hashCode();\n    String toString();\n    Class<? extends Annotation> annotationType();\n}\n```\n也就是说，注解接口也是普通接口的一种。注解接口中的元素实际上也是方法的声明，这些方法类似于bean的get、set，我们使用@Result(name=\"A\")的形式实际上是调用了set方法给某个变量赋值。\n\n既然是接口，那么就应该有实现(不然怎么用呢？)。我们不需要主动提供实现了注解接口的类，虚拟机会在需要的时候产生一些代理类和对象。下文会提到。\n\n既然可以为注解元素赋值，那么必定有方法去获得这些值。也就是注解的解析。\n\n## 注解的解析\n\n我们定义了注解并且应用了注解，但是仅仅这样的话注解并不会起到什么作用。需要我们提供一种工具去解析声明的注解，然后实现一些自动配置或者生成报告的功能。这就是注解的解析。\n\n- 源代码中的注解\n\n注解的用处之一就是自动生成一些包含程序额外信息的文件。比如，根据注解生成代码进度报告，或者bug修复报告等。生成的文件可以是属性文件、xml文件、html文档或者shell脚本。也可以生成java源文件。\n\n注解处理器通常通过集成AbstractProcessor类实现了Processor接口，通过process方法实现处理源码中注解的逻辑。通过声明具体的注解类型来指定该处理器处理哪些注解。\n\n```\n@SupportedAnnotationTypes(\"space.yukai.annotations.BUG\")\nclass AnnotationProcessor extends AbstractProcessor {\n\n\t@Override\n\tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\t\n}\n```\nprocess的两个参数：annotations代表了要处理的注解集，roundEnv是包含有关当前处理循环信息的RoundEnv引用。\n\n[Java注解处理器](http://www.race604.com/annotation-processing/)这篇文章以通过注解自动生成工厂类文件为例，详细介绍了如何处理源码级别的注解。（英文原文在这：http://hannesdorfmann.com/annotation-processing/annotationprocessing101）\n\n注意，我们虽然可以通过源码级别的注解处理器生成新的文件，却很难编辑源文件，比如，通过处理注解自动生成get、set方法。字节码级别的处理器是可以的。\n\n- 字节码中的注解\n\n字节码级别的注解，即存在于class文件中的注解。我们还可以通过BCEL这样的字节码工程类库修改或插入字节码来改变类文件。比如在声明了@LogEntity的方法开始部分插入打印日志信息的字节码。\n\n涉及的不多，不再赘述。\n\n- 运行时的注解\n\n在运行时处理注解是比较常见的注解处理手段。一般是通过反射API获取到我们的注解信息，从而实现一些功能。\n\n下面是自己写的一个例子，通过解析BugReport注解得到一些测试信息，然后通过动态代理的方式生成代理测试类，最后运行测试自动生成测试报告。（不要在意代码有什么缺陷或者其他问题，仅仅是一个例子而已～）\n\n```\npackage space.kyu.proxy;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class AnnotationsTest {\n\tpublic static void main(String[] args) {\n\t\tTestBug testBug = new TestBug(true);\n\t\tTestBug testBug1 = new TestBug(false);\n\t\tTestExecutor executor = new TestExecutor();\n\t\texecutor.addTest(testBug);\n\t\texecutor.addTest(testBug1);\n\t\texecutor.executeTest();\n\t}\n}\n\nclass TestExecutor {\n\tprivate List<Test>  testCases;\n\tpublic TestExecutor() {\n\t\ttestCases = new ArrayList<Test>();\n\t}\n\t\n\tpublic <T extends Test> void  addTest(T testCase) {\n\t\tClass<? extends Object> cl = testCase.getClass();\n\t\tMethod[] declaredMethods = cl.getDeclaredMethods();\n\t\ttry {\n\t\t\tfor (Method method : declaredMethods) {\n\t\t\t\tif (method.isAnnotationPresent(BugReport.class)) {\n\t\t\t\t\tBugReport annotation = method.getAnnotation(BugReport.class);\n\t\t\t\t\tif (annotation != null) {\n\t\t\t\t\t\tSystem.out.println(annotation.toString());\n\t\t\t\t\t\tSystem.out.println(annotation.annotationType().getName());\n\t\t\t\t\t\tSystem.out.println(annotation.getClass().getName());\n\t\t\t\t\t\tString bugId = annotation.id();\n\t\t\t\t\t\tString bugMsg = annotation.msg();\n\t\t\t\t\t\tTest obj = (Test) createBugReportHandler(testCase,bugId,bugMsg);\n\t\t\t\t\t\ttestCases.add(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t}\n\tpublic void executeTest() {\n\t\tfor (Test test : testCases) {\n\t\t\ttest.test();\n\t\t}\n\t}\n\tprivate Object createBugReportHandler(Test testCase, final String bugId, final String bugMsg) {\n\t\treturn Proxy.newProxyInstance(testCase.getClass().getClassLoader(), testCase.getClass().getInterfaces(), new InvocationHandler() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t\tboolean res = (boolean) method.invoke(testCase, args);\n\t\t\t\t//也可以输出到文件中形成测试报告\n\t\t\t\tSystem.out.println(\"******************************\");\n\t\t\t\tSystem.out.println(\"bug: \" + bugId + \"测试结果：\");\n\t\t\t\tif (res) {//测试通过\n\t\t\t\t\tSystem.out.println(\"已通过\");\n\t\t\t\t} else {//测试不通过\n\t\t\t\t\tSystem.out.println(\"未通过\");\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"备注信息：\" + bugMsg);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t}\n}\n\ninterface Test {\n\t/**\n\t * 测试方法 2017年4月1日\n\t * @return \n\t * true 通过测试 \n\t * false 未通过测试\n\t */\n\tboolean test();\n}\n\nclass TestBug implements Test {\n\tboolean fixed;\n\tpublic TestBug(boolean fixed) {\n\t\t//控制测试成功或失败\n\t\tthis.fixed = fixed;\n\t}\n\t@BugReport(id = \"bug001\", msg = \"bug注释：这是一条测试bug\")\n\t@Override\n\tpublic boolean test() {\n\t\tSystem.out.println(\"执行测试...\");\n\t\t//假装测试成功或者失败了\n\t\treturn fixed;\n\t}\n\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface BugReport {\n\tString id();\n\n\tString msg();\n}\n\n```\n\n运行结果：\n\n```\n@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)\nspace.kyu.proxy.BugReport\nspace.kyu.proxy.$Proxy1\n@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)\nspace.kyu.proxy.BugReport\nspace.kyu.proxy.$Proxy1\n执行测试...\n******************************\nbug: bug001测试结果：\n已通过\n备注信息：bug注释：这是一条测试bug\n执行测试...\n******************************\nbug: bug001测试结果：\n未通过\n备注信息：bug注释：这是一条测试bug\n```\n上面的代码很简单，我们要注意的有几点：\n\n1.`method.isAnnotationPresent(BugReport.class)`和 `method.getAnnotation(BugReport.class)`\n\n这两个方法来自于接口AnnotatedElement，Method、Field、Package、Constructor、Class这些类都实现了这个接口，使得这些类拥有了提供所声明的注解的功能。\n\n通过method.getAnnotation(BugReport.class)得到了声明在方法上的BugReport注解，获得这个注解的实例之后，我们就可以调用以该注解声明的元素为名称的方法来获取对应的元素值了。\n\n2.`annotation.annotationType().getName()`和`annotation.getClass().getName()`\n\nannotation.annotationType()方法上面已经提到过了，是Annotation的一个方法，用于描述该注解对象的注解接口。这个方法返回的内容为：space.kyu.proxy.BugReport\n\nannotation.getClass()获得了实现了Annotation接口的代理类，通过调用getName()方法可以打印这个代理类的名称：space.kyu.proxy.$Proxy1。从而印证了我们上面所说，确实自动生成了代理类。\n\n上面的例子很简单，说白了，注解就是给代码加了一些额外的信息，这些信息对代码里面的逻辑是没有任何影响的。但是我们可以通过其他手段获得我们在代码中的注解，从而实现一些重复性的工作。这就是注解的作用。","source":"_posts/java注解.md","raw":"---\nlayout: post\ntitle: java注解\ndate: 2017-03-31 21:07:33\ncategories: 编程\ntags: java\n---\n> 在写java代码的过程中，经常会遇到注解，但是没有去理解注解背后的原理，也没有实现过注解。网上关于java注解的文章已经有很多了，参考了一些资料，整理一下注解这方面的知识~\n\n## 什么是注解\n注解其实很常见。比如@override、Deprecated等。在使用Junit或Spring boot等一些框架的时候，注解更是无处不在了。那么，到底什么是注解呢？\n\n```\nAnnotations, a form of metadata, provide data about a program that is not part of the program itself. \nAnnotations have no direct effect on the operation of the code they annotate.   \n>>[https://docs.oracle.com/javase/tutorial/java/annotations/]\n```\n注解是元数据的一种，提供了关于程序的一些描述信息，但这些信息并不属于这个程序本身的一部分。注解并不会直接影响到代码的执行。\n\n翻译起来有点拗口。实际上，注解是那些插入到源代码中用于某种工具进行处理的标签。注解不会改变对编写的程序的编译方式，对于包含和不包含注解的代码，java编译器都会生成相同的虚拟机指令。\n\n一句话来说，注解只是描述代码的标签。注解本身不会做什么事情，为了使注解起到作用来实现一些黑科技，我们还需要用于处理注解的工具(编写代码处理这些注解)。\n\n我们使用注解可以：\n\n- 生成文档\n\n- 在编译时进行检查。比如@override\n\n- 替代配置文件，实现自动配置。比如 Springboot\n\n注解Annotation是在jdk1.5之后引进的，jdk1.8之后又增加了一些新的特性。接下来的讨论基于jdk1.7。\n\n## 注解的使用\n\n在java中，注解是当做一个修饰符(比如public或static之类的关键词)来使用的。注解可以存在于：\n\n包 | 类(包括enum) | 接口(包括注解接口) | 方法 | 构造器 | 成员变量 | 本地变量 | 方法参数\n\n注意：\n\n1.对于包的注解，需要在[package-info.java](http://strong-life-126-com.iteye.com/blog/806246)中声明。\n\n2.对于本地变量的注解，只能在源码级别上进行处理。所有的本地变量注解在类编译完之后会被遗弃掉。\n\n假如有这样一个注解：(注解的定义见下文)\n\n```\n@interface Result {\n\tString name() default \"\";\n\tint value() default -1;\n    String res() default \"\";\n}\n```\n\n我们可以这样使用它：\n\n`@Result(name=\"res1\",value=1)`\n\n括号中元素的顺序无关紧要\n\n`@Result(value=1,name=\"res1\")等价于@Result(name=\"res1\",value=1)`\n\n如果元素值没有指定，则使用默认值：(没有声明默认值时必须指定元素值)\n\n`@Result等价于@Result(name=\"\",value=-1,\"\")`\n\n如果元素的名字为特殊值value，那么可以忽略这个元素名和等号：\n\n`@Result(1)等价于@Result(name=\"\",value=1,\"\")`\n\n如果元素是数组，那么他的值要用括号括起来：\n\n`@Result(res={\"a\",\"b\"})`\n\n如果数组是单值，可以忽略这些括号：\n\n`@Result(res=\"a\")`\n\n## 注解分类\n\n根据注解的用途和使用方式，注解可以分为以下几类：\n\n元注解：注解注解的注解。也就是用来描述注解定义的注解\n\n预定义注解：jdk内置的一些注解\n\n自定义注解：我们自己定义的注解\n\n- 元注解\n\n元注解包含下面几个：\n\n**@Target: 指定这个注解可以应用于哪些项**\n\n```\npublic enum ElementType {\n    /** Class, interface (including annotation type), or enum declaration */\n    TYPE,\n\n    /** Field declaration (includes enum constants) */\n    FIELD,\n\n    /** Method declaration */\n    METHOD,\n\n    /** Parameter declaration */\n    PARAMETER,\n\n    /** Constructor declaration */\n    CONSTRUCTOR,\n\n    /** Local variable declaration */\n    LOCAL_VARIABLE,\n\n    /** Annotation type declaration */\n    ANNOTATION_TYPE,\n\n    /** Package declaration */\n    PACKAGE\n}\n```\n比如，我们定义了一个注解Bug，该注解只能应用于方法或成员变量：\n\n```\n@Target({ElementType.METHOD,ElementType.FIELD})\n@interface Bug{\n\tint value() default -1;\n}\n```\n注解Bug则只能用于类方法或成员变量，如果注解了其他项比如类或者包，编译则不会通过。\n\n对于一个没有声明@Target的注解，可以应用到任何项上。\n\n**@Retention: 指定这个注解可以保留多久**\n\n```\npublic enum RetentionPolicy {\n    /**\n     * Annotations are to be discarded by the compiler.\n     */\n    SOURCE,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler\n     * but need not be retained by the VM at run time.  This is the default\n     * behavior.\n     */\n    CLASS,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler and\n     * retained by the VM at run time, so they may be read reflectively.\n     *\n     * @see java.lang.reflect.AnnotatedElement\n     */\n    RUNTIME\n}\n```\nSOURCE：只存在于源代码，编译成.class之后就没了\n\nCLASS: 保留到类文件中，但是虚拟机不会载入\n\nRUNTIME：保留到类文件中，并且虚拟机会载入。这意味着通过反射可以获取到这些注解和注解元素值\n\n默认情况下(没有声明@Retention)，注解保留级别为CLASS\n\n**@Document：指定这个注解应该包含在文档中**\n\n文档化的注解意味着像javadoc这样的工具生成的文档中会包含这些注解。比如：\n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})\npublic @interface Deprecated {\n}\n```\n@Deprecated是文档化的注解，URLDecoder.decode(String s)方法应用了这个注解：\n\n{% asset_img decode.jpg decode %}\n\n{% asset_img doc.jpg doc %}\n\n可以在文档中看到Deprecated的出现。\n\n**@Inherited: 指定一个注解，当他应用于一个类的时候，能够自动被其子类继承**\n\n@Inherited只能应用于对类的注解。如果一个类具有继承注解，那么他的所有子类都自动具有同样的注解。\n\n比如，定义了一个继承注解@Secret表示一个类是隐私的不可被序列化传输的，那么该类的子类会被自动注解为不可序列化传输的。\n\n```\n@Inherited\n@interface Secret{\n}\n\n@Secret class A{}\n\nclass B extends A{} //同样是@Secret的\n```\n当注解工具去获取声明了@Secret的对象时，他能够获取到A的对象和B的对象。\n\n- 预定义注解\n\n常用的有三个：@override、@Deprecated、@SuppressWarnings，具体的作用可以查文档或者源码，不再赘述。\n\n## 注解的定义\n\n上面的讨论中已经涉及到了注解的定义。一个注解是由一个注解接口来定义的：\n\n```\n@interface Result {\n\tString name();\n\tint value() default -1;\n}\n```\n每个元素的声明有两种形式，有默认值和没有默认值的，就像上面那样。注解的元素可以是下面之一：\n\n基本类型|String|Class类型|enum|注解类型|由前面所述类型构成的数组\n\n```\n@interface BugReport{\n\tenum Status{FIXED,OPEN,NEW,CLOSE};\n\tboolean isIgnore() default false;\n\tString id();\n\tClass<?> testCase() default Void.class;\n\tStatus status() default Status.NEW;\n\tAuthor author() default @Author;\n\tString[] reportMsg() default \"\";\n}\n```\n注意，虽然注解元素可以是另一个注解，但是不能在注解中引入循环依赖，比如@BugReport依赖@Author，而@Author又依赖@BugReport。同时，注解元素也不可以为null，元素的值必须是编译期常量。\n\n我们可以通过在注解的定义前声明之前提到的元注解来定制我们的注解，比如：\n\n```\n@Target({ ElementType.METHOD, ElementType.FIELD })\n@Inherited\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@interface Result {\n\tString name() default \"\";\n\tint value() default -1;\n\tString[] reportMsg() default \"\";\n}\n```\n所有的注解接口隐式的继承自java.lang.annotation.Annotation接口。这是一个正常的接口，而不是注解接口。\n```\npublic interface Annotation {\n    boolean equals(Object obj);\n    int hashCode();\n    String toString();\n    Class<? extends Annotation> annotationType();\n}\n```\n也就是说，注解接口也是普通接口的一种。注解接口中的元素实际上也是方法的声明，这些方法类似于bean的get、set，我们使用@Result(name=\"A\")的形式实际上是调用了set方法给某个变量赋值。\n\n既然是接口，那么就应该有实现(不然怎么用呢？)。我们不需要主动提供实现了注解接口的类，虚拟机会在需要的时候产生一些代理类和对象。下文会提到。\n\n既然可以为注解元素赋值，那么必定有方法去获得这些值。也就是注解的解析。\n\n## 注解的解析\n\n我们定义了注解并且应用了注解，但是仅仅这样的话注解并不会起到什么作用。需要我们提供一种工具去解析声明的注解，然后实现一些自动配置或者生成报告的功能。这就是注解的解析。\n\n- 源代码中的注解\n\n注解的用处之一就是自动生成一些包含程序额外信息的文件。比如，根据注解生成代码进度报告，或者bug修复报告等。生成的文件可以是属性文件、xml文件、html文档或者shell脚本。也可以生成java源文件。\n\n注解处理器通常通过集成AbstractProcessor类实现了Processor接口，通过process方法实现处理源码中注解的逻辑。通过声明具体的注解类型来指定该处理器处理哪些注解。\n\n```\n@SupportedAnnotationTypes(\"space.yukai.annotations.BUG\")\nclass AnnotationProcessor extends AbstractProcessor {\n\n\t@Override\n\tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\t\n}\n```\nprocess的两个参数：annotations代表了要处理的注解集，roundEnv是包含有关当前处理循环信息的RoundEnv引用。\n\n[Java注解处理器](http://www.race604.com/annotation-processing/)这篇文章以通过注解自动生成工厂类文件为例，详细介绍了如何处理源码级别的注解。（英文原文在这：http://hannesdorfmann.com/annotation-processing/annotationprocessing101）\n\n注意，我们虽然可以通过源码级别的注解处理器生成新的文件，却很难编辑源文件，比如，通过处理注解自动生成get、set方法。字节码级别的处理器是可以的。\n\n- 字节码中的注解\n\n字节码级别的注解，即存在于class文件中的注解。我们还可以通过BCEL这样的字节码工程类库修改或插入字节码来改变类文件。比如在声明了@LogEntity的方法开始部分插入打印日志信息的字节码。\n\n涉及的不多，不再赘述。\n\n- 运行时的注解\n\n在运行时处理注解是比较常见的注解处理手段。一般是通过反射API获取到我们的注解信息，从而实现一些功能。\n\n下面是自己写的一个例子，通过解析BugReport注解得到一些测试信息，然后通过动态代理的方式生成代理测试类，最后运行测试自动生成测试报告。（不要在意代码有什么缺陷或者其他问题，仅仅是一个例子而已～）\n\n```\npackage space.kyu.proxy;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class AnnotationsTest {\n\tpublic static void main(String[] args) {\n\t\tTestBug testBug = new TestBug(true);\n\t\tTestBug testBug1 = new TestBug(false);\n\t\tTestExecutor executor = new TestExecutor();\n\t\texecutor.addTest(testBug);\n\t\texecutor.addTest(testBug1);\n\t\texecutor.executeTest();\n\t}\n}\n\nclass TestExecutor {\n\tprivate List<Test>  testCases;\n\tpublic TestExecutor() {\n\t\ttestCases = new ArrayList<Test>();\n\t}\n\t\n\tpublic <T extends Test> void  addTest(T testCase) {\n\t\tClass<? extends Object> cl = testCase.getClass();\n\t\tMethod[] declaredMethods = cl.getDeclaredMethods();\n\t\ttry {\n\t\t\tfor (Method method : declaredMethods) {\n\t\t\t\tif (method.isAnnotationPresent(BugReport.class)) {\n\t\t\t\t\tBugReport annotation = method.getAnnotation(BugReport.class);\n\t\t\t\t\tif (annotation != null) {\n\t\t\t\t\t\tSystem.out.println(annotation.toString());\n\t\t\t\t\t\tSystem.out.println(annotation.annotationType().getName());\n\t\t\t\t\t\tSystem.out.println(annotation.getClass().getName());\n\t\t\t\t\t\tString bugId = annotation.id();\n\t\t\t\t\t\tString bugMsg = annotation.msg();\n\t\t\t\t\t\tTest obj = (Test) createBugReportHandler(testCase,bugId,bugMsg);\n\t\t\t\t\t\ttestCases.add(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t}\n\tpublic void executeTest() {\n\t\tfor (Test test : testCases) {\n\t\t\ttest.test();\n\t\t}\n\t}\n\tprivate Object createBugReportHandler(Test testCase, final String bugId, final String bugMsg) {\n\t\treturn Proxy.newProxyInstance(testCase.getClass().getClassLoader(), testCase.getClass().getInterfaces(), new InvocationHandler() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t\tboolean res = (boolean) method.invoke(testCase, args);\n\t\t\t\t//也可以输出到文件中形成测试报告\n\t\t\t\tSystem.out.println(\"******************************\");\n\t\t\t\tSystem.out.println(\"bug: \" + bugId + \"测试结果：\");\n\t\t\t\tif (res) {//测试通过\n\t\t\t\t\tSystem.out.println(\"已通过\");\n\t\t\t\t} else {//测试不通过\n\t\t\t\t\tSystem.out.println(\"未通过\");\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"备注信息：\" + bugMsg);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t}\n}\n\ninterface Test {\n\t/**\n\t * 测试方法 2017年4月1日\n\t * @return \n\t * true 通过测试 \n\t * false 未通过测试\n\t */\n\tboolean test();\n}\n\nclass TestBug implements Test {\n\tboolean fixed;\n\tpublic TestBug(boolean fixed) {\n\t\t//控制测试成功或失败\n\t\tthis.fixed = fixed;\n\t}\n\t@BugReport(id = \"bug001\", msg = \"bug注释：这是一条测试bug\")\n\t@Override\n\tpublic boolean test() {\n\t\tSystem.out.println(\"执行测试...\");\n\t\t//假装测试成功或者失败了\n\t\treturn fixed;\n\t}\n\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface BugReport {\n\tString id();\n\n\tString msg();\n}\n\n```\n\n运行结果：\n\n```\n@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)\nspace.kyu.proxy.BugReport\nspace.kyu.proxy.$Proxy1\n@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)\nspace.kyu.proxy.BugReport\nspace.kyu.proxy.$Proxy1\n执行测试...\n******************************\nbug: bug001测试结果：\n已通过\n备注信息：bug注释：这是一条测试bug\n执行测试...\n******************************\nbug: bug001测试结果：\n未通过\n备注信息：bug注释：这是一条测试bug\n```\n上面的代码很简单，我们要注意的有几点：\n\n1.`method.isAnnotationPresent(BugReport.class)`和 `method.getAnnotation(BugReport.class)`\n\n这两个方法来自于接口AnnotatedElement，Method、Field、Package、Constructor、Class这些类都实现了这个接口，使得这些类拥有了提供所声明的注解的功能。\n\n通过method.getAnnotation(BugReport.class)得到了声明在方法上的BugReport注解，获得这个注解的实例之后，我们就可以调用以该注解声明的元素为名称的方法来获取对应的元素值了。\n\n2.`annotation.annotationType().getName()`和`annotation.getClass().getName()`\n\nannotation.annotationType()方法上面已经提到过了，是Annotation的一个方法，用于描述该注解对象的注解接口。这个方法返回的内容为：space.kyu.proxy.BugReport\n\nannotation.getClass()获得了实现了Annotation接口的代理类，通过调用getName()方法可以打印这个代理类的名称：space.kyu.proxy.$Proxy1。从而印证了我们上面所说，确实自动生成了代理类。\n\n上面的例子很简单，说白了，注解就是给代码加了一些额外的信息，这些信息对代码里面的逻辑是没有任何影响的。但是我们可以通过其他手段获得我们在代码中的注解，从而实现一些重复性的工作。这就是注解的作用。","slug":"java注解","published":1,"updated":"2017-04-02T02:32:19.000Z","_id":"cj0xuzlrr0026vegc5xrl4yju","comments":1,"photos":[],"link":"","content":"<blockquote>\n<p>在写java代码的过程中，经常会遇到注解，但是没有去理解注解背后的原理，也没有实现过注解。网上关于java注解的文章已经有很多了，参考了一些资料，整理一下注解这方面的知识~</p>\n</blockquote>\n<h2 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h2><p>注解其实很常见。比如@override、Deprecated等。在使用Junit或Spring boot等一些框架的时候，注解更是无处不在了。那么，到底什么是注解呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Annotations, a form of metadata, provide data about a program that is not part of the program itself. </div><div class=\"line\">Annotations have no direct effect on the operation of the code they annotate.   </div><div class=\"line\">&gt;&gt;[https://docs.oracle.com/javase/tutorial/java/annotations/]</div></pre></td></tr></table></figure>\n<p>注解是元数据的一种，提供了关于程序的一些描述信息，但这些信息并不属于这个程序本身的一部分。注解并不会直接影响到代码的执行。</p>\n<p>翻译起来有点拗口。实际上，注解是那些插入到源代码中用于某种工具进行处理的标签。注解不会改变对编写的程序的编译方式，对于包含和不包含注解的代码，java编译器都会生成相同的虚拟机指令。</p>\n<p>一句话来说，注解只是描述代码的标签。注解本身不会做什么事情，为了使注解起到作用来实现一些黑科技，我们还需要用于处理注解的工具(编写代码处理这些注解)。</p>\n<p>我们使用注解可以：</p>\n<ul>\n<li><p>生成文档</p>\n</li>\n<li><p>在编译时进行检查。比如@override</p>\n</li>\n<li><p>替代配置文件，实现自动配置。比如 Springboot</p>\n</li>\n</ul>\n<p>注解Annotation是在jdk1.5之后引进的，jdk1.8之后又增加了一些新的特性。接下来的讨论基于jdk1.7。</p>\n<h2 id=\"注解的使用\"><a href=\"#注解的使用\" class=\"headerlink\" title=\"注解的使用\"></a>注解的使用</h2><p>在java中，注解是当做一个修饰符(比如public或static之类的关键词)来使用的。注解可以存在于：</p>\n<p>包 | 类(包括enum) | 接口(包括注解接口) | 方法 | 构造器 | 成员变量 | 本地变量 | 方法参数</p>\n<p>注意：</p>\n<p>1.对于包的注解，需要在<a href=\"http://strong-life-126-com.iteye.com/blog/806246\" target=\"_blank\" rel=\"external\">package-info.java</a>中声明。</p>\n<p>2.对于本地变量的注解，只能在源码级别上进行处理。所有的本地变量注解在类编译完之后会被遗弃掉。</p>\n<p>假如有这样一个注解：(注解的定义见下文)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Result &#123;</div><div class=\"line\">\tString name() default &quot;&quot;;</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">    String res() default &quot;&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以这样使用它：</p>\n<p><code>@Result(name=&quot;res1&quot;,value=1)</code></p>\n<p>括号中元素的顺序无关紧要</p>\n<p><code>@Result(value=1,name=&quot;res1&quot;)等价于@Result(name=&quot;res1&quot;,value=1)</code></p>\n<p>如果元素值没有指定，则使用默认值：(没有声明默认值时必须指定元素值)</p>\n<p><code>@Result等价于@Result(name=&quot;&quot;,value=-1,&quot;&quot;)</code></p>\n<p>如果元素的名字为特殊值value，那么可以忽略这个元素名和等号：</p>\n<p><code>@Result(1)等价于@Result(name=&quot;&quot;,value=1,&quot;&quot;)</code></p>\n<p>如果元素是数组，那么他的值要用括号括起来：</p>\n<p><code>@Result(res={&quot;a&quot;,&quot;b&quot;})</code></p>\n<p>如果数组是单值，可以忽略这些括号：</p>\n<p><code>@Result(res=&quot;a&quot;)</code></p>\n<h2 id=\"注解分类\"><a href=\"#注解分类\" class=\"headerlink\" title=\"注解分类\"></a>注解分类</h2><p>根据注解的用途和使用方式，注解可以分为以下几类：</p>\n<p>元注解：注解注解的注解。也就是用来描述注解定义的注解</p>\n<p>预定义注解：jdk内置的一些注解</p>\n<p>自定义注解：我们自己定义的注解</p>\n<ul>\n<li>元注解</li>\n</ul>\n<p>元注解包含下面几个：</p>\n<p><strong>@Target: 指定这个注解可以应用于哪些项</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public enum ElementType &#123;</div><div class=\"line\">    /** Class, interface (including annotation type), or enum declaration */</div><div class=\"line\">    TYPE,</div><div class=\"line\"></div><div class=\"line\">    /** Field declaration (includes enum constants) */</div><div class=\"line\">    FIELD,</div><div class=\"line\"></div><div class=\"line\">    /** Method declaration */</div><div class=\"line\">    METHOD,</div><div class=\"line\"></div><div class=\"line\">    /** Parameter declaration */</div><div class=\"line\">    PARAMETER,</div><div class=\"line\"></div><div class=\"line\">    /** Constructor declaration */</div><div class=\"line\">    CONSTRUCTOR,</div><div class=\"line\"></div><div class=\"line\">    /** Local variable declaration */</div><div class=\"line\">    LOCAL_VARIABLE,</div><div class=\"line\"></div><div class=\"line\">    /** Annotation type declaration */</div><div class=\"line\">    ANNOTATION_TYPE,</div><div class=\"line\"></div><div class=\"line\">    /** Package declaration */</div><div class=\"line\">    PACKAGE</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>比如，我们定义了一个注解Bug，该注解只能应用于方法或成员变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</div><div class=\"line\">@interface Bug&#123;</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注解Bug则只能用于类方法或成员变量，如果注解了其他项比如类或者包，编译则不会通过。</p>\n<p>对于一个没有声明@Target的注解，可以应用到任何项上。</p>\n<p><strong>@Retention: 指定这个注解可以保留多久</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public enum RetentionPolicy &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Annotations are to be discarded by the compiler.</div><div class=\"line\">     */</div><div class=\"line\">    SOURCE,</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Annotations are to be recorded in the class file by the compiler</div><div class=\"line\">     * but need not be retained by the VM at run time.  This is the default</div><div class=\"line\">     * behavior.</div><div class=\"line\">     */</div><div class=\"line\">    CLASS,</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Annotations are to be recorded in the class file by the compiler and</div><div class=\"line\">     * retained by the VM at run time, so they may be read reflectively.</div><div class=\"line\">     *</div><div class=\"line\">     * @see java.lang.reflect.AnnotatedElement</div><div class=\"line\">     */</div><div class=\"line\">    RUNTIME</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>SOURCE：只存在于源代码，编译成.class之后就没了</p>\n<p>CLASS: 保留到类文件中，但是虚拟机不会载入</p>\n<p>RUNTIME：保留到类文件中，并且虚拟机会载入。这意味着通过反射可以获取到这些注解和注解元素值</p>\n<p>默认情况下(没有声明@Retention)，注解保留级别为CLASS</p>\n<p><strong>@Document：指定这个注解应该包含在文档中</strong></p>\n<p>文档化的注解意味着像javadoc这样的工具生成的文档中会包含这些注解。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Documented</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</div><div class=\"line\">public @interface Deprecated &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>@Deprecated是文档化的注解，URLDecoder.decode(String s)方法应用了这个注解：</p>\n<img src=\"/2017/03/31/java注解/decode.jpg\" alt=\"decode\" title=\"decode\">\n<img src=\"/2017/03/31/java注解/doc.jpg\" alt=\"doc\" title=\"doc\">\n<p>可以在文档中看到Deprecated的出现。</p>\n<p><strong>@Inherited: 指定一个注解，当他应用于一个类的时候，能够自动被其子类继承</strong></p>\n<p>@Inherited只能应用于对类的注解。如果一个类具有继承注解，那么他的所有子类都自动具有同样的注解。</p>\n<p>比如，定义了一个继承注解@Secret表示一个类是隐私的不可被序列化传输的，那么该类的子类会被自动注解为不可序列化传输的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Inherited</div><div class=\"line\">@interface Secret&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Secret class A&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">class B extends A&#123;&#125; //同样是@Secret的</div></pre></td></tr></table></figure>\n<p>当注解工具去获取声明了@Secret的对象时，他能够获取到A的对象和B的对象。</p>\n<ul>\n<li>预定义注解</li>\n</ul>\n<p>常用的有三个：@override、@Deprecated、@SuppressWarnings，具体的作用可以查文档或者源码，不再赘述。</p>\n<h2 id=\"注解的定义\"><a href=\"#注解的定义\" class=\"headerlink\" title=\"注解的定义\"></a>注解的定义</h2><p>上面的讨论中已经涉及到了注解的定义。一个注解是由一个注解接口来定义的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Result &#123;</div><div class=\"line\">\tString name();</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每个元素的声明有两种形式，有默认值和没有默认值的，就像上面那样。注解的元素可以是下面之一：</p>\n<p>基本类型|String|Class类型|enum|注解类型|由前面所述类型构成的数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface BugReport&#123;</div><div class=\"line\">\tenum Status&#123;FIXED,OPEN,NEW,CLOSE&#125;;</div><div class=\"line\">\tboolean isIgnore() default false;</div><div class=\"line\">\tString id();</div><div class=\"line\">\tClass&lt;?&gt; testCase() default Void.class;</div><div class=\"line\">\tStatus status() default Status.NEW;</div><div class=\"line\">\tAuthor author() default @Author;</div><div class=\"line\">\tString[] reportMsg() default &quot;&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，虽然注解元素可以是另一个注解，但是不能在注解中引入循环依赖，比如@BugReport依赖@Author，而@Author又依赖@BugReport。同时，注解元素也不可以为null，元素的值必须是编译期常量。</p>\n<p>我们可以通过在注解的定义前声明之前提到的元注解来定制我们的注解，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(&#123; ElementType.METHOD, ElementType.FIELD &#125;)</div><div class=\"line\">@Inherited</div><div class=\"line\">@Documented</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@interface Result &#123;</div><div class=\"line\">\tString name() default &quot;&quot;;</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">\tString[] reportMsg() default &quot;&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所有的注解接口隐式的继承自java.lang.annotation.Annotation接口。这是一个正常的接口，而不是注解接口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Annotation &#123;</div><div class=\"line\">    boolean equals(Object obj);</div><div class=\"line\">    int hashCode();</div><div class=\"line\">    String toString();</div><div class=\"line\">    Class&lt;? extends Annotation&gt; annotationType();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>也就是说，注解接口也是普通接口的一种。注解接口中的元素实际上也是方法的声明，这些方法类似于bean的get、set，我们使用@Result(name=”A”)的形式实际上是调用了set方法给某个变量赋值。</p>\n<p>既然是接口，那么就应该有实现(不然怎么用呢？)。我们不需要主动提供实现了注解接口的类，虚拟机会在需要的时候产生一些代理类和对象。下文会提到。</p>\n<p>既然可以为注解元素赋值，那么必定有方法去获得这些值。也就是注解的解析。</p>\n<h2 id=\"注解的解析\"><a href=\"#注解的解析\" class=\"headerlink\" title=\"注解的解析\"></a>注解的解析</h2><p>我们定义了注解并且应用了注解，但是仅仅这样的话注解并不会起到什么作用。需要我们提供一种工具去解析声明的注解，然后实现一些自动配置或者生成报告的功能。这就是注解的解析。</p>\n<ul>\n<li>源代码中的注解</li>\n</ul>\n<p>注解的用处之一就是自动生成一些包含程序额外信息的文件。比如，根据注解生成代码进度报告，或者bug修复报告等。生成的文件可以是属性文件、xml文件、html文档或者shell脚本。也可以生成java源文件。</p>\n<p>注解处理器通常通过集成AbstractProcessor类实现了Processor接口，通过process方法实现处理源码中注解的逻辑。通过声明具体的注解类型来指定该处理器处理哪些注解。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SupportedAnnotationTypes(&quot;space.yukai.annotations.BUG&quot;)</div><div class=\"line\">class AnnotationProcessor extends AbstractProcessor &#123;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\treturn false;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>process的两个参数：annotations代表了要处理的注解集，roundEnv是包含有关当前处理循环信息的RoundEnv引用。</p>\n<p><a href=\"http://www.race604.com/annotation-processing/\" target=\"_blank\" rel=\"external\">Java注解处理器</a>这篇文章以通过注解自动生成工厂类文件为例，详细介绍了如何处理源码级别的注解。（英文原文在这：<a href=\"http://hannesdorfmann.com/annotation-processing/annotationprocessing101）\" target=\"_blank\" rel=\"external\">http://hannesdorfmann.com/annotation-processing/annotationprocessing101）</a></p>\n<p>注意，我们虽然可以通过源码级别的注解处理器生成新的文件，却很难编辑源文件，比如，通过处理注解自动生成get、set方法。字节码级别的处理器是可以的。</p>\n<ul>\n<li>字节码中的注解</li>\n</ul>\n<p>字节码级别的注解，即存在于class文件中的注解。我们还可以通过BCEL这样的字节码工程类库修改或插入字节码来改变类文件。比如在声明了@LogEntity的方法开始部分插入打印日志信息的字节码。</p>\n<p>涉及的不多，不再赘述。</p>\n<ul>\n<li>运行时的注解</li>\n</ul>\n<p>在运行时处理注解是比较常见的注解处理手段。一般是通过反射API获取到我们的注解信息，从而实现一些功能。</p>\n<p>下面是自己写的一个例子，通过解析BugReport注解得到一些测试信息，然后通过动态代理的方式生成代理测试类，最后运行测试自动生成测试报告。（不要在意代码有什么缺陷或者其他问题，仅仅是一个例子而已～）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\">package space.kyu.proxy;</div><div class=\"line\"></div><div class=\"line\">import java.lang.annotation.ElementType;</div><div class=\"line\">import java.lang.annotation.Retention;</div><div class=\"line\">import java.lang.annotation.RetentionPolicy;</div><div class=\"line\">import java.lang.annotation.Target;</div><div class=\"line\">import java.lang.reflect.InvocationHandler;</div><div class=\"line\">import java.lang.reflect.Method;</div><div class=\"line\">import java.lang.reflect.Proxy;</div><div class=\"line\">import java.util.ArrayList;</div><div class=\"line\">import java.util.List;</div><div class=\"line\"></div><div class=\"line\">public class AnnotationsTest &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tTestBug testBug = new TestBug(true);</div><div class=\"line\">\t\tTestBug testBug1 = new TestBug(false);</div><div class=\"line\">\t\tTestExecutor executor = new TestExecutor();</div><div class=\"line\">\t\texecutor.addTest(testBug);</div><div class=\"line\">\t\texecutor.addTest(testBug1);</div><div class=\"line\">\t\texecutor.executeTest();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class TestExecutor &#123;</div><div class=\"line\">\tprivate List&lt;Test&gt;  testCases;</div><div class=\"line\">\tpublic TestExecutor() &#123;</div><div class=\"line\">\t\ttestCases = new ArrayList&lt;Test&gt;();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic &lt;T extends Test&gt; void  addTest(T testCase) &#123;</div><div class=\"line\">\t\tClass&lt;? extends Object&gt; cl = testCase.getClass();</div><div class=\"line\">\t\tMethod[] declaredMethods = cl.getDeclaredMethods();</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tfor (Method method : declaredMethods) &#123;</div><div class=\"line\">\t\t\t\tif (method.isAnnotationPresent(BugReport.class)) &#123;</div><div class=\"line\">\t\t\t\t\tBugReport annotation = method.getAnnotation(BugReport.class);</div><div class=\"line\">\t\t\t\t\tif (annotation != null) &#123;</div><div class=\"line\">\t\t\t\t\t\tSystem.out.println(annotation.toString());</div><div class=\"line\">\t\t\t\t\t\tSystem.out.println(annotation.annotationType().getName());</div><div class=\"line\">\t\t\t\t\t\tSystem.out.println(annotation.getClass().getName());</div><div class=\"line\">\t\t\t\t\t\tString bugId = annotation.id();</div><div class=\"line\">\t\t\t\t\t\tString bugMsg = annotation.msg();</div><div class=\"line\">\t\t\t\t\t\tTest obj = (Test) createBugReportHandler(testCase,bugId,bugMsg);</div><div class=\"line\">\t\t\t\t\t\ttestCases.add(obj);</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; catch (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\tthrow new IllegalStateException(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void executeTest() &#123;</div><div class=\"line\">\t\tfor (Test test : testCases) &#123;</div><div class=\"line\">\t\t\ttest.test();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tprivate Object createBugReportHandler(Test testCase, final String bugId, final String bugMsg) &#123;</div><div class=\"line\">\t\treturn Proxy.newProxyInstance(testCase.getClass().getClassLoader(), testCase.getClass().getInterfaces(), new InvocationHandler() &#123;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\t@Override</div><div class=\"line\">\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class=\"line\">\t\t\t\tboolean res = (boolean) method.invoke(testCase, args);</div><div class=\"line\">\t\t\t\t//也可以输出到文件中形成测试报告</div><div class=\"line\">\t\t\t\tSystem.out.println(&quot;******************************&quot;);</div><div class=\"line\">\t\t\t\tSystem.out.println(&quot;bug: &quot; + bugId + &quot;测试结果：&quot;);</div><div class=\"line\">\t\t\t\tif (res) &#123;//测试通过</div><div class=\"line\">\t\t\t\t\tSystem.out.println(&quot;已通过&quot;);</div><div class=\"line\">\t\t\t\t&#125; else &#123;//测试不通过</div><div class=\"line\">\t\t\t\t\tSystem.out.println(&quot;未通过&quot;);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tSystem.out.println(&quot;备注信息：&quot; + bugMsg);</div><div class=\"line\">\t\t\t\treturn res;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">interface Test &#123;</div><div class=\"line\">\t/**</div><div class=\"line\">\t * 测试方法 2017年4月1日</div><div class=\"line\">\t * @return </div><div class=\"line\">\t * true 通过测试 </div><div class=\"line\">\t * false 未通过测试</div><div class=\"line\">\t */</div><div class=\"line\">\tboolean test();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class TestBug implements Test &#123;</div><div class=\"line\">\tboolean fixed;</div><div class=\"line\">\tpublic TestBug(boolean fixed) &#123;</div><div class=\"line\">\t\t//控制测试成功或失败</div><div class=\"line\">\t\tthis.fixed = fixed;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@BugReport(id = &quot;bug001&quot;, msg = &quot;bug注释：这是一条测试bug&quot;)</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean test() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;执行测试...&quot;);</div><div class=\"line\">\t\t//假装测试成功或者失败了</div><div class=\"line\">\t\treturn fixed;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Target(ElementType.METHOD)</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@interface BugReport &#123;</div><div class=\"line\">\tString id();</div><div class=\"line\"></div><div class=\"line\">\tString msg();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)</div><div class=\"line\">space.kyu.proxy.BugReport</div><div class=\"line\">space.kyu.proxy.$Proxy1</div><div class=\"line\">@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)</div><div class=\"line\">space.kyu.proxy.BugReport</div><div class=\"line\">space.kyu.proxy.$Proxy1</div><div class=\"line\">执行测试...</div><div class=\"line\">******************************</div><div class=\"line\">bug: bug001测试结果：</div><div class=\"line\">已通过</div><div class=\"line\">备注信息：bug注释：这是一条测试bug</div><div class=\"line\">执行测试...</div><div class=\"line\">******************************</div><div class=\"line\">bug: bug001测试结果：</div><div class=\"line\">未通过</div><div class=\"line\">备注信息：bug注释：这是一条测试bug</div></pre></td></tr></table></figure>\n<p>上面的代码很简单，我们要注意的有几点：</p>\n<p>1.<code>method.isAnnotationPresent(BugReport.class)</code>和 <code>method.getAnnotation(BugReport.class)</code></p>\n<p>这两个方法来自于接口AnnotatedElement，Method、Field、Package、Constructor、Class这些类都实现了这个接口，使得这些类拥有了提供所声明的注解的功能。</p>\n<p>通过method.getAnnotation(BugReport.class)得到了声明在方法上的BugReport注解，获得这个注解的实例之后，我们就可以调用以该注解声明的元素为名称的方法来获取对应的元素值了。</p>\n<p>2.<code>annotation.annotationType().getName()</code>和<code>annotation.getClass().getName()</code></p>\n<p>annotation.annotationType()方法上面已经提到过了，是Annotation的一个方法，用于描述该注解对象的注解接口。这个方法返回的内容为：space.kyu.proxy.BugReport</p>\n<p>annotation.getClass()获得了实现了Annotation接口的代理类，通过调用getName()方法可以打印这个代理类的名称：space.kyu.proxy.$Proxy1。从而印证了我们上面所说，确实自动生成了代理类。</p>\n<p>上面的例子很简单，说白了，注解就是给代码加了一些额外的信息，这些信息对代码里面的逻辑是没有任何影响的。但是我们可以通过其他手段获得我们在代码中的注解，从而实现一些重复性的工作。这就是注解的作用。</p>\n","excerpt":"","more":"<blockquote>\n<p>在写java代码的过程中，经常会遇到注解，但是没有去理解注解背后的原理，也没有实现过注解。网上关于java注解的文章已经有很多了，参考了一些资料，整理一下注解这方面的知识~</p>\n</blockquote>\n<h2 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h2><p>注解其实很常见。比如@override、Deprecated等。在使用Junit或Spring boot等一些框架的时候，注解更是无处不在了。那么，到底什么是注解呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Annotations, a form of metadata, provide data about a program that is not part of the program itself. </div><div class=\"line\">Annotations have no direct effect on the operation of the code they annotate.   </div><div class=\"line\">&gt;&gt;[https://docs.oracle.com/javase/tutorial/java/annotations/]</div></pre></td></tr></table></figure>\n<p>注解是元数据的一种，提供了关于程序的一些描述信息，但这些信息并不属于这个程序本身的一部分。注解并不会直接影响到代码的执行。</p>\n<p>翻译起来有点拗口。实际上，注解是那些插入到源代码中用于某种工具进行处理的标签。注解不会改变对编写的程序的编译方式，对于包含和不包含注解的代码，java编译器都会生成相同的虚拟机指令。</p>\n<p>一句话来说，注解只是描述代码的标签。注解本身不会做什么事情，为了使注解起到作用来实现一些黑科技，我们还需要用于处理注解的工具(编写代码处理这些注解)。</p>\n<p>我们使用注解可以：</p>\n<ul>\n<li><p>生成文档</p>\n</li>\n<li><p>在编译时进行检查。比如@override</p>\n</li>\n<li><p>替代配置文件，实现自动配置。比如 Springboot</p>\n</li>\n</ul>\n<p>注解Annotation是在jdk1.5之后引进的，jdk1.8之后又增加了一些新的特性。接下来的讨论基于jdk1.7。</p>\n<h2 id=\"注解的使用\"><a href=\"#注解的使用\" class=\"headerlink\" title=\"注解的使用\"></a>注解的使用</h2><p>在java中，注解是当做一个修饰符(比如public或static之类的关键词)来使用的。注解可以存在于：</p>\n<p>包 | 类(包括enum) | 接口(包括注解接口) | 方法 | 构造器 | 成员变量 | 本地变量 | 方法参数</p>\n<p>注意：</p>\n<p>1.对于包的注解，需要在<a href=\"http://strong-life-126-com.iteye.com/blog/806246\">package-info.java</a>中声明。</p>\n<p>2.对于本地变量的注解，只能在源码级别上进行处理。所有的本地变量注解在类编译完之后会被遗弃掉。</p>\n<p>假如有这样一个注解：(注解的定义见下文)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Result &#123;</div><div class=\"line\">\tString name() default &quot;&quot;;</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">    String res() default &quot;&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以这样使用它：</p>\n<p><code>@Result(name=&quot;res1&quot;,value=1)</code></p>\n<p>括号中元素的顺序无关紧要</p>\n<p><code>@Result(value=1,name=&quot;res1&quot;)等价于@Result(name=&quot;res1&quot;,value=1)</code></p>\n<p>如果元素值没有指定，则使用默认值：(没有声明默认值时必须指定元素值)</p>\n<p><code>@Result等价于@Result(name=&quot;&quot;,value=-1,&quot;&quot;)</code></p>\n<p>如果元素的名字为特殊值value，那么可以忽略这个元素名和等号：</p>\n<p><code>@Result(1)等价于@Result(name=&quot;&quot;,value=1,&quot;&quot;)</code></p>\n<p>如果元素是数组，那么他的值要用括号括起来：</p>\n<p><code>@Result(res={&quot;a&quot;,&quot;b&quot;})</code></p>\n<p>如果数组是单值，可以忽略这些括号：</p>\n<p><code>@Result(res=&quot;a&quot;)</code></p>\n<h2 id=\"注解分类\"><a href=\"#注解分类\" class=\"headerlink\" title=\"注解分类\"></a>注解分类</h2><p>根据注解的用途和使用方式，注解可以分为以下几类：</p>\n<p>元注解：注解注解的注解。也就是用来描述注解定义的注解</p>\n<p>预定义注解：jdk内置的一些注解</p>\n<p>自定义注解：我们自己定义的注解</p>\n<ul>\n<li>元注解</li>\n</ul>\n<p>元注解包含下面几个：</p>\n<p><strong>@Target: 指定这个注解可以应用于哪些项</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public enum ElementType &#123;</div><div class=\"line\">    /** Class, interface (including annotation type), or enum declaration */</div><div class=\"line\">    TYPE,</div><div class=\"line\"></div><div class=\"line\">    /** Field declaration (includes enum constants) */</div><div class=\"line\">    FIELD,</div><div class=\"line\"></div><div class=\"line\">    /** Method declaration */</div><div class=\"line\">    METHOD,</div><div class=\"line\"></div><div class=\"line\">    /** Parameter declaration */</div><div class=\"line\">    PARAMETER,</div><div class=\"line\"></div><div class=\"line\">    /** Constructor declaration */</div><div class=\"line\">    CONSTRUCTOR,</div><div class=\"line\"></div><div class=\"line\">    /** Local variable declaration */</div><div class=\"line\">    LOCAL_VARIABLE,</div><div class=\"line\"></div><div class=\"line\">    /** Annotation type declaration */</div><div class=\"line\">    ANNOTATION_TYPE,</div><div class=\"line\"></div><div class=\"line\">    /** Package declaration */</div><div class=\"line\">    PACKAGE</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>比如，我们定义了一个注解Bug，该注解只能应用于方法或成员变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</div><div class=\"line\">@interface Bug&#123;</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注解Bug则只能用于类方法或成员变量，如果注解了其他项比如类或者包，编译则不会通过。</p>\n<p>对于一个没有声明@Target的注解，可以应用到任何项上。</p>\n<p><strong>@Retention: 指定这个注解可以保留多久</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public enum RetentionPolicy &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Annotations are to be discarded by the compiler.</div><div class=\"line\">     */</div><div class=\"line\">    SOURCE,</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Annotations are to be recorded in the class file by the compiler</div><div class=\"line\">     * but need not be retained by the VM at run time.  This is the default</div><div class=\"line\">     * behavior.</div><div class=\"line\">     */</div><div class=\"line\">    CLASS,</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Annotations are to be recorded in the class file by the compiler and</div><div class=\"line\">     * retained by the VM at run time, so they may be read reflectively.</div><div class=\"line\">     *</div><div class=\"line\">     * @see java.lang.reflect.AnnotatedElement</div><div class=\"line\">     */</div><div class=\"line\">    RUNTIME</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>SOURCE：只存在于源代码，编译成.class之后就没了</p>\n<p>CLASS: 保留到类文件中，但是虚拟机不会载入</p>\n<p>RUNTIME：保留到类文件中，并且虚拟机会载入。这意味着通过反射可以获取到这些注解和注解元素值</p>\n<p>默认情况下(没有声明@Retention)，注解保留级别为CLASS</p>\n<p><strong>@Document：指定这个注解应该包含在文档中</strong></p>\n<p>文档化的注解意味着像javadoc这样的工具生成的文档中会包含这些注解。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Documented</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</div><div class=\"line\">public @interface Deprecated &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>@Deprecated是文档化的注解，URLDecoder.decode(String s)方法应用了这个注解：</p>\n<img src=\"/2017/03/31/java注解/decode.jpg\" alt=\"decode\" title=\"decode\">\n<img src=\"/2017/03/31/java注解/doc.jpg\" alt=\"doc\" title=\"doc\">\n<p>可以在文档中看到Deprecated的出现。</p>\n<p><strong>@Inherited: 指定一个注解，当他应用于一个类的时候，能够自动被其子类继承</strong></p>\n<p>@Inherited只能应用于对类的注解。如果一个类具有继承注解，那么他的所有子类都自动具有同样的注解。</p>\n<p>比如，定义了一个继承注解@Secret表示一个类是隐私的不可被序列化传输的，那么该类的子类会被自动注解为不可序列化传输的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Inherited</div><div class=\"line\">@interface Secret&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Secret class A&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">class B extends A&#123;&#125; //同样是@Secret的</div></pre></td></tr></table></figure>\n<p>当注解工具去获取声明了@Secret的对象时，他能够获取到A的对象和B的对象。</p>\n<ul>\n<li>预定义注解</li>\n</ul>\n<p>常用的有三个：@override、@Deprecated、@SuppressWarnings，具体的作用可以查文档或者源码，不再赘述。</p>\n<h2 id=\"注解的定义\"><a href=\"#注解的定义\" class=\"headerlink\" title=\"注解的定义\"></a>注解的定义</h2><p>上面的讨论中已经涉及到了注解的定义。一个注解是由一个注解接口来定义的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Result &#123;</div><div class=\"line\">\tString name();</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每个元素的声明有两种形式，有默认值和没有默认值的，就像上面那样。注解的元素可以是下面之一：</p>\n<p>基本类型|String|Class类型|enum|注解类型|由前面所述类型构成的数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface BugReport&#123;</div><div class=\"line\">\tenum Status&#123;FIXED,OPEN,NEW,CLOSE&#125;;</div><div class=\"line\">\tboolean isIgnore() default false;</div><div class=\"line\">\tString id();</div><div class=\"line\">\tClass&lt;?&gt; testCase() default Void.class;</div><div class=\"line\">\tStatus status() default Status.NEW;</div><div class=\"line\">\tAuthor author() default @Author;</div><div class=\"line\">\tString[] reportMsg() default &quot;&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，虽然注解元素可以是另一个注解，但是不能在注解中引入循环依赖，比如@BugReport依赖@Author，而@Author又依赖@BugReport。同时，注解元素也不可以为null，元素的值必须是编译期常量。</p>\n<p>我们可以通过在注解的定义前声明之前提到的元注解来定制我们的注解，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(&#123; ElementType.METHOD, ElementType.FIELD &#125;)</div><div class=\"line\">@Inherited</div><div class=\"line\">@Documented</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@interface Result &#123;</div><div class=\"line\">\tString name() default &quot;&quot;;</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">\tString[] reportMsg() default &quot;&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所有的注解接口隐式的继承自java.lang.annotation.Annotation接口。这是一个正常的接口，而不是注解接口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Annotation &#123;</div><div class=\"line\">    boolean equals(Object obj);</div><div class=\"line\">    int hashCode();</div><div class=\"line\">    String toString();</div><div class=\"line\">    Class&lt;? extends Annotation&gt; annotationType();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>也就是说，注解接口也是普通接口的一种。注解接口中的元素实际上也是方法的声明，这些方法类似于bean的get、set，我们使用@Result(name=”A”)的形式实际上是调用了set方法给某个变量赋值。</p>\n<p>既然是接口，那么就应该有实现(不然怎么用呢？)。我们不需要主动提供实现了注解接口的类，虚拟机会在需要的时候产生一些代理类和对象。下文会提到。</p>\n<p>既然可以为注解元素赋值，那么必定有方法去获得这些值。也就是注解的解析。</p>\n<h2 id=\"注解的解析\"><a href=\"#注解的解析\" class=\"headerlink\" title=\"注解的解析\"></a>注解的解析</h2><p>我们定义了注解并且应用了注解，但是仅仅这样的话注解并不会起到什么作用。需要我们提供一种工具去解析声明的注解，然后实现一些自动配置或者生成报告的功能。这就是注解的解析。</p>\n<ul>\n<li>源代码中的注解</li>\n</ul>\n<p>注解的用处之一就是自动生成一些包含程序额外信息的文件。比如，根据注解生成代码进度报告，或者bug修复报告等。生成的文件可以是属性文件、xml文件、html文档或者shell脚本。也可以生成java源文件。</p>\n<p>注解处理器通常通过集成AbstractProcessor类实现了Processor接口，通过process方法实现处理源码中注解的逻辑。通过声明具体的注解类型来指定该处理器处理哪些注解。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SupportedAnnotationTypes(&quot;space.yukai.annotations.BUG&quot;)</div><div class=\"line\">class AnnotationProcessor extends AbstractProcessor &#123;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\treturn false;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>process的两个参数：annotations代表了要处理的注解集，roundEnv是包含有关当前处理循环信息的RoundEnv引用。</p>\n<p><a href=\"http://www.race604.com/annotation-processing/\">Java注解处理器</a>这篇文章以通过注解自动生成工厂类文件为例，详细介绍了如何处理源码级别的注解。（英文原文在这：<a href=\"http://hannesdorfmann.com/annotation-processing/annotationprocessing101）\">http://hannesdorfmann.com/annotation-processing/annotationprocessing101）</a></p>\n<p>注意，我们虽然可以通过源码级别的注解处理器生成新的文件，却很难编辑源文件，比如，通过处理注解自动生成get、set方法。字节码级别的处理器是可以的。</p>\n<ul>\n<li>字节码中的注解</li>\n</ul>\n<p>字节码级别的注解，即存在于class文件中的注解。我们还可以通过BCEL这样的字节码工程类库修改或插入字节码来改变类文件。比如在声明了@LogEntity的方法开始部分插入打印日志信息的字节码。</p>\n<p>涉及的不多，不再赘述。</p>\n<ul>\n<li>运行时的注解</li>\n</ul>\n<p>在运行时处理注解是比较常见的注解处理手段。一般是通过反射API获取到我们的注解信息，从而实现一些功能。</p>\n<p>下面是自己写的一个例子，通过解析BugReport注解得到一些测试信息，然后通过动态代理的方式生成代理测试类，最后运行测试自动生成测试报告。（不要在意代码有什么缺陷或者其他问题，仅仅是一个例子而已～）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\">package space.kyu.proxy;</div><div class=\"line\"></div><div class=\"line\">import java.lang.annotation.ElementType;</div><div class=\"line\">import java.lang.annotation.Retention;</div><div class=\"line\">import java.lang.annotation.RetentionPolicy;</div><div class=\"line\">import java.lang.annotation.Target;</div><div class=\"line\">import java.lang.reflect.InvocationHandler;</div><div class=\"line\">import java.lang.reflect.Method;</div><div class=\"line\">import java.lang.reflect.Proxy;</div><div class=\"line\">import java.util.ArrayList;</div><div class=\"line\">import java.util.List;</div><div class=\"line\"></div><div class=\"line\">public class AnnotationsTest &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tTestBug testBug = new TestBug(true);</div><div class=\"line\">\t\tTestBug testBug1 = new TestBug(false);</div><div class=\"line\">\t\tTestExecutor executor = new TestExecutor();</div><div class=\"line\">\t\texecutor.addTest(testBug);</div><div class=\"line\">\t\texecutor.addTest(testBug1);</div><div class=\"line\">\t\texecutor.executeTest();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class TestExecutor &#123;</div><div class=\"line\">\tprivate List&lt;Test&gt;  testCases;</div><div class=\"line\">\tpublic TestExecutor() &#123;</div><div class=\"line\">\t\ttestCases = new ArrayList&lt;Test&gt;();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic &lt;T extends Test&gt; void  addTest(T testCase) &#123;</div><div class=\"line\">\t\tClass&lt;? extends Object&gt; cl = testCase.getClass();</div><div class=\"line\">\t\tMethod[] declaredMethods = cl.getDeclaredMethods();</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tfor (Method method : declaredMethods) &#123;</div><div class=\"line\">\t\t\t\tif (method.isAnnotationPresent(BugReport.class)) &#123;</div><div class=\"line\">\t\t\t\t\tBugReport annotation = method.getAnnotation(BugReport.class);</div><div class=\"line\">\t\t\t\t\tif (annotation != null) &#123;</div><div class=\"line\">\t\t\t\t\t\tSystem.out.println(annotation.toString());</div><div class=\"line\">\t\t\t\t\t\tSystem.out.println(annotation.annotationType().getName());</div><div class=\"line\">\t\t\t\t\t\tSystem.out.println(annotation.getClass().getName());</div><div class=\"line\">\t\t\t\t\t\tString bugId = annotation.id();</div><div class=\"line\">\t\t\t\t\t\tString bugMsg = annotation.msg();</div><div class=\"line\">\t\t\t\t\t\tTest obj = (Test) createBugReportHandler(testCase,bugId,bugMsg);</div><div class=\"line\">\t\t\t\t\t\ttestCases.add(obj);</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; catch (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\tthrow new IllegalStateException(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void executeTest() &#123;</div><div class=\"line\">\t\tfor (Test test : testCases) &#123;</div><div class=\"line\">\t\t\ttest.test();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tprivate Object createBugReportHandler(Test testCase, final String bugId, final String bugMsg) &#123;</div><div class=\"line\">\t\treturn Proxy.newProxyInstance(testCase.getClass().getClassLoader(), testCase.getClass().getInterfaces(), new InvocationHandler() &#123;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\t@Override</div><div class=\"line\">\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class=\"line\">\t\t\t\tboolean res = (boolean) method.invoke(testCase, args);</div><div class=\"line\">\t\t\t\t//也可以输出到文件中形成测试报告</div><div class=\"line\">\t\t\t\tSystem.out.println(&quot;******************************&quot;);</div><div class=\"line\">\t\t\t\tSystem.out.println(&quot;bug: &quot; + bugId + &quot;测试结果：&quot;);</div><div class=\"line\">\t\t\t\tif (res) &#123;//测试通过</div><div class=\"line\">\t\t\t\t\tSystem.out.println(&quot;已通过&quot;);</div><div class=\"line\">\t\t\t\t&#125; else &#123;//测试不通过</div><div class=\"line\">\t\t\t\t\tSystem.out.println(&quot;未通过&quot;);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tSystem.out.println(&quot;备注信息：&quot; + bugMsg);</div><div class=\"line\">\t\t\t\treturn res;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">interface Test &#123;</div><div class=\"line\">\t/**</div><div class=\"line\">\t * 测试方法 2017年4月1日</div><div class=\"line\">\t * @return </div><div class=\"line\">\t * true 通过测试 </div><div class=\"line\">\t * false 未通过测试</div><div class=\"line\">\t */</div><div class=\"line\">\tboolean test();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class TestBug implements Test &#123;</div><div class=\"line\">\tboolean fixed;</div><div class=\"line\">\tpublic TestBug(boolean fixed) &#123;</div><div class=\"line\">\t\t//控制测试成功或失败</div><div class=\"line\">\t\tthis.fixed = fixed;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@BugReport(id = &quot;bug001&quot;, msg = &quot;bug注释：这是一条测试bug&quot;)</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean test() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;执行测试...&quot;);</div><div class=\"line\">\t\t//假装测试成功或者失败了</div><div class=\"line\">\t\treturn fixed;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Target(ElementType.METHOD)</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@interface BugReport &#123;</div><div class=\"line\">\tString id();</div><div class=\"line\"></div><div class=\"line\">\tString msg();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)</div><div class=\"line\">space.kyu.proxy.BugReport</div><div class=\"line\">space.kyu.proxy.$Proxy1</div><div class=\"line\">@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)</div><div class=\"line\">space.kyu.proxy.BugReport</div><div class=\"line\">space.kyu.proxy.$Proxy1</div><div class=\"line\">执行测试...</div><div class=\"line\">******************************</div><div class=\"line\">bug: bug001测试结果：</div><div class=\"line\">已通过</div><div class=\"line\">备注信息：bug注释：这是一条测试bug</div><div class=\"line\">执行测试...</div><div class=\"line\">******************************</div><div class=\"line\">bug: bug001测试结果：</div><div class=\"line\">未通过</div><div class=\"line\">备注信息：bug注释：这是一条测试bug</div></pre></td></tr></table></figure>\n<p>上面的代码很简单，我们要注意的有几点：</p>\n<p>1.<code>method.isAnnotationPresent(BugReport.class)</code>和 <code>method.getAnnotation(BugReport.class)</code></p>\n<p>这两个方法来自于接口AnnotatedElement，Method、Field、Package、Constructor、Class这些类都实现了这个接口，使得这些类拥有了提供所声明的注解的功能。</p>\n<p>通过method.getAnnotation(BugReport.class)得到了声明在方法上的BugReport注解，获得这个注解的实例之后，我们就可以调用以该注解声明的元素为名称的方法来获取对应的元素值了。</p>\n<p>2.<code>annotation.annotationType().getName()</code>和<code>annotation.getClass().getName()</code></p>\n<p>annotation.annotationType()方法上面已经提到过了，是Annotation的一个方法，用于描述该注解对象的注解接口。这个方法返回的内容为：space.kyu.proxy.BugReport</p>\n<p>annotation.getClass()获得了实现了Annotation接口的代理类，通过调用getName()方法可以打印这个代理类的名称：space.kyu.proxy.$Proxy1。从而印证了我们上面所说，确实自动生成了代理类。</p>\n<p>上面的例子很简单，说白了，注解就是给代码加了一些额外的信息，这些信息对代码里面的逻辑是没有任何影响的。但是我们可以通过其他手段获得我们在代码中的注解，从而实现一些重复性的工作。这就是注解的作用。</p>\n"},{"layout":"post","title":"java远程调试学习","date":"2016-12-07T13:55:48.000Z","_content":"\n> 集群前后台协议需要做一些修改，我负责jdbc这边的修改。按照协议内容修改完代码之后却面临一个测试的问题：修改后的后台又部署在北京，但北京并不是所有的机器都对天津这边开放，只给提供一台机器A，就是集群的服务器。\n> 这样的话,就无法创建节点的连接，测试没有办法进行。\n\n> 一开始用了最简单的办法，把打好的jar包通过远程ssh放到A上面，再通过ssh去跑用例，打印结果看看正确与否。但是这样的效率真的太低了，每做一次修改都要打包、部署、运行、分析log。于是借这个机会学习一下java程序的远程调试。以下为总结。\n\n\n## 一些概念\n\nJDPA: java平台调试架构\n\nJVMTI: JVM端调试接口\n\nJDI: java端调试接口\n\nJDWP: java调试网络协议\n\n{% asset_img jdpa.png jdpa %}\n\nJPDA 定义了一套如何开发调试工具的接口和规范。\n\nJPDA 由三个独立的模块 JVMTI、JDWP、JDI 组成。\n\n调试者通过 JDI 发送接受调试命令。\n\nJDWP 定义调试者和被调试者交流数据的格式。\n\nJVMTI 可以控制当前虚拟机运行状态。\n\n上图中的前端工具就是我们要用到的调试工具。如JDB、Eclipse等等。这些工具实现了JDI接口，通过这些工具我们可以达到在命令行或者图形界面下调试的目的。\n\n关于这部分，只是简单的了解一下概念，更多的关于JDPA的介绍：[JDPA体系](http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?search_by=%E6%B7%B1%E5%85%A5+Java+%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB)\n\n## 使用JDB进行本地调试\n\nJDB 是jdk自带的一个调试工具，用于命令行下调试java程序\n\njdb.exe就位于jdk安装目录的bin目录下，安装好jdk并设置好环境变量之后就可以愉快的使用jdb了。\n\n```\nC:\\Users\\kyu>jdb -help\n用法: jdb <options> <class> <arguments>\n\n其中, 选项包括:\n    -help             输出此消息并退出\n    -sourcepath <由 \";\" 分隔的目录>\n                      要在其中查找源文件的目录\n    -attach <address>\n                      使用标准连接器附加到指定地址处正在运行的 VM\n    -listen <address>\n                      等待正在运行的 VM 使用标准连接器在指定地址处连接\n    -listenany\n                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接\n    -launch\n                      立即启动 VM 而不是等待 'run' 命令\n    -listconnectors   列出此 VM 中的可用连接器\n    -connect <connector-name>:<name1>=<value1>,...\n                      使用所列参数值通过指定的连接器连接到目标 VM\n    -dbgtrace [flags] 输出信息供调试jdb\n    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序\n    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序\n\n转发到被调试进程的选项:\n    -v -verbose[:class|gc|jni]\n                      启用详细模式\n    -D<name>=<value>  设置系统属性\n    -classpath <由 \";\" 分隔的目录>\n                      列出要在其中查找类的目录\n    -X<option>        非标准目标 VM 选项\n\n<class> 是要开始调试的类的名称\n<arguments> 是传递到 <class> 的 main() 方法的参数\n\n要获得命令的帮助, 请在jdb提示下键入 'help'\n```\n\n上面是启动JDB的语法说明。\n\n现假设运行程序的工程目录如下：\n\n```\nJDBTest\n  |----bin(编译生成的class文件)\n  |     |----*.class\n  |----src(源文件)\n  |     |----*.java\n  |----lib(依赖的第三方jar)\n  |     |----*.jar\n```\n\n开始启动JDB调试：\n\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n\n`注意，如果有多个文件，windows下使用 \";\" 分隔每个文件或目录，Linux下使用 \":\" 分隔每个文件或目录`\n\n`-classpath` 指定了类路径，`-sourcepath` 指定了源文件的路径\n\n回车，出现如下信息：\n\n```\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n正在初始化jdb...\n> \n```\n此时，JDB调试器等待用户的输入，输入`help`，出现如下信息：\n\n```\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n正在初始化jdb...\n> help\n** 命令列表 **\nconnectors                -- 列出此 VM 中可用的连接器和传输\n\nrun [class [args]]        -- 开始执行应用程序的主类\n\nthreads [threadgroup]     -- 列出线程\nthread <thread id>        -- 设置默认线程\nsuspend [thread id(s)]    -- 挂起线程 (默认值: all)\nresume [thread id(s)]     -- 恢复线程 (默认值: all)\nwhere [<thread id> | all] -- 转储线程的堆栈\nwherei [<thread id> | all]-- 转储线程的堆栈, 以及 pc 信息\nup [n frames]             -- 上移线程的堆栈\ndown [n frames]           -- 下移线程的堆栈\nkill <thread id> <expr>   -- 终止具有给定的异常错误对象的线程\ninterrupt <thread id>     -- 中断线程\n\nprint <expr>              -- 输出表达式的值\ndump <expr>               -- 输出所有对象信息\neval <expr>               -- 对表达式求值 (与 print 相同)\nset <lvalue> = <expr>     -- 向字段/变量/数组元素分配新值\nlocals                    -- 输出当前堆栈帧中的所有本地变量\n\nclasses                   -- 列出当前已知的类\nclass <class id>          -- 显示已命名类的详细资料\nmethods <class id>        -- 列出类的方法\nfields <class id>         -- 列出类的字段\n\nthreadgroups              -- 列出线程组\nthreadgroup <name>        -- 设置当前线程组\n\nstop in <class id>.<method>[(argument_type,...)]\n                          -- 在方法中设置断点\nstop at <class id>:<line> -- 在行中设置断点\nclear <class id>.<method>[(argument_type,...)]\n                          -- 清除方法中的断点\nclear <class id>:<line>   -- 清除行中的断点\nclear                     -- 列出断点\ncatch [uncaught|caught|all] <class id>|<class pattern>\n                          -- 出现指定的异常错误时中断\nignore [uncaught|caught|all] <class id>|<class pattern>\n                          -- 对于指定的异常错误, 取消 'catch'\nwatch [access|all] <class id>.<field name>\n                          -- 监视对字段的访问/修改\nunwatch [access|all] <class id>.<field name>\n                          -- 停止监视对字段的访问/修改\ntrace [go] methods [thread]\n                          -- 跟踪方法进入和退出。\n                          -- 除非指定 'go', 否则挂起所有线程\ntrace [go] method exit | exits [thread]\n                          -- 跟踪当前方法的退出, 或者所有方法的退出\n                          -- 除非指定 'go', 否则挂起所有线程\nuntrace [methods]         -- 停止跟踪方法进入和/或退出\nstep                      -- 执行当前行\nstep up                   -- 一直执行, 直到当前方法返回到其调用方\nstepi                     -- 执行当前指令\nnext                      -- 步进一行 (步过调用)\ncont                      -- 从断点处继续执行\n\nlist [line number|method] -- 输出源代码\nuse (或 sourcepath) [source file path]\n                          -- 显示或更改源路径\nexclude [<class pattern>, ... | \"none\"]\n                          -- 对于指定的类, 不报告步骤或方法事件\nclasspath                 -- 从目标 VM 输出类路径信息\n\nmonitor <command>         -- 每次程序停止时执行命令\nmonitor                   -- 列出监视器\nunmonitor <monitor#>      -- 删除监视器\nread <filename>           -- 读取并执行命令文件\n\nlock <expr>               -- 输出对象的锁信息\nthreadlocks [thread id]   -- 输出线程的锁信息\n\npop                       -- 通过当前帧出栈, 且包含当前帧\nreenter                   -- 与 pop 相同, 但重新进入当前帧\nredefine <class id> <class file name>\n                          -- 重新定义类的代码\n\ndisablegc <expr>          -- 禁止对象的垃圾收集\nenablegc <expr>           -- 允许对象的垃圾收集\n\n!!                        -- 重复执行最后一个命令\n<n> <command>             -- 将命令重复执行 n 次\n# <command>               -- 放弃 (无操作)\nhelp (或 ?)               -- 列出命令\nversion                   -- 输出版本信息\nexit (或 quit)            -- 退出调试器\n\n<class id>: 带有程序包限定符的完整类名\n<class pattern>: 带有前导或尾随通配符 ('*') 的类名\n<thread id>: 'threads' 命令中报告的线程编号\n<expr>: Java(TM) 编程语言表达式。\n支持大多数常见语法。\n\n可以将启动命令置于 \"jdb.ini\" 或 \".jdbrc\" 中\n位于 user.home 或 user.dir 中\n>\n```\n上面的帮助信息说明了如何进行JDB调试，解释一下其中的几个：\n\nstep: -- 执行当前行 相当于Eclipse中的F5\n\nstep up: -- 一直执行, 直到当前方法返回到其调用方 相当于Eclipse中的F7\n\nnext: -- 步进一行 (步过调用) 相当于Eclipse中的F6\n\ncont: -- 从断点处继续执行 相当于Eclipse中的F8\n\n此时，继续输入：\n\n```\n> stop at test.JDBTest:7\n正在延迟断点test.JDBTest:7。\n将在加载类后设置。\n> run\n运行test.JDBTest\n设置未捕获的java.lang.Throwable\n设置延迟的未捕获的java.lang.Throwable\n>\nVM 已启动: 设置延迟的断点test.JDBTest:7\n\n断点命中: \"线程=main\", test.JDBTest.main(), 行=7 bci=0\n7               JDBTest jdbTest = new JDBTest();\n\nmain[1]\n```\nstop at test.JDBTest:7 表示在这个类文件的第7行处打一个断点\n\n接着，输入run，就开始进入调试步骤了。现在可以输入上面帮助中的语法来了解当前程序的执行情况了。一试便知\n\n`注意, 若想要在调试时能够正常输出调试信息如变量值等等，需要在编译java文件时指定 -g 参数，否则无法获得其运行时的调试信息`\n\n另外，使用list可以打印当前断点处的源代码，如果没有在启动JDB时指定源代码路径 -sourcepath ./src/ ，那么会提示没有源代码信息，无法输出。此时可以使用命令 use ./src/ 来指定源代码路径，再使用list命令时可以正常打印了。\n\n以上就是使用JDB调试本地程序的方法，具体的使用可根据实际情况参照语法说明去执行。\n\n## 使用JDB进行远程调试\n\n如果程序不是运行在本机，而是在其他机器或者现场的时候，可以使用java提供的远程调试功能。\n\n假设程序现运行在主机 192.168.101.72 这台机器上，该机器为linux环境，且只可以通过ssh作为一个普通用户连接。我们想要在自己的机器上调试运行在192.168.101.72这台机器上的程序。\n\n### 启动要调试的程序\n\n在192.168.101.72这台主机上以下面的方式启动java程序：还是以JDBTest为例\n\n`java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest`\n\n此时，命令行输出\n\n`Listening for transport dt_socket at address: 8899`\n\n并处于等待状态\n\n下面是几个参数的解释：\n\n-Xdebug 启用调试特性。 \n\n-Xrunjdwp:<sub-options> 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。下面介绍一些特定的子选项。\n从 Java V5 开始，您可以使用 -agentlib:jdwp 选项，而不是 -Xdebug 和 -Xrunjdwp。但如果连接到 V5 以前的 VM，只能选择 -Xdebug 和 -Xrunjdwp。下面简单描述 -Xrunjdwp 子选项。\n\ntransport 这里通常使用套接字传输。但是在 Windows 平台上也可以使用共享内存传输。\n\nserver 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。\n\naddress 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。\n\nsuspend 如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。\n\n### 本机连接远程程序并启动调试\n\n在本机上命令行下输入：\n\n`jdb -connect com.sun.jdi.SocketAttach:hostname=192.168.101.72,port=8899`\n\n然后就进入了调试界面，你可以像调试本机程序那样使用JDB的一些命令来调试了。当退出调试程序时，远程主机上的程序也就退出了。\n\n\n## 使用Eclipse进行远程调试\n\n可以使用Eclipse进行远程调试，就上上面使用JDB一样。\n\n### 启动要调试的程序\n\n与JDB远程调试一样，启动远程主机上的程序：\n\n`java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest`\n\n### 本机启动Eclipse进行调试\n\n首先要右键工程->java compiler\n\n{% asset_img setting.png jdpa %}\n\n上图中的几个选项最好全部打勾，否则调试时会出现无法打断点或者获取不到行号等问题(关于这几个选项的含义在之前的总结中有提到)\n\n接着，右键工程->Debug As->Run Configurations, 在出现的对话框中选择Remote Java Application, 右键->New, 出现如下界面：\n\n{% asset_img remote.png jdpa %}\n\n在Connect页中，选择对应的java 工程，Connection Type选择 Socket Attach，然后填写远程主机的ip和端口，这里应该填写192.168.101.72和8899。\n在Source页中可以添加源代码，如用到的第三方jar的源代码或者引用的工程，调试时就可以进入到这部分代码查看。在Common页可以设置编码的配置。\n\n接下来点击Debug按钮，就可以愉快的在本机调试远程程序了，就像调试本地程序那样。只不过可能有一点一点慢，不过比打Log的方式要好很多了。\n\n## 参考\n\n[使用 Eclipse 远程调试 Java 应用程序](https://www.ibm.com/developerworks/cn/opensource/os-eclipse-javadebug/)\n\n[JDB的简单使用](http://www.ibm.com/developerworks/cn/java/joy-jdb/)\n\n[深入 Java 调试体系: 第 1 部分，JPDA 体系概览 ](https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/)\n","source":"_posts/java远程调试学习.md","raw":"---\nlayout: post\ntitle: java远程调试学习\ndate: 2016-12-07 21:55:48\ncategories: 编程\ntags: \n- java \n- 调试\n---\n\n> 集群前后台协议需要做一些修改，我负责jdbc这边的修改。按照协议内容修改完代码之后却面临一个测试的问题：修改后的后台又部署在北京，但北京并不是所有的机器都对天津这边开放，只给提供一台机器A，就是集群的服务器。\n> 这样的话,就无法创建节点的连接，测试没有办法进行。\n\n> 一开始用了最简单的办法，把打好的jar包通过远程ssh放到A上面，再通过ssh去跑用例，打印结果看看正确与否。但是这样的效率真的太低了，每做一次修改都要打包、部署、运行、分析log。于是借这个机会学习一下java程序的远程调试。以下为总结。\n\n\n## 一些概念\n\nJDPA: java平台调试架构\n\nJVMTI: JVM端调试接口\n\nJDI: java端调试接口\n\nJDWP: java调试网络协议\n\n{% asset_img jdpa.png jdpa %}\n\nJPDA 定义了一套如何开发调试工具的接口和规范。\n\nJPDA 由三个独立的模块 JVMTI、JDWP、JDI 组成。\n\n调试者通过 JDI 发送接受调试命令。\n\nJDWP 定义调试者和被调试者交流数据的格式。\n\nJVMTI 可以控制当前虚拟机运行状态。\n\n上图中的前端工具就是我们要用到的调试工具。如JDB、Eclipse等等。这些工具实现了JDI接口，通过这些工具我们可以达到在命令行或者图形界面下调试的目的。\n\n关于这部分，只是简单的了解一下概念，更多的关于JDPA的介绍：[JDPA体系](http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?search_by=%E6%B7%B1%E5%85%A5+Java+%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB)\n\n## 使用JDB进行本地调试\n\nJDB 是jdk自带的一个调试工具，用于命令行下调试java程序\n\njdb.exe就位于jdk安装目录的bin目录下，安装好jdk并设置好环境变量之后就可以愉快的使用jdb了。\n\n```\nC:\\Users\\kyu>jdb -help\n用法: jdb <options> <class> <arguments>\n\n其中, 选项包括:\n    -help             输出此消息并退出\n    -sourcepath <由 \";\" 分隔的目录>\n                      要在其中查找源文件的目录\n    -attach <address>\n                      使用标准连接器附加到指定地址处正在运行的 VM\n    -listen <address>\n                      等待正在运行的 VM 使用标准连接器在指定地址处连接\n    -listenany\n                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接\n    -launch\n                      立即启动 VM 而不是等待 'run' 命令\n    -listconnectors   列出此 VM 中的可用连接器\n    -connect <connector-name>:<name1>=<value1>,...\n                      使用所列参数值通过指定的连接器连接到目标 VM\n    -dbgtrace [flags] 输出信息供调试jdb\n    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序\n    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序\n\n转发到被调试进程的选项:\n    -v -verbose[:class|gc|jni]\n                      启用详细模式\n    -D<name>=<value>  设置系统属性\n    -classpath <由 \";\" 分隔的目录>\n                      列出要在其中查找类的目录\n    -X<option>        非标准目标 VM 选项\n\n<class> 是要开始调试的类的名称\n<arguments> 是传递到 <class> 的 main() 方法的参数\n\n要获得命令的帮助, 请在jdb提示下键入 'help'\n```\n\n上面是启动JDB的语法说明。\n\n现假设运行程序的工程目录如下：\n\n```\nJDBTest\n  |----bin(编译生成的class文件)\n  |     |----*.class\n  |----src(源文件)\n  |     |----*.java\n  |----lib(依赖的第三方jar)\n  |     |----*.jar\n```\n\n开始启动JDB调试：\n\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n\n`注意，如果有多个文件，windows下使用 \";\" 分隔每个文件或目录，Linux下使用 \":\" 分隔每个文件或目录`\n\n`-classpath` 指定了类路径，`-sourcepath` 指定了源文件的路径\n\n回车，出现如下信息：\n\n```\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n正在初始化jdb...\n> \n```\n此时，JDB调试器等待用户的输入，输入`help`，出现如下信息：\n\n```\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n正在初始化jdb...\n> help\n** 命令列表 **\nconnectors                -- 列出此 VM 中可用的连接器和传输\n\nrun [class [args]]        -- 开始执行应用程序的主类\n\nthreads [threadgroup]     -- 列出线程\nthread <thread id>        -- 设置默认线程\nsuspend [thread id(s)]    -- 挂起线程 (默认值: all)\nresume [thread id(s)]     -- 恢复线程 (默认值: all)\nwhere [<thread id> | all] -- 转储线程的堆栈\nwherei [<thread id> | all]-- 转储线程的堆栈, 以及 pc 信息\nup [n frames]             -- 上移线程的堆栈\ndown [n frames]           -- 下移线程的堆栈\nkill <thread id> <expr>   -- 终止具有给定的异常错误对象的线程\ninterrupt <thread id>     -- 中断线程\n\nprint <expr>              -- 输出表达式的值\ndump <expr>               -- 输出所有对象信息\neval <expr>               -- 对表达式求值 (与 print 相同)\nset <lvalue> = <expr>     -- 向字段/变量/数组元素分配新值\nlocals                    -- 输出当前堆栈帧中的所有本地变量\n\nclasses                   -- 列出当前已知的类\nclass <class id>          -- 显示已命名类的详细资料\nmethods <class id>        -- 列出类的方法\nfields <class id>         -- 列出类的字段\n\nthreadgroups              -- 列出线程组\nthreadgroup <name>        -- 设置当前线程组\n\nstop in <class id>.<method>[(argument_type,...)]\n                          -- 在方法中设置断点\nstop at <class id>:<line> -- 在行中设置断点\nclear <class id>.<method>[(argument_type,...)]\n                          -- 清除方法中的断点\nclear <class id>:<line>   -- 清除行中的断点\nclear                     -- 列出断点\ncatch [uncaught|caught|all] <class id>|<class pattern>\n                          -- 出现指定的异常错误时中断\nignore [uncaught|caught|all] <class id>|<class pattern>\n                          -- 对于指定的异常错误, 取消 'catch'\nwatch [access|all] <class id>.<field name>\n                          -- 监视对字段的访问/修改\nunwatch [access|all] <class id>.<field name>\n                          -- 停止监视对字段的访问/修改\ntrace [go] methods [thread]\n                          -- 跟踪方法进入和退出。\n                          -- 除非指定 'go', 否则挂起所有线程\ntrace [go] method exit | exits [thread]\n                          -- 跟踪当前方法的退出, 或者所有方法的退出\n                          -- 除非指定 'go', 否则挂起所有线程\nuntrace [methods]         -- 停止跟踪方法进入和/或退出\nstep                      -- 执行当前行\nstep up                   -- 一直执行, 直到当前方法返回到其调用方\nstepi                     -- 执行当前指令\nnext                      -- 步进一行 (步过调用)\ncont                      -- 从断点处继续执行\n\nlist [line number|method] -- 输出源代码\nuse (或 sourcepath) [source file path]\n                          -- 显示或更改源路径\nexclude [<class pattern>, ... | \"none\"]\n                          -- 对于指定的类, 不报告步骤或方法事件\nclasspath                 -- 从目标 VM 输出类路径信息\n\nmonitor <command>         -- 每次程序停止时执行命令\nmonitor                   -- 列出监视器\nunmonitor <monitor#>      -- 删除监视器\nread <filename>           -- 读取并执行命令文件\n\nlock <expr>               -- 输出对象的锁信息\nthreadlocks [thread id]   -- 输出线程的锁信息\n\npop                       -- 通过当前帧出栈, 且包含当前帧\nreenter                   -- 与 pop 相同, 但重新进入当前帧\nredefine <class id> <class file name>\n                          -- 重新定义类的代码\n\ndisablegc <expr>          -- 禁止对象的垃圾收集\nenablegc <expr>           -- 允许对象的垃圾收集\n\n!!                        -- 重复执行最后一个命令\n<n> <command>             -- 将命令重复执行 n 次\n# <command>               -- 放弃 (无操作)\nhelp (或 ?)               -- 列出命令\nversion                   -- 输出版本信息\nexit (或 quit)            -- 退出调试器\n\n<class id>: 带有程序包限定符的完整类名\n<class pattern>: 带有前导或尾随通配符 ('*') 的类名\n<thread id>: 'threads' 命令中报告的线程编号\n<expr>: Java(TM) 编程语言表达式。\n支持大多数常见语法。\n\n可以将启动命令置于 \"jdb.ini\" 或 \".jdbrc\" 中\n位于 user.home 或 user.dir 中\n>\n```\n上面的帮助信息说明了如何进行JDB调试，解释一下其中的几个：\n\nstep: -- 执行当前行 相当于Eclipse中的F5\n\nstep up: -- 一直执行, 直到当前方法返回到其调用方 相当于Eclipse中的F7\n\nnext: -- 步进一行 (步过调用) 相当于Eclipse中的F6\n\ncont: -- 从断点处继续执行 相当于Eclipse中的F8\n\n此时，继续输入：\n\n```\n> stop at test.JDBTest:7\n正在延迟断点test.JDBTest:7。\n将在加载类后设置。\n> run\n运行test.JDBTest\n设置未捕获的java.lang.Throwable\n设置延迟的未捕获的java.lang.Throwable\n>\nVM 已启动: 设置延迟的断点test.JDBTest:7\n\n断点命中: \"线程=main\", test.JDBTest.main(), 行=7 bci=0\n7               JDBTest jdbTest = new JDBTest();\n\nmain[1]\n```\nstop at test.JDBTest:7 表示在这个类文件的第7行处打一个断点\n\n接着，输入run，就开始进入调试步骤了。现在可以输入上面帮助中的语法来了解当前程序的执行情况了。一试便知\n\n`注意, 若想要在调试时能够正常输出调试信息如变量值等等，需要在编译java文件时指定 -g 参数，否则无法获得其运行时的调试信息`\n\n另外，使用list可以打印当前断点处的源代码，如果没有在启动JDB时指定源代码路径 -sourcepath ./src/ ，那么会提示没有源代码信息，无法输出。此时可以使用命令 use ./src/ 来指定源代码路径，再使用list命令时可以正常打印了。\n\n以上就是使用JDB调试本地程序的方法，具体的使用可根据实际情况参照语法说明去执行。\n\n## 使用JDB进行远程调试\n\n如果程序不是运行在本机，而是在其他机器或者现场的时候，可以使用java提供的远程调试功能。\n\n假设程序现运行在主机 192.168.101.72 这台机器上，该机器为linux环境，且只可以通过ssh作为一个普通用户连接。我们想要在自己的机器上调试运行在192.168.101.72这台机器上的程序。\n\n### 启动要调试的程序\n\n在192.168.101.72这台主机上以下面的方式启动java程序：还是以JDBTest为例\n\n`java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest`\n\n此时，命令行输出\n\n`Listening for transport dt_socket at address: 8899`\n\n并处于等待状态\n\n下面是几个参数的解释：\n\n-Xdebug 启用调试特性。 \n\n-Xrunjdwp:<sub-options> 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。下面介绍一些特定的子选项。\n从 Java V5 开始，您可以使用 -agentlib:jdwp 选项，而不是 -Xdebug 和 -Xrunjdwp。但如果连接到 V5 以前的 VM，只能选择 -Xdebug 和 -Xrunjdwp。下面简单描述 -Xrunjdwp 子选项。\n\ntransport 这里通常使用套接字传输。但是在 Windows 平台上也可以使用共享内存传输。\n\nserver 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。\n\naddress 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。\n\nsuspend 如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。\n\n### 本机连接远程程序并启动调试\n\n在本机上命令行下输入：\n\n`jdb -connect com.sun.jdi.SocketAttach:hostname=192.168.101.72,port=8899`\n\n然后就进入了调试界面，你可以像调试本机程序那样使用JDB的一些命令来调试了。当退出调试程序时，远程主机上的程序也就退出了。\n\n\n## 使用Eclipse进行远程调试\n\n可以使用Eclipse进行远程调试，就上上面使用JDB一样。\n\n### 启动要调试的程序\n\n与JDB远程调试一样，启动远程主机上的程序：\n\n`java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest`\n\n### 本机启动Eclipse进行调试\n\n首先要右键工程->java compiler\n\n{% asset_img setting.png jdpa %}\n\n上图中的几个选项最好全部打勾，否则调试时会出现无法打断点或者获取不到行号等问题(关于这几个选项的含义在之前的总结中有提到)\n\n接着，右键工程->Debug As->Run Configurations, 在出现的对话框中选择Remote Java Application, 右键->New, 出现如下界面：\n\n{% asset_img remote.png jdpa %}\n\n在Connect页中，选择对应的java 工程，Connection Type选择 Socket Attach，然后填写远程主机的ip和端口，这里应该填写192.168.101.72和8899。\n在Source页中可以添加源代码，如用到的第三方jar的源代码或者引用的工程，调试时就可以进入到这部分代码查看。在Common页可以设置编码的配置。\n\n接下来点击Debug按钮，就可以愉快的在本机调试远程程序了，就像调试本地程序那样。只不过可能有一点一点慢，不过比打Log的方式要好很多了。\n\n## 参考\n\n[使用 Eclipse 远程调试 Java 应用程序](https://www.ibm.com/developerworks/cn/opensource/os-eclipse-javadebug/)\n\n[JDB的简单使用](http://www.ibm.com/developerworks/cn/java/joy-jdb/)\n\n[深入 Java 调试体系: 第 1 部分，JPDA 体系概览 ](https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/)\n","slug":"java远程调试学习","published":1,"updated":"2017-03-29T06:08:12.000Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlru0029vegc4axe0e6k","content":"<blockquote>\n<p>集群前后台协议需要做一些修改，我负责jdbc这边的修改。按照协议内容修改完代码之后却面临一个测试的问题：修改后的后台又部署在北京，但北京并不是所有的机器都对天津这边开放，只给提供一台机器A，就是集群的服务器。<br>这样的话,就无法创建节点的连接，测试没有办法进行。</p>\n<p>一开始用了最简单的办法，把打好的jar包通过远程ssh放到A上面，再通过ssh去跑用例，打印结果看看正确与否。但是这样的效率真的太低了，每做一次修改都要打包、部署、运行、分析log。于是借这个机会学习一下java程序的远程调试。以下为总结。</p>\n</blockquote>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><p>JDPA: java平台调试架构</p>\n<p>JVMTI: JVM端调试接口</p>\n<p>JDI: java端调试接口</p>\n<p>JDWP: java调试网络协议</p>\n<img src=\"/2016/12/07/java远程调试学习/jdpa.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>JPDA 定义了一套如何开发调试工具的接口和规范。</p>\n<p>JPDA 由三个独立的模块 JVMTI、JDWP、JDI 组成。</p>\n<p>调试者通过 JDI 发送接受调试命令。</p>\n<p>JDWP 定义调试者和被调试者交流数据的格式。</p>\n<p>JVMTI 可以控制当前虚拟机运行状态。</p>\n<p>上图中的前端工具就是我们要用到的调试工具。如JDB、Eclipse等等。这些工具实现了JDI接口，通过这些工具我们可以达到在命令行或者图形界面下调试的目的。</p>\n<p>关于这部分，只是简单的了解一下概念，更多的关于JDPA的介绍：<a href=\"http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?search_by=%E6%B7%B1%E5%85%A5+Java+%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB\" target=\"_blank\" rel=\"external\">JDPA体系</a></p>\n<h2 id=\"使用JDB进行本地调试\"><a href=\"#使用JDB进行本地调试\" class=\"headerlink\" title=\"使用JDB进行本地调试\"></a>使用JDB进行本地调试</h2><p>JDB 是jdk自带的一个调试工具，用于命令行下调试java程序</p>\n<p>jdb.exe就位于jdk安装目录的bin目录下，安装好jdk并设置好环境变量之后就可以愉快的使用jdb了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:\\Users\\kyu&gt;jdb -help</div><div class=\"line\">用法: jdb &lt;options&gt; &lt;class&gt; &lt;arguments&gt;</div><div class=\"line\"></div><div class=\"line\">其中, 选项包括:</div><div class=\"line\">    -help             输出此消息并退出</div><div class=\"line\">    -sourcepath &lt;由 &quot;;&quot; 分隔的目录&gt;</div><div class=\"line\">                      要在其中查找源文件的目录</div><div class=\"line\">    -attach &lt;address&gt;</div><div class=\"line\">                      使用标准连接器附加到指定地址处正在运行的 VM</div><div class=\"line\">    -listen &lt;address&gt;</div><div class=\"line\">                      等待正在运行的 VM 使用标准连接器在指定地址处连接</div><div class=\"line\">    -listenany</div><div class=\"line\">                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接</div><div class=\"line\">    -launch</div><div class=\"line\">                      立即启动 VM 而不是等待 &apos;run&apos; 命令</div><div class=\"line\">    -listconnectors   列出此 VM 中的可用连接器</div><div class=\"line\">    -connect &lt;connector-name&gt;:&lt;name1&gt;=&lt;value1&gt;,...</div><div class=\"line\">                      使用所列参数值通过指定的连接器连接到目标 VM</div><div class=\"line\">    -dbgtrace [flags] 输出信息供调试jdb</div><div class=\"line\">    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序</div><div class=\"line\">    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序</div><div class=\"line\"></div><div class=\"line\">转发到被调试进程的选项:</div><div class=\"line\">    -v -verbose[:class|gc|jni]</div><div class=\"line\">                      启用详细模式</div><div class=\"line\">    -D&lt;name&gt;=&lt;value&gt;  设置系统属性</div><div class=\"line\">    -classpath &lt;由 &quot;;&quot; 分隔的目录&gt;</div><div class=\"line\">                      列出要在其中查找类的目录</div><div class=\"line\">    -X&lt;option&gt;        非标准目标 VM 选项</div><div class=\"line\"></div><div class=\"line\">&lt;class&gt; 是要开始调试的类的名称</div><div class=\"line\">&lt;arguments&gt; 是传递到 &lt;class&gt; 的 main() 方法的参数</div><div class=\"line\"></div><div class=\"line\">要获得命令的帮助, 请在jdb提示下键入 &apos;help&apos;</div></pre></td></tr></table></figure>\n<p>上面是启动JDB的语法说明。</p>\n<p>现假设运行程序的工程目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">JDBTest</div><div class=\"line\">  |----bin(编译生成的class文件)</div><div class=\"line\">  |     |----*.class</div><div class=\"line\">  |----src(源文件)</div><div class=\"line\">  |     |----*.java</div><div class=\"line\">  |----lib(依赖的第三方jar)</div><div class=\"line\">  |     |----*.jar</div></pre></td></tr></table></figure>\n<p>开始启动JDB调试：</p>\n<p>Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</p>\n<p><code>注意，如果有多个文件，windows下使用 &quot;;&quot; 分隔每个文件或目录，Linux下使用 &quot;:&quot; 分隔每个文件或目录</code></p>\n<p><code>-classpath</code> 指定了类路径，<code>-sourcepath</code> 指定了源文件的路径</p>\n<p>回车，出现如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</div><div class=\"line\">正在初始化jdb...</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<p>此时，JDB调试器等待用户的输入，输入<code>help</code>，出现如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div></pre></td><td class=\"code\"><pre><div class=\"line\">Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</div><div class=\"line\">正在初始化jdb...</div><div class=\"line\">&gt; help</div><div class=\"line\">** 命令列表 **</div><div class=\"line\">connectors                -- 列出此 VM 中可用的连接器和传输</div><div class=\"line\"></div><div class=\"line\">run [class [args]]        -- 开始执行应用程序的主类</div><div class=\"line\"></div><div class=\"line\">threads [threadgroup]     -- 列出线程</div><div class=\"line\">thread &lt;thread id&gt;        -- 设置默认线程</div><div class=\"line\">suspend [thread id(s)]    -- 挂起线程 (默认值: all)</div><div class=\"line\">resume [thread id(s)]     -- 恢复线程 (默认值: all)</div><div class=\"line\">where [&lt;thread id&gt; | all] -- 转储线程的堆栈</div><div class=\"line\">wherei [&lt;thread id&gt; | all]-- 转储线程的堆栈, 以及 pc 信息</div><div class=\"line\">up [n frames]             -- 上移线程的堆栈</div><div class=\"line\">down [n frames]           -- 下移线程的堆栈</div><div class=\"line\">kill &lt;thread id&gt; &lt;expr&gt;   -- 终止具有给定的异常错误对象的线程</div><div class=\"line\">interrupt &lt;thread id&gt;     -- 中断线程</div><div class=\"line\"></div><div class=\"line\">print &lt;expr&gt;              -- 输出表达式的值</div><div class=\"line\">dump &lt;expr&gt;               -- 输出所有对象信息</div><div class=\"line\">eval &lt;expr&gt;               -- 对表达式求值 (与 print 相同)</div><div class=\"line\">set &lt;lvalue&gt; = &lt;expr&gt;     -- 向字段/变量/数组元素分配新值</div><div class=\"line\">locals                    -- 输出当前堆栈帧中的所有本地变量</div><div class=\"line\"></div><div class=\"line\">classes                   -- 列出当前已知的类</div><div class=\"line\">class &lt;class id&gt;          -- 显示已命名类的详细资料</div><div class=\"line\">methods &lt;class id&gt;        -- 列出类的方法</div><div class=\"line\">fields &lt;class id&gt;         -- 列出类的字段</div><div class=\"line\"></div><div class=\"line\">threadgroups              -- 列出线程组</div><div class=\"line\">threadgroup &lt;name&gt;        -- 设置当前线程组</div><div class=\"line\"></div><div class=\"line\">stop in &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]</div><div class=\"line\">                          -- 在方法中设置断点</div><div class=\"line\">stop at &lt;class id&gt;:&lt;line&gt; -- 在行中设置断点</div><div class=\"line\">clear &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]</div><div class=\"line\">                          -- 清除方法中的断点</div><div class=\"line\">clear &lt;class id&gt;:&lt;line&gt;   -- 清除行中的断点</div><div class=\"line\">clear                     -- 列出断点</div><div class=\"line\">catch [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;</div><div class=\"line\">                          -- 出现指定的异常错误时中断</div><div class=\"line\">ignore [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;</div><div class=\"line\">                          -- 对于指定的异常错误, 取消 &apos;catch&apos;</div><div class=\"line\">watch [access|all] &lt;class id&gt;.&lt;field name&gt;</div><div class=\"line\">                          -- 监视对字段的访问/修改</div><div class=\"line\">unwatch [access|all] &lt;class id&gt;.&lt;field name&gt;</div><div class=\"line\">                          -- 停止监视对字段的访问/修改</div><div class=\"line\">trace [go] methods [thread]</div><div class=\"line\">                          -- 跟踪方法进入和退出。</div><div class=\"line\">                          -- 除非指定 &apos;go&apos;, 否则挂起所有线程</div><div class=\"line\">trace [go] method exit | exits [thread]</div><div class=\"line\">                          -- 跟踪当前方法的退出, 或者所有方法的退出</div><div class=\"line\">                          -- 除非指定 &apos;go&apos;, 否则挂起所有线程</div><div class=\"line\">untrace [methods]         -- 停止跟踪方法进入和/或退出</div><div class=\"line\">step                      -- 执行当前行</div><div class=\"line\">step up                   -- 一直执行, 直到当前方法返回到其调用方</div><div class=\"line\">stepi                     -- 执行当前指令</div><div class=\"line\">next                      -- 步进一行 (步过调用)</div><div class=\"line\">cont                      -- 从断点处继续执行</div><div class=\"line\"></div><div class=\"line\">list [line number|method] -- 输出源代码</div><div class=\"line\">use (或 sourcepath) [source file path]</div><div class=\"line\">                          -- 显示或更改源路径</div><div class=\"line\">exclude [&lt;class pattern&gt;, ... | &quot;none&quot;]</div><div class=\"line\">                          -- 对于指定的类, 不报告步骤或方法事件</div><div class=\"line\">classpath                 -- 从目标 VM 输出类路径信息</div><div class=\"line\"></div><div class=\"line\">monitor &lt;command&gt;         -- 每次程序停止时执行命令</div><div class=\"line\">monitor                   -- 列出监视器</div><div class=\"line\">unmonitor &lt;monitor#&gt;      -- 删除监视器</div><div class=\"line\">read &lt;filename&gt;           -- 读取并执行命令文件</div><div class=\"line\"></div><div class=\"line\">lock &lt;expr&gt;               -- 输出对象的锁信息</div><div class=\"line\">threadlocks [thread id]   -- 输出线程的锁信息</div><div class=\"line\"></div><div class=\"line\">pop                       -- 通过当前帧出栈, 且包含当前帧</div><div class=\"line\">reenter                   -- 与 pop 相同, 但重新进入当前帧</div><div class=\"line\">redefine &lt;class id&gt; &lt;class file name&gt;</div><div class=\"line\">                          -- 重新定义类的代码</div><div class=\"line\"></div><div class=\"line\">disablegc &lt;expr&gt;          -- 禁止对象的垃圾收集</div><div class=\"line\">enablegc &lt;expr&gt;           -- 允许对象的垃圾收集</div><div class=\"line\"></div><div class=\"line\">!!                        -- 重复执行最后一个命令</div><div class=\"line\">&lt;n&gt; &lt;command&gt;             -- 将命令重复执行 n 次</div><div class=\"line\"># &lt;command&gt;               -- 放弃 (无操作)</div><div class=\"line\">help (或 ?)               -- 列出命令</div><div class=\"line\">version                   -- 输出版本信息</div><div class=\"line\">exit (或 quit)            -- 退出调试器</div><div class=\"line\"></div><div class=\"line\">&lt;class id&gt;: 带有程序包限定符的完整类名</div><div class=\"line\">&lt;class pattern&gt;: 带有前导或尾随通配符 (&apos;*&apos;) 的类名</div><div class=\"line\">&lt;thread id&gt;: &apos;threads&apos; 命令中报告的线程编号</div><div class=\"line\">&lt;expr&gt;: Java(TM) 编程语言表达式。</div><div class=\"line\">支持大多数常见语法。</div><div class=\"line\"></div><div class=\"line\">可以将启动命令置于 &quot;jdb.ini&quot; 或 &quot;.jdbrc&quot; 中</div><div class=\"line\">位于 user.home 或 user.dir 中</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<p>上面的帮助信息说明了如何进行JDB调试，解释一下其中的几个：</p>\n<p>step: – 执行当前行 相当于Eclipse中的F5</p>\n<p>step up: – 一直执行, 直到当前方法返回到其调用方 相当于Eclipse中的F7</p>\n<p>next: – 步进一行 (步过调用) 相当于Eclipse中的F6</p>\n<p>cont: – 从断点处继续执行 相当于Eclipse中的F8</p>\n<p>此时，继续输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; stop at test.JDBTest:7</div><div class=\"line\">正在延迟断点test.JDBTest:7。</div><div class=\"line\">将在加载类后设置。</div><div class=\"line\">&gt; run</div><div class=\"line\">运行test.JDBTest</div><div class=\"line\">设置未捕获的java.lang.Throwable</div><div class=\"line\">设置延迟的未捕获的java.lang.Throwable</div><div class=\"line\">&gt;</div><div class=\"line\">VM 已启动: 设置延迟的断点test.JDBTest:7</div><div class=\"line\"></div><div class=\"line\">断点命中: &quot;线程=main&quot;, test.JDBTest.main(), 行=7 bci=0</div><div class=\"line\">7               JDBTest jdbTest = new JDBTest();</div><div class=\"line\"></div><div class=\"line\">main[1]</div></pre></td></tr></table></figure>\n<p>stop at test.JDBTest:7 表示在这个类文件的第7行处打一个断点</p>\n<p>接着，输入run，就开始进入调试步骤了。现在可以输入上面帮助中的语法来了解当前程序的执行情况了。一试便知</p>\n<p><code>注意, 若想要在调试时能够正常输出调试信息如变量值等等，需要在编译java文件时指定 -g 参数，否则无法获得其运行时的调试信息</code></p>\n<p>另外，使用list可以打印当前断点处的源代码，如果没有在启动JDB时指定源代码路径 -sourcepath ./src/ ，那么会提示没有源代码信息，无法输出。此时可以使用命令 use ./src/ 来指定源代码路径，再使用list命令时可以正常打印了。</p>\n<p>以上就是使用JDB调试本地程序的方法，具体的使用可根据实际情况参照语法说明去执行。</p>\n<h2 id=\"使用JDB进行远程调试\"><a href=\"#使用JDB进行远程调试\" class=\"headerlink\" title=\"使用JDB进行远程调试\"></a>使用JDB进行远程调试</h2><p>如果程序不是运行在本机，而是在其他机器或者现场的时候，可以使用java提供的远程调试功能。</p>\n<p>假设程序现运行在主机 192.168.101.72 这台机器上，该机器为linux环境，且只可以通过ssh作为一个普通用户连接。我们想要在自己的机器上调试运行在192.168.101.72这台机器上的程序。</p>\n<h3 id=\"启动要调试的程序\"><a href=\"#启动要调试的程序\" class=\"headerlink\" title=\"启动要调试的程序\"></a>启动要调试的程序</h3><p>在192.168.101.72这台主机上以下面的方式启动java程序：还是以JDBTest为例</p>\n<p><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest</code></p>\n<p>此时，命令行输出</p>\n<p><code>Listening for transport dt_socket at address: 8899</code></p>\n<p>并处于等待状态</p>\n<p>下面是几个参数的解释：</p>\n<p>-Xdebug 启用调试特性。 </p>\n<p>-Xrunjdwp:<sub-options> 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。下面介绍一些特定的子选项。<br>从 Java V5 开始，您可以使用 -agentlib:jdwp 选项，而不是 -Xdebug 和 -Xrunjdwp。但如果连接到 V5 以前的 VM，只能选择 -Xdebug 和 -Xrunjdwp。下面简单描述 -Xrunjdwp 子选项。</sub-options></p>\n<p>transport 这里通常使用套接字传输。但是在 Windows 平台上也可以使用共享内存传输。</p>\n<p>server 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。</p>\n<p>address 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。</p>\n<p>suspend 如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。</p>\n<h3 id=\"本机连接远程程序并启动调试\"><a href=\"#本机连接远程程序并启动调试\" class=\"headerlink\" title=\"本机连接远程程序并启动调试\"></a>本机连接远程程序并启动调试</h3><p>在本机上命令行下输入：</p>\n<p><code>jdb -connect com.sun.jdi.SocketAttach:hostname=192.168.101.72,port=8899</code></p>\n<p>然后就进入了调试界面，你可以像调试本机程序那样使用JDB的一些命令来调试了。当退出调试程序时，远程主机上的程序也就退出了。</p>\n<h2 id=\"使用Eclipse进行远程调试\"><a href=\"#使用Eclipse进行远程调试\" class=\"headerlink\" title=\"使用Eclipse进行远程调试\"></a>使用Eclipse进行远程调试</h2><p>可以使用Eclipse进行远程调试，就上上面使用JDB一样。</p>\n<h3 id=\"启动要调试的程序-1\"><a href=\"#启动要调试的程序-1\" class=\"headerlink\" title=\"启动要调试的程序\"></a>启动要调试的程序</h3><p>与JDB远程调试一样，启动远程主机上的程序：</p>\n<p><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest</code></p>\n<h3 id=\"本机启动Eclipse进行调试\"><a href=\"#本机启动Eclipse进行调试\" class=\"headerlink\" title=\"本机启动Eclipse进行调试\"></a>本机启动Eclipse进行调试</h3><p>首先要右键工程-&gt;java compiler</p>\n<img src=\"/2016/12/07/java远程调试学习/setting.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>上图中的几个选项最好全部打勾，否则调试时会出现无法打断点或者获取不到行号等问题(关于这几个选项的含义在之前的总结中有提到)</p>\n<p>接着，右键工程-&gt;Debug As-&gt;Run Configurations, 在出现的对话框中选择Remote Java Application, 右键-&gt;New, 出现如下界面：</p>\n<img src=\"/2016/12/07/java远程调试学习/remote.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>在Connect页中，选择对应的java 工程，Connection Type选择 Socket Attach，然后填写远程主机的ip和端口，这里应该填写192.168.101.72和8899。<br>在Source页中可以添加源代码，如用到的第三方jar的源代码或者引用的工程，调试时就可以进入到这部分代码查看。在Common页可以设置编码的配置。</p>\n<p>接下来点击Debug按钮，就可以愉快的在本机调试远程程序了，就像调试本地程序那样。只不过可能有一点一点慢，不过比打Log的方式要好很多了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-eclipse-javadebug/\" target=\"_blank\" rel=\"external\">使用 Eclipse 远程调试 Java 应用程序</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/java/joy-jdb/\" target=\"_blank\" rel=\"external\">JDB的简单使用</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/\" target=\"_blank\" rel=\"external\">深入 Java 调试体系: 第 1 部分，JPDA 体系概览 </a></p>\n","excerpt":"","more":"<blockquote>\n<p>集群前后台协议需要做一些修改，我负责jdbc这边的修改。按照协议内容修改完代码之后却面临一个测试的问题：修改后的后台又部署在北京，但北京并不是所有的机器都对天津这边开放，只给提供一台机器A，就是集群的服务器。<br>这样的话,就无法创建节点的连接，测试没有办法进行。</p>\n<p>一开始用了最简单的办法，把打好的jar包通过远程ssh放到A上面，再通过ssh去跑用例，打印结果看看正确与否。但是这样的效率真的太低了，每做一次修改都要打包、部署、运行、分析log。于是借这个机会学习一下java程序的远程调试。以下为总结。</p>\n</blockquote>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><p>JDPA: java平台调试架构</p>\n<p>JVMTI: JVM端调试接口</p>\n<p>JDI: java端调试接口</p>\n<p>JDWP: java调试网络协议</p>\n<img src=\"/2016/12/07/java远程调试学习/jdpa.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>JPDA 定义了一套如何开发调试工具的接口和规范。</p>\n<p>JPDA 由三个独立的模块 JVMTI、JDWP、JDI 组成。</p>\n<p>调试者通过 JDI 发送接受调试命令。</p>\n<p>JDWP 定义调试者和被调试者交流数据的格式。</p>\n<p>JVMTI 可以控制当前虚拟机运行状态。</p>\n<p>上图中的前端工具就是我们要用到的调试工具。如JDB、Eclipse等等。这些工具实现了JDI接口，通过这些工具我们可以达到在命令行或者图形界面下调试的目的。</p>\n<p>关于这部分，只是简单的了解一下概念，更多的关于JDPA的介绍：<a href=\"http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?search_by=%E6%B7%B1%E5%85%A5+Java+%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB\">JDPA体系</a></p>\n<h2 id=\"使用JDB进行本地调试\"><a href=\"#使用JDB进行本地调试\" class=\"headerlink\" title=\"使用JDB进行本地调试\"></a>使用JDB进行本地调试</h2><p>JDB 是jdk自带的一个调试工具，用于命令行下调试java程序</p>\n<p>jdb.exe就位于jdk安装目录的bin目录下，安装好jdk并设置好环境变量之后就可以愉快的使用jdb了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:\\Users\\kyu&gt;jdb -help</div><div class=\"line\">用法: jdb &lt;options&gt; &lt;class&gt; &lt;arguments&gt;</div><div class=\"line\"></div><div class=\"line\">其中, 选项包括:</div><div class=\"line\">    -help             输出此消息并退出</div><div class=\"line\">    -sourcepath &lt;由 &quot;;&quot; 分隔的目录&gt;</div><div class=\"line\">                      要在其中查找源文件的目录</div><div class=\"line\">    -attach &lt;address&gt;</div><div class=\"line\">                      使用标准连接器附加到指定地址处正在运行的 VM</div><div class=\"line\">    -listen &lt;address&gt;</div><div class=\"line\">                      等待正在运行的 VM 使用标准连接器在指定地址处连接</div><div class=\"line\">    -listenany</div><div class=\"line\">                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接</div><div class=\"line\">    -launch</div><div class=\"line\">                      立即启动 VM 而不是等待 &apos;run&apos; 命令</div><div class=\"line\">    -listconnectors   列出此 VM 中的可用连接器</div><div class=\"line\">    -connect &lt;connector-name&gt;:&lt;name1&gt;=&lt;value1&gt;,...</div><div class=\"line\">                      使用所列参数值通过指定的连接器连接到目标 VM</div><div class=\"line\">    -dbgtrace [flags] 输出信息供调试jdb</div><div class=\"line\">    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序</div><div class=\"line\">    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序</div><div class=\"line\"></div><div class=\"line\">转发到被调试进程的选项:</div><div class=\"line\">    -v -verbose[:class|gc|jni]</div><div class=\"line\">                      启用详细模式</div><div class=\"line\">    -D&lt;name&gt;=&lt;value&gt;  设置系统属性</div><div class=\"line\">    -classpath &lt;由 &quot;;&quot; 分隔的目录&gt;</div><div class=\"line\">                      列出要在其中查找类的目录</div><div class=\"line\">    -X&lt;option&gt;        非标准目标 VM 选项</div><div class=\"line\"></div><div class=\"line\">&lt;class&gt; 是要开始调试的类的名称</div><div class=\"line\">&lt;arguments&gt; 是传递到 &lt;class&gt; 的 main() 方法的参数</div><div class=\"line\"></div><div class=\"line\">要获得命令的帮助, 请在jdb提示下键入 &apos;help&apos;</div></pre></td></tr></table></figure>\n<p>上面是启动JDB的语法说明。</p>\n<p>现假设运行程序的工程目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">JDBTest</div><div class=\"line\">  |----bin(编译生成的class文件)</div><div class=\"line\">  |     |----*.class</div><div class=\"line\">  |----src(源文件)</div><div class=\"line\">  |     |----*.java</div><div class=\"line\">  |----lib(依赖的第三方jar)</div><div class=\"line\">  |     |----*.jar</div></pre></td></tr></table></figure>\n<p>开始启动JDB调试：</p>\n<p>Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</p>\n<p><code>注意，如果有多个文件，windows下使用 &quot;;&quot; 分隔每个文件或目录，Linux下使用 &quot;:&quot; 分隔每个文件或目录</code></p>\n<p><code>-classpath</code> 指定了类路径，<code>-sourcepath</code> 指定了源文件的路径</p>\n<p>回车，出现如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</div><div class=\"line\">正在初始化jdb...</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<p>此时，JDB调试器等待用户的输入，输入<code>help</code>，出现如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div></pre></td><td class=\"code\"><pre><div class=\"line\">Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</div><div class=\"line\">正在初始化jdb...</div><div class=\"line\">&gt; help</div><div class=\"line\">** 命令列表 **</div><div class=\"line\">connectors                -- 列出此 VM 中可用的连接器和传输</div><div class=\"line\"></div><div class=\"line\">run [class [args]]        -- 开始执行应用程序的主类</div><div class=\"line\"></div><div class=\"line\">threads [threadgroup]     -- 列出线程</div><div class=\"line\">thread &lt;thread id&gt;        -- 设置默认线程</div><div class=\"line\">suspend [thread id(s)]    -- 挂起线程 (默认值: all)</div><div class=\"line\">resume [thread id(s)]     -- 恢复线程 (默认值: all)</div><div class=\"line\">where [&lt;thread id&gt; | all] -- 转储线程的堆栈</div><div class=\"line\">wherei [&lt;thread id&gt; | all]-- 转储线程的堆栈, 以及 pc 信息</div><div class=\"line\">up [n frames]             -- 上移线程的堆栈</div><div class=\"line\">down [n frames]           -- 下移线程的堆栈</div><div class=\"line\">kill &lt;thread id&gt; &lt;expr&gt;   -- 终止具有给定的异常错误对象的线程</div><div class=\"line\">interrupt &lt;thread id&gt;     -- 中断线程</div><div class=\"line\"></div><div class=\"line\">print &lt;expr&gt;              -- 输出表达式的值</div><div class=\"line\">dump &lt;expr&gt;               -- 输出所有对象信息</div><div class=\"line\">eval &lt;expr&gt;               -- 对表达式求值 (与 print 相同)</div><div class=\"line\">set &lt;lvalue&gt; = &lt;expr&gt;     -- 向字段/变量/数组元素分配新值</div><div class=\"line\">locals                    -- 输出当前堆栈帧中的所有本地变量</div><div class=\"line\"></div><div class=\"line\">classes                   -- 列出当前已知的类</div><div class=\"line\">class &lt;class id&gt;          -- 显示已命名类的详细资料</div><div class=\"line\">methods &lt;class id&gt;        -- 列出类的方法</div><div class=\"line\">fields &lt;class id&gt;         -- 列出类的字段</div><div class=\"line\"></div><div class=\"line\">threadgroups              -- 列出线程组</div><div class=\"line\">threadgroup &lt;name&gt;        -- 设置当前线程组</div><div class=\"line\"></div><div class=\"line\">stop in &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]</div><div class=\"line\">                          -- 在方法中设置断点</div><div class=\"line\">stop at &lt;class id&gt;:&lt;line&gt; -- 在行中设置断点</div><div class=\"line\">clear &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]</div><div class=\"line\">                          -- 清除方法中的断点</div><div class=\"line\">clear &lt;class id&gt;:&lt;line&gt;   -- 清除行中的断点</div><div class=\"line\">clear                     -- 列出断点</div><div class=\"line\">catch [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;</div><div class=\"line\">                          -- 出现指定的异常错误时中断</div><div class=\"line\">ignore [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;</div><div class=\"line\">                          -- 对于指定的异常错误, 取消 &apos;catch&apos;</div><div class=\"line\">watch [access|all] &lt;class id&gt;.&lt;field name&gt;</div><div class=\"line\">                          -- 监视对字段的访问/修改</div><div class=\"line\">unwatch [access|all] &lt;class id&gt;.&lt;field name&gt;</div><div class=\"line\">                          -- 停止监视对字段的访问/修改</div><div class=\"line\">trace [go] methods [thread]</div><div class=\"line\">                          -- 跟踪方法进入和退出。</div><div class=\"line\">                          -- 除非指定 &apos;go&apos;, 否则挂起所有线程</div><div class=\"line\">trace [go] method exit | exits [thread]</div><div class=\"line\">                          -- 跟踪当前方法的退出, 或者所有方法的退出</div><div class=\"line\">                          -- 除非指定 &apos;go&apos;, 否则挂起所有线程</div><div class=\"line\">untrace [methods]         -- 停止跟踪方法进入和/或退出</div><div class=\"line\">step                      -- 执行当前行</div><div class=\"line\">step up                   -- 一直执行, 直到当前方法返回到其调用方</div><div class=\"line\">stepi                     -- 执行当前指令</div><div class=\"line\">next                      -- 步进一行 (步过调用)</div><div class=\"line\">cont                      -- 从断点处继续执行</div><div class=\"line\"></div><div class=\"line\">list [line number|method] -- 输出源代码</div><div class=\"line\">use (或 sourcepath) [source file path]</div><div class=\"line\">                          -- 显示或更改源路径</div><div class=\"line\">exclude [&lt;class pattern&gt;, ... | &quot;none&quot;]</div><div class=\"line\">                          -- 对于指定的类, 不报告步骤或方法事件</div><div class=\"line\">classpath                 -- 从目标 VM 输出类路径信息</div><div class=\"line\"></div><div class=\"line\">monitor &lt;command&gt;         -- 每次程序停止时执行命令</div><div class=\"line\">monitor                   -- 列出监视器</div><div class=\"line\">unmonitor &lt;monitor#&gt;      -- 删除监视器</div><div class=\"line\">read &lt;filename&gt;           -- 读取并执行命令文件</div><div class=\"line\"></div><div class=\"line\">lock &lt;expr&gt;               -- 输出对象的锁信息</div><div class=\"line\">threadlocks [thread id]   -- 输出线程的锁信息</div><div class=\"line\"></div><div class=\"line\">pop                       -- 通过当前帧出栈, 且包含当前帧</div><div class=\"line\">reenter                   -- 与 pop 相同, 但重新进入当前帧</div><div class=\"line\">redefine &lt;class id&gt; &lt;class file name&gt;</div><div class=\"line\">                          -- 重新定义类的代码</div><div class=\"line\"></div><div class=\"line\">disablegc &lt;expr&gt;          -- 禁止对象的垃圾收集</div><div class=\"line\">enablegc &lt;expr&gt;           -- 允许对象的垃圾收集</div><div class=\"line\"></div><div class=\"line\">!!                        -- 重复执行最后一个命令</div><div class=\"line\">&lt;n&gt; &lt;command&gt;             -- 将命令重复执行 n 次</div><div class=\"line\"># &lt;command&gt;               -- 放弃 (无操作)</div><div class=\"line\">help (或 ?)               -- 列出命令</div><div class=\"line\">version                   -- 输出版本信息</div><div class=\"line\">exit (或 quit)            -- 退出调试器</div><div class=\"line\"></div><div class=\"line\">&lt;class id&gt;: 带有程序包限定符的完整类名</div><div class=\"line\">&lt;class pattern&gt;: 带有前导或尾随通配符 (&apos;*&apos;) 的类名</div><div class=\"line\">&lt;thread id&gt;: &apos;threads&apos; 命令中报告的线程编号</div><div class=\"line\">&lt;expr&gt;: Java(TM) 编程语言表达式。</div><div class=\"line\">支持大多数常见语法。</div><div class=\"line\"></div><div class=\"line\">可以将启动命令置于 &quot;jdb.ini&quot; 或 &quot;.jdbrc&quot; 中</div><div class=\"line\">位于 user.home 或 user.dir 中</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<p>上面的帮助信息说明了如何进行JDB调试，解释一下其中的几个：</p>\n<p>step: – 执行当前行 相当于Eclipse中的F5</p>\n<p>step up: – 一直执行, 直到当前方法返回到其调用方 相当于Eclipse中的F7</p>\n<p>next: – 步进一行 (步过调用) 相当于Eclipse中的F6</p>\n<p>cont: – 从断点处继续执行 相当于Eclipse中的F8</p>\n<p>此时，继续输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; stop at test.JDBTest:7</div><div class=\"line\">正在延迟断点test.JDBTest:7。</div><div class=\"line\">将在加载类后设置。</div><div class=\"line\">&gt; run</div><div class=\"line\">运行test.JDBTest</div><div class=\"line\">设置未捕获的java.lang.Throwable</div><div class=\"line\">设置延迟的未捕获的java.lang.Throwable</div><div class=\"line\">&gt;</div><div class=\"line\">VM 已启动: 设置延迟的断点test.JDBTest:7</div><div class=\"line\"></div><div class=\"line\">断点命中: &quot;线程=main&quot;, test.JDBTest.main(), 行=7 bci=0</div><div class=\"line\">7               JDBTest jdbTest = new JDBTest();</div><div class=\"line\"></div><div class=\"line\">main[1]</div></pre></td></tr></table></figure>\n<p>stop at test.JDBTest:7 表示在这个类文件的第7行处打一个断点</p>\n<p>接着，输入run，就开始进入调试步骤了。现在可以输入上面帮助中的语法来了解当前程序的执行情况了。一试便知</p>\n<p><code>注意, 若想要在调试时能够正常输出调试信息如变量值等等，需要在编译java文件时指定 -g 参数，否则无法获得其运行时的调试信息</code></p>\n<p>另外，使用list可以打印当前断点处的源代码，如果没有在启动JDB时指定源代码路径 -sourcepath ./src/ ，那么会提示没有源代码信息，无法输出。此时可以使用命令 use ./src/ 来指定源代码路径，再使用list命令时可以正常打印了。</p>\n<p>以上就是使用JDB调试本地程序的方法，具体的使用可根据实际情况参照语法说明去执行。</p>\n<h2 id=\"使用JDB进行远程调试\"><a href=\"#使用JDB进行远程调试\" class=\"headerlink\" title=\"使用JDB进行远程调试\"></a>使用JDB进行远程调试</h2><p>如果程序不是运行在本机，而是在其他机器或者现场的时候，可以使用java提供的远程调试功能。</p>\n<p>假设程序现运行在主机 192.168.101.72 这台机器上，该机器为linux环境，且只可以通过ssh作为一个普通用户连接。我们想要在自己的机器上调试运行在192.168.101.72这台机器上的程序。</p>\n<h3 id=\"启动要调试的程序\"><a href=\"#启动要调试的程序\" class=\"headerlink\" title=\"启动要调试的程序\"></a>启动要调试的程序</h3><p>在192.168.101.72这台主机上以下面的方式启动java程序：还是以JDBTest为例</p>\n<p><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest</code></p>\n<p>此时，命令行输出</p>\n<p><code>Listening for transport dt_socket at address: 8899</code></p>\n<p>并处于等待状态</p>\n<p>下面是几个参数的解释：</p>\n<p>-Xdebug 启用调试特性。 </p>\n<p>-Xrunjdwp:<sub-options> 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。下面介绍一些特定的子选项。<br>从 Java V5 开始，您可以使用 -agentlib:jdwp 选项，而不是 -Xdebug 和 -Xrunjdwp。但如果连接到 V5 以前的 VM，只能选择 -Xdebug 和 -Xrunjdwp。下面简单描述 -Xrunjdwp 子选项。</p>\n<p>transport 这里通常使用套接字传输。但是在 Windows 平台上也可以使用共享内存传输。</p>\n<p>server 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。</p>\n<p>address 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。</p>\n<p>suspend 如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。</p>\n<h3 id=\"本机连接远程程序并启动调试\"><a href=\"#本机连接远程程序并启动调试\" class=\"headerlink\" title=\"本机连接远程程序并启动调试\"></a>本机连接远程程序并启动调试</h3><p>在本机上命令行下输入：</p>\n<p><code>jdb -connect com.sun.jdi.SocketAttach:hostname=192.168.101.72,port=8899</code></p>\n<p>然后就进入了调试界面，你可以像调试本机程序那样使用JDB的一些命令来调试了。当退出调试程序时，远程主机上的程序也就退出了。</p>\n<h2 id=\"使用Eclipse进行远程调试\"><a href=\"#使用Eclipse进行远程调试\" class=\"headerlink\" title=\"使用Eclipse进行远程调试\"></a>使用Eclipse进行远程调试</h2><p>可以使用Eclipse进行远程调试，就上上面使用JDB一样。</p>\n<h3 id=\"启动要调试的程序-1\"><a href=\"#启动要调试的程序-1\" class=\"headerlink\" title=\"启动要调试的程序\"></a>启动要调试的程序</h3><p>与JDB远程调试一样，启动远程主机上的程序：</p>\n<p><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest</code></p>\n<h3 id=\"本机启动Eclipse进行调试\"><a href=\"#本机启动Eclipse进行调试\" class=\"headerlink\" title=\"本机启动Eclipse进行调试\"></a>本机启动Eclipse进行调试</h3><p>首先要右键工程-&gt;java compiler</p>\n<img src=\"/2016/12/07/java远程调试学习/setting.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>上图中的几个选项最好全部打勾，否则调试时会出现无法打断点或者获取不到行号等问题(关于这几个选项的含义在之前的总结中有提到)</p>\n<p>接着，右键工程-&gt;Debug As-&gt;Run Configurations, 在出现的对话框中选择Remote Java Application, 右键-&gt;New, 出现如下界面：</p>\n<img src=\"/2016/12/07/java远程调试学习/remote.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>在Connect页中，选择对应的java 工程，Connection Type选择 Socket Attach，然后填写远程主机的ip和端口，这里应该填写192.168.101.72和8899。<br>在Source页中可以添加源代码，如用到的第三方jar的源代码或者引用的工程，调试时就可以进入到这部分代码查看。在Common页可以设置编码的配置。</p>\n<p>接下来点击Debug按钮，就可以愉快的在本机调试远程程序了，就像调试本地程序那样。只不过可能有一点一点慢，不过比打Log的方式要好很多了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-eclipse-javadebug/\">使用 Eclipse 远程调试 Java 应用程序</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/java/joy-jdb/\">JDB的简单使用</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/\">深入 Java 调试体系: 第 1 部分，JPDA 体系概览 </a></p>\n"},{"layout":"post","date":"2016-04-12T04:48:55.000Z","title":"Junit的使用","_content":"\n>[Junit](http://junit.org/junit4/)是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。\n\n\n\n\n\n\n\n**资料**\n\n[Unit Testing with JUnit - Tutorial](http://www.vogella.com/tutorials/JUnit/article.html)\n\n[JUnit Tutorial](http://www.tutorialspoint.com/junit/)\n\n[走进java测试利器-junit](http://developer.51cto.com/art/201103/252490.htm)\n\n","source":"_posts/junit使用.md","raw":"---\nlayout: post\ndate:   2016-04-12 12:48:55\ntitle: \"Junit的使用\"\ncategories: 工具\ntags: \n- junit\n- 测试\n---\n\n>[Junit](http://junit.org/junit4/)是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。\n\n\n\n\n\n\n\n**资料**\n\n[Unit Testing with JUnit - Tutorial](http://www.vogella.com/tutorials/JUnit/article.html)\n\n[JUnit Tutorial](http://www.tutorialspoint.com/junit/)\n\n[走进java测试利器-junit](http://developer.51cto.com/art/201103/252490.htm)\n\n","slug":"junit使用","published":1,"updated":"2017-02-19T13:08:11.036Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlrx002dvegcz0jtpms7","content":"<blockquote>\n<p><a href=\"http://junit.org/junit4/\" target=\"_blank\" rel=\"external\">Junit</a>是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。</p>\n</blockquote>\n<p><strong>资料</strong></p>\n<p><a href=\"http://www.vogella.com/tutorials/JUnit/article.html\" target=\"_blank\" rel=\"external\">Unit Testing with JUnit - Tutorial</a></p>\n<p><a href=\"http://www.tutorialspoint.com/junit/\" target=\"_blank\" rel=\"external\">JUnit Tutorial</a></p>\n<p><a href=\"http://developer.51cto.com/art/201103/252490.htm\" target=\"_blank\" rel=\"external\">走进java测试利器-junit</a></p>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"http://junit.org/junit4/\">Junit</a>是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。</p>\n</blockquote>\n<p><strong>资料</strong></p>\n<p><a href=\"http://www.vogella.com/tutorials/JUnit/article.html\">Unit Testing with JUnit - Tutorial</a></p>\n<p><a href=\"http://www.tutorialspoint.com/junit/\">JUnit Tutorial</a></p>\n<p><a href=\"http://developer.51cto.com/art/201103/252490.htm\">走进java测试利器-junit</a></p>\n"},{"layout":"post","title":"linux分区","date":"2017-03-04T03:45:43.000Z","_content":"> 每次安装linux的时候，都会选择分区和挂载点。但是基本上没怎么研究过linux分区的细节，今天回顾了一下《鸟哥的linux私房菜》，总结一下分区的相关知识。\n\n## 磁盘的组成\n\n{% asset_img cipan.png 磁盘 %}\n\n磁道（Track）：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。\n\n柱面（Cylinder）：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。\n\n扇区（Sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。\n\n磁头（Heads）\n\n盘片（Platters）\n\n每个碟片都有两面，因此也会相对应每碟片有2个磁头。\n\n硬盘的物理结构一般由磁头与碟片、电动机、主控芯片与排线等部件组成；当主电动机带动碟片旋转时，副电动机带动一组（磁头）到相对应的碟片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与碟片同心的圆形轨道（磁轨或称柱面），这时由磁头的磁感线圈感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位扇区，从而得到该扇区的数据内容；\n\n磁盘的第一个扇区记录了整块磁盘的重要信息，主要有两个：\n\n1.主引导分区：可以安装引导加载程序的地方，有446bytes\n\n2.分区表：记录整块音盘的分区状况，有64bytes\n\n ## 开机流程\n\n简单梳理一下开机流程：\n\n计算机开机后，会主动执行BIOS程序，BIOS是写入到主板上面的一个软件程序。接下来BIOS会去分析计算机中有哪些存储设备，然后依据用户的设置获取可以开机的硬盘（比如我们设置从usb启动），\n然后到读取该硬盘中的第一个扇区MBR位置。MBR中放置着基本的引导加载程序，接下来就是MBR内的引导加载程序加载内核文件。这个引导加载程序是操作系统在安装时提供的。\n\n## 磁盘分区表\n\n分区不难理解，在windows中，就意味着C，D，E等不同的盘，其实这些c盘，d盘往往都是属于同一块磁盘，将同一块磁盘划分开来，这就是分区。那为什么要分区呢？\n\n1.数据安全\n\n很好理解。比如我们在重装win操作系统的时候，往往只需要重装c盘即可，d盘等其他分区里的数据并不受重装系统的影响。\n\n2.性能\n\n将磁盘分区后，提高了数据读取的速度。我们在寻找某个分区的数据时，只需要扫描该分区对应磁盘的位置即可，并不需要全盘扫描。\n\n那么，到底是如何分区呢？\n\n{% asset_img zhumian.jpg 柱面 %}\n\n上图中，不同颜色的柱面范围就代表了不同的分区。分区利用了柱面号码的方式来处理。在分区表所在的64bytes中，总共分为四组记录，每组记录该分区的起始与结束柱面号码。\n\n我们将上图中从圆心到周长中间切出一条长方形来看：\n\n{% asset_img fen.png 分区 %}\n\n上图假设硬盘有400个柱面，分成四个分区。所谓的分区其实就是针对分区表进行设置而已。分区表最多可以容纳四个分区(只能记录四条数据)，这四个分区被称为主分区或者扩展分区。\n系统要写磁盘时，首先会参考磁盘分区表，然后才对某个分区的数据进行处理。\n\n假设这个磁盘在linux中的设备文件名为/dev/hda，那么这四个分区的文件名分别为：\n\np1:/dev/hda1  p2:/dev/hda2  p3:/dev/hda3  p4:/dev/hda4\n\n那么如何可以分得更多的分区呢？装过操作系统的人都知道分区不仅仅可以分四个，我们可以有c,d,e,f,g等等多个磁盘的划分。这都是通过扩展分区来做到的。\n\n扩展分区的原理就是利用额外的扇区来记录更多的分区信息，从而继续分出更多的分区来。由扩展分区分出来的分区叫做逻辑分区。\n\n{% asset_img kuozhan.png 分区 %}\n\n上图中，我们将磁盘/dev/sdb 分为了六个分区，分别是\n\n三个主分区：/dev/sdb1，/dev/sdb2/，/dev/sdb3\n\n三个逻辑分区：/dev/sdb5，/dev/sdb6/，/dev/sdb7\n\n为什么没有sdb4呢？那是因为1-4是保留给主分区或者扩展分区使用的。\n\n注意以下几点：\n\n主分区和扩展分区最多只能有四个；\n\n扩展分区只能有一个；\n\n逻辑分区是有扩展分区再切割而来的；\n\n扩展分区不能够格式化，所以无法直接使用，必须分为逻辑分区后才可以访问；\n\n所以说，如果我们想要分出四个以上的分区时，务必要设置一个扩展分区，而不能将四个分区全部划为主分区。\n\n## 多重引导\n\n前面的开机流程中提到，计算机通过读取MBR中的引导加载程序，使用该程序读取内核文件，启动操作系统。如果我们安装了双系统的话，又是如何指定启动哪一个操作系统呢？\n\n引导加载程序主要有下面几个功能：\n\n提供不同的开机选项；\n\n载入内核文件；\n\n将引导加载功能转交给其他引导加载程序；\n\n其中第三点，转交给其他引导加载程序，表明我们可以安装不同的引导加载程序到硬盘上面，但是MBR只有一个，也只能安装一个引导加载程序。\n其他的引导加载程序，可以安装在不同分区的引导扇区上面。\n\n{% asset_img yindao.jpg 分区 %}\n\n上图中，我们假设分别在两块分区上安装了windows和linux。当MBR中的引导加载程序开始工作时，会提供两个开机选项供我们选择：\n\n如果我们选择windows，引导加载程序直接加载windows的内核文件开机；\n\n如果我们选择linux，引导加载程序会把工作交给第二个分区的启动扇区中的引导加载程序。第二个引导加载程序启动后，加载该分区内的内核文件开机。\n\n那么，为什么安装双系统时，常常要求先安装windows，后安装linux呢？\n\n那是因为windows在安装的时候，会主动覆盖掉MBR及自己所在分区的启动扇区，并且也没有提供不同的开机选项菜单；而安装linux，可以选择将引导程序安装在MBR或者其他分区的启动扇区，并且也提供了手动设置开机菜单的功能。\n\n如果我们先安装了linux，再安装windows的时候就会把linux在MBR内的引导加载程序覆盖掉，并且也不会提供linux选项，而是直接进入windows系统。\n\n## 挂载点\n\n安装linux的时候，都会让我们选择挂载点。这个挂载点又与分区有什么关系呢？\n\n我们知道linux中所有的数据都以文件的形式存在，而文件数据是放在磁盘的分区当中的。所有的文件都是又根目录/衍生而来，我们想要取得/home/yukai/data.txt这个文件时，系统又根目录开始找，\n找到home，然后找到yukai，最后找到data.txt这个文件。如何由目录树找到磁盘分区中的数据，就是挂载点的意义。\n\n所谓的挂载就是利用一个目录当作进入点，去访问挂载在这个目录上的分区内的文件，即进入该目录就可以读取该分区，该目录是该分区的入口。我们想要访问一个分区时，必须将该分区挂载到某个目录上面，这个目录就是挂载点。\n\n所以说在安装linux的时候，要选择分区和挂载点，意思就是把不同的数据放置到不同的分区上的意思，比如我们把 /dev/sda1的挂载点设置为/home，就意味着/home下所有的数据都存放在/dev/sda1这个分区上面。\n\n","source":"_posts/linux分区.md","raw":"---\nlayout: post\ntitle: linux分区\ndate: 2017-03-04 11:45:43\ncategories: 技术\ntags: linux\n---\n> 每次安装linux的时候，都会选择分区和挂载点。但是基本上没怎么研究过linux分区的细节，今天回顾了一下《鸟哥的linux私房菜》，总结一下分区的相关知识。\n\n## 磁盘的组成\n\n{% asset_img cipan.png 磁盘 %}\n\n磁道（Track）：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。\n\n柱面（Cylinder）：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。\n\n扇区（Sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。\n\n磁头（Heads）\n\n盘片（Platters）\n\n每个碟片都有两面，因此也会相对应每碟片有2个磁头。\n\n硬盘的物理结构一般由磁头与碟片、电动机、主控芯片与排线等部件组成；当主电动机带动碟片旋转时，副电动机带动一组（磁头）到相对应的碟片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与碟片同心的圆形轨道（磁轨或称柱面），这时由磁头的磁感线圈感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位扇区，从而得到该扇区的数据内容；\n\n磁盘的第一个扇区记录了整块磁盘的重要信息，主要有两个：\n\n1.主引导分区：可以安装引导加载程序的地方，有446bytes\n\n2.分区表：记录整块音盘的分区状况，有64bytes\n\n ## 开机流程\n\n简单梳理一下开机流程：\n\n计算机开机后，会主动执行BIOS程序，BIOS是写入到主板上面的一个软件程序。接下来BIOS会去分析计算机中有哪些存储设备，然后依据用户的设置获取可以开机的硬盘（比如我们设置从usb启动），\n然后到读取该硬盘中的第一个扇区MBR位置。MBR中放置着基本的引导加载程序，接下来就是MBR内的引导加载程序加载内核文件。这个引导加载程序是操作系统在安装时提供的。\n\n## 磁盘分区表\n\n分区不难理解，在windows中，就意味着C，D，E等不同的盘，其实这些c盘，d盘往往都是属于同一块磁盘，将同一块磁盘划分开来，这就是分区。那为什么要分区呢？\n\n1.数据安全\n\n很好理解。比如我们在重装win操作系统的时候，往往只需要重装c盘即可，d盘等其他分区里的数据并不受重装系统的影响。\n\n2.性能\n\n将磁盘分区后，提高了数据读取的速度。我们在寻找某个分区的数据时，只需要扫描该分区对应磁盘的位置即可，并不需要全盘扫描。\n\n那么，到底是如何分区呢？\n\n{% asset_img zhumian.jpg 柱面 %}\n\n上图中，不同颜色的柱面范围就代表了不同的分区。分区利用了柱面号码的方式来处理。在分区表所在的64bytes中，总共分为四组记录，每组记录该分区的起始与结束柱面号码。\n\n我们将上图中从圆心到周长中间切出一条长方形来看：\n\n{% asset_img fen.png 分区 %}\n\n上图假设硬盘有400个柱面，分成四个分区。所谓的分区其实就是针对分区表进行设置而已。分区表最多可以容纳四个分区(只能记录四条数据)，这四个分区被称为主分区或者扩展分区。\n系统要写磁盘时，首先会参考磁盘分区表，然后才对某个分区的数据进行处理。\n\n假设这个磁盘在linux中的设备文件名为/dev/hda，那么这四个分区的文件名分别为：\n\np1:/dev/hda1  p2:/dev/hda2  p3:/dev/hda3  p4:/dev/hda4\n\n那么如何可以分得更多的分区呢？装过操作系统的人都知道分区不仅仅可以分四个，我们可以有c,d,e,f,g等等多个磁盘的划分。这都是通过扩展分区来做到的。\n\n扩展分区的原理就是利用额外的扇区来记录更多的分区信息，从而继续分出更多的分区来。由扩展分区分出来的分区叫做逻辑分区。\n\n{% asset_img kuozhan.png 分区 %}\n\n上图中，我们将磁盘/dev/sdb 分为了六个分区，分别是\n\n三个主分区：/dev/sdb1，/dev/sdb2/，/dev/sdb3\n\n三个逻辑分区：/dev/sdb5，/dev/sdb6/，/dev/sdb7\n\n为什么没有sdb4呢？那是因为1-4是保留给主分区或者扩展分区使用的。\n\n注意以下几点：\n\n主分区和扩展分区最多只能有四个；\n\n扩展分区只能有一个；\n\n逻辑分区是有扩展分区再切割而来的；\n\n扩展分区不能够格式化，所以无法直接使用，必须分为逻辑分区后才可以访问；\n\n所以说，如果我们想要分出四个以上的分区时，务必要设置一个扩展分区，而不能将四个分区全部划为主分区。\n\n## 多重引导\n\n前面的开机流程中提到，计算机通过读取MBR中的引导加载程序，使用该程序读取内核文件，启动操作系统。如果我们安装了双系统的话，又是如何指定启动哪一个操作系统呢？\n\n引导加载程序主要有下面几个功能：\n\n提供不同的开机选项；\n\n载入内核文件；\n\n将引导加载功能转交给其他引导加载程序；\n\n其中第三点，转交给其他引导加载程序，表明我们可以安装不同的引导加载程序到硬盘上面，但是MBR只有一个，也只能安装一个引导加载程序。\n其他的引导加载程序，可以安装在不同分区的引导扇区上面。\n\n{% asset_img yindao.jpg 分区 %}\n\n上图中，我们假设分别在两块分区上安装了windows和linux。当MBR中的引导加载程序开始工作时，会提供两个开机选项供我们选择：\n\n如果我们选择windows，引导加载程序直接加载windows的内核文件开机；\n\n如果我们选择linux，引导加载程序会把工作交给第二个分区的启动扇区中的引导加载程序。第二个引导加载程序启动后，加载该分区内的内核文件开机。\n\n那么，为什么安装双系统时，常常要求先安装windows，后安装linux呢？\n\n那是因为windows在安装的时候，会主动覆盖掉MBR及自己所在分区的启动扇区，并且也没有提供不同的开机选项菜单；而安装linux，可以选择将引导程序安装在MBR或者其他分区的启动扇区，并且也提供了手动设置开机菜单的功能。\n\n如果我们先安装了linux，再安装windows的时候就会把linux在MBR内的引导加载程序覆盖掉，并且也不会提供linux选项，而是直接进入windows系统。\n\n## 挂载点\n\n安装linux的时候，都会让我们选择挂载点。这个挂载点又与分区有什么关系呢？\n\n我们知道linux中所有的数据都以文件的形式存在，而文件数据是放在磁盘的分区当中的。所有的文件都是又根目录/衍生而来，我们想要取得/home/yukai/data.txt这个文件时，系统又根目录开始找，\n找到home，然后找到yukai，最后找到data.txt这个文件。如何由目录树找到磁盘分区中的数据，就是挂载点的意义。\n\n所谓的挂载就是利用一个目录当作进入点，去访问挂载在这个目录上的分区内的文件，即进入该目录就可以读取该分区，该目录是该分区的入口。我们想要访问一个分区时，必须将该分区挂载到某个目录上面，这个目录就是挂载点。\n\n所以说在安装linux的时候，要选择分区和挂载点，意思就是把不同的数据放置到不同的分区上的意思，比如我们把 /dev/sda1的挂载点设置为/home，就意味着/home下所有的数据都存放在/dev/sda1这个分区上面。\n\n","slug":"linux分区","published":1,"updated":"2017-03-05T12:49:27.753Z","comments":1,"photos":[],"link":"","_id":"cj0xuzls2002gvegcktu63uu8","content":"<blockquote>\n<p>每次安装linux的时候，都会选择分区和挂载点。但是基本上没怎么研究过linux分区的细节，今天回顾了一下《鸟哥的linux私房菜》，总结一下分区的相关知识。</p>\n</blockquote>\n<h2 id=\"磁盘的组成\"><a href=\"#磁盘的组成\" class=\"headerlink\" title=\"磁盘的组成\"></a>磁盘的组成</h2><img src=\"/2017/03/04/linux分区/cipan.png\" alt=\"磁盘\" title=\"磁盘\">\n<p>磁道（Track）：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。</p>\n<p>柱面（Cylinder）：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。</p>\n<p>扇区（Sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。</p>\n<p>磁头（Heads）</p>\n<p>盘片（Platters）</p>\n<p>每个碟片都有两面，因此也会相对应每碟片有2个磁头。</p>\n<p>硬盘的物理结构一般由磁头与碟片、电动机、主控芯片与排线等部件组成；当主电动机带动碟片旋转时，副电动机带动一组（磁头）到相对应的碟片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与碟片同心的圆形轨道（磁轨或称柱面），这时由磁头的磁感线圈感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位扇区，从而得到该扇区的数据内容；</p>\n<p>磁盘的第一个扇区记录了整块磁盘的重要信息，主要有两个：</p>\n<p>1.主引导分区：可以安装引导加载程序的地方，有446bytes</p>\n<p>2.分区表：记录整块音盘的分区状况，有64bytes</p>\n<h2 id=\"开机流程\"><a href=\"#开机流程\" class=\"headerlink\" title=\"开机流程\"></a>开机流程</h2><p>简单梳理一下开机流程：</p>\n<p>计算机开机后，会主动执行BIOS程序，BIOS是写入到主板上面的一个软件程序。接下来BIOS会去分析计算机中有哪些存储设备，然后依据用户的设置获取可以开机的硬盘（比如我们设置从usb启动），<br>然后到读取该硬盘中的第一个扇区MBR位置。MBR中放置着基本的引导加载程序，接下来就是MBR内的引导加载程序加载内核文件。这个引导加载程序是操作系统在安装时提供的。</p>\n<h2 id=\"磁盘分区表\"><a href=\"#磁盘分区表\" class=\"headerlink\" title=\"磁盘分区表\"></a>磁盘分区表</h2><p>分区不难理解，在windows中，就意味着C，D，E等不同的盘，其实这些c盘，d盘往往都是属于同一块磁盘，将同一块磁盘划分开来，这就是分区。那为什么要分区呢？</p>\n<p>1.数据安全</p>\n<p>很好理解。比如我们在重装win操作系统的时候，往往只需要重装c盘即可，d盘等其他分区里的数据并不受重装系统的影响。</p>\n<p>2.性能</p>\n<p>将磁盘分区后，提高了数据读取的速度。我们在寻找某个分区的数据时，只需要扫描该分区对应磁盘的位置即可，并不需要全盘扫描。</p>\n<p>那么，到底是如何分区呢？</p>\n<img src=\"/2017/03/04/linux分区/zhumian.jpg\" alt=\"柱面\" title=\"柱面\">\n<p>上图中，不同颜色的柱面范围就代表了不同的分区。分区利用了柱面号码的方式来处理。在分区表所在的64bytes中，总共分为四组记录，每组记录该分区的起始与结束柱面号码。</p>\n<p>我们将上图中从圆心到周长中间切出一条长方形来看：</p>\n<img src=\"/2017/03/04/linux分区/fen.png\" alt=\"分区\" title=\"分区\">\n<p>上图假设硬盘有400个柱面，分成四个分区。所谓的分区其实就是针对分区表进行设置而已。分区表最多可以容纳四个分区(只能记录四条数据)，这四个分区被称为主分区或者扩展分区。<br>系统要写磁盘时，首先会参考磁盘分区表，然后才对某个分区的数据进行处理。</p>\n<p>假设这个磁盘在linux中的设备文件名为/dev/hda，那么这四个分区的文件名分别为：</p>\n<p>p1:/dev/hda1  p2:/dev/hda2  p3:/dev/hda3  p4:/dev/hda4</p>\n<p>那么如何可以分得更多的分区呢？装过操作系统的人都知道分区不仅仅可以分四个，我们可以有c,d,e,f,g等等多个磁盘的划分。这都是通过扩展分区来做到的。</p>\n<p>扩展分区的原理就是利用额外的扇区来记录更多的分区信息，从而继续分出更多的分区来。由扩展分区分出来的分区叫做逻辑分区。</p>\n<img src=\"/2017/03/04/linux分区/kuozhan.png\" alt=\"分区\" title=\"分区\">\n<p>上图中，我们将磁盘/dev/sdb 分为了六个分区，分别是</p>\n<p>三个主分区：/dev/sdb1，/dev/sdb2/，/dev/sdb3</p>\n<p>三个逻辑分区：/dev/sdb5，/dev/sdb6/，/dev/sdb7</p>\n<p>为什么没有sdb4呢？那是因为1-4是保留给主分区或者扩展分区使用的。</p>\n<p>注意以下几点：</p>\n<p>主分区和扩展分区最多只能有四个；</p>\n<p>扩展分区只能有一个；</p>\n<p>逻辑分区是有扩展分区再切割而来的；</p>\n<p>扩展分区不能够格式化，所以无法直接使用，必须分为逻辑分区后才可以访问；</p>\n<p>所以说，如果我们想要分出四个以上的分区时，务必要设置一个扩展分区，而不能将四个分区全部划为主分区。</p>\n<h2 id=\"多重引导\"><a href=\"#多重引导\" class=\"headerlink\" title=\"多重引导\"></a>多重引导</h2><p>前面的开机流程中提到，计算机通过读取MBR中的引导加载程序，使用该程序读取内核文件，启动操作系统。如果我们安装了双系统的话，又是如何指定启动哪一个操作系统呢？</p>\n<p>引导加载程序主要有下面几个功能：</p>\n<p>提供不同的开机选项；</p>\n<p>载入内核文件；</p>\n<p>将引导加载功能转交给其他引导加载程序；</p>\n<p>其中第三点，转交给其他引导加载程序，表明我们可以安装不同的引导加载程序到硬盘上面，但是MBR只有一个，也只能安装一个引导加载程序。<br>其他的引导加载程序，可以安装在不同分区的引导扇区上面。</p>\n<img src=\"/2017/03/04/linux分区/yindao.jpg\" alt=\"分区\" title=\"分区\">\n<p>上图中，我们假设分别在两块分区上安装了windows和linux。当MBR中的引导加载程序开始工作时，会提供两个开机选项供我们选择：</p>\n<p>如果我们选择windows，引导加载程序直接加载windows的内核文件开机；</p>\n<p>如果我们选择linux，引导加载程序会把工作交给第二个分区的启动扇区中的引导加载程序。第二个引导加载程序启动后，加载该分区内的内核文件开机。</p>\n<p>那么，为什么安装双系统时，常常要求先安装windows，后安装linux呢？</p>\n<p>那是因为windows在安装的时候，会主动覆盖掉MBR及自己所在分区的启动扇区，并且也没有提供不同的开机选项菜单；而安装linux，可以选择将引导程序安装在MBR或者其他分区的启动扇区，并且也提供了手动设置开机菜单的功能。</p>\n<p>如果我们先安装了linux，再安装windows的时候就会把linux在MBR内的引导加载程序覆盖掉，并且也不会提供linux选项，而是直接进入windows系统。</p>\n<h2 id=\"挂载点\"><a href=\"#挂载点\" class=\"headerlink\" title=\"挂载点\"></a>挂载点</h2><p>安装linux的时候，都会让我们选择挂载点。这个挂载点又与分区有什么关系呢？</p>\n<p>我们知道linux中所有的数据都以文件的形式存在，而文件数据是放在磁盘的分区当中的。所有的文件都是又根目录/衍生而来，我们想要取得/home/yukai/data.txt这个文件时，系统又根目录开始找，<br>找到home，然后找到yukai，最后找到data.txt这个文件。如何由目录树找到磁盘分区中的数据，就是挂载点的意义。</p>\n<p>所谓的挂载就是利用一个目录当作进入点，去访问挂载在这个目录上的分区内的文件，即进入该目录就可以读取该分区，该目录是该分区的入口。我们想要访问一个分区时，必须将该分区挂载到某个目录上面，这个目录就是挂载点。</p>\n<p>所以说在安装linux的时候，要选择分区和挂载点，意思就是把不同的数据放置到不同的分区上的意思，比如我们把 /dev/sda1的挂载点设置为/home，就意味着/home下所有的数据都存放在/dev/sda1这个分区上面。</p>\n","excerpt":"","more":"<blockquote>\n<p>每次安装linux的时候，都会选择分区和挂载点。但是基本上没怎么研究过linux分区的细节，今天回顾了一下《鸟哥的linux私房菜》，总结一下分区的相关知识。</p>\n</blockquote>\n<h2 id=\"磁盘的组成\"><a href=\"#磁盘的组成\" class=\"headerlink\" title=\"磁盘的组成\"></a>磁盘的组成</h2><img src=\"/2017/03/04/linux分区/cipan.png\" alt=\"磁盘\" title=\"磁盘\">\n<p>磁道（Track）：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。</p>\n<p>柱面（Cylinder）：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。</p>\n<p>扇区（Sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。</p>\n<p>磁头（Heads）</p>\n<p>盘片（Platters）</p>\n<p>每个碟片都有两面，因此也会相对应每碟片有2个磁头。</p>\n<p>硬盘的物理结构一般由磁头与碟片、电动机、主控芯片与排线等部件组成；当主电动机带动碟片旋转时，副电动机带动一组（磁头）到相对应的碟片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与碟片同心的圆形轨道（磁轨或称柱面），这时由磁头的磁感线圈感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位扇区，从而得到该扇区的数据内容；</p>\n<p>磁盘的第一个扇区记录了整块磁盘的重要信息，主要有两个：</p>\n<p>1.主引导分区：可以安装引导加载程序的地方，有446bytes</p>\n<p>2.分区表：记录整块音盘的分区状况，有64bytes</p>\n<h2 id=\"开机流程\"><a href=\"#开机流程\" class=\"headerlink\" title=\"开机流程\"></a>开机流程</h2><p>简单梳理一下开机流程：</p>\n<p>计算机开机后，会主动执行BIOS程序，BIOS是写入到主板上面的一个软件程序。接下来BIOS会去分析计算机中有哪些存储设备，然后依据用户的设置获取可以开机的硬盘（比如我们设置从usb启动），<br>然后到读取该硬盘中的第一个扇区MBR位置。MBR中放置着基本的引导加载程序，接下来就是MBR内的引导加载程序加载内核文件。这个引导加载程序是操作系统在安装时提供的。</p>\n<h2 id=\"磁盘分区表\"><a href=\"#磁盘分区表\" class=\"headerlink\" title=\"磁盘分区表\"></a>磁盘分区表</h2><p>分区不难理解，在windows中，就意味着C，D，E等不同的盘，其实这些c盘，d盘往往都是属于同一块磁盘，将同一块磁盘划分开来，这就是分区。那为什么要分区呢？</p>\n<p>1.数据安全</p>\n<p>很好理解。比如我们在重装win操作系统的时候，往往只需要重装c盘即可，d盘等其他分区里的数据并不受重装系统的影响。</p>\n<p>2.性能</p>\n<p>将磁盘分区后，提高了数据读取的速度。我们在寻找某个分区的数据时，只需要扫描该分区对应磁盘的位置即可，并不需要全盘扫描。</p>\n<p>那么，到底是如何分区呢？</p>\n<img src=\"/2017/03/04/linux分区/zhumian.jpg\" alt=\"柱面\" title=\"柱面\">\n<p>上图中，不同颜色的柱面范围就代表了不同的分区。分区利用了柱面号码的方式来处理。在分区表所在的64bytes中，总共分为四组记录，每组记录该分区的起始与结束柱面号码。</p>\n<p>我们将上图中从圆心到周长中间切出一条长方形来看：</p>\n<img src=\"/2017/03/04/linux分区/fen.png\" alt=\"分区\" title=\"分区\">\n<p>上图假设硬盘有400个柱面，分成四个分区。所谓的分区其实就是针对分区表进行设置而已。分区表最多可以容纳四个分区(只能记录四条数据)，这四个分区被称为主分区或者扩展分区。<br>系统要写磁盘时，首先会参考磁盘分区表，然后才对某个分区的数据进行处理。</p>\n<p>假设这个磁盘在linux中的设备文件名为/dev/hda，那么这四个分区的文件名分别为：</p>\n<p>p1:/dev/hda1  p2:/dev/hda2  p3:/dev/hda3  p4:/dev/hda4</p>\n<p>那么如何可以分得更多的分区呢？装过操作系统的人都知道分区不仅仅可以分四个，我们可以有c,d,e,f,g等等多个磁盘的划分。这都是通过扩展分区来做到的。</p>\n<p>扩展分区的原理就是利用额外的扇区来记录更多的分区信息，从而继续分出更多的分区来。由扩展分区分出来的分区叫做逻辑分区。</p>\n<img src=\"/2017/03/04/linux分区/kuozhan.png\" alt=\"分区\" title=\"分区\">\n<p>上图中，我们将磁盘/dev/sdb 分为了六个分区，分别是</p>\n<p>三个主分区：/dev/sdb1，/dev/sdb2/，/dev/sdb3</p>\n<p>三个逻辑分区：/dev/sdb5，/dev/sdb6/，/dev/sdb7</p>\n<p>为什么没有sdb4呢？那是因为1-4是保留给主分区或者扩展分区使用的。</p>\n<p>注意以下几点：</p>\n<p>主分区和扩展分区最多只能有四个；</p>\n<p>扩展分区只能有一个；</p>\n<p>逻辑分区是有扩展分区再切割而来的；</p>\n<p>扩展分区不能够格式化，所以无法直接使用，必须分为逻辑分区后才可以访问；</p>\n<p>所以说，如果我们想要分出四个以上的分区时，务必要设置一个扩展分区，而不能将四个分区全部划为主分区。</p>\n<h2 id=\"多重引导\"><a href=\"#多重引导\" class=\"headerlink\" title=\"多重引导\"></a>多重引导</h2><p>前面的开机流程中提到，计算机通过读取MBR中的引导加载程序，使用该程序读取内核文件，启动操作系统。如果我们安装了双系统的话，又是如何指定启动哪一个操作系统呢？</p>\n<p>引导加载程序主要有下面几个功能：</p>\n<p>提供不同的开机选项；</p>\n<p>载入内核文件；</p>\n<p>将引导加载功能转交给其他引导加载程序；</p>\n<p>其中第三点，转交给其他引导加载程序，表明我们可以安装不同的引导加载程序到硬盘上面，但是MBR只有一个，也只能安装一个引导加载程序。<br>其他的引导加载程序，可以安装在不同分区的引导扇区上面。</p>\n<img src=\"/2017/03/04/linux分区/yindao.jpg\" alt=\"分区\" title=\"分区\">\n<p>上图中，我们假设分别在两块分区上安装了windows和linux。当MBR中的引导加载程序开始工作时，会提供两个开机选项供我们选择：</p>\n<p>如果我们选择windows，引导加载程序直接加载windows的内核文件开机；</p>\n<p>如果我们选择linux，引导加载程序会把工作交给第二个分区的启动扇区中的引导加载程序。第二个引导加载程序启动后，加载该分区内的内核文件开机。</p>\n<p>那么，为什么安装双系统时，常常要求先安装windows，后安装linux呢？</p>\n<p>那是因为windows在安装的时候，会主动覆盖掉MBR及自己所在分区的启动扇区，并且也没有提供不同的开机选项菜单；而安装linux，可以选择将引导程序安装在MBR或者其他分区的启动扇区，并且也提供了手动设置开机菜单的功能。</p>\n<p>如果我们先安装了linux，再安装windows的时候就会把linux在MBR内的引导加载程序覆盖掉，并且也不会提供linux选项，而是直接进入windows系统。</p>\n<h2 id=\"挂载点\"><a href=\"#挂载点\" class=\"headerlink\" title=\"挂载点\"></a>挂载点</h2><p>安装linux的时候，都会让我们选择挂载点。这个挂载点又与分区有什么关系呢？</p>\n<p>我们知道linux中所有的数据都以文件的形式存在，而文件数据是放在磁盘的分区当中的。所有的文件都是又根目录/衍生而来，我们想要取得/home/yukai/data.txt这个文件时，系统又根目录开始找，<br>找到home，然后找到yukai，最后找到data.txt这个文件。如何由目录树找到磁盘分区中的数据，就是挂载点的意义。</p>\n<p>所谓的挂载就是利用一个目录当作进入点，去访问挂载在这个目录上的分区内的文件，即进入该目录就可以读取该分区，该目录是该分区的入口。我们想要访问一个分区时，必须将该分区挂载到某个目录上面，这个目录就是挂载点。</p>\n<p>所以说在安装linux的时候，要选择分区和挂载点，意思就是把不同的数据放置到不同的分区上的意思，比如我们把 /dev/sda1的挂载点设置为/home，就意味着/home下所有的数据都存放在/dev/sda1这个分区上面。</p>\n"},{"layout":"post","title":"Markdown","date":"2016-03-03T14:10:55.000Z","_content":"\n>[Markdown][markdown-com] 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。\n\n# 常用语法\n \n makedown 语法  \n\n---\n\n## 代码\n\n\\`\\`\\`\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\\`\\`\\`\n\nUse the \\`printf()` function.\n\n---\n\n\n## 标题\n\n\\# 标题1\n\n\\## 标题2\n\n\\### 标题3\n\n\\#### 标题4\n\n\\##### 标题5\n\n\\###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n\n2. 有序列表2\n\n\n\\- 无序列表1\n\n\\- 无序列表2\n\n\\* 无序列表3\n\n\\+ 无序列表4\n\n---\n\n## 链接\n\n\\[谷歌](http://www.google.com)\n\n这是一个 \\[例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 \\[例子] \\[id] 参考链接.\n\n\\[id]: http://google.com/ \"google\"\n\n\n自动链接\n\n```\n<http://example.com/>\n```\n\n---\n\n## 图片\n\n行内链接：\n\\!\\[](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n\\!\\[img]\n\n\\[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n```\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n```\n---\n\n## 引用\n\n\\> 引用\n\n\\>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n\\*这里是斜体\\*\n\n\\*\\*这里是粗体\\*\\*\n\n\\*\\*\\*这里是粗斜体\\*\\*\\*\n\n---\n\n## 表格\n\ndog \\| bird \\| cat\n\n----\\|------\\|----\n\nfoo \\| foo  \\| foo\n\nbar \\| bar  \\| bar\n\nbaz \\| baz  \\| baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\\\   反斜线\n  \n   \\\\`   反引号\n   \n   \\\\*   星号\n   \n   \\\\_   底线\n   \n   \\\\{}  花括号\n   \n   \\\\[]  方括号\n   \n   \\\\()  括弧\n   \n   \\\\#   井字号\n   \n   \\\\+   加号\n   \n   \\\\-   减号\n   \n   \\\\.   英文句点\n   \n   \\\\!   惊叹号\n\n---\n\n## 删除线\n\n\\~~删除这里的内容~~\n\n---\n\n\n\n\n# 效果\n\nmakedown 语法  \n---\n\n## 代码\n\n```\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\n```\n\nUse the `printf()` function.\n\n---\n\n\n## 标题\n\n# 标题1\n\n## 标题2\n\n### 标题3\n\n#### 标题4\n\n##### 标题5\n\n###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n2. 有序列表2\n\n\n- 无序列表1\n- 无序列表2\n* 无序列表3\n+ 无序列表4\n\n---\n\n## 链接\n\n[谷歌](http://www.google.com)\n\n这是一个 [例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 [例子] [id] 参考链接.\n[id]: http://google.com/  \"google\"\n\n\n自动链接\n<http://example.com/>\n\n---\n\n## 图片\n\n行内链接：\n![](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n![img]\n\n[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n\n---\n\n## 引用\n\n> 引用\n\n>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n*这里是斜体*\n\n**这里是粗体**\n\n***这里是粗斜体***\n\n---\n\n## 表格\n\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\   反斜线\n  \n   \\`   反引号\n   \n   \\*   星号\n   \n   \\_   底线\n   \n   \\{}  花括号\n   \n   \\[]  方括号\n   \n   \\()  括弧\n   \n   \\#   井字号\n   \n   \\+   加号\n   \n   \\-   减号\n   \n   \\.   英文句点\n   \n   \\!   惊叹号\n\n---\n\n## 删除线\n\n~~删除这里的内容~~\n\n---\n\n## 一些参考\n\n[Markdown 语法说明 (简体中文版)](http://www.markdown.cn/)\n\n[Markdown 维基百科 ](https://zh.wikipedia.org/wiki/Markdown)\n\n---\n\n[markdown-com]:      http://wowubuntu.com/markdown/\n","source":"_posts/markdown.md","raw":"---\nlayout: post\ntitle:  \"Markdown\"\ndate:   2016-03-03 22:10:55\ncategories: 工具\ntags: \n- markdown\n---\n\n>[Markdown][markdown-com] 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。\n\n# 常用语法\n \n makedown 语法  \n\n---\n\n## 代码\n\n\\`\\`\\`\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\\`\\`\\`\n\nUse the \\`printf()` function.\n\n---\n\n\n## 标题\n\n\\# 标题1\n\n\\## 标题2\n\n\\### 标题3\n\n\\#### 标题4\n\n\\##### 标题5\n\n\\###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n\n2. 有序列表2\n\n\n\\- 无序列表1\n\n\\- 无序列表2\n\n\\* 无序列表3\n\n\\+ 无序列表4\n\n---\n\n## 链接\n\n\\[谷歌](http://www.google.com)\n\n这是一个 \\[例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 \\[例子] \\[id] 参考链接.\n\n\\[id]: http://google.com/ \"google\"\n\n\n自动链接\n\n```\n<http://example.com/>\n```\n\n---\n\n## 图片\n\n行内链接：\n\\!\\[](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n\\!\\[img]\n\n\\[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n```\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n```\n---\n\n## 引用\n\n\\> 引用\n\n\\>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n\\*这里是斜体\\*\n\n\\*\\*这里是粗体\\*\\*\n\n\\*\\*\\*这里是粗斜体\\*\\*\\*\n\n---\n\n## 表格\n\ndog \\| bird \\| cat\n\n----\\|------\\|----\n\nfoo \\| foo  \\| foo\n\nbar \\| bar  \\| bar\n\nbaz \\| baz  \\| baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\\\   反斜线\n  \n   \\\\`   反引号\n   \n   \\\\*   星号\n   \n   \\\\_   底线\n   \n   \\\\{}  花括号\n   \n   \\\\[]  方括号\n   \n   \\\\()  括弧\n   \n   \\\\#   井字号\n   \n   \\\\+   加号\n   \n   \\\\-   减号\n   \n   \\\\.   英文句点\n   \n   \\\\!   惊叹号\n\n---\n\n## 删除线\n\n\\~~删除这里的内容~~\n\n---\n\n\n\n\n# 效果\n\nmakedown 语法  \n---\n\n## 代码\n\n```\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\n```\n\nUse the `printf()` function.\n\n---\n\n\n## 标题\n\n# 标题1\n\n## 标题2\n\n### 标题3\n\n#### 标题4\n\n##### 标题5\n\n###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n2. 有序列表2\n\n\n- 无序列表1\n- 无序列表2\n* 无序列表3\n+ 无序列表4\n\n---\n\n## 链接\n\n[谷歌](http://www.google.com)\n\n这是一个 [例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 [例子] [id] 参考链接.\n[id]: http://google.com/  \"google\"\n\n\n自动链接\n<http://example.com/>\n\n---\n\n## 图片\n\n行内链接：\n![](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n![img]\n\n[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n\n---\n\n## 引用\n\n> 引用\n\n>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n*这里是斜体*\n\n**这里是粗体**\n\n***这里是粗斜体***\n\n---\n\n## 表格\n\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\   反斜线\n  \n   \\`   反引号\n   \n   \\*   星号\n   \n   \\_   底线\n   \n   \\{}  花括号\n   \n   \\[]  方括号\n   \n   \\()  括弧\n   \n   \\#   井字号\n   \n   \\+   加号\n   \n   \\-   减号\n   \n   \\.   英文句点\n   \n   \\!   惊叹号\n\n---\n\n## 删除线\n\n~~删除这里的内容~~\n\n---\n\n## 一些参考\n\n[Markdown 语法说明 (简体中文版)](http://www.markdown.cn/)\n\n[Markdown 维基百科 ](https://zh.wikipedia.org/wiki/Markdown)\n\n---\n\n[markdown-com]:      http://wowubuntu.com/markdown/\n","slug":"markdown","published":1,"updated":"2017-02-19T13:08:11.036Z","comments":1,"photos":[],"link":"","_id":"cj0xuzls3002jvegc2tb9l0ja","content":"<blockquote>\n<p><a href=\"http://wowubuntu.com/markdown/\" target=\"_blank\" rel=\"external\">Markdown</a> 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>\n</blockquote>\n<p> 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。</p>\n<h1 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h1><p> makedown 语法  </p>\n<hr>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>```<br>public void main(String args[]){<br>    System.out.print(“Hello World”);<br>}<br>```</p>\n<p>Use the `printf()` function.</p>\n<hr>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p># 标题1</p>\n<p>## 标题2</p>\n<p>### 标题3</p>\n<p>#### 标题4</p>\n<p>##### 标题5</p>\n<p>###### 标题6</p>\n<hr>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li><p>有序列表1</p>\n</li>\n<li><p>有序列表2</p>\n</li>\n</ol>\n<p>- 无序列表1</p>\n<p>- 无序列表2</p>\n<p>* 无序列表3</p>\n<p>+ 无序列表4</p>\n<hr>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>[谷歌](<a href=\"http://www.google.com\" target=\"_blank\" rel=\"external\">http://www.google.com</a>)</p>\n<p>这是一个 [例子](<a href=\"http://google.com/\" target=\"_blank\" rel=\"external\">http://google.com/</a> “google”) 行内链接.</p>\n<p>这是一个 [例子] [id] 参考链接.</p>\n<p>[id]: <a href=\"http://google.com/\" target=\"_blank\" rel=\"external\">http://google.com/</a> “google”</p>\n<p>自动链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;http://example.com/&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br>![](<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" target=\"_blank\" rel=\"external\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a>)</p>\n<p>参考链接：<br>![img]</p>\n<p>[img]:<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" target=\"_blank\" rel=\"external\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a></p>\n<p>指定宽高：需用html标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;img src=&quot;http://img3.3lian.com/2013/s1/65/d/104.jpg&quot; width=&quot;200&quot; height=&quot;128&quot;  /&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>> 引用</p>\n<p>>&gt; 嵌套引用</p>\n<hr>\n<h2 id=\"粗体-斜体\"><a href=\"#粗体-斜体\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p>*这里是斜体*</p>\n<p>**这里是粗体**</p>\n<p>***这里是粗斜体***</p>\n<hr>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>dog | bird | cat</p>\n<p>—-|——|—-</p>\n<p>foo | foo  | foo</p>\n<p>bar | bar  | bar</p>\n<p>baz | baz  | baz</p>\n<hr>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\\\   反斜线</p>\n<p>   \\`   反引号</p>\n<p>   \\*   星号</p>\n<p>   \\_   底线</p>\n<p>   \\{}  花括号</p>\n<p>   \\[]  方括号</p>\n<p>   \\()  括弧</p>\n<p>   \\#   井字号</p>\n<p>   \\+   加号</p>\n<p>   \\-   减号</p>\n<p>   \\.   英文句点</p>\n<p>   \\!   惊叹号</p>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>~~删除这里的内容~~</p>\n<hr>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><h2 id=\"makedown-语法\"><a href=\"#makedown-语法\" class=\"headerlink\" title=\"makedown 语法  \"></a>makedown 语法  </h2><h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void main(String args[])&#123;</div><div class=\"line\">    System.out.print(&quot;Hello World&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Use the <code>printf()</code> function.</p>\n<hr>\n<h2 id=\"标题-1\"><a href=\"#标题-1\" class=\"headerlink\" title=\"标题\"></a>标题</h2><h1 id=\"标题1\"><a href=\"#标题1\" class=\"headerlink\" title=\"标题1\"></a>标题1</h1><h2 id=\"标题2\"><a href=\"#标题2\" class=\"headerlink\" title=\"标题2\"></a>标题2</h2><h3 id=\"标题3\"><a href=\"#标题3\" class=\"headerlink\" title=\"标题3\"></a>标题3</h3><h4 id=\"标题4\"><a href=\"#标题4\" class=\"headerlink\" title=\"标题4\"></a>标题4</h4><h5 id=\"标题5\"><a href=\"#标题5\" class=\"headerlink\" title=\"标题5\"></a>标题5</h5><h6 id=\"标题6\"><a href=\"#标题6\" class=\"headerlink\" title=\"标题6\"></a>标题6</h6><hr>\n<h2 id=\"列表-1\"><a href=\"#列表-1\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n</ul>\n<ul>\n<li>无序列表3</li>\n</ul>\n<ul>\n<li>无序列表4</li>\n</ul>\n<hr>\n<h2 id=\"链接-1\"><a href=\"#链接-1\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://www.google.com\" target=\"_blank\" rel=\"external\">谷歌</a></p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\" target=\"_blank\" rel=\"external\">例子</a> 行内链接.</p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\" target=\"_blank\" rel=\"external\">例子</a> 参考链接.</p>\n<p>自动链接<br><a href=\"http://example.com/\" target=\"_blank\" rel=\"external\">http://example.com/</a></p>\n<hr>\n<h2 id=\"图片-1\"><a href=\"#图片-1\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"\"></p>\n<p>参考链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"img\"></p>\n<p>指定宽高：需用html标记</p>\n<p><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\">  </p>\n<hr>\n<h2 id=\"引用-1\"><a href=\"#引用-1\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>引用</p>\n<blockquote>\n<p>嵌套引用</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"粗体-斜体-1\"><a href=\"#粗体-斜体-1\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p><em>这里是斜体</em></p>\n<p><strong>这里是粗体</strong></p>\n<p><strong><em>这里是粗斜体</em></strong></p>\n<hr>\n<h2 id=\"表格-1\"><a href=\"#表格-1\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th>dog</th>\n<th>bird</th>\n<th>cat</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>foo</td>\n<td>foo</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>bar</td>\n<td>bar</td>\n</tr>\n<tr>\n<td>baz</td>\n<td>baz</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"转义-1\"><a href=\"#转义-1\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\   反斜线</p>\n<p>   `   反引号</p>\n<p>   *   星号</p>\n<p>   _   底线</p>\n<p>   {}  花括号</p>\n<p>   []  方括号</p>\n<p>   ()  括弧</p>\n<p>   #   井字号</p>\n<p>   +   加号</p>\n<p>   -   减号</p>\n<p>   .   英文句点</p>\n<p>   !   惊叹号</p>\n<hr>\n<h2 id=\"删除线-1\"><a href=\"#删除线-1\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p><del>删除这里的内容</del></p>\n<hr>\n<h2 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h2><p><a href=\"http://www.markdown.cn/\" target=\"_blank\" rel=\"external\">Markdown 语法说明 (简体中文版)</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"external\">Markdown 维基百科 </a></p>\n<hr>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"http://wowubuntu.com/markdown/\">Markdown</a> 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>\n</blockquote>\n<p> 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。</p>\n<h1 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h1><p> makedown 语法  </p>\n<hr>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>```<br>public void main(String args[]){<br>    System.out.print(“Hello World”);<br>}<br>```</p>\n<p>Use the `printf()` function.</p>\n<hr>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p># 标题1</p>\n<p>## 标题2</p>\n<p>### 标题3</p>\n<p>#### 标题4</p>\n<p>##### 标题5</p>\n<p>###### 标题6</p>\n<hr>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li><p>有序列表1</p>\n</li>\n<li><p>有序列表2</p>\n</li>\n</ol>\n<p>- 无序列表1</p>\n<p>- 无序列表2</p>\n<p>* 无序列表3</p>\n<p>+ 无序列表4</p>\n<hr>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>[谷歌](<a href=\"http://www.google.com\">http://www.google.com</a>)</p>\n<p>这是一个 [例子](<a href=\"http://google.com/\">http://google.com/</a> “google”) 行内链接.</p>\n<p>这是一个 [例子] [id] 参考链接.</p>\n<p>[id]: <a href=\"http://google.com/\">http://google.com/</a> “google”</p>\n<p>自动链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;http://example.com/&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br>![](<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a>)</p>\n<p>参考链接：<br>![img]</p>\n<p>[img]:<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a></p>\n<p>指定宽高：需用html标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;img src=&quot;http://img3.3lian.com/2013/s1/65/d/104.jpg&quot; width=&quot;200&quot; height=&quot;128&quot;  /&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>> 引用</p>\n<p>>&gt; 嵌套引用</p>\n<hr>\n<h2 id=\"粗体-斜体\"><a href=\"#粗体-斜体\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p>*这里是斜体*</p>\n<p>**这里是粗体**</p>\n<p>***这里是粗斜体***</p>\n<hr>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>dog | bird | cat</p>\n<p>—-|——|—-</p>\n<p>foo | foo  | foo</p>\n<p>bar | bar  | bar</p>\n<p>baz | baz  | baz</p>\n<hr>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\\\   反斜线</p>\n<p>   \\`   反引号</p>\n<p>   \\*   星号</p>\n<p>   \\_   底线</p>\n<p>   \\{}  花括号</p>\n<p>   \\[]  方括号</p>\n<p>   \\()  括弧</p>\n<p>   \\#   井字号</p>\n<p>   \\+   加号</p>\n<p>   \\-   减号</p>\n<p>   \\.   英文句点</p>\n<p>   \\!   惊叹号</p>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>~~删除这里的内容~~</p>\n<hr>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><h2 id=\"makedown-语法\"><a href=\"#makedown-语法\" class=\"headerlink\" title=\"makedown 语法  \"></a>makedown 语法  </h2><h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void main(String args[])&#123;</div><div class=\"line\">    System.out.print(&quot;Hello World&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Use the <code>printf()</code> function.</p>\n<hr>\n<h2 id=\"标题-1\"><a href=\"#标题-1\" class=\"headerlink\" title=\"标题\"></a>标题</h2><h1 id=\"标题1\"><a href=\"#标题1\" class=\"headerlink\" title=\"标题1\"></a>标题1</h1><h2 id=\"标题2\"><a href=\"#标题2\" class=\"headerlink\" title=\"标题2\"></a>标题2</h2><h3 id=\"标题3\"><a href=\"#标题3\" class=\"headerlink\" title=\"标题3\"></a>标题3</h3><h4 id=\"标题4\"><a href=\"#标题4\" class=\"headerlink\" title=\"标题4\"></a>标题4</h4><h5 id=\"标题5\"><a href=\"#标题5\" class=\"headerlink\" title=\"标题5\"></a>标题5</h5><h6 id=\"标题6\"><a href=\"#标题6\" class=\"headerlink\" title=\"标题6\"></a>标题6</h6><hr>\n<h2 id=\"列表-1\"><a href=\"#列表-1\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n</ul>\n<ul>\n<li>无序列表3</li>\n</ul>\n<ul>\n<li>无序列表4</li>\n</ul>\n<hr>\n<h2 id=\"链接-1\"><a href=\"#链接-1\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://www.google.com\">谷歌</a></p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\">例子</a> 行内链接.</p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\">例子</a> 参考链接.</p>\n<p>自动链接<br><a href=\"http://example.com/\">http://example.com/</a></p>\n<hr>\n<h2 id=\"图片-1\"><a href=\"#图片-1\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"\"></p>\n<p>参考链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"img\"></p>\n<p>指定宽高：需用html标记</p>\n<p><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  </p>\n<hr>\n<h2 id=\"引用-1\"><a href=\"#引用-1\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>引用</p>\n<blockquote>\n<p>嵌套引用</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"粗体-斜体-1\"><a href=\"#粗体-斜体-1\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p><em>这里是斜体</em></p>\n<p><strong>这里是粗体</strong></p>\n<p><strong><em>这里是粗斜体</em></strong></p>\n<hr>\n<h2 id=\"表格-1\"><a href=\"#表格-1\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th>dog</th>\n<th>bird</th>\n<th>cat</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>foo</td>\n<td>foo</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>bar</td>\n<td>bar</td>\n</tr>\n<tr>\n<td>baz</td>\n<td>baz</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"转义-1\"><a href=\"#转义-1\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\   反斜线</p>\n<p>   `   反引号</p>\n<p>   *   星号</p>\n<p>   _   底线</p>\n<p>   {}  花括号</p>\n<p>   []  方括号</p>\n<p>   ()  括弧</p>\n<p>   #   井字号</p>\n<p>   +   加号</p>\n<p>   -   减号</p>\n<p>   .   英文句点</p>\n<p>   !   惊叹号</p>\n<hr>\n<h2 id=\"删除线-1\"><a href=\"#删除线-1\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p><del>删除这里的内容</del></p>\n<hr>\n<h2 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h2><p><a href=\"http://www.markdown.cn/\">Markdown 语法说明 (简体中文版)</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\">Markdown 维基百科 </a></p>\n<hr>\n"},{"layout":"post","title":"notify 问题","date":"2015-12-21T04:48:55.000Z","_content":"\n今天遇到了这么个情况：\n有线程若干，我需要他们按顺序执行。\n代码大概长这样：\n\n```\nclass SyncTag {\n\tpublic int threadNO;\n\tpublic SyncTag() {\n\t    threadNO = 0;\n\t}\n}\nclass ThreadA extend Thread{\n\tSyncTag syncTag;\n\tint scriptNO;\n\tThreadA(SyncTag syncTag,int scriptNO){\n\t\t\tthis.syncTag=syncTag;\n\t\t\tthis.scriptNO=scriptNO;\n\t}\n\tpublic void Run(){\n\t\t\tsynchronized (syncTag) {\n                if (syncTag.threadNO != scriptNO) {\n                        try {\n                                syncTag.wait();\n                        } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                        }\n                }\n                dosomething();\n                syncTag.threadNO++;\n                syncTag.notifyAll();\n\t\t\t}\n\t}\n}\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t    SyncTag syncTag=new SyncTag();\n\t\t\tfor(int i=0;i<10;++i){\n\t\t\t\tThreadA t=new ThreadA(syncTag,i);\n\t\t\t\tt.start();\n\t\t\t}\n\t}\n}\n```\n\n结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。\n研究一番，发现是 notify 与notifyAll 在捣鬼。\n当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。\n其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。\n\t\t \n当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，\n剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，\n没抢到的老实等着。\n\t\t \n这就是notify 与 notifyAll两者的区别.\n\t\t \n那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。\n原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合\nsyncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，\n如果不符合，就继续wait.符合则执行。\n很简单，将 \n\n```java\nif (syncTag.threadNO != scriptNO) {\n        try {\n                syncTag.wait();\n            } catch (InterruptedException e) {\n                                    e.printStackTrace();\n            }\n}\n```\n\n这部分代码 改为： \n\n```java\nwhile (syncTag.threadNO != scriptNO) {\n\t\ttry {\n\t\t\t\tsyncTag.wait();\n\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n这个问题就解决了。\n\n所以，应该记住这样一个原则：**永远在循环（loop）里调用 wait 和 notify，不是在 If 语句**。\n\t \n## **延伸**：\n假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：\n设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO\n这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们\n中的一个。于是陷入死锁，无尽的等待。\n\t\t \n所以，具体使用notify还是notifyAll 就得具体情况具体分析了。","source":"_posts/notify问题.md","raw":"---\nlayout: post\ntitle:  \"notify 问题\"\ndate:   2015-12-21 12:48:55\ncategories: 编程\ntags:\n- java\n- 多线程 \n---\n\n今天遇到了这么个情况：\n有线程若干，我需要他们按顺序执行。\n代码大概长这样：\n\n```\nclass SyncTag {\n\tpublic int threadNO;\n\tpublic SyncTag() {\n\t    threadNO = 0;\n\t}\n}\nclass ThreadA extend Thread{\n\tSyncTag syncTag;\n\tint scriptNO;\n\tThreadA(SyncTag syncTag,int scriptNO){\n\t\t\tthis.syncTag=syncTag;\n\t\t\tthis.scriptNO=scriptNO;\n\t}\n\tpublic void Run(){\n\t\t\tsynchronized (syncTag) {\n                if (syncTag.threadNO != scriptNO) {\n                        try {\n                                syncTag.wait();\n                        } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                        }\n                }\n                dosomething();\n                syncTag.threadNO++;\n                syncTag.notifyAll();\n\t\t\t}\n\t}\n}\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t    SyncTag syncTag=new SyncTag();\n\t\t\tfor(int i=0;i<10;++i){\n\t\t\t\tThreadA t=new ThreadA(syncTag,i);\n\t\t\t\tt.start();\n\t\t\t}\n\t}\n}\n```\n\n结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。\n研究一番，发现是 notify 与notifyAll 在捣鬼。\n当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。\n其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。\n\t\t \n当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，\n剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，\n没抢到的老实等着。\n\t\t \n这就是notify 与 notifyAll两者的区别.\n\t\t \n那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。\n原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合\nsyncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，\n如果不符合，就继续wait.符合则执行。\n很简单，将 \n\n```java\nif (syncTag.threadNO != scriptNO) {\n        try {\n                syncTag.wait();\n            } catch (InterruptedException e) {\n                                    e.printStackTrace();\n            }\n}\n```\n\n这部分代码 改为： \n\n```java\nwhile (syncTag.threadNO != scriptNO) {\n\t\ttry {\n\t\t\t\tsyncTag.wait();\n\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n这个问题就解决了。\n\n所以，应该记住这样一个原则：**永远在循环（loop）里调用 wait 和 notify，不是在 If 语句**。\n\t \n## **延伸**：\n假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：\n设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO\n这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们\n中的一个。于是陷入死锁，无尽的等待。\n\t\t \n所以，具体使用notify还是notifyAll 就得具体情况具体分析了。","slug":"notify问题","published":1,"updated":"2017-02-19T13:08:11.036Z","comments":1,"photos":[],"link":"","_id":"cj0xuzls5002nvegc0b464giz","content":"<p>今天遇到了这么个情况：<br>有线程若干，我需要他们按顺序执行。<br>代码大概长这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SyncTag &#123;</div><div class=\"line\">\tpublic int threadNO;</div><div class=\"line\">\tpublic SyncTag() &#123;</div><div class=\"line\">\t    threadNO = 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class ThreadA extend Thread&#123;</div><div class=\"line\">\tSyncTag syncTag;</div><div class=\"line\">\tint scriptNO;</div><div class=\"line\">\tThreadA(SyncTag syncTag,int scriptNO)&#123;</div><div class=\"line\">\t\t\tthis.syncTag=syncTag;</div><div class=\"line\">\t\t\tthis.scriptNO=scriptNO;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void Run()&#123;</div><div class=\"line\">\t\t\tsynchronized (syncTag) &#123;</div><div class=\"line\">                if (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">                        try &#123;</div><div class=\"line\">                                syncTag.wait();</div><div class=\"line\">                        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                dosomething();</div><div class=\"line\">                syncTag.threadNO++;</div><div class=\"line\">                syncTag.notifyAll();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">public class Test&#123;</div><div class=\"line\">\tpublic static void main(String args[])&#123;</div><div class=\"line\">\t\t    SyncTag syncTag=new SyncTag();</div><div class=\"line\">\t\t\tfor(int i=0;i&lt;10;++i)&#123;</div><div class=\"line\">\t\t\t\tThreadA t=new ThreadA(syncTag,i);</div><div class=\"line\">\t\t\t\tt.start();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。<br>研究一番，发现是 notify 与notifyAll 在捣鬼。<br>当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。<br>其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。</p>\n<p>当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，<br>剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，<br>没抢到的老实等着。</p>\n<p>这就是notify 与 notifyAll两者的区别.</p>\n<p>那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。<br>原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合<br>syncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，<br>如果不符合，就继续wait.符合则执行。<br>很简单，将 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                syncTag.wait();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这部分代码 改为： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tsyncTag.wait();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个问题就解决了。</p>\n<p>所以，应该记住这样一个原则：<strong>永远在循环（loop）里调用 wait 和 notify，不是在 If 语句</strong>。</p>\n<h2 id=\"延伸：\"><a href=\"#延伸：\" class=\"headerlink\" title=\"延伸：\"></a><strong>延伸</strong>：</h2><p>假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：<br>设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO<br>这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们<br>中的一个。于是陷入死锁，无尽的等待。</p>\n<p>所以，具体使用notify还是notifyAll 就得具体情况具体分析了。</p>\n","excerpt":"","more":"<p>今天遇到了这么个情况：<br>有线程若干，我需要他们按顺序执行。<br>代码大概长这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SyncTag &#123;</div><div class=\"line\">\tpublic int threadNO;</div><div class=\"line\">\tpublic SyncTag() &#123;</div><div class=\"line\">\t    threadNO = 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class ThreadA extend Thread&#123;</div><div class=\"line\">\tSyncTag syncTag;</div><div class=\"line\">\tint scriptNO;</div><div class=\"line\">\tThreadA(SyncTag syncTag,int scriptNO)&#123;</div><div class=\"line\">\t\t\tthis.syncTag=syncTag;</div><div class=\"line\">\t\t\tthis.scriptNO=scriptNO;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void Run()&#123;</div><div class=\"line\">\t\t\tsynchronized (syncTag) &#123;</div><div class=\"line\">                if (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">                        try &#123;</div><div class=\"line\">                                syncTag.wait();</div><div class=\"line\">                        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                dosomething();</div><div class=\"line\">                syncTag.threadNO++;</div><div class=\"line\">                syncTag.notifyAll();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">public class Test&#123;</div><div class=\"line\">\tpublic static void main(String args[])&#123;</div><div class=\"line\">\t\t    SyncTag syncTag=new SyncTag();</div><div class=\"line\">\t\t\tfor(int i=0;i&lt;10;++i)&#123;</div><div class=\"line\">\t\t\t\tThreadA t=new ThreadA(syncTag,i);</div><div class=\"line\">\t\t\t\tt.start();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。<br>研究一番，发现是 notify 与notifyAll 在捣鬼。<br>当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。<br>其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。</p>\n<p>当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，<br>剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，<br>没抢到的老实等着。</p>\n<p>这就是notify 与 notifyAll两者的区别.</p>\n<p>那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。<br>原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合<br>syncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，<br>如果不符合，就继续wait.符合则执行。<br>很简单，将 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                syncTag.wait();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这部分代码 改为： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tsyncTag.wait();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个问题就解决了。</p>\n<p>所以，应该记住这样一个原则：<strong>永远在循环（loop）里调用 wait 和 notify，不是在 If 语句</strong>。</p>\n<h2 id=\"延伸：\"><a href=\"#延伸：\" class=\"headerlink\" title=\"延伸：\"></a><strong>延伸</strong>：</h2><p>假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：<br>设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO<br>这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们<br>中的一个。于是陷入死锁，无尽的等待。</p>\n<p>所以，具体使用notify还是notifyAll 就得具体情况具体分析了。</p>\n"},{"layout":"post","date":"2016-03-30T04:48:55.000Z","title":"sphinx安装问题","_content":"\n>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python\n 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。\n\n>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是\n Python2，Python3与Python2是不兼容的，在编码问题上报错。\n\n>遂改之，卸载Python3，安装Python2.问题来了。\n\n安装完Python2之后，使用 easy_install sphinx \n指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：\n\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 4-5: ordi al not in range(128)\n\n意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内\n，就会抛出异常（ordinal not in range(128)）。\n\n看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆\n.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。\n\n后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。\n\n首先所有修改的动作都是要创建一个叫 **sitecustomize.py**的文件，为什么要创建这个文件呢，是因为python在启动的时候会\n去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。\n\n修改默认字符编码的代码很简单就2行：\n\n```\n\n# sitecustomize.py                   # this file can be anywhere in your Python path,\n# but it usually goes in ${pythondir}/lib/site-packages/\nimport sys\nsys.setdefaultencoding('utf-8') \n\n```\n\n写完这个文件放哪里呢？\n\nwindows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 \n\nok,现在再次运行 easy_install sphinx ，可以通过安装了！\n\nps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。\n\n**参考**\n\n[解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误](http://wangye.org/blog/archives/629/)\n\n[永久修改python默认的字符编码为utf-8](http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html)       \n","source":"_posts/sphinx安装问题.md","raw":"---\nlayout: post\ndate:   2016-03-30 12:48:55\ntitle: \"sphinx安装问题\"\ncategories: 工具\ntags: \n- python\n- 编码\n---\n\n>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python\n 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。\n\n>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是\n Python2，Python3与Python2是不兼容的，在编码问题上报错。\n\n>遂改之，卸载Python3，安装Python2.问题来了。\n\n安装完Python2之后，使用 easy_install sphinx \n指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：\n\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 4-5: ordi al not in range(128)\n\n意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内\n，就会抛出异常（ordinal not in range(128)）。\n\n看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆\n.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。\n\n后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。\n\n首先所有修改的动作都是要创建一个叫 **sitecustomize.py**的文件，为什么要创建这个文件呢，是因为python在启动的时候会\n去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。\n\n修改默认字符编码的代码很简单就2行：\n\n```\n\n# sitecustomize.py                   # this file can be anywhere in your Python path,\n# but it usually goes in ${pythondir}/lib/site-packages/\nimport sys\nsys.setdefaultencoding('utf-8') \n\n```\n\n写完这个文件放哪里呢？\n\nwindows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 \n\nok,现在再次运行 easy_install sphinx ，可以通过安装了！\n\nps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。\n\n**参考**\n\n[解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误](http://wangye.org/blog/archives/629/)\n\n[永久修改python默认的字符编码为utf-8](http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html)       \n","slug":"sphinx安装问题","published":1,"updated":"2017-02-19T13:08:11.036Z","comments":1,"photos":[],"link":"","_id":"cj0xuzls7002qvegc4d5n338j","content":"<blockquote>\n<p>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python<br> 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。</p>\n<p>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是<br> Python2，Python3与Python2是不兼容的，在编码问题上报错。</p>\n<p>遂改之，卸载Python3，安装Python2.问题来了。</p>\n</blockquote>\n<p>安装完Python2之后，使用 easy_install sphinx<br>指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：</p>\n<p>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 4-5: ordi al not in range(128)</p>\n<p>意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内<br>，就会抛出异常（ordinal not in range(128)）。</p>\n<p>看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆<br>.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。</p>\n<p>后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。</p>\n<p>首先所有修改的动作都是要创建一个叫 <strong>sitecustomize.py</strong>的文件，为什么要创建这个文件呢，是因为python在启动的时候会<br>去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。</p>\n<p>修改默认字符编码的代码很简单就2行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># sitecustomize.py                   # this file can be anywhere in your Python path,</div><div class=\"line\"># but it usually goes in $&#123;pythondir&#125;/lib/site-packages/</div><div class=\"line\">import sys</div><div class=\"line\">sys.setdefaultencoding(&apos;utf-8&apos;)</div></pre></td></tr></table></figure>\n<p>写完这个文件放哪里呢？</p>\n<p>windows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 </p>\n<p>ok,现在再次运行 easy_install sphinx ，可以通过安装了！</p>\n<p>ps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"http://wangye.org/blog/archives/629/\" target=\"_blank\" rel=\"external\">解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html\" target=\"_blank\" rel=\"external\">永久修改python默认的字符编码为utf-8</a>       </p>\n","excerpt":"","more":"<blockquote>\n<p>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python<br> 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。</p>\n<p>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是<br> Python2，Python3与Python2是不兼容的，在编码问题上报错。</p>\n<p>遂改之，卸载Python3，安装Python2.问题来了。</p>\n</blockquote>\n<p>安装完Python2之后，使用 easy_install sphinx<br>指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：</p>\n<p>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 4-5: ordi al not in range(128)</p>\n<p>意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内<br>，就会抛出异常（ordinal not in range(128)）。</p>\n<p>看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆<br>.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。</p>\n<p>后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。</p>\n<p>首先所有修改的动作都是要创建一个叫 <strong>sitecustomize.py</strong>的文件，为什么要创建这个文件呢，是因为python在启动的时候会<br>去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。</p>\n<p>修改默认字符编码的代码很简单就2行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># sitecustomize.py                   # this file can be anywhere in your Python path,</div><div class=\"line\"># but it usually goes in $&#123;pythondir&#125;/lib/site-packages/</div><div class=\"line\">import sys</div><div class=\"line\">sys.setdefaultencoding(&apos;utf-8&apos;)</div></pre></td></tr></table></figure>\n<p>写完这个文件放哪里呢？</p>\n<p>windows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 </p>\n<p>ok,现在再次运行 easy_install sphinx ，可以通过安装了！</p>\n<p>ps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"http://wangye.org/blog/archives/629/\">解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html\">永久修改python默认的字符编码为utf-8</a>       </p>\n"},{"layout":"post","title":"ssh的两种用法","date":"2017-02-23T12:05:03.000Z","_content":"> 工作中在远程主机上进行一些操作时，经常使用ssh进行远程登录。后来使用github时，也会用到ssh。其中涉及到了ssh的两种用法，记录一下~\n\n> 本文主要参考自阮一峰老师的博客：[SSH原理与运用（一）：远程登录](http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)\n\nssh是每台linux机器的标准配置。ssh是一种协议，SSH在计算机之间构建网络连接，确保连接双方身份的真实性，同时，它还保证在此连接上传送的数据到达时不会被人更改，不会被他人窃听。\n\nssh有多种实现，我们一般使用的是openssh，这是一款免费开源的ssh工具。一般在我们使用的linux发行版中，已经预设了这个软件了，所以可以直接使用它。如果是在windows中使用ssh客户端连接远程linux ssh服务，\n我使用一款名为MobaXterm的工具。\n\n## 密码登录\n\n这是我们使用远程linux机器时最一般的登录方式。使用user这个用户登录到主机host:\n\nssh user@host\n\nssh默认端口是22，如果远程主机ssh服务端口不是22的话，可以通过-p参数修改连接端口：\n\nssh -p 8899 user@host\n\n整个的登录过程：\n\n1.远程主机收到客户端的登录请求，把自己的公钥发给用户。\n\n2.客户端使用这个公钥，将登录密码加密后，发送回来。\n\n3.远程主机用自己的私钥，解密登录密码，如果密码正确，就同意客户端登录。\n\n这样的登录方式有一个问题，那就是如果有人截获了客户端的登录请求（比如使用公共WiFi），然后将自己的公钥发给了客户端，就可以冒充远程主机获取客户端的密码了。\nHttps协议是有CA证书中心作公证的，ssh协议并不存在这样的机构，所以就有中间人攻击的风险。\n\n为了应对这种风险，当客户端第一次登陆远程主机时，会有类似的提示：\n\n```\nThe authenticity of host 'test.linux.org (192.168.1.100)' can't be established. \nRSA key fingerprint is 46:cf:06:6a:ad:ba:e2:85:cc:d9:c4:8d:15:bb:f3:ec. \nAre you sure you want to continue connecting (yes/no)?\n```\n意思就是要你核对远程主机的公钥指纹，从而证明他的身份。那么我们如何判断这个公钥指纹是不是远程主机的公钥产生的指纹呢？答案是没有好办法，只能由用户自己想办法核对，比如远程主机在网站上贴出了自己的公钥指纹。\n\n当我们输入yes之后，会出现：\n\n```\nWarning: Permanently added 'test.linux.org,192.168.1.100' (RSA) to the list of known \n```\n表示我们已经认可了该主机。\n\n此时要求我们输入登录用户的密码，密码正确则登录。\n\n当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。\n\n每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。\n\n## 公钥登录\n\n### 步骤\n\nssh还提供了另一种登录方式，就是公钥登录，避免了输入密码的麻烦。\n\n所谓\"公钥登录\"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。\n\n这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：\n\nssh-keygen\n\n运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。\n\n这时再输入下面的命令，将公钥传送到远程主机host上面：\n\nssh-copy-id user@host\n\n然后，打开远程主机/etc/ssh/sshd_config这个文件，检查以下几项：\n\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n\n然后重启ssh服务就可以了：\n\nservice sshd restart\n\n### authorized_keys\n\n远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。\n\n这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：\n\nssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub\n\n这条命令由多个语句组成，依次分解开来看：\n\n1. \"ssh user@host\"，表示登录远程主机；\n\n2. 单引号中的mkdir .ssh && cat >> .ssh/authorized_keys，表示登录后在远程shell上执行的命令：\n\n3. \"mkdir -p .ssh\"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；\n\n4. 'cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。\n\n写入authorized_keys文件后，公钥登录的设置就完成了。\n\n## 参考\n\n[簡易 Telnet 與 SSH 主機設定](http://linux.vbird.org/linux_server/0310telnetssh/0310telnetssh.php)\n\n[SSH原理与运用（一）：远程登录](http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)","source":"_posts/ssh的两种用法.md","raw":"---\nlayout: post\ntitle: ssh的两种用法\ndate: 2017-02-23 20:05:03\ncategories: 编程 \ntags:\n- linux\n---\n> 工作中在远程主机上进行一些操作时，经常使用ssh进行远程登录。后来使用github时，也会用到ssh。其中涉及到了ssh的两种用法，记录一下~\n\n> 本文主要参考自阮一峰老师的博客：[SSH原理与运用（一）：远程登录](http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)\n\nssh是每台linux机器的标准配置。ssh是一种协议，SSH在计算机之间构建网络连接，确保连接双方身份的真实性，同时，它还保证在此连接上传送的数据到达时不会被人更改，不会被他人窃听。\n\nssh有多种实现，我们一般使用的是openssh，这是一款免费开源的ssh工具。一般在我们使用的linux发行版中，已经预设了这个软件了，所以可以直接使用它。如果是在windows中使用ssh客户端连接远程linux ssh服务，\n我使用一款名为MobaXterm的工具。\n\n## 密码登录\n\n这是我们使用远程linux机器时最一般的登录方式。使用user这个用户登录到主机host:\n\nssh user@host\n\nssh默认端口是22，如果远程主机ssh服务端口不是22的话，可以通过-p参数修改连接端口：\n\nssh -p 8899 user@host\n\n整个的登录过程：\n\n1.远程主机收到客户端的登录请求，把自己的公钥发给用户。\n\n2.客户端使用这个公钥，将登录密码加密后，发送回来。\n\n3.远程主机用自己的私钥，解密登录密码，如果密码正确，就同意客户端登录。\n\n这样的登录方式有一个问题，那就是如果有人截获了客户端的登录请求（比如使用公共WiFi），然后将自己的公钥发给了客户端，就可以冒充远程主机获取客户端的密码了。\nHttps协议是有CA证书中心作公证的，ssh协议并不存在这样的机构，所以就有中间人攻击的风险。\n\n为了应对这种风险，当客户端第一次登陆远程主机时，会有类似的提示：\n\n```\nThe authenticity of host 'test.linux.org (192.168.1.100)' can't be established. \nRSA key fingerprint is 46:cf:06:6a:ad:ba:e2:85:cc:d9:c4:8d:15:bb:f3:ec. \nAre you sure you want to continue connecting (yes/no)?\n```\n意思就是要你核对远程主机的公钥指纹，从而证明他的身份。那么我们如何判断这个公钥指纹是不是远程主机的公钥产生的指纹呢？答案是没有好办法，只能由用户自己想办法核对，比如远程主机在网站上贴出了自己的公钥指纹。\n\n当我们输入yes之后，会出现：\n\n```\nWarning: Permanently added 'test.linux.org,192.168.1.100' (RSA) to the list of known \n```\n表示我们已经认可了该主机。\n\n此时要求我们输入登录用户的密码，密码正确则登录。\n\n当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。\n\n每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。\n\n## 公钥登录\n\n### 步骤\n\nssh还提供了另一种登录方式，就是公钥登录，避免了输入密码的麻烦。\n\n所谓\"公钥登录\"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。\n\n这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：\n\nssh-keygen\n\n运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。\n\n这时再输入下面的命令，将公钥传送到远程主机host上面：\n\nssh-copy-id user@host\n\n然后，打开远程主机/etc/ssh/sshd_config这个文件，检查以下几项：\n\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n\n然后重启ssh服务就可以了：\n\nservice sshd restart\n\n### authorized_keys\n\n远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。\n\n这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：\n\nssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub\n\n这条命令由多个语句组成，依次分解开来看：\n\n1. \"ssh user@host\"，表示登录远程主机；\n\n2. 单引号中的mkdir .ssh && cat >> .ssh/authorized_keys，表示登录后在远程shell上执行的命令：\n\n3. \"mkdir -p .ssh\"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；\n\n4. 'cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。\n\n写入authorized_keys文件后，公钥登录的设置就完成了。\n\n## 参考\n\n[簡易 Telnet 與 SSH 主機設定](http://linux.vbird.org/linux_server/0310telnetssh/0310telnetssh.php)\n\n[SSH原理与运用（一）：远程登录](http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)","slug":"ssh的两种用法","published":1,"updated":"2017-02-23T12:34:54.645Z","comments":1,"photos":[],"link":"","_id":"cj0xuzls9002uvegc24uf2znn","content":"<blockquote>\n<p>工作中在远程主机上进行一些操作时，经常使用ssh进行远程登录。后来使用github时，也会用到ssh。其中涉及到了ssh的两种用法，记录一下~</p>\n<p>本文主要参考自阮一峰老师的博客：<a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\" target=\"_blank\" rel=\"external\">SSH原理与运用（一）：远程登录</a></p>\n</blockquote>\n<p>ssh是每台linux机器的标准配置。ssh是一种协议，SSH在计算机之间构建网络连接，确保连接双方身份的真实性，同时，它还保证在此连接上传送的数据到达时不会被人更改，不会被他人窃听。</p>\n<p>ssh有多种实现，我们一般使用的是openssh，这是一款免费开源的ssh工具。一般在我们使用的linux发行版中，已经预设了这个软件了，所以可以直接使用它。如果是在windows中使用ssh客户端连接远程linux ssh服务，<br>我使用一款名为MobaXterm的工具。</p>\n<h2 id=\"密码登录\"><a href=\"#密码登录\" class=\"headerlink\" title=\"密码登录\"></a>密码登录</h2><p>这是我们使用远程linux机器时最一般的登录方式。使用user这个用户登录到主机host:</p>\n<p>ssh user@host</p>\n<p>ssh默认端口是22，如果远程主机ssh服务端口不是22的话，可以通过-p参数修改连接端口：</p>\n<p>ssh -p 8899 user@host</p>\n<p>整个的登录过程：</p>\n<p>1.远程主机收到客户端的登录请求，把自己的公钥发给用户。</p>\n<p>2.客户端使用这个公钥，将登录密码加密后，发送回来。</p>\n<p>3.远程主机用自己的私钥，解密登录密码，如果密码正确，就同意客户端登录。</p>\n<p>这样的登录方式有一个问题，那就是如果有人截获了客户端的登录请求（比如使用公共WiFi），然后将自己的公钥发给了客户端，就可以冒充远程主机获取客户端的密码了。<br>Https协议是有CA证书中心作公证的，ssh协议并不存在这样的机构，所以就有中间人攻击的风险。</p>\n<p>为了应对这种风险，当客户端第一次登陆远程主机时，会有类似的提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">The authenticity of host &apos;test.linux.org (192.168.1.100)&apos; can&apos;t be established. </div><div class=\"line\">RSA key fingerprint is 46:cf:06:6a:ad:ba:e2:85:cc:d9:c4:8d:15:bb:f3:ec. </div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>\n<p>意思就是要你核对远程主机的公钥指纹，从而证明他的身份。那么我们如何判断这个公钥指纹是不是远程主机的公钥产生的指纹呢？答案是没有好办法，只能由用户自己想办法核对，比如远程主机在网站上贴出了自己的公钥指纹。</p>\n<p>当我们输入yes之后，会出现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Warning: Permanently added &apos;test.linux.org,192.168.1.100&apos; (RSA) to the list of known</div></pre></td></tr></table></figure>\n<p>表示我们已经认可了该主机。</p>\n<p>此时要求我们输入登录用户的密码，密码正确则登录。</p>\n<p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>\n<p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>\n<h2 id=\"公钥登录\"><a href=\"#公钥登录\" class=\"headerlink\" title=\"公钥登录\"></a>公钥登录</h2><h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>ssh还提供了另一种登录方式，就是公钥登录，避免了输入密码的麻烦。</p>\n<p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>\n<p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p>\n<p>ssh-keygen</p>\n<p>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。</p>\n<p>这时再输入下面的命令，将公钥传送到远程主机host上面：</p>\n<p>ssh-copy-id user@host</p>\n<p>然后，打开远程主机/etc/ssh/sshd_config这个文件，检查以下几项：</p>\n<p>RSAAuthentication yes<br>PubkeyAuthentication yes<br>AuthorizedKeysFile .ssh/authorized_keys</p>\n<p>然后重启ssh服务就可以了：</p>\n<p>service sshd restart</p>\n<h3 id=\"authorized-keys\"><a href=\"#authorized-keys\" class=\"headerlink\" title=\"authorized_keys\"></a>authorized_keys</h3><p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。</p>\n<p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p>\n<p>ssh user@host ‘mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub</p>\n<p>这条命令由多个语句组成，依次分解开来看：</p>\n<ol>\n<li><p>“ssh user@host”，表示登录远程主机；</p>\n</li>\n<li><p>单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：</p>\n</li>\n<li><p>“mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；</p>\n</li>\n<li><p>‘cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。</p>\n</li>\n</ol>\n<p>写入authorized_keys文件后，公钥登录的设置就完成了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://linux.vbird.org/linux_server/0310telnetssh/0310telnetssh.php\" target=\"_blank\" rel=\"external\">簡易 Telnet 與 SSH 主機設定</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\" target=\"_blank\" rel=\"external\">SSH原理与运用（一）：远程登录</a></p>\n","excerpt":"","more":"<blockquote>\n<p>工作中在远程主机上进行一些操作时，经常使用ssh进行远程登录。后来使用github时，也会用到ssh。其中涉及到了ssh的两种用法，记录一下~</p>\n<p>本文主要参考自阮一峰老师的博客：<a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\">SSH原理与运用（一）：远程登录</a></p>\n</blockquote>\n<p>ssh是每台linux机器的标准配置。ssh是一种协议，SSH在计算机之间构建网络连接，确保连接双方身份的真实性，同时，它还保证在此连接上传送的数据到达时不会被人更改，不会被他人窃听。</p>\n<p>ssh有多种实现，我们一般使用的是openssh，这是一款免费开源的ssh工具。一般在我们使用的linux发行版中，已经预设了这个软件了，所以可以直接使用它。如果是在windows中使用ssh客户端连接远程linux ssh服务，<br>我使用一款名为MobaXterm的工具。</p>\n<h2 id=\"密码登录\"><a href=\"#密码登录\" class=\"headerlink\" title=\"密码登录\"></a>密码登录</h2><p>这是我们使用远程linux机器时最一般的登录方式。使用user这个用户登录到主机host:</p>\n<p>ssh user@host</p>\n<p>ssh默认端口是22，如果远程主机ssh服务端口不是22的话，可以通过-p参数修改连接端口：</p>\n<p>ssh -p 8899 user@host</p>\n<p>整个的登录过程：</p>\n<p>1.远程主机收到客户端的登录请求，把自己的公钥发给用户。</p>\n<p>2.客户端使用这个公钥，将登录密码加密后，发送回来。</p>\n<p>3.远程主机用自己的私钥，解密登录密码，如果密码正确，就同意客户端登录。</p>\n<p>这样的登录方式有一个问题，那就是如果有人截获了客户端的登录请求（比如使用公共WiFi），然后将自己的公钥发给了客户端，就可以冒充远程主机获取客户端的密码了。<br>Https协议是有CA证书中心作公证的，ssh协议并不存在这样的机构，所以就有中间人攻击的风险。</p>\n<p>为了应对这种风险，当客户端第一次登陆远程主机时，会有类似的提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">The authenticity of host &apos;test.linux.org (192.168.1.100)&apos; can&apos;t be established. </div><div class=\"line\">RSA key fingerprint is 46:cf:06:6a:ad:ba:e2:85:cc:d9:c4:8d:15:bb:f3:ec. </div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>\n<p>意思就是要你核对远程主机的公钥指纹，从而证明他的身份。那么我们如何判断这个公钥指纹是不是远程主机的公钥产生的指纹呢？答案是没有好办法，只能由用户自己想办法核对，比如远程主机在网站上贴出了自己的公钥指纹。</p>\n<p>当我们输入yes之后，会出现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Warning: Permanently added &apos;test.linux.org,192.168.1.100&apos; (RSA) to the list of known</div></pre></td></tr></table></figure>\n<p>表示我们已经认可了该主机。</p>\n<p>此时要求我们输入登录用户的密码，密码正确则登录。</p>\n<p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>\n<p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>\n<h2 id=\"公钥登录\"><a href=\"#公钥登录\" class=\"headerlink\" title=\"公钥登录\"></a>公钥登录</h2><h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>ssh还提供了另一种登录方式，就是公钥登录，避免了输入密码的麻烦。</p>\n<p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>\n<p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p>\n<p>ssh-keygen</p>\n<p>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。</p>\n<p>这时再输入下面的命令，将公钥传送到远程主机host上面：</p>\n<p>ssh-copy-id user@host</p>\n<p>然后，打开远程主机/etc/ssh/sshd_config这个文件，检查以下几项：</p>\n<p>RSAAuthentication yes<br>PubkeyAuthentication yes<br>AuthorizedKeysFile .ssh/authorized_keys</p>\n<p>然后重启ssh服务就可以了：</p>\n<p>service sshd restart</p>\n<h3 id=\"authorized-keys\"><a href=\"#authorized-keys\" class=\"headerlink\" title=\"authorized_keys\"></a>authorized_keys</h3><p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。</p>\n<p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p>\n<p>ssh user@host ‘mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub</p>\n<p>这条命令由多个语句组成，依次分解开来看：</p>\n<ol>\n<li><p>“ssh user@host”，表示登录远程主机；</p>\n</li>\n<li><p>单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：</p>\n</li>\n<li><p>“mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；</p>\n</li>\n<li><p>‘cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。</p>\n</li>\n</ol>\n<p>写入authorized_keys文件后，公钥登录的设置就完成了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://linux.vbird.org/linux_server/0310telnetssh/0310telnetssh.php\">簡易 Telnet 與 SSH 主機設定</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\">SSH原理与运用（一）：远程登录</a></p>\n"},{"layout":"post","title":"ssl使用总结","date":"2016-09-25T02:09:10.000Z","_content":"\n>这次维护的web服务器要求使用Https双向认证，了解了一下如何在客户端和服务器之间进行ssl的配置，在此记录。另外，这篇日志主要记录如何使用，并不深入底层原理。\n\n## 简单认识ssl和证书\n\n在理解这部分内容之前，建议先看看前面对的一篇总结：[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)\n\nSSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。\n\nSSL协议提供的服务主要有：\n\n1、认证用户和服务器，确保数据发送到正确的客户机和服务器；\n\n2、加密数据以防止数据中途被窃取；\n\n3、维护数据的完整性，确保数据在传输过程中不被改变。\n\n其实，ssl就是一种协议。我们知道Http协议是明文传输的，安全性不高。Https就是在Http基础之上加一层ssl协议，来达到加密通信的目的。具体的ssl握手过程，可以参考[百度百科](http://baike.baidu.com/view/14121.htm#6)\n\n附上一张图方便理解：\n\n{% asset_img sslprocess.jpg sslprocess %}\n\n图片来自网络\n\n可以看到ssl握手过程中服务器向客户端发送了自己的证书。这个证书是加密过程的重要内容。在前面的[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)这篇博客中，在关于数字证书的一节，我们知道了数字证书可以证明服务器的身份，服务器证书中包含了服务器的公钥，用于之后的通信。\n\n那么，简单了解下证书的工作原理。\n\n首先看一下证书中有哪些内容：\n\n{% asset_img zhifubao.png 支付宝证书 %}\n\n{% asset_img zhufubao1.png 支付宝证书 %}\n\n{% asset_img zhufubao2.png 支付宝证书 %}\n\n上面是我从谷chorme浏览器中截取的支付宝所使用证书的信息截图。\n\n可以看到，里面有颁发者和使用者。颁发者就是颁发此证书的CA(证书颁发机构),使用者就是与我们通信的服务器，也就是该证书的持有者。证书中还包含了我们上面提到的公钥。\n\n我们知道，证书能够证明服务器的身份，那么他是如何证明的呢？我们以浏览器为例：\n\n首先，浏览器(客户端)接收到服务器发来的证书A之后，会去验证这个证书A是否被篡改或者是伪造的。浏览器首先会去操作系统中内置根证书库中搜索A的颁发者的证书。关于这一点要解释一下，数字证书的颁发机构也有自己的证书，这个证书就是根证书，这个根证书在我的系统刚安装好时，就被微软等公司默认安装在操作系统当中了。\n\n如果在操作系统中找到了服务器证书中的颁发者的证书Root，那么继续下一步，否则，就知道这个服务器证书的颁发者是个不受信任的CA发布的，此时，浏览器会给出警告。若我们选择相信这个CA并继续，则继续下一步。\n\n接下来，浏览器从Root中得到Root的公钥，然后用该公钥对A中的指纹算法和指纹进行解密。注意，为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。\n\n那么什么是指纹算法和指纹呢？这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。\n\n此时就可以判断该证书是否是仿冒或者经过伪造篡改的。如没有，则证明这个服务器是可信任的。接下来就可以使用该服务器提供的公钥来进行通信了。\n\n通过上面的分析我们知道了，ssl协议中，首先通过证书来证明服务器的身份，然后取出证书中的公钥，接下来就可以按照[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)这篇博客中说到的通信方式通信了。这大概上就是ssl的原理，当然实际中ssl的细节还是要复杂很多。\n\n了解了ssl的基本原理，对我们实现服务器的https通信有很大的帮助。\n\n## Https 单向认证\n\n单向认证就是服务器必须向客户端发送自己的证书来证明自己的身份，然后进行加密通信。现在服务器的基础框架是springboot，演示如何配置服务器和客户端：\n\n服务器：\n\n打开springboot的配置文件application.properties:\n\nserver.ssl.key-store=server.keystore\n\nserver.ssl.key-store-password=123456\n\nserver.ssl.keyStoreType=JKS\n\nserver.ssl.keyAlias:server\n\n先解释一下上面几个配置：\n\n.keystore: keystore文件中存储了密钥和证书。密钥包括私钥和公钥，而证书中只包含公钥。这个证书就是我们上面所说的证书。注意：密钥和证书是一一对应的。\n\npassword: 生成keystore文件时所填的密码。\n\nkeyStoreType: keystore类型。\n\nkeyAlias: 生成密钥的别名。\n\nkeysotre文件是怎么生成的呢？使用jdk自带的工具：keytool。生成keystore文件的命令如下：\n\n`keytool -genkey -alias server -keyalg RSA -validity 365 -keystore server.keystore`\n\n其中：-alias 指定生成密钥的别名，-keystore 指定生成的keystore文件的位置和名称。其他的参数的含义可以通过keytool -help来查找。\n\n一个keystore文件中可以存储多个证书和证书对应的密钥，这些证书和其对应的密钥通过唯一的别名alias来指定，也就是说，通过alias可以导出证书。但是要注意，无法通过keytool导出私钥。\n\n看一下如何从keystore文件中导出证书：\n\n`keytool -export -alias server -keystore server.keystore -file serverCA.crt`\n\n-alias指定了要导出的证书文件，-file 指定了要导出的证书文件的位置和名称。\n\n了解了上面的几个配置，再结合之前对ssl原理的总结，不难知道：\n\n我们指定的别名(server.ssl.keyAlias:server)之后,服务器通过该别名从keystore文件中获得对应的证书，并将其发送给客户端，同时使用keystore中alias对应的私钥(keytool虽然导不出私钥，但可以通过代码等方式获得)可以对与客户端通信的内容进行加密和解密。这便是keystore文件的作用：存储证书和私钥。\n\n服务器端的配置完成了。现在有一个问题，虽然服务器可以发送证书到客户端了，但是客户端并不会信任我们这个证书。如果这个时候通过浏览器以https的方式访问服务器，浏览器会提醒你，此连接不受信任。那是因为虽然服务器将证书发送到了浏览器(客户端)，但是浏览器并不认为这个证书能够证明服务器的身份。那为什么https访问支付宝等网站没有报这个警告呢？想想上面的内容，浏览器或操作系统内置了颁发给支付宝证书的机构的根证书，通过这个根证书的公钥对支付宝发来的证书进行解密可以证明这个证书确实是由支付宝发过来的，从而证明了服务器的身份。\n\n虽然浏览器并不能验证我们的证书，我们可以手动的把证书添加到浏览器的信任列表中。这个证书就是我们上面通过keytool导出的证书，将这个证书手动添加到浏览器信任列表里面，再次访问服务器就不会有警告啦。(具体的添加方式不再赘述)(从这点上也可以看出自签名证书的不安全性，有可能被假冒和伪造)\n\nso,通过上面的方式我们已经将ssl单向验证配置好了。那么，如果客户端是自己用java写的呢？下面举一个例子，使用HttpsURLConnection实现：\n\n首先生成客户端的信任证书库，用来存放客户端所信任的证书：\n\n`keytool -keystore truststore.jks -alias client -import -trustcacerts -file serverCA.crt`\n\n-file 指定要信任的证书，此例中应该是我们上面导出的证书serverCA.crt\n\n-keystore 指定要生成的信任库路径和名称。\n\n然后生成我们自己的信任证书管理器：\n\n参考了网上的代码：\n\n```java\npublic class MyX509TrustManager implements X509TrustManager {\n\t/*\n\t * The default X509TrustManager returned by SunX509. We'll delegate\n\t * decisions to it, and fall back to the logic in this class if the default\n\t * X509TrustManager doesn't trust it.\n\t */\n\tX509TrustManager sunJSSEX509TrustManager;\n\n\tpublic MyX509TrustManager() throws Exception {\n\t\t// create a \"default\" JSSE X509TrustManager.\n\t\tKeyStore ks = KeyStore.getInstance(\"JKS\");\n\t\t//注意 src/clientTrustCA.jks就是上面生成的信任证书库\n\t\tks.load(new FileInputStream(\"src/clientTrustCA.jks\"), \"123456\".toCharArray());\n\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\", \"SunJSSE\");\n\t\ttmf.init(ks);\n\t\tTrustManager tms[] = tmf.getTrustManagers();\n\t\t/*\n\t\t * Iterate over the returned trustmanagers, look for an instance of\n\t\t * X509TrustManager. If found, use that as our \"default\" trust manager.\n\t\t */\n\t\tfor (int i = 0; i < tms.length; i++) {\n\t\t\tif (tms[i] instanceof X509TrustManager) {\n\t\t\t\tsunJSSEX509TrustManager = (X509TrustManager) tms[i];\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Find some other way to initialize, or else we have to fail the\n\t\t * constructor.\n\t\t */\n\t\tthrow new Exception(\"Couldn't initialize\");\n\t}\n\n\t/*\n\t * Delegate to the default trust manager.\n\t */\n\tpublic void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\ttry {\n\t\t\tsunJSSEX509TrustManager.checkClientTrusted(chain, authType);\n\t\t} catch (CertificateException excep) {\n\t\t\t// do any special handling here, or rethrow exception.\n\t\t}\n\t}\n\n\t/*\n\t * Delegate to the default trust manager.\n\t */\n\tpublic void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\ttry {\n\t\t\tsunJSSEX509TrustManager.checkServerTrusted(chain, authType);\n\t\t} catch (CertificateException excep) {\n\t\t\t/*\n\t\t\t * Possibly pop up a dialog box asking whether to trust the cert\n\t\t\t * chain.\n\t\t\t */\n\t\t}\n\t}\n\n\t/*\n\t * Merely pass this through.\n\t */\n\tpublic X509Certificate[] getAcceptedIssuers() {\n\t\treturn sunJSSEX509TrustManager.getAcceptedIssuers();\n\t}\n}\n```\n接着使用这个管理器：\n\n```java\n TrustManager[] tm = { new MyX509TrustManager() };\n SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n sslContext.init(null, tm, new java.security.SecureRandom());\n // 从上述SSLContext对象中得到SSLSocketFactory对象\n SSLSocketFactory ssf = sslContext.getSocketFactory();\n\n // 创建URL对象\n URL myURL = new URL(url);\n // 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象\n HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();\n httpsConn.setSSLSocketFactory(ssf);\n\n```\n\n接下来就可以使用这个HttpsURLConnection来访问服务器啦。\n\n## Https双向认证\n\n所谓的Https双向认证就是不仅仅客户端要验证浏览器的身份，浏览器也要向服务器证明自己的身份，也就是第一幅图片中的5。\n\n理解了单向认证，双向认证实现起来也就不难了。\n\n首先像我们之前一样使用keytool生成keystore文件client.keystore，这个文件是为客户端使用准备的。\n\n然后通过client.keystore导出证书client.crt。\n\n接着生成信任库文件serverTrust.jks,将client.crt导入其中。\n\n在单向认证中我们给出了客户端单向认证时的java代码，用来下面给出双向认证的代码：\n\n生成读取keystore的类：\n\n```java\npublic class MyKeyManager{\n\t// 相关的 jks 文件及其密码定义\n\t private final static String CERT_STORE=\"src/client.keystore\";\n\t private final static String CERT_STORE_PASSWORD=\"123456\";\n\t \n\t public static KeyManager[] getKeyManagers() throws Exception{\n\t\t // 载入 jks 文件\n\t\t FileInputStream f_certStore=new FileInputStream(CERT_STORE); \n\t\t KeyStore ks=KeyStore.getInstance(\"jks\"); \n\t\t ks.load(f_certStore, CERT_STORE_PASSWORD.toCharArray()); \n\t\t f_certStore.close(); \n\n\t\t // 创建并初始化证书库工厂\n\t\t String alg=KeyManagerFactory.getDefaultAlgorithm(); \n\t\t KeyManagerFactory kmFact=KeyManagerFactory.getInstance(alg); \n\t\t kmFact.init(ks, CERT_STORE_PASSWORD.toCharArray()); \n\n\t\t KeyManager[] kms=kmFact.getKeyManagers(); \n\t\t return kms;\n\t }\n}\n```\n\n像上面单向认证中那样使用它：\n\n```java \n TrustManager[] tm = { new MyX509TrustManager() };\n KeyManager[] km = MyKeyManager.getKeyManagers();\n SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n sslContext.init(km, tm, new java.security.SecureRandom());\n // 从上述SSLContext对象中得到SSLSocketFactory对象\n SSLSocketFactory ssf = sslContext.getSocketFactory();\n\n // 创建URL对象\n URL myURL = new URL(url);\n // 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象\n HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();\n httpsConn.setSSLSocketFactory(ssf);\n```\n\n然后使用HttpsURLConnection就可以使用了。但是此时服务器端还需要配置，因为客户端仅仅是将自己的证书发过去了，服务器应该如何信任它呢？\n\n打开springboot的配置文件application.properties添加以下配置:\n\n#Whether client authentication is wanted (\"want\") or needed (\"need\"). Requires a trust store.\n\nserver.ssl.client-auth=need\n\nserver.ssl.trust-store=serverTrust.jks \n\nserver.ssl.trust-store-password=123456\n\n其中，serverTrust.jks就是刚刚生成的服务器端信任库。\n\n以上步骤全部做完，服务器和客户端就可以愉快的使用Https进行双向认证通信了。\n\n## 关于证书的一些格式\n\n在使用keytool和openssl的时候，会发现有好多种格式让人头晕眼花。不妨参考这篇文章：[那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)](http://www.cnblogs.com/guogangj/p/4118605.html)\n\n我现在也不是理解的十分清楚，故不再赘述。\n\n## 总结\n\n感觉这篇博客没有把自己想要总结的内容全部记录下来，但是现在也不想再写了。服务器实际测试的时候是使用curl这样一个命令行浏览器进行的，使用curl作为客户端进行双向认证的时候也遇到了不少问题，总结了一份配置的[readme](https://github.com/Hikyu/SSL-Configuration/blob/master/ssl%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE.md)，放在github上面，以作记录。readme中的配置方法可能还有一些瑕疵，有些格式转换可能会有冗余，但是整个配置是没有问题的，经过了自己的验证。证书这一块内容感觉还不是理解的特别透彻，尤其是ssl协议的交互和证书格式的一些问题，留作以后学习吧！真的不想看了...\n\n## 参考\n\n[数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html):这篇一定要看，总结的很好！\n\n[浏览器和SSL证书通讯过程](http://www.live-in.org/archives/1302.html)\n\n[Java安全通信：HTTPS与SSL](http://www.cnblogs.com/devinzhang/archive/2012/02/28/2371631.html)\n\n[Java 安全套接字编程以及 keytool 使用最佳实践](http://www.ibm.com/developerworks/cn/java/j-lo-socketkeytool/)\n\n[openssl生成SSL证书的流程](http://blog.csdn.net/liuchunming033/article/details/48470575)\n\n[如何添加自签名SSL证书 自签名SSL证书存风险](https://freessl.wosign.com/911.html)\n\n[keystore提取私钥和证书(重要×××)](http://www.360doc.com/content/11/1226/02/3700464_174996042.shtml)\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/ssl总结.md","raw":"---\nlayout: post\ntitle: ssl使用总结\ndate: 2016-09-25 10:09:10\ncategories: 技术 \ntags: \n- java\n- 加密\n---\n\n>这次维护的web服务器要求使用Https双向认证，了解了一下如何在客户端和服务器之间进行ssl的配置，在此记录。另外，这篇日志主要记录如何使用，并不深入底层原理。\n\n## 简单认识ssl和证书\n\n在理解这部分内容之前，建议先看看前面对的一篇总结：[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)\n\nSSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。\n\nSSL协议提供的服务主要有：\n\n1、认证用户和服务器，确保数据发送到正确的客户机和服务器；\n\n2、加密数据以防止数据中途被窃取；\n\n3、维护数据的完整性，确保数据在传输过程中不被改变。\n\n其实，ssl就是一种协议。我们知道Http协议是明文传输的，安全性不高。Https就是在Http基础之上加一层ssl协议，来达到加密通信的目的。具体的ssl握手过程，可以参考[百度百科](http://baike.baidu.com/view/14121.htm#6)\n\n附上一张图方便理解：\n\n{% asset_img sslprocess.jpg sslprocess %}\n\n图片来自网络\n\n可以看到ssl握手过程中服务器向客户端发送了自己的证书。这个证书是加密过程的重要内容。在前面的[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)这篇博客中，在关于数字证书的一节，我们知道了数字证书可以证明服务器的身份，服务器证书中包含了服务器的公钥，用于之后的通信。\n\n那么，简单了解下证书的工作原理。\n\n首先看一下证书中有哪些内容：\n\n{% asset_img zhifubao.png 支付宝证书 %}\n\n{% asset_img zhufubao1.png 支付宝证书 %}\n\n{% asset_img zhufubao2.png 支付宝证书 %}\n\n上面是我从谷chorme浏览器中截取的支付宝所使用证书的信息截图。\n\n可以看到，里面有颁发者和使用者。颁发者就是颁发此证书的CA(证书颁发机构),使用者就是与我们通信的服务器，也就是该证书的持有者。证书中还包含了我们上面提到的公钥。\n\n我们知道，证书能够证明服务器的身份，那么他是如何证明的呢？我们以浏览器为例：\n\n首先，浏览器(客户端)接收到服务器发来的证书A之后，会去验证这个证书A是否被篡改或者是伪造的。浏览器首先会去操作系统中内置根证书库中搜索A的颁发者的证书。关于这一点要解释一下，数字证书的颁发机构也有自己的证书，这个证书就是根证书，这个根证书在我的系统刚安装好时，就被微软等公司默认安装在操作系统当中了。\n\n如果在操作系统中找到了服务器证书中的颁发者的证书Root，那么继续下一步，否则，就知道这个服务器证书的颁发者是个不受信任的CA发布的，此时，浏览器会给出警告。若我们选择相信这个CA并继续，则继续下一步。\n\n接下来，浏览器从Root中得到Root的公钥，然后用该公钥对A中的指纹算法和指纹进行解密。注意，为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。\n\n那么什么是指纹算法和指纹呢？这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。\n\n此时就可以判断该证书是否是仿冒或者经过伪造篡改的。如没有，则证明这个服务器是可信任的。接下来就可以使用该服务器提供的公钥来进行通信了。\n\n通过上面的分析我们知道了，ssl协议中，首先通过证书来证明服务器的身份，然后取出证书中的公钥，接下来就可以按照[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)这篇博客中说到的通信方式通信了。这大概上就是ssl的原理，当然实际中ssl的细节还是要复杂很多。\n\n了解了ssl的基本原理，对我们实现服务器的https通信有很大的帮助。\n\n## Https 单向认证\n\n单向认证就是服务器必须向客户端发送自己的证书来证明自己的身份，然后进行加密通信。现在服务器的基础框架是springboot，演示如何配置服务器和客户端：\n\n服务器：\n\n打开springboot的配置文件application.properties:\n\nserver.ssl.key-store=server.keystore\n\nserver.ssl.key-store-password=123456\n\nserver.ssl.keyStoreType=JKS\n\nserver.ssl.keyAlias:server\n\n先解释一下上面几个配置：\n\n.keystore: keystore文件中存储了密钥和证书。密钥包括私钥和公钥，而证书中只包含公钥。这个证书就是我们上面所说的证书。注意：密钥和证书是一一对应的。\n\npassword: 生成keystore文件时所填的密码。\n\nkeyStoreType: keystore类型。\n\nkeyAlias: 生成密钥的别名。\n\nkeysotre文件是怎么生成的呢？使用jdk自带的工具：keytool。生成keystore文件的命令如下：\n\n`keytool -genkey -alias server -keyalg RSA -validity 365 -keystore server.keystore`\n\n其中：-alias 指定生成密钥的别名，-keystore 指定生成的keystore文件的位置和名称。其他的参数的含义可以通过keytool -help来查找。\n\n一个keystore文件中可以存储多个证书和证书对应的密钥，这些证书和其对应的密钥通过唯一的别名alias来指定，也就是说，通过alias可以导出证书。但是要注意，无法通过keytool导出私钥。\n\n看一下如何从keystore文件中导出证书：\n\n`keytool -export -alias server -keystore server.keystore -file serverCA.crt`\n\n-alias指定了要导出的证书文件，-file 指定了要导出的证书文件的位置和名称。\n\n了解了上面的几个配置，再结合之前对ssl原理的总结，不难知道：\n\n我们指定的别名(server.ssl.keyAlias:server)之后,服务器通过该别名从keystore文件中获得对应的证书，并将其发送给客户端，同时使用keystore中alias对应的私钥(keytool虽然导不出私钥，但可以通过代码等方式获得)可以对与客户端通信的内容进行加密和解密。这便是keystore文件的作用：存储证书和私钥。\n\n服务器端的配置完成了。现在有一个问题，虽然服务器可以发送证书到客户端了，但是客户端并不会信任我们这个证书。如果这个时候通过浏览器以https的方式访问服务器，浏览器会提醒你，此连接不受信任。那是因为虽然服务器将证书发送到了浏览器(客户端)，但是浏览器并不认为这个证书能够证明服务器的身份。那为什么https访问支付宝等网站没有报这个警告呢？想想上面的内容，浏览器或操作系统内置了颁发给支付宝证书的机构的根证书，通过这个根证书的公钥对支付宝发来的证书进行解密可以证明这个证书确实是由支付宝发过来的，从而证明了服务器的身份。\n\n虽然浏览器并不能验证我们的证书，我们可以手动的把证书添加到浏览器的信任列表中。这个证书就是我们上面通过keytool导出的证书，将这个证书手动添加到浏览器信任列表里面，再次访问服务器就不会有警告啦。(具体的添加方式不再赘述)(从这点上也可以看出自签名证书的不安全性，有可能被假冒和伪造)\n\nso,通过上面的方式我们已经将ssl单向验证配置好了。那么，如果客户端是自己用java写的呢？下面举一个例子，使用HttpsURLConnection实现：\n\n首先生成客户端的信任证书库，用来存放客户端所信任的证书：\n\n`keytool -keystore truststore.jks -alias client -import -trustcacerts -file serverCA.crt`\n\n-file 指定要信任的证书，此例中应该是我们上面导出的证书serverCA.crt\n\n-keystore 指定要生成的信任库路径和名称。\n\n然后生成我们自己的信任证书管理器：\n\n参考了网上的代码：\n\n```java\npublic class MyX509TrustManager implements X509TrustManager {\n\t/*\n\t * The default X509TrustManager returned by SunX509. We'll delegate\n\t * decisions to it, and fall back to the logic in this class if the default\n\t * X509TrustManager doesn't trust it.\n\t */\n\tX509TrustManager sunJSSEX509TrustManager;\n\n\tpublic MyX509TrustManager() throws Exception {\n\t\t// create a \"default\" JSSE X509TrustManager.\n\t\tKeyStore ks = KeyStore.getInstance(\"JKS\");\n\t\t//注意 src/clientTrustCA.jks就是上面生成的信任证书库\n\t\tks.load(new FileInputStream(\"src/clientTrustCA.jks\"), \"123456\".toCharArray());\n\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\", \"SunJSSE\");\n\t\ttmf.init(ks);\n\t\tTrustManager tms[] = tmf.getTrustManagers();\n\t\t/*\n\t\t * Iterate over the returned trustmanagers, look for an instance of\n\t\t * X509TrustManager. If found, use that as our \"default\" trust manager.\n\t\t */\n\t\tfor (int i = 0; i < tms.length; i++) {\n\t\t\tif (tms[i] instanceof X509TrustManager) {\n\t\t\t\tsunJSSEX509TrustManager = (X509TrustManager) tms[i];\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Find some other way to initialize, or else we have to fail the\n\t\t * constructor.\n\t\t */\n\t\tthrow new Exception(\"Couldn't initialize\");\n\t}\n\n\t/*\n\t * Delegate to the default trust manager.\n\t */\n\tpublic void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\ttry {\n\t\t\tsunJSSEX509TrustManager.checkClientTrusted(chain, authType);\n\t\t} catch (CertificateException excep) {\n\t\t\t// do any special handling here, or rethrow exception.\n\t\t}\n\t}\n\n\t/*\n\t * Delegate to the default trust manager.\n\t */\n\tpublic void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\ttry {\n\t\t\tsunJSSEX509TrustManager.checkServerTrusted(chain, authType);\n\t\t} catch (CertificateException excep) {\n\t\t\t/*\n\t\t\t * Possibly pop up a dialog box asking whether to trust the cert\n\t\t\t * chain.\n\t\t\t */\n\t\t}\n\t}\n\n\t/*\n\t * Merely pass this through.\n\t */\n\tpublic X509Certificate[] getAcceptedIssuers() {\n\t\treturn sunJSSEX509TrustManager.getAcceptedIssuers();\n\t}\n}\n```\n接着使用这个管理器：\n\n```java\n TrustManager[] tm = { new MyX509TrustManager() };\n SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n sslContext.init(null, tm, new java.security.SecureRandom());\n // 从上述SSLContext对象中得到SSLSocketFactory对象\n SSLSocketFactory ssf = sslContext.getSocketFactory();\n\n // 创建URL对象\n URL myURL = new URL(url);\n // 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象\n HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();\n httpsConn.setSSLSocketFactory(ssf);\n\n```\n\n接下来就可以使用这个HttpsURLConnection来访问服务器啦。\n\n## Https双向认证\n\n所谓的Https双向认证就是不仅仅客户端要验证浏览器的身份，浏览器也要向服务器证明自己的身份，也就是第一幅图片中的5。\n\n理解了单向认证，双向认证实现起来也就不难了。\n\n首先像我们之前一样使用keytool生成keystore文件client.keystore，这个文件是为客户端使用准备的。\n\n然后通过client.keystore导出证书client.crt。\n\n接着生成信任库文件serverTrust.jks,将client.crt导入其中。\n\n在单向认证中我们给出了客户端单向认证时的java代码，用来下面给出双向认证的代码：\n\n生成读取keystore的类：\n\n```java\npublic class MyKeyManager{\n\t// 相关的 jks 文件及其密码定义\n\t private final static String CERT_STORE=\"src/client.keystore\";\n\t private final static String CERT_STORE_PASSWORD=\"123456\";\n\t \n\t public static KeyManager[] getKeyManagers() throws Exception{\n\t\t // 载入 jks 文件\n\t\t FileInputStream f_certStore=new FileInputStream(CERT_STORE); \n\t\t KeyStore ks=KeyStore.getInstance(\"jks\"); \n\t\t ks.load(f_certStore, CERT_STORE_PASSWORD.toCharArray()); \n\t\t f_certStore.close(); \n\n\t\t // 创建并初始化证书库工厂\n\t\t String alg=KeyManagerFactory.getDefaultAlgorithm(); \n\t\t KeyManagerFactory kmFact=KeyManagerFactory.getInstance(alg); \n\t\t kmFact.init(ks, CERT_STORE_PASSWORD.toCharArray()); \n\n\t\t KeyManager[] kms=kmFact.getKeyManagers(); \n\t\t return kms;\n\t }\n}\n```\n\n像上面单向认证中那样使用它：\n\n```java \n TrustManager[] tm = { new MyX509TrustManager() };\n KeyManager[] km = MyKeyManager.getKeyManagers();\n SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n sslContext.init(km, tm, new java.security.SecureRandom());\n // 从上述SSLContext对象中得到SSLSocketFactory对象\n SSLSocketFactory ssf = sslContext.getSocketFactory();\n\n // 创建URL对象\n URL myURL = new URL(url);\n // 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象\n HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();\n httpsConn.setSSLSocketFactory(ssf);\n```\n\n然后使用HttpsURLConnection就可以使用了。但是此时服务器端还需要配置，因为客户端仅仅是将自己的证书发过去了，服务器应该如何信任它呢？\n\n打开springboot的配置文件application.properties添加以下配置:\n\n#Whether client authentication is wanted (\"want\") or needed (\"need\"). Requires a trust store.\n\nserver.ssl.client-auth=need\n\nserver.ssl.trust-store=serverTrust.jks \n\nserver.ssl.trust-store-password=123456\n\n其中，serverTrust.jks就是刚刚生成的服务器端信任库。\n\n以上步骤全部做完，服务器和客户端就可以愉快的使用Https进行双向认证通信了。\n\n## 关于证书的一些格式\n\n在使用keytool和openssl的时候，会发现有好多种格式让人头晕眼花。不妨参考这篇文章：[那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)](http://www.cnblogs.com/guogangj/p/4118605.html)\n\n我现在也不是理解的十分清楚，故不再赘述。\n\n## 总结\n\n感觉这篇博客没有把自己想要总结的内容全部记录下来，但是现在也不想再写了。服务器实际测试的时候是使用curl这样一个命令行浏览器进行的，使用curl作为客户端进行双向认证的时候也遇到了不少问题，总结了一份配置的[readme](https://github.com/Hikyu/SSL-Configuration/blob/master/ssl%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE.md)，放在github上面，以作记录。readme中的配置方法可能还有一些瑕疵，有些格式转换可能会有冗余，但是整个配置是没有问题的，经过了自己的验证。证书这一块内容感觉还不是理解的特别透彻，尤其是ssl协议的交互和证书格式的一些问题，留作以后学习吧！真的不想看了...\n\n## 参考\n\n[数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html):这篇一定要看，总结的很好！\n\n[浏览器和SSL证书通讯过程](http://www.live-in.org/archives/1302.html)\n\n[Java安全通信：HTTPS与SSL](http://www.cnblogs.com/devinzhang/archive/2012/02/28/2371631.html)\n\n[Java 安全套接字编程以及 keytool 使用最佳实践](http://www.ibm.com/developerworks/cn/java/j-lo-socketkeytool/)\n\n[openssl生成SSL证书的流程](http://blog.csdn.net/liuchunming033/article/details/48470575)\n\n[如何添加自签名SSL证书 自签名SSL证书存风险](https://freessl.wosign.com/911.html)\n\n[keystore提取私钥和证书(重要×××)](http://www.360doc.com/content/11/1226/02/3700464_174996042.shtml)\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"ssl总结","published":1,"updated":"2017-02-19T13:08:11.036Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlsb002xvegcyd6ark7u","content":"<blockquote>\n<p>这次维护的web服务器要求使用Https双向认证，了解了一下如何在客户端和服务器之间进行ssl的配置，在此记录。另外，这篇日志主要记录如何使用，并不深入底层原理。</p>\n</blockquote>\n<h2 id=\"简单认识ssl和证书\"><a href=\"#简单认识ssl和证书\" class=\"headerlink\" title=\"简单认识ssl和证书\"></a>简单认识ssl和证书</h2><p>在理解这部分内容之前，建议先看看前面对的一篇总结：<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a></p>\n<p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</p>\n<p>SSL协议提供的服务主要有：</p>\n<p>1、认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>\n<p>2、加密数据以防止数据中途被窃取；</p>\n<p>3、维护数据的完整性，确保数据在传输过程中不被改变。</p>\n<p>其实，ssl就是一种协议。我们知道Http协议是明文传输的，安全性不高。Https就是在Http基础之上加一层ssl协议，来达到加密通信的目的。具体的ssl握手过程，可以参考<a href=\"http://baike.baidu.com/view/14121.htm#6\" target=\"_blank\" rel=\"external\">百度百科</a></p>\n<p>附上一张图方便理解：</p>\n<img src=\"/2016/09/25/ssl总结/sslprocess.jpg\" alt=\"sslprocess\" title=\"sslprocess\">\n<p>图片来自网络</p>\n<p>可以看到ssl握手过程中服务器向客户端发送了自己的证书。这个证书是加密过程的重要内容。在前面的<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a>这篇博客中，在关于数字证书的一节，我们知道了数字证书可以证明服务器的身份，服务器证书中包含了服务器的公钥，用于之后的通信。</p>\n<p>那么，简单了解下证书的工作原理。</p>\n<p>首先看一下证书中有哪些内容：</p>\n<img src=\"/2016/09/25/ssl总结/zhifubao.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<img src=\"/2016/09/25/ssl总结/zhufubao1.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<img src=\"/2016/09/25/ssl总结/zhufubao2.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<p>上面是我从谷chorme浏览器中截取的支付宝所使用证书的信息截图。</p>\n<p>可以看到，里面有颁发者和使用者。颁发者就是颁发此证书的CA(证书颁发机构),使用者就是与我们通信的服务器，也就是该证书的持有者。证书中还包含了我们上面提到的公钥。</p>\n<p>我们知道，证书能够证明服务器的身份，那么他是如何证明的呢？我们以浏览器为例：</p>\n<p>首先，浏览器(客户端)接收到服务器发来的证书A之后，会去验证这个证书A是否被篡改或者是伪造的。浏览器首先会去操作系统中内置根证书库中搜索A的颁发者的证书。关于这一点要解释一下，数字证书的颁发机构也有自己的证书，这个证书就是根证书，这个根证书在我的系统刚安装好时，就被微软等公司默认安装在操作系统当中了。</p>\n<p>如果在操作系统中找到了服务器证书中的颁发者的证书Root，那么继续下一步，否则，就知道这个服务器证书的颁发者是个不受信任的CA发布的，此时，浏览器会给出警告。若我们选择相信这个CA并继续，则继续下一步。</p>\n<p>接下来，浏览器从Root中得到Root的公钥，然后用该公钥对A中的指纹算法和指纹进行解密。注意，为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。</p>\n<p>那么什么是指纹算法和指纹呢？这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。</p>\n<p>此时就可以判断该证书是否是仿冒或者经过伪造篡改的。如没有，则证明这个服务器是可信任的。接下来就可以使用该服务器提供的公钥来进行通信了。</p>\n<p>通过上面的分析我们知道了，ssl协议中，首先通过证书来证明服务器的身份，然后取出证书中的公钥，接下来就可以按照<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a>这篇博客中说到的通信方式通信了。这大概上就是ssl的原理，当然实际中ssl的细节还是要复杂很多。</p>\n<p>了解了ssl的基本原理，对我们实现服务器的https通信有很大的帮助。</p>\n<h2 id=\"Https-单向认证\"><a href=\"#Https-单向认证\" class=\"headerlink\" title=\"Https 单向认证\"></a>Https 单向认证</h2><p>单向认证就是服务器必须向客户端发送自己的证书来证明自己的身份，然后进行加密通信。现在服务器的基础框架是springboot，演示如何配置服务器和客户端：</p>\n<p>服务器：</p>\n<p>打开springboot的配置文件application.properties:</p>\n<p>server.ssl.key-store=server.keystore</p>\n<p>server.ssl.key-store-password=123456</p>\n<p>server.ssl.keyStoreType=JKS</p>\n<p>server.ssl.keyAlias:server</p>\n<p>先解释一下上面几个配置：</p>\n<p>.keystore: keystore文件中存储了密钥和证书。密钥包括私钥和公钥，而证书中只包含公钥。这个证书就是我们上面所说的证书。注意：密钥和证书是一一对应的。</p>\n<p>password: 生成keystore文件时所填的密码。</p>\n<p>keyStoreType: keystore类型。</p>\n<p>keyAlias: 生成密钥的别名。</p>\n<p>keysotre文件是怎么生成的呢？使用jdk自带的工具：keytool。生成keystore文件的命令如下：</p>\n<p><code>keytool -genkey -alias server -keyalg RSA -validity 365 -keystore server.keystore</code></p>\n<p>其中：-alias 指定生成密钥的别名，-keystore 指定生成的keystore文件的位置和名称。其他的参数的含义可以通过keytool -help来查找。</p>\n<p>一个keystore文件中可以存储多个证书和证书对应的密钥，这些证书和其对应的密钥通过唯一的别名alias来指定，也就是说，通过alias可以导出证书。但是要注意，无法通过keytool导出私钥。</p>\n<p>看一下如何从keystore文件中导出证书：</p>\n<p><code>keytool -export -alias server -keystore server.keystore -file serverCA.crt</code></p>\n<p>-alias指定了要导出的证书文件，-file 指定了要导出的证书文件的位置和名称。</p>\n<p>了解了上面的几个配置，再结合之前对ssl原理的总结，不难知道：</p>\n<p>我们指定的别名(server.ssl.keyAlias:server)之后,服务器通过该别名从keystore文件中获得对应的证书，并将其发送给客户端，同时使用keystore中alias对应的私钥(keytool虽然导不出私钥，但可以通过代码等方式获得)可以对与客户端通信的内容进行加密和解密。这便是keystore文件的作用：存储证书和私钥。</p>\n<p>服务器端的配置完成了。现在有一个问题，虽然服务器可以发送证书到客户端了，但是客户端并不会信任我们这个证书。如果这个时候通过浏览器以https的方式访问服务器，浏览器会提醒你，此连接不受信任。那是因为虽然服务器将证书发送到了浏览器(客户端)，但是浏览器并不认为这个证书能够证明服务器的身份。那为什么https访问支付宝等网站没有报这个警告呢？想想上面的内容，浏览器或操作系统内置了颁发给支付宝证书的机构的根证书，通过这个根证书的公钥对支付宝发来的证书进行解密可以证明这个证书确实是由支付宝发过来的，从而证明了服务器的身份。</p>\n<p>虽然浏览器并不能验证我们的证书，我们可以手动的把证书添加到浏览器的信任列表中。这个证书就是我们上面通过keytool导出的证书，将这个证书手动添加到浏览器信任列表里面，再次访问服务器就不会有警告啦。(具体的添加方式不再赘述)(从这点上也可以看出自签名证书的不安全性，有可能被假冒和伪造)</p>\n<p>so,通过上面的方式我们已经将ssl单向验证配置好了。那么，如果客户端是自己用java写的呢？下面举一个例子，使用HttpsURLConnection实现：</p>\n<p>首先生成客户端的信任证书库，用来存放客户端所信任的证书：</p>\n<p><code>keytool -keystore truststore.jks -alias client -import -trustcacerts -file serverCA.crt</code></p>\n<p>-file 指定要信任的证书，此例中应该是我们上面导出的证书serverCA.crt</p>\n<p>-keystore 指定要生成的信任库路径和名称。</p>\n<p>然后生成我们自己的信任证书管理器：</p>\n<p>参考了网上的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyX509TrustManager</span> <span class=\"keyword\">implements</span> <span class=\"title\">X509TrustManager</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t * The default X509TrustManager returned by SunX509. We'll delegate</div><div class=\"line\">\t * decisions to it, and fall back to the logic in this class if the default</div><div class=\"line\">\t * X509TrustManager doesn't trust it.</div><div class=\"line\">\t */</div><div class=\"line\">\tX509TrustManager sunJSSEX509TrustManager;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyX509TrustManager</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// create a \"default\" JSSE X509TrustManager.</span></div><div class=\"line\">\t\tKeyStore ks = KeyStore.getInstance(<span class=\"string\">\"JKS\"</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//注意 src/clientTrustCA.jks就是上面生成的信任证书库</span></div><div class=\"line\">\t\tks.load(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"src/clientTrustCA.jks\"</span>), <span class=\"string\">\"123456\"</span>.toCharArray());</div><div class=\"line\">\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(<span class=\"string\">\"SunX509\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">\t\ttmf.init(ks);</div><div class=\"line\">\t\tTrustManager tms[] = tmf.getTrustManagers();</div><div class=\"line\">\t\t<span class=\"comment\">/*</span></div><div class=\"line\">\t\t * Iterate over the returned trustmanagers, look for an instance of</div><div class=\"line\">\t\t * X509TrustManager. If found, use that as our \"default\" trust manager.</div><div class=\"line\">\t\t */</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tms.length; i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tms[i] <span class=\"keyword\">instanceof</span> X509TrustManager) &#123;</div><div class=\"line\">\t\t\t\tsunJSSEX509TrustManager = (X509TrustManager) tms[i];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">/*</span></div><div class=\"line\">\t\t * Find some other way to initialize, or else we have to fail the</div><div class=\"line\">\t\t * constructor.</div><div class=\"line\">\t\t */</div><div class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Couldn't initialize\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t * Delegate to the default trust manager.</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkClientTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsunJSSEX509TrustManager.checkClientTrusted(chain, authType);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CertificateException excep) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// do any special handling here, or rethrow exception.</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t * Delegate to the default trust manager.</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkServerTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsunJSSEX509TrustManager.checkServerTrusted(chain, authType);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CertificateException excep) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">/*</span></div><div class=\"line\">\t\t\t * Possibly pop up a dialog box asking whether to trust the cert</div><div class=\"line\">\t\t\t * chain.</div><div class=\"line\">\t\t\t */</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t * Merely pass this through.</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"keyword\">public</span> X509Certificate[] getAcceptedIssuers() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> sunJSSEX509TrustManager.getAcceptedIssuers();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接着使用这个管理器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManager[] tm = &#123; <span class=\"keyword\">new</span> MyX509TrustManager() &#125;;</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(<span class=\"string\">\"SSL\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">sslContext.init(<span class=\"keyword\">null</span>, tm, <span class=\"keyword\">new</span> java.security.SecureRandom());</div><div class=\"line\"><span class=\"comment\">// 从上述SSLContext对象中得到SSLSocketFactory对象</span></div><div class=\"line\">SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建URL对象</span></div><div class=\"line\">URL myURL = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\"><span class=\"comment\">// 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></div><div class=\"line\">HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();</div><div class=\"line\">httpsConn.setSSLSocketFactory(ssf);</div></pre></td></tr></table></figure>\n<p>接下来就可以使用这个HttpsURLConnection来访问服务器啦。</p>\n<h2 id=\"Https双向认证\"><a href=\"#Https双向认证\" class=\"headerlink\" title=\"Https双向认证\"></a>Https双向认证</h2><p>所谓的Https双向认证就是不仅仅客户端要验证浏览器的身份，浏览器也要向服务器证明自己的身份，也就是第一幅图片中的5。</p>\n<p>理解了单向认证，双向认证实现起来也就不难了。</p>\n<p>首先像我们之前一样使用keytool生成keystore文件client.keystore，这个文件是为客户端使用准备的。</p>\n<p>然后通过client.keystore导出证书client.crt。</p>\n<p>接着生成信任库文件serverTrust.jks,将client.crt导入其中。</p>\n<p>在单向认证中我们给出了客户端单向认证时的java代码，用来下面给出双向认证的代码：</p>\n<p>生成读取keystore的类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyKeyManager</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 相关的 jks 文件及其密码定义</span></div><div class=\"line\">\t <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CERT_STORE=<span class=\"string\">\"src/client.keystore\"</span>;</div><div class=\"line\">\t <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CERT_STORE_PASSWORD=<span class=\"string\">\"123456\"</span>;</div><div class=\"line\">\t </div><div class=\"line\">\t <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> KeyManager[] getKeyManagers() <span class=\"keyword\">throws</span> Exception&#123;</div><div class=\"line\">\t\t <span class=\"comment\">// 载入 jks 文件</span></div><div class=\"line\">\t\t FileInputStream f_certStore=<span class=\"keyword\">new</span> FileInputStream(CERT_STORE); </div><div class=\"line\">\t\t KeyStore ks=KeyStore.getInstance(<span class=\"string\">\"jks\"</span>); </div><div class=\"line\">\t\t ks.load(f_certStore, CERT_STORE_PASSWORD.toCharArray()); </div><div class=\"line\">\t\t f_certStore.close(); </div><div class=\"line\"></div><div class=\"line\">\t\t <span class=\"comment\">// 创建并初始化证书库工厂</span></div><div class=\"line\">\t\t String alg=KeyManagerFactory.getDefaultAlgorithm(); </div><div class=\"line\">\t\t KeyManagerFactory kmFact=KeyManagerFactory.getInstance(alg); </div><div class=\"line\">\t\t kmFact.init(ks, CERT_STORE_PASSWORD.toCharArray()); </div><div class=\"line\"></div><div class=\"line\">\t\t KeyManager[] kms=kmFact.getKeyManagers(); </div><div class=\"line\">\t\t <span class=\"keyword\">return</span> kms;</div><div class=\"line\">\t &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面单向认证中那样使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManager[] tm = &#123; <span class=\"keyword\">new</span> MyX509TrustManager() &#125;;</div><div class=\"line\">KeyManager[] km = MyKeyManager.getKeyManagers();</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(<span class=\"string\">\"SSL\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">sslContext.init(km, tm, <span class=\"keyword\">new</span> java.security.SecureRandom());</div><div class=\"line\"><span class=\"comment\">// 从上述SSLContext对象中得到SSLSocketFactory对象</span></div><div class=\"line\">SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建URL对象</span></div><div class=\"line\">URL myURL = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\"><span class=\"comment\">// 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></div><div class=\"line\">HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();</div><div class=\"line\">httpsConn.setSSLSocketFactory(ssf);</div></pre></td></tr></table></figure>\n<p>然后使用HttpsURLConnection就可以使用了。但是此时服务器端还需要配置，因为客户端仅仅是将自己的证书发过去了，服务器应该如何信任它呢？</p>\n<p>打开springboot的配置文件application.properties添加以下配置:</p>\n<p>#Whether client authentication is wanted (“want”) or needed (“need”). Requires a trust store.</p>\n<p>server.ssl.client-auth=need</p>\n<p>server.ssl.trust-store=serverTrust.jks </p>\n<p>server.ssl.trust-store-password=123456</p>\n<p>其中，serverTrust.jks就是刚刚生成的服务器端信任库。</p>\n<p>以上步骤全部做完，服务器和客户端就可以愉快的使用Https进行双向认证通信了。</p>\n<h2 id=\"关于证书的一些格式\"><a href=\"#关于证书的一些格式\" class=\"headerlink\" title=\"关于证书的一些格式\"></a>关于证书的一些格式</h2><p>在使用keytool和openssl的时候，会发现有好多种格式让人头晕眼花。不妨参考这篇文章：<a href=\"http://www.cnblogs.com/guogangj/p/4118605.html\" target=\"_blank\" rel=\"external\">那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)</a></p>\n<p>我现在也不是理解的十分清楚，故不再赘述。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>感觉这篇博客没有把自己想要总结的内容全部记录下来，但是现在也不想再写了。服务器实际测试的时候是使用curl这样一个命令行浏览器进行的，使用curl作为客户端进行双向认证的时候也遇到了不少问题，总结了一份配置的<a href=\"https://github.com/Hikyu/SSL-Configuration/blob/master/ssl%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE.md\" target=\"_blank\" rel=\"external\">readme</a>，放在github上面，以作记录。readme中的配置方法可能还有一些瑕疵，有些格式转换可能会有冗余，但是整个配置是没有问题的，经过了自己的验证。证书这一块内容感觉还不是理解的特别透彻，尤其是ssl协议的交互和证书格式的一些问题，留作以后学习吧！真的不想看了…</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\" target=\"_blank\" rel=\"external\">数字证书原理</a>:这篇一定要看，总结的很好！</p>\n<p><a href=\"http://www.live-in.org/archives/1302.html\" target=\"_blank\" rel=\"external\">浏览器和SSL证书通讯过程</a></p>\n<p><a href=\"http://www.cnblogs.com/devinzhang/archive/2012/02/28/2371631.html\" target=\"_blank\" rel=\"external\">Java安全通信：HTTPS与SSL</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-socketkeytool/\" target=\"_blank\" rel=\"external\">Java 安全套接字编程以及 keytool 使用最佳实践</a></p>\n<p><a href=\"http://blog.csdn.net/liuchunming033/article/details/48470575\" target=\"_blank\" rel=\"external\">openssl生成SSL证书的流程</a></p>\n<p><a href=\"https://freessl.wosign.com/911.html\" target=\"_blank\" rel=\"external\">如何添加自签名SSL证书 自签名SSL证书存风险</a></p>\n<p><a href=\"http://www.360doc.com/content/11/1226/02/3700464_174996042.shtml\" target=\"_blank\" rel=\"external\">keystore提取私钥和证书(重要×××)</a></p>\n","excerpt":"","more":"<blockquote>\n<p>这次维护的web服务器要求使用Https双向认证，了解了一下如何在客户端和服务器之间进行ssl的配置，在此记录。另外，这篇日志主要记录如何使用，并不深入底层原理。</p>\n</blockquote>\n<h2 id=\"简单认识ssl和证书\"><a href=\"#简单认识ssl和证书\" class=\"headerlink\" title=\"简单认识ssl和证书\"></a>简单认识ssl和证书</h2><p>在理解这部分内容之前，建议先看看前面对的一篇总结：<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a></p>\n<p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</p>\n<p>SSL协议提供的服务主要有：</p>\n<p>1、认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>\n<p>2、加密数据以防止数据中途被窃取；</p>\n<p>3、维护数据的完整性，确保数据在传输过程中不被改变。</p>\n<p>其实，ssl就是一种协议。我们知道Http协议是明文传输的，安全性不高。Https就是在Http基础之上加一层ssl协议，来达到加密通信的目的。具体的ssl握手过程，可以参考<a href=\"http://baike.baidu.com/view/14121.htm#6\">百度百科</a></p>\n<p>附上一张图方便理解：</p>\n<img src=\"/2016/09/25/ssl总结/sslprocess.jpg\" alt=\"sslprocess\" title=\"sslprocess\">\n<p>图片来自网络</p>\n<p>可以看到ssl握手过程中服务器向客户端发送了自己的证书。这个证书是加密过程的重要内容。在前面的<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a>这篇博客中，在关于数字证书的一节，我们知道了数字证书可以证明服务器的身份，服务器证书中包含了服务器的公钥，用于之后的通信。</p>\n<p>那么，简单了解下证书的工作原理。</p>\n<p>首先看一下证书中有哪些内容：</p>\n<img src=\"/2016/09/25/ssl总结/zhifubao.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<img src=\"/2016/09/25/ssl总结/zhufubao1.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<img src=\"/2016/09/25/ssl总结/zhufubao2.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<p>上面是我从谷chorme浏览器中截取的支付宝所使用证书的信息截图。</p>\n<p>可以看到，里面有颁发者和使用者。颁发者就是颁发此证书的CA(证书颁发机构),使用者就是与我们通信的服务器，也就是该证书的持有者。证书中还包含了我们上面提到的公钥。</p>\n<p>我们知道，证书能够证明服务器的身份，那么他是如何证明的呢？我们以浏览器为例：</p>\n<p>首先，浏览器(客户端)接收到服务器发来的证书A之后，会去验证这个证书A是否被篡改或者是伪造的。浏览器首先会去操作系统中内置根证书库中搜索A的颁发者的证书。关于这一点要解释一下，数字证书的颁发机构也有自己的证书，这个证书就是根证书，这个根证书在我的系统刚安装好时，就被微软等公司默认安装在操作系统当中了。</p>\n<p>如果在操作系统中找到了服务器证书中的颁发者的证书Root，那么继续下一步，否则，就知道这个服务器证书的颁发者是个不受信任的CA发布的，此时，浏览器会给出警告。若我们选择相信这个CA并继续，则继续下一步。</p>\n<p>接下来，浏览器从Root中得到Root的公钥，然后用该公钥对A中的指纹算法和指纹进行解密。注意，为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。</p>\n<p>那么什么是指纹算法和指纹呢？这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。</p>\n<p>此时就可以判断该证书是否是仿冒或者经过伪造篡改的。如没有，则证明这个服务器是可信任的。接下来就可以使用该服务器提供的公钥来进行通信了。</p>\n<p>通过上面的分析我们知道了，ssl协议中，首先通过证书来证明服务器的身份，然后取出证书中的公钥，接下来就可以按照<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a>这篇博客中说到的通信方式通信了。这大概上就是ssl的原理，当然实际中ssl的细节还是要复杂很多。</p>\n<p>了解了ssl的基本原理，对我们实现服务器的https通信有很大的帮助。</p>\n<h2 id=\"Https-单向认证\"><a href=\"#Https-单向认证\" class=\"headerlink\" title=\"Https 单向认证\"></a>Https 单向认证</h2><p>单向认证就是服务器必须向客户端发送自己的证书来证明自己的身份，然后进行加密通信。现在服务器的基础框架是springboot，演示如何配置服务器和客户端：</p>\n<p>服务器：</p>\n<p>打开springboot的配置文件application.properties:</p>\n<p>server.ssl.key-store=server.keystore</p>\n<p>server.ssl.key-store-password=123456</p>\n<p>server.ssl.keyStoreType=JKS</p>\n<p>server.ssl.keyAlias:server</p>\n<p>先解释一下上面几个配置：</p>\n<p>.keystore: keystore文件中存储了密钥和证书。密钥包括私钥和公钥，而证书中只包含公钥。这个证书就是我们上面所说的证书。注意：密钥和证书是一一对应的。</p>\n<p>password: 生成keystore文件时所填的密码。</p>\n<p>keyStoreType: keystore类型。</p>\n<p>keyAlias: 生成密钥的别名。</p>\n<p>keysotre文件是怎么生成的呢？使用jdk自带的工具：keytool。生成keystore文件的命令如下：</p>\n<p><code>keytool -genkey -alias server -keyalg RSA -validity 365 -keystore server.keystore</code></p>\n<p>其中：-alias 指定生成密钥的别名，-keystore 指定生成的keystore文件的位置和名称。其他的参数的含义可以通过keytool -help来查找。</p>\n<p>一个keystore文件中可以存储多个证书和证书对应的密钥，这些证书和其对应的密钥通过唯一的别名alias来指定，也就是说，通过alias可以导出证书。但是要注意，无法通过keytool导出私钥。</p>\n<p>看一下如何从keystore文件中导出证书：</p>\n<p><code>keytool -export -alias server -keystore server.keystore -file serverCA.crt</code></p>\n<p>-alias指定了要导出的证书文件，-file 指定了要导出的证书文件的位置和名称。</p>\n<p>了解了上面的几个配置，再结合之前对ssl原理的总结，不难知道：</p>\n<p>我们指定的别名(server.ssl.keyAlias:server)之后,服务器通过该别名从keystore文件中获得对应的证书，并将其发送给客户端，同时使用keystore中alias对应的私钥(keytool虽然导不出私钥，但可以通过代码等方式获得)可以对与客户端通信的内容进行加密和解密。这便是keystore文件的作用：存储证书和私钥。</p>\n<p>服务器端的配置完成了。现在有一个问题，虽然服务器可以发送证书到客户端了，但是客户端并不会信任我们这个证书。如果这个时候通过浏览器以https的方式访问服务器，浏览器会提醒你，此连接不受信任。那是因为虽然服务器将证书发送到了浏览器(客户端)，但是浏览器并不认为这个证书能够证明服务器的身份。那为什么https访问支付宝等网站没有报这个警告呢？想想上面的内容，浏览器或操作系统内置了颁发给支付宝证书的机构的根证书，通过这个根证书的公钥对支付宝发来的证书进行解密可以证明这个证书确实是由支付宝发过来的，从而证明了服务器的身份。</p>\n<p>虽然浏览器并不能验证我们的证书，我们可以手动的把证书添加到浏览器的信任列表中。这个证书就是我们上面通过keytool导出的证书，将这个证书手动添加到浏览器信任列表里面，再次访问服务器就不会有警告啦。(具体的添加方式不再赘述)(从这点上也可以看出自签名证书的不安全性，有可能被假冒和伪造)</p>\n<p>so,通过上面的方式我们已经将ssl单向验证配置好了。那么，如果客户端是自己用java写的呢？下面举一个例子，使用HttpsURLConnection实现：</p>\n<p>首先生成客户端的信任证书库，用来存放客户端所信任的证书：</p>\n<p><code>keytool -keystore truststore.jks -alias client -import -trustcacerts -file serverCA.crt</code></p>\n<p>-file 指定要信任的证书，此例中应该是我们上面导出的证书serverCA.crt</p>\n<p>-keystore 指定要生成的信任库路径和名称。</p>\n<p>然后生成我们自己的信任证书管理器：</p>\n<p>参考了网上的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyX509TrustManager</span> <span class=\"keyword\">implements</span> <span class=\"title\">X509TrustManager</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">/*</div><div class=\"line\">\t * The default X509TrustManager returned by SunX509. We'll delegate</div><div class=\"line\">\t * decisions to it, and fall back to the logic in this class if the default</div><div class=\"line\">\t * X509TrustManager doesn't trust it.</div><div class=\"line\">\t */</span></div><div class=\"line\">\tX509TrustManager sunJSSEX509TrustManager;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyX509TrustManager</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// create a \"default\" JSSE X509TrustManager.</span></div><div class=\"line\">\t\tKeyStore ks = KeyStore.getInstance(<span class=\"string\">\"JKS\"</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//注意 src/clientTrustCA.jks就是上面生成的信任证书库</span></div><div class=\"line\">\t\tks.load(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"src/clientTrustCA.jks\"</span>), <span class=\"string\">\"123456\"</span>.toCharArray());</div><div class=\"line\">\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(<span class=\"string\">\"SunX509\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">\t\ttmf.init(ks);</div><div class=\"line\">\t\tTrustManager tms[] = tmf.getTrustManagers();</div><div class=\"line\">\t\t<span class=\"comment\">/*</div><div class=\"line\">\t\t * Iterate over the returned trustmanagers, look for an instance of</div><div class=\"line\">\t\t * X509TrustManager. If found, use that as our \"default\" trust manager.</div><div class=\"line\">\t\t */</span></div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tms.length; i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tms[i] <span class=\"keyword\">instanceof</span> X509TrustManager) &#123;</div><div class=\"line\">\t\t\t\tsunJSSEX509TrustManager = (X509TrustManager) tms[i];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">/*</div><div class=\"line\">\t\t * Find some other way to initialize, or else we have to fail the</div><div class=\"line\">\t\t * constructor.</div><div class=\"line\">\t\t */</span></div><div class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Couldn't initialize\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</div><div class=\"line\">\t * Delegate to the default trust manager.</div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkClientTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsunJSSEX509TrustManager.checkClientTrusted(chain, authType);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CertificateException excep) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// do any special handling here, or rethrow exception.</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</div><div class=\"line\">\t * Delegate to the default trust manager.</div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkServerTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsunJSSEX509TrustManager.checkServerTrusted(chain, authType);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CertificateException excep) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">/*</div><div class=\"line\">\t\t\t * Possibly pop up a dialog box asking whether to trust the cert</div><div class=\"line\">\t\t\t * chain.</div><div class=\"line\">\t\t\t */</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</div><div class=\"line\">\t * Merely pass this through.</div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> X509Certificate[] getAcceptedIssuers() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> sunJSSEX509TrustManager.getAcceptedIssuers();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接着使用这个管理器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManager[] tm = &#123; <span class=\"keyword\">new</span> MyX509TrustManager() &#125;;</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(<span class=\"string\">\"SSL\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">sslContext.init(<span class=\"keyword\">null</span>, tm, <span class=\"keyword\">new</span> java.security.SecureRandom());</div><div class=\"line\"><span class=\"comment\">// 从上述SSLContext对象中得到SSLSocketFactory对象</span></div><div class=\"line\">SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建URL对象</span></div><div class=\"line\">URL myURL = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\"><span class=\"comment\">// 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></div><div class=\"line\">HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();</div><div class=\"line\">httpsConn.setSSLSocketFactory(ssf);</div></pre></td></tr></table></figure>\n<p>接下来就可以使用这个HttpsURLConnection来访问服务器啦。</p>\n<h2 id=\"Https双向认证\"><a href=\"#Https双向认证\" class=\"headerlink\" title=\"Https双向认证\"></a>Https双向认证</h2><p>所谓的Https双向认证就是不仅仅客户端要验证浏览器的身份，浏览器也要向服务器证明自己的身份，也就是第一幅图片中的5。</p>\n<p>理解了单向认证，双向认证实现起来也就不难了。</p>\n<p>首先像我们之前一样使用keytool生成keystore文件client.keystore，这个文件是为客户端使用准备的。</p>\n<p>然后通过client.keystore导出证书client.crt。</p>\n<p>接着生成信任库文件serverTrust.jks,将client.crt导入其中。</p>\n<p>在单向认证中我们给出了客户端单向认证时的java代码，用来下面给出双向认证的代码：</p>\n<p>生成读取keystore的类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyKeyManager</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 相关的 jks 文件及其密码定义</span></div><div class=\"line\">\t <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CERT_STORE=<span class=\"string\">\"src/client.keystore\"</span>;</div><div class=\"line\">\t <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CERT_STORE_PASSWORD=<span class=\"string\">\"123456\"</span>;</div><div class=\"line\">\t </div><div class=\"line\">\t <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> KeyManager[] getKeyManagers() <span class=\"keyword\">throws</span> Exception&#123;</div><div class=\"line\">\t\t <span class=\"comment\">// 载入 jks 文件</span></div><div class=\"line\">\t\t FileInputStream f_certStore=<span class=\"keyword\">new</span> FileInputStream(CERT_STORE); </div><div class=\"line\">\t\t KeyStore ks=KeyStore.getInstance(<span class=\"string\">\"jks\"</span>); </div><div class=\"line\">\t\t ks.load(f_certStore, CERT_STORE_PASSWORD.toCharArray()); </div><div class=\"line\">\t\t f_certStore.close(); </div><div class=\"line\"></div><div class=\"line\">\t\t <span class=\"comment\">// 创建并初始化证书库工厂</span></div><div class=\"line\">\t\t String alg=KeyManagerFactory.getDefaultAlgorithm(); </div><div class=\"line\">\t\t KeyManagerFactory kmFact=KeyManagerFactory.getInstance(alg); </div><div class=\"line\">\t\t kmFact.init(ks, CERT_STORE_PASSWORD.toCharArray()); </div><div class=\"line\"></div><div class=\"line\">\t\t KeyManager[] kms=kmFact.getKeyManagers(); </div><div class=\"line\">\t\t <span class=\"keyword\">return</span> kms;</div><div class=\"line\">\t &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面单向认证中那样使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManager[] tm = &#123; <span class=\"keyword\">new</span> MyX509TrustManager() &#125;;</div><div class=\"line\">KeyManager[] km = MyKeyManager.getKeyManagers();</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(<span class=\"string\">\"SSL\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">sslContext.init(km, tm, <span class=\"keyword\">new</span> java.security.SecureRandom());</div><div class=\"line\"><span class=\"comment\">// 从上述SSLContext对象中得到SSLSocketFactory对象</span></div><div class=\"line\">SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建URL对象</span></div><div class=\"line\">URL myURL = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\"><span class=\"comment\">// 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></div><div class=\"line\">HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();</div><div class=\"line\">httpsConn.setSSLSocketFactory(ssf);</div></pre></td></tr></table></figure>\n<p>然后使用HttpsURLConnection就可以使用了。但是此时服务器端还需要配置，因为客户端仅仅是将自己的证书发过去了，服务器应该如何信任它呢？</p>\n<p>打开springboot的配置文件application.properties添加以下配置:</p>\n<p>#Whether client authentication is wanted (“want”) or needed (“need”). Requires a trust store.</p>\n<p>server.ssl.client-auth=need</p>\n<p>server.ssl.trust-store=serverTrust.jks </p>\n<p>server.ssl.trust-store-password=123456</p>\n<p>其中，serverTrust.jks就是刚刚生成的服务器端信任库。</p>\n<p>以上步骤全部做完，服务器和客户端就可以愉快的使用Https进行双向认证通信了。</p>\n<h2 id=\"关于证书的一些格式\"><a href=\"#关于证书的一些格式\" class=\"headerlink\" title=\"关于证书的一些格式\"></a>关于证书的一些格式</h2><p>在使用keytool和openssl的时候，会发现有好多种格式让人头晕眼花。不妨参考这篇文章：<a href=\"http://www.cnblogs.com/guogangj/p/4118605.html\">那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)</a></p>\n<p>我现在也不是理解的十分清楚，故不再赘述。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>感觉这篇博客没有把自己想要总结的内容全部记录下来，但是现在也不想再写了。服务器实际测试的时候是使用curl这样一个命令行浏览器进行的，使用curl作为客户端进行双向认证的时候也遇到了不少问题，总结了一份配置的<a href=\"https://github.com/Hikyu/SSL-Configuration/blob/master/ssl%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE.md\">readme</a>，放在github上面，以作记录。readme中的配置方法可能还有一些瑕疵，有些格式转换可能会有冗余，但是整个配置是没有问题的，经过了自己的验证。证书这一块内容感觉还不是理解的特别透彻，尤其是ssl协议的交互和证书格式的一些问题，留作以后学习吧！真的不想看了…</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\">数字证书原理</a>:这篇一定要看，总结的很好！</p>\n<p><a href=\"http://www.live-in.org/archives/1302.html\">浏览器和SSL证书通讯过程</a></p>\n<p><a href=\"http://www.cnblogs.com/devinzhang/archive/2012/02/28/2371631.html\">Java安全通信：HTTPS与SSL</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-socketkeytool/\">Java 安全套接字编程以及 keytool 使用最佳实践</a></p>\n<p><a href=\"http://blog.csdn.net/liuchunming033/article/details/48470575\">openssl生成SSL证书的流程</a></p>\n<p><a href=\"https://freessl.wosign.com/911.html\">如何添加自签名SSL证书 自签名SSL证书存风险</a></p>\n<p><a href=\"http://www.360doc.com/content/11/1226/02/3700464_174996042.shtml\">keystore提取私钥和证书(重要×××)</a></p>\n"},{"layout":"post","date":"2016-08-16T07:31:44.000Z","title":"synchronized的用法","comments":1,"_content":"\n>以前的工作过程中，偶尔会遇到synchronized的使用，比如[这篇总结](http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/)。今天来总结一下自己对synchronized的关键字的一些认识。\n\n## 同步锁\n\nsynchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。\n\n每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：\n\n```java\nsynchronized (object) {\n\t//doSomething...\t\t\n}\n```\n\n上面的 '{' '}' 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。\n\n## synchronized修饰代码块\n\n### synchronized同步锁为普通对象\n\n```java\npublic void function(){\n\tsynchronized (object) {\n\t\t//doSomething...\t\t\n\t}\n}\n```\n当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。\n\n下面的例子：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(new Object());\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n运行结果：\n\n```\nThread-0运行中...\nThread-1运行中...\nThread-2运行中...\nThread-3运行中...\nThread-4运行中...\nThread-1结束...\nThread-0结束...\nThread-3结束...\nThread-4结束...\nThread-2结束...\n```\n\n跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tObject object = new Object();\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(object);\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```java\nThread-0运行中...\nThread-0结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。\n\n重点要理解：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**\n\n### synchronized同步锁为类\n\n类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。\n\n将上面的例子修改一下：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-0结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\n```\n这些线程同样实现了同步，因为他们的同步锁是同一个对象--SyncTest类对象。\n\n需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\tSync1 sync1 = new Sync1(new SyncTest());\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t\t\n\t\tsync1.start();\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n\nclass Sync1 extends Thread{\n\tSyncTest syncTest;\n\tpublic Sync1(SyncTest syncTest){\n\t\tthis.syncTest = syncTest;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncTest) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-5运行中...\nThread-0结束...\nThread-5结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。\n\n## synchronized修饰方法\n\nsynchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。\n\n### synchronized修饰普通方法\n\n```java\npublic synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\nsynchronized修饰普通方法中的同步锁就是这个对象本身，即\"this\"。\n\n下面的代码：\n\n```java\nclass Sync extends Thread{\n\tpublic synchronized void syncFunction(){\n\t\tdoSomething();\n\t}\n\t\n\tpublic void syncFunction2(){\n\t\tsynchronized (this) {\n\t\t\tdoSomething();\n\t\t}\n\t}\n\t\n\tprivate void doSomething(){\n\t\t//doSomething...\n\t}\n}\n```\n\n上面syncFunction()与syncFunction2()实现的同步效果是一样的。\n\n当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的\"this\"。\n\n### synchronized修饰静态方法\n\n```java\npublic static synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\n同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。\n\n不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。\n\n## 总结\n\n理解synchronized的关键就在于：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**这个同步锁，可以理解为一个对象。","source":"_posts/synchronized的一些用法.md","raw":"---\nlayout: post\ndate: 2016-08-16 15:31:44\ncategories: 编程\ntitle: synchronized的用法\ntags: \n- 多线程\n- java\ncomments: true\n---\n\n>以前的工作过程中，偶尔会遇到synchronized的使用，比如[这篇总结](http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/)。今天来总结一下自己对synchronized的关键字的一些认识。\n\n## 同步锁\n\nsynchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。\n\n每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：\n\n```java\nsynchronized (object) {\n\t//doSomething...\t\t\n}\n```\n\n上面的 '{' '}' 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。\n\n## synchronized修饰代码块\n\n### synchronized同步锁为普通对象\n\n```java\npublic void function(){\n\tsynchronized (object) {\n\t\t//doSomething...\t\t\n\t}\n}\n```\n当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。\n\n下面的例子：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(new Object());\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n运行结果：\n\n```\nThread-0运行中...\nThread-1运行中...\nThread-2运行中...\nThread-3运行中...\nThread-4运行中...\nThread-1结束...\nThread-0结束...\nThread-3结束...\nThread-4结束...\nThread-2结束...\n```\n\n跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tObject object = new Object();\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(object);\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```java\nThread-0运行中...\nThread-0结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。\n\n重点要理解：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**\n\n### synchronized同步锁为类\n\n类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。\n\n将上面的例子修改一下：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-0结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\n```\n这些线程同样实现了同步，因为他们的同步锁是同一个对象--SyncTest类对象。\n\n需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\tSync1 sync1 = new Sync1(new SyncTest());\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t\t\n\t\tsync1.start();\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n\nclass Sync1 extends Thread{\n\tSyncTest syncTest;\n\tpublic Sync1(SyncTest syncTest){\n\t\tthis.syncTest = syncTest;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncTest) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-5运行中...\nThread-0结束...\nThread-5结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。\n\n## synchronized修饰方法\n\nsynchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。\n\n### synchronized修饰普通方法\n\n```java\npublic synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\nsynchronized修饰普通方法中的同步锁就是这个对象本身，即\"this\"。\n\n下面的代码：\n\n```java\nclass Sync extends Thread{\n\tpublic synchronized void syncFunction(){\n\t\tdoSomething();\n\t}\n\t\n\tpublic void syncFunction2(){\n\t\tsynchronized (this) {\n\t\t\tdoSomething();\n\t\t}\n\t}\n\t\n\tprivate void doSomething(){\n\t\t//doSomething...\n\t}\n}\n```\n\n上面syncFunction()与syncFunction2()实现的同步效果是一样的。\n\n当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的\"this\"。\n\n### synchronized修饰静态方法\n\n```java\npublic static synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\n同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。\n\n不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。\n\n## 总结\n\n理解synchronized的关键就在于：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**这个同步锁，可以理解为一个对象。","slug":"synchronized的一些用法","published":1,"updated":"2017-02-19T13:08:11.038Z","photos":[],"link":"","_id":"cj0xuzlsd0031vegc7hefs16b","content":"<blockquote>\n<p>以前的工作过程中，偶尔会遇到synchronized的使用，比如<a href=\"http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/\">这篇总结</a>。今天来总结一下自己对synchronized的关键字的一些认识。</p>\n</blockquote>\n<h2 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h2><p>synchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。</p>\n<p>每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的 ‘{‘ ‘}’ 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p>\n<h2 id=\"synchronized修饰代码块\"><a href=\"#synchronized修饰代码块\" class=\"headerlink\" title=\"synchronized修饰代码块\"></a>synchronized修饰代码块</h2><h3 id=\"synchronized同步锁为普通对象\"><a href=\"#synchronized同步锁为普通对象\" class=\"headerlink\" title=\"synchronized同步锁为普通对象\"></a>synchronized同步锁为普通对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。</p>\n<p>下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(<span class=\"keyword\">new</span> Object());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\tObject object = <span class=\"keyword\">new</span> Object();</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(object);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-<span class=\"number\">0</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">0</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">4</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">4</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">2</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">2</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">3</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">3</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">1</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">1</span>结束...</div></pre></td></tr></table></figure>\n<p>5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。</p>\n<p>重点要理解：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong></p>\n<h3 id=\"synchronized同步锁为类\"><a href=\"#synchronized同步锁为类\" class=\"headerlink\" title=\"synchronized同步锁为类\"></a>synchronized同步锁为类</h3><p>类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。</p>\n<p>将上面的例子修改一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>这些线程同样实现了同步，因为他们的同步锁是同一个对象–SyncTest类对象。</p>\n<p>需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSync1 sync1 = <span class=\"keyword\">new</span> Sync1(<span class=\"keyword\">new</span> SyncTest());</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsync1.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tSyncTest syncTest;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync1</span><span class=\"params\">(SyncTest syncTest)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncTest = syncTest;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncTest) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-5运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-5结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div></pre></td></tr></table></figure>\n<p>可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。</p>\n<h2 id=\"synchronized修饰方法\"><a href=\"#synchronized修饰方法\" class=\"headerlink\" title=\"synchronized修饰方法\"></a>synchronized修饰方法</h2><p>synchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。</p>\n<h3 id=\"synchronized修饰普通方法\"><a href=\"#synchronized修饰普通方法\" class=\"headerlink\" title=\"synchronized修饰普通方法\"></a>synchronized修饰普通方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>synchronized修饰普通方法中的同步锁就是这个对象本身，即”this”。</p>\n<p>下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tdoSomething();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\tdoSomething();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面syncFunction()与syncFunction2()实现的同步效果是一样的。</p>\n<p>当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的”this”。</p>\n<h3 id=\"synchronized修饰静态方法\"><a href=\"#synchronized修饰静态方法\" class=\"headerlink\" title=\"synchronized修饰静态方法\"></a>synchronized修饰静态方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。</p>\n<p>不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>理解synchronized的关键就在于：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong>这个同步锁，可以理解为一个对象。</p>\n","excerpt":"","more":"<blockquote>\n<p>以前的工作过程中，偶尔会遇到synchronized的使用，比如<a href=\"http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/\">这篇总结</a>。今天来总结一下自己对synchronized的关键字的一些认识。</p>\n</blockquote>\n<h2 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h2><p>synchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。</p>\n<p>每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的 ‘{‘ ‘}’ 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p>\n<h2 id=\"synchronized修饰代码块\"><a href=\"#synchronized修饰代码块\" class=\"headerlink\" title=\"synchronized修饰代码块\"></a>synchronized修饰代码块</h2><h3 id=\"synchronized同步锁为普通对象\"><a href=\"#synchronized同步锁为普通对象\" class=\"headerlink\" title=\"synchronized同步锁为普通对象\"></a>synchronized同步锁为普通对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。</p>\n<p>下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(<span class=\"keyword\">new</span> Object());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\tObject object = <span class=\"keyword\">new</span> Object();</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(object);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-<span class=\"number\">0</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">0</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">4</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">4</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">2</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">2</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">3</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">3</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">1</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">1</span>结束...</div></pre></td></tr></table></figure>\n<p>5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。</p>\n<p>重点要理解：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong></p>\n<h3 id=\"synchronized同步锁为类\"><a href=\"#synchronized同步锁为类\" class=\"headerlink\" title=\"synchronized同步锁为类\"></a>synchronized同步锁为类</h3><p>类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。</p>\n<p>将上面的例子修改一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>这些线程同样实现了同步，因为他们的同步锁是同一个对象–SyncTest类对象。</p>\n<p>需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSync1 sync1 = <span class=\"keyword\">new</span> Sync1(<span class=\"keyword\">new</span> SyncTest());</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsync1.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tSyncTest syncTest;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync1</span><span class=\"params\">(SyncTest syncTest)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncTest = syncTest;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncTest) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-5运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-5结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div></pre></td></tr></table></figure>\n<p>可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。</p>\n<h2 id=\"synchronized修饰方法\"><a href=\"#synchronized修饰方法\" class=\"headerlink\" title=\"synchronized修饰方法\"></a>synchronized修饰方法</h2><p>synchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。</p>\n<h3 id=\"synchronized修饰普通方法\"><a href=\"#synchronized修饰普通方法\" class=\"headerlink\" title=\"synchronized修饰普通方法\"></a>synchronized修饰普通方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>synchronized修饰普通方法中的同步锁就是这个对象本身，即”this”。</p>\n<p>下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tdoSomething();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\tdoSomething();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面syncFunction()与syncFunction2()实现的同步效果是一样的。</p>\n<p>当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的”this”。</p>\n<h3 id=\"synchronized修饰静态方法\"><a href=\"#synchronized修饰静态方法\" class=\"headerlink\" title=\"synchronized修饰静态方法\"></a>synchronized修饰静态方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。</p>\n<p>不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>理解synchronized的关键就在于：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong>这个同步锁，可以理解为一个对象。</p>\n"},{"layout":"post","title":"webservice相关","date":"2017-03-15T03:22:45.000Z","_content":"> 上周最后三天去北京培训了Hadoop，了解了一些目前流行的分布式组件。在谈到这些组件的交互过程中，经常会提到RPC，webservice等关键词，所以简单了解了一下这些关键词的含义~\n\n## [WebService](https://zh.wikipedia.org/wiki/Web_services)\n\nwebservice，拆开来看就是 web（网络）和service（服务），先了解一下什么是服务：\n\n计算机的后台进程提供了某种功能，我们把提供了这种功能的进程称为守护进程（Daemon），提供的功能称为服务。比如，我们启动了数据库，数据库进程就会一直运行在后台监听连接数据库的动作，这种监听连接的功能就是一种服务。\n\n服务分为本地服务和网络服务。使用同一台机器上提供的服务就是本地服务，通过网络连接到另一台计算机使用它提供的服务就是网络服务。\n\n所以，webservice 就是通过网络使用了其他服务器提供的某种功能或获取了某些资源。\n\n这样一来，webservice就很常见了。比如我们做了一个显示天气情况的app，使用了百度地图提供的定位功能，使用了其他服务商提供的天气数据，这些都属于webservice。\n\nwebservice可以包含以下几个实现：\n\nRPC：面向过程\n\nRMI：面向对象\n\nREST：面向资源\n\n[Web Service tutorial](http://www.java2blog.com/2013/03/web-service-tutorial.html)\n\n## [RPC](https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8)\n\n### 概念\n\n> 远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。\n该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。\n如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。\n\n上面的解释摘自维基百科\n\nRPC属于webservice的一种，就是在一个进程中调用另一个进程中的服务。就像调用本地方法一样调用远程服务器的方法。\n\nRPC有很多实现，包括XML-RPC、JSON-RPC、JAX-RPC等等。\n\n一次RPC调用过程就是向服务器发送一个过程调用的方法和参数，得到服务器返回的方法执行结果。RPC的本质就是一次远程调用，但更强调透明调用。RPC是跨语言的。\n\n### 使用\n\n以[Json-Rpc](http://www.jsonrpc.org) 为例，看一下RPC是如何工作的：\n\n使用java中的json-rpc实现[jsonrpc4j](https://github.com/briandilley/jsonrpc4j)：（也有其他语言的实现）\n\nCreate your service interface:\n```\npackage com.mycompany;\npublic interface UserService {\n    User createUser(String userName, String firstName, String password);\n    User createUser(String userName, String password);\n    User findUserByUserName(String userName);\n    int getUserCount();\n}\n```\nImplement it:\n```\npackage com.mycompany;\npublic class UserServiceImpl\n    implements UserService {\n\n    public User createUser(String userName, String firstName, String password) {\n        User user = new User();\n        user.setUserName(userName);\n        user.setFirstName(firstName);\n        user.setPassword(password);\n        database.saveUser(user)\n        return user;\n    }\n\n    public User createUser(String userName, String password) {\n        return this.createUser(userName, null, password);\n    }\n\n    public User findUserByUserName(String userName) {\n        return database.findUserByUserName(userName);\n    }\n\n    public int getUserCount() {\n        return database.getUserCount();\n    }\n\n}\n```\nServer\n```\nclass UserServiceServlet\n    extends HttpServlet {\n\n    private UserService userService;\n    private JsonRpcServer jsonRpcServer;\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) {\n        jsonRpcServer.handle(req, resp);\n    }\n\n    public void init(ServletConfig config) {\n        //this.userService = ...\n        this.jsonRpcServer = new JsonRpcServer(this.userService, UserService.class);\n    }\n\n}\n```\nClient\n```\nJsonRpcHttpClient client = new JsonRpcHttpClient(\n    new URL(\"http://example.com/UserService.json\"));\n\nUserService userService = ProxyUtil.createClientProxy(\n    getClass().getClassLoader(),\n    UserService.class,\n    client);\n\nUser user = userService.createUser(\"bob\", \"the builder\");\n```\n\n上面的例子只是最简单的访问方式，在分布式环境中，RPC还涉及到服务寻址，负载均衡等等问题。\n\n更加详细的RPC介绍，可以参考[RPC 是什么](http://blog.brucefeng.info/post/what-is-rpc)\n\n### 为什么是RPC\n\n在网上查看RPC资料的时候，就想到一个问题，既然RPC这么复杂，为什么不使用HTTP接口调用的方式来进行网络通信呢？以前做一些小demo的时候使用HttpClient就完全OK了。\n\n看到一个很有意思的讨论：[为什么需要RPC，而不是简单的HTTP接口](https://www.oschina.net/question/271044_2155059)\n\nRPC调用简单，适用于业务逻辑比较复杂的情况，比如分布式环境当中。RPC强调透明调用,也利于解耦。\n\n### 原理\n\n[QiuRPC](https://github.com/i1see1you/QiuRPC)：一个通用的网络RPC框架\n\n[你应该知道的 RPC 原理](http://blog.jobbole.com/92290/)\n\n## [SOAP](https://zh.wikipedia.org/wiki/SOAP)\n\nXML-RPC只能使用有限的数据类型种类和一些简单的数据结构。于是就出现了SOAP(Simple Object Access Protocol)。\n\nSOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。\n\n事实上SOAP数据使用XML数据格式，定义了一整套复杂的标签，以描述调用的远程过程、参数、返回值和出错信息等等。而且随着需要的增长，又不得增加协议以支持安全性，这使SOAP变得异常庞大，背离了简单的初衷。另一方面，各个服务器都可以基于这个协议推出自己的API，即使它们提供的服务及其相似，定义的API也不尽相同，这又导致了WSDL的诞生。\n\nWSDL (Web Service Description Language) 也遵循XML格式，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，简言之，服务发现。\n\n现在，使用Web Service的过程变成，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。\n\n[Working Soap client example](http://stackoverflow.com/questions/15948927/working-soap-client-example)\n\n[SOAP Messaging Models and Examples](https://docs.oracle.com/cd/E19340-01/820-6767/aeqfx/index.html)\n\n通过soap demo体会soap与rpc的区别\n\n## [RMI](https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8)\n\nRMI其实也属于RPC的一种，是面向对象的。RMI只能在java里玩，不支持跨语言。与RPC不同的是，RMI可以返回java对象以及基本的数据类型，RPC不允许返回对象，RPC服务的信息由外部数据表示。RMI的优势在于依靠Java序列化机制，对开发人员屏蔽了数据编排和解排的细节，要做的事情非常少。\n\n用代码说话：\n\nRMI采用的是典型的客户端-服务器端架构。首先需要定义的是服务器端的远程接口，这一步是设计好服务器端需要提供什么样的服务。对远程接口的要求很简单，只需要继承自RMI中的Remote接口即可。Remote和Serializable一样，也是标记接口。远程接口中的方法需要抛出RemoteException。定义好远程接口之后，实现该接口即可。如下面的Calculator是一个简单的远程接口。\n```\npublic interface Calculator extends Remote {\n    String calculate(String expr) throws RemoteException;\n}  \n```\n实现了远程接口的类的实例称为远程对象。创建出远程对象之后，需要把它注册到一个注册表之中。这是为了客户端能够找到该远程对象并调用。\n```\npublic class CalculatorServer implements Calculator {\n    public String calculate(String expr) throws RemoteException {\n        return expr;\n    }\n    public void start() throws RemoteException, AlreadyBoundException {\n        Calculator stub = (Calculator) UnicastRemoteObject.exportObject(this, 0);\n        Registry registry = LocateRegistry.getRegistry();\n        registry.rebind(\"Calculator\", stub);\n    }\n}\n```\nCalculatorServer是远程对象的Java类。在它的start方法中通过UnicastRemoteObject的exportObject把当前对象暴露出来，使得它可以接收来自客户端的调用请求。再通过Registry的rebind方法进行注册，使得客户端可以查找到。\n\n客户端的实现就是首先从注册表中查找到远程接口的实现对象，再调用相应的方法即可。实际的调用虽然是在服务器端完成的，但是在客户端看来，这个接口中的方法就好像是在当前JVM中一样。这就是RMI的强大之处。\n```\npublic class CalculatorClient {\n    public void calculate(String expr) {\n        try {\n            Registry registry = LocateRegistry.getRegistry(\"localhost\");\n            Calculator calculator = (Calculator) registry.lookup(\"Calculator\");\n            String result = calculator.calculate(expr);\n            System.out.println(result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n} \n```\n在运行的时候，需要首先通过rmiregistry命令来启动RMI中用到的注册表服务器。\n\n为了通过Java的序列化机制来进行传输，远程接口中的方法的参数和返回值，要么是Java的基本类型，要么是远程对象，要么是实现了 Serializable接口的Java类。当客户端通过RMI注册表找到一个远程接口的时候，所得到的其实是远程接口的一个动态代理对象。当客户端调用其中的方法的时候，方法的参数对象会在序列化之后，传输到服务器端。服务器端接收到之后，进行反序列化得到参数对象。并使用这些参数对象，在服务器端调用实际的方法。调用的返回值Java对象经过序列化之后，再发送回客户端。客户端再经过反序列化之后得到Java对象，返回给调用者。这中间的序列化过程对于使用者来说是透明的，由动态代理对象自动完成。除了序列化之外，RMI还使用了动态类加载技术。当需要进行反序列化的时候，如果该对象的类定义在当前JVM中没有找到，RMI会尝试从远端下载所需的类文件定义。可以在RMI程序启动的时候，通过JVM参数java.rmi.server.codebase来指定动态下载Java类文件的URL。  \n\n## [REST](https://zh.wikipedia.org/wiki/REST)\n\nREST只是一种软件架构的风格，而不是一种协议或者其他。\n\nREST基于HTTP协议，一般使用JSON传输数据。REST是面向资源的，资源由URI来表示。\n\n以下解释参考自[理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n---\n要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。\n\n资源（Resources）\n\nREST的名称\"表现层状态转化\"中，省略了主语。\"表现层\"其实指的是\"资源\"（Resources）的\"表现层\"。\n\n所谓\"资源\"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。\n\n所谓\"上网\"，就是与互联网上一系列的\"资源\"互动，调用它的URI。\n\n表现层（Representation）\n\n\"资源\"是一种信息实体，它可以有多种外在表现形式。我们把\"资源\"具体呈现出来的形式，叫做它的\"表现层\"（Representation）。\n\n比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。\n\nURI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的\".html\"后缀名是不必要的，因为这个后缀名表示格式，属于\"表现层\"范畴，而URI应该只代表\"资源\"的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对\"表现层\"的描述。\n\n状态转化（State Transfer）\n\n访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。\n\n互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\"状态转化\"（State Transfer）。而这种转化是建立在表现层之上的，所以就是\"表现层状态转化\"。\n\n客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。\n\n综述\n\n综合上面的解释，我们总结一下什么是RESTful架构：\n（1）每一个URI代表一种资源；\n（2）客户端和服务器之间，传递这种资源的某种表现层；\n（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现\"表现层状态转化\"。\n\n---\n\n参考[RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)设计Rest API\n\ngithub的API设计就是REST风格的。\n\n网上关于REST和PRC的争论有很多,总的来说有以下几个：\n\n安全性上：SOAP安全性高于REST\n\n成熟度上：SOAP在成熟度上优于REST\n\n效率和易用性上：REST更胜一筹\n\n## 参考\n\n[你应该知道的 RPC 原理](http://blog.jobbole.com/92290/)\n\n[RPC 是什么](http://blog.brucefeng.info/post/what-is-rpc)\n\n[Web service是什么？](http://www.ruanyifeng.com/blog/2009/08/what_is_web_service.html)\n\n[Java深度历险（十）——Java对象序列化与RMI](http://www.infoq.com/cn/articles/cf-java-object-serialization-rmi)","source":"_posts/webservice相关.md","raw":"---\nlayout: post\ntitle: webservice相关\ndate: 2017-03-15 11:22:45\ncategories: 技术\ntags: web\n---\n> 上周最后三天去北京培训了Hadoop，了解了一些目前流行的分布式组件。在谈到这些组件的交互过程中，经常会提到RPC，webservice等关键词，所以简单了解了一下这些关键词的含义~\n\n## [WebService](https://zh.wikipedia.org/wiki/Web_services)\n\nwebservice，拆开来看就是 web（网络）和service（服务），先了解一下什么是服务：\n\n计算机的后台进程提供了某种功能，我们把提供了这种功能的进程称为守护进程（Daemon），提供的功能称为服务。比如，我们启动了数据库，数据库进程就会一直运行在后台监听连接数据库的动作，这种监听连接的功能就是一种服务。\n\n服务分为本地服务和网络服务。使用同一台机器上提供的服务就是本地服务，通过网络连接到另一台计算机使用它提供的服务就是网络服务。\n\n所以，webservice 就是通过网络使用了其他服务器提供的某种功能或获取了某些资源。\n\n这样一来，webservice就很常见了。比如我们做了一个显示天气情况的app，使用了百度地图提供的定位功能，使用了其他服务商提供的天气数据，这些都属于webservice。\n\nwebservice可以包含以下几个实现：\n\nRPC：面向过程\n\nRMI：面向对象\n\nREST：面向资源\n\n[Web Service tutorial](http://www.java2blog.com/2013/03/web-service-tutorial.html)\n\n## [RPC](https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8)\n\n### 概念\n\n> 远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。\n该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。\n如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。\n\n上面的解释摘自维基百科\n\nRPC属于webservice的一种，就是在一个进程中调用另一个进程中的服务。就像调用本地方法一样调用远程服务器的方法。\n\nRPC有很多实现，包括XML-RPC、JSON-RPC、JAX-RPC等等。\n\n一次RPC调用过程就是向服务器发送一个过程调用的方法和参数，得到服务器返回的方法执行结果。RPC的本质就是一次远程调用，但更强调透明调用。RPC是跨语言的。\n\n### 使用\n\n以[Json-Rpc](http://www.jsonrpc.org) 为例，看一下RPC是如何工作的：\n\n使用java中的json-rpc实现[jsonrpc4j](https://github.com/briandilley/jsonrpc4j)：（也有其他语言的实现）\n\nCreate your service interface:\n```\npackage com.mycompany;\npublic interface UserService {\n    User createUser(String userName, String firstName, String password);\n    User createUser(String userName, String password);\n    User findUserByUserName(String userName);\n    int getUserCount();\n}\n```\nImplement it:\n```\npackage com.mycompany;\npublic class UserServiceImpl\n    implements UserService {\n\n    public User createUser(String userName, String firstName, String password) {\n        User user = new User();\n        user.setUserName(userName);\n        user.setFirstName(firstName);\n        user.setPassword(password);\n        database.saveUser(user)\n        return user;\n    }\n\n    public User createUser(String userName, String password) {\n        return this.createUser(userName, null, password);\n    }\n\n    public User findUserByUserName(String userName) {\n        return database.findUserByUserName(userName);\n    }\n\n    public int getUserCount() {\n        return database.getUserCount();\n    }\n\n}\n```\nServer\n```\nclass UserServiceServlet\n    extends HttpServlet {\n\n    private UserService userService;\n    private JsonRpcServer jsonRpcServer;\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) {\n        jsonRpcServer.handle(req, resp);\n    }\n\n    public void init(ServletConfig config) {\n        //this.userService = ...\n        this.jsonRpcServer = new JsonRpcServer(this.userService, UserService.class);\n    }\n\n}\n```\nClient\n```\nJsonRpcHttpClient client = new JsonRpcHttpClient(\n    new URL(\"http://example.com/UserService.json\"));\n\nUserService userService = ProxyUtil.createClientProxy(\n    getClass().getClassLoader(),\n    UserService.class,\n    client);\n\nUser user = userService.createUser(\"bob\", \"the builder\");\n```\n\n上面的例子只是最简单的访问方式，在分布式环境中，RPC还涉及到服务寻址，负载均衡等等问题。\n\n更加详细的RPC介绍，可以参考[RPC 是什么](http://blog.brucefeng.info/post/what-is-rpc)\n\n### 为什么是RPC\n\n在网上查看RPC资料的时候，就想到一个问题，既然RPC这么复杂，为什么不使用HTTP接口调用的方式来进行网络通信呢？以前做一些小demo的时候使用HttpClient就完全OK了。\n\n看到一个很有意思的讨论：[为什么需要RPC，而不是简单的HTTP接口](https://www.oschina.net/question/271044_2155059)\n\nRPC调用简单，适用于业务逻辑比较复杂的情况，比如分布式环境当中。RPC强调透明调用,也利于解耦。\n\n### 原理\n\n[QiuRPC](https://github.com/i1see1you/QiuRPC)：一个通用的网络RPC框架\n\n[你应该知道的 RPC 原理](http://blog.jobbole.com/92290/)\n\n## [SOAP](https://zh.wikipedia.org/wiki/SOAP)\n\nXML-RPC只能使用有限的数据类型种类和一些简单的数据结构。于是就出现了SOAP(Simple Object Access Protocol)。\n\nSOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。\n\n事实上SOAP数据使用XML数据格式，定义了一整套复杂的标签，以描述调用的远程过程、参数、返回值和出错信息等等。而且随着需要的增长，又不得增加协议以支持安全性，这使SOAP变得异常庞大，背离了简单的初衷。另一方面，各个服务器都可以基于这个协议推出自己的API，即使它们提供的服务及其相似，定义的API也不尽相同，这又导致了WSDL的诞生。\n\nWSDL (Web Service Description Language) 也遵循XML格式，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，简言之，服务发现。\n\n现在，使用Web Service的过程变成，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。\n\n[Working Soap client example](http://stackoverflow.com/questions/15948927/working-soap-client-example)\n\n[SOAP Messaging Models and Examples](https://docs.oracle.com/cd/E19340-01/820-6767/aeqfx/index.html)\n\n通过soap demo体会soap与rpc的区别\n\n## [RMI](https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8)\n\nRMI其实也属于RPC的一种，是面向对象的。RMI只能在java里玩，不支持跨语言。与RPC不同的是，RMI可以返回java对象以及基本的数据类型，RPC不允许返回对象，RPC服务的信息由外部数据表示。RMI的优势在于依靠Java序列化机制，对开发人员屏蔽了数据编排和解排的细节，要做的事情非常少。\n\n用代码说话：\n\nRMI采用的是典型的客户端-服务器端架构。首先需要定义的是服务器端的远程接口，这一步是设计好服务器端需要提供什么样的服务。对远程接口的要求很简单，只需要继承自RMI中的Remote接口即可。Remote和Serializable一样，也是标记接口。远程接口中的方法需要抛出RemoteException。定义好远程接口之后，实现该接口即可。如下面的Calculator是一个简单的远程接口。\n```\npublic interface Calculator extends Remote {\n    String calculate(String expr) throws RemoteException;\n}  \n```\n实现了远程接口的类的实例称为远程对象。创建出远程对象之后，需要把它注册到一个注册表之中。这是为了客户端能够找到该远程对象并调用。\n```\npublic class CalculatorServer implements Calculator {\n    public String calculate(String expr) throws RemoteException {\n        return expr;\n    }\n    public void start() throws RemoteException, AlreadyBoundException {\n        Calculator stub = (Calculator) UnicastRemoteObject.exportObject(this, 0);\n        Registry registry = LocateRegistry.getRegistry();\n        registry.rebind(\"Calculator\", stub);\n    }\n}\n```\nCalculatorServer是远程对象的Java类。在它的start方法中通过UnicastRemoteObject的exportObject把当前对象暴露出来，使得它可以接收来自客户端的调用请求。再通过Registry的rebind方法进行注册，使得客户端可以查找到。\n\n客户端的实现就是首先从注册表中查找到远程接口的实现对象，再调用相应的方法即可。实际的调用虽然是在服务器端完成的，但是在客户端看来，这个接口中的方法就好像是在当前JVM中一样。这就是RMI的强大之处。\n```\npublic class CalculatorClient {\n    public void calculate(String expr) {\n        try {\n            Registry registry = LocateRegistry.getRegistry(\"localhost\");\n            Calculator calculator = (Calculator) registry.lookup(\"Calculator\");\n            String result = calculator.calculate(expr);\n            System.out.println(result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n} \n```\n在运行的时候，需要首先通过rmiregistry命令来启动RMI中用到的注册表服务器。\n\n为了通过Java的序列化机制来进行传输，远程接口中的方法的参数和返回值，要么是Java的基本类型，要么是远程对象，要么是实现了 Serializable接口的Java类。当客户端通过RMI注册表找到一个远程接口的时候，所得到的其实是远程接口的一个动态代理对象。当客户端调用其中的方法的时候，方法的参数对象会在序列化之后，传输到服务器端。服务器端接收到之后，进行反序列化得到参数对象。并使用这些参数对象，在服务器端调用实际的方法。调用的返回值Java对象经过序列化之后，再发送回客户端。客户端再经过反序列化之后得到Java对象，返回给调用者。这中间的序列化过程对于使用者来说是透明的，由动态代理对象自动完成。除了序列化之外，RMI还使用了动态类加载技术。当需要进行反序列化的时候，如果该对象的类定义在当前JVM中没有找到，RMI会尝试从远端下载所需的类文件定义。可以在RMI程序启动的时候，通过JVM参数java.rmi.server.codebase来指定动态下载Java类文件的URL。  \n\n## [REST](https://zh.wikipedia.org/wiki/REST)\n\nREST只是一种软件架构的风格，而不是一种协议或者其他。\n\nREST基于HTTP协议，一般使用JSON传输数据。REST是面向资源的，资源由URI来表示。\n\n以下解释参考自[理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n---\n要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。\n\n资源（Resources）\n\nREST的名称\"表现层状态转化\"中，省略了主语。\"表现层\"其实指的是\"资源\"（Resources）的\"表现层\"。\n\n所谓\"资源\"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。\n\n所谓\"上网\"，就是与互联网上一系列的\"资源\"互动，调用它的URI。\n\n表现层（Representation）\n\n\"资源\"是一种信息实体，它可以有多种外在表现形式。我们把\"资源\"具体呈现出来的形式，叫做它的\"表现层\"（Representation）。\n\n比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。\n\nURI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的\".html\"后缀名是不必要的，因为这个后缀名表示格式，属于\"表现层\"范畴，而URI应该只代表\"资源\"的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对\"表现层\"的描述。\n\n状态转化（State Transfer）\n\n访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。\n\n互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\"状态转化\"（State Transfer）。而这种转化是建立在表现层之上的，所以就是\"表现层状态转化\"。\n\n客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。\n\n综述\n\n综合上面的解释，我们总结一下什么是RESTful架构：\n（1）每一个URI代表一种资源；\n（2）客户端和服务器之间，传递这种资源的某种表现层；\n（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现\"表现层状态转化\"。\n\n---\n\n参考[RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)设计Rest API\n\ngithub的API设计就是REST风格的。\n\n网上关于REST和PRC的争论有很多,总的来说有以下几个：\n\n安全性上：SOAP安全性高于REST\n\n成熟度上：SOAP在成熟度上优于REST\n\n效率和易用性上：REST更胜一筹\n\n## 参考\n\n[你应该知道的 RPC 原理](http://blog.jobbole.com/92290/)\n\n[RPC 是什么](http://blog.brucefeng.info/post/what-is-rpc)\n\n[Web service是什么？](http://www.ruanyifeng.com/blog/2009/08/what_is_web_service.html)\n\n[Java深度历险（十）——Java对象序列化与RMI](http://www.infoq.com/cn/articles/cf-java-object-serialization-rmi)","slug":"webservice相关","published":1,"updated":"2017-03-15T14:20:33.000Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlsf0034vegcb8dbc0sw","content":"<blockquote>\n<p>上周最后三天去北京培训了Hadoop，了解了一些目前流行的分布式组件。在谈到这些组件的交互过程中，经常会提到RPC，webservice等关键词，所以简单了解了一下这些关键词的含义~</p>\n</blockquote>\n<h2 id=\"WebService\"><a href=\"#WebService\" class=\"headerlink\" title=\"WebService\"></a><a href=\"https://zh.wikipedia.org/wiki/Web_services\" target=\"_blank\" rel=\"external\">WebService</a></h2><p>webservice，拆开来看就是 web（网络）和service（服务），先了解一下什么是服务：</p>\n<p>计算机的后台进程提供了某种功能，我们把提供了这种功能的进程称为守护进程（Daemon），提供的功能称为服务。比如，我们启动了数据库，数据库进程就会一直运行在后台监听连接数据库的动作，这种监听连接的功能就是一种服务。</p>\n<p>服务分为本地服务和网络服务。使用同一台机器上提供的服务就是本地服务，通过网络连接到另一台计算机使用它提供的服务就是网络服务。</p>\n<p>所以，webservice 就是通过网络使用了其他服务器提供的某种功能或获取了某些资源。</p>\n<p>这样一来，webservice就很常见了。比如我们做了一个显示天气情况的app，使用了百度地图提供的定位功能，使用了其他服务商提供的天气数据，这些都属于webservice。</p>\n<p>webservice可以包含以下几个实现：</p>\n<p>RPC：面向过程</p>\n<p>RMI：面向对象</p>\n<p>REST：面向资源</p>\n<p><a href=\"http://www.java2blog.com/2013/03/web-service-tutorial.html\" target=\"_blank\" rel=\"external\">Web Service tutorial</a></p>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a><a href=\"https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8\" target=\"_blank\" rel=\"external\">RPC</a></h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。<br>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。<br>如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。</p>\n</blockquote>\n<p>上面的解释摘自维基百科</p>\n<p>RPC属于webservice的一种，就是在一个进程中调用另一个进程中的服务。就像调用本地方法一样调用远程服务器的方法。</p>\n<p>RPC有很多实现，包括XML-RPC、JSON-RPC、JAX-RPC等等。</p>\n<p>一次RPC调用过程就是向服务器发送一个过程调用的方法和参数，得到服务器返回的方法执行结果。RPC的本质就是一次远程调用，但更强调透明调用。RPC是跨语言的。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>以<a href=\"http://www.jsonrpc.org\" target=\"_blank\" rel=\"external\">Json-Rpc</a> 为例，看一下RPC是如何工作的：</p>\n<p>使用java中的json-rpc实现<a href=\"https://github.com/briandilley/jsonrpc4j\" target=\"_blank\" rel=\"external\">jsonrpc4j</a>：（也有其他语言的实现）</p>\n<p>Create your service interface:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.mycompany;</div><div class=\"line\">public interface UserService &#123;</div><div class=\"line\">    User createUser(String userName, String firstName, String password);</div><div class=\"line\">    User createUser(String userName, String password);</div><div class=\"line\">    User findUserByUserName(String userName);</div><div class=\"line\">    int getUserCount();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Implement it:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.mycompany;</div><div class=\"line\">public class UserServiceImpl</div><div class=\"line\">    implements UserService &#123;</div><div class=\"line\"></div><div class=\"line\">    public User createUser(String userName, String firstName, String password) &#123;</div><div class=\"line\">        User user = new User();</div><div class=\"line\">        user.setUserName(userName);</div><div class=\"line\">        user.setFirstName(firstName);</div><div class=\"line\">        user.setPassword(password);</div><div class=\"line\">        database.saveUser(user)</div><div class=\"line\">        return user;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public User createUser(String userName, String password) &#123;</div><div class=\"line\">        return this.createUser(userName, null, password);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public User findUserByUserName(String userName) &#123;</div><div class=\"line\">        return database.findUserByUserName(userName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public int getUserCount() &#123;</div><div class=\"line\">        return database.getUserCount();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Server<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class UserServiceServlet</div><div class=\"line\">    extends HttpServlet &#123;</div><div class=\"line\"></div><div class=\"line\">    private UserService userService;</div><div class=\"line\">    private JsonRpcServer jsonRpcServer;</div><div class=\"line\"></div><div class=\"line\">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) &#123;</div><div class=\"line\">        jsonRpcServer.handle(req, resp);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void init(ServletConfig config) &#123;</div><div class=\"line\">        //this.userService = ...</div><div class=\"line\">        this.jsonRpcServer = new JsonRpcServer(this.userService, UserService.class);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Client<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">JsonRpcHttpClient client = new JsonRpcHttpClient(</div><div class=\"line\">    new URL(&quot;http://example.com/UserService.json&quot;));</div><div class=\"line\"></div><div class=\"line\">UserService userService = ProxyUtil.createClientProxy(</div><div class=\"line\">    getClass().getClassLoader(),</div><div class=\"line\">    UserService.class,</div><div class=\"line\">    client);</div><div class=\"line\"></div><div class=\"line\">User user = userService.createUser(&quot;bob&quot;, &quot;the builder&quot;);</div></pre></td></tr></table></figure></p>\n<p>上面的例子只是最简单的访问方式，在分布式环境中，RPC还涉及到服务寻址，负载均衡等等问题。</p>\n<p>更加详细的RPC介绍，可以参考<a href=\"http://blog.brucefeng.info/post/what-is-rpc\" target=\"_blank\" rel=\"external\">RPC 是什么</a></p>\n<h3 id=\"为什么是RPC\"><a href=\"#为什么是RPC\" class=\"headerlink\" title=\"为什么是RPC\"></a>为什么是RPC</h3><p>在网上查看RPC资料的时候，就想到一个问题，既然RPC这么复杂，为什么不使用HTTP接口调用的方式来进行网络通信呢？以前做一些小demo的时候使用HttpClient就完全OK了。</p>\n<p>看到一个很有意思的讨论：<a href=\"https://www.oschina.net/question/271044_2155059\" target=\"_blank\" rel=\"external\">为什么需要RPC，而不是简单的HTTP接口</a></p>\n<p>RPC调用简单，适用于业务逻辑比较复杂的情况，比如分布式环境当中。RPC强调透明调用,也利于解耦。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><a href=\"https://github.com/i1see1you/QiuRPC\" target=\"_blank\" rel=\"external\">QiuRPC</a>：一个通用的网络RPC框架</p>\n<p><a href=\"http://blog.jobbole.com/92290/\" target=\"_blank\" rel=\"external\">你应该知道的 RPC 原理</a></p>\n<h2 id=\"SOAP\"><a href=\"#SOAP\" class=\"headerlink\" title=\"SOAP\"></a><a href=\"https://zh.wikipedia.org/wiki/SOAP\" target=\"_blank\" rel=\"external\">SOAP</a></h2><p>XML-RPC只能使用有限的数据类型种类和一些简单的数据结构。于是就出现了SOAP(Simple Object Access Protocol)。</p>\n<p>SOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。</p>\n<p>事实上SOAP数据使用XML数据格式，定义了一整套复杂的标签，以描述调用的远程过程、参数、返回值和出错信息等等。而且随着需要的增长，又不得增加协议以支持安全性，这使SOAP变得异常庞大，背离了简单的初衷。另一方面，各个服务器都可以基于这个协议推出自己的API，即使它们提供的服务及其相似，定义的API也不尽相同，这又导致了WSDL的诞生。</p>\n<p>WSDL (Web Service Description Language) 也遵循XML格式，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，简言之，服务发现。</p>\n<p>现在，使用Web Service的过程变成，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。</p>\n<p><a href=\"http://stackoverflow.com/questions/15948927/working-soap-client-example\" target=\"_blank\" rel=\"external\">Working Soap client example</a></p>\n<p><a href=\"https://docs.oracle.com/cd/E19340-01/820-6767/aeqfx/index.html\" target=\"_blank\" rel=\"external\">SOAP Messaging Models and Examples</a></p>\n<p>通过soap demo体会soap与rpc的区别</p>\n<h2 id=\"RMI\"><a href=\"#RMI\" class=\"headerlink\" title=\"RMI\"></a><a href=\"https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8\" target=\"_blank\" rel=\"external\">RMI</a></h2><p>RMI其实也属于RPC的一种，是面向对象的。RMI只能在java里玩，不支持跨语言。与RPC不同的是，RMI可以返回java对象以及基本的数据类型，RPC不允许返回对象，RPC服务的信息由外部数据表示。RMI的优势在于依靠Java序列化机制，对开发人员屏蔽了数据编排和解排的细节，要做的事情非常少。</p>\n<p>用代码说话：</p>\n<p>RMI采用的是典型的客户端-服务器端架构。首先需要定义的是服务器端的远程接口，这一步是设计好服务器端需要提供什么样的服务。对远程接口的要求很简单，只需要继承自RMI中的Remote接口即可。Remote和Serializable一样，也是标记接口。远程接口中的方法需要抛出RemoteException。定义好远程接口之后，实现该接口即可。如下面的Calculator是一个简单的远程接口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Calculator extends Remote &#123;</div><div class=\"line\">    String calculate(String expr) throws RemoteException;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实现了远程接口的类的实例称为远程对象。创建出远程对象之后，需要把它注册到一个注册表之中。这是为了客户端能够找到该远程对象并调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CalculatorServer implements Calculator &#123;</div><div class=\"line\">    public String calculate(String expr) throws RemoteException &#123;</div><div class=\"line\">        return expr;</div><div class=\"line\">    &#125;</div><div class=\"line\">    public void start() throws RemoteException, AlreadyBoundException &#123;</div><div class=\"line\">        Calculator stub = (Calculator) UnicastRemoteObject.exportObject(this, 0);</div><div class=\"line\">        Registry registry = LocateRegistry.getRegistry();</div><div class=\"line\">        registry.rebind(&quot;Calculator&quot;, stub);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>CalculatorServer是远程对象的Java类。在它的start方法中通过UnicastRemoteObject的exportObject把当前对象暴露出来，使得它可以接收来自客户端的调用请求。再通过Registry的rebind方法进行注册，使得客户端可以查找到。</p>\n<p>客户端的实现就是首先从注册表中查找到远程接口的实现对象，再调用相应的方法即可。实际的调用虽然是在服务器端完成的，但是在客户端看来，这个接口中的方法就好像是在当前JVM中一样。这就是RMI的强大之处。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CalculatorClient &#123;</div><div class=\"line\">    public void calculate(String expr) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;);</div><div class=\"line\">            Calculator calculator = (Calculator) registry.lookup(&quot;Calculator&quot;);</div><div class=\"line\">            String result = calculator.calculate(expr);</div><div class=\"line\">            System.out.println(result);</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在运行的时候，需要首先通过rmiregistry命令来启动RMI中用到的注册表服务器。</p>\n<p>为了通过Java的序列化机制来进行传输，远程接口中的方法的参数和返回值，要么是Java的基本类型，要么是远程对象，要么是实现了 Serializable接口的Java类。当客户端通过RMI注册表找到一个远程接口的时候，所得到的其实是远程接口的一个动态代理对象。当客户端调用其中的方法的时候，方法的参数对象会在序列化之后，传输到服务器端。服务器端接收到之后，进行反序列化得到参数对象。并使用这些参数对象，在服务器端调用实际的方法。调用的返回值Java对象经过序列化之后，再发送回客户端。客户端再经过反序列化之后得到Java对象，返回给调用者。这中间的序列化过程对于使用者来说是透明的，由动态代理对象自动完成。除了序列化之外，RMI还使用了动态类加载技术。当需要进行反序列化的时候，如果该对象的类定义在当前JVM中没有找到，RMI会尝试从远端下载所需的类文件定义。可以在RMI程序启动的时候，通过JVM参数java.rmi.server.codebase来指定动态下载Java类文件的URL。  </p>\n<h2 id=\"REST\"><a href=\"#REST\" class=\"headerlink\" title=\"REST\"></a><a href=\"https://zh.wikipedia.org/wiki/REST\" target=\"_blank\" rel=\"external\">REST</a></h2><p>REST只是一种软件架构的风格，而不是一种协议或者其他。</p>\n<p>REST基于HTTP协议，一般使用JSON传输数据。REST是面向资源的，资源由URI来表示。</p>\n<p>以下解释参考自<a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"external\">理解RESTful架构</a></p>\n<hr>\n<p>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p>\n<p>资源（Resources）</p>\n<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>\n<p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>\n<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p>\n<p>表现层（Representation）</p>\n<p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p>\n<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>\n<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>\n<p>状态转化（State Transfer）</p>\n<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>\n<p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>\n<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>\n<p>综述</p>\n<p>综合上面的解释，我们总结一下什么是RESTful架构：<br>（1）每一个URI代表一种资源；<br>（2）客户端和服务器之间，传递这种资源的某种表现层；<br>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>\n<hr>\n<p>参考<a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"external\">RESTful API 设计指南</a>设计Rest API</p>\n<p>github的API设计就是REST风格的。</p>\n<p>网上关于REST和PRC的争论有很多,总的来说有以下几个：</p>\n<p>安全性上：SOAP安全性高于REST</p>\n<p>成熟度上：SOAP在成熟度上优于REST</p>\n<p>效率和易用性上：REST更胜一筹</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.jobbole.com/92290/\" target=\"_blank\" rel=\"external\">你应该知道的 RPC 原理</a></p>\n<p><a href=\"http://blog.brucefeng.info/post/what-is-rpc\" target=\"_blank\" rel=\"external\">RPC 是什么</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2009/08/what_is_web_service.html\" target=\"_blank\" rel=\"external\">Web service是什么？</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/cf-java-object-serialization-rmi\" target=\"_blank\" rel=\"external\">Java深度历险（十）——Java对象序列化与RMI</a></p>\n","excerpt":"","more":"<blockquote>\n<p>上周最后三天去北京培训了Hadoop，了解了一些目前流行的分布式组件。在谈到这些组件的交互过程中，经常会提到RPC，webservice等关键词，所以简单了解了一下这些关键词的含义~</p>\n</blockquote>\n<h2 id=\"WebService\"><a href=\"#WebService\" class=\"headerlink\" title=\"WebService\"></a><a href=\"https://zh.wikipedia.org/wiki/Web_services\">WebService</a></h2><p>webservice，拆开来看就是 web（网络）和service（服务），先了解一下什么是服务：</p>\n<p>计算机的后台进程提供了某种功能，我们把提供了这种功能的进程称为守护进程（Daemon），提供的功能称为服务。比如，我们启动了数据库，数据库进程就会一直运行在后台监听连接数据库的动作，这种监听连接的功能就是一种服务。</p>\n<p>服务分为本地服务和网络服务。使用同一台机器上提供的服务就是本地服务，通过网络连接到另一台计算机使用它提供的服务就是网络服务。</p>\n<p>所以，webservice 就是通过网络使用了其他服务器提供的某种功能或获取了某些资源。</p>\n<p>这样一来，webservice就很常见了。比如我们做了一个显示天气情况的app，使用了百度地图提供的定位功能，使用了其他服务商提供的天气数据，这些都属于webservice。</p>\n<p>webservice可以包含以下几个实现：</p>\n<p>RPC：面向过程</p>\n<p>RMI：面向对象</p>\n<p>REST：面向资源</p>\n<p><a href=\"http://www.java2blog.com/2013/03/web-service-tutorial.html\">Web Service tutorial</a></p>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a><a href=\"https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8\">RPC</a></h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。<br>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。<br>如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。</p>\n</blockquote>\n<p>上面的解释摘自维基百科</p>\n<p>RPC属于webservice的一种，就是在一个进程中调用另一个进程中的服务。就像调用本地方法一样调用远程服务器的方法。</p>\n<p>RPC有很多实现，包括XML-RPC、JSON-RPC、JAX-RPC等等。</p>\n<p>一次RPC调用过程就是向服务器发送一个过程调用的方法和参数，得到服务器返回的方法执行结果。RPC的本质就是一次远程调用，但更强调透明调用。RPC是跨语言的。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>以<a href=\"http://www.jsonrpc.org\">Json-Rpc</a> 为例，看一下RPC是如何工作的：</p>\n<p>使用java中的json-rpc实现<a href=\"https://github.com/briandilley/jsonrpc4j\">jsonrpc4j</a>：（也有其他语言的实现）</p>\n<p>Create your service interface:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.mycompany;</div><div class=\"line\">public interface UserService &#123;</div><div class=\"line\">    User createUser(String userName, String firstName, String password);</div><div class=\"line\">    User createUser(String userName, String password);</div><div class=\"line\">    User findUserByUserName(String userName);</div><div class=\"line\">    int getUserCount();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Implement it:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.mycompany;</div><div class=\"line\">public class UserServiceImpl</div><div class=\"line\">    implements UserService &#123;</div><div class=\"line\"></div><div class=\"line\">    public User createUser(String userName, String firstName, String password) &#123;</div><div class=\"line\">        User user = new User();</div><div class=\"line\">        user.setUserName(userName);</div><div class=\"line\">        user.setFirstName(firstName);</div><div class=\"line\">        user.setPassword(password);</div><div class=\"line\">        database.saveUser(user)</div><div class=\"line\">        return user;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public User createUser(String userName, String password) &#123;</div><div class=\"line\">        return this.createUser(userName, null, password);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public User findUserByUserName(String userName) &#123;</div><div class=\"line\">        return database.findUserByUserName(userName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public int getUserCount() &#123;</div><div class=\"line\">        return database.getUserCount();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Server<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class UserServiceServlet</div><div class=\"line\">    extends HttpServlet &#123;</div><div class=\"line\"></div><div class=\"line\">    private UserService userService;</div><div class=\"line\">    private JsonRpcServer jsonRpcServer;</div><div class=\"line\"></div><div class=\"line\">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) &#123;</div><div class=\"line\">        jsonRpcServer.handle(req, resp);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void init(ServletConfig config) &#123;</div><div class=\"line\">        //this.userService = ...</div><div class=\"line\">        this.jsonRpcServer = new JsonRpcServer(this.userService, UserService.class);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Client<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">JsonRpcHttpClient client = new JsonRpcHttpClient(</div><div class=\"line\">    new URL(&quot;http://example.com/UserService.json&quot;));</div><div class=\"line\"></div><div class=\"line\">UserService userService = ProxyUtil.createClientProxy(</div><div class=\"line\">    getClass().getClassLoader(),</div><div class=\"line\">    UserService.class,</div><div class=\"line\">    client);</div><div class=\"line\"></div><div class=\"line\">User user = userService.createUser(&quot;bob&quot;, &quot;the builder&quot;);</div></pre></td></tr></table></figure></p>\n<p>上面的例子只是最简单的访问方式，在分布式环境中，RPC还涉及到服务寻址，负载均衡等等问题。</p>\n<p>更加详细的RPC介绍，可以参考<a href=\"http://blog.brucefeng.info/post/what-is-rpc\">RPC 是什么</a></p>\n<h3 id=\"为什么是RPC\"><a href=\"#为什么是RPC\" class=\"headerlink\" title=\"为什么是RPC\"></a>为什么是RPC</h3><p>在网上查看RPC资料的时候，就想到一个问题，既然RPC这么复杂，为什么不使用HTTP接口调用的方式来进行网络通信呢？以前做一些小demo的时候使用HttpClient就完全OK了。</p>\n<p>看到一个很有意思的讨论：<a href=\"https://www.oschina.net/question/271044_2155059\">为什么需要RPC，而不是简单的HTTP接口</a></p>\n<p>RPC调用简单，适用于业务逻辑比较复杂的情况，比如分布式环境当中。RPC强调透明调用,也利于解耦。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><a href=\"https://github.com/i1see1you/QiuRPC\">QiuRPC</a>：一个通用的网络RPC框架</p>\n<p><a href=\"http://blog.jobbole.com/92290/\">你应该知道的 RPC 原理</a></p>\n<h2 id=\"SOAP\"><a href=\"#SOAP\" class=\"headerlink\" title=\"SOAP\"></a><a href=\"https://zh.wikipedia.org/wiki/SOAP\">SOAP</a></h2><p>XML-RPC只能使用有限的数据类型种类和一些简单的数据结构。于是就出现了SOAP(Simple Object Access Protocol)。</p>\n<p>SOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。</p>\n<p>事实上SOAP数据使用XML数据格式，定义了一整套复杂的标签，以描述调用的远程过程、参数、返回值和出错信息等等。而且随着需要的增长，又不得增加协议以支持安全性，这使SOAP变得异常庞大，背离了简单的初衷。另一方面，各个服务器都可以基于这个协议推出自己的API，即使它们提供的服务及其相似，定义的API也不尽相同，这又导致了WSDL的诞生。</p>\n<p>WSDL (Web Service Description Language) 也遵循XML格式，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，简言之，服务发现。</p>\n<p>现在，使用Web Service的过程变成，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。</p>\n<p><a href=\"http://stackoverflow.com/questions/15948927/working-soap-client-example\">Working Soap client example</a></p>\n<p><a href=\"https://docs.oracle.com/cd/E19340-01/820-6767/aeqfx/index.html\">SOAP Messaging Models and Examples</a></p>\n<p>通过soap demo体会soap与rpc的区别</p>\n<h2 id=\"RMI\"><a href=\"#RMI\" class=\"headerlink\" title=\"RMI\"></a><a href=\"https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8\">RMI</a></h2><p>RMI其实也属于RPC的一种，是面向对象的。RMI只能在java里玩，不支持跨语言。与RPC不同的是，RMI可以返回java对象以及基本的数据类型，RPC不允许返回对象，RPC服务的信息由外部数据表示。RMI的优势在于依靠Java序列化机制，对开发人员屏蔽了数据编排和解排的细节，要做的事情非常少。</p>\n<p>用代码说话：</p>\n<p>RMI采用的是典型的客户端-服务器端架构。首先需要定义的是服务器端的远程接口，这一步是设计好服务器端需要提供什么样的服务。对远程接口的要求很简单，只需要继承自RMI中的Remote接口即可。Remote和Serializable一样，也是标记接口。远程接口中的方法需要抛出RemoteException。定义好远程接口之后，实现该接口即可。如下面的Calculator是一个简单的远程接口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Calculator extends Remote &#123;</div><div class=\"line\">    String calculate(String expr) throws RemoteException;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实现了远程接口的类的实例称为远程对象。创建出远程对象之后，需要把它注册到一个注册表之中。这是为了客户端能够找到该远程对象并调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CalculatorServer implements Calculator &#123;</div><div class=\"line\">    public String calculate(String expr) throws RemoteException &#123;</div><div class=\"line\">        return expr;</div><div class=\"line\">    &#125;</div><div class=\"line\">    public void start() throws RemoteException, AlreadyBoundException &#123;</div><div class=\"line\">        Calculator stub = (Calculator) UnicastRemoteObject.exportObject(this, 0);</div><div class=\"line\">        Registry registry = LocateRegistry.getRegistry();</div><div class=\"line\">        registry.rebind(&quot;Calculator&quot;, stub);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>CalculatorServer是远程对象的Java类。在它的start方法中通过UnicastRemoteObject的exportObject把当前对象暴露出来，使得它可以接收来自客户端的调用请求。再通过Registry的rebind方法进行注册，使得客户端可以查找到。</p>\n<p>客户端的实现就是首先从注册表中查找到远程接口的实现对象，再调用相应的方法即可。实际的调用虽然是在服务器端完成的，但是在客户端看来，这个接口中的方法就好像是在当前JVM中一样。这就是RMI的强大之处。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CalculatorClient &#123;</div><div class=\"line\">    public void calculate(String expr) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;);</div><div class=\"line\">            Calculator calculator = (Calculator) registry.lookup(&quot;Calculator&quot;);</div><div class=\"line\">            String result = calculator.calculate(expr);</div><div class=\"line\">            System.out.println(result);</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在运行的时候，需要首先通过rmiregistry命令来启动RMI中用到的注册表服务器。</p>\n<p>为了通过Java的序列化机制来进行传输，远程接口中的方法的参数和返回值，要么是Java的基本类型，要么是远程对象，要么是实现了 Serializable接口的Java类。当客户端通过RMI注册表找到一个远程接口的时候，所得到的其实是远程接口的一个动态代理对象。当客户端调用其中的方法的时候，方法的参数对象会在序列化之后，传输到服务器端。服务器端接收到之后，进行反序列化得到参数对象。并使用这些参数对象，在服务器端调用实际的方法。调用的返回值Java对象经过序列化之后，再发送回客户端。客户端再经过反序列化之后得到Java对象，返回给调用者。这中间的序列化过程对于使用者来说是透明的，由动态代理对象自动完成。除了序列化之外，RMI还使用了动态类加载技术。当需要进行反序列化的时候，如果该对象的类定义在当前JVM中没有找到，RMI会尝试从远端下载所需的类文件定义。可以在RMI程序启动的时候，通过JVM参数java.rmi.server.codebase来指定动态下载Java类文件的URL。  </p>\n<h2 id=\"REST\"><a href=\"#REST\" class=\"headerlink\" title=\"REST\"></a><a href=\"https://zh.wikipedia.org/wiki/REST\">REST</a></h2><p>REST只是一种软件架构的风格，而不是一种协议或者其他。</p>\n<p>REST基于HTTP协议，一般使用JSON传输数据。REST是面向资源的，资源由URI来表示。</p>\n<p>以下解释参考自<a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\">理解RESTful架构</a></p>\n<hr>\n<p>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p>\n<p>资源（Resources）</p>\n<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>\n<p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>\n<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p>\n<p>表现层（Representation）</p>\n<p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p>\n<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>\n<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>\n<p>状态转化（State Transfer）</p>\n<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>\n<p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>\n<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>\n<p>综述</p>\n<p>综合上面的解释，我们总结一下什么是RESTful架构：<br>（1）每一个URI代表一种资源；<br>（2）客户端和服务器之间，传递这种资源的某种表现层；<br>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>\n<hr>\n<p>参考<a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\">RESTful API 设计指南</a>设计Rest API</p>\n<p>github的API设计就是REST风格的。</p>\n<p>网上关于REST和PRC的争论有很多,总的来说有以下几个：</p>\n<p>安全性上：SOAP安全性高于REST</p>\n<p>成熟度上：SOAP在成熟度上优于REST</p>\n<p>效率和易用性上：REST更胜一筹</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.jobbole.com/92290/\">你应该知道的 RPC 原理</a></p>\n<p><a href=\"http://blog.brucefeng.info/post/what-is-rpc\">RPC 是什么</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2009/08/what_is_web_service.html\">Web service是什么？</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/cf-java-object-serialization-rmi\">Java深度历险（十）——Java对象序列化与RMI</a></p>\n"},{"layout":"post","title":"win7与centos7双系统安装","date":"2017-02-18T13:10:00.000Z","_content":"> 之前会有同学让帮忙重装操作系统，正好计划重新装一下自己电脑的系统，折腾了win7与linux双系统，在此记录。以后就可以给他们看这篇笔记自己去装啦~\n\n> ps: 由于是双系统的安装操作，而不是虚拟机，所以并未截图，是纯文字说明。如果不清楚，可以参考最下面的参考链接\n\n## 安装win7\n\n### 下载win7镜像文件：\n\n[系统之家win7下载](http://www.xitongzhijia.net/win7/)\n\n选择一款进行下载，我选择了`雨林木风 GHOST WIN7 SP1 X64 装机旗舰版 V2017.02（64位）`\n\n### 制作U盘启动工具\n\n下载启动盘制作工具：\n\n[老毛桃u盘启动盘制作工具](http://www.laomaotao.org/lmtxz/933.html)\n\n下载装机版，进行安装\n\n启动盘制作工具安装完成，且镜像下载完毕之后，启动老毛桃，选择U盘启动->默认模式\n\n插入一个可用的U盘，在选择设备这项中，选择插入的U盘设备，注意不要选错\n\n其他选项默认，点击 开始制作 进行启动盘的制作。\n\n启动盘制作完毕之后，将下载好的iso文件拷入U盘\n\n### 安装win7\n\n插入制作好的启动盘，重启电脑\n\n开机画面出现时，按下F12，boot options(我的电脑是DELL的，其他品牌电脑自行查找)\n\n选择USB启动\n\n老毛桃启动盘正常启动，此时选择第二项，win8pe,点击进入win8pe\n\n1. 首先进行分区，选择分区工具，可以自由设置分区数目和分区大小(我分了3个区，一个用来装win7(C)，一个用来做Windows的资料盘(D)，另外一个用来安装Linux(E))\n\n双击win8pe桌面上的“diskgenius分区工具”图标，在弹出的窗口中点击“快速分区”，即可启动分区工具，具体的分区方法参考官网介绍：[老毛桃分区工具的使用](http://www.laomaotao.org/lmtjc/245.html)\n\n2. 设置好分区后，鼠标左键双击打开桌面上的“老毛桃PE装机工具”，选择“还原分区”，映像文件路径选择上一步拷入U盘的镜像，然后选择要装入的分区(C盘)，点击确认开始自动装机。\n\n3. 系统自动重启几次之后，就安装好了，可以卸载一些不必要的系统自带软件，此时的操作系统已经是激活的版本了（我下载的镜像是），各种需要的驱动也都安装完毕，简单省事。\n\n## 安装centos7\n\n### 查看磁盘分区情况\n\n右键计算机->管理，打开计算机管理程序。选择磁盘管理，查看分区情况。\n\n选择之前分好的E盘，右键“删除卷”，使之状态变为“可用空间”，以便centos安装程序识别。\n\n### 制作U盘启动工具\n\n下载centos7镜像文件（DVD版本即可）\n\n[CentOS-7-x86_64-DVD-1611.iso](http://101.96.8.151/mirror.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1611.iso)\n\n下载烧录U盘工具\n\n[ImageUsb](http://www.osforensics.com/tools/write-usb-images.html)\n\n插入一个可用的U盘\n\n启动 imageusb.exe，\n\nstep1 选择要写入的U盘;\n\nstep2 选择 write image to USB driver;\n\nstep3 选择下载好的centos7镜像文件\n\nstep4 点击 write ，开始烧录启动盘\n\n启动盘烧录完毕后，可以开始安装centos\n\n### 安装centos7\n\n插入制作好的启动盘，重启电脑\n\n开机画面出现时，按下F12 (我的电脑是DELL的，其他品牌电脑自行查找)\n\n选择USB启动\n\n选择第一项，Install CentOs 7 ，回车，开始安装CentOS 7\n\n之后就进入了简单的可视化安装界面，有几点需要注意：\n\n1.分区选择\n\n如果是像上面一样分了3个区，两个被Windows使用，还剩一个分区未被使用，\n那么可以选择自动选择分区，centos安装程序会自动选择好这块未被使用的分区（将“/”目录挂载到这个分区上面）\n\n也可以自定义分区，建议分四个区：/   /boot  /home swap（如果有这么些分区的话）\n\n2.在之后的安装信息摘要中，注意“软件”-“软件选择”，默认是最小安装，即不安装桌面环境，若选择此项，则只有命令行界面，应该选择带有UI界面的选项。\n\n之后就是很简单的安装了\n\n### 配置引导程序\n\n再次启动电脑之后，会发现自动进入Linux，没有win7系统的选项，此时需要配置引导程序\n\n首先添加ntfs支持\n\n```\nwget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo\n\nyum update;yum install ntfs-3g\n```\n\n安装完毕后打开终端，运行`grub2-mkconfig -o /boot/grub2/grub.cfg`\n\n就会重新生成引导项，重启电脑即可\n\n## 参考\n\n[老毛桃u盘安装原版win7系统详细教程](http://www.laomaotao.org/jiaocheng/upzybwin7.html)\n\n[老毛桃分区工具的使用](http://www.laomaotao.org/lmtjc/245.html)\n\n[CentOS 7.0系统安装配置图解教程](http://www.osyunwei.com/archives/7829.html)\n","source":"_posts/win7与centos7双系统安装.md","raw":"layout: post\ntitle: win7与centos7双系统安装\ndate: 2017-02-18 21:10:00\ncategories: 技术\ntags: linux\n---\n> 之前会有同学让帮忙重装操作系统，正好计划重新装一下自己电脑的系统，折腾了win7与linux双系统，在此记录。以后就可以给他们看这篇笔记自己去装啦~\n\n> ps: 由于是双系统的安装操作，而不是虚拟机，所以并未截图，是纯文字说明。如果不清楚，可以参考最下面的参考链接\n\n## 安装win7\n\n### 下载win7镜像文件：\n\n[系统之家win7下载](http://www.xitongzhijia.net/win7/)\n\n选择一款进行下载，我选择了`雨林木风 GHOST WIN7 SP1 X64 装机旗舰版 V2017.02（64位）`\n\n### 制作U盘启动工具\n\n下载启动盘制作工具：\n\n[老毛桃u盘启动盘制作工具](http://www.laomaotao.org/lmtxz/933.html)\n\n下载装机版，进行安装\n\n启动盘制作工具安装完成，且镜像下载完毕之后，启动老毛桃，选择U盘启动->默认模式\n\n插入一个可用的U盘，在选择设备这项中，选择插入的U盘设备，注意不要选错\n\n其他选项默认，点击 开始制作 进行启动盘的制作。\n\n启动盘制作完毕之后，将下载好的iso文件拷入U盘\n\n### 安装win7\n\n插入制作好的启动盘，重启电脑\n\n开机画面出现时，按下F12，boot options(我的电脑是DELL的，其他品牌电脑自行查找)\n\n选择USB启动\n\n老毛桃启动盘正常启动，此时选择第二项，win8pe,点击进入win8pe\n\n1. 首先进行分区，选择分区工具，可以自由设置分区数目和分区大小(我分了3个区，一个用来装win7(C)，一个用来做Windows的资料盘(D)，另外一个用来安装Linux(E))\n\n双击win8pe桌面上的“diskgenius分区工具”图标，在弹出的窗口中点击“快速分区”，即可启动分区工具，具体的分区方法参考官网介绍：[老毛桃分区工具的使用](http://www.laomaotao.org/lmtjc/245.html)\n\n2. 设置好分区后，鼠标左键双击打开桌面上的“老毛桃PE装机工具”，选择“还原分区”，映像文件路径选择上一步拷入U盘的镜像，然后选择要装入的分区(C盘)，点击确认开始自动装机。\n\n3. 系统自动重启几次之后，就安装好了，可以卸载一些不必要的系统自带软件，此时的操作系统已经是激活的版本了（我下载的镜像是），各种需要的驱动也都安装完毕，简单省事。\n\n## 安装centos7\n\n### 查看磁盘分区情况\n\n右键计算机->管理，打开计算机管理程序。选择磁盘管理，查看分区情况。\n\n选择之前分好的E盘，右键“删除卷”，使之状态变为“可用空间”，以便centos安装程序识别。\n\n### 制作U盘启动工具\n\n下载centos7镜像文件（DVD版本即可）\n\n[CentOS-7-x86_64-DVD-1611.iso](http://101.96.8.151/mirror.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1611.iso)\n\n下载烧录U盘工具\n\n[ImageUsb](http://www.osforensics.com/tools/write-usb-images.html)\n\n插入一个可用的U盘\n\n启动 imageusb.exe，\n\nstep1 选择要写入的U盘;\n\nstep2 选择 write image to USB driver;\n\nstep3 选择下载好的centos7镜像文件\n\nstep4 点击 write ，开始烧录启动盘\n\n启动盘烧录完毕后，可以开始安装centos\n\n### 安装centos7\n\n插入制作好的启动盘，重启电脑\n\n开机画面出现时，按下F12 (我的电脑是DELL的，其他品牌电脑自行查找)\n\n选择USB启动\n\n选择第一项，Install CentOs 7 ，回车，开始安装CentOS 7\n\n之后就进入了简单的可视化安装界面，有几点需要注意：\n\n1.分区选择\n\n如果是像上面一样分了3个区，两个被Windows使用，还剩一个分区未被使用，\n那么可以选择自动选择分区，centos安装程序会自动选择好这块未被使用的分区（将“/”目录挂载到这个分区上面）\n\n也可以自定义分区，建议分四个区：/   /boot  /home swap（如果有这么些分区的话）\n\n2.在之后的安装信息摘要中，注意“软件”-“软件选择”，默认是最小安装，即不安装桌面环境，若选择此项，则只有命令行界面，应该选择带有UI界面的选项。\n\n之后就是很简单的安装了\n\n### 配置引导程序\n\n再次启动电脑之后，会发现自动进入Linux，没有win7系统的选项，此时需要配置引导程序\n\n首先添加ntfs支持\n\n```\nwget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo\n\nyum update;yum install ntfs-3g\n```\n\n安装完毕后打开终端，运行`grub2-mkconfig -o /boot/grub2/grub.cfg`\n\n就会重新生成引导项，重启电脑即可\n\n## 参考\n\n[老毛桃u盘安装原版win7系统详细教程](http://www.laomaotao.org/jiaocheng/upzybwin7.html)\n\n[老毛桃分区工具的使用](http://www.laomaotao.org/lmtjc/245.html)\n\n[CentOS 7.0系统安装配置图解教程](http://www.osyunwei.com/archives/7829.html)\n","slug":"win7与centos7双系统安装","published":1,"updated":"2017-02-19T13:08:11.038Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlsg0038vegc6d62hi6g","content":"<blockquote>\n<p>之前会有同学让帮忙重装操作系统，正好计划重新装一下自己电脑的系统，折腾了win7与linux双系统，在此记录。以后就可以给他们看这篇笔记自己去装啦~</p>\n<p>ps: 由于是双系统的安装操作，而不是虚拟机，所以并未截图，是纯文字说明。如果不清楚，可以参考最下面的参考链接</p>\n</blockquote>\n<h2 id=\"安装win7\"><a href=\"#安装win7\" class=\"headerlink\" title=\"安装win7\"></a>安装win7</h2><h3 id=\"下载win7镜像文件：\"><a href=\"#下载win7镜像文件：\" class=\"headerlink\" title=\"下载win7镜像文件：\"></a>下载win7镜像文件：</h3><p><a href=\"http://www.xitongzhijia.net/win7/\" target=\"_blank\" rel=\"external\">系统之家win7下载</a></p>\n<p>选择一款进行下载，我选择了<code>雨林木风 GHOST WIN7 SP1 X64 装机旗舰版 V2017.02（64位）</code></p>\n<h3 id=\"制作U盘启动工具\"><a href=\"#制作U盘启动工具\" class=\"headerlink\" title=\"制作U盘启动工具\"></a>制作U盘启动工具</h3><p>下载启动盘制作工具：</p>\n<p><a href=\"http://www.laomaotao.org/lmtxz/933.html\" target=\"_blank\" rel=\"external\">老毛桃u盘启动盘制作工具</a></p>\n<p>下载装机版，进行安装</p>\n<p>启动盘制作工具安装完成，且镜像下载完毕之后，启动老毛桃，选择U盘启动-&gt;默认模式</p>\n<p>插入一个可用的U盘，在选择设备这项中，选择插入的U盘设备，注意不要选错</p>\n<p>其他选项默认，点击 开始制作 进行启动盘的制作。</p>\n<p>启动盘制作完毕之后，将下载好的iso文件拷入U盘</p>\n<h3 id=\"安装win7-1\"><a href=\"#安装win7-1\" class=\"headerlink\" title=\"安装win7\"></a>安装win7</h3><p>插入制作好的启动盘，重启电脑</p>\n<p>开机画面出现时，按下F12，boot options(我的电脑是DELL的，其他品牌电脑自行查找)</p>\n<p>选择USB启动</p>\n<p>老毛桃启动盘正常启动，此时选择第二项，win8pe,点击进入win8pe</p>\n<ol>\n<li>首先进行分区，选择分区工具，可以自由设置分区数目和分区大小(我分了3个区，一个用来装win7(C)，一个用来做Windows的资料盘(D)，另外一个用来安装Linux(E))</li>\n</ol>\n<p>双击win8pe桌面上的“diskgenius分区工具”图标，在弹出的窗口中点击“快速分区”，即可启动分区工具，具体的分区方法参考官网介绍：<a href=\"http://www.laomaotao.org/lmtjc/245.html\" target=\"_blank\" rel=\"external\">老毛桃分区工具的使用</a></p>\n<ol>\n<li><p>设置好分区后，鼠标左键双击打开桌面上的“老毛桃PE装机工具”，选择“还原分区”，映像文件路径选择上一步拷入U盘的镜像，然后选择要装入的分区(C盘)，点击确认开始自动装机。</p>\n</li>\n<li><p>系统自动重启几次之后，就安装好了，可以卸载一些不必要的系统自带软件，此时的操作系统已经是激活的版本了（我下载的镜像是），各种需要的驱动也都安装完毕，简单省事。</p>\n</li>\n</ol>\n<h2 id=\"安装centos7\"><a href=\"#安装centos7\" class=\"headerlink\" title=\"安装centos7\"></a>安装centos7</h2><h3 id=\"查看磁盘分区情况\"><a href=\"#查看磁盘分区情况\" class=\"headerlink\" title=\"查看磁盘分区情况\"></a>查看磁盘分区情况</h3><p>右键计算机-&gt;管理，打开计算机管理程序。选择磁盘管理，查看分区情况。</p>\n<p>选择之前分好的E盘，右键“删除卷”，使之状态变为“可用空间”，以便centos安装程序识别。</p>\n<h3 id=\"制作U盘启动工具-1\"><a href=\"#制作U盘启动工具-1\" class=\"headerlink\" title=\"制作U盘启动工具\"></a>制作U盘启动工具</h3><p>下载centos7镜像文件（DVD版本即可）</p>\n<p><a href=\"http://101.96.8.151/mirror.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1611.iso\" target=\"_blank\" rel=\"external\">CentOS-7-x86_64-DVD-1611.iso</a></p>\n<p>下载烧录U盘工具</p>\n<p><a href=\"http://www.osforensics.com/tools/write-usb-images.html\" target=\"_blank\" rel=\"external\">ImageUsb</a></p>\n<p>插入一个可用的U盘</p>\n<p>启动 imageusb.exe，</p>\n<p>step1 选择要写入的U盘;</p>\n<p>step2 选择 write image to USB driver;</p>\n<p>step3 选择下载好的centos7镜像文件</p>\n<p>step4 点击 write ，开始烧录启动盘</p>\n<p>启动盘烧录完毕后，可以开始安装centos</p>\n<h3 id=\"安装centos7-1\"><a href=\"#安装centos7-1\" class=\"headerlink\" title=\"安装centos7\"></a>安装centos7</h3><p>插入制作好的启动盘，重启电脑</p>\n<p>开机画面出现时，按下F12 (我的电脑是DELL的，其他品牌电脑自行查找)</p>\n<p>选择USB启动</p>\n<p>选择第一项，Install CentOs 7 ，回车，开始安装CentOS 7</p>\n<p>之后就进入了简单的可视化安装界面，有几点需要注意：</p>\n<p>1.分区选择</p>\n<p>如果是像上面一样分了3个区，两个被Windows使用，还剩一个分区未被使用，<br>那么可以选择自动选择分区，centos安装程序会自动选择好这块未被使用的分区（将“/”目录挂载到这个分区上面）</p>\n<p>也可以自定义分区，建议分四个区：/   /boot  /home swap（如果有这么些分区的话）</p>\n<p>2.在之后的安装信息摘要中，注意“软件”-“软件选择”，默认是最小安装，即不安装桌面环境，若选择此项，则只有命令行界面，应该选择带有UI界面的选项。</p>\n<p>之后就是很简单的安装了</p>\n<h3 id=\"配置引导程序\"><a href=\"#配置引导程序\" class=\"headerlink\" title=\"配置引导程序\"></a>配置引导程序</h3><p>再次启动电脑之后，会发现自动进入Linux，没有win7系统的选项，此时需要配置引导程序</p>\n<p>首先添加ntfs支持</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</div><div class=\"line\"></div><div class=\"line\">yum update;yum install ntfs-3g</div></pre></td></tr></table></figure>\n<p>安装完毕后打开终端，运行<code>grub2-mkconfig -o /boot/grub2/grub.cfg</code></p>\n<p>就会重新生成引导项，重启电脑即可</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.laomaotao.org/jiaocheng/upzybwin7.html\" target=\"_blank\" rel=\"external\">老毛桃u盘安装原版win7系统详细教程</a></p>\n<p><a href=\"http://www.laomaotao.org/lmtjc/245.html\" target=\"_blank\" rel=\"external\">老毛桃分区工具的使用</a></p>\n<p><a href=\"http://www.osyunwei.com/archives/7829.html\" target=\"_blank\" rel=\"external\">CentOS 7.0系统安装配置图解教程</a></p>\n","excerpt":"","more":"<blockquote>\n<p>之前会有同学让帮忙重装操作系统，正好计划重新装一下自己电脑的系统，折腾了win7与linux双系统，在此记录。以后就可以给他们看这篇笔记自己去装啦~</p>\n<p>ps: 由于是双系统的安装操作，而不是虚拟机，所以并未截图，是纯文字说明。如果不清楚，可以参考最下面的参考链接</p>\n</blockquote>\n<h2 id=\"安装win7\"><a href=\"#安装win7\" class=\"headerlink\" title=\"安装win7\"></a>安装win7</h2><h3 id=\"下载win7镜像文件：\"><a href=\"#下载win7镜像文件：\" class=\"headerlink\" title=\"下载win7镜像文件：\"></a>下载win7镜像文件：</h3><p><a href=\"http://www.xitongzhijia.net/win7/\">系统之家win7下载</a></p>\n<p>选择一款进行下载，我选择了<code>雨林木风 GHOST WIN7 SP1 X64 装机旗舰版 V2017.02（64位）</code></p>\n<h3 id=\"制作U盘启动工具\"><a href=\"#制作U盘启动工具\" class=\"headerlink\" title=\"制作U盘启动工具\"></a>制作U盘启动工具</h3><p>下载启动盘制作工具：</p>\n<p><a href=\"http://www.laomaotao.org/lmtxz/933.html\">老毛桃u盘启动盘制作工具</a></p>\n<p>下载装机版，进行安装</p>\n<p>启动盘制作工具安装完成，且镜像下载完毕之后，启动老毛桃，选择U盘启动-&gt;默认模式</p>\n<p>插入一个可用的U盘，在选择设备这项中，选择插入的U盘设备，注意不要选错</p>\n<p>其他选项默认，点击 开始制作 进行启动盘的制作。</p>\n<p>启动盘制作完毕之后，将下载好的iso文件拷入U盘</p>\n<h3 id=\"安装win7-1\"><a href=\"#安装win7-1\" class=\"headerlink\" title=\"安装win7\"></a>安装win7</h3><p>插入制作好的启动盘，重启电脑</p>\n<p>开机画面出现时，按下F12，boot options(我的电脑是DELL的，其他品牌电脑自行查找)</p>\n<p>选择USB启动</p>\n<p>老毛桃启动盘正常启动，此时选择第二项，win8pe,点击进入win8pe</p>\n<ol>\n<li>首先进行分区，选择分区工具，可以自由设置分区数目和分区大小(我分了3个区，一个用来装win7(C)，一个用来做Windows的资料盘(D)，另外一个用来安装Linux(E))</li>\n</ol>\n<p>双击win8pe桌面上的“diskgenius分区工具”图标，在弹出的窗口中点击“快速分区”，即可启动分区工具，具体的分区方法参考官网介绍：<a href=\"http://www.laomaotao.org/lmtjc/245.html\">老毛桃分区工具的使用</a></p>\n<ol>\n<li><p>设置好分区后，鼠标左键双击打开桌面上的“老毛桃PE装机工具”，选择“还原分区”，映像文件路径选择上一步拷入U盘的镜像，然后选择要装入的分区(C盘)，点击确认开始自动装机。</p>\n</li>\n<li><p>系统自动重启几次之后，就安装好了，可以卸载一些不必要的系统自带软件，此时的操作系统已经是激活的版本了（我下载的镜像是），各种需要的驱动也都安装完毕，简单省事。</p>\n</li>\n</ol>\n<h2 id=\"安装centos7\"><a href=\"#安装centos7\" class=\"headerlink\" title=\"安装centos7\"></a>安装centos7</h2><h3 id=\"查看磁盘分区情况\"><a href=\"#查看磁盘分区情况\" class=\"headerlink\" title=\"查看磁盘分区情况\"></a>查看磁盘分区情况</h3><p>右键计算机-&gt;管理，打开计算机管理程序。选择磁盘管理，查看分区情况。</p>\n<p>选择之前分好的E盘，右键“删除卷”，使之状态变为“可用空间”，以便centos安装程序识别。</p>\n<h3 id=\"制作U盘启动工具-1\"><a href=\"#制作U盘启动工具-1\" class=\"headerlink\" title=\"制作U盘启动工具\"></a>制作U盘启动工具</h3><p>下载centos7镜像文件（DVD版本即可）</p>\n<p><a href=\"http://101.96.8.151/mirror.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1611.iso\">CentOS-7-x86_64-DVD-1611.iso</a></p>\n<p>下载烧录U盘工具</p>\n<p><a href=\"http://www.osforensics.com/tools/write-usb-images.html\">ImageUsb</a></p>\n<p>插入一个可用的U盘</p>\n<p>启动 imageusb.exe，</p>\n<p>step1 选择要写入的U盘;</p>\n<p>step2 选择 write image to USB driver;</p>\n<p>step3 选择下载好的centos7镜像文件</p>\n<p>step4 点击 write ，开始烧录启动盘</p>\n<p>启动盘烧录完毕后，可以开始安装centos</p>\n<h3 id=\"安装centos7-1\"><a href=\"#安装centos7-1\" class=\"headerlink\" title=\"安装centos7\"></a>安装centos7</h3><p>插入制作好的启动盘，重启电脑</p>\n<p>开机画面出现时，按下F12 (我的电脑是DELL的，其他品牌电脑自行查找)</p>\n<p>选择USB启动</p>\n<p>选择第一项，Install CentOs 7 ，回车，开始安装CentOS 7</p>\n<p>之后就进入了简单的可视化安装界面，有几点需要注意：</p>\n<p>1.分区选择</p>\n<p>如果是像上面一样分了3个区，两个被Windows使用，还剩一个分区未被使用，<br>那么可以选择自动选择分区，centos安装程序会自动选择好这块未被使用的分区（将“/”目录挂载到这个分区上面）</p>\n<p>也可以自定义分区，建议分四个区：/   /boot  /home swap（如果有这么些分区的话）</p>\n<p>2.在之后的安装信息摘要中，注意“软件”-“软件选择”，默认是最小安装，即不安装桌面环境，若选择此项，则只有命令行界面，应该选择带有UI界面的选项。</p>\n<p>之后就是很简单的安装了</p>\n<h3 id=\"配置引导程序\"><a href=\"#配置引导程序\" class=\"headerlink\" title=\"配置引导程序\"></a>配置引导程序</h3><p>再次启动电脑之后，会发现自动进入Linux，没有win7系统的选项，此时需要配置引导程序</p>\n<p>首先添加ntfs支持</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</div><div class=\"line\"></div><div class=\"line\">yum update;yum install ntfs-3g</div></pre></td></tr></table></figure>\n<p>安装完毕后打开终端，运行<code>grub2-mkconfig -o /boot/grub2/grub.cfg</code></p>\n<p>就会重新生成引导项，重启电脑即可</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.laomaotao.org/jiaocheng/upzybwin7.html\">老毛桃u盘安装原版win7系统详细教程</a></p>\n<p><a href=\"http://www.laomaotao.org/lmtjc/245.html\">老毛桃分区工具的使用</a></p>\n<p><a href=\"http://www.osyunwei.com/archives/7829.html\">CentOS 7.0系统安装配置图解教程</a></p>\n"},{"layout":"post","date":"2016-08-15T06:54:55.000Z","title":"一些计划","comments":0,"_content":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe>\n转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。\n\n上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的[作者](https://github.com/A-limon/pacman)，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名[www.yukai.space](www.yukai.space)作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。\n\n## 关于学习\n\n程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：\n\n### java\n\n吃饭的家伙，必须得用好了。虽然用java写过不少\"小DEMO\",但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：\n\n- Thinking In Java\n\n- Effect Java\n\n- 大话设计模式\n\n- 深入理解Jvm虚拟机\n\n- 重构：改善既有的代码\n\n前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。\n\n### Linux\n\n一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。\n\n从 鸟哥的Linux私房菜 开始吧。\n\n### Groovy\n\n第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。\n\n### 数据库\n\n说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把<<数据库系统概论>>通读一遍吧。贪多嚼不烂。\n\n以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。\n\n## 关于减肥\n\n确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：\n\n腹肌轮：80\n\n卷腹：50\n\n哑铃深蹲：40\n\n俯卧撑：80\n\n其他健身动作：若干\n\n跑步：一周至少三次\n\n## 关于理财\n\n写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。\n\n写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。\n\n以上","source":"_posts/一些计划.md","raw":"---\nlayout: post\ndate: 2016-08-15 14:54:55\ncategories: 生活\ntitle: 一些计划\ncomments: false\n---\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe>\n转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。\n\n上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的[作者](https://github.com/A-limon/pacman)，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名[www.yukai.space](www.yukai.space)作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。\n\n## 关于学习\n\n程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：\n\n### java\n\n吃饭的家伙，必须得用好了。虽然用java写过不少\"小DEMO\",但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：\n\n- Thinking In Java\n\n- Effect Java\n\n- 大话设计模式\n\n- 深入理解Jvm虚拟机\n\n- 重构：改善既有的代码\n\n前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。\n\n### Linux\n\n一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。\n\n从 鸟哥的Linux私房菜 开始吧。\n\n### Groovy\n\n第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。\n\n### 数据库\n\n说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把<<数据库系统概论>>通读一遍吧。贪多嚼不烂。\n\n以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。\n\n## 关于减肥\n\n确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：\n\n腹肌轮：80\n\n卷腹：50\n\n哑铃深蹲：40\n\n俯卧撑：80\n\n其他健身动作：若干\n\n跑步：一周至少三次\n\n## 关于理财\n\n写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。\n\n写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。\n\n以上","slug":"一些计划","published":1,"updated":"2017-02-19T13:08:11.038Z","photos":[],"link":"","_id":"cj0xuzlsi003bvegc3u2ma52f","content":"<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe><br>转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。</p>\n<p>上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的<a href=\"https://github.com/A-limon/pacman\" target=\"_blank\" rel=\"external\">作者</a>，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名<a href=\"www.yukai.space\">www.yukai.space</a>作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。</p>\n<h2 id=\"关于学习\"><a href=\"#关于学习\" class=\"headerlink\" title=\"关于学习\"></a>关于学习</h2><p>程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：</p>\n<h3 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h3><p>吃饭的家伙，必须得用好了。虽然用java写过不少”小DEMO”,但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：</p>\n<ul>\n<li><p>Thinking In Java</p>\n</li>\n<li><p>Effect Java</p>\n</li>\n<li><p>大话设计模式</p>\n</li>\n<li><p>深入理解Jvm虚拟机</p>\n</li>\n<li><p>重构：改善既有的代码</p>\n</li>\n</ul>\n<p>前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。</p>\n<h3 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h3><p>一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。</p>\n<p>从 鸟哥的Linux私房菜 开始吧。</p>\n<h3 id=\"Groovy\"><a href=\"#Groovy\" class=\"headerlink\" title=\"Groovy\"></a>Groovy</h3><p>第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。</p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把&lt;&lt;数据库系统概论&gt;&gt;通读一遍吧。贪多嚼不烂。</p>\n<p>以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。</p>\n<h2 id=\"关于减肥\"><a href=\"#关于减肥\" class=\"headerlink\" title=\"关于减肥\"></a>关于减肥</h2><p>确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：</p>\n<p>腹肌轮：80</p>\n<p>卷腹：50</p>\n<p>哑铃深蹲：40</p>\n<p>俯卧撑：80</p>\n<p>其他健身动作：若干</p>\n<p>跑步：一周至少三次</p>\n<h2 id=\"关于理财\"><a href=\"#关于理财\" class=\"headerlink\" title=\"关于理财\"></a>关于理财</h2><p>写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。</p>\n<p>写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。</p>\n<p>以上</p>\n","excerpt":"","more":"<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe><br>转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。</p>\n<p>上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的<a href=\"https://github.com/A-limon/pacman\">作者</a>，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名<a href=\"www.yukai.space\">www.yukai.space</a>作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。</p>\n<h2 id=\"关于学习\"><a href=\"#关于学习\" class=\"headerlink\" title=\"关于学习\"></a>关于学习</h2><p>程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：</p>\n<h3 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h3><p>吃饭的家伙，必须得用好了。虽然用java写过不少”小DEMO”,但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：</p>\n<ul>\n<li><p>Thinking In Java</p>\n</li>\n<li><p>Effect Java</p>\n</li>\n<li><p>大话设计模式</p>\n</li>\n<li><p>深入理解Jvm虚拟机</p>\n</li>\n<li><p>重构：改善既有的代码</p>\n</li>\n</ul>\n<p>前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。</p>\n<h3 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h3><p>一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。</p>\n<p>从 鸟哥的Linux私房菜 开始吧。</p>\n<h3 id=\"Groovy\"><a href=\"#Groovy\" class=\"headerlink\" title=\"Groovy\"></a>Groovy</h3><p>第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。</p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把&lt;&lt;数据库系统概论&gt;&gt;通读一遍吧。贪多嚼不烂。</p>\n<p>以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。</p>\n<h2 id=\"关于减肥\"><a href=\"#关于减肥\" class=\"headerlink\" title=\"关于减肥\"></a>关于减肥</h2><p>确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：</p>\n<p>腹肌轮：80</p>\n<p>卷腹：50</p>\n<p>哑铃深蹲：40</p>\n<p>俯卧撑：80</p>\n<p>其他健身动作：若干</p>\n<p>跑步：一周至少三次</p>\n<h2 id=\"关于理财\"><a href=\"#关于理财\" class=\"headerlink\" title=\"关于理财\"></a>关于理财</h2><p>写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。</p>\n<p>写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。</p>\n<p>以上</p>\n"},{"layout":"post","date":"2016-07-31T09:30:55.000Z","title":"为什么是final","_content":"\n>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。\n\n注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。\n\n例子是这样的：\n\n```java\npublic class Outer {\n\tprivate int outerVar=0;\n\tpublic void testInner(final String paramVal){\n\t\tfinal Integer localVal = 1;\n\t\tInner inner = new Inner(){\n\t\t\t@Override\n\t\t\tpublic void doSomething() {\n\t\t\t\tSystem.out.println(localVal+paramVal);\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tfinal int localVal1 = 2;\n\t\tclass Inner2{\n\t\t\tpublic void testInner2(){\n\t\t\t\tSystem.out.println(localVal1);\n\t\t\t}\n\t\t}\n\t}\n\tinterface Inner{\n\t\tpublic void doSomething();\n\t}\n\tpublic static void main(String args[]){\n\t\tOuter outer = new Outer();\n\t\touter.testInner(\"hello\");\n\t}\n}\n```\n\n可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。\n\n后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。\n\n我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）\n\n但是确实生成了这样几个.class文件：\n\nOuter.class:class Outer\n\nOuter$1.class:匿名内部类 new Inner(){...}\n\nOuter$1Inner2.class:class Inner2\n\nOuter$Inner.class:interface Inner\n\n这说明，匿名内部类与他的外围类之间确实是相互独立的。\n\n为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：\n\n```java\nclass kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner {\n  final java.lang.Integer val$localVar;\n\n  final java.lang.String val$paramVal;\n\n  final kyu.java.util.Outer this$0;\n\n  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);\n    Code:\n       0: aload_0\n       1: aload_1\n       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;\n       5: aload_0\n       6: aload_2\n       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;\n      10: aload_0\n      11: aload_3\n      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;\n      15: aload_0\n      16: invokespecial #4                  // Method java/lang/Object.\"<init>\":()V\n      19: return\n\n      .....\n }\n```\n\n上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参\n。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。\n\n所以，现在有两个问题：\n\n- **为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？**\n\n我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。\n\n- **局部变量或形参为什么必须是final类型？**\n\n在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。\n\n```java\nfinal Integer localVal = 1;\nInner inner = new Inner(){\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(localVar+paramVal);\n\t}\n};\n```\n\n这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。\n\nps:后来在stackoverflow上看到[Why are only final variables accessible in anonymous class?](http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class)，可以参考一下。","source":"_posts/为什么是final.md","raw":"---\nlayout: post\ndate:   2016-07-31 17:30:55\ntitle: \"为什么是final\"\ncategories: 编程\ntags: \n- java\n---\n\n>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。\n\n注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。\n\n例子是这样的：\n\n```java\npublic class Outer {\n\tprivate int outerVar=0;\n\tpublic void testInner(final String paramVal){\n\t\tfinal Integer localVal = 1;\n\t\tInner inner = new Inner(){\n\t\t\t@Override\n\t\t\tpublic void doSomething() {\n\t\t\t\tSystem.out.println(localVal+paramVal);\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tfinal int localVal1 = 2;\n\t\tclass Inner2{\n\t\t\tpublic void testInner2(){\n\t\t\t\tSystem.out.println(localVal1);\n\t\t\t}\n\t\t}\n\t}\n\tinterface Inner{\n\t\tpublic void doSomething();\n\t}\n\tpublic static void main(String args[]){\n\t\tOuter outer = new Outer();\n\t\touter.testInner(\"hello\");\n\t}\n}\n```\n\n可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。\n\n后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。\n\n我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）\n\n但是确实生成了这样几个.class文件：\n\nOuter.class:class Outer\n\nOuter$1.class:匿名内部类 new Inner(){...}\n\nOuter$1Inner2.class:class Inner2\n\nOuter$Inner.class:interface Inner\n\n这说明，匿名内部类与他的外围类之间确实是相互独立的。\n\n为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：\n\n```java\nclass kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner {\n  final java.lang.Integer val$localVar;\n\n  final java.lang.String val$paramVal;\n\n  final kyu.java.util.Outer this$0;\n\n  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);\n    Code:\n       0: aload_0\n       1: aload_1\n       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;\n       5: aload_0\n       6: aload_2\n       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;\n      10: aload_0\n      11: aload_3\n      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;\n      15: aload_0\n      16: invokespecial #4                  // Method java/lang/Object.\"<init>\":()V\n      19: return\n\n      .....\n }\n```\n\n上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参\n。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。\n\n所以，现在有两个问题：\n\n- **为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？**\n\n我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。\n\n- **局部变量或形参为什么必须是final类型？**\n\n在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。\n\n```java\nfinal Integer localVal = 1;\nInner inner = new Inner(){\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(localVar+paramVal);\n\t}\n};\n```\n\n这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。\n\nps:后来在stackoverflow上看到[Why are only final variables accessible in anonymous class?](http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class)，可以参考一下。","slug":"为什么是final","published":1,"updated":"2017-02-19T13:08:11.038Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlsk003fvegcc9tczim0","content":"<blockquote>\n<p>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。</p>\n</blockquote>\n<p>注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。</p>\n<p>例子是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> outerVar=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner</span><span class=\"params\">(<span class=\"keyword\">final</span> String paramVal)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">\t\tInner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal+paramVal);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localVal1 = <span class=\"number\">2</span>;</div><div class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner2</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal1);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Inner</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tOuter outer = <span class=\"keyword\">new</span> Outer();</div><div class=\"line\">\t\touter.testInner(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。</p>\n<p>后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。</p>\n<p>我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）</p>\n<p>但是确实生成了这样几个.class文件：</p>\n<p>Outer.class:class Outer</p>\n<p>Outer$1.class:匿名内部类 new Inner(){…}</p>\n<p>Outer$1Inner2.class:class Inner2</p>\n<p>Outer$Inner.class:interface Inner</p>\n<p>这说明，匿名内部类与他的外围类之间确实是相互独立的。</p>\n<p>为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner &#123;</div><div class=\"line\">  final java.lang.Integer val$localVar;</div><div class=\"line\"></div><div class=\"line\">  final java.lang.String val$paramVal;</div><div class=\"line\"></div><div class=\"line\">  final kyu.java.util.Outer this$0;</div><div class=\"line\"></div><div class=\"line\">  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);</div><div class=\"line\">    Code:</div><div class=\"line\">       0: aload_0</div><div class=\"line\">       1: aload_1</div><div class=\"line\">       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;</div><div class=\"line\">       5: aload_0</div><div class=\"line\">       6: aload_2</div><div class=\"line\">       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;</div><div class=\"line\">      10: aload_0</div><div class=\"line\">      11: aload_3</div><div class=\"line\">      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;</div><div class=\"line\">      15: aload_0</div><div class=\"line\">      16: invokespecial #4                  // Method java/lang/Object.\"&lt;init&gt;\":()V</div><div class=\"line\">      19: return</div><div class=\"line\"></div><div class=\"line\">      .....</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参<br>。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。</p>\n<p>所以，现在有两个问题：</p>\n<ul>\n<li><strong>为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？</strong></li>\n</ul>\n<p>我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。</p>\n<ul>\n<li><strong>局部变量或形参为什么必须是final类型？</strong></li>\n</ul>\n<p>在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">Inner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(localVar+paramVal);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。</p>\n<p>ps:后来在stackoverflow上看到<a href=\"http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class\" target=\"_blank\" rel=\"external\">Why are only final variables accessible in anonymous class?</a>，可以参考一下。</p>\n","excerpt":"","more":"<blockquote>\n<p>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。</p>\n</blockquote>\n<p>注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。</p>\n<p>例子是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> outerVar=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner</span><span class=\"params\">(<span class=\"keyword\">final</span> String paramVal)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">\t\tInner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal+paramVal);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localVal1 = <span class=\"number\">2</span>;</div><div class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner2</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal1);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Inner</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tOuter outer = <span class=\"keyword\">new</span> Outer();</div><div class=\"line\">\t\touter.testInner(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。</p>\n<p>后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。</p>\n<p>我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）</p>\n<p>但是确实生成了这样几个.class文件：</p>\n<p>Outer.class:class Outer</p>\n<p>Outer$1.class:匿名内部类 new Inner(){…}</p>\n<p>Outer$1Inner2.class:class Inner2</p>\n<p>Outer$Inner.class:interface Inner</p>\n<p>这说明，匿名内部类与他的外围类之间确实是相互独立的。</p>\n<p>为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner &#123;</div><div class=\"line\">  final java.lang.Integer val$localVar;</div><div class=\"line\"></div><div class=\"line\">  final java.lang.String val$paramVal;</div><div class=\"line\"></div><div class=\"line\">  final kyu.java.util.Outer this$0;</div><div class=\"line\"></div><div class=\"line\">  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);</div><div class=\"line\">    Code:</div><div class=\"line\">       0: aload_0</div><div class=\"line\">       1: aload_1</div><div class=\"line\">       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;</div><div class=\"line\">       5: aload_0</div><div class=\"line\">       6: aload_2</div><div class=\"line\">       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;</div><div class=\"line\">      10: aload_0</div><div class=\"line\">      11: aload_3</div><div class=\"line\">      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;</div><div class=\"line\">      15: aload_0</div><div class=\"line\">      16: invokespecial #4                  // Method java/lang/Object.\"&lt;init&gt;\":()V</div><div class=\"line\">      19: return</div><div class=\"line\"></div><div class=\"line\">      .....</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参<br>。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。</p>\n<p>所以，现在有两个问题：</p>\n<ul>\n<li><strong>为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？</strong></li>\n</ul>\n<p>我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。</p>\n<ul>\n<li><strong>局部变量或形参为什么必须是final类型？</strong></li>\n</ul>\n<p>在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">Inner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(localVar+paramVal);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。</p>\n<p>ps:后来在stackoverflow上看到<a href=\"http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class\">Why are only final variables accessible in anonymous class?</a>，可以参考一下。</p>\n"},{"layout":"post","date":"2016-04-14T05:48:55.000Z","title":"他可是科比布莱恩特","_content":"<center>\n\t<iframe \n\t\twidth=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen>\n\t</iframe>\n</center>\nwhat can i say, Mamba out！\n\n{% asset_img kobe.jpg 科比 %}\n\n\n\n","source":"_posts/他可是科比·布莱恩特!.md","raw":"---\nlayout: post\ndate:   2016-04-14 13:48:55\ntitle: \"他可是科比布莱恩特\"\ncategories: 生活\n---\n<center>\n\t<iframe \n\t\twidth=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen>\n\t</iframe>\n</center>\nwhat can i say, Mamba out！\n\n{% asset_img kobe.jpg 科比 %}\n\n\n\n","slug":"他可是科比·布莱恩特!","published":1,"updated":"2017-02-19T13:08:11.038Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlsm003jvegcxsz3x41m","content":"<p><center><br>    <iframe width=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen><br>    </iframe><br></center><br>what can i say, Mamba out！</p>\n<img src=\"/2016/04/14/他可是科比·布莱恩特!/kobe.jpg\" alt=\"科比\" title=\"科比\">\n","excerpt":"","more":"<p><center><br>    <iframe \n        width=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen><br>    </iframe><br></center><br>what can i say, Mamba out！</p>\n<img src=\"/2016/04/14/他可是科比·布莱恩特!/kobe.jpg\" alt=\"科比\" title=\"科比\">\n"},{"layout":"post","title":"代码规范","date":"2016-03-29T08:31:55.000Z","_content":"\n>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。\n 所以决定总结一些规范，以后写代码要注意了~\n\n- ## **命名**\n\n  - 变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名\n\n  - 避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean\n\n  1. 方法\n\n     方法名第一个单词小写，以后每个单词首字母大写。\n\n  2. 类、接口\n\n     所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词\n\n  3. 字段、常量\n\n     成员变量、局部变量第一个单词小写，如 userName, instance。\n\n     常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。\n\n     代码中禁止使用硬编码，把一些数字或字符串定义成常用量。\n\n- ## **注释**\n\n  1. 成员变量注释\n\n    ```java\n    /** 成员变量注释 */\n    protected Object mObject0;\n\n    /**\n     * 对于注释多于一行的，采用这种方式来\n     * 定义该变量\n     */\n    private Object mObject4;\n    ```\n\n  2. 方法描述\n\n    ```java\n    /**\n      * 方法描述...\n      * \n      * @param param1  参数1描述...\n      * @param param2  参数2描述...\n      * @param paramXX 参数XX描述... （注意：请将参数、描述都对齐）\n      */\n      public void doSomething(int param1, float param2, String paramXX) {}\n    ```\n\n  3.方法内部注释\n\n    可以使用 /*注释*/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。\n    \n    ```java\n    if (a == 2) {\n        return TRUE;            /* special case */\n    } else {    \n        return isprime(a);      /* works only for odd a */}\n    ```\n\n\n- ## **换行、空格**\n\n  - **换行**\n\n    当代码过长造成阅读困难的时候，就应该考虑代码换行。\n\n    有这么几个原则：\n\n    1.在逗号之后换行\n\n    2.在操作符之前换行\n\n    3.考虑在表达式的外层就换行，而不是内层\n\n    4.新一行的开头应该与前一行的同一级代码对齐\n\n    5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。\n\n    **示例**\n\n    ```java\n    function(longExpression1, longExpression2, longExpression3,         \n             longExpression4, longExpression5);\n\n    var = function1(longExpression1,                \n                   function2(longExpression2,\n                             longExpression3));\n    ```\n\n    在表达式外层换行：\n\n    ```java\n    longName1 = longName2 * (longName3 + longName4 - longName5)\n                + 4 * longname6; // PREFER\n\n    longName1 = longName2 * (longName3 + longName4\n                             - longName5) + 4 * longname6; // AVOID\n\n    ```\n\n    插入8个空格的情况\n\n    ```java\n    //INDENT 8 SPACES TO AVOID VERY DEEP INDENTS\n    private static synchronized horkingLongMethodName(int anArg,\n            Object anotherArg, String yetAnotherArg,\n            Object andStillAnother) {    \n         ...\n    } \n\n    //条件表达式8空格原则\n    if ((condition1 && condition2)\n            || (condition3 && condition4)\n            ||!(condition5 && condition6)) {\n        doSomethingAboutIt();\n    }\n    ```\n\n  - **空格**\n\n    1.`{`内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。\n\n    2. 操作符左右，大括号`{}`左右，等于号左右都要有一个空格的间距。\nf\n\n- ## **参考**\n\n  [JavaCode Conventions](http://www.oracle.com/technetwork/java/codeconventions-150003.pdf)","source":"_posts/代码格式.md","raw":"---\nlayout: post\ntitle:  \"代码规范\"\ndate:   2016-03-29 16:31:55\ncategories: 编程 \ntags: \n- java\n---\n\n>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。\n 所以决定总结一些规范，以后写代码要注意了~\n\n- ## **命名**\n\n  - 变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名\n\n  - 避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean\n\n  1. 方法\n\n     方法名第一个单词小写，以后每个单词首字母大写。\n\n  2. 类、接口\n\n     所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词\n\n  3. 字段、常量\n\n     成员变量、局部变量第一个单词小写，如 userName, instance。\n\n     常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。\n\n     代码中禁止使用硬编码，把一些数字或字符串定义成常用量。\n\n- ## **注释**\n\n  1. 成员变量注释\n\n    ```java\n    /** 成员变量注释 */\n    protected Object mObject0;\n\n    /**\n     * 对于注释多于一行的，采用这种方式来\n     * 定义该变量\n     */\n    private Object mObject4;\n    ```\n\n  2. 方法描述\n\n    ```java\n    /**\n      * 方法描述...\n      * \n      * @param param1  参数1描述...\n      * @param param2  参数2描述...\n      * @param paramXX 参数XX描述... （注意：请将参数、描述都对齐）\n      */\n      public void doSomething(int param1, float param2, String paramXX) {}\n    ```\n\n  3.方法内部注释\n\n    可以使用 /*注释*/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。\n    \n    ```java\n    if (a == 2) {\n        return TRUE;            /* special case */\n    } else {    \n        return isprime(a);      /* works only for odd a */}\n    ```\n\n\n- ## **换行、空格**\n\n  - **换行**\n\n    当代码过长造成阅读困难的时候，就应该考虑代码换行。\n\n    有这么几个原则：\n\n    1.在逗号之后换行\n\n    2.在操作符之前换行\n\n    3.考虑在表达式的外层就换行，而不是内层\n\n    4.新一行的开头应该与前一行的同一级代码对齐\n\n    5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。\n\n    **示例**\n\n    ```java\n    function(longExpression1, longExpression2, longExpression3,         \n             longExpression4, longExpression5);\n\n    var = function1(longExpression1,                \n                   function2(longExpression2,\n                             longExpression3));\n    ```\n\n    在表达式外层换行：\n\n    ```java\n    longName1 = longName2 * (longName3 + longName4 - longName5)\n                + 4 * longname6; // PREFER\n\n    longName1 = longName2 * (longName3 + longName4\n                             - longName5) + 4 * longname6; // AVOID\n\n    ```\n\n    插入8个空格的情况\n\n    ```java\n    //INDENT 8 SPACES TO AVOID VERY DEEP INDENTS\n    private static synchronized horkingLongMethodName(int anArg,\n            Object anotherArg, String yetAnotherArg,\n            Object andStillAnother) {    \n         ...\n    } \n\n    //条件表达式8空格原则\n    if ((condition1 && condition2)\n            || (condition3 && condition4)\n            ||!(condition5 && condition6)) {\n        doSomethingAboutIt();\n    }\n    ```\n\n  - **空格**\n\n    1.`{`内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。\n\n    2. 操作符左右，大括号`{}`左右，等于号左右都要有一个空格的间距。\nf\n\n- ## **参考**\n\n  [JavaCode Conventions](http://www.oracle.com/technetwork/java/codeconventions-150003.pdf)","slug":"代码格式","published":1,"updated":"2017-02-19T13:08:11.038Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlso003mvegcewnuja1u","content":"<blockquote>\n<p>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。<br> 所以决定总结一些规范，以后写代码要注意了~</p>\n</blockquote>\n<ul>\n<li><h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a><strong>命名</strong></h2><ul>\n<li><p>变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名</p>\n</li>\n<li><p>避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean</p>\n</li>\n</ul>\n<ol>\n<li><p>方法</p>\n<p>方法名第一个单词小写，以后每个单词首字母大写。</p>\n</li>\n<li><p>类、接口</p>\n<p>所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词</p>\n</li>\n<li><p>字段、常量</p>\n<p>成员变量、局部变量第一个单词小写，如 userName, instance。</p>\n<p>常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。</p>\n<p>代码中禁止使用硬编码，把一些数字或字符串定义成常用量。</p>\n</li>\n</ol>\n</li>\n<li><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a><strong>注释</strong></h2><ol>\n<li><p>成员变量注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** 成员变量注释 */</span></div><div class=\"line\"><span class=\"keyword\">protected</span> Object mObject0;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 对于注释多于一行的，采用这种方式来</div><div class=\"line\"> * 定义该变量</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">private</span> Object mObject4;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方法描述</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * 方法描述...</div><div class=\"line\">  * </div><div class=\"line\">  * <span class=\"doctag\">@param</span> param1  参数1描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> param2  参数2描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> paramXX 参数XX描述... （注意：请将参数、描述都对齐）</div><div class=\"line\">  */</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> param1, <span class=\"keyword\">float</span> param2, String paramXX)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.方法内部注释</p>\n<p>  可以使用 /<em>注释</em>/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> TRUE;            <span class=\"comment\">/* special case */</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">    <span class=\"keyword\">return</span> isprime(a);      <span class=\"comment\">/* works only for odd a */</span>&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><h2 id=\"换行、空格\"><a href=\"#换行、空格\" class=\"headerlink\" title=\"换行、空格\"></a><strong>换行、空格</strong></h2><ul>\n<li><p><strong>换行</strong></p>\n<p>当代码过长造成阅读困难的时候，就应该考虑代码换行。</p>\n<p>有这么几个原则：</p>\n<p>1.在逗号之后换行</p>\n<p>2.在操作符之前换行</p>\n<p>3.考虑在表达式的外层就换行，而不是内层</p>\n<p>4.新一行的开头应该与前一行的同一级代码对齐</p>\n<p>5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(longExpression1, longExpression2, longExpression3,         </div><div class=\"line\">         longExpression4, longExpression5);</div><div class=\"line\"></div><div class=\"line\">var = function1(longExpression1,                </div><div class=\"line\">               function2(longExpression2,</div><div class=\"line\">                         longExpression3));</div></pre></td></tr></table></figure>\n<p>在表达式外层换行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">longName1 = longName2 * (longName3 + longName4 - longName5)</div><div class=\"line\">            + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// PREFER</span></div><div class=\"line\"></div><div class=\"line\">longName1 = longName2 * (longName3 + longName4</div><div class=\"line\">                         - longName5) + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// AVOID</span></div></pre></td></tr></table></figure>\n<p>插入8个空格的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//INDENT 8 SPACES TO AVOID VERY DEEP INDENTS</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">horkingLongMethodName</span><span class=\"params\">(<span class=\"keyword\">int</span> anArg,</span></span></div><div class=\"line\">        Object anotherArg, String yetAnotherArg,</div><div class=\"line\">        Object andStillAnother) &#123;    </div><div class=\"line\">     ...</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//条件表达式8空格原则</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((condition1 &amp;&amp; condition2)</div><div class=\"line\">        || (condition3 &amp;&amp; condition4)</div><div class=\"line\">        ||!(condition5 &amp;&amp; condition6)) &#123;</div><div class=\"line\">    doSomethingAboutIt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>空格</strong></p>\n<p>1.<code>{</code>内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。</p>\n<ol>\n<li>操作符左右，大括号<code>{}</code>左右，等于号左右都要有一个空格的间距。<br>f</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://www.oracle.com/technetwork/java/codeconventions-150003.pdf\" target=\"_blank\" rel=\"external\">JavaCode Conventions</a></p>\n</li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<p>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。<br> 所以决定总结一些规范，以后写代码要注意了~</p>\n</blockquote>\n<ul>\n<li><h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a><strong>命名</strong></h2><ul>\n<li><p>变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名</p>\n</li>\n<li><p>避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean</p>\n</li>\n</ul>\n<ol>\n<li><p>方法</p>\n<p>方法名第一个单词小写，以后每个单词首字母大写。</p>\n</li>\n<li><p>类、接口</p>\n<p>所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词</p>\n</li>\n<li><p>字段、常量</p>\n<p>成员变量、局部变量第一个单词小写，如 userName, instance。</p>\n<p>常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。</p>\n<p>代码中禁止使用硬编码，把一些数字或字符串定义成常用量。</p>\n</li>\n</ol>\n</li>\n<li><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a><strong>注释</strong></h2><ol>\n<li><p>成员变量注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** 成员变量注释 */</span></div><div class=\"line\"><span class=\"keyword\">protected</span> Object mObject0;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 对于注释多于一行的，采用这种方式来</div><div class=\"line\"> * 定义该变量</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">private</span> Object mObject4;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方法描述</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * 方法描述...</div><div class=\"line\">  * </div><div class=\"line\">  * <span class=\"doctag\">@param</span> param1  参数1描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> param2  参数2描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> paramXX 参数XX描述... （注意：请将参数、描述都对齐）</div><div class=\"line\">  */</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> param1, <span class=\"keyword\">float</span> param2, String paramXX)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.方法内部注释</p>\n<p>  可以使用 /<em>注释</em>/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> TRUE;            <span class=\"comment\">/* special case */</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">    <span class=\"keyword\">return</span> isprime(a);      <span class=\"comment\">/* works only for odd a */</span>&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><h2 id=\"换行、空格\"><a href=\"#换行、空格\" class=\"headerlink\" title=\"换行、空格\"></a><strong>换行、空格</strong></h2><ul>\n<li><p><strong>换行</strong></p>\n<p>当代码过长造成阅读困难的时候，就应该考虑代码换行。</p>\n<p>有这么几个原则：</p>\n<p>1.在逗号之后换行</p>\n<p>2.在操作符之前换行</p>\n<p>3.考虑在表达式的外层就换行，而不是内层</p>\n<p>4.新一行的开头应该与前一行的同一级代码对齐</p>\n<p>5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(longExpression1, longExpression2, longExpression3,         </div><div class=\"line\">         longExpression4, longExpression5);</div><div class=\"line\"></div><div class=\"line\">var = function1(longExpression1,                </div><div class=\"line\">               function2(longExpression2,</div><div class=\"line\">                         longExpression3));</div></pre></td></tr></table></figure>\n<p>在表达式外层换行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">longName1 = longName2 * (longName3 + longName4 - longName5)</div><div class=\"line\">            + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// PREFER</span></div><div class=\"line\"></div><div class=\"line\">longName1 = longName2 * (longName3 + longName4</div><div class=\"line\">                         - longName5) + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// AVOID</span></div></pre></td></tr></table></figure>\n<p>插入8个空格的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//INDENT 8 SPACES TO AVOID VERY DEEP INDENTS</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">horkingLongMethodName</span><span class=\"params\">(<span class=\"keyword\">int</span> anArg,</div><div class=\"line\">        Object anotherArg, String yetAnotherArg,</div><div class=\"line\">        Object andStillAnother)</span> </span>&#123;    </div><div class=\"line\">     ...</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//条件表达式8空格原则</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((condition1 &amp;&amp; condition2)</div><div class=\"line\">        || (condition3 &amp;&amp; condition4)</div><div class=\"line\">        ||!(condition5 &amp;&amp; condition6)) &#123;</div><div class=\"line\">    doSomethingAboutIt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>空格</strong></p>\n<p>1.<code>{</code>内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。</p>\n<ol>\n<li>操作符左右，大括号<code>{}</code>左右，等于号左右都要有一个空格的间距。<br>f</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://www.oracle.com/technetwork/java/codeconventions-150003.pdf\">JavaCode Conventions</a></p>\n</li>\n</ul>\n"},{"layout":"post","title":"关于加密的一点总结","date":"2016-08-22T12:59:00.000Z","_content":"前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。\n\n## 信息摘要算法\n\n### 简介\n\n验证用户名密码的整个过程主要使用了MD5算法。严格来说，[MD5](https://zh.wikipedia.org/wiki/MD5)不是一种加密算法，而是一种信息摘要算法。\n\n所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在[这篇](http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/)总结中提到过。简单来说，就是把给出的\"信息\"经过哈希之后得到的值，就是这些内容的\"摘要\"。\n\n### 特点\n\n信息摘要算法有这样几个特点：\n\n1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。\n\n2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个[提问](http://www.zhihu.com/question/22651987).\n\n3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。\n\n满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？\n\n1.一致性检验。\n\n我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。\n\n下面是jdk-7u79对应的MD5校验值，从[官方网站](https://www.oracle.com/webfolder/s/digest/7u79checksum.html)截图。\n\n{% asset_img md5.png MD5 %}\n\n2.数字签名\n\n其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。\n\n3.登陆验证\n\n模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回success\n\n3.客户端将密码经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。\n\n那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 [加盐](https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6) 的手段来保证我们密码的安全。\n\n所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。\n\n使用加盐手段后，上面的验证过程改为如下：\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt\n\n3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。\n\n### java中的MD5\n\n```java\npublic static String stringMD5(String input) {  \n  \n   try {    \n      // 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    \n      MessageDigest messageDigest =MessageDigest.getInstance(\"MD5\");  \n      // 输入的字符串转换成字节数组  \n      byte[] inputByteArray = input.getBytes();  \n  \n      // inputByteArray是输入字符串转换得到的字节数组  \n      messageDigest.update(inputByteArray);      \n  \n      // 转换并返回结果，也是字节数组，包含16个元素  \n      byte[] resultByteArray = messageDigest.digest();  \n    \n      // 字符数组转换成字符串返回  \n      return byteArrayToHex(resultByteArray);           \n   } catch (NoSuchAlgorithmException e) {   \n      return null;    \n   }  \n  \n}  \n\npublic static String byteArrayToHex(byte[] byteArray) {    \n   // 首先初始化一个字符数组，用来存放每个16进制字符    \n   char[] hexDigits = {'0','1','2','3','4','5','6','7','8','9', 'A','B','C','D','E','F' };  \n    \n   // new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    \n   char[] resultCharArray =new char[byteArray.length * 2];   \n  \n   // 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    \n   int index = 0;    \n   int pos,tmp;\n   for (byte b : byteArray) {   \n   \t  //当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！\n   \t  //为便于理解，此处对原文进行修改\n   \t  int tmp = b & 0xFF;\n   \t  pos = tmp >> 4;//得到低四位\n      resultCharArray[index++] = hexDigits[pos];  \n      pos = tmp & 0xF;//得到高四位\n      resultCharArray[index++] = hexDigits[pos];   \n   }    \n  \n   // 字符数组组合成字符串返回   \n   return new String(resultCharArray);  \n}\n```\n代码参考自[叉叉哥的BLOG](http://blog.csdn.net/xiao__gui/article/details/8148203)\n\n\n## 数字签名\n\n前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。\n\n首先了解一下两个概念：[对称加密](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86)和[非对称加密](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)。\n\n对称加密，就是信息加密解密使用相同的密钥。\n\n非对称加密，有两种密钥，公钥和私钥。\n\n公钥私钥满足以下几个特点：\n\n1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。\n\n2.顾名思义，公钥是可以公开的，而私钥是不公开的。\n\n3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。\n\n4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容\n\n5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。\n\n与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。\n\n下面看一下数字签名使用过程：\n\n1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。\n\n2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的**身份认证**。\n\n3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了**信息完整性**（一致性检验）。\n\n上面的过程能够得出数字签名的作用：**身份认证**与**完整性检验**\n\n使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。\n\n## 数字证书\n\n数字证书是用来解决公钥从哪里来的问题。\n\n可能有以下两种方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了\n\n所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。\n\n关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。\n\n## 参考\n\n网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。\n\n以下内容来自[无恙-数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html) http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n2、一个加密通信过程的演化\n\n我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：\n\n2.1 第一回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：？？？？\n\n因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”\n\n“黑客”->“客户”：你好，我是服务器\n\n因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：\n\n \n\n2.2 第二回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n      // 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n\n为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。\n\n“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。\n\n假设“黑客”想冒充“服务器”：\n\n“黑客”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。\n\n“客户”->“黑客”：？？？？\n\n由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！\n\n到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：\n\n \n\n2.3 第三回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]\n\n“服务器”->“客户”：{你的余额是100元}[私钥|RSA]\n\n注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。\n\n这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：\n\n \n\n2.4 第四回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。\n\n“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]\n\n在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。\n\n由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。\n\n \n\n总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：\n\n因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。\n客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。\n如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)\n\n到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。\n\n \n\n但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：\n\n“客户”->“黑客”：你好           //黑客截获“客户”发给“服务器”的消息\n\n“黑客”->“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”\n\n因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。\n\n为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：\n\n证书的发布机构\n证书的有效期\n公钥\n证书所有者（Subject）\n签名所使用的算法\n指纹以及指纹算法\n证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：\n\n \n\n2.5 第五回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：\n\n \n\n2.6 完整过程：\n\nstep1： “客户”向服务端发送一个通信请求\n\n“客户”->“服务器”：你好\n\n  \n\nstep2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 \n\n \n\nstep3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。\n\n“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。\n\n“服务器”->“客户”：{一个随机字符串}[私钥|RSA]\n\n \n\nstep4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。\n\n“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]\n\n…… //继续其它的通信\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n另外，也可以看看这篇博客：[阮一峰-数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)\n\n\n\n\n\n\n\n\n","source":"_posts/关于加密的一点总结.md","raw":"layout: post\ntitle: 关于加密的一点总结\ndate: 2016-08-22 20:59:00\ncategories: 技术\ntags: 加密\n---\n前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。\n\n## 信息摘要算法\n\n### 简介\n\n验证用户名密码的整个过程主要使用了MD5算法。严格来说，[MD5](https://zh.wikipedia.org/wiki/MD5)不是一种加密算法，而是一种信息摘要算法。\n\n所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在[这篇](http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/)总结中提到过。简单来说，就是把给出的\"信息\"经过哈希之后得到的值，就是这些内容的\"摘要\"。\n\n### 特点\n\n信息摘要算法有这样几个特点：\n\n1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。\n\n2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个[提问](http://www.zhihu.com/question/22651987).\n\n3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。\n\n满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？\n\n1.一致性检验。\n\n我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。\n\n下面是jdk-7u79对应的MD5校验值，从[官方网站](https://www.oracle.com/webfolder/s/digest/7u79checksum.html)截图。\n\n{% asset_img md5.png MD5 %}\n\n2.数字签名\n\n其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。\n\n3.登陆验证\n\n模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回success\n\n3.客户端将密码经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。\n\n那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 [加盐](https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6) 的手段来保证我们密码的安全。\n\n所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。\n\n使用加盐手段后，上面的验证过程改为如下：\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt\n\n3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。\n\n### java中的MD5\n\n```java\npublic static String stringMD5(String input) {  \n  \n   try {    \n      // 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    \n      MessageDigest messageDigest =MessageDigest.getInstance(\"MD5\");  \n      // 输入的字符串转换成字节数组  \n      byte[] inputByteArray = input.getBytes();  \n  \n      // inputByteArray是输入字符串转换得到的字节数组  \n      messageDigest.update(inputByteArray);      \n  \n      // 转换并返回结果，也是字节数组，包含16个元素  \n      byte[] resultByteArray = messageDigest.digest();  \n    \n      // 字符数组转换成字符串返回  \n      return byteArrayToHex(resultByteArray);           \n   } catch (NoSuchAlgorithmException e) {   \n      return null;    \n   }  \n  \n}  \n\npublic static String byteArrayToHex(byte[] byteArray) {    \n   // 首先初始化一个字符数组，用来存放每个16进制字符    \n   char[] hexDigits = {'0','1','2','3','4','5','6','7','8','9', 'A','B','C','D','E','F' };  \n    \n   // new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    \n   char[] resultCharArray =new char[byteArray.length * 2];   \n  \n   // 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    \n   int index = 0;    \n   int pos,tmp;\n   for (byte b : byteArray) {   \n   \t  //当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！\n   \t  //为便于理解，此处对原文进行修改\n   \t  int tmp = b & 0xFF;\n   \t  pos = tmp >> 4;//得到低四位\n      resultCharArray[index++] = hexDigits[pos];  \n      pos = tmp & 0xF;//得到高四位\n      resultCharArray[index++] = hexDigits[pos];   \n   }    \n  \n   // 字符数组组合成字符串返回   \n   return new String(resultCharArray);  \n}\n```\n代码参考自[叉叉哥的BLOG](http://blog.csdn.net/xiao__gui/article/details/8148203)\n\n\n## 数字签名\n\n前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。\n\n首先了解一下两个概念：[对称加密](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86)和[非对称加密](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)。\n\n对称加密，就是信息加密解密使用相同的密钥。\n\n非对称加密，有两种密钥，公钥和私钥。\n\n公钥私钥满足以下几个特点：\n\n1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。\n\n2.顾名思义，公钥是可以公开的，而私钥是不公开的。\n\n3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。\n\n4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容\n\n5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。\n\n与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。\n\n下面看一下数字签名使用过程：\n\n1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。\n\n2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的**身份认证**。\n\n3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了**信息完整性**（一致性检验）。\n\n上面的过程能够得出数字签名的作用：**身份认证**与**完整性检验**\n\n使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。\n\n## 数字证书\n\n数字证书是用来解决公钥从哪里来的问题。\n\n可能有以下两种方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了\n\n所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。\n\n关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。\n\n## 参考\n\n网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。\n\n以下内容来自[无恙-数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html) http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n2、一个加密通信过程的演化\n\n我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：\n\n2.1 第一回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：？？？？\n\n因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”\n\n“黑客”->“客户”：你好，我是服务器\n\n因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：\n\n \n\n2.2 第二回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n      // 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n\n为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。\n\n“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。\n\n假设“黑客”想冒充“服务器”：\n\n“黑客”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。\n\n“客户”->“黑客”：？？？？\n\n由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！\n\n到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：\n\n \n\n2.3 第三回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]\n\n“服务器”->“客户”：{你的余额是100元}[私钥|RSA]\n\n注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。\n\n这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：\n\n \n\n2.4 第四回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。\n\n“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]\n\n在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。\n\n由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。\n\n \n\n总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：\n\n因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。\n客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。\n如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)\n\n到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。\n\n \n\n但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：\n\n“客户”->“黑客”：你好           //黑客截获“客户”发给“服务器”的消息\n\n“黑客”->“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”\n\n因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。\n\n为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：\n\n证书的发布机构\n证书的有效期\n公钥\n证书所有者（Subject）\n签名所使用的算法\n指纹以及指纹算法\n证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：\n\n \n\n2.5 第五回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：\n\n \n\n2.6 完整过程：\n\nstep1： “客户”向服务端发送一个通信请求\n\n“客户”->“服务器”：你好\n\n  \n\nstep2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 \n\n \n\nstep3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。\n\n“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。\n\n“服务器”->“客户”：{一个随机字符串}[私钥|RSA]\n\n \n\nstep4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。\n\n“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]\n\n…… //继续其它的通信\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n另外，也可以看看这篇博客：[阮一峰-数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)\n\n\n\n\n\n\n\n\n","slug":"关于加密的一点总结","published":1,"updated":"2017-02-19T13:08:11.039Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlss003qvegcbmz8tjfl","content":"<p>前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。</p>\n<h2 id=\"信息摘要算法\"><a href=\"#信息摘要算法\" class=\"headerlink\" title=\"信息摘要算法\"></a>信息摘要算法</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>验证用户名密码的整个过程主要使用了MD5算法。严格来说，<a href=\"https://zh.wikipedia.org/wiki/MD5\" target=\"_blank\" rel=\"external\">MD5</a>不是一种加密算法，而是一种信息摘要算法。</p>\n<p>所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在<a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/\">这篇</a>总结中提到过。简单来说，就是把给出的”信息”经过哈希之后得到的值，就是这些内容的”摘要”。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>信息摘要算法有这样几个特点：</p>\n<p>1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。</p>\n<p>2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个<a href=\"http://www.zhihu.com/question/22651987\" target=\"_blank\" rel=\"external\">提问</a>.</p>\n<p>3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。</p>\n<p>满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？</p>\n<p>1.一致性检验。</p>\n<p>我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。</p>\n<p>下面是jdk-7u79对应的MD5校验值，从<a href=\"https://www.oracle.com/webfolder/s/digest/7u79checksum.html\" target=\"_blank\" rel=\"external\">官方网站</a>截图。</p>\n<img src=\"/2016/08/22/关于加密的一点总结/md5.png\" alt=\"MD5\" title=\"MD5\">\n<p>2.数字签名</p>\n<p>其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。</p>\n<p>3.登陆验证</p>\n<p>模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回success</p>\n<p>3.客户端将密码经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。</p>\n<p>那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 <a href=\"https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6\" target=\"_blank\" rel=\"external\">加盐</a> 的手段来保证我们密码的安全。</p>\n<p>所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。</p>\n<p>使用加盐手段后，上面的验证过程改为如下：</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt</p>\n<p>3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。</p>\n<h3 id=\"java中的MD5\"><a href=\"#java中的MD5\" class=\"headerlink\" title=\"java中的MD5\"></a>java中的MD5</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">stringMD5</span><span class=\"params\">(String input)</span> </span>&#123;  </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">      <span class=\"comment\">// 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    </span></div><div class=\"line\">      MessageDigest messageDigest =MessageDigest.getInstance(<span class=\"string\">\"MD5\"</span>);  </div><div class=\"line\">      <span class=\"comment\">// 输入的字符串转换成字节数组  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] inputByteArray = input.getBytes();  </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// inputByteArray是输入字符串转换得到的字节数组  </span></div><div class=\"line\">      messageDigest.update(inputByteArray);      </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// 转换并返回结果，也是字节数组，包含16个元素  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] resultByteArray = messageDigest.digest();  </div><div class=\"line\">    </div><div class=\"line\">      <span class=\"comment\">// 字符数组转换成字符串返回  </span></div><div class=\"line\">      <span class=\"keyword\">return</span> byteArrayToHex(resultByteArray);           </div><div class=\"line\">   &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;   </div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;    </div><div class=\"line\">   &#125;  </div><div class=\"line\">  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">byteArrayToHex</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] byteArray)</span> </span>&#123;    </div><div class=\"line\">   <span class=\"comment\">// 首先初始化一个字符数组，用来存放每个16进制字符    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] hexDigits = &#123;<span class=\"string\">'0'</span>,<span class=\"string\">'1'</span>,<span class=\"string\">'2'</span>,<span class=\"string\">'3'</span>,<span class=\"string\">'4'</span>,<span class=\"string\">'5'</span>,<span class=\"string\">'6'</span>,<span class=\"string\">'7'</span>,<span class=\"string\">'8'</span>,<span class=\"string\">'9'</span>, <span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span> &#125;;  </div><div class=\"line\">    </div><div class=\"line\">   <span class=\"comment\">// new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] resultCharArray =<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[byteArray.length * <span class=\"number\">2</span>];   </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    </span></div><div class=\"line\">   <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;    </div><div class=\"line\">   <span class=\"keyword\">int</span> pos,tmp;</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">byte</span> b : byteArray) &#123;   </div><div class=\"line\">   \t  <span class=\"comment\">//当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！</span></div><div class=\"line\">   \t  <span class=\"comment\">//为便于理解，此处对原文进行修改</span></div><div class=\"line\">   \t  <span class=\"keyword\">int</span> tmp = b &amp; <span class=\"number\">0xFF</span>;</div><div class=\"line\">   \t  pos = tmp &gt;&gt; <span class=\"number\">4</span>;<span class=\"comment\">//得到低四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];  </div><div class=\"line\">      pos = tmp &amp; <span class=\"number\">0xF</span>;<span class=\"comment\">//得到高四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];   </div><div class=\"line\">   &#125;    </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 字符数组组合成字符串返回   </span></div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(resultCharArray);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码参考自<a href=\"http://blog.csdn.net/xiao__gui/article/details/8148203\" target=\"_blank\" rel=\"external\">叉叉哥的BLOG</a></p>\n<h2 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h2><p>前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。</p>\n<p>首先了解一下两个概念：<a href=\"https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86\" target=\"_blank\" rel=\"external\">对称加密</a>和<a href=\"https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86\" target=\"_blank\" rel=\"external\">非对称加密</a>。</p>\n<p>对称加密，就是信息加密解密使用相同的密钥。</p>\n<p>非对称加密，有两种密钥，公钥和私钥。</p>\n<p>公钥私钥满足以下几个特点：</p>\n<p>1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。</p>\n<p>2.顾名思义，公钥是可以公开的，而私钥是不公开的。</p>\n<p>3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。</p>\n<p>4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容</p>\n<p>5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。</p>\n<p>与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。</p>\n<p>下面看一下数字签名使用过程：</p>\n<p>1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。</p>\n<p>2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的<strong>身份认证</strong>。</p>\n<p>3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了<strong>信息完整性</strong>（一致性检验）。</p>\n<p>上面的过程能够得出数字签名的作用：<strong>身份认证</strong>与<strong>完整性检验</strong></p>\n<p>使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。</p>\n<h2 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h2><p>数字证书是用来解决公钥从哪里来的问题。</p>\n<p>可能有以下两种方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了</p>\n<p>所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。</p>\n<p>关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。</p>\n<p>以下内容来自<a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\" target=\"_blank\" rel=\"external\">无恙-数字证书原理</a> <a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html</a></p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>2、一个加密通信过程的演化</p>\n<p>我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：</p>\n<p>2.1 第一回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：？？？？</p>\n<p>因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：</p>\n<p>2.2 第二回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<pre><code>// 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n</code></pre><p>为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。</p>\n<p>“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。</p>\n<p>假设“黑客”想冒充“服务器”：</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。</p>\n<p>“客户”-&gt;“黑客”：？？？？</p>\n<p>由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！</p>\n<p>到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：</p>\n<p>2.3 第三回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[私钥|RSA]</p>\n<p>注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。</p>\n<p>这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：</p>\n<p>2.4 第四回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。</p>\n<p>“服务器”-&gt;“客户”：{OK，收到！}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[密钥|对称加密算法]</p>\n<p>在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。</p>\n<p>由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。</p>\n<p>总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：</p>\n<p>因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。<br>客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。<br>如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)</p>\n<p>到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。</p>\n<p>但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：</p>\n<p>“客户”-&gt;“黑客”：你好           //黑客截获“客户”发给“服务器”的消息</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”</p>\n<p>因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。</p>\n<p>为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：</p>\n<p>证书的发布机构<br>证书的有效期<br>公钥<br>证书所有者（Subject）<br>签名所使用的算法<br>指纹以及指纹算法<br>证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：</p>\n<p>2.5 第五回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：</p>\n<p>2.6 完整过程：</p>\n<p>step1： “客户”向服务端发送一个通信请求</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>step2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 </p>\n<p>step3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。</p>\n<p>“服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]</p>\n<p>step4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>\n<p>“服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]</p>\n<p>…… //继续其它的通信</p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>另外，也可以看看这篇博客：<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\" target=\"_blank\" rel=\"external\">阮一峰-数字签名是什么？</a></p>\n","excerpt":"","more":"<p>前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。</p>\n<h2 id=\"信息摘要算法\"><a href=\"#信息摘要算法\" class=\"headerlink\" title=\"信息摘要算法\"></a>信息摘要算法</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>验证用户名密码的整个过程主要使用了MD5算法。严格来说，<a href=\"https://zh.wikipedia.org/wiki/MD5\">MD5</a>不是一种加密算法，而是一种信息摘要算法。</p>\n<p>所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在<a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/\">这篇</a>总结中提到过。简单来说，就是把给出的”信息”经过哈希之后得到的值，就是这些内容的”摘要”。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>信息摘要算法有这样几个特点：</p>\n<p>1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。</p>\n<p>2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个<a href=\"http://www.zhihu.com/question/22651987\">提问</a>.</p>\n<p>3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。</p>\n<p>满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？</p>\n<p>1.一致性检验。</p>\n<p>我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。</p>\n<p>下面是jdk-7u79对应的MD5校验值，从<a href=\"https://www.oracle.com/webfolder/s/digest/7u79checksum.html\">官方网站</a>截图。</p>\n<img src=\"/2016/08/22/关于加密的一点总结/md5.png\" alt=\"MD5\" title=\"MD5\">\n<p>2.数字签名</p>\n<p>其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。</p>\n<p>3.登陆验证</p>\n<p>模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回success</p>\n<p>3.客户端将密码经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。</p>\n<p>那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 <a href=\"https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6\">加盐</a> 的手段来保证我们密码的安全。</p>\n<p>所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。</p>\n<p>使用加盐手段后，上面的验证过程改为如下：</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt</p>\n<p>3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。</p>\n<h3 id=\"java中的MD5\"><a href=\"#java中的MD5\" class=\"headerlink\" title=\"java中的MD5\"></a>java中的MD5</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">stringMD5</span><span class=\"params\">(String input)</span> </span>&#123;  </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">      <span class=\"comment\">// 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    </span></div><div class=\"line\">      MessageDigest messageDigest =MessageDigest.getInstance(<span class=\"string\">\"MD5\"</span>);  </div><div class=\"line\">      <span class=\"comment\">// 输入的字符串转换成字节数组  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] inputByteArray = input.getBytes();  </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// inputByteArray是输入字符串转换得到的字节数组  </span></div><div class=\"line\">      messageDigest.update(inputByteArray);      </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// 转换并返回结果，也是字节数组，包含16个元素  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] resultByteArray = messageDigest.digest();  </div><div class=\"line\">    </div><div class=\"line\">      <span class=\"comment\">// 字符数组转换成字符串返回  </span></div><div class=\"line\">      <span class=\"keyword\">return</span> byteArrayToHex(resultByteArray);           </div><div class=\"line\">   &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;   </div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;    </div><div class=\"line\">   &#125;  </div><div class=\"line\">  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">byteArrayToHex</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] byteArray)</span> </span>&#123;    </div><div class=\"line\">   <span class=\"comment\">// 首先初始化一个字符数组，用来存放每个16进制字符    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] hexDigits = &#123;<span class=\"string\">'0'</span>,<span class=\"string\">'1'</span>,<span class=\"string\">'2'</span>,<span class=\"string\">'3'</span>,<span class=\"string\">'4'</span>,<span class=\"string\">'5'</span>,<span class=\"string\">'6'</span>,<span class=\"string\">'7'</span>,<span class=\"string\">'8'</span>,<span class=\"string\">'9'</span>, <span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span> &#125;;  </div><div class=\"line\">    </div><div class=\"line\">   <span class=\"comment\">// new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] resultCharArray =<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[byteArray.length * <span class=\"number\">2</span>];   </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    </span></div><div class=\"line\">   <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;    </div><div class=\"line\">   <span class=\"keyword\">int</span> pos,tmp;</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">byte</span> b : byteArray) &#123;   </div><div class=\"line\">   \t  <span class=\"comment\">//当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！</span></div><div class=\"line\">   \t  <span class=\"comment\">//为便于理解，此处对原文进行修改</span></div><div class=\"line\">   \t  <span class=\"keyword\">int</span> tmp = b &amp; <span class=\"number\">0xFF</span>;</div><div class=\"line\">   \t  pos = tmp &gt;&gt; <span class=\"number\">4</span>;<span class=\"comment\">//得到低四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];  </div><div class=\"line\">      pos = tmp &amp; <span class=\"number\">0xF</span>;<span class=\"comment\">//得到高四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];   </div><div class=\"line\">   &#125;    </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 字符数组组合成字符串返回   </span></div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(resultCharArray);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码参考自<a href=\"http://blog.csdn.net/xiao__gui/article/details/8148203\">叉叉哥的BLOG</a></p>\n<h2 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h2><p>前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。</p>\n<p>首先了解一下两个概念：<a href=\"https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86\">对称加密</a>和<a href=\"https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86\">非对称加密</a>。</p>\n<p>对称加密，就是信息加密解密使用相同的密钥。</p>\n<p>非对称加密，有两种密钥，公钥和私钥。</p>\n<p>公钥私钥满足以下几个特点：</p>\n<p>1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。</p>\n<p>2.顾名思义，公钥是可以公开的，而私钥是不公开的。</p>\n<p>3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。</p>\n<p>4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容</p>\n<p>5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。</p>\n<p>与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。</p>\n<p>下面看一下数字签名使用过程：</p>\n<p>1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。</p>\n<p>2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的<strong>身份认证</strong>。</p>\n<p>3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了<strong>信息完整性</strong>（一致性检验）。</p>\n<p>上面的过程能够得出数字签名的作用：<strong>身份认证</strong>与<strong>完整性检验</strong></p>\n<p>使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。</p>\n<h2 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h2><p>数字证书是用来解决公钥从哪里来的问题。</p>\n<p>可能有以下两种方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了</p>\n<p>所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。</p>\n<p>关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。</p>\n<p>以下内容来自<a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\">无恙-数字证书原理</a> <a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\">http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html</a></p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>2、一个加密通信过程的演化</p>\n<p>我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：</p>\n<p>2.1 第一回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：？？？？</p>\n<p>因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：</p>\n<p>2.2 第二回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<pre><code>// 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n</code></pre><p>为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。</p>\n<p>“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。</p>\n<p>假设“黑客”想冒充“服务器”：</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。</p>\n<p>“客户”-&gt;“黑客”：？？？？</p>\n<p>由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！</p>\n<p>到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：</p>\n<p>2.3 第三回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[私钥|RSA]</p>\n<p>注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。</p>\n<p>这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：</p>\n<p>2.4 第四回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。</p>\n<p>“服务器”-&gt;“客户”：{OK，收到！}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[密钥|对称加密算法]</p>\n<p>在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。</p>\n<p>由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。</p>\n<p>总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：</p>\n<p>因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。<br>客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。<br>如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)</p>\n<p>到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。</p>\n<p>但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：</p>\n<p>“客户”-&gt;“黑客”：你好           //黑客截获“客户”发给“服务器”的消息</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”</p>\n<p>因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。</p>\n<p>为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：</p>\n<p>证书的发布机构<br>证书的有效期<br>公钥<br>证书所有者（Subject）<br>签名所使用的算法<br>指纹以及指纹算法<br>证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：</p>\n<p>2.5 第五回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：</p>\n<p>2.6 完整过程：</p>\n<p>step1： “客户”向服务端发送一个通信请求</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>step2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 </p>\n<p>step3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。</p>\n<p>“服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]</p>\n<p>step4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>\n<p>“服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]</p>\n<p>…… //继续其它的通信</p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>另外，也可以看看这篇博客：<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\">阮一峰-数字签名是什么？</a></p>\n"},{"layout":"post","title":"关于抽象类和接口","date":"2016-04-15T14:48:55.000Z","_content":"\n## 抽象类：\n\n> 使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.\n\n   - 抽象类不能被实例化\n\n   - 如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类\n\n   - 抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。\n\n   - 可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。\n   \n   - 不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。\n\n   - 抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。\n\n   - 子类中的抽象方法不能与父类的抽象方法同名\n\n   - 其余情况抽象类与普通类相同。\n\n\n## 接口：\n\n\n > 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.\n\n   - 接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。\n\n   - 接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。\n\n   - 接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。\n\n   - 接口中没有构造方法，不能被实例化。\n\n   - 如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。\n\n   - 接口中不能含有静态代码块以及静态方法。\n\n   - 在实现多接口的时候一定要避免方法名的重复。\n\n## 区别与联系：\n   \n   - **语义**\n   \n     1. 一个类只能继承一个抽象类，但可以实现多个接口。\n\n     2. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法\n\n   - **设计思想**\n\n     >抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。\n\n     1. 抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。\n\n        对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。\n\n     2. 抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。\n    \n        抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n\n     3. 抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n\n        对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。\n\n     **示例**\n\n     门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n\n  \n```java\nabstract class Door {\n      public abstract void open();\n      public abstract void close();\n}\n```\n    \t\n\n或\n \n```java\ninterface Door {\n      public abstract void open();\n      public abstract void close();\n} \n```\n\n\n但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：\n\n1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；\n\n2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。\n\n从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。\n      \n\n```java\ninterface Alram {\n      void alarm();\n}\nabstract class Door {\n      void open();\n      void close();\n}\nclass AlarmDoor extends Door implements Alarm {\n      void oepn() {\n           //....\n      }\n      void close() {\n           //....\n      }\n      void alarm() {\n           //....\n      }\n} \n```\n---------------------\n## **对继承的思考**\n\n2016/10/27更新\n\n写代码的过程中发现java的继承经常被滥用。思考一下解决方法...\n\n1.当子类和父类属于同一个种类时使用继承，而不是拥有相同的功能。\n\n  比如：飞机能飞，鸟也能飞。但是这两种东西不应该归为一类。飞只是个功能，可以作为一个接口。\n        鸟却可以是大雁的父类，他们从本质上是一种东西\n\n2.继承可用于模板方法模式。即能够从很多类中抽象出同一个流程，把这个流程作为一个模板写在父类当中。设置好钩子供子类实现。\n\n3.既不属于同一种类又没有抽象出模板，但是多个类之间有相同的代码冗余。考虑委托，写一个通用的Utility类，吧冗余的代码放到utility类当中去，把需要的参数传进去。避免滥用继承。比如：\n\n写web服务器时，有很多controller，如果这些controller关联不大，没必要继承同一个父类。但是都有一个验证身份的verify方法，考虑把这个verify方法写到一个Utility类中，所有的controller去调用它。\n\n\n## **资料:**\n\n   [Java 中的接口有什么作用？](https://www.zhihu.com/question/20111251)\n\n   [java提高篇（四）-----抽象类与接口](http://blog.csdn.net/chenssy/article/details/12858267)\n\n","source":"_posts/关于抽象类和接口.md","raw":"---\nlayout: post\ntitle:  \"关于抽象类和接口\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-15 22:48:55\n---\n\n## 抽象类：\n\n> 使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.\n\n   - 抽象类不能被实例化\n\n   - 如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类\n\n   - 抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。\n\n   - 可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。\n   \n   - 不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。\n\n   - 抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。\n\n   - 子类中的抽象方法不能与父类的抽象方法同名\n\n   - 其余情况抽象类与普通类相同。\n\n\n## 接口：\n\n\n > 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.\n\n   - 接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。\n\n   - 接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。\n\n   - 接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。\n\n   - 接口中没有构造方法，不能被实例化。\n\n   - 如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。\n\n   - 接口中不能含有静态代码块以及静态方法。\n\n   - 在实现多接口的时候一定要避免方法名的重复。\n\n## 区别与联系：\n   \n   - **语义**\n   \n     1. 一个类只能继承一个抽象类，但可以实现多个接口。\n\n     2. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法\n\n   - **设计思想**\n\n     >抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。\n\n     1. 抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。\n\n        对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。\n\n     2. 抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。\n    \n        抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n\n     3. 抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n\n        对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。\n\n     **示例**\n\n     门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n\n  \n```java\nabstract class Door {\n      public abstract void open();\n      public abstract void close();\n}\n```\n    \t\n\n或\n \n```java\ninterface Door {\n      public abstract void open();\n      public abstract void close();\n} \n```\n\n\n但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：\n\n1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；\n\n2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。\n\n从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。\n      \n\n```java\ninterface Alram {\n      void alarm();\n}\nabstract class Door {\n      void open();\n      void close();\n}\nclass AlarmDoor extends Door implements Alarm {\n      void oepn() {\n           //....\n      }\n      void close() {\n           //....\n      }\n      void alarm() {\n           //....\n      }\n} \n```\n---------------------\n## **对继承的思考**\n\n2016/10/27更新\n\n写代码的过程中发现java的继承经常被滥用。思考一下解决方法...\n\n1.当子类和父类属于同一个种类时使用继承，而不是拥有相同的功能。\n\n  比如：飞机能飞，鸟也能飞。但是这两种东西不应该归为一类。飞只是个功能，可以作为一个接口。\n        鸟却可以是大雁的父类，他们从本质上是一种东西\n\n2.继承可用于模板方法模式。即能够从很多类中抽象出同一个流程，把这个流程作为一个模板写在父类当中。设置好钩子供子类实现。\n\n3.既不属于同一种类又没有抽象出模板，但是多个类之间有相同的代码冗余。考虑委托，写一个通用的Utility类，吧冗余的代码放到utility类当中去，把需要的参数传进去。避免滥用继承。比如：\n\n写web服务器时，有很多controller，如果这些controller关联不大，没必要继承同一个父类。但是都有一个验证身份的verify方法，考虑把这个verify方法写到一个Utility类中，所有的controller去调用它。\n\n\n## **资料:**\n\n   [Java 中的接口有什么作用？](https://www.zhihu.com/question/20111251)\n\n   [java提高篇（四）-----抽象类与接口](http://blog.csdn.net/chenssy/article/details/12858267)\n\n","slug":"关于抽象类和接口","published":1,"updated":"2017-02-19T13:08:11.039Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlsv003uvegc4j8nzno3","content":"<h2 id=\"抽象类：\"><a href=\"#抽象类：\" class=\"headerlink\" title=\"抽象类：\"></a>抽象类：</h2><blockquote>\n<p>使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.</p>\n</blockquote>\n<ul>\n<li><p>抽象类不能被实例化</p>\n</li>\n<li><p>如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类</p>\n</li>\n<li><p>抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。</p>\n</li>\n<li><p>可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。</p>\n</li>\n<li><p>不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。</p>\n</li>\n<li><p>抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。</p>\n</li>\n<li><p>子类中的抽象方法不能与父类的抽象方法同名</p>\n</li>\n<li><p>其余情况抽象类与普通类相同。</p>\n</li>\n</ul>\n<h2 id=\"接口：\"><a href=\"#接口：\" class=\"headerlink\" title=\"接口：\"></a>接口：</h2><blockquote>\n<p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.</p>\n</blockquote>\n<ul>\n<li><p>接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。</p>\n</li>\n<li><p>接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。</p>\n</li>\n<li><p>接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。</p>\n</li>\n<li><p>接口中没有构造方法，不能被实例化。</p>\n</li>\n<li><p>如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>\n</li>\n<li><p>接口中不能含有静态代码块以及静态方法。</p>\n</li>\n<li><p>在实现多接口的时候一定要避免方法名的重复。</p>\n</li>\n</ul>\n<h2 id=\"区别与联系：\"><a href=\"#区别与联系：\" class=\"headerlink\" title=\"区别与联系：\"></a>区别与联系：</h2><ul>\n<li><p><strong>语义</strong></p>\n<ol>\n<li><p>一个类只能继承一个抽象类，但可以实现多个接口。</p>\n</li>\n<li><p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法</p>\n</li>\n</ol>\n</li>\n<li><p><strong>设计思想</strong></p>\n<blockquote>\n<p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</p>\n</blockquote>\n<ol>\n<li><p>抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。</p>\n<p>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>\n</li>\n<li><p>抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。</p>\n<p>抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。</p>\n</li>\n<li><p>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>\n<p>对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。</p>\n</li>\n</ol>\n<p><strong>示例</strong></p>\n<p>门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>\n<p>1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>\n<p>2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>\n<p>从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alram</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">oepn</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"对继承的思考\"><a href=\"#对继承的思考\" class=\"headerlink\" title=\"对继承的思考\"></a><strong>对继承的思考</strong></h2><p>2016/10/27更新</p>\n<p>写代码的过程中发现java的继承经常被滥用。思考一下解决方法…</p>\n<p>1.当子类和父类属于同一个种类时使用继承，而不是拥有相同的功能。</p>\n<p>  比如：飞机能飞，鸟也能飞。但是这两种东西不应该归为一类。飞只是个功能，可以作为一个接口。<br>        鸟却可以是大雁的父类，他们从本质上是一种东西</p>\n<p>2.继承可用于模板方法模式。即能够从很多类中抽象出同一个流程，把这个流程作为一个模板写在父类当中。设置好钩子供子类实现。</p>\n<p>3.既不属于同一种类又没有抽象出模板，但是多个类之间有相同的代码冗余。考虑委托，写一个通用的Utility类，吧冗余的代码放到utility类当中去，把需要的参数传进去。避免滥用继承。比如：</p>\n<p>写web服务器时，有很多controller，如果这些controller关联不大，没必要继承同一个父类。但是都有一个验证身份的verify方法，考虑把这个verify方法写到一个Utility类中，所有的controller去调用它。</p>\n<h2 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料:\"></a><strong>资料:</strong></h2><p>   <a href=\"https://www.zhihu.com/question/20111251\" target=\"_blank\" rel=\"external\">Java 中的接口有什么作用？</a></p>\n<p>   <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\" target=\"_blank\" rel=\"external\">java提高篇（四）—–抽象类与接口</a></p>\n","excerpt":"","more":"<h2 id=\"抽象类：\"><a href=\"#抽象类：\" class=\"headerlink\" title=\"抽象类：\"></a>抽象类：</h2><blockquote>\n<p>使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.</p>\n</blockquote>\n<ul>\n<li><p>抽象类不能被实例化</p>\n</li>\n<li><p>如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类</p>\n</li>\n<li><p>抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。</p>\n</li>\n<li><p>可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。</p>\n</li>\n<li><p>不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。</p>\n</li>\n<li><p>抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。</p>\n</li>\n<li><p>子类中的抽象方法不能与父类的抽象方法同名</p>\n</li>\n<li><p>其余情况抽象类与普通类相同。</p>\n</li>\n</ul>\n<h2 id=\"接口：\"><a href=\"#接口：\" class=\"headerlink\" title=\"接口：\"></a>接口：</h2><blockquote>\n<p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.</p>\n</blockquote>\n<ul>\n<li><p>接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。</p>\n</li>\n<li><p>接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。</p>\n</li>\n<li><p>接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。</p>\n</li>\n<li><p>接口中没有构造方法，不能被实例化。</p>\n</li>\n<li><p>如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>\n</li>\n<li><p>接口中不能含有静态代码块以及静态方法。</p>\n</li>\n<li><p>在实现多接口的时候一定要避免方法名的重复。</p>\n</li>\n</ul>\n<h2 id=\"区别与联系：\"><a href=\"#区别与联系：\" class=\"headerlink\" title=\"区别与联系：\"></a>区别与联系：</h2><ul>\n<li><p><strong>语义</strong></p>\n<ol>\n<li><p>一个类只能继承一个抽象类，但可以实现多个接口。</p>\n</li>\n<li><p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法</p>\n</li>\n</ol>\n</li>\n<li><p><strong>设计思想</strong></p>\n<blockquote>\n<p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</p>\n</blockquote>\n<ol>\n<li><p>抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。</p>\n<p>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>\n</li>\n<li><p>抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。</p>\n<p>抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。</p>\n</li>\n<li><p>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>\n<p>对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。</p>\n</li>\n</ol>\n<p><strong>示例</strong></p>\n<p>门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>\n<p>1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>\n<p>2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>\n<p>从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alram</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">oepn</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"对继承的思考\"><a href=\"#对继承的思考\" class=\"headerlink\" title=\"对继承的思考\"></a><strong>对继承的思考</strong></h2><p>2016/10/27更新</p>\n<p>写代码的过程中发现java的继承经常被滥用。思考一下解决方法…</p>\n<p>1.当子类和父类属于同一个种类时使用继承，而不是拥有相同的功能。</p>\n<p>  比如：飞机能飞，鸟也能飞。但是这两种东西不应该归为一类。飞只是个功能，可以作为一个接口。<br>        鸟却可以是大雁的父类，他们从本质上是一种东西</p>\n<p>2.继承可用于模板方法模式。即能够从很多类中抽象出同一个流程，把这个流程作为一个模板写在父类当中。设置好钩子供子类实现。</p>\n<p>3.既不属于同一种类又没有抽象出模板，但是多个类之间有相同的代码冗余。考虑委托，写一个通用的Utility类，吧冗余的代码放到utility类当中去，把需要的参数传进去。避免滥用继承。比如：</p>\n<p>写web服务器时，有很多controller，如果这些controller关联不大，没必要继承同一个父类。但是都有一个验证身份的verify方法，考虑把这个verify方法写到一个Utility类中，所有的controller去调用它。</p>\n<h2 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料:\"></a><strong>资料:</strong></h2><p>   <a href=\"https://www.zhihu.com/question/20111251\">Java 中的接口有什么作用？</a></p>\n<p>   <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\">java提高篇（四）—–抽象类与接口</a></p>\n"},{"layout":"post","title":"常用快捷键总结","date":"2016-03-22T08:31:55.000Z","_content":"- ## ECLIPSE:\n\n   **查看代码**\n   \n   Ctrl+O 搜索当前类变量及方法\n\n   Ctrl+H 打开搜索对话框\n\n   Ctrl+Shift+G  搜索选中变量或方法的引用\n\n   Ctrl+D 删除当前行\n\n   Ctrl+Shift+F 格式化代码\n\n   F4 查看当前类继承结构\n\n   Ctrl+Shift+R 搜索类，文件等资源\n\n   Ctrl+Shift+O 倒包\n   \n   Ctrl + 1 ：快速修复\n  \n   Ctrl + Shift + /(小键盘) ：收起左侧导航树或代码(依据当前焦点而定)\n\n   Ctrl + *(小键盘) ：展开代码\n\n   Shift + Enter ：在当前行下方插入一行空行\n\n   Alt + 向上键 ：当前行与上方行交换\n\n   Alt + 向下键 ：当前行与下方行交换\n\n   Shift + Alt + R : 重命名\n\n   Shift + Alt + L (表达式末尾)：为表达式赋值为局部变量\n\n   Shift + 向上键/向下键 : 选中此行\n\n   Shift + Alt + M : 提取选中代码为一个方法\n\n   Ctrl + . : 下一个错误\n\n   **调试**\n     \n     F5 进入方法内部\n     \n     F6 顺序执行到下一行\n     \n     F7 跳出方法，返回调用处\n     \n     F8 执行到下一个断点\n\n     Ctrl+Shift+I  查看选中表达式的值\n\n     Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法\n\n     Ctrl+R   运行到光标所在的行\n     \n- ## WINDOWS:\n   \n   ALT+TAB 切换窗口\n   \n   ALT+F4  关闭窗口\n   \n   Ctrl+L  锁定\n   \n   Windows+D 显示桌面\n   \n   Windows+E 打开我的电脑\n   \n   Windows+R 打开运行对话框\n   \n   Ctrl+Z 撤销上一步操作\n   \n   Ctrl+Y 恢复撤销的操作\n   \n   Ctrl+Shift+Esc 打开任务管理器\n\n   按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口\n   \n- ## Chorme:\n  \n   Ctrl+N 打开新窗口\n   \n   Ctrl+Tab 切换标签页\n   \n   Ctrl+L 选中网址栏\n   \n   Ctrl+T 新建标签页\n   \n   Ctrl+Shift+T 重新打开上次关闭的标签页\n   \n   Home 转至网页顶部\n   \n   Ctrl+W 关闭标签页\n   \n","source":"_posts/常用快捷键总结.md","raw":"---\nlayout: post\ntitle:  \"常用快捷键总结\"\ndate:   2016-03-22 16:31:55\ncategories: 工具\ntags: \n- 快捷键\n---\n- ## ECLIPSE:\n\n   **查看代码**\n   \n   Ctrl+O 搜索当前类变量及方法\n\n   Ctrl+H 打开搜索对话框\n\n   Ctrl+Shift+G  搜索选中变量或方法的引用\n\n   Ctrl+D 删除当前行\n\n   Ctrl+Shift+F 格式化代码\n\n   F4 查看当前类继承结构\n\n   Ctrl+Shift+R 搜索类，文件等资源\n\n   Ctrl+Shift+O 倒包\n   \n   Ctrl + 1 ：快速修复\n  \n   Ctrl + Shift + /(小键盘) ：收起左侧导航树或代码(依据当前焦点而定)\n\n   Ctrl + *(小键盘) ：展开代码\n\n   Shift + Enter ：在当前行下方插入一行空行\n\n   Alt + 向上键 ：当前行与上方行交换\n\n   Alt + 向下键 ：当前行与下方行交换\n\n   Shift + Alt + R : 重命名\n\n   Shift + Alt + L (表达式末尾)：为表达式赋值为局部变量\n\n   Shift + 向上键/向下键 : 选中此行\n\n   Shift + Alt + M : 提取选中代码为一个方法\n\n   Ctrl + . : 下一个错误\n\n   **调试**\n     \n     F5 进入方法内部\n     \n     F6 顺序执行到下一行\n     \n     F7 跳出方法，返回调用处\n     \n     F8 执行到下一个断点\n\n     Ctrl+Shift+I  查看选中表达式的值\n\n     Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法\n\n     Ctrl+R   运行到光标所在的行\n     \n- ## WINDOWS:\n   \n   ALT+TAB 切换窗口\n   \n   ALT+F4  关闭窗口\n   \n   Ctrl+L  锁定\n   \n   Windows+D 显示桌面\n   \n   Windows+E 打开我的电脑\n   \n   Windows+R 打开运行对话框\n   \n   Ctrl+Z 撤销上一步操作\n   \n   Ctrl+Y 恢复撤销的操作\n   \n   Ctrl+Shift+Esc 打开任务管理器\n\n   按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口\n   \n- ## Chorme:\n  \n   Ctrl+N 打开新窗口\n   \n   Ctrl+Tab 切换标签页\n   \n   Ctrl+L 选中网址栏\n   \n   Ctrl+T 新建标签页\n   \n   Ctrl+Shift+T 重新打开上次关闭的标签页\n   \n   Home 转至网页顶部\n   \n   Ctrl+W 关闭标签页\n   \n","slug":"常用快捷键总结","published":1,"updated":"2017-02-19T13:08:11.039Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlsx003yvegc5jj6nu9d","content":"<ul>\n<li><h2 id=\"ECLIPSE\"><a href=\"#ECLIPSE\" class=\"headerlink\" title=\"ECLIPSE:\"></a>ECLIPSE:</h2><p> <strong>查看代码</strong></p>\n<p> Ctrl+O 搜索当前类变量及方法</p>\n<p> Ctrl+H 打开搜索对话框</p>\n<p> Ctrl+Shift+G  搜索选中变量或方法的引用</p>\n<p> Ctrl+D 删除当前行</p>\n<p> Ctrl+Shift+F 格式化代码</p>\n<p> F4 查看当前类继承结构</p>\n<p> Ctrl+Shift+R 搜索类，文件等资源</p>\n<p> Ctrl+Shift+O 倒包</p>\n<p> Ctrl + 1 ：快速修复</p>\n<p> Ctrl + Shift + /(小键盘) ：收起左侧导航树或代码(依据当前焦点而定)</p>\n<p> Ctrl + *(小键盘) ：展开代码</p>\n<p> Shift + Enter ：在当前行下方插入一行空行</p>\n<p> Alt + 向上键 ：当前行与上方行交换</p>\n<p> Alt + 向下键 ：当前行与下方行交换</p>\n<p> Shift + Alt + R : 重命名</p>\n<p> Shift + Alt + L (表达式末尾)：为表达式赋值为局部变量</p>\n<p> Shift + 向上键/向下键 : 选中此行</p>\n<p> Shift + Alt + M : 提取选中代码为一个方法</p>\n<p> Ctrl + . : 下一个错误</p>\n<p> <strong>调试</strong></p>\n<p>   F5 进入方法内部</p>\n<p>   F6 顺序执行到下一行</p>\n<p>   F7 跳出方法，返回调用处</p>\n<p>   F8 执行到下一个断点</p>\n<p>   Ctrl+Shift+I  查看选中表达式的值</p>\n<p>   Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法</p>\n<p>   Ctrl+R   运行到光标所在的行</p>\n</li>\n<li><h2 id=\"WINDOWS\"><a href=\"#WINDOWS\" class=\"headerlink\" title=\"WINDOWS:\"></a>WINDOWS:</h2><p> ALT+TAB 切换窗口</p>\n<p> ALT+F4  关闭窗口</p>\n<p> Ctrl+L  锁定</p>\n<p> Windows+D 显示桌面</p>\n<p> Windows+E 打开我的电脑</p>\n<p> Windows+R 打开运行对话框</p>\n<p> Ctrl+Z 撤销上一步操作</p>\n<p> Ctrl+Y 恢复撤销的操作</p>\n<p> Ctrl+Shift+Esc 打开任务管理器</p>\n<p> 按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口</p>\n</li>\n<li><h2 id=\"Chorme\"><a href=\"#Chorme\" class=\"headerlink\" title=\"Chorme:\"></a>Chorme:</h2><p> Ctrl+N 打开新窗口</p>\n<p> Ctrl+Tab 切换标签页</p>\n<p> Ctrl+L 选中网址栏</p>\n<p> Ctrl+T 新建标签页</p>\n<p> Ctrl+Shift+T 重新打开上次关闭的标签页</p>\n<p> Home 转至网页顶部</p>\n<p> Ctrl+W 关闭标签页</p>\n</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li><h2 id=\"ECLIPSE\"><a href=\"#ECLIPSE\" class=\"headerlink\" title=\"ECLIPSE:\"></a>ECLIPSE:</h2><p> <strong>查看代码</strong></p>\n<p> Ctrl+O 搜索当前类变量及方法</p>\n<p> Ctrl+H 打开搜索对话框</p>\n<p> Ctrl+Shift+G  搜索选中变量或方法的引用</p>\n<p> Ctrl+D 删除当前行</p>\n<p> Ctrl+Shift+F 格式化代码</p>\n<p> F4 查看当前类继承结构</p>\n<p> Ctrl+Shift+R 搜索类，文件等资源</p>\n<p> Ctrl+Shift+O 倒包</p>\n<p> Ctrl + 1 ：快速修复</p>\n<p> Ctrl + Shift + /(小键盘) ：收起左侧导航树或代码(依据当前焦点而定)</p>\n<p> Ctrl + *(小键盘) ：展开代码</p>\n<p> Shift + Enter ：在当前行下方插入一行空行</p>\n<p> Alt + 向上键 ：当前行与上方行交换</p>\n<p> Alt + 向下键 ：当前行与下方行交换</p>\n<p> Shift + Alt + R : 重命名</p>\n<p> Shift + Alt + L (表达式末尾)：为表达式赋值为局部变量</p>\n<p> Shift + 向上键/向下键 : 选中此行</p>\n<p> Shift + Alt + M : 提取选中代码为一个方法</p>\n<p> Ctrl + . : 下一个错误</p>\n<p> <strong>调试</strong></p>\n<p>   F5 进入方法内部</p>\n<p>   F6 顺序执行到下一行</p>\n<p>   F7 跳出方法，返回调用处</p>\n<p>   F8 执行到下一个断点</p>\n<p>   Ctrl+Shift+I  查看选中表达式的值</p>\n<p>   Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法</p>\n<p>   Ctrl+R   运行到光标所在的行</p>\n</li>\n<li><h2 id=\"WINDOWS\"><a href=\"#WINDOWS\" class=\"headerlink\" title=\"WINDOWS:\"></a>WINDOWS:</h2><p> ALT+TAB 切换窗口</p>\n<p> ALT+F4  关闭窗口</p>\n<p> Ctrl+L  锁定</p>\n<p> Windows+D 显示桌面</p>\n<p> Windows+E 打开我的电脑</p>\n<p> Windows+R 打开运行对话框</p>\n<p> Ctrl+Z 撤销上一步操作</p>\n<p> Ctrl+Y 恢复撤销的操作</p>\n<p> Ctrl+Shift+Esc 打开任务管理器</p>\n<p> 按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口</p>\n</li>\n<li><h2 id=\"Chorme\"><a href=\"#Chorme\" class=\"headerlink\" title=\"Chorme:\"></a>Chorme:</h2><p> Ctrl+N 打开新窗口</p>\n<p> Ctrl+Tab 切换标签页</p>\n<p> Ctrl+L 选中网址栏</p>\n<p> Ctrl+T 新建标签页</p>\n<p> Ctrl+Shift+T 重新打开上次关闭的标签页</p>\n<p> Home 转至网页顶部</p>\n<p> Ctrl+W 关闭标签页</p>\n</li>\n</ul>\n"},{"layout":"post","title":"毕业了","date":"2016-06-30T15:48:55.000Z","_content":"<iframe \n\tframeborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\">\n</iframe>\n毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。\n\n转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。\n\n但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？\n\n大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。\n\n希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。\n\n{% asset_img graduation1.jpg 毕业照 %}\n\n{% asset_img graduation2.jpg 毕设之后金客来 %}\n\n{% asset_img graduation3.jpg 跳蚤市场卖书 %}\n\n{% asset_img graduation4.jpg 去唱K %}\n\n{% asset_img graduation5.jpg 毕业照之前 %}\n\n{% asset_img graduation6.jpg 机房老师 %}\n\n{% asset_img graduation7.jpg 毕业照之前 %}\n\n{% asset_img graduation8.jpg 我和张蕾 %}\n\n\n\n\n","source":"_posts/毕业了.md","raw":"---\nlayout: post\ntitle:  \"毕业了\"\ncategories: 生活 \ndate:  2016-06-30 23:48:55\n---\n<iframe \n\tframeborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\">\n</iframe>\n毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。\n\n转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。\n\n但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？\n\n大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。\n\n希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。\n\n{% asset_img graduation1.jpg 毕业照 %}\n\n{% asset_img graduation2.jpg 毕设之后金客来 %}\n\n{% asset_img graduation3.jpg 跳蚤市场卖书 %}\n\n{% asset_img graduation4.jpg 去唱K %}\n\n{% asset_img graduation5.jpg 毕业照之前 %}\n\n{% asset_img graduation6.jpg 机房老师 %}\n\n{% asset_img graduation7.jpg 毕业照之前 %}\n\n{% asset_img graduation8.jpg 我和张蕾 %}\n\n\n\n\n","slug":"毕业了","published":1,"updated":"2017-02-19T13:08:11.039Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlsy0041vegcktrnnbt1","content":"<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\"><br></iframe><br>毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。</p>\n<p>转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。</p>\n<p>但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？</p>\n<p>大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。</p>\n<p>希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。</p>\n<img src=\"/2016/06/30/毕业了/graduation1.jpg\" alt=\"毕业照\" title=\"毕业照\">\n<img src=\"/2016/06/30/毕业了/graduation2.jpg\" alt=\"毕设之后金客来\" title=\"毕设之后金客来\">\n<img src=\"/2016/06/30/毕业了/graduation3.jpg\" alt=\"跳蚤市场卖书\" title=\"跳蚤市场卖书\">\n<img src=\"/2016/06/30/毕业了/graduation4.jpg\" alt=\"去唱K\" title=\"去唱K\">\n<img src=\"/2016/06/30/毕业了/graduation5.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation6.jpg\" alt=\"机房老师\" title=\"机房老师\">\n<img src=\"/2016/06/30/毕业了/graduation7.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation8.jpg\" alt=\"我和张蕾\" title=\"我和张蕾\">\n","excerpt":"","more":"<p><iframe \n    frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\"><br></iframe><br>毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。</p>\n<p>转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。</p>\n<p>但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？</p>\n<p>大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。</p>\n<p>希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。</p>\n<img src=\"/2016/06/30/毕业了/graduation1.jpg\" alt=\"毕业照\" title=\"毕业照\">\n<img src=\"/2016/06/30/毕业了/graduation2.jpg\" alt=\"毕设之后金客来\" title=\"毕设之后金客来\">\n<img src=\"/2016/06/30/毕业了/graduation3.jpg\" alt=\"跳蚤市场卖书\" title=\"跳蚤市场卖书\">\n<img src=\"/2016/06/30/毕业了/graduation4.jpg\" alt=\"去唱K\" title=\"去唱K\">\n<img src=\"/2016/06/30/毕业了/graduation5.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation6.jpg\" alt=\"机房老师\" title=\"机房老师\">\n<img src=\"/2016/06/30/毕业了/graduation7.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation8.jpg\" alt=\"我和张蕾\" title=\"我和张蕾\">\n"},{"layout":"post","title":"理解java内存模型","date":"2016-09-10T02:32:40.000Z","_content":"\n最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~\n\n## 并发为啥会出现问题\n\nPS：2016/9/13更新：今天在地铁上看到这篇文章：[Java 并发原理无废话指南](http://toutiao.io/posts/493923/app_preview),感觉跟我这一小节要说明的问题比较相似，参考一下。\n\n### 原子性\n\n其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：\n\n```java\npublic class BankAccount {\n\tprivate static int accountBalance = 10000;\n\n\tstatic class Save implements Runnable {\n\t\tprivate int money;\n\n\t\tpublic Save(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\t//存钱\n\t\t\tint tempAccount = accountBalance + money;\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次存入：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tstatic class Obtain implements Runnable {\n\n\t\tprivate int money;\n\n\t\tpublic Obtain(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (money > accountBalance) {\n\t\t\t\tSystem.out.println(\"余额不足\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//取钱\n\t\t\tint tempAccount = accountBalance - money;\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);//艾玛，卡了一秒\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次取出：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tint saveMoney = 10000;\n\t\tint obtainMoney = 10000;\n\t\t//自己取钱\n\t\tThread obtain = new Thread(new Obtain(obtainMoney));\n\t\t//老婆存钱\n\t\tThread save = new Thread(new Save(saveMoney));\n\t\tobtain.start();\n\t\tsave.start();\n\t}\n\n}\n```\n\n输出结果：\n\n```\n此次存入：10000\n当前余额：20000\n此次取出：10000\n当前余额：0\n```\n\n可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。\n\n分析一下出现问题的原因：\n\n出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。\n\n这就涉及到线程并发的第一个问题：原子性。\n\n我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。\n\n```\n//取钱\nint tempAccount = accountBalance - money;\n\n//设置余额\naccountBalance = tempAccount;\n```\n\n为了实现这种错误的效果，我故意把\n\n```\naccountBalance -= accountBalance;\n```\n\n拆成了上面的两行。其实`accountBalance -= accountBalance;`本身就不是一个原子操作，拆成两行是为了放大这种效果。\n\n通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。\n\n原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。\n\njava中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。\n\n那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。\n\n### 可见性\n\n组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。\n\nJava虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）\n\n画个图：\n\n{% asset_img 内存模型.png 内存模型 %}\n\n这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。\n\n我们回到上述的例子：\n\n上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似`accountBalance -= accountBalance;`这样的操作是原子性操作，设想以下的场景：\n\n1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时`accountBalance~ = 20000;accountBalance = 10000;`\n\n2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时`accountBalance~ = 0;accountBalance = 10000;`\n\n3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；\n\n4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；\n\n通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。\n\n我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。\n\n### 有序性\n\nCpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。\n\n以下例子来自《深入理解Java虚拟机》：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\nconfigOptions = new HashMap();\nconfigText = readConfigFile(flieName);\nprocessConfigOptions(configText,configOptions);\ninitialized = true;\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\nwhile(!initialized){\n\tsleep();\n}\n//使用线程A中初始化好的配置信息\ndoSomethingWithConfig();\n```\n\n在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码`initialized=true`被提前执行，这样线程B中使用配置信息的代码就可能出现错误。\n\n所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\npublic synchronized void init(){\n\tconfigOptions = new HashMap();\n\tconfigText = readConfigFile(flieName);\n\tprocessConfigOptions(configText,configOptions);\n\tinitialized = true;\n}\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\npublic synchronized void doSomething(){\n\twhile(!initialized){\n\t\tsleep();\n\t}\n\t//使用线程A中初始化好的配置信息\n\tdoSomethingWithConfig();\n}\n```\n注意上面两个方法在同一个类中实现。\n\n至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇[synchronized的用法](http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/)，对synchronized的使用更加得心应手啦！\n\n## 先行发生原则\n\n没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。\n\n比如我想到了之前宇哥跟我提到的一个bug:\n\n在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。\n\n后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用`calendar.setTime(date);`,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个`calendar.setTime(date);`，结果肯定就变得混乱了。\n\n上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。\n\n解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。\n\n先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。\n\n还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：\n\n```\n//以下操作在线程A中执行\ni = 1;\n\n//以下操作在线程B中执行\nj = i;\n\n//以下操作在线程C中执行\ni = 2;\n```\n\n假设线程A中的操作`i=1`先行发生于线程B的操作`j=i`,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，`i=1`的结果可以被B观察到。\n\n现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。\n\n其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。\n\n你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性...\n\n如果还没有理解所谓的先行发生原则的话，可以看一下[这篇文章](http://ifeve.com/easy-happens-before/)。\n\n下面介绍几个java内存模型中存在的先行发生关系：\n\n**程序次序规则**：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。\n\n**管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。\n\n**volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。\n\n**传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。\n\n以上只是一部分先行发生关系，其他的不再一一介绍。\n\n那么，先行发生原则如何使用呢？我们看一个例子：\n\n```java\nprivate int value = 0;\n\npublic void setValue(int value){\n\tthis.value = value;\n}\n\npublic int getValue(){\n\treturn value;\n}\n```\n\n假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？\n\n套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看[这个](http://wiki.jikexueyuan.com/project/java-memory-model/lock.html)\n\n通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。\n\n## Volatile关键字\n\n通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。\n\nvolatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：**保证内存可见性和禁止重排序**。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：\n\n```java\npublic class VolatileTest {\n\tpublic static volatile int race = 0;\n\t\n\tpublic static void increase(){\n\t\trace++;\n\t}\n\t\n\tprivate static int THREAD_COUNT = 20;\n\t\n\tpublic static void main(String args[]) {\n\t\tThread[] threads = new Thread[THREAD_COUNT];\n\t\tfor (int i = 0; i < THREAD_COUNT; i++) {\n\t\t\tthreads[i] = new Thread(new Runnable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i< 10000; i++) {\n\t\t\t\t\t\tincrease();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthreads[i].start();\n\t\t}\n\t\twhile (Thread.activeCount()>1) {\n\t\t\tThread.yield();\n\t\t}\n\t\tSystem.out.println(race);\n\t}\n}\n\n```\n\n```\n运行结果：130310 //每次运行结果并不相同\n```\n\n可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于`race++`,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。\n\n这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。\n\n现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：**每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量**。\n\n当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。\n\n当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。\n\n关于volatile怎么实现内存可见性，是通过一个叫[内存屏障](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C)的东西来实现的。具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。\n\n关于volatile关键字的禁止重排序，具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n我们从先行发生原则的角度看一下volatile的禁止重排序：\n\n{% asset_img volatile.png volatile先行发生原则 %}\n\n其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。\n\n根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。\n\n即：**普通读写不能与其后的所有写volatile变量重排序**。同理，**普通读写不能与之前的所有读volatile变量重排序**。\n\n下面看看volatile的使用场景：\n\n1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n\n2.变量不需要与其他状态的变量共同参与不变约束。\n\n第一点就很好理解了，volatile不保证原子性嘛~~\n\n**第二点我也有点疑惑，待研究...**\n\n关于volatile的使用场景，可以看看这篇文章：[Java 理论与实践: 正确使用 Volatile 变量](http://www.ibm.com/developerworks/cn/java/j-jtp06197.html)\n\n## 最后\n\n终于把自己想要总结的写完了~~断断续续写了四个小时...好累...\n\n加油！\n\n\n\n\n\n","source":"_posts/理解java内存模型.md","raw":"---\nlayout: post\ntitle: 理解java内存模型\ndate: 2016-09-10 10:32:40\ncategories: 技术\ntags: java\n---\n\n最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~\n\n## 并发为啥会出现问题\n\nPS：2016/9/13更新：今天在地铁上看到这篇文章：[Java 并发原理无废话指南](http://toutiao.io/posts/493923/app_preview),感觉跟我这一小节要说明的问题比较相似，参考一下。\n\n### 原子性\n\n其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：\n\n```java\npublic class BankAccount {\n\tprivate static int accountBalance = 10000;\n\n\tstatic class Save implements Runnable {\n\t\tprivate int money;\n\n\t\tpublic Save(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\t//存钱\n\t\t\tint tempAccount = accountBalance + money;\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次存入：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tstatic class Obtain implements Runnable {\n\n\t\tprivate int money;\n\n\t\tpublic Obtain(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (money > accountBalance) {\n\t\t\t\tSystem.out.println(\"余额不足\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//取钱\n\t\t\tint tempAccount = accountBalance - money;\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);//艾玛，卡了一秒\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次取出：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tint saveMoney = 10000;\n\t\tint obtainMoney = 10000;\n\t\t//自己取钱\n\t\tThread obtain = new Thread(new Obtain(obtainMoney));\n\t\t//老婆存钱\n\t\tThread save = new Thread(new Save(saveMoney));\n\t\tobtain.start();\n\t\tsave.start();\n\t}\n\n}\n```\n\n输出结果：\n\n```\n此次存入：10000\n当前余额：20000\n此次取出：10000\n当前余额：0\n```\n\n可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。\n\n分析一下出现问题的原因：\n\n出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。\n\n这就涉及到线程并发的第一个问题：原子性。\n\n我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。\n\n```\n//取钱\nint tempAccount = accountBalance - money;\n\n//设置余额\naccountBalance = tempAccount;\n```\n\n为了实现这种错误的效果，我故意把\n\n```\naccountBalance -= accountBalance;\n```\n\n拆成了上面的两行。其实`accountBalance -= accountBalance;`本身就不是一个原子操作，拆成两行是为了放大这种效果。\n\n通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。\n\n原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。\n\njava中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。\n\n那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。\n\n### 可见性\n\n组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。\n\nJava虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）\n\n画个图：\n\n{% asset_img 内存模型.png 内存模型 %}\n\n这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。\n\n我们回到上述的例子：\n\n上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似`accountBalance -= accountBalance;`这样的操作是原子性操作，设想以下的场景：\n\n1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时`accountBalance~ = 20000;accountBalance = 10000;`\n\n2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时`accountBalance~ = 0;accountBalance = 10000;`\n\n3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；\n\n4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；\n\n通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。\n\n我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。\n\n### 有序性\n\nCpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。\n\n以下例子来自《深入理解Java虚拟机》：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\nconfigOptions = new HashMap();\nconfigText = readConfigFile(flieName);\nprocessConfigOptions(configText,configOptions);\ninitialized = true;\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\nwhile(!initialized){\n\tsleep();\n}\n//使用线程A中初始化好的配置信息\ndoSomethingWithConfig();\n```\n\n在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码`initialized=true`被提前执行，这样线程B中使用配置信息的代码就可能出现错误。\n\n所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\npublic synchronized void init(){\n\tconfigOptions = new HashMap();\n\tconfigText = readConfigFile(flieName);\n\tprocessConfigOptions(configText,configOptions);\n\tinitialized = true;\n}\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\npublic synchronized void doSomething(){\n\twhile(!initialized){\n\t\tsleep();\n\t}\n\t//使用线程A中初始化好的配置信息\n\tdoSomethingWithConfig();\n}\n```\n注意上面两个方法在同一个类中实现。\n\n至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇[synchronized的用法](http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/)，对synchronized的使用更加得心应手啦！\n\n## 先行发生原则\n\n没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。\n\n比如我想到了之前宇哥跟我提到的一个bug:\n\n在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。\n\n后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用`calendar.setTime(date);`,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个`calendar.setTime(date);`，结果肯定就变得混乱了。\n\n上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。\n\n解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。\n\n先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。\n\n还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：\n\n```\n//以下操作在线程A中执行\ni = 1;\n\n//以下操作在线程B中执行\nj = i;\n\n//以下操作在线程C中执行\ni = 2;\n```\n\n假设线程A中的操作`i=1`先行发生于线程B的操作`j=i`,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，`i=1`的结果可以被B观察到。\n\n现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。\n\n其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。\n\n你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性...\n\n如果还没有理解所谓的先行发生原则的话，可以看一下[这篇文章](http://ifeve.com/easy-happens-before/)。\n\n下面介绍几个java内存模型中存在的先行发生关系：\n\n**程序次序规则**：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。\n\n**管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。\n\n**volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。\n\n**传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。\n\n以上只是一部分先行发生关系，其他的不再一一介绍。\n\n那么，先行发生原则如何使用呢？我们看一个例子：\n\n```java\nprivate int value = 0;\n\npublic void setValue(int value){\n\tthis.value = value;\n}\n\npublic int getValue(){\n\treturn value;\n}\n```\n\n假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？\n\n套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看[这个](http://wiki.jikexueyuan.com/project/java-memory-model/lock.html)\n\n通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。\n\n## Volatile关键字\n\n通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。\n\nvolatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：**保证内存可见性和禁止重排序**。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：\n\n```java\npublic class VolatileTest {\n\tpublic static volatile int race = 0;\n\t\n\tpublic static void increase(){\n\t\trace++;\n\t}\n\t\n\tprivate static int THREAD_COUNT = 20;\n\t\n\tpublic static void main(String args[]) {\n\t\tThread[] threads = new Thread[THREAD_COUNT];\n\t\tfor (int i = 0; i < THREAD_COUNT; i++) {\n\t\t\tthreads[i] = new Thread(new Runnable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i< 10000; i++) {\n\t\t\t\t\t\tincrease();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthreads[i].start();\n\t\t}\n\t\twhile (Thread.activeCount()>1) {\n\t\t\tThread.yield();\n\t\t}\n\t\tSystem.out.println(race);\n\t}\n}\n\n```\n\n```\n运行结果：130310 //每次运行结果并不相同\n```\n\n可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于`race++`,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。\n\n这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。\n\n现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：**每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量**。\n\n当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。\n\n当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。\n\n关于volatile怎么实现内存可见性，是通过一个叫[内存屏障](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C)的东西来实现的。具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。\n\n关于volatile关键字的禁止重排序，具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n我们从先行发生原则的角度看一下volatile的禁止重排序：\n\n{% asset_img volatile.png volatile先行发生原则 %}\n\n其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。\n\n根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。\n\n即：**普通读写不能与其后的所有写volatile变量重排序**。同理，**普通读写不能与之前的所有读volatile变量重排序**。\n\n下面看看volatile的使用场景：\n\n1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n\n2.变量不需要与其他状态的变量共同参与不变约束。\n\n第一点就很好理解了，volatile不保证原子性嘛~~\n\n**第二点我也有点疑惑，待研究...**\n\n关于volatile的使用场景，可以看看这篇文章：[Java 理论与实践: 正确使用 Volatile 变量](http://www.ibm.com/developerworks/cn/java/j-jtp06197.html)\n\n## 最后\n\n终于把自己想要总结的写完了~~断断续续写了四个小时...好累...\n\n加油！\n\n\n\n\n\n","slug":"理解java内存模型","published":1,"updated":"2017-02-19T13:08:11.044Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlt10045vegcsmme8k3a","content":"<p>最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~</p>\n<h2 id=\"并发为啥会出现问题\"><a href=\"#并发为啥会出现问题\" class=\"headerlink\" title=\"并发为啥会出现问题\"></a>并发为啥会出现问题</h2><p>PS：2016/9/13更新：今天在地铁上看到这篇文章：<a href=\"http://toutiao.io/posts/493923/app_preview\" target=\"_blank\" rel=\"external\">Java 并发原理无废话指南</a>,感觉跟我这一小节要说明的问题比较相似，参考一下。</p>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankAccount</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> accountBalance = <span class=\"number\">10000</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Save</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Save</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//存钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance + money;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次存入：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Obtain</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Obtain</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (money &gt; accountBalance) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"余额不足\"</span>);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//取钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance - money;</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//艾玛，卡了一秒</span></div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次取出：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> saveMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> obtainMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"comment\">//自己取钱</span></div><div class=\"line\">\t\tThread obtain = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Obtain(obtainMoney));</div><div class=\"line\">\t\t<span class=\"comment\">//老婆存钱</span></div><div class=\"line\">\t\tThread save = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Save(saveMoney));</div><div class=\"line\">\t\tobtain.start();</div><div class=\"line\">\t\tsave.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">此次存入：10000</div><div class=\"line\">当前余额：20000</div><div class=\"line\">此次取出：10000</div><div class=\"line\">当前余额：0</div></pre></td></tr></table></figure>\n<p>可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。</p>\n<p>分析一下出现问题的原因：</p>\n<p>出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。</p>\n<p>这就涉及到线程并发的第一个问题：原子性。</p>\n<p>我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//取钱</div><div class=\"line\">int tempAccount = accountBalance - money;</div><div class=\"line\"></div><div class=\"line\">//设置余额</div><div class=\"line\">accountBalance = tempAccount;</div></pre></td></tr></table></figure>\n<p>为了实现这种错误的效果，我故意把</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">accountBalance -= accountBalance;</div></pre></td></tr></table></figure>\n<p>拆成了上面的两行。其实<code>accountBalance -= accountBalance;</code>本身就不是一个原子操作，拆成两行是为了放大这种效果。</p>\n<p>通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。</p>\n<p>原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。</p>\n<p>java中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。</p>\n<p>那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。</p>\n<h3 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h3><p>组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。</p>\n<p>Java虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）</p>\n<p>画个图：</p>\n<img src=\"/2016/09/10/理解java内存模型/内存模型.png\" alt=\"内存模型\" title=\"内存模型\">\n<p>这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。</p>\n<p>我们回到上述的例子：</p>\n<p>上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似<code>accountBalance -= accountBalance;</code>这样的操作是原子性操作，设想以下的场景：</p>\n<p>1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时<code>accountBalance~ = 20000;accountBalance = 10000;</code></p>\n<p>2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时<code>accountBalance~ = 0;accountBalance = 10000;</code></p>\n<p>3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；</p>\n<p>4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；</p>\n<p>通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。</p>\n<p>我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。</p>\n<h3 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h3><p>Cpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。</p>\n<p>以下例子来自《深入理解Java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\">configOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">configText = readConfigFile(flieName);</div><div class=\"line\">processConfigOptions(configText,configOptions);</div><div class=\"line\">initialized = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\tsleep();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">doSomethingWithConfig();</div></pre></td></tr></table></figure>\n<p>在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码<code>initialized=true</code>被提前执行，这样线程B中使用配置信息的代码就可能出现错误。</p>\n<p>所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tconfigOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">\tconfigText = readConfigFile(flieName);</div><div class=\"line\">\tprocessConfigOptions(configText,configOptions);</div><div class=\"line\">\tinitialized = <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\t\tsleep();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">\tdoSomethingWithConfig();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意上面两个方法在同一个类中实现。</p>\n<p>至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇<a href=\"http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/\">synchronized的用法</a>，对synchronized的使用更加得心应手啦！</p>\n<h2 id=\"先行发生原则\"><a href=\"#先行发生原则\" class=\"headerlink\" title=\"先行发生原则\"></a>先行发生原则</h2><p>没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。</p>\n<p>比如我想到了之前宇哥跟我提到的一个bug:</p>\n<p>在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。</p>\n<p>后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用<code>calendar.setTime(date);</code>,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个<code>calendar.setTime(date);</code>，结果肯定就变得混乱了。</p>\n<p>上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。</p>\n<p>解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。</p>\n<p>先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。</p>\n<p>还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下操作在线程A中执行</div><div class=\"line\">i = 1;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程B中执行</div><div class=\"line\">j = i;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程C中执行</div><div class=\"line\">i = 2;</div></pre></td></tr></table></figure>\n<p>假设线程A中的操作<code>i=1</code>先行发生于线程B的操作<code>j=i</code>,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，<code>i=1</code>的结果可以被B观察到。</p>\n<p>现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。</p>\n<p>其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。</p>\n<p>你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性…</p>\n<p>如果还没有理解所谓的先行发生原则的话，可以看一下<a href=\"http://ifeve.com/easy-happens-before/\" target=\"_blank\" rel=\"external\">这篇文章</a>。</p>\n<p>下面介绍几个java内存模型中存在的先行发生关系：</p>\n<p><strong>程序次序规则</strong>：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。</p>\n<p><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。</p>\n<p><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。</p>\n<p><strong>传递性</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。</p>\n<p>以上只是一部分先行发生关系，其他的不再一一介绍。</p>\n<p>那么，先行发生原则如何使用呢？我们看一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？</p>\n<p>套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看<a href=\"http://wiki.jikexueyuan.com/project/java-memory-model/lock.html\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。</p>\n<h2 id=\"Volatile关键字\"><a href=\"#Volatile关键字\" class=\"headerlink\" title=\"Volatile关键字\"></a>Volatile关键字</h2><p>通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。</p>\n<p>volatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：<strong>保证内存可见性和禁止重排序</strong>。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> race = <span class=\"number\">0</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\trace++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> THREAD_COUNT = <span class=\"number\">20</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\tThread[] threads = <span class=\"keyword\">new</span> Thread[THREAD_COUNT];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; THREAD_COUNT; i++) &#123;</div><div class=\"line\">\t\t\tthreads[i] = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t\t\t</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"number\">10000</span>; i++) &#123;</div><div class=\"line\">\t\t\t\t\t\tincrease();</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t\tthreads[i].start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (Thread.activeCount()&gt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">\t\t\tThread.yield();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.println(race);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">运行结果：130310 //每次运行结果并不相同</div></pre></td></tr></table></figure>\n<p>可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于<code>race++</code>,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。</p>\n<p>这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。</p>\n<p>现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：<strong>每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量</strong>。</p>\n<p>当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。</p>\n<p>当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。</p>\n<p>关于volatile怎么实现内存可见性，是通过一个叫<a href=\"https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C\" target=\"_blank\" rel=\"external\">内存屏障</a>的东西来实现的。具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。</p>\n<p>关于volatile关键字的禁止重排序，具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>我们从先行发生原则的角度看一下volatile的禁止重排序：</p>\n<img src=\"/2016/09/10/理解java内存模型/volatile.png\" alt=\"volatile先行发生原则\" title=\"volatile先行发生原则\">\n<p>其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。</p>\n<p>根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。</p>\n<p>即：<strong>普通读写不能与其后的所有写volatile变量重排序</strong>。同理，<strong>普通读写不能与之前的所有读volatile变量重排序</strong>。</p>\n<p>下面看看volatile的使用场景：</p>\n<p>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>\n<p>2.变量不需要与其他状态的变量共同参与不变约束。</p>\n<p>第一点就很好理解了，volatile不保证原子性嘛~~</p>\n<p><strong>第二点我也有点疑惑，待研究…</strong></p>\n<p>关于volatile的使用场景，可以看看这篇文章：<a href=\"http://www.ibm.com/developerworks/cn/java/j-jtp06197.html\" target=\"_blank\" rel=\"external\">Java 理论与实践: 正确使用 Volatile 变量</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>终于把自己想要总结的写完了~~断断续续写了四个小时…好累…</p>\n<p>加油！</p>\n","excerpt":"","more":"<p>最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~</p>\n<h2 id=\"并发为啥会出现问题\"><a href=\"#并发为啥会出现问题\" class=\"headerlink\" title=\"并发为啥会出现问题\"></a>并发为啥会出现问题</h2><p>PS：2016/9/13更新：今天在地铁上看到这篇文章：<a href=\"http://toutiao.io/posts/493923/app_preview\">Java 并发原理无废话指南</a>,感觉跟我这一小节要说明的问题比较相似，参考一下。</p>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankAccount</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> accountBalance = <span class=\"number\">10000</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Save</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Save</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//存钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance + money;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次存入：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Obtain</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Obtain</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (money &gt; accountBalance) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"余额不足\"</span>);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//取钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance - money;</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//艾玛，卡了一秒</span></div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次取出：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> saveMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> obtainMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"comment\">//自己取钱</span></div><div class=\"line\">\t\tThread obtain = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Obtain(obtainMoney));</div><div class=\"line\">\t\t<span class=\"comment\">//老婆存钱</span></div><div class=\"line\">\t\tThread save = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Save(saveMoney));</div><div class=\"line\">\t\tobtain.start();</div><div class=\"line\">\t\tsave.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">此次存入：10000</div><div class=\"line\">当前余额：20000</div><div class=\"line\">此次取出：10000</div><div class=\"line\">当前余额：0</div></pre></td></tr></table></figure>\n<p>可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。</p>\n<p>分析一下出现问题的原因：</p>\n<p>出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。</p>\n<p>这就涉及到线程并发的第一个问题：原子性。</p>\n<p>我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//取钱</div><div class=\"line\">int tempAccount = accountBalance - money;</div><div class=\"line\"></div><div class=\"line\">//设置余额</div><div class=\"line\">accountBalance = tempAccount;</div></pre></td></tr></table></figure>\n<p>为了实现这种错误的效果，我故意把</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">accountBalance -= accountBalance;</div></pre></td></tr></table></figure>\n<p>拆成了上面的两行。其实<code>accountBalance -= accountBalance;</code>本身就不是一个原子操作，拆成两行是为了放大这种效果。</p>\n<p>通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。</p>\n<p>原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。</p>\n<p>java中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。</p>\n<p>那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。</p>\n<h3 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h3><p>组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。</p>\n<p>Java虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）</p>\n<p>画个图：</p>\n<img src=\"/2016/09/10/理解java内存模型/内存模型.png\" alt=\"内存模型\" title=\"内存模型\">\n<p>这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。</p>\n<p>我们回到上述的例子：</p>\n<p>上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似<code>accountBalance -= accountBalance;</code>这样的操作是原子性操作，设想以下的场景：</p>\n<p>1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时<code>accountBalance~ = 20000;accountBalance = 10000;</code></p>\n<p>2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时<code>accountBalance~ = 0;accountBalance = 10000;</code></p>\n<p>3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；</p>\n<p>4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；</p>\n<p>通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。</p>\n<p>我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。</p>\n<h3 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h3><p>Cpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。</p>\n<p>以下例子来自《深入理解Java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\">configOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">configText = readConfigFile(flieName);</div><div class=\"line\">processConfigOptions(configText,configOptions);</div><div class=\"line\">initialized = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\tsleep();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">doSomethingWithConfig();</div></pre></td></tr></table></figure>\n<p>在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码<code>initialized=true</code>被提前执行，这样线程B中使用配置信息的代码就可能出现错误。</p>\n<p>所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tconfigOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">\tconfigText = readConfigFile(flieName);</div><div class=\"line\">\tprocessConfigOptions(configText,configOptions);</div><div class=\"line\">\tinitialized = <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\t\tsleep();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">\tdoSomethingWithConfig();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意上面两个方法在同一个类中实现。</p>\n<p>至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇<a href=\"http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/\">synchronized的用法</a>，对synchronized的使用更加得心应手啦！</p>\n<h2 id=\"先行发生原则\"><a href=\"#先行发生原则\" class=\"headerlink\" title=\"先行发生原则\"></a>先行发生原则</h2><p>没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。</p>\n<p>比如我想到了之前宇哥跟我提到的一个bug:</p>\n<p>在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。</p>\n<p>后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用<code>calendar.setTime(date);</code>,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个<code>calendar.setTime(date);</code>，结果肯定就变得混乱了。</p>\n<p>上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。</p>\n<p>解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。</p>\n<p>先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。</p>\n<p>还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下操作在线程A中执行</div><div class=\"line\">i = 1;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程B中执行</div><div class=\"line\">j = i;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程C中执行</div><div class=\"line\">i = 2;</div></pre></td></tr></table></figure>\n<p>假设线程A中的操作<code>i=1</code>先行发生于线程B的操作<code>j=i</code>,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，<code>i=1</code>的结果可以被B观察到。</p>\n<p>现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。</p>\n<p>其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。</p>\n<p>你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性…</p>\n<p>如果还没有理解所谓的先行发生原则的话，可以看一下<a href=\"http://ifeve.com/easy-happens-before/\">这篇文章</a>。</p>\n<p>下面介绍几个java内存模型中存在的先行发生关系：</p>\n<p><strong>程序次序规则</strong>：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。</p>\n<p><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。</p>\n<p><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。</p>\n<p><strong>传递性</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。</p>\n<p>以上只是一部分先行发生关系，其他的不再一一介绍。</p>\n<p>那么，先行发生原则如何使用呢？我们看一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？</p>\n<p>套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看<a href=\"http://wiki.jikexueyuan.com/project/java-memory-model/lock.html\">这个</a></p>\n<p>通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。</p>\n<h2 id=\"Volatile关键字\"><a href=\"#Volatile关键字\" class=\"headerlink\" title=\"Volatile关键字\"></a>Volatile关键字</h2><p>通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。</p>\n<p>volatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：<strong>保证内存可见性和禁止重排序</strong>。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> race = <span class=\"number\">0</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\trace++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> THREAD_COUNT = <span class=\"number\">20</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\tThread[] threads = <span class=\"keyword\">new</span> Thread[THREAD_COUNT];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; THREAD_COUNT; i++) &#123;</div><div class=\"line\">\t\t\tthreads[i] = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t\t\t</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"number\">10000</span>; i++) &#123;</div><div class=\"line\">\t\t\t\t\t\tincrease();</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t\tthreads[i].start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (Thread.activeCount()&gt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">\t\t\tThread.yield();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.println(race);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">运行结果：130310 //每次运行结果并不相同</div></pre></td></tr></table></figure>\n<p>可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于<code>race++</code>,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。</p>\n<p>这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。</p>\n<p>现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：<strong>每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量</strong>。</p>\n<p>当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。</p>\n<p>当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。</p>\n<p>关于volatile怎么实现内存可见性，是通过一个叫<a href=\"https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C\">内存屏障</a>的东西来实现的。具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\">这个</a></p>\n<p>所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。</p>\n<p>关于volatile关键字的禁止重排序，具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\">这个</a></p>\n<p>我们从先行发生原则的角度看一下volatile的禁止重排序：</p>\n<img src=\"/2016/09/10/理解java内存模型/volatile.png\" alt=\"volatile先行发生原则\" title=\"volatile先行发生原则\">\n<p>其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。</p>\n<p>根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。</p>\n<p>即：<strong>普通读写不能与其后的所有写volatile变量重排序</strong>。同理，<strong>普通读写不能与之前的所有读volatile变量重排序</strong>。</p>\n<p>下面看看volatile的使用场景：</p>\n<p>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>\n<p>2.变量不需要与其他状态的变量共同参与不变约束。</p>\n<p>第一点就很好理解了，volatile不保证原子性嘛~~</p>\n<p><strong>第二点我也有点疑惑，待研究…</strong></p>\n<p>关于volatile的使用场景，可以看看这篇文章：<a href=\"http://www.ibm.com/developerworks/cn/java/j-jtp06197.html\">Java 理论与实践: 正确使用 Volatile 变量</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>终于把自己想要总结的写完了~~断断续续写了四个小时…好累…</p>\n<p>加油！</p>\n"},{"layout":"post","title":"理解notify notifyall sleep","date":"2016-08-31T13:27:09.000Z","_content":"\n今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。\n\n## 从线程状态说起\n\n一般的操作系统中，线程的状态大概有这么几个：\n\n1. 执行：线程获得cpu，程序正在执行\n\n2. 就绪：线程已经准备好运行，只要获得cpu，便立即执行\n\n3. 阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度\n\n4. 挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。\n\n5. 激活：把一个挂起的线程激活\n\n着重理解一下几个关键状态的转换：\n\n活动就绪-->静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。\n\n活动阻塞-->静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。\n\n注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。\n\n画个图理解一下：\n\n{% asset_img 线程状态.png %}\n\n线程创建和终止状态不再讨论。\n\n## wait\n\nwait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。\n\n当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。\n\n调用wait方法，相当于上图中**执行->活动阻塞->静止阻塞**的过程。同时，wait方法释放了对象的锁，然后阻塞，挂起，等待被唤醒。\n\n## notify\n\n当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒(挂起)的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒(激活),这个过程相当于上图中**静止阻塞->活动阻塞**的过程。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。\n\n此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图**活动阻塞->活动就绪**的过程。此时线程等待调度执行。\n\n需要注意的是，notify不恰当使用很有可能造成死锁问题。\n\n## notifyAll\n\n当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒(挂起)的线程(调用了A的wait方法的线程)唤醒(激活)。这些线程会开始竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。\n\n## sleep\n\n与以上三个关键字不同的是，sleep方法是Thread中的方法。\n\n当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。调用sleep的目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;\n\n调用线程Y的sleep(1000)sleep方法，相当于上图中**执行->静止就绪状态**。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。\n\n## synchronized\n\n当程序执行遇到synchronized关键字的时候，若此时锁被占用，则线程被阻塞。相当于上图中**执行->活动阻塞**过程。\n\nPS：上述的几个状态跟java中描述的Thread.state并不尽相同。而且底层真正的运行情况(OS的线程状态)是否是跟以上描述相同也有待考究。但是我理解的这几个关键字对外的表现应该与上述描述是一样的。\n\n参考知乎上的一个提问：[java sleep和wait的区别的疑惑?](https://www.zhihu.com/question/23328075)\n\n## 使用场景\n\nObject.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？\n\n在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。\n\n例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。","source":"_posts/理解notify notifyall sleep.md","raw":"layout: post\ntitle: 理解notify notifyall sleep\ndate: 2016-08-31 21:27:09\ncategories: 编程\ntags:\n- java\n- 多线程 \n---\n\n今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。\n\n## 从线程状态说起\n\n一般的操作系统中，线程的状态大概有这么几个：\n\n1. 执行：线程获得cpu，程序正在执行\n\n2. 就绪：线程已经准备好运行，只要获得cpu，便立即执行\n\n3. 阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度\n\n4. 挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。\n\n5. 激活：把一个挂起的线程激活\n\n着重理解一下几个关键状态的转换：\n\n活动就绪-->静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。\n\n活动阻塞-->静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。\n\n注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。\n\n画个图理解一下：\n\n{% asset_img 线程状态.png %}\n\n线程创建和终止状态不再讨论。\n\n## wait\n\nwait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。\n\n当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。\n\n调用wait方法，相当于上图中**执行->活动阻塞->静止阻塞**的过程。同时，wait方法释放了对象的锁，然后阻塞，挂起，等待被唤醒。\n\n## notify\n\n当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒(挂起)的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒(激活),这个过程相当于上图中**静止阻塞->活动阻塞**的过程。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。\n\n此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图**活动阻塞->活动就绪**的过程。此时线程等待调度执行。\n\n需要注意的是，notify不恰当使用很有可能造成死锁问题。\n\n## notifyAll\n\n当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒(挂起)的线程(调用了A的wait方法的线程)唤醒(激活)。这些线程会开始竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。\n\n## sleep\n\n与以上三个关键字不同的是，sleep方法是Thread中的方法。\n\n当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。调用sleep的目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;\n\n调用线程Y的sleep(1000)sleep方法，相当于上图中**执行->静止就绪状态**。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。\n\n## synchronized\n\n当程序执行遇到synchronized关键字的时候，若此时锁被占用，则线程被阻塞。相当于上图中**执行->活动阻塞**过程。\n\nPS：上述的几个状态跟java中描述的Thread.state并不尽相同。而且底层真正的运行情况(OS的线程状态)是否是跟以上描述相同也有待考究。但是我理解的这几个关键字对外的表现应该与上述描述是一样的。\n\n参考知乎上的一个提问：[java sleep和wait的区别的疑惑?](https://www.zhihu.com/question/23328075)\n\n## 使用场景\n\nObject.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？\n\n在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。\n\n例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。","slug":"理解notify notifyall sleep","published":1,"updated":"2017-02-19T13:08:11.045Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlt30048vegcv6gu397j","content":"<p>今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。</p>\n<h2 id=\"从线程状态说起\"><a href=\"#从线程状态说起\" class=\"headerlink\" title=\"从线程状态说起\"></a>从线程状态说起</h2><p>一般的操作系统中，线程的状态大概有这么几个：</p>\n<ol>\n<li><p>执行：线程获得cpu，程序正在执行</p>\n</li>\n<li><p>就绪：线程已经准备好运行，只要获得cpu，便立即执行</p>\n</li>\n<li><p>阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度</p>\n</li>\n<li><p>挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。</p>\n</li>\n<li><p>激活：把一个挂起的线程激活</p>\n</li>\n</ol>\n<p>着重理解一下几个关键状态的转换：</p>\n<p>活动就绪–&gt;静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。</p>\n<p>活动阻塞–&gt;静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。</p>\n<p>注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。</p>\n<p>画个图理解一下：</p>\n<img src=\"/2016/08/31/理解notify%20notifyall%20sleep/线程状态.png\" alt=\"线程状态.png\" title=\"\">\n<p>线程创建和终止状态不再讨论。</p>\n<h2 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h2><p>wait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。</p>\n<p>当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。</p>\n<p>调用wait方法，相当于上图中<strong>执行-&gt;活动阻塞-&gt;静止阻塞</strong>的过程。同时，wait方法释放了对象的锁，然后阻塞，挂起，等待被唤醒。</p>\n<h2 id=\"notify\"><a href=\"#notify\" class=\"headerlink\" title=\"notify\"></a>notify</h2><p>当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒(挂起)的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒(激活),这个过程相当于上图中<strong>静止阻塞-&gt;活动阻塞</strong>的过程。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。</p>\n<p>此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图<strong>活动阻塞-&gt;活动就绪</strong>的过程。此时线程等待调度执行。</p>\n<p>需要注意的是，notify不恰当使用很有可能造成死锁问题。</p>\n<h2 id=\"notifyAll\"><a href=\"#notifyAll\" class=\"headerlink\" title=\"notifyAll\"></a>notifyAll</h2><p>当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒(挂起)的线程(调用了A的wait方法的线程)唤醒(激活)。这些线程会开始竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。</p>\n<h2 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep\"></a>sleep</h2><p>与以上三个关键字不同的是，sleep方法是Thread中的方法。</p>\n<p>当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。调用sleep的目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;</p>\n<p>调用线程Y的sleep(1000)sleep方法，相当于上图中<strong>执行-&gt;静止就绪状态</strong>。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。</p>\n<h2 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h2><p>当程序执行遇到synchronized关键字的时候，若此时锁被占用，则线程被阻塞。相当于上图中<strong>执行-&gt;活动阻塞</strong>过程。</p>\n<p>PS：上述的几个状态跟java中描述的Thread.state并不尽相同。而且底层真正的运行情况(OS的线程状态)是否是跟以上描述相同也有待考究。但是我理解的这几个关键字对外的表现应该与上述描述是一样的。</p>\n<p>参考知乎上的一个提问：<a href=\"https://www.zhihu.com/question/23328075\" target=\"_blank\" rel=\"external\">java sleep和wait的区别的疑惑?</a></p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>Object.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？</p>\n<p>在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。</p>\n<p>例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。</p>\n","excerpt":"","more":"<p>今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。</p>\n<h2 id=\"从线程状态说起\"><a href=\"#从线程状态说起\" class=\"headerlink\" title=\"从线程状态说起\"></a>从线程状态说起</h2><p>一般的操作系统中，线程的状态大概有这么几个：</p>\n<ol>\n<li><p>执行：线程获得cpu，程序正在执行</p>\n</li>\n<li><p>就绪：线程已经准备好运行，只要获得cpu，便立即执行</p>\n</li>\n<li><p>阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度</p>\n</li>\n<li><p>挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。</p>\n</li>\n<li><p>激活：把一个挂起的线程激活</p>\n</li>\n</ol>\n<p>着重理解一下几个关键状态的转换：</p>\n<p>活动就绪–&gt;静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。</p>\n<p>活动阻塞–&gt;静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。</p>\n<p>注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。</p>\n<p>画个图理解一下：</p>\n<img src=\"/2016/08/31/理解notify%20notifyall%20sleep/线程状态.png\" alt=\"线程状态.png\" title=\"\">\n<p>线程创建和终止状态不再讨论。</p>\n<h2 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h2><p>wait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。</p>\n<p>当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。</p>\n<p>调用wait方法，相当于上图中<strong>执行-&gt;活动阻塞-&gt;静止阻塞</strong>的过程。同时，wait方法释放了对象的锁，然后阻塞，挂起，等待被唤醒。</p>\n<h2 id=\"notify\"><a href=\"#notify\" class=\"headerlink\" title=\"notify\"></a>notify</h2><p>当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒(挂起)的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒(激活),这个过程相当于上图中<strong>静止阻塞-&gt;活动阻塞</strong>的过程。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。</p>\n<p>此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图<strong>活动阻塞-&gt;活动就绪</strong>的过程。此时线程等待调度执行。</p>\n<p>需要注意的是，notify不恰当使用很有可能造成死锁问题。</p>\n<h2 id=\"notifyAll\"><a href=\"#notifyAll\" class=\"headerlink\" title=\"notifyAll\"></a>notifyAll</h2><p>当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒(挂起)的线程(调用了A的wait方法的线程)唤醒(激活)。这些线程会开始竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。</p>\n<h2 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep\"></a>sleep</h2><p>与以上三个关键字不同的是，sleep方法是Thread中的方法。</p>\n<p>当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。调用sleep的目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;</p>\n<p>调用线程Y的sleep(1000)sleep方法，相当于上图中<strong>执行-&gt;静止就绪状态</strong>。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。</p>\n<h2 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h2><p>当程序执行遇到synchronized关键字的时候，若此时锁被占用，则线程被阻塞。相当于上图中<strong>执行-&gt;活动阻塞</strong>过程。</p>\n<p>PS：上述的几个状态跟java中描述的Thread.state并不尽相同。而且底层真正的运行情况(OS的线程状态)是否是跟以上描述相同也有待考究。但是我理解的这几个关键字对外的表现应该与上述描述是一样的。</p>\n<p>参考知乎上的一个提问：<a href=\"https://www.zhihu.com/question/23328075\">java sleep和wait的区别的疑惑?</a></p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>Object.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？</p>\n<p>在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。</p>\n<p>例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。</p>\n"},{"layout":"post","title":"记录工作遇到的坑","date":"2016-09-24T08:30:44.000Z","_content":"\n昨天晚上12.30才进的家门，回来之后还远程合了个代码打了个包，发布restAPI新版本之用。这一周的主要工作就是在做一个web服务器，是一个集群的中间件。因为着急发布新版本，所以昨晚加班到12点多...\n\n主要实现了几个接口，实现了ssl双向验证功能。其实ssl双向验证的功能主要是了解ssl原理之后如何配置的问题。期间还学习了session和cookie的原理。ssl与cookie、session单开一篇进行总结。这篇日志记录一下这周工作中遇到的一些坑，不一定是技术上的，但是遇到这些小问题还是耽误了一些时间。这篇日志也会持续更新，把以后遇到的坑都总结到这里来。\n\n希望以后遇到类似的情况能够迅速找到原因将其解决，同时也希望能帮助到可能会看到这篇文章的人。\n\n## Spring项目通过export方法打包为jar的问题\n\n在前面的日志中已经有[专门的一篇](http://yukai.space/2016/09/19/Spring%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAjar/)来总结这个问题:**当通过export方式打包Spring项目时，一定要记得勾选Add Directory Entries这个选项，否则spring无法正确扫描到controller，发生404**\n\n## 使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常\n\n假如你的项目中有一个类似下面的controller来接收一个请求：\n\n```java\n@GET\n@RequestMapping(\"web/{groupName}\")\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\npublic void getWorkerAddress(HttpServletRequest request, HttpServletResponse response,\n\t\t@PathVariable String groupName) {\n\t\tdoSomething...\n}\t\t\n\n```\n\n当你的项目运行时你发起一个`http://ip:port/web/groupName1`这样的请求，那么很有可能服务器会报这样一个异常：**java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.**\n\n大概的意思就是参数名称信息没有在类文件中找到。若是浏览器为客户端，浏览器的页面是这样的：\n\n{% asset_img error.png error %}\n\n解决这个异常的方法有两种：\n\n**1.在@PathVariable注解后面加上参数名，比如：@PathVariable(\"groupName\")**\n\n**2.编译时将debug信息勾选进去：**\n\n{% asset_img compiler.png compiler %}\n\n编译时把上图绿色框中的单选框勾选，就不会报异常。原因在于Local variable属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量名称和描述符之间的映射关系。\n\n顺便了解一下上面四个选项的作用：\n\n{% asset_img gengeration.png compiler %}\n\n图片截取自：[Eclipse用户手册](http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-compiler.htm)\n\n其实就是java工程编译时的一些选项。当我们在debug时遇到问题，比如断点打不上，source not found等等或许修改这些选项可以得到解决。\n\n参考一篇文章：[java编译时生成调试信息选项详解（javac -g）](http://daimojingdeyu.iteye.com/blog/679030)\n\n## Windows环境下使用Curl，要使用双引号包裹内容\n\nweb服务器是通过curl来测试的。之前自己也没用过这个所谓的命令行浏览器工具。在机器上装好curl之后，把测试那边提供的脚本拿过来，由于脚本是linux环境下的，做了一点修改之后(其实就是直接换成.bat啦)就直接跑了。脚本内容类似这样：\n\n```\ncurl -X POST -H 'content-type: application/json' -d @del.txt https://localhost:8899/web/rest/data/load/topictarget  -k -b cookie.txt>delresult.txt\n```\n\n但是实际测试的过程中，发现收到的post的数据为null，确定了不是服务器的问题之后，感觉应该是curl使用的问题。查了一些资料，是说post的数据要使用双引号包裹，而不是单引号。由于是从del.txt中提取post的数据，所以不存在这个问题。后来将content-type: application/json 的单引号换成双引号之后，问题解决。\n\n**所以：Windows环境下使用Curl，要使用双引号包裹需要加引号的内容，而不是单引号**\n\n## Spring项目运行过程中，@Autowired注解的变量为null的问题\n\n2016/09/09 更新\n\n这两天开发了一个公众账号来做一些简单的记账工作。后台服务器是用springboot搭建的，测试过程中遇到了这么个情况:\n\n在运行时服务器报了空指针NullPointerException异常，debug看了一下，发现是一个使用了@Autowired注解的变量没有被初始化。但是按理来说使用了@Autowired注解某个变量后spring会自动为我们实例化这个变量的啊！谷歌了一下，找到了一个类似的情况：[Why is my Spring @Autowired field null?](http://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null).\n\n下面模拟一下问题出现的场景(代码来自上面的链接)：\n\n```java\n@Controller\npublic class MileageFeeController {    \n    @RequestMapping(\"/mileage/{miles}\")\n    @ResponseBody\n    public float mileageFee(@PathVariable int miles) {\n        MileageFeeCalculator calc = new MileageFeeCalculator();\n        return calc.mileageCharge(miles);\n    }\n}\n\n@Service\npublic class MileageFeeCalculator {\n\n    @Autowired\n    private MileageRateService rateService; // <--- should be autowired, is null\n\n    public float mileageCharge(final int miles) {\n        return (miles * rateService.ratePerMile()); // <--- throws NPE\n    }\n}\n\n@Service\npublic class MileageFeeCalculator {\n\n    @Autowired\n    private MileageRateService rateService; // <--- should be autowired, is null\n\n    public float mileageCharge(final int miles) {\n        return (miles * rateService.ratePerMile()); // <--- throws NPE\n    }\n}\n```\n\n访问MileageFeeController时报错：\n\n```\njava.lang.NullPointerException: null\n    at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13)\n    at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14)\n```\n\n可以看到，变量rateService是个空值。导致空指针异常...\n\n原因就在于MileageFeeController.mileageFee中使用了new这种方式实例化了MileageFeeCalculator对象，该对象中的rateService为空，我们使用new这种方式实例化对象时，无法通过spring的@Autowired注解自动实例化对象中的属性。解决的方法就是实例化对象时应该通知spring，使其能够自动配置。\n\n我采用了上述链接中的第三种方法，解决了问题：\n\n```java\n@Component\npublic class ApplicationContextHolder implements ApplicationContextAware {\n    private static ApplicationContext context;\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        context = applicationContext;   \n    }\n\n    public static ApplicationContext getContext() {\n        return context;\n    }\n}\n\n@Controller\npublic class MileageFeeController {    \n    @RequestMapping(\"/mileage/{miles}\")\n    @ResponseBody\n    public float mileageFee(@PathVariable int miles) {\n        MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);\n        return calc.mileageCharge(miles);\n    }\n}\n```\n\n发生这些问题的原因还是在于对框架的不熟悉，内部原理不甚明了。有机会真得研究研究spring的源码~~\n\n## @RestController与@Controller\n\n2016/10/24 更新\n\nSpringboot 使用 Thymeleaf 模板 打算给公众号加一点地图功能，按照[这个教程](https://hellokoding.com/spring-boot-hello-world-example-with-thymeleaf/)在springboot项目中配置Thymeleaf，但是每次都没有正确返回html页面，反而是返回了这个html的名称。试了几次才发现自己用错了@RestController这个注解...Controller代码如下：\n\n```java\n@RestController\n@RequestMapping(\"/wechat\")\npublic class MapController {\n    @RequestMapping(\"/map/showRestaurant\")\n    public String showRestaurant(@RequestParam(value = \"location_x\", required = true) String location_x,\n            @RequestParam(value = \"location_y\", required = true) String location_y,\n            @RequestParam(value = \"label\", required = true) String label, Model model) {\n        model.addAttribute(\"locationx\", location_x);\n        model.addAttribute(\"locationy\", location_y);\n        model.addAttribute(\"label\",label);\n        return \"hello\";\n    }\n}\n\n```\n问题原因就在于上面的@RestController这个注解，将其替换为@Controller便解决了。\n \n根本原因在于@RestController与@Controller[这两个注解之间的区别](http://stackoverflow.com/questions/25242321/difference-between-spring-controller-and-restcontroller-annotation)\n\n## Linux下可靠的启动webservice\n\n2016/12/14 更新\n\n今天线上webservice发现了一个问题，技服把出现的问题描述和日志发给了我，需要解决一下。最终确定不是代码的问题，而是linux下启动程序的方式引发的一个错误。虽然简单，却很容易被疏忽导致问题的发生，值得记录下来。\n情况是这样的，每次springboot程序会不定时自动停止，观察log发现，每次挂掉之前都会打印一行log,大致意思是，代码中调用的系统程序tail退出了。查看代码时发现确实在tail程序退出时会打印这么一行日志，但却是正常表现，程序运行在一个死循环当中，随后就会重启tail这个程序。循环当中也做了相应的异常捕获，按道理来说webservice不应该挂掉。初步怀疑多次启动tail导致内存泄漏以至于程序退出。由于代码中没有对内存泄漏这种error类型的异常捕获和记录到日志，从日志中无法判断是否发生了内存泄漏。代码中实现了Throwable级别异常的捕获，并记录异常信息到日志，再次抛出该异常。\n打包，发送给技服到测试机上去跑。一会之后，又挂了。观察新的Log，竟然与之前的没什么区别，并没有什么新的异常信息输出。也就是说，压根没有异常从代码中抛出。很有可能是程序被认为关闭或被系统干掉了。但是之前询问技服，对方否定了这种情况。\n这就怪了。继续观察日志，此时，发现这么一行：`Unregistering JMX-exposed beans on shutdown`.确实是springboot退出时打印的信息。google之，大部分的答案是没有添加依赖`spring-boot-starter-web`所导致springboot无法启动。与现在的情况不符，当前情况是启动正常，运行时突然挂掉。\n再次询问技服是否kill掉了运行webservice的进程。技服否认，说该程序时运行在后台的，继续询问如何运行在后台，回答是： `java -jar MyApplication.jar & `\n果然，使用这种方式运行在后台的程序，当ssh断掉或关闭bash窗口后，程序依然会被系统干掉，父进程都被干掉了，子进程也一并干掉了...\n正确的启动方式应为：`nohup java -jar MyApplication.jar &`\n\n```\nnohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。\n\n该命令的一般形式为：nohup command &\n\n使用nohup命令提交作业\n\n如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：\n\nnohup command > myout.file 2>&1 &\n\n在上面的例子中，输出被重定向到myout.file文件中。\n```\n该问题虽然不是很难解决，但是很容易被忽略。故在此记录。\n\n## 持续更新中....\n\n\n\n\n\n\n\n\n","source":"_posts/记录这周工作遇到的坑.md","raw":"---\nlayout: post\ntitle: 记录工作遇到的坑\ndate: 2016-09-24 16:30:44\ncategories: 技术 \ntags: \n- spring\n- curl\n---\n\n昨天晚上12.30才进的家门，回来之后还远程合了个代码打了个包，发布restAPI新版本之用。这一周的主要工作就是在做一个web服务器，是一个集群的中间件。因为着急发布新版本，所以昨晚加班到12点多...\n\n主要实现了几个接口，实现了ssl双向验证功能。其实ssl双向验证的功能主要是了解ssl原理之后如何配置的问题。期间还学习了session和cookie的原理。ssl与cookie、session单开一篇进行总结。这篇日志记录一下这周工作中遇到的一些坑，不一定是技术上的，但是遇到这些小问题还是耽误了一些时间。这篇日志也会持续更新，把以后遇到的坑都总结到这里来。\n\n希望以后遇到类似的情况能够迅速找到原因将其解决，同时也希望能帮助到可能会看到这篇文章的人。\n\n## Spring项目通过export方法打包为jar的问题\n\n在前面的日志中已经有[专门的一篇](http://yukai.space/2016/09/19/Spring%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAjar/)来总结这个问题:**当通过export方式打包Spring项目时，一定要记得勾选Add Directory Entries这个选项，否则spring无法正确扫描到controller，发生404**\n\n## 使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常\n\n假如你的项目中有一个类似下面的controller来接收一个请求：\n\n```java\n@GET\n@RequestMapping(\"web/{groupName}\")\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\npublic void getWorkerAddress(HttpServletRequest request, HttpServletResponse response,\n\t\t@PathVariable String groupName) {\n\t\tdoSomething...\n}\t\t\n\n```\n\n当你的项目运行时你发起一个`http://ip:port/web/groupName1`这样的请求，那么很有可能服务器会报这样一个异常：**java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.**\n\n大概的意思就是参数名称信息没有在类文件中找到。若是浏览器为客户端，浏览器的页面是这样的：\n\n{% asset_img error.png error %}\n\n解决这个异常的方法有两种：\n\n**1.在@PathVariable注解后面加上参数名，比如：@PathVariable(\"groupName\")**\n\n**2.编译时将debug信息勾选进去：**\n\n{% asset_img compiler.png compiler %}\n\n编译时把上图绿色框中的单选框勾选，就不会报异常。原因在于Local variable属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量名称和描述符之间的映射关系。\n\n顺便了解一下上面四个选项的作用：\n\n{% asset_img gengeration.png compiler %}\n\n图片截取自：[Eclipse用户手册](http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-compiler.htm)\n\n其实就是java工程编译时的一些选项。当我们在debug时遇到问题，比如断点打不上，source not found等等或许修改这些选项可以得到解决。\n\n参考一篇文章：[java编译时生成调试信息选项详解（javac -g）](http://daimojingdeyu.iteye.com/blog/679030)\n\n## Windows环境下使用Curl，要使用双引号包裹内容\n\nweb服务器是通过curl来测试的。之前自己也没用过这个所谓的命令行浏览器工具。在机器上装好curl之后，把测试那边提供的脚本拿过来，由于脚本是linux环境下的，做了一点修改之后(其实就是直接换成.bat啦)就直接跑了。脚本内容类似这样：\n\n```\ncurl -X POST -H 'content-type: application/json' -d @del.txt https://localhost:8899/web/rest/data/load/topictarget  -k -b cookie.txt>delresult.txt\n```\n\n但是实际测试的过程中，发现收到的post的数据为null，确定了不是服务器的问题之后，感觉应该是curl使用的问题。查了一些资料，是说post的数据要使用双引号包裹，而不是单引号。由于是从del.txt中提取post的数据，所以不存在这个问题。后来将content-type: application/json 的单引号换成双引号之后，问题解决。\n\n**所以：Windows环境下使用Curl，要使用双引号包裹需要加引号的内容，而不是单引号**\n\n## Spring项目运行过程中，@Autowired注解的变量为null的问题\n\n2016/09/09 更新\n\n这两天开发了一个公众账号来做一些简单的记账工作。后台服务器是用springboot搭建的，测试过程中遇到了这么个情况:\n\n在运行时服务器报了空指针NullPointerException异常，debug看了一下，发现是一个使用了@Autowired注解的变量没有被初始化。但是按理来说使用了@Autowired注解某个变量后spring会自动为我们实例化这个变量的啊！谷歌了一下，找到了一个类似的情况：[Why is my Spring @Autowired field null?](http://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null).\n\n下面模拟一下问题出现的场景(代码来自上面的链接)：\n\n```java\n@Controller\npublic class MileageFeeController {    \n    @RequestMapping(\"/mileage/{miles}\")\n    @ResponseBody\n    public float mileageFee(@PathVariable int miles) {\n        MileageFeeCalculator calc = new MileageFeeCalculator();\n        return calc.mileageCharge(miles);\n    }\n}\n\n@Service\npublic class MileageFeeCalculator {\n\n    @Autowired\n    private MileageRateService rateService; // <--- should be autowired, is null\n\n    public float mileageCharge(final int miles) {\n        return (miles * rateService.ratePerMile()); // <--- throws NPE\n    }\n}\n\n@Service\npublic class MileageFeeCalculator {\n\n    @Autowired\n    private MileageRateService rateService; // <--- should be autowired, is null\n\n    public float mileageCharge(final int miles) {\n        return (miles * rateService.ratePerMile()); // <--- throws NPE\n    }\n}\n```\n\n访问MileageFeeController时报错：\n\n```\njava.lang.NullPointerException: null\n    at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13)\n    at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14)\n```\n\n可以看到，变量rateService是个空值。导致空指针异常...\n\n原因就在于MileageFeeController.mileageFee中使用了new这种方式实例化了MileageFeeCalculator对象，该对象中的rateService为空，我们使用new这种方式实例化对象时，无法通过spring的@Autowired注解自动实例化对象中的属性。解决的方法就是实例化对象时应该通知spring，使其能够自动配置。\n\n我采用了上述链接中的第三种方法，解决了问题：\n\n```java\n@Component\npublic class ApplicationContextHolder implements ApplicationContextAware {\n    private static ApplicationContext context;\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        context = applicationContext;   \n    }\n\n    public static ApplicationContext getContext() {\n        return context;\n    }\n}\n\n@Controller\npublic class MileageFeeController {    \n    @RequestMapping(\"/mileage/{miles}\")\n    @ResponseBody\n    public float mileageFee(@PathVariable int miles) {\n        MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);\n        return calc.mileageCharge(miles);\n    }\n}\n```\n\n发生这些问题的原因还是在于对框架的不熟悉，内部原理不甚明了。有机会真得研究研究spring的源码~~\n\n## @RestController与@Controller\n\n2016/10/24 更新\n\nSpringboot 使用 Thymeleaf 模板 打算给公众号加一点地图功能，按照[这个教程](https://hellokoding.com/spring-boot-hello-world-example-with-thymeleaf/)在springboot项目中配置Thymeleaf，但是每次都没有正确返回html页面，反而是返回了这个html的名称。试了几次才发现自己用错了@RestController这个注解...Controller代码如下：\n\n```java\n@RestController\n@RequestMapping(\"/wechat\")\npublic class MapController {\n    @RequestMapping(\"/map/showRestaurant\")\n    public String showRestaurant(@RequestParam(value = \"location_x\", required = true) String location_x,\n            @RequestParam(value = \"location_y\", required = true) String location_y,\n            @RequestParam(value = \"label\", required = true) String label, Model model) {\n        model.addAttribute(\"locationx\", location_x);\n        model.addAttribute(\"locationy\", location_y);\n        model.addAttribute(\"label\",label);\n        return \"hello\";\n    }\n}\n\n```\n问题原因就在于上面的@RestController这个注解，将其替换为@Controller便解决了。\n \n根本原因在于@RestController与@Controller[这两个注解之间的区别](http://stackoverflow.com/questions/25242321/difference-between-spring-controller-and-restcontroller-annotation)\n\n## Linux下可靠的启动webservice\n\n2016/12/14 更新\n\n今天线上webservice发现了一个问题，技服把出现的问题描述和日志发给了我，需要解决一下。最终确定不是代码的问题，而是linux下启动程序的方式引发的一个错误。虽然简单，却很容易被疏忽导致问题的发生，值得记录下来。\n情况是这样的，每次springboot程序会不定时自动停止，观察log发现，每次挂掉之前都会打印一行log,大致意思是，代码中调用的系统程序tail退出了。查看代码时发现确实在tail程序退出时会打印这么一行日志，但却是正常表现，程序运行在一个死循环当中，随后就会重启tail这个程序。循环当中也做了相应的异常捕获，按道理来说webservice不应该挂掉。初步怀疑多次启动tail导致内存泄漏以至于程序退出。由于代码中没有对内存泄漏这种error类型的异常捕获和记录到日志，从日志中无法判断是否发生了内存泄漏。代码中实现了Throwable级别异常的捕获，并记录异常信息到日志，再次抛出该异常。\n打包，发送给技服到测试机上去跑。一会之后，又挂了。观察新的Log，竟然与之前的没什么区别，并没有什么新的异常信息输出。也就是说，压根没有异常从代码中抛出。很有可能是程序被认为关闭或被系统干掉了。但是之前询问技服，对方否定了这种情况。\n这就怪了。继续观察日志，此时，发现这么一行：`Unregistering JMX-exposed beans on shutdown`.确实是springboot退出时打印的信息。google之，大部分的答案是没有添加依赖`spring-boot-starter-web`所导致springboot无法启动。与现在的情况不符，当前情况是启动正常，运行时突然挂掉。\n再次询问技服是否kill掉了运行webservice的进程。技服否认，说该程序时运行在后台的，继续询问如何运行在后台，回答是： `java -jar MyApplication.jar & `\n果然，使用这种方式运行在后台的程序，当ssh断掉或关闭bash窗口后，程序依然会被系统干掉，父进程都被干掉了，子进程也一并干掉了...\n正确的启动方式应为：`nohup java -jar MyApplication.jar &`\n\n```\nnohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。\n\n该命令的一般形式为：nohup command &\n\n使用nohup命令提交作业\n\n如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：\n\nnohup command > myout.file 2>&1 &\n\n在上面的例子中，输出被重定向到myout.file文件中。\n```\n该问题虽然不是很难解决，但是很容易被忽略。故在此记录。\n\n## 持续更新中....\n\n\n\n\n\n\n\n\n","slug":"记录这周工作遇到的坑","published":1,"updated":"2017-02-19T13:08:11.045Z","comments":1,"photos":[],"link":"","_id":"cj0xuzlt4004cvegc2vuha4kq","content":"<p>昨天晚上12.30才进的家门，回来之后还远程合了个代码打了个包，发布restAPI新版本之用。这一周的主要工作就是在做一个web服务器，是一个集群的中间件。因为着急发布新版本，所以昨晚加班到12点多…</p>\n<p>主要实现了几个接口，实现了ssl双向验证功能。其实ssl双向验证的功能主要是了解ssl原理之后如何配置的问题。期间还学习了session和cookie的原理。ssl与cookie、session单开一篇进行总结。这篇日志记录一下这周工作中遇到的一些坑，不一定是技术上的，但是遇到这些小问题还是耽误了一些时间。这篇日志也会持续更新，把以后遇到的坑都总结到这里来。</p>\n<p>希望以后遇到类似的情况能够迅速找到原因将其解决，同时也希望能帮助到可能会看到这篇文章的人。</p>\n<h2 id=\"Spring项目通过export方法打包为jar的问题\"><a href=\"#Spring项目通过export方法打包为jar的问题\" class=\"headerlink\" title=\"Spring项目通过export方法打包为jar的问题\"></a>Spring项目通过export方法打包为jar的问题</h2><p>在前面的日志中已经有<a href=\"http://yukai.space/2016/09/19/Spring%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAjar/\">专门的一篇</a>来总结这个问题:<strong>当通过export方式打包Spring项目时，一定要记得勾选Add Directory Entries这个选项，否则spring无法正确扫描到controller，发生404</strong></p>\n<h2 id=\"使用-PathVariable注解时抛出java-lang-IllegalArgumentException异常\"><a href=\"#使用-PathVariable注解时抛出java-lang-IllegalArgumentException异常\" class=\"headerlink\" title=\"使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常\"></a>使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常</h2><p>假如你的项目中有一个类似下面的controller来接收一个请求：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@GET</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"web/&#123;groupName&#125;\"</span>)</div><div class=\"line\"><span class=\"meta\">@Consumes</span>(MediaType.APPLICATION_JSON)</div><div class=\"line\"><span class=\"meta\">@Produces</span>(MediaType.APPLICATION_JSON)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getWorkerAddress</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response,</span></span></div><div class=\"line\">\t\t@PathVariable String groupName) &#123;</div><div class=\"line\">\t\tdoSomething...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当你的项目运行时你发起一个<code>http://ip:port/web/groupName1</code>这样的请求，那么很有可能服务器会报这样一个异常：<strong>java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.</strong></p>\n<p>大概的意思就是参数名称信息没有在类文件中找到。若是浏览器为客户端，浏览器的页面是这样的：</p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/error.png\" alt=\"error\" title=\"error\">\n<p>解决这个异常的方法有两种：</p>\n<p><strong>1.在@PathVariable注解后面加上参数名，比如：@PathVariable(“groupName”)</strong></p>\n<p><strong>2.编译时将debug信息勾选进去：</strong></p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/compiler.png\" alt=\"compiler\" title=\"compiler\">\n<p>编译时把上图绿色框中的单选框勾选，就不会报异常。原因在于Local variable属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量名称和描述符之间的映射关系。</p>\n<p>顺便了解一下上面四个选项的作用：</p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/gengeration.png\" alt=\"compiler\" title=\"compiler\">\n<p>图片截取自：<a href=\"http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-compiler.htm\" target=\"_blank\" rel=\"external\">Eclipse用户手册</a></p>\n<p>其实就是java工程编译时的一些选项。当我们在debug时遇到问题，比如断点打不上，source not found等等或许修改这些选项可以得到解决。</p>\n<p>参考一篇文章：<a href=\"http://daimojingdeyu.iteye.com/blog/679030\" target=\"_blank\" rel=\"external\">java编译时生成调试信息选项详解（javac -g）</a></p>\n<h2 id=\"Windows环境下使用Curl，要使用双引号包裹内容\"><a href=\"#Windows环境下使用Curl，要使用双引号包裹内容\" class=\"headerlink\" title=\"Windows环境下使用Curl，要使用双引号包裹内容\"></a>Windows环境下使用Curl，要使用双引号包裹内容</h2><p>web服务器是通过curl来测试的。之前自己也没用过这个所谓的命令行浏览器工具。在机器上装好curl之后，把测试那边提供的脚本拿过来，由于脚本是linux环境下的，做了一点修改之后(其实就是直接换成.bat啦)就直接跑了。脚本内容类似这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -X POST -H &apos;content-type: application/json&apos; -d @del.txt https://localhost:8899/web/rest/data/load/topictarget  -k -b cookie.txt&gt;delresult.txt</div></pre></td></tr></table></figure>\n<p>但是实际测试的过程中，发现收到的post的数据为null，确定了不是服务器的问题之后，感觉应该是curl使用的问题。查了一些资料，是说post的数据要使用双引号包裹，而不是单引号。由于是从del.txt中提取post的数据，所以不存在这个问题。后来将content-type: application/json 的单引号换成双引号之后，问题解决。</p>\n<p><strong>所以：Windows环境下使用Curl，要使用双引号包裹需要加引号的内容，而不是单引号</strong></p>\n<h2 id=\"Spring项目运行过程中，-Autowired注解的变量为null的问题\"><a href=\"#Spring项目运行过程中，-Autowired注解的变量为null的问题\" class=\"headerlink\" title=\"Spring项目运行过程中，@Autowired注解的变量为null的问题\"></a>Spring项目运行过程中，@Autowired注解的变量为null的问题</h2><p>2016/09/09 更新</p>\n<p>这两天开发了一个公众账号来做一些简单的记账工作。后台服务器是用springboot搭建的，测试过程中遇到了这么个情况:</p>\n<p>在运行时服务器报了空指针NullPointerException异常，debug看了一下，发现是一个使用了@Autowired注解的变量没有被初始化。但是按理来说使用了@Autowired注解某个变量后spring会自动为我们实例化这个变量的啊！谷歌了一下，找到了一个类似的情况：<a href=\"http://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null\" target=\"_blank\" rel=\"external\">Why is my Spring @Autowired field null?</a>.</p>\n<p>下面模拟一下问题出现的场景(代码来自上面的链接)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeController</span> </span>&#123;    </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mileage/&#123;miles&#125;\"</span>)</div><div class=\"line\">    <span class=\"meta\">@ResponseBody</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageFee</span><span class=\"params\">(@PathVariable <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        MileageFeeCalculator calc = <span class=\"keyword\">new</span> MileageFeeCalculator();</div><div class=\"line\">        <span class=\"keyword\">return</span> calc.mileageCharge(miles);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Service</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeCalculator</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> MileageRateService rateService; <span class=\"comment\">// &lt;--- should be autowired, is null</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageCharge</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (miles * rateService.ratePerMile()); <span class=\"comment\">// &lt;--- throws NPE</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Service</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeCalculator</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> MileageRateService rateService; <span class=\"comment\">// &lt;--- should be autowired, is null</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageCharge</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (miles * rateService.ratePerMile()); <span class=\"comment\">// &lt;--- throws NPE</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>访问MileageFeeController时报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.NullPointerException: null</div><div class=\"line\">    at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13)</div><div class=\"line\">    at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14)</div></pre></td></tr></table></figure>\n<p>可以看到，变量rateService是个空值。导致空指针异常…</p>\n<p>原因就在于MileageFeeController.mileageFee中使用了new这种方式实例化了MileageFeeCalculator对象，该对象中的rateService为空，我们使用new这种方式实例化对象时，无法通过spring的@Autowired注解自动实例化对象中的属性。解决的方法就是实例化对象时应该通知spring，使其能够自动配置。</p>\n<p>我采用了上述链接中的第三种方法，解决了问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Component</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationContextHolder</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationContextAware</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ApplicationContext context;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</div><div class=\"line\">        context = applicationContext;   </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ApplicationContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> context;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeController</span> </span>&#123;    </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mileage/&#123;miles&#125;\"</span>)</div><div class=\"line\">    <span class=\"meta\">@ResponseBody</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageFee</span><span class=\"params\">(@PathVariable <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);</div><div class=\"line\">        <span class=\"keyword\">return</span> calc.mileageCharge(miles);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>发生这些问题的原因还是在于对框架的不熟悉，内部原理不甚明了。有机会真得研究研究spring的源码~~</p>\n<h2 id=\"RestController与-Controller\"><a href=\"#RestController与-Controller\" class=\"headerlink\" title=\"@RestController与@Controller\"></a>@RestController与@Controller</h2><p>2016/10/24 更新</p>\n<p>Springboot 使用 Thymeleaf 模板 打算给公众号加一点地图功能，按照<a href=\"https://hellokoding.com/spring-boot-hello-world-example-with-thymeleaf/\" target=\"_blank\" rel=\"external\">这个教程</a>在springboot项目中配置Thymeleaf，但是每次都没有正确返回html页面，反而是返回了这个html的名称。试了几次才发现自己用错了@RestController这个注解…Controller代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@RestController</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/wechat\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapController</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/map/showRestaurant\"</span>)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showRestaurant</span><span class=\"params\">(@RequestParam(value = <span class=\"string\">\"location_x\"</span>, required = <span class=\"keyword\">true</span>)</span> String location_x,</span></div><div class=\"line\">            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"location_y\"</span>, required = <span class=\"keyword\">true</span>)</span> String location_y,</div><div class=\"line\">            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"label\"</span>, required = <span class=\"keyword\">true</span>)</span> String label, Model model) &#123;</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"locationx\"</span>, location_x);</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"locationy\"</span>, location_y);</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"label\"</span>,label);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"hello\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>问题原因就在于上面的@RestController这个注解，将其替换为@Controller便解决了。</p>\n<p>根本原因在于@RestController与@Controller<a href=\"http://stackoverflow.com/questions/25242321/difference-between-spring-controller-and-restcontroller-annotation\" target=\"_blank\" rel=\"external\">这两个注解之间的区别</a></p>\n<h2 id=\"Linux下可靠的启动webservice\"><a href=\"#Linux下可靠的启动webservice\" class=\"headerlink\" title=\"Linux下可靠的启动webservice\"></a>Linux下可靠的启动webservice</h2><p>2016/12/14 更新</p>\n<p>今天线上webservice发现了一个问题，技服把出现的问题描述和日志发给了我，需要解决一下。最终确定不是代码的问题，而是linux下启动程序的方式引发的一个错误。虽然简单，却很容易被疏忽导致问题的发生，值得记录下来。<br>情况是这样的，每次springboot程序会不定时自动停止，观察log发现，每次挂掉之前都会打印一行log,大致意思是，代码中调用的系统程序tail退出了。查看代码时发现确实在tail程序退出时会打印这么一行日志，但却是正常表现，程序运行在一个死循环当中，随后就会重启tail这个程序。循环当中也做了相应的异常捕获，按道理来说webservice不应该挂掉。初步怀疑多次启动tail导致内存泄漏以至于程序退出。由于代码中没有对内存泄漏这种error类型的异常捕获和记录到日志，从日志中无法判断是否发生了内存泄漏。代码中实现了Throwable级别异常的捕获，并记录异常信息到日志，再次抛出该异常。<br>打包，发送给技服到测试机上去跑。一会之后，又挂了。观察新的Log，竟然与之前的没什么区别，并没有什么新的异常信息输出。也就是说，压根没有异常从代码中抛出。很有可能是程序被认为关闭或被系统干掉了。但是之前询问技服，对方否定了这种情况。<br>这就怪了。继续观察日志，此时，发现这么一行：<code>Unregistering JMX-exposed beans on shutdown</code>.确实是springboot退出时打印的信息。google之，大部分的答案是没有添加依赖<code>spring-boot-starter-web</code>所导致springboot无法启动。与现在的情况不符，当前情况是启动正常，运行时突然挂掉。<br>再次询问技服是否kill掉了运行webservice的进程。技服否认，说该程序时运行在后台的，继续询问如何运行在后台，回答是： <code>java -jar MyApplication.jar &amp;</code><br>果然，使用这种方式运行在后台的程序，当ssh断掉或关闭bash窗口后，程序依然会被系统干掉，父进程都被干掉了，子进程也一并干掉了…<br>正确的启动方式应为：<code>nohup java -jar MyApplication.jar &amp;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。</div><div class=\"line\"></div><div class=\"line\">该命令的一般形式为：nohup command &amp;</div><div class=\"line\"></div><div class=\"line\">使用nohup命令提交作业</div><div class=\"line\"></div><div class=\"line\">如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</div><div class=\"line\"></div><div class=\"line\">nohup command &gt; myout.file 2&gt;&amp;1 &amp;</div><div class=\"line\"></div><div class=\"line\">在上面的例子中，输出被重定向到myout.file文件中。</div></pre></td></tr></table></figure>\n<p>该问题虽然不是很难解决，但是很容易被忽略。故在此记录。</p>\n<h2 id=\"持续更新中…\"><a href=\"#持续更新中…\" class=\"headerlink\" title=\"持续更新中….\"></a>持续更新中….</h2>","excerpt":"","more":"<p>昨天晚上12.30才进的家门，回来之后还远程合了个代码打了个包，发布restAPI新版本之用。这一周的主要工作就是在做一个web服务器，是一个集群的中间件。因为着急发布新版本，所以昨晚加班到12点多…</p>\n<p>主要实现了几个接口，实现了ssl双向验证功能。其实ssl双向验证的功能主要是了解ssl原理之后如何配置的问题。期间还学习了session和cookie的原理。ssl与cookie、session单开一篇进行总结。这篇日志记录一下这周工作中遇到的一些坑，不一定是技术上的，但是遇到这些小问题还是耽误了一些时间。这篇日志也会持续更新，把以后遇到的坑都总结到这里来。</p>\n<p>希望以后遇到类似的情况能够迅速找到原因将其解决，同时也希望能帮助到可能会看到这篇文章的人。</p>\n<h2 id=\"Spring项目通过export方法打包为jar的问题\"><a href=\"#Spring项目通过export方法打包为jar的问题\" class=\"headerlink\" title=\"Spring项目通过export方法打包为jar的问题\"></a>Spring项目通过export方法打包为jar的问题</h2><p>在前面的日志中已经有<a href=\"http://yukai.space/2016/09/19/Spring%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAjar/\">专门的一篇</a>来总结这个问题:<strong>当通过export方式打包Spring项目时，一定要记得勾选Add Directory Entries这个选项，否则spring无法正确扫描到controller，发生404</strong></p>\n<h2 id=\"使用-PathVariable注解时抛出java-lang-IllegalArgumentException异常\"><a href=\"#使用-PathVariable注解时抛出java-lang-IllegalArgumentException异常\" class=\"headerlink\" title=\"使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常\"></a>使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常</h2><p>假如你的项目中有一个类似下面的controller来接收一个请求：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@GET</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"web/&#123;groupName&#125;\"</span>)</div><div class=\"line\"><span class=\"meta\">@Consumes</span>(MediaType.APPLICATION_JSON)</div><div class=\"line\"><span class=\"meta\">@Produces</span>(MediaType.APPLICATION_JSON)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getWorkerAddress</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response,</div><div class=\"line\">\t\t@PathVariable String groupName)</span> </span>&#123;</div><div class=\"line\">\t\tdoSomething...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当你的项目运行时你发起一个<code>http://ip:port/web/groupName1</code>这样的请求，那么很有可能服务器会报这样一个异常：<strong>java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.</strong></p>\n<p>大概的意思就是参数名称信息没有在类文件中找到。若是浏览器为客户端，浏览器的页面是这样的：</p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/error.png\" alt=\"error\" title=\"error\">\n<p>解决这个异常的方法有两种：</p>\n<p><strong>1.在@PathVariable注解后面加上参数名，比如：@PathVariable(“groupName”)</strong></p>\n<p><strong>2.编译时将debug信息勾选进去：</strong></p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/compiler.png\" alt=\"compiler\" title=\"compiler\">\n<p>编译时把上图绿色框中的单选框勾选，就不会报异常。原因在于Local variable属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量名称和描述符之间的映射关系。</p>\n<p>顺便了解一下上面四个选项的作用：</p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/gengeration.png\" alt=\"compiler\" title=\"compiler\">\n<p>图片截取自：<a href=\"http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-compiler.htm\">Eclipse用户手册</a></p>\n<p>其实就是java工程编译时的一些选项。当我们在debug时遇到问题，比如断点打不上，source not found等等或许修改这些选项可以得到解决。</p>\n<p>参考一篇文章：<a href=\"http://daimojingdeyu.iteye.com/blog/679030\">java编译时生成调试信息选项详解（javac -g）</a></p>\n<h2 id=\"Windows环境下使用Curl，要使用双引号包裹内容\"><a href=\"#Windows环境下使用Curl，要使用双引号包裹内容\" class=\"headerlink\" title=\"Windows环境下使用Curl，要使用双引号包裹内容\"></a>Windows环境下使用Curl，要使用双引号包裹内容</h2><p>web服务器是通过curl来测试的。之前自己也没用过这个所谓的命令行浏览器工具。在机器上装好curl之后，把测试那边提供的脚本拿过来，由于脚本是linux环境下的，做了一点修改之后(其实就是直接换成.bat啦)就直接跑了。脚本内容类似这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -X POST -H &apos;content-type: application/json&apos; -d @del.txt https://localhost:8899/web/rest/data/load/topictarget  -k -b cookie.txt&gt;delresult.txt</div></pre></td></tr></table></figure>\n<p>但是实际测试的过程中，发现收到的post的数据为null，确定了不是服务器的问题之后，感觉应该是curl使用的问题。查了一些资料，是说post的数据要使用双引号包裹，而不是单引号。由于是从del.txt中提取post的数据，所以不存在这个问题。后来将content-type: application/json 的单引号换成双引号之后，问题解决。</p>\n<p><strong>所以：Windows环境下使用Curl，要使用双引号包裹需要加引号的内容，而不是单引号</strong></p>\n<h2 id=\"Spring项目运行过程中，-Autowired注解的变量为null的问题\"><a href=\"#Spring项目运行过程中，-Autowired注解的变量为null的问题\" class=\"headerlink\" title=\"Spring项目运行过程中，@Autowired注解的变量为null的问题\"></a>Spring项目运行过程中，@Autowired注解的变量为null的问题</h2><p>2016/09/09 更新</p>\n<p>这两天开发了一个公众账号来做一些简单的记账工作。后台服务器是用springboot搭建的，测试过程中遇到了这么个情况:</p>\n<p>在运行时服务器报了空指针NullPointerException异常，debug看了一下，发现是一个使用了@Autowired注解的变量没有被初始化。但是按理来说使用了@Autowired注解某个变量后spring会自动为我们实例化这个变量的啊！谷歌了一下，找到了一个类似的情况：<a href=\"http://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null\">Why is my Spring @Autowired field null?</a>.</p>\n<p>下面模拟一下问题出现的场景(代码来自上面的链接)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeController</span> </span>&#123;    </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mileage/&#123;miles&#125;\"</span>)</div><div class=\"line\">    <span class=\"meta\">@ResponseBody</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageFee</span><span class=\"params\">(@PathVariable <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        MileageFeeCalculator calc = <span class=\"keyword\">new</span> MileageFeeCalculator();</div><div class=\"line\">        <span class=\"keyword\">return</span> calc.mileageCharge(miles);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Service</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeCalculator</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> MileageRateService rateService; <span class=\"comment\">// &lt;--- should be autowired, is null</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageCharge</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (miles * rateService.ratePerMile()); <span class=\"comment\">// &lt;--- throws NPE</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Service</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeCalculator</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> MileageRateService rateService; <span class=\"comment\">// &lt;--- should be autowired, is null</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageCharge</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (miles * rateService.ratePerMile()); <span class=\"comment\">// &lt;--- throws NPE</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>访问MileageFeeController时报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.NullPointerException: null</div><div class=\"line\">    at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13)</div><div class=\"line\">    at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14)</div></pre></td></tr></table></figure>\n<p>可以看到，变量rateService是个空值。导致空指针异常…</p>\n<p>原因就在于MileageFeeController.mileageFee中使用了new这种方式实例化了MileageFeeCalculator对象，该对象中的rateService为空，我们使用new这种方式实例化对象时，无法通过spring的@Autowired注解自动实例化对象中的属性。解决的方法就是实例化对象时应该通知spring，使其能够自动配置。</p>\n<p>我采用了上述链接中的第三种方法，解决了问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Component</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationContextHolder</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationContextAware</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ApplicationContext context;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</div><div class=\"line\">        context = applicationContext;   </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ApplicationContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> context;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeController</span> </span>&#123;    </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mileage/&#123;miles&#125;\"</span>)</div><div class=\"line\">    <span class=\"meta\">@ResponseBody</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageFee</span><span class=\"params\">(@PathVariable <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);</div><div class=\"line\">        <span class=\"keyword\">return</span> calc.mileageCharge(miles);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>发生这些问题的原因还是在于对框架的不熟悉，内部原理不甚明了。有机会真得研究研究spring的源码~~</p>\n<h2 id=\"RestController与-Controller\"><a href=\"#RestController与-Controller\" class=\"headerlink\" title=\"@RestController与@Controller\"></a>@RestController与@Controller</h2><p>2016/10/24 更新</p>\n<p>Springboot 使用 Thymeleaf 模板 打算给公众号加一点地图功能，按照<a href=\"https://hellokoding.com/spring-boot-hello-world-example-with-thymeleaf/\">这个教程</a>在springboot项目中配置Thymeleaf，但是每次都没有正确返回html页面，反而是返回了这个html的名称。试了几次才发现自己用错了@RestController这个注解…Controller代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@RestController</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/wechat\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapController</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/map/showRestaurant\"</span>)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showRestaurant</span><span class=\"params\">(@RequestParam(value = <span class=\"string\">\"location_x\"</span>, required = <span class=\"keyword\">true</span>)</span> String location_x,</div><div class=\"line\">            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"location_y\"</span>, required = <span class=\"keyword\">true</span>)</span> String location_y,</div><div class=\"line\">            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"label\"</span>, required = <span class=\"keyword\">true</span>)</span> String label, Model model) </span>&#123;</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"locationx\"</span>, location_x);</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"locationy\"</span>, location_y);</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"label\"</span>,label);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"hello\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>问题原因就在于上面的@RestController这个注解，将其替换为@Controller便解决了。</p>\n<p>根本原因在于@RestController与@Controller<a href=\"http://stackoverflow.com/questions/25242321/difference-between-spring-controller-and-restcontroller-annotation\">这两个注解之间的区别</a></p>\n<h2 id=\"Linux下可靠的启动webservice\"><a href=\"#Linux下可靠的启动webservice\" class=\"headerlink\" title=\"Linux下可靠的启动webservice\"></a>Linux下可靠的启动webservice</h2><p>2016/12/14 更新</p>\n<p>今天线上webservice发现了一个问题，技服把出现的问题描述和日志发给了我，需要解决一下。最终确定不是代码的问题，而是linux下启动程序的方式引发的一个错误。虽然简单，却很容易被疏忽导致问题的发生，值得记录下来。<br>情况是这样的，每次springboot程序会不定时自动停止，观察log发现，每次挂掉之前都会打印一行log,大致意思是，代码中调用的系统程序tail退出了。查看代码时发现确实在tail程序退出时会打印这么一行日志，但却是正常表现，程序运行在一个死循环当中，随后就会重启tail这个程序。循环当中也做了相应的异常捕获，按道理来说webservice不应该挂掉。初步怀疑多次启动tail导致内存泄漏以至于程序退出。由于代码中没有对内存泄漏这种error类型的异常捕获和记录到日志，从日志中无法判断是否发生了内存泄漏。代码中实现了Throwable级别异常的捕获，并记录异常信息到日志，再次抛出该异常。<br>打包，发送给技服到测试机上去跑。一会之后，又挂了。观察新的Log，竟然与之前的没什么区别，并没有什么新的异常信息输出。也就是说，压根没有异常从代码中抛出。很有可能是程序被认为关闭或被系统干掉了。但是之前询问技服，对方否定了这种情况。<br>这就怪了。继续观察日志，此时，发现这么一行：<code>Unregistering JMX-exposed beans on shutdown</code>.确实是springboot退出时打印的信息。google之，大部分的答案是没有添加依赖<code>spring-boot-starter-web</code>所导致springboot无法启动。与现在的情况不符，当前情况是启动正常，运行时突然挂掉。<br>再次询问技服是否kill掉了运行webservice的进程。技服否认，说该程序时运行在后台的，继续询问如何运行在后台，回答是： <code>java -jar MyApplication.jar &amp;</code><br>果然，使用这种方式运行在后台的程序，当ssh断掉或关闭bash窗口后，程序依然会被系统干掉，父进程都被干掉了，子进程也一并干掉了…<br>正确的启动方式应为：<code>nohup java -jar MyApplication.jar &amp;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。</div><div class=\"line\"></div><div class=\"line\">该命令的一般形式为：nohup command &amp;</div><div class=\"line\"></div><div class=\"line\">使用nohup命令提交作业</div><div class=\"line\"></div><div class=\"line\">如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</div><div class=\"line\"></div><div class=\"line\">nohup command &gt; myout.file 2&gt;&amp;1 &amp;</div><div class=\"line\"></div><div class=\"line\">在上面的例子中，输出被重定向到myout.file文件中。</div></pre></td></tr></table></figure>\n<p>该问题虽然不是很难解决，但是很容易被忽略。故在此记录。</p>\n<h2 id=\"持续更新中…\"><a href=\"#持续更新中…\" class=\"headerlink\" title=\"持续更新中….\"></a>持续更新中….</h2>"}],"PostAsset":[{"_id":"source/_posts/毕业了/graduation3.jpg","slug":"graduation3.jpg","post":"cj0xuzlsy0041vegcktrnnbt1","modified":0,"renderable":0},{"_id":"source/_posts/I-O总结/javaio.png","slug":"javaio.png","post":"cj0xuzlpg0005vegc5x3zlm3t","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation2.jpg","slug":"graduation2.jpg","post":"cj0xuzlsy0041vegcktrnnbt1","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation8.jpg","slug":"graduation8.jpg","post":"cj0xuzlsy0041vegcktrnnbt1","modified":0,"renderable":0},{"_id":"source/_posts/Java集合框架学习总结/collection.png","slug":"collection.png","post":"cj0xuzlpm0006vegcxzcgch5j","modified":0,"renderable":0},{"_id":"source/_posts/java中的equals与hashcode/entry.png","slug":"entry.png","post":"cj0xuzlqq000xvegcadtqlue0","modified":0,"renderable":0},{"_id":"source/_posts/java异常的学习/java.png","slug":"java.png","post":"cj0xuzlrk001vvegc54kc1ps7","modified":0,"renderable":0},{"_id":"source/_posts/java泛型学习/easybill.jpg","slug":"easybill.jpg","post":"cj0xuzlro0022vegcq3i35rx0","modified":0,"renderable":0},{"_id":"source/_posts/他可是科比·布莱恩特!/kobe.jpg","slug":"kobe.jpg","post":"cj0xuzlsm003jvegcxsz3x41m","modified":0,"renderable":0},{"_id":"source/_posts/关于加密的一点总结/md5.png","slug":"md5.png","post":"cj0xuzlss003qvegcbmz8tjfl","modified":0,"renderable":0},{"_id":"source/_posts/理解notify notifyall sleep/线程状态.png","slug":"线程状态.png","post":"cj0xuzlt30048vegcv6gu397j","modified":0,"renderable":0},{"_id":"source/_posts/centos7BCM驱动安装/demo.png","slug":"demo.png","post":"cj0xuzlqh000kvegcxxkkimbc","modified":0,"renderable":0},{"_id":"source/_posts/centos7BCM驱动安装/iwconfig.png","slug":"iwconfig.png","post":"cj0xuzlqh000kvegcxxkkimbc","modified":0,"renderable":0},{"_id":"source/_posts/java注解/decode.jpg","slug":"decode.jpg","post":"cj0xuzlrr0026vegc5xrl4yju","modified":0,"renderable":0},{"_id":"source/_posts/java注解/doc.jpg","slug":"doc.jpg","post":"cj0xuzlrr0026vegc5xrl4yju","modified":0,"renderable":0},{"_id":"source/_posts/理解java内存模型/volatile.png","slug":"volatile.png","post":"cj0xuzlt10045vegcsmme8k3a","modified":0,"renderable":0},{"_id":"source/_posts/理解java内存模型/内存模型.png","slug":"内存模型.png","post":"cj0xuzlt10045vegcsmme8k3a","modified":0,"renderable":0},{"_id":"source/_posts/java中的编码问题/reader.png","slug":"reader.png","post":"cj0xuzlr0001avegcj62aofj5","modified":0,"renderable":0},{"_id":"source/_posts/java中的编码问题/utf8.png","slug":"utf8.png","post":"cj0xuzlr0001avegcj62aofj5","modified":0,"renderable":0},{"_id":"source/_posts/java中的编码问题/writer.png","slug":"writer.png","post":"cj0xuzlr0001avegcj62aofj5","modified":0,"renderable":0},{"_id":"source/_posts/java远程调试学习/jdpa.png","slug":"jdpa.png","post":"cj0xuzlru0029vegc4axe0e6k","modified":0,"renderable":0},{"_id":"source/_posts/java远程调试学习/remote.png","slug":"remote.png","post":"cj0xuzlru0029vegc4axe0e6k","modified":0,"renderable":0},{"_id":"source/_posts/java远程调试学习/setting.png","slug":"setting.png","post":"cj0xuzlru0029vegc4axe0e6k","modified":0,"renderable":0},{"_id":"source/_posts/记录这周工作遇到的坑/compiler.png","slug":"compiler.png","post":"cj0xuzlt4004cvegc2vuha4kq","modified":0,"renderable":0},{"_id":"source/_posts/记录这周工作遇到的坑/error.png","slug":"error.png","post":"cj0xuzlt4004cvegc2vuha4kq","modified":0,"renderable":0},{"_id":"source/_posts/记录这周工作遇到的坑/gengeration.png","slug":"gengeration.png","post":"cj0xuzlt4004cvegc2vuha4kq","modified":0,"renderable":0},{"_id":"source/_posts/ssl总结/sslprocess.jpg","slug":"sslprocess.jpg","post":"cj0xuzlsb002xvegcyd6ark7u","modified":0,"renderable":0},{"_id":"source/_posts/ssl总结/zhifubao.png","slug":"zhifubao.png","post":"cj0xuzlsb002xvegcyd6ark7u","modified":0,"renderable":0},{"_id":"source/_posts/ssl总结/zhufubao1.png","slug":"zhufubao1.png","post":"cj0xuzlsb002xvegcyd6ark7u","modified":0,"renderable":0},{"_id":"source/_posts/ssl总结/zhufubao2.png","slug":"zhufubao2.png","post":"cj0xuzlsb002xvegcyd6ark7u","modified":0,"renderable":0},{"_id":"source/_posts/Spring项目打包为jar/1.png","slug":"1.png","post":"cj0xuzlpw000avegc3nld2wru","modified":0,"renderable":0},{"_id":"source/_posts/Spring项目打包为jar/2.png","slug":"2.png","post":"cj0xuzlpw000avegc3nld2wru","modified":0,"renderable":0},{"_id":"source/_posts/Spring项目打包为jar/3.png","slug":"3.png","post":"cj0xuzlpw000avegc3nld2wru","modified":0,"renderable":0},{"_id":"source/_posts/Spring项目打包为jar/4.png","slug":"4.png","post":"cj0xuzlpw000avegc3nld2wru","modified":0,"renderable":0},{"_id":"source/_posts/Spring项目打包为jar/5.png","slug":"5.png","post":"cj0xuzlpw000avegc3nld2wru","modified":0,"renderable":0},{"_id":"source/_posts/linux分区/cipan.png","slug":"cipan.png","post":"cj0xuzls2002gvegcktu63uu8","modified":0,"renderable":0},{"_id":"source/_posts/linux分区/fen.png","slug":"fen.png","post":"cj0xuzls2002gvegcktu63uu8","modified":0,"renderable":0},{"_id":"source/_posts/linux分区/kuozhan.png","slug":"kuozhan.png","post":"cj0xuzls2002gvegcktu63uu8","modified":0,"renderable":0},{"_id":"source/_posts/linux分区/yindao.jpg","slug":"yindao.jpg","post":"cj0xuzls2002gvegcktu63uu8","modified":0,"renderable":0},{"_id":"source/_posts/linux分区/zhumian.jpg","slug":"zhumian.jpg","post":"cj0xuzls2002gvegcktu63uu8","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/1.png","slug":"1.png","post":"cj0xuzlp70002vegcsiqckxxb","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/2.png","slug":"2.png","post":"cj0xuzlp70002vegcsiqckxxb","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/3.png","slug":"3.png","post":"cj0xuzlp70002vegcsiqckxxb","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/4.png","slug":"4.png","post":"cj0xuzlp70002vegcsiqckxxb","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/5.png","slug":"5.png","post":"cj0xuzlp70002vegcsiqckxxb","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/6.png","slug":"6.png","post":"cj0xuzlp70002vegcsiqckxxb","modified":0,"renderable":0},{"_id":"source/_posts/Eclipse编码问题终极解决方案/7.png","slug":"7.png","post":"cj0xuzlp70002vegcsiqckxxb","modified":0,"renderable":0},{"_id":"source/_posts/java代理机制/1.png","slug":"1.png","post":"cj0xuzlra001hvegcahn5vkpb","modified":0,"renderable":0},{"_id":"source/_posts/java代理机制/2.png","slug":"2.png","post":"cj0xuzlra001hvegcahn5vkpb","modified":0,"renderable":0},{"_id":"source/_posts/java代理机制/3.png","slug":"3.png","post":"cj0xuzlra001hvegcahn5vkpb","modified":0,"renderable":0},{"_id":"source/_posts/java代理机制/4.png","slug":"4.png","post":"cj0xuzlra001hvegcahn5vkpb","modified":0,"renderable":0},{"_id":"source/_posts/java代理机制/5.png","slug":"5.png","post":"cj0xuzlra001hvegcahn5vkpb","modified":0,"renderable":0},{"_id":"source/_posts/java代理机制/Proxy.jpg","slug":"Proxy.jpg","post":"cj0xuzlra001hvegcahn5vkpb","modified":0,"renderable":0},{"_id":"source/_posts/java代理机制/seq_Proxy.jpg","slug":"seq_Proxy.jpg","post":"cj0xuzlra001hvegcahn5vkpb","modified":0,"renderable":0},{"_id":"source/_posts/I-O总结/child-817369__340.jpg","slug":"child-817369__340.jpg","post":"cj0xuzlpg0005vegc5x3zlm3t","modified":0,"renderable":0},{"_id":"source/_posts/I-O总结/decoder.jpg","slug":"decoder.jpg","post":"cj0xuzlpg0005vegc5x3zlm3t","modified":0,"renderable":0},{"_id":"source/_posts/I-O总结/decorator.jpg","slug":"decorator.jpg","post":"cj0xuzlpg0005vegc5x3zlm3t","modified":0,"renderable":0},{"_id":"source/_posts/I-O总结/encoder.jpg","slug":"encoder.jpg","post":"cj0xuzlpg0005vegc5x3zlm3t","modified":0,"renderable":0},{"_id":"source/_posts/I-O总结/io.png","slug":"io.png","post":"cj0xuzlpg0005vegc5x3zlm3t","modified":0,"renderable":0},{"_id":"source/_posts/I-O总结/javaio2.bmp","slug":"javaio2.bmp","post":"cj0xuzlpg0005vegc5x3zlm3t","modified":0,"renderable":0},{"_id":"source/_posts/I-O总结/stream.png","slug":"stream.png","post":"cj0xuzlpg0005vegc5x3zlm3t","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation1.jpg","slug":"graduation1.jpg","post":"cj0xuzlsy0041vegcktrnnbt1","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation4.jpg","slug":"graduation4.jpg","post":"cj0xuzlsy0041vegcktrnnbt1","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation5.jpg","slug":"graduation5.jpg","post":"cj0xuzlsy0041vegcktrnnbt1","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation6.jpg","slug":"graduation6.jpg","post":"cj0xuzlsy0041vegcktrnnbt1","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation7.jpg","slug":"graduation7.jpg","post":"cj0xuzlsy0041vegcktrnnbt1","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cj0xuzlov0000vegcb90zdb7n","category_id":"cj0xuzlpf0004vegci8jmlp0u","_id":"cj0xuzlq0000bvegcgxcsjzdc"},{"post_id":"cj0xuzlpt0008vegcbeox4myi","category_id":"cj0xuzlpf0004vegci8jmlp0u","_id":"cj0xuzlqa000fvegcbx3bn2oq"},{"post_id":"cj0xuzlp70002vegcsiqckxxb","category_id":"cj0xuzlpf0004vegci8jmlp0u","_id":"cj0xuzlqg000ivegc6x2xg6uf"},{"post_id":"cj0xuzlq1000cvegcjhdbx91v","category_id":"cj0xuzlpf0004vegci8jmlp0u","_id":"cj0xuzlqk000nvegc9x57tude"},{"post_id":"cj0xuzlqb000hvegcnc8ipmnz","category_id":"cj0xuzlpf0004vegci8jmlp0u","_id":"cj0xuzlqn000qvegcq7u43rw6"},{"post_id":"cj0xuzlpg0005vegc5x3zlm3t","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlqq000vvegcsy7njisq"},{"post_id":"cj0xuzlqh000kvegcxxkkimbc","category_id":"cj0xuzlpf0004vegci8jmlp0u","_id":"cj0xuzlqs000yvegczknad4lx"},{"post_id":"cj0xuzlql000pvegcy8uodrcr","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlqv0011vegcjn3l1dt4"},{"post_id":"cj0xuzlpm0006vegcxzcgch5j","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlqy0015vegc769m4oer"},{"post_id":"cj0xuzlqo000svegc8exom9cy","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlr00018vegcn7viqyxe"},{"post_id":"cj0xuzlqq000xvegcadtqlue0","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlr4001cvegcnk371pvn"},{"post_id":"cj0xuzlpw000avegc3nld2wru","category_id":"cj0xuzlqp000tvegc673r1prx","_id":"cj0xuzlra001fvegc5d2zsy9t"},{"post_id":"cj0xuzlqs0010vegctqj1ztrj","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlrc001jvegc8i2jbvaf"},{"post_id":"cj0xuzlqv0014vegc2pnjsf8e","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlre001mvegcrlt5gg0q"},{"post_id":"cj0xuzlqy0017vegcbcz5j44p","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlrg001qvegc1tssp0wc"},{"post_id":"cj0xuzlr0001avegcj62aofj5","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlri001tvegcy6j2oupi"},{"post_id":"cj0xuzlr6001evegc6b2vn5pg","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlrl001xvegc7zgwh4fh"},{"post_id":"cj0xuzlra001hvegcahn5vkpb","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlrn0020vegcmd4l315a"},{"post_id":"cj0xuzlrc001lvegc5pxbuqk7","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlrq0024vegcx18wiggi"},{"post_id":"cj0xuzlre001ovegcqrg9t6fj","category_id":"cj0xuzlqp000tvegc673r1prx","_id":"cj0xuzlrt0027vegcz1yat2fj"},{"post_id":"cj0xuzlrh001svegcoq71j4df","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlrw002avegcaaak45ea"},{"post_id":"cj0xuzlrm001zvegcq79km8xo","category_id":"cj0xuzlpf0004vegci8jmlp0u","_id":"cj0xuzlrz002evegccm5lsoxw"},{"post_id":"cj0xuzlro0022vegcq3i35rx0","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzls3002hvegcdno76yev"},{"post_id":"cj0xuzlrr0026vegc5xrl4yju","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzls5002lvegc0njiy61p"},{"post_id":"cj0xuzlru0029vegc4axe0e6k","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzls6002ovegcbtlkoknl"},{"post_id":"cj0xuzlrx002dvegcz0jtpms7","category_id":"cj0xuzlpf0004vegci8jmlp0u","_id":"cj0xuzls9002svegc5v7b649x"},{"post_id":"cj0xuzls2002gvegcktu63uu8","category_id":"cj0xuzlqp000tvegc673r1prx","_id":"cj0xuzlsa002vvegcwd3z96na"},{"post_id":"cj0xuzls3002jvegc2tb9l0ja","category_id":"cj0xuzlpf0004vegci8jmlp0u","_id":"cj0xuzlsd002zvegcrf99nrlx"},{"post_id":"cj0xuzls5002nvegc0b464giz","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlse0032vegcdrys0wlq"},{"post_id":"cj0xuzls7002qvegc4d5n338j","category_id":"cj0xuzlpf0004vegci8jmlp0u","_id":"cj0xuzlsg0036vegctstxown5"},{"post_id":"cj0xuzls9002uvegc24uf2znn","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlsi0039vegc9ddg8cy7"},{"post_id":"cj0xuzlsb002xvegcyd6ark7u","category_id":"cj0xuzlqp000tvegc673r1prx","_id":"cj0xuzlsk003cvegcb6afzcrv"},{"post_id":"cj0xuzlsd0031vegc7hefs16b","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlsm003hvegcz2y8v52o"},{"post_id":"cj0xuzlsf0034vegcb8dbc0sw","category_id":"cj0xuzlqp000tvegc673r1prx","_id":"cj0xuzlso003kvegc3e3e1v15"},{"post_id":"cj0xuzlsg0038vegc6d62hi6g","category_id":"cj0xuzlqp000tvegc673r1prx","_id":"cj0xuzlss003ovegcf7akexm4"},{"post_id":"cj0xuzlsk003fvegcc9tczim0","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlsu003svegcziv6fs9b"},{"post_id":"cj0xuzlso003mvegcewnuja1u","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlsw003wvegcy5xa943k"},{"post_id":"cj0xuzlsi003bvegc3u2ma52f","category_id":"cj0xuzlsm003gvegctjt692d5","_id":"cj0xuzlsy003zvegcyg7owkj4"},{"post_id":"cj0xuzlss003qvegcbmz8tjfl","category_id":"cj0xuzlqp000tvegc673r1prx","_id":"cj0xuzlt00043vegcwvz3ihe7"},{"post_id":"cj0xuzlsv003uvegc4j8nzno3","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlt30046vegc8cno1c3n"},{"post_id":"cj0xuzlsm003jvegcxsz3x41m","category_id":"cj0xuzlsm003gvegctjt692d5","_id":"cj0xuzlt40049vegcjr2bv5wc"},{"post_id":"cj0xuzlsx003yvegc5jj6nu9d","category_id":"cj0xuzlpf0004vegci8jmlp0u","_id":"cj0xuzlt6004dvegcd10aqqar"},{"post_id":"cj0xuzlsy0041vegcktrnnbt1","category_id":"cj0xuzlsm003gvegctjt692d5","_id":"cj0xuzlt7004fvegc743wbyms"},{"post_id":"cj0xuzlt10045vegcsmme8k3a","category_id":"cj0xuzlqp000tvegc673r1prx","_id":"cj0xuzlt7004ivegck13z6glw"},{"post_id":"cj0xuzlt30048vegcv6gu397j","category_id":"cj0xuzlq2000dvegcbswl3sbm","_id":"cj0xuzlt7004kvegcix66euxl"},{"post_id":"cj0xuzlt4004cvegc2vuha4kq","category_id":"cj0xuzlqp000tvegc673r1prx","_id":"cj0xuzlt8004nvegcbbqjq762"}],"PostTag":[{"post_id":"cj0xuzlov0000vegcb90zdb7n","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlqb000gvegcn1qskdh1"},{"post_id":"cj0xuzlov0000vegcb90zdb7n","tag_id":"cj0xuzlps0007vegciy0arka5","_id":"cj0xuzlqh000jvegc7dy9t30j"},{"post_id":"cj0xuzlqb000hvegcnc8ipmnz","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlqk000ovegc1agbqmjv"},{"post_id":"cj0xuzlqb000hvegcnc8ipmnz","tag_id":"cj0xuzlps0007vegciy0arka5","_id":"cj0xuzlqo000rvegcd3hosufl"},{"post_id":"cj0xuzlp70002vegcsiqckxxb","tag_id":"cj0xuzlq3000evegcn99zqmnc","_id":"cj0xuzlqq000wvegceehzx3d8"},{"post_id":"cj0xuzlql000pvegcy8uodrcr","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlqs000zvegclhzee4ep"},{"post_id":"cj0xuzlpg0005vegc5x3zlm3t","tag_id":"cj0xuzlqj000mvegc6nl6ibmk","_id":"cj0xuzlqv0013vegcelnuiv9c"},{"post_id":"cj0xuzlqq000xvegcadtqlue0","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlqy0016vegcpkv88cal"},{"post_id":"cj0xuzlqs0010vegctqj1ztrj","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlr00019vegc29hztk4x"},{"post_id":"cj0xuzlpm0006vegcxzcgch5j","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlr4001dvegc0901f0a6"},{"post_id":"cj0xuzlpm0006vegcxzcgch5j","tag_id":"cj0xuzlqq000uvegchbvtz9vs","_id":"cj0xuzlra001gvegckmxvszsc"},{"post_id":"cj0xuzlqv0014vegc2pnjsf8e","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlrc001kvegcy2tdcnjg"},{"post_id":"cj0xuzlqy0017vegcbcz5j44p","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlre001nvegc36uyvqv8"},{"post_id":"cj0xuzlpt0008vegcbeox4myi","tag_id":"cj0xuzlqv0012vegcqq8l8w53","_id":"cj0xuzlrh001rvegcdy79u3en"},{"post_id":"cj0xuzlra001hvegcahn5vkpb","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlrj001uvegchv29slhj"},{"post_id":"cj0xuzlpw000avegc3nld2wru","tag_id":"cj0xuzlr2001bvegcrnv9bmvl","_id":"cj0xuzlrm001yvegczg68l4th"},{"post_id":"cj0xuzlpw000avegc3nld2wru","tag_id":"cj0xuzlrc001ivegctgnfn9ao","_id":"cj0xuzlrn0021vegc4fypomzp"},{"post_id":"cj0xuzlre001ovegcqrg9t6fj","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlrr0025vegc48z8rwpe"},{"post_id":"cj0xuzlrh001svegcoq71j4df","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlrt0028vegczglttamn"},{"post_id":"cj0xuzlq1000cvegcjhdbx91v","tag_id":"cj0xuzlqv0012vegcqq8l8w53","_id":"cj0xuzlrx002cvegcxk2ewyeh"},{"post_id":"cj0xuzlrk001vvegc54kc1ps7","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlrz002fvegcdgrgc1hk"},{"post_id":"cj0xuzlrm001zvegcq79km8xo","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzls3002ivegc107gdygu"},{"post_id":"cj0xuzlqh000kvegcxxkkimbc","tag_id":"cj0xuzlqv0012vegcqq8l8w53","_id":"cj0xuzls5002mvegc96mpnw41"},{"post_id":"cj0xuzlro0022vegcq3i35rx0","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzls7002pvegczarv4sf2"},{"post_id":"cj0xuzlrr0026vegc5xrl4yju","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzls9002tvegcxx597f48"},{"post_id":"cj0xuzlqo000svegc8exom9cy","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlsa002wvegc9iwkr8i4"},{"post_id":"cj0xuzlqo000svegc8exom9cy","tag_id":"cj0xuzlrq0023vegcmaj7q44l","_id":"cj0xuzlsd0030vegchuo67oxn"},{"post_id":"cj0xuzls2002gvegcktu63uu8","tag_id":"cj0xuzlqv0012vegcqq8l8w53","_id":"cj0xuzlse0033vegc4yuc3dx7"},{"post_id":"cj0xuzlr0001avegcj62aofj5","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlsg0037vegc44oelkac"},{"post_id":"cj0xuzlr0001avegcj62aofj5","tag_id":"cj0xuzlrw002bvegcn4fkcbb8","_id":"cj0xuzlsi003avegc71e9vhkf"},{"post_id":"cj0xuzls5002nvegc0b464giz","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlsk003evegci4fyz2ht"},{"post_id":"cj0xuzls5002nvegc0b464giz","tag_id":"cj0xuzlrq0023vegcmaj7q44l","_id":"cj0xuzlsm003ivegc6xeipk96"},{"post_id":"cj0xuzlrc001lvegc5pxbuqk7","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlso003lvegcgmgbc7mc"},{"post_id":"cj0xuzlrc001lvegc5pxbuqk7","tag_id":"cj0xuzlrq0023vegcmaj7q44l","_id":"cj0xuzlss003pvegcf0qxaw5a"},{"post_id":"cj0xuzls9002uvegc24uf2znn","tag_id":"cj0xuzlqv0012vegcqq8l8w53","_id":"cj0xuzlsu003tvegc3a6vs0ts"},{"post_id":"cj0xuzlru0029vegc4axe0e6k","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlsw003xvegc1ckqsa3r"},{"post_id":"cj0xuzlru0029vegc4axe0e6k","tag_id":"cj0xuzls8002rvegcmrr2jvqo","_id":"cj0xuzlsy0040vegcbe9eh0pr"},{"post_id":"cj0xuzlsd0031vegc7hefs16b","tag_id":"cj0xuzlrq0023vegcmaj7q44l","_id":"cj0xuzlt10044vegc3sitwumx"},{"post_id":"cj0xuzlsd0031vegc7hefs16b","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlt30047vegc2ms3zkrs"},{"post_id":"cj0xuzlsg0038vegc6d62hi6g","tag_id":"cj0xuzlqv0012vegcqq8l8w53","_id":"cj0xuzlt4004bvegcun18ae48"},{"post_id":"cj0xuzlrx002dvegcz0jtpms7","tag_id":"cj0xuzlsc002yvegcrjtvozgu","_id":"cj0xuzlt6004evegcm57dxu3x"},{"post_id":"cj0xuzlrx002dvegcz0jtpms7","tag_id":"cj0xuzlsg0035vegcr8d8gdz6","_id":"cj0xuzlt7004hvegcixqsihc2"},{"post_id":"cj0xuzlsk003fvegcc9tczim0","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlt7004jvegcmhw5emer"},{"post_id":"cj0xuzls3002jvegc2tb9l0ja","tag_id":"cj0xuzlsk003dvegc6cq9g7oy","_id":"cj0xuzlt8004lvegcjym6d4yz"},{"post_id":"cj0xuzlso003mvegcewnuja1u","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlt8004ovegcw584w4tj"},{"post_id":"cj0xuzls7002qvegc4d5n338j","tag_id":"cj0xuzlsq003nvegca2xwekaa","_id":"cj0xuzlt8004pvegc61xs0q3o"},{"post_id":"cj0xuzls7002qvegc4d5n338j","tag_id":"cj0xuzlrw002bvegcn4fkcbb8","_id":"cj0xuzlt8004qvegchacs2432"},{"post_id":"cj0xuzlsv003uvegc4j8nzno3","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlt8004rvegct8524dyo"},{"post_id":"cj0xuzlsb002xvegcyd6ark7u","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlt8004svegcm5q3kjl5"},{"post_id":"cj0xuzlsb002xvegcyd6ark7u","tag_id":"cj0xuzlsw003vvegcu83u0ue3","_id":"cj0xuzlt8004tvegchdbep99s"},{"post_id":"cj0xuzlt10045vegcsmme8k3a","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlt8004uvegcf1kfv6sy"},{"post_id":"cj0xuzlt30048vegcv6gu397j","tag_id":"cj0xuzlpb0003vegc4knggns6","_id":"cj0xuzlt8004vvegcfm2sbrnm"},{"post_id":"cj0xuzlt30048vegcv6gu397j","tag_id":"cj0xuzlrq0023vegcmaj7q44l","_id":"cj0xuzlt9004wvegcv16mxbtz"},{"post_id":"cj0xuzlsf0034vegcb8dbc0sw","tag_id":"cj0xuzlt00042vegcps1lbdmt","_id":"cj0xuzlt9004xvegcu8mnlvzr"},{"post_id":"cj0xuzlss003qvegcbmz8tjfl","tag_id":"cj0xuzlsw003vvegcu83u0ue3","_id":"cj0xuzlt9004yvegc3a9nd41f"},{"post_id":"cj0xuzlsx003yvegc5jj6nu9d","tag_id":"cj0xuzlt7004gvegcq4izo90w","_id":"cj0xuzlt9004zvegcw0irms88"},{"post_id":"cj0xuzlt4004cvegc2vuha4kq","tag_id":"cj0xuzlrc001ivegctgnfn9ao","_id":"cj0xuzlt90050vegcgizinzpi"},{"post_id":"cj0xuzlt4004cvegc2vuha4kq","tag_id":"cj0xuzlt8004mvegcx5wjwiti","_id":"cj0xuzlt90051vegckxq2axm5"}],"Tag":[{"name":"java","_id":"cj0xuzlpb0003vegc4knggns6"},{"name":"ant","_id":"cj0xuzlps0007vegciy0arka5"},{"name":"Eclipse","_id":"cj0xuzlq3000evegcn99zqmnc"},{"name":"java io","_id":"cj0xuzlqj000mvegc6nl6ibmk"},{"name":"源码","_id":"cj0xuzlqq000uvegchbvtz9vs"},{"name":"linux","_id":"cj0xuzlqv0012vegcqq8l8w53"},{"name":"服务器","_id":"cj0xuzlr2001bvegcrnv9bmvl"},{"name":"spring","_id":"cj0xuzlrc001ivegctgnfn9ao"},{"name":"多线程","_id":"cj0xuzlrq0023vegcmaj7q44l"},{"name":"编码","_id":"cj0xuzlrw002bvegcn4fkcbb8"},{"name":"调试","_id":"cj0xuzls8002rvegcmrr2jvqo"},{"name":"junit","_id":"cj0xuzlsc002yvegcrjtvozgu"},{"name":"测试","_id":"cj0xuzlsg0035vegcr8d8gdz6"},{"name":"markdown","_id":"cj0xuzlsk003dvegc6cq9g7oy"},{"name":"python","_id":"cj0xuzlsq003nvegca2xwekaa"},{"name":"加密","_id":"cj0xuzlsw003vvegcu83u0ue3"},{"name":"web","_id":"cj0xuzlt00042vegcps1lbdmt"},{"name":"快捷键","_id":"cj0xuzlt7004gvegcq4izo90w"},{"name":"curl","_id":"cj0xuzlt8004mvegcx5wjwiti"}]}}