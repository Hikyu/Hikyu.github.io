{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/next/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechat-qcode.jpg","path":"images/wechat-qcode.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"75913de577e6e2674855228ebb98f985574fdca1","modified":1491916118816},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1491916118869},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1491916118870},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1491916118870},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1491916118870},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1491916118870},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1491916118870},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1491916118870},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1491916118870},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1491916118870},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1491916118870},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1491916118870},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1491916118871},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1491916118871},{"_id":"themes/next/_config.yml","hash":"73feefe5e6b1ebb8515d0270ee21e0d628de294e","modified":1493990024642},{"_id":"themes/next/package.json","hash":"7e87b2621104b39a30488654c2a8a0c6a563574b","modified":1491916118878},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1491916118871},{"_id":"source/_posts/Java-NIO-Channel.md","hash":"6cb9ba0a328924e9572d24e9ff76c513d4052a00","modified":1499521644876},{"_id":"source/_posts/Java-NIO-MappedByteBuffer.md","hash":"2208d1899930c016aff1089407a798bcc27ee98a","modified":1499126444523},{"_id":"source/_posts/Linux的五个查找命令.md","hash":"10e23bb2b504edb697344d22066ddc6577b0a08e","modified":1491916118834},{"_id":"source/_posts/Java集合框架学习总结.md","hash":"391f959477c20810a80deed8447c766c21faffc5","modified":1491916118833},{"_id":"source/_posts/Spring项目打包为jar.md","hash":"74606324b74f435ef7936cab241c6c7e4003a5f0","modified":1491916118834},{"_id":"source/_posts/ant编译java工程jdk路径的设置.md","hash":"6cf26f08f8cc8f7e30a7ee58b3cec9569a0bef07","modified":1491916118836},{"_id":"source/_posts/Vps使用笔记.md","hash":"8c18b9f5efcadd579833afa554f442b5e0b0ab8d","modified":1491916118836},{"_id":"source/_posts/centos7BCM驱动安装.md","hash":"da90d1cb0645957b790d3355526e88ffc2c3f5b8","modified":1491916118836},{"_id":"source/_posts/hexo博客备份方案.md","hash":"4f4566754bf586ce1be65f5650d136d4fa20cd12","modified":1491920094245},{"_id":"source/_posts/java-NIO-Buffer.md","hash":"a7f0a0811cdf004397833071e9ddfc7027cc4097","modified":1498739748298},{"_id":"source/_posts/java_Tips.md","hash":"9aa7fea82a20c5ff8585a88adbd2d37aa27d529c","modified":1491916118837},{"_id":"source/_posts/java中的ThreadLocal.md","hash":"e89f4cae23060b733e510506c663344b5475a932","modified":1491916118838},{"_id":"source/_posts/java中的equals与hashcode.md","hash":"95117c4b10c2755e2f827caaefeadf29db47f21a","modified":1491916118838},{"_id":"source/_posts/java中的int/byte互转.md","hash":"1e03e7c37002ccb9593f1dbcf155af18e7784981","modified":1491916118838},{"_id":"source/_posts/java中的枚举.md","hash":"e1252cbfc46058fac0d6a34d1ac67b7d3c8b7ecf","modified":1491916118839},{"_id":"source/_posts/java中的类型转换.md","hash":"ec86f157a05080c545943a7ae9050f5d03848441","modified":1491916118839},{"_id":"source/_posts/java中的编码问题.md","hash":"cd60e56e16c4aad6238498c435111ab037465a41","modified":1491916118839},{"_id":"source/_posts/java中的路径.md","hash":"d7481d22fdb646dde8e400bd71f4fce26779738c","modified":1491916118840},{"_id":"source/_posts/java代理机制.md","hash":"9c665cc1bd65a7267eda2ab9d6a4de852e9c1fd2","modified":1491916118840},{"_id":"source/_posts/java任务取消.md","hash":"5a428e4666194cf4e8612dd0ce65cb3a89089eb5","modified":1493899547444},{"_id":"source/_posts/Ant的使用.md","hash":"a4cc151fe62ac6f8432b2353d1a263cbf0ff783d","modified":1491916118816},{"_id":"source/_posts/java国际化.md","hash":"54b4f2c31e5034118003ad713804b772e56335a7","modified":1491916118842},{"_id":"source/_posts/java序列化与反序列化.md","hash":"bb303bcc3f3cfd329450b417df1e97f347f14dfc","modified":1491916118842},{"_id":"source/_posts/java异常的学习.md","hash":"aa1db12aa5c0ba75b40abce1e0e802863f8966d4","modified":1491916118842},{"_id":"source/_posts/java文件描述符.md","hash":"b63da9989d8a4cbfdaa9a4d2974f844eb236a8d4","modified":1499432695310},{"_id":"source/_posts/java日志使用.md","hash":"c1382d58e837362d47e8b478d01b9df75b84b2e5","modified":1491916118843},{"_id":"source/_posts/Eclipse编码问题终极解决方案.md","hash":"ae458fba0c5e23b88bc20e1fd6b977d16041642b","modified":1491916118816},{"_id":"source/_posts/I-O总结.md","hash":"3a1f6396588d964879963ac440028c138ff8f0be","modified":1491916118820},{"_id":"source/_posts/java类加载.md","hash":"41811444a0c2af3a974dd88ee505f17beb08f8c9","modified":1491916118844},{"_id":"source/_posts/java注解.md","hash":"d2dfc3115da4838f462df8624f1383c9c467ca13","modified":1491916118844},{"_id":"source/_posts/java线程池的使用.md","hash":"b0c33150601552c9b36c039fc76cb6d2676f2d89","modified":1494249546000},{"_id":"source/_posts/java远程调试学习.md","hash":"fbbacb497454d6bbfd6b3e60cab6b3fc2f903243","modified":1491916118845},{"_id":"source/_posts/junit使用.md","hash":"1f10d82729fd73e56186258b4f3af2b326e163f1","modified":1491916118846},{"_id":"source/_posts/linux分区.md","hash":"d37cf4dff119e3d21f95d3c0f8479ddc7d898d54","modified":1491916118846},{"_id":"source/_posts/markdown.md","hash":"76cd5083979e3424223d582a2a91bfc4676f5473","modified":1491916118847},{"_id":"source/_posts/maven学习笔记.md","hash":"f63781079a6be52f9c99ac2e3b4220b8768372b1","modified":1492574412882},{"_id":"source/_posts/notify问题.md","hash":"c7fb077a5b48dfec3063bb9af5ac7f28a0e38950","modified":1491916118847},{"_id":"source/_posts/maven学习笔记2.md","hash":"ea94156c946a9f5b3f49cd4227939e636331f69d","modified":1492574434672},{"_id":"source/_posts/sphinx安装问题.md","hash":"bc839405bac5a09c502c5245a151be5dbc2480a4","modified":1491916118847},{"_id":"source/_posts/ssh的两种用法.md","hash":"acd053079ee19b77d2e3d1a6eed86cebfa87ba30","modified":1491916118847},{"_id":"source/_posts/ssl总结.md","hash":"aabba5f142b7d3cdb4833a9492f055c1dab367ec","modified":1491916118847},{"_id":"source/_posts/synchronized的一些用法.md","hash":"1d094f75d1b6445f2b750f59e55633249de912ae","modified":1491916118849},{"_id":"source/_posts/win7与centos7双系统安装.md","hash":"49c571c64a9f83d589b2cc7067fe99f41af75c6d","modified":1491916118850},{"_id":"source/_posts/webservice相关.md","hash":"55e658db93cf226459a2660dd1d107220441b5bc","modified":1491916118850},{"_id":"source/_posts/java同步锁锁什么.md","hash":"23311294d5915b74a6e69d06e687cec30ea234bf","modified":1491916118842},{"_id":"source/_posts/java泛型学习.md","hash":"504d47f6bfdf302ef6e34acb4d60b81dc02c5b75","modified":1491916118843},{"_id":"source/_posts/为什么是final.md","hash":"ffc362471cc5b99fb82dad4035d5f20de9b542b9","modified":1491916118850},{"_id":"source/_posts/他可是科比·布莱恩特!.md","hash":"85285dc7b79ee5ffb425fe6dd92d0ab6ef4be7df","modified":1491916118850},{"_id":"source/_posts/关于加密的一点总结.md","hash":"0ee25fb4cafe05a1d74242f7efac201690d66c2a","modified":1491916118851},{"_id":"source/_posts/关于抽象类和接口.md","hash":"49b8135e73da00c8f65380159232e32c155930f6","modified":1491916118851},{"_id":"source/_posts/代码格式.md","hash":"1ccca7f51d3c68b113a8c80111de94b3cd8dda54","modified":1491916118851},{"_id":"source/_posts/凉拌黄瓜.md","hash":"8f54b574af5867a905aa2db7778c07a792251a31","modified":1494163819420},{"_id":"source/_posts/如何炒肉.md","hash":"d090120d834e3e7c01e99a1a692688ae6165af77","modified":1494163830022},{"_id":"source/_posts/土豆烧肉.md","hash":"666d00884458735d26d13b9bf392721823d3cb19","modified":1492574718783},{"_id":"source/_posts/如何从外网访问家里的电脑.md","hash":"32026d592aabcfce5aaf6571fb0bdc6f5ed35f93","modified":1496599400400},{"_id":"source/_posts/并发场景下缓存的创建.md","hash":"972d52c9c97e1b0d877e1e3c6dd674a22617b36f","modified":1498650225910},{"_id":"source/_posts/常用快捷键总结.md","hash":"a14ed1a05666cb99513228554ab8e38f020e8674","modified":1491916118851},{"_id":"source/_posts/建造者模式的使用.md","hash":"f5926a65d5f547119cfb067ef7a7a73b26de7378","modified":1496069689059},{"_id":"source/_posts/毕业了.md","hash":"d6cf83cbfc0dffa61499e49cc60be6de65e8d9f3","modified":1491916118852},{"_id":"source/_posts/木耳炒山药.md","hash":"37b9d882c51a39d8cbf2ab0e15b914043faa5813","modified":1493215659952},{"_id":"source/_posts/理解notify notifyall sleep.md","hash":"5770f907e9a15b7b00e8d8c611b7717f88fb37fe","modified":1491916118858},{"_id":"source/_posts/糖醋里脊.md","hash":"862fa235af0ca584826bfa77439e86249d60ce5c","modified":1494247205290},{"_id":"source/_posts/理解java内存模型.md","hash":"375e87cbdb0d8b5143ec9a196efdeb07198dc610","modified":1491916118857},{"_id":"source/_posts/线程池异常处理方案.md","hash":"44b7cc13747b652650bbb92f98c1327cf14be800","modified":1493899620242},{"_id":"source/_posts/记录这周工作遇到的坑.md","hash":"6fb106e6e4aca44d52d7d2441bf89a2d3a7539c7","modified":1491916118860},{"_id":"source/categories/index.md","hash":"775cc742c92a460eced93ff229e473a42f931c00","modified":1492575772000},{"_id":"source/tags/index.md","hash":"6e4173e9cfd9ad7399e923a10b9fe5e8baefab70","modified":1492575713987},{"_id":"source/page/index.md","hash":"b80531ea22382a2ef0f390d539403b146e92db14","modified":1496070462768},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1491916118870},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"fdd63b77472612337309eb93ec415a059b90756b","modified":1491916118870},{"_id":"source/tools/index.md","hash":"25fe930d3376c509897260b19825a6ebaa06080c","modified":1496594691553},{"_id":"themes/next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1491916118871},{"_id":"themes/next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1491916118871},{"_id":"themes/next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1491916118871},{"_id":"themes/next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1491916118871},{"_id":"themes/next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1491916118871},{"_id":"themes/next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1491916118871},{"_id":"themes/next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1491916118871},{"_id":"themes/next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1491916118872},{"_id":"themes/next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1491916118872},{"_id":"themes/next/languages/ru.yml","hash":"7462c3017dae88e5f80ff308db0b95baf960c83f","modified":1491916118872},{"_id":"themes/next/languages/zh-Hans.yml","hash":"a2cbe85ba935915720d0f88469f07c2d6a08fc93","modified":1493988657000},{"_id":"themes/next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1491916118872},{"_id":"themes/next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1491916118872},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1491916118877},{"_id":"themes/next/layout/_layout.swig","hash":"909d68b164227fe7601d82e2303bf574eb754172","modified":1491916118872},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1491916118877},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1491916118877},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1491916118877},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1491916118877},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1491916118878},{"_id":"themes/next/layout/schedule.swig","hash":"234dc8c3b9e276e7811c69011efd5d560519ef19","modified":1491916118878},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1491916118878},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1491916118878},{"_id":"themes/next/source/404.html","hash":"d6cd47ba4ab178269d9e7be773e521a3f74a738b","modified":1491916118879},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1491916118911},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1491916118911},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1491916118911},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1491916118886},{"_id":"source/_posts/Eclipse编码问题终极解决方案/2.png","hash":"4dd8a8d179e898c803a879fec14afb855a34b23d","modified":1491916118817},{"_id":"source/_posts/Eclipse编码问题终极解决方案/3.png","hash":"d62218e89ab63a0c4a05ebfd35192b7f3c031588","modified":1491916118818},{"_id":"source/_posts/Eclipse编码问题终极解决方案/4.png","hash":"5ef56fc1e37d46da093fbf0b94273b45eb3cb8bd","modified":1491916118818},{"_id":"source/_posts/Eclipse编码问题终极解决方案/5.png","hash":"7fc75d3a44bebd24c9df7ad7e7d49d70de611325","modified":1491916118818},{"_id":"source/_posts/I-O总结/child-817369__340.jpg","hash":"bd3bc9c879086c56a6b11fb9bf537a7aefea6bbf","modified":1491916118820},{"_id":"source/_posts/I-O总结/decoder.jpg","hash":"3ade788875dedb4a1bfb181edb2e6a3124e80f82","modified":1491916118820},{"_id":"source/_posts/I-O总结/decorator.jpg","hash":"7cc2521b403bd45ab7078ee7eb9557e0df6ccc65","modified":1491916118821},{"_id":"source/_posts/I-O总结/encoder.jpg","hash":"d4eb18c566bc686b1ef2c570e54e30cfbba3dec3","modified":1491916118821},{"_id":"source/_posts/Java-NIO-Channel/api.png","hash":"81b4ea714966c133809736d16d2a98de67fbc354","modified":1499405868000},{"_id":"source/_posts/Java-NIO-Channel/bytechannel.png","hash":"f5a0a41a3852f3e920af3a2533deea2c3d6cbcc0","modified":1499324840000},{"_id":"source/_posts/Java-NIO-Channel/channel-uml.png","hash":"c13c9e65f2cdd2f1c929e6741ef7c710d327aac8","modified":1499323277000},{"_id":"source/_posts/Java-NIO-Channel/channel.png","hash":"1a87397099966d5f1195e20847573f5d8a149084","modified":1499321470000},{"_id":"source/_posts/Java-NIO-Channel/filechannel.png","hash":"1c7cb1c1944cfa42f5cb26d8fb1dbd1dbc55c34d","modified":1499328190000},{"_id":"source/_posts/Java-NIO-MappedByteBuffer/内存文件映射.png","hash":"696dca030b18370fcce62cad28f98cda02a6d24d","modified":1499067641000},{"_id":"source/_posts/Java-NIO-MappedByteBuffer/io.png","hash":"679b0afcda5c2cc0d2c345cdae8c6859ecfd1aa8","modified":1499066605000},{"_id":"source/_posts/Java-NIO-MappedByteBuffer/虚拟内存.png","hash":"8b33030ba4c25226940d528dd4cb4a0f42514dc4","modified":1499066491000},{"_id":"source/_posts/Java-NIO-MappedByteBuffer/页表1.png","hash":"d21ec18481468da2b783dffd9747c24cdfaeba16","modified":1499065713000},{"_id":"source/_posts/Java-NIO-MappedByteBuffer/页表.jpg","hash":"d75ec558e79f1c4af7a9381d4b704d0ad10a49d6","modified":1499063423000},{"_id":"source/_posts/Java集合框架学习总结/collection.png","hash":"9644281b68a057f4db9b162c45ac4c076c7c5651","modified":1491916118833},{"_id":"source/_posts/Spring项目打包为jar/2.png","hash":"7ff532cc98f22996c89a2a590954c113e2de486f","modified":1491916118835},{"_id":"source/_posts/Spring项目打包为jar/3.png","hash":"a6c93e41c454ca4d89a2c5153ff74ac3c9eec04a","modified":1491916118835},{"_id":"source/_posts/Spring项目打包为jar/4.png","hash":"644dca24dfefc583f2b222e967962d2de68452bb","modified":1491916118835},{"_id":"source/_posts/centos7BCM驱动安装/demo.png","hash":"bcc155b1952c95c1e4f710668c1fbf66c3fec530","modified":1491916118837},{"_id":"source/_posts/Spring项目打包为jar/5.png","hash":"7c9911eab320a22ef1a310dfb15a8996aa37de2b","modified":1491916118835},{"_id":"source/_posts/hexo博客备份方案/blog.png","hash":"aad5b5327b16a32850f62d78c92c9c33540c2d3c","modified":1491918848930},{"_id":"source/_posts/java-NIO-Buffer/2.png","hash":"e241dc86d757f3001f13c25a00b9ea8610b6d510","modified":1498707924000},{"_id":"source/_posts/java-NIO-Buffer/3.png","hash":"570d12baf84bdffb2221a0a221a638567f8d65b2","modified":1498715037000},{"_id":"source/_posts/java-NIO-Buffer/1.png","hash":"63491b5b534e6bbe6c48c0e9e28e896f87197bf9","modified":1498707880000},{"_id":"source/_posts/java-NIO-Buffer/buffer.png","hash":"c3584d02febd812ec1d726edd76f3a057d3ec648","modified":1498557641000},{"_id":"source/_posts/java-NIO-Buffer/buffer_api.png","hash":"bb331854fad535456fa658ca0ff7097f149d8512","modified":1498640978000},{"_id":"source/_posts/java中的编码问题/reader.png","hash":"4cf16c765f0952a9134bc5097270d3a6b2679f76","modified":1491916118839},{"_id":"source/_posts/java中的编码问题/utf8.png","hash":"f4a2eb95b15e12d6957c07099fafd42d9b6c035e","modified":1491916118839},{"_id":"source/_posts/java中的equals与hashcode/entry.png","hash":"c6c32336b30c74d2e825684e590fc8bb15af2dc1","modified":1491916118838},{"_id":"source/_posts/java中的编码问题/writer.png","hash":"3ac4dcf3e18dc011372297be5069f387fef0e9f9","modified":1491916118840},{"_id":"source/_posts/java代理机制/1.png","hash":"56ebe545cbaf4dc499f7cad5850d8abaa1300bf1","modified":1491916118840},{"_id":"source/_posts/java代理机制/2.png","hash":"8bdbbb357ab36dd4fd07c36616a9693538738929","modified":1491916118841},{"_id":"source/_posts/java代理机制/3.png","hash":"a87ecd9f56c1d3c3d430512faccdf919814c849f","modified":1491916118841},{"_id":"source/_posts/java代理机制/4.png","hash":"f654d9216ca853f0c48d5b09882580a366fc6fd7","modified":1491916118841},{"_id":"source/_posts/java代理机制/5.png","hash":"69bce396b216a2cd2a54f5c0d0e27f9afdc3344a","modified":1491916118841},{"_id":"source/_posts/java代理机制/Proxy.jpg","hash":"3a9e9d0a8266db70d1e842a01511830832456efb","modified":1491916118841},{"_id":"source/_posts/java代理机制/seq_Proxy.jpg","hash":"8370dba164de10270140c8825538326d8701465a","modified":1491916118842},{"_id":"source/_posts/java异常的学习/java.png","hash":"1f36e7cffb24b7771a60661d3d7301b9ca8c8f87","modified":1491916118843},{"_id":"source/_posts/java泛型学习/easybill.jpg","hash":"4090b7f4d3fb71aa1213a4ac8ef44e1d11dd8818","modified":1491916118844},{"_id":"source/_posts/java注解/doc.jpg","hash":"03a06b49ab366ff3c94cea331ed365b09468e929","modified":1491916118844},{"_id":"source/_posts/java注解/decode.jpg","hash":"e030ecf761e8d22dc3b1c0384117c43b2da8cda1","modified":1491916118844},{"_id":"source/_posts/java类加载/classloader.png","hash":"115f0a25001eacaa48002434a18be8f456631a18","modified":1491916118845},{"_id":"source/_posts/java类加载/jiazai.png","hash":"1308ab67c3f6bfe33453e811b98a0e62f0bd2199","modified":1491916118845},{"_id":"source/_posts/java线程池的使用/pool_execute.jpg","hash":"6738a0ea3f5971bd8ef12ed01cb14356906faab4","modified":1494247028790},{"_id":"source/_posts/java远程调试学习/jdpa.png","hash":"d0fc92e1d6b23a66eb753304c6ca06df2f91357d","modified":1491916118845},{"_id":"source/_posts/java线程池的使用/pool_uml.png","hash":"ab72db6cf9ff2dd6943b38dd16213cbdb77ab51b","modified":1493184265000},{"_id":"source/_posts/java远程调试学习/setting.png","hash":"5cdc18528edb9e01c731b8c4c5057467670ea59e","modified":1491916118846},{"_id":"source/_posts/linux分区/cipan.png","hash":"1e77c52d0c861bc5fd7510e831d568abf572678f","modified":1491916118846},{"_id":"source/_posts/linux分区/fen.png","hash":"de50e2303147c158b8a7b7cc2a37f73dd5684024","modified":1491916118847},{"_id":"source/_posts/linux分区/kuozhan.png","hash":"df39a6db64d871444b8dfaf6b60230b5b5dd35e7","modified":1491916118847},{"_id":"source/_posts/linux分区/yindao.jpg","hash":"6a6e4a3550ac8e515a08c22c71f1197b353a815e","modified":1491916118847},{"_id":"source/_posts/linux分区/zhumian.jpg","hash":"8b553452a7eab6e787183f5b39f1c35e7302de2d","modified":1491916118847},{"_id":"source/_posts/maven学习笔记/mvn.png","hash":"740cf81f23b447dc2435bdc85c5e9b5c3c674b02","modified":1492407347000},{"_id":"source/_posts/ssl总结/zhifubao.png","hash":"861fb5b3e7686cab022872e16f93eee43f2f657c","modified":1491916118849},{"_id":"source/_posts/ssl总结/zhufubao1.png","hash":"31d3700c1b34205b3527e551806815a179012710","modified":1491916118849},{"_id":"source/_posts/ssl总结/zhufubao2.png","hash":"670fb52cc2d6a871af24621ff34613d80f47213a","modified":1491916118849},{"_id":"source/_posts/关于加密的一点总结/md5.png","hash":"5830f21212d5da0f37cb94dd97fc8db37dcdf033","modified":1491916118851},{"_id":"source/_posts/如何从外网访问家里的电脑/2.png","hash":"54a76bd9b6ee1f73ae0e4021a44a804cba6fde1e","modified":1496598926089},{"_id":"source/_posts/如何从外网访问家里的电脑/3.png","hash":"53d7edaa360b4eb3d500f3c5c7612149c6fc5fb8","modified":1496585905289},{"_id":"source/_posts/如何从外网访问家里的电脑/4.png","hash":"f4be7599bb4a42c5fbf519ea7cf195aba0334737","modified":1496585889530},{"_id":"source/_posts/如何从外网访问家里的电脑/5.png","hash":"f0182fc6bc760181cb033f5434dee6db72b85dfc","modified":1496598565369},{"_id":"source/_posts/如何从外网访问家里的电脑/6.png","hash":"356960022e9d61aa024f55c266701eca415f034e","modified":1496585666786},{"_id":"source/_posts/如何从外网访问家里的电脑/7.png","hash":"85cfa901e970d7cb7e59e48317288b4e62e1e526","modified":1496585869000},{"_id":"source/_posts/并发场景下缓存的创建/1.png","hash":"db1cf1da8d437ec6beca3bd764de5d6536fb60f0","modified":1498202476000},{"_id":"source/_posts/并发场景下缓存的创建/2.png","hash":"9b933eed4530d215aee750b86fd5373964adb977","modified":1498202935000},{"_id":"source/_posts/并发场景下缓存的创建/3.png","hash":"bfdba04f42d2876098a72cfd019f235361f94af0","modified":1498202877000},{"_id":"source/_posts/建造者模式的使用/builder.jpg","hash":"79f2162d57679771b2e21b5aa0c05808f5531602","modified":1496062829990},{"_id":"source/_posts/理解java内存模型/volatile.png","hash":"66e532f81e9747722754733ee0361d3e28bf3ce1","modified":1491916118858},{"_id":"source/_posts/理解java内存模型/内存模型.png","hash":"9afbd38d84a83cd56288172cc45fc627867113c2","modified":1491916118858},{"_id":"source/_posts/理解notify notifyall sleep/线程状态.png","hash":"0716019dc5c338a2b07197e0cd5f593d4dedc504","modified":1491916118858},{"_id":"source/_posts/线程池异常处理方案/future.png","hash":"558ef0b77855071e9370e3b151f0eec42a27e3ac","modified":1493186753000},{"_id":"source/_posts/线程池异常处理方案/futuretask.png","hash":"13ea1762a6ea24f102b7f1f81058e42c8be09301","modified":1493173725000},{"_id":"source/_posts/线程池异常处理方案/futuretask_get.png","hash":"b5008c0bc23be8843cf572e0456365a6df37068c","modified":1493188549000},{"_id":"source/_posts/线程池异常处理方案/callable.png","hash":"72cf5f1e0240c16f4886da841030f07df316fafc","modified":1493188003000},{"_id":"source/_posts/线程池异常处理方案/futuretask_run.png","hash":"40d4dc9dc1da15955896ceefd77c1edf28729a07","modified":1493188301000},{"_id":"source/_posts/线程池异常处理方案/siwei.png","hash":"99d54f1ac52eb58f2e60ee79849b8c7e49469dc3","modified":1493182854000},{"_id":"source/_posts/线程池异常处理方案/submit.png","hash":"a3e6fd9847c4fecff501e37c09f2004047b29ef3","modified":1493186267000},{"_id":"source/_posts/线程池异常处理方案/threadpool.png","hash":"ab72db6cf9ff2dd6943b38dd16213cbdb77ab51b","modified":1493184265000},{"_id":"source/_posts/线程池异常处理方案/futuretask_report.png","hash":"eefc0f520bc31cec5b0153f51cc57c0b2c7a63f9","modified":1493188573000},{"_id":"source/_posts/记录这周工作遇到的坑/compiler.png","hash":"9ac5d2d7f2e76b216a82cf9eaea2034857c18127","modified":1491916118860},{"_id":"source/_posts/记录这周工作遇到的坑/gengeration.png","hash":"acd8916c32713eb373fed19198b000b0516080e6","modified":1491916118860},{"_id":"source/_posts/一些计划.md","hash":"96ae1edd7dc3708b5168b142cf3a5fa2b66fe245","modified":1491916118850},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1491916118872},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"b16fcbf0efd20c018d7545257a8533c497ea7647","modified":1491916118872},{"_id":"themes/next/layout/_macro/post.swig","hash":"640b431eccbbd27f10c6781f33db5ea9a6e064de","modified":1491916118873},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1491916118873},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"911b99ba0445b2c07373128d87a4ef2eb7de341a","modified":1491916118873},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1491916118873},{"_id":"themes/next/layout/_partials/comments.swig","hash":"1c7d3c975e499b9aa3119d6724b030b7b00fc87e","modified":1491916118873},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1491916118873},{"_id":"themes/next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1491916118873},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1491916118873},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1491916118873},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1491916118873},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1491916118874},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1491916118876},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1491916118876},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1491916118876},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1491916118876},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1491916118874},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1491916118874},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9de352a32865869e7ed6863db271c46db5853e5a","modified":1491916118875},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1491916118878},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1491916118878},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1491916118878},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1491916118878},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1491916118879},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1491916118879},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1491916118886},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1491916118887},{"_id":"themes/next/source/images/avatar.jpg","hash":"d8b905583cd35355aef1a2b4f892e052d530e346","modified":1491916118887},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1491916118887},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1491916118887},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1491916118887},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1491916118887},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1491916118887},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1491916118888},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1491916118888},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1491916118888},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1491916118888},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1491916118888},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1491916118888},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1491916118888},{"_id":"themes/next/source/images/wechat-qcode.jpg","hash":"141b7fde52da8bac6d6a15b83492cc434dcd18f6","modified":1491916118888},{"_id":"source/_posts/Eclipse编码问题终极解决方案/1.png","hash":"6ed1e52158e7dbce544e72af037ede46b38f1600","modified":1491916118817},{"_id":"source/_posts/Eclipse编码问题终极解决方案/6.png","hash":"b27b88bd85eb9e2dac3cc7164678ca203c3ff9c7","modified":1491916118819},{"_id":"source/_posts/Eclipse编码问题终极解决方案/7.png","hash":"1558afd4f271658241ff3a5189ee10bf7f5ebbf2","modified":1491916118820},{"_id":"source/_posts/I-O总结/stream.png","hash":"961acbb3af1a3fcbf57e4dd4fe6539808c0796f6","modified":1491916118833},{"_id":"source/_posts/Spring项目打包为jar/1.png","hash":"925c9162dc357b505520543c5c47d3dd11dc840a","modified":1491916118835},{"_id":"source/_posts/centos7BCM驱动安装/iwconfig.png","hash":"32e3d93bd385129acf493856b8357b025adf683a","modified":1491916118837},{"_id":"source/_posts/java任务取消/java.png","hash":"6ac61c72bf12a4a30002bec098760281d89c4c3e","modified":1493726483578},{"_id":"source/_posts/java文件描述符/filedescriptors.png","hash":"1873b955899dbd6f684d77e51703e3af254ace83","modified":1499392794000},{"_id":"source/_posts/java远程调试学习/remote.png","hash":"31329d2e3f6c04d6d13be67437e7a4322c31a061","modified":1491916118846},{"_id":"source/_posts/他可是科比·布莱恩特!/kobe.jpg","hash":"5e2e8343a4fba076d7475cc6cda941d21176be44","modified":1491916118850},{"_id":"source/_posts/如何从外网访问家里的电脑/1.png","hash":"2d42f254fc792d6e23071f6f65b4589494920085","modified":1496595276961},{"_id":"source/_posts/土豆烧肉/tudou.jpg","hash":"403c9a87655236fe1b1a7e8531aea1541a71b001","modified":1492574625000},{"_id":"source/_posts/木耳炒山药/cai.jpg","hash":"8270369202c67a192d77d67acdfb751a17f0ddf7","modified":1492346130908},{"_id":"source/_posts/毕业了/graduation5.jpg","hash":"976ff6965b27f578d365ae139db1c8d5c298d757","modified":1491916118855},{"_id":"source/_posts/毕业了/graduation6.jpg","hash":"4f36689e7db00afd3f2bc3b4c33480e9d1f1a99c","modified":1491916118855},{"_id":"source/_posts/糖醋里脊/tangculiji.jpg","hash":"06861e006547407c9d02e2f7fa3808f0d6682992","modified":1491916118859},{"_id":"source/_posts/糖醋里脊/wufan.jpg","hash":"1d624fa99aeee197c51c8dbc0910375c7cf0c572","modified":1491916118859},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1491916118875},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1491916118875},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1491916118884},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1491916118884},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1491916118884},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1491916118886},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1491916118886},{"_id":"source/_posts/记录这周工作遇到的坑/error.png","hash":"016f7b6c6d5ef72cc405baa5777bf2077d178931","modified":1491916118860},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1491916118872},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1491916118872},{"_id":"source/_posts/ssl总结/sslprocess.jpg","hash":"449b6c730fb7f7452592972d8748cf6bbe942de8","modified":1491916118849},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1491916118874},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1491916118874},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1491916118874},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1491916118873},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1491916118873},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"2d1075f4cabcb3956b7b84a8e210f5a66f0a5562","modified":1491916118874},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1491916118874},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1491916118874},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1491916118874},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1491916118876},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1491916118876},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1491916118876},{"_id":"themes/next/layout/_third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1491916118876},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1491916118876},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"abb92620197a16ed2c0775edf18a0f044a82256e","modified":1491916118876},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1491916118876},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1491916118876},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1491916118875},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1491916118875},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1491916118875},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1491916118875},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1491916118875},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1491916118875},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1491916118875},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1491916118875},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1491916118875},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1491916118875},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1491916118876},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1491916118877},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"f4dbd4c896e6510ded8ebe05394c28f8a86e71bf","modified":1491916118877},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1491916118877},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1491916118877},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1491916118875},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1491916118874},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1491916118884},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1491916118884},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1491916118884},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1491916118886},{"_id":"themes/next/source/css/_variables/base.styl","hash":"28a7f84242ca816a6452a0a79669ca963d824607","modified":1491916118886},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1491916118886},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1491916118889},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1491916118889},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1491916118889},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1491916118889},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1491916118889},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1491916118889},{"_id":"themes/next/source/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1491916118889},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1491916118889},{"_id":"themes/next/source/js/src/utils.js","hash":"e13c9ccf70d593bdf3b8cc1d768f595abd610e6e","modified":1491916118889},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1491916118890},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1491916118892},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1490345568000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1490345568000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1491916118895},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1491916118895},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1491916118895},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1491916118895},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1491916118895},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1491916118894},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1491916118894},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1491916118894},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1491916118894},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1491916118904},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1491916118903},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1491916118904},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1491916118905},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1491916118904},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1491916118905},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1491916118905},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"5b38ae00297ffc07f433c632c3dbf7bde4cdf39a","modified":1491916118905},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1491916118909},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1491916118909},{"_id":"source/_posts/毕业了/graduation3.jpg","hash":"54cffe443f66930659fe9d0a6ee12154ce8d5c28","modified":1491916118854},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1491916118904},{"_id":"source/_posts/I-O总结/javaio.png","hash":"25d4f5daf95fac37cd3ca03cab4d82dc39ce06cf","modified":1491916118826},{"_id":"source/_posts/毕业了/graduation8.jpg","hash":"ab88166275c1a01036fe3680407dfff9f52c3434","modified":1491916118857},{"_id":"source/_posts/毕业了/graduation2.jpg","hash":"ccffa377b02496a0f2437578d7f6d35b879373a5","modified":1491916118853},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1491916118910},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1491916118911},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1491916118911},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1491916118877},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1491916118884},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1491916118885},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1491916118885},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1491916118885},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1491916118885},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1491916118885},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1491916118885},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1491916118885},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1491916118885},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1491916118885},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1491916118885},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1491916118877},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1491916118885},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1491916118886},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"1eb34b9c1f6d541605ff23333eeb133e1c4daf17","modified":1491916118886},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1491916118886},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1491916118886},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1491916118886},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1491916118886},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1491916118879},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1491916118879},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1491916118879},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1491916118879},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1491916118879},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1491916118880},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1491916118882},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1491916118883},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1491916118884},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1491916118884},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1491916118884},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1491916118884},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1491916118884},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1491916118889},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1491916118892},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1491916118892},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1491916118893},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1491916118893},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1491916118893},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1491916118893},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1491916118893},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1491916118894},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1491916118895},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1491916118896},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1491916118896},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1491916118894},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1491916118908},{"_id":"source/_posts/I-O总结/io.png","hash":"68f3e58424ea0ad2e2d87b20dbb321b4b8415787","modified":1491916118824},{"_id":"source/_posts/毕业了/graduation1.jpg","hash":"55cd28acab408b9a81fd6877a47e24d20749e20c","modified":1491916118853},{"_id":"source/_posts/毕业了/graduation7.jpg","hash":"4ef31ad176f81cde92dff0958cfc0b70d789e754","modified":1491916118856},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1491916118908},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1491916118895},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1491916118895},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1491916118903},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1491916118903},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1491916118910},{"_id":"source/_posts/java线程池的使用/pool.jpg","hash":"03263f5d5d3540b33b4e08341ad933ad1464b1ac","modified":1494247022992},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1491916118885},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1491916118885},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1491916118886},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1491916118879},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1491916118879},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1491916118879},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1491916118880},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1491916118880},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1491916118880},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1491916118880},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"755b04edbbfbdd981a783edb09c9cc34cb79cea7","modified":1491916118880},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1491916118880},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1491916118880},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1491916118880},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1491916118880},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1491916118880},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1491916118880},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1491916118881},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1491916118881},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1491916118881},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1491916118881},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1491916118881},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1491916118881},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1491916118881},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1491916118881},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1491916118881},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1491916118881},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1491916118881},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1491916118881},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8c0276883398651336853d5ec0e9da267a00dd86","modified":1491916118881},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1491916118882},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1491916118882},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1491916118882},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1491916118882},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1491916118882},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1491916118882},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1491916118882},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1491916118882},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1491916118882},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1491916118882},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1491916118882},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1491916118882},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1491916118883},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1491916118883},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"dd310c2d999185e881db007360176ee2f811df10","modified":1491916118883},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1491916118883},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1491916118883},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1491916118883},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1491916118883},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1491916118883},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1491916118883},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"173490e21bece35a34858e8e534cf86e34561350","modified":1491916118883},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1491916118883},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1491916118893},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1491916118893},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1491916118893},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1491916118897},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1491916118898},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1491916118903},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1491916118893},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1491916118893},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1491916118893},{"_id":"source/_posts/毕业了/graduation4.jpg","hash":"e84c1f0a512f1aba02163ba3a8cf39460b9cb28b","modified":1491916118855},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1491916118892},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1491916118908},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1491916118901},{"_id":"source/_posts/I-O总结/javaio2.bmp","hash":"fbf20e5aaf5773f62162cb12f3c7beb6a37c520e","modified":1491916118832},{"_id":"public/search.xml","hash":"cbce8a90ace53f9d83d4423d0e7d7705fbdd8a6d","modified":1499521663145},{"_id":"public/categories/index.html","hash":"7e17119330c749bf99d05bceda391766d148e6d7","modified":1499521663443},{"_id":"public/archives/2016/10/index.html","hash":"72a1ade630dc30c8d517ba99a1fa31890ebd869b","modified":1499521663444},{"_id":"public/archives/2016/11/index.html","hash":"b7a9ef513565daf7f5ed16091484c79133c01f8b","modified":1499521663444},{"_id":"public/tags/源码/index.html","hash":"8d16bab83153b40a2059e1f4f30b404964877683","modified":1499521663444},{"_id":"public/tags/服务器/index.html","hash":"110452661dd3b9af72131d69d7c3bed3d6d59209","modified":1499521663444},{"_id":"public/tags/spring/index.html","hash":"a8a3e09026f963089168f284946dc8647a474c2c","modified":1499521663444},{"_id":"public/tags/ant/index.html","hash":"12598c3f6cfd862804d340cb69dfbfbb659b72a2","modified":1499521663445},{"_id":"public/tags/编码/index.html","hash":"9fce41d0e74076ab204a8694355514e04764f72a","modified":1499521663445},{"_id":"public/tags/hexo/index.html","hash":"d7e29ec4c1892aea66a070081ad0c87c3759e26d","modified":1499521663445},{"_id":"public/tags/Eclipse/index.html","hash":"67edfd5df3817028a6b75fe5112e4ee59dffb1b4","modified":1499521663445},{"_id":"public/tags/java-io/index.html","hash":"8df1e73d6526a7a527f1dd74325b90e7241440b2","modified":1499521663445},{"_id":"public/tags/junit/index.html","hash":"3831768bf0a3187cac51f1e2abd6aa5d1a7081b7","modified":1499521663445},{"_id":"public/tags/测试/index.html","hash":"918a3fc488e845f301b5921a891c612d514ba81b","modified":1499521663445},{"_id":"public/tags/markdown/index.html","hash":"59d02cbfbd565873c1554dee8f081574f5851478","modified":1499521663445},{"_id":"public/tags/python/index.html","hash":"0db8b55225a25ce3ca2b2b4fbf1ce76c7efc5e83","modified":1499521663445},{"_id":"public/tags/调试/index.html","hash":"3ea67ddff53b0d9bfed186e4b2d9e17a347ab25d","modified":1499521663445},{"_id":"public/tags/maven/index.html","hash":"b178a10a2129605002f365543fe9c2606e22d9c8","modified":1499521663445},{"_id":"public/tags/加密/index.html","hash":"ebe8b227197c6bcdeed225a93c1d937f94020f6d","modified":1499521663445},{"_id":"public/tags/web/index.html","hash":"a54d30113270673c76afd010b9bdbd03fbe70c26","modified":1499521663445},{"_id":"public/tags/快捷键/index.html","hash":"46bc5e031936c1066145f5b54fdd0b2f10491345","modified":1499521663445},{"_id":"public/tags/curl/index.html","hash":"ae4d8222fa1482d026ca7aa07db7dc3ce67ad354","modified":1499521663445},{"_id":"public/page/index.html","hash":"53408741b126d268571744acc19929715f4c5f2a","modified":1499521663445},{"_id":"public/2017/07/07/java文件描述符/index.html","hash":"01ee96891bc2e37de0145eeca13ff1ba91afad1b","modified":1499521663445},{"_id":"public/tags/index.html","hash":"e94f4e051702fe87e82ca80703a9326eb728808d","modified":1499521663446},{"_id":"public/tools/index.html","hash":"3af2e897a273a0eb97db3ae1d7644c45929c47eb","modified":1499521663446},{"_id":"public/2017/07/04/Java-NIO-MappedByteBuffer/index.html","hash":"b0e2e7a9d9bb5aafea6b5170c9378c8e71eaa6b0","modified":1499521663446},{"_id":"public/2017/06/28/java-NIO-Buffer/index.html","hash":"1d6df9e5a4ee472ce6c96d4666ead8f492e89ff3","modified":1499521663446},{"_id":"public/2017/06/24/并发场景下缓存的创建/index.html","hash":"4688380e81eee73c78ba744c309ab67a89325e9d","modified":1499521663446},{"_id":"public/2017/06/05/如何从外网访问家里的电脑/index.html","hash":"67eae1142909d5318d2d9f57f2f13a7649fdb36a","modified":1499521663446},{"_id":"public/2017/05/29/建造者模式的使用/index.html","hash":"a299a11dfeb13d4d07dc26ef7b07584a488b7214","modified":1499521663446},{"_id":"public/2017/05/08/java线程池的使用/index.html","hash":"74a77e16c81ae15f54b4a8307139a99b744d7b30","modified":1499521663446},{"_id":"public/2017/05/02/java任务取消/index.html","hash":"697282ecda7bb2163bedcac170621f1c204297d5","modified":1499521663446},{"_id":"public/2017/05/07/如何炒肉/index.html","hash":"a19c001e0d629c3f6de28f138ce4981e6f48b16f","modified":1499521663446},{"_id":"public/2017/04/26/线程池异常处理方案/index.html","hash":"c2d69f2a1814daff289cf187ff7cc291733e2cf1","modified":1499521663446},{"_id":"public/2017/05/07/凉拌黄瓜/index.html","hash":"6aa73326cc12c7627621380527d53c5731cd2dd3","modified":1499521663446},{"_id":"public/2017/04/19/土豆烧肉/index.html","hash":"d050d8d342fb5114eb2dbf2abda218c7031ed585","modified":1499521663446},{"_id":"public/2017/04/17/maven学习笔记/index.html","hash":"f10ceeac52de6259e7baf1867cf9cc7106dfb311","modified":1499521663446},{"_id":"public/2017/04/19/maven学习笔记2/index.html","hash":"31863b3b398ef299f2c44afdd7697f1c01832a7b","modified":1499521663446},{"_id":"public/2017/04/16/木耳炒山药/index.html","hash":"8a8c1aa118ea08b3c69371f94292fd8ba4b784e6","modified":1499521663446},{"_id":"public/2017/04/11/hexo博客备份方案/index.html","hash":"5c795d031964ab10f1cc38dd475fbd8a2c536bf6","modified":1499521663447},{"_id":"public/2017/04/09/糖醋里脊/index.html","hash":"c4dfaec77df6a0d133e79741316c7f7ecf8c1ed7","modified":1499521663447},{"_id":"public/2017/03/31/java注解/index.html","hash":"008ac166d650e2fdaab89a4169b119e88c53773b","modified":1499521663447},{"_id":"public/2017/04/06/java类加载/index.html","hash":"f412c3a17621608831427fdda7b8ca2f52fa9e70","modified":1499521663447},{"_id":"public/2017/03/28/java代理机制/index.html","hash":"a8c60672a16565e27510de3bcb57bfc1169e3c3c","modified":1499521663447},{"_id":"public/2017/03/19/I-O总结/index.html","hash":"9751efa1125315e4577fc94b89009c4e7408e58d","modified":1499521663447},{"_id":"public/2017/03/04/linux分区/index.html","hash":"e0281fb755748e96ab5e63eea91584d9c4d35c87","modified":1499521663447},{"_id":"public/2017/03/22/java序列化与反序列化/index.html","hash":"c4674668491c7b77b7ec9896dab300c6ffb26c61","modified":1499521663447},{"_id":"public/2017/03/15/webservice相关/index.html","hash":"c72781ac29c39d3ee6bd0a8b461b54050062a20c","modified":1499521663447},{"_id":"public/2017/02/25/centos7BCM驱动安装/index.html","hash":"abfbdeadd943e92e6255cf2ad42cb939822fa3f5","modified":1499521663447},{"_id":"public/2017/02/26/Linux的五个查找命令/index.html","hash":"81ef636534c4042dc2191db3f832731b00464a14","modified":1499521663447},{"_id":"public/2017/02/23/ssh的两种用法/index.html","hash":"c7119c5b1f854d429dd59709635e03f5e44f3b09","modified":1499521663447},{"_id":"public/2017/02/21/java日志使用/index.html","hash":"8a71685782c7f732582f3a8d50f812fc4b5d2a0d","modified":1499521663447},{"_id":"public/2017/02/18/win7与centos7双系统安装/index.html","hash":"8c6b60fbbdab04ecd8b31ae5c05d2066ce550d8e","modified":1499521663447},{"_id":"public/2017/02/19/java国际化/index.html","hash":"d140c784457deebed2663086052af606fe061a95","modified":1499521663447},{"_id":"public/2016/12/07/java远程调试学习/index.html","hash":"d9ce449a01ea66dede5353607672b816b2d74eb3","modified":1499521663447},{"_id":"public/2016/12/13/java异常的学习/index.html","hash":"5af4b77b2b66811e2c737a1f1a3db1b6c3d49e51","modified":1499521663448},{"_id":"public/2017/02/07/Vps使用笔记/index.html","hash":"a9a7a859a63b7b1bf644ef27d3b9d8b298ccea84","modified":1499521663448},{"_id":"public/2016/10/10/java泛型学习/index.html","hash":"9d002275dd14b3b39cad09732f6fc1c70d86d3bb","modified":1499521663448},{"_id":"public/2016/12/04/java中的路径/index.html","hash":"9f796d18b290a0c67088164f40cd9f83d7e7aff3","modified":1499521663448},{"_id":"public/2016/09/25/ssl总结/index.html","hash":"efb6ed7e282801863b3198a56b737db6f5ba5928","modified":1499521663448},{"_id":"public/2016/09/24/记录这周工作遇到的坑/index.html","hash":"eef9925818371d64ac70069a189862a90ba4ae32","modified":1499521663448},{"_id":"public/2016/11/24/java中的int/byte互转/index.html","hash":"c0dee9668acd6d0322e57b434a921283f746f028","modified":1499521663448},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/index.html","hash":"d457608532fa8c00a5e992fdea58fc96cef0ebd3","modified":1499521663448},{"_id":"public/2016/09/19/Spring项目打包为jar/index.html","hash":"5974278e03be6ab29276cb98a6b54199a73962b3","modified":1499521663448},{"_id":"public/2016/08/31/理解notify notifyall sleep/index.html","hash":"6b5143cfae5e48c4bdcb5a502950da29e65eb26a","modified":1499521663448},{"_id":"public/2016/09/10/理解java内存模型/index.html","hash":"aede85a8134add49d3d98a4f1d0008d3149b5b43","modified":1499521663448},{"_id":"public/2016/08/22/关于加密的一点总结/index.html","hash":"3e349ac9a83fedf998f974bfbcbbe1b688d85cf4","modified":1499521663448},{"_id":"public/2016/08/16/Java集合框架学习总结/index.html","hash":"85754916967dfc8868315e5e5950ffa888fc9188","modified":1499521663448},{"_id":"public/2016/07/31/为什么是final/index.html","hash":"68c00c25f7efecf7731577238db015e41b6a0522","modified":1499521663448},{"_id":"public/2016/08/16/synchronized的一些用法/index.html","hash":"b41aec01cf3e877c1674faf61e46c937ed332d9e","modified":1499521663448},{"_id":"public/2016/07/24/java_Tips/index.html","hash":"79c8b420d25c810e328812cac5d2c87c11d88def","modified":1499521663448},{"_id":"public/2016/08/15/一些计划/index.html","hash":"2e91aac71c92bfe28997635c46b1f27d57097c64","modified":1499521663448},{"_id":"public/2016/07/18/Ant的使用/index.html","hash":"ac8becd9c604dbf8d9e5fed8642780d80fcbc23d","modified":1499521663449},{"_id":"public/2016/06/30/毕业了/index.html","hash":"cde01fe476902d35e296c995b1cc42eaa5ac3f31","modified":1499521663449},{"_id":"public/2016/06/30/java中的枚举/index.html","hash":"377ee0a4852f73133fe55f6b39c1cfbd42ff9023","modified":1499521663449},{"_id":"public/2016/06/21/java中的ThreadLocal/index.html","hash":"0f7f550fb06b2e9c43c045ae9ea522e92d00f8ca","modified":1499521663449},{"_id":"public/2016/04/28/java中的类型转换/index.html","hash":"4618234ba45a3e434707c15864ca9eff10b01a05","modified":1499521663449},{"_id":"public/2016/04/28/java中的equals与hashcode/index.html","hash":"e2a2b8cba80205cb80eaa98e1568c4fdbd968f28","modified":1499521663449},{"_id":"public/2016/04/25/ant编译java工程jdk路径的设置/index.html","hash":"c897fb48e831856fa37795a58bf9e96cfb84f585","modified":1499521663449},{"_id":"public/2016/04/20/java中的编码问题/index.html","hash":"d4ccf335862337faa9a3b9b4896885923e18e443","modified":1499521663449},{"_id":"public/2016/04/15/关于抽象类和接口/index.html","hash":"4002f4dd9352f1dd65c0cdd8e7eaf62accf9ef68","modified":1499521663449},{"_id":"public/2016/04/14/他可是科比·布莱恩特!/index.html","hash":"520137bad1ae65cb12010af54e747264e3e2c4ca","modified":1499521663449},{"_id":"public/2016/04/12/junit使用/index.html","hash":"385268c14b556d3df694bd6a840c76877e38bfeb","modified":1499521663449},{"_id":"public/2016/03/29/代码格式/index.html","hash":"d6b420ca23afeba82f640d39c734261a04d0eb0d","modified":1499521663449},{"_id":"public/2016/03/30/sphinx安装问题/index.html","hash":"b7dcdb5088412817358a755a496e8b748b1be7c9","modified":1499521663449},{"_id":"public/2016/03/22/常用快捷键总结/index.html","hash":"54b711ea01453c265cc1f3a0867dd502ddf1042a","modified":1499521663449},{"_id":"public/2015/12/21/notify问题/index.html","hash":"8c38f76e277257f47d473656508ab41c805059f4","modified":1499521663449},{"_id":"public/2016/03/03/markdown/index.html","hash":"64edde75c1854778b68342e2053fa949d1c19973","modified":1499521663449},{"_id":"public/2015/12/17/java同步锁锁什么/index.html","hash":"44da847a3338b1123791ad8e7fe6d8dba7ee7af9","modified":1499521663449},{"_id":"public/archives/index.html","hash":"e94627c6d3295a873fb23fc7a09b6cfccc576fd3","modified":1499521663450},{"_id":"public/archives/page/2/index.html","hash":"240e08df3cd392bcee2539cb777291740a0132eb","modified":1499521663450},{"_id":"public/archives/page/3/index.html","hash":"6b2ab26e42b923b798eb03ee5ed34c083eb8b13e","modified":1499521663450},{"_id":"public/archives/page/4/index.html","hash":"519e3145ef16a9d56eba8b970390f86108eec44b","modified":1499521663450},{"_id":"public/archives/page/5/index.html","hash":"5d1ba3dc51e2a8958f9400b6b5c63396c5c386d3","modified":1499521663450},{"_id":"public/archives/2015/index.html","hash":"914671d4312cf657fed8e8305c20804c5f92721b","modified":1499521663450},{"_id":"public/archives/page/6/index.html","hash":"7a3f035664c21306b741c600ccf4f43b6150ce77","modified":1499521663450},{"_id":"public/archives/2015/12/index.html","hash":"29c392628a3ca88a93f6aaf042cef6d358af7626","modified":1499521663450},{"_id":"public/archives/2016/index.html","hash":"237864b5071eddb536a8a51650ebd8f3770a88bd","modified":1499521663450},{"_id":"public/archives/2016/page/2/index.html","hash":"fff1d914271ac747ad6969a75e5fdc92553b03ae","modified":1499521663450},{"_id":"public/archives/2016/page/3/index.html","hash":"79929758eba5dec411af018a4fd97747d1d2dca3","modified":1499521663450},{"_id":"public/archives/2016/page/4/index.html","hash":"b875b6afb1abb451e84aaff228179c5554728210","modified":1499521663450},{"_id":"public/archives/2016/03/index.html","hash":"72a0132ed07e9aa6a3620bb7b4d74c3dcbed48d8","modified":1499521663450},{"_id":"public/archives/2016/04/index.html","hash":"639975a69a6157c3b7976eaaf4f7fdead65b0c97","modified":1499521663450},{"_id":"public/archives/2016/06/index.html","hash":"ce5c00599547d2a5c12a891044905b22e0fd5a96","modified":1499521663450},{"_id":"public/archives/2016/07/index.html","hash":"c06e472d7def0e080d3440687c815ac096cb94c6","modified":1499521663450},{"_id":"public/archives/2016/08/index.html","hash":"a5633723ce2ff06c84493be3119e7c627308da5c","modified":1499521663450},{"_id":"public/archives/2016/09/index.html","hash":"68c9bbe17090a7f3c4dc98c1a4e52b3fdb736d12","modified":1499521663450},{"_id":"public/archives/2016/12/index.html","hash":"b21fa3811bd61fc6dee06e34d9f8964b0877d120","modified":1499521663451},{"_id":"public/archives/2017/index.html","hash":"78d694b18ead302583b10b4de2b5b39d86e7f891","modified":1499521663451},{"_id":"public/archives/2017/page/3/index.html","hash":"55f49e02c63b0692ad975b374c9058ff681d86ae","modified":1499521663451},{"_id":"public/archives/2017/page/2/index.html","hash":"769c8dfa8c5ab0d2d7c00958690b780c64a4ee72","modified":1499521663451},{"_id":"public/archives/2017/page/4/index.html","hash":"1ba693a3f5bd09fbdab050eb38d121ebf54535d0","modified":1499521663451},{"_id":"public/archives/2017/02/index.html","hash":"e37f42ade128c9621d277d37134074b49358e9fc","modified":1499521663451},{"_id":"public/archives/2017/03/index.html","hash":"29132fbda4d9991d84279a2bb7cbeb06ce809433","modified":1499521663451},{"_id":"public/archives/2017/04/index.html","hash":"d3bf7093c370685c4f942bb5c171ce2632141e26","modified":1499521663451},{"_id":"public/archives/2017/05/index.html","hash":"a79a81bdeb3dfd3475c119fe7d10e67963f1d93a","modified":1499521663451},{"_id":"public/archives/2017/06/index.html","hash":"cfe15492cfd67cf232a74e1af4067f1ac4b6acfb","modified":1499521663451},{"_id":"public/archives/2017/07/index.html","hash":"14c81551f0549e7e7bed93b40c7d6d90230ece41","modified":1499521663451},{"_id":"public/categories/工具/index.html","hash":"220be2e25a69ade0371fbd199bfcc4c93c512290","modified":1499521663451},{"_id":"public/categories/编程/index.html","hash":"52cf2a099f39e4162418a9d0991c49b47ced66c2","modified":1499521663451},{"_id":"public/categories/编程/page/2/index.html","hash":"2fe224f758ce6884e7f48acea3676a8474c9f2c1","modified":1499521663451},{"_id":"public/categories/工具/page/2/index.html","hash":"c0fdd3b70a09899ca4d1e0f25fe7583359407c8e","modified":1499521663451},{"_id":"public/categories/编程/page/4/index.html","hash":"be66c40c968b5a795a5c780e06359e23785701c0","modified":1499521663451},{"_id":"public/categories/编程/page/3/index.html","hash":"55e33e69c0f2aae58b6425ebd109779a7507ee46","modified":1499521663451},{"_id":"public/categories/生活/index.html","hash":"d1c85c52cd1dad01f60cbaa0bbcfe948f219b0b2","modified":1499521663452},{"_id":"public/index.html","hash":"52656fea48dbafb8dcc3faf0b0792a483f4a52a5","modified":1499521663452},{"_id":"public/categories/技术/index.html","hash":"460c812b90ab00299356702454c259f2345d8903","modified":1499521663452},{"_id":"public/page/2/index.html","hash":"c212b8e987a6660e18e26f980841f25165586a14","modified":1499521663452},{"_id":"public/page/3/index.html","hash":"25f7969e6a42c786756615d174937fa4c0f2f1e7","modified":1499521663452},{"_id":"public/page/4/index.html","hash":"ee71c283338398dd866cb552e00b94f264a98b8d","modified":1499521663452},{"_id":"public/page/5/index.html","hash":"69e2e31d661c446122d063ac6d77f008d121f431","modified":1499521663452},{"_id":"public/page/6/index.html","hash":"1d9dec111f2fecaeaac74eacce99e1e5fd7a9635","modified":1499521663452},{"_id":"public/page/7/index.html","hash":"23bff4dafc4c12d6688f4fd8128c908f6e298a95","modified":1499521663453},{"_id":"public/tags/java/index.html","hash":"b107057eb3b85ac62ca0b6600e97a33dcbae80c7","modified":1499521663453},{"_id":"public/tags/java/page/2/index.html","hash":"59c6167270b2b005b4e85e8faa59d6d8a3552be5","modified":1499521663453},{"_id":"public/tags/linux/index.html","hash":"9af22769f96aad7b8f66bfcf68ec1b8e8beba673","modified":1499521663453},{"_id":"public/tags/java/page/3/index.html","hash":"45cfe23db8a1e98d934161d1db2ee36c65b8a87e","modified":1499521663454},{"_id":"public/tags/java/page/4/index.html","hash":"0b66fba84ccf4f86489a2266f70a6be3f4729ed2","modified":1499521663454},{"_id":"public/tags/多线程/index.html","hash":"ae8dd690d98659d1a9586d2412ecb278ff8010f4","modified":1499521663454},{"_id":"public/tags/食物/index.html","hash":"6504c1e822bfd98e0f2d207c998b174eec4fa7d1","modified":1499521663454},{"_id":"public/2017/07/08/Java-NIO-Channel/index.html","hash":"368b08e6aeb56da1eed24ab8565ce9b376f944fd","modified":1499521663524},{"_id":"public/archives/page/7/index.html","hash":"ea9b07d3b1d9bb32e42794319944b43cb3ed2656","modified":1499521663524},{"_id":"public/CNAME","hash":"75913de577e6e2674855228ebb98f985574fdca1","modified":1499521663524},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1499521663524},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1499521663524},{"_id":"public/images/avatar.jpg","hash":"d8b905583cd35355aef1a2b4f892e052d530e346","modified":1499521663525},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1499521663525},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1499521663525},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1499521663525},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1499521663525},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1499521663525},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1499521663525},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1499521663525},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1499521663525},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1499521663525},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1499521663525},{"_id":"public/images/wechat-qcode.jpg","hash":"141b7fde52da8bac6d6a15b83492cc434dcd18f6","modified":1499521663525},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1499521663525},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1499521663525},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1499521663525},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1499521663525},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1499521663525},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1499521663526},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1499521663526},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1499521663526},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1499521663526},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1499521663526},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1499521663526},{"_id":"public/2016/04/28/java中的equals与hashcode/entry.png","hash":"c6c32336b30c74d2e825684e590fc8bb15af2dc1","modified":1499521663526},{"_id":"public/2016/08/16/Java集合框架学习总结/collection.png","hash":"9644281b68a057f4db9b162c45ac4c076c7c5651","modified":1499521663526},{"_id":"public/2017/04/11/hexo博客备份方案/blog.png","hash":"aad5b5327b16a32850f62d78c92c9c33540c2d3c","modified":1499521663526},{"_id":"public/2017/04/17/maven学习笔记/mvn.png","hash":"740cf81f23b447dc2435bdc85c5e9b5c3c674b02","modified":1499521663526},{"_id":"public/2016/12/13/java异常的学习/java.png","hash":"1f36e7cffb24b7771a60661d3d7301b9ca8c8f87","modified":1499521663526},{"_id":"public/2016/10/10/java泛型学习/easybill.jpg","hash":"4090b7f4d3fb71aa1213a4ac8ef44e1d11dd8818","modified":1499521663526},{"_id":"public/2016/08/22/关于加密的一点总结/md5.png","hash":"5830f21212d5da0f37cb94dd97fc8db37dcdf033","modified":1499521663526},{"_id":"public/2017/05/29/建造者模式的使用/builder.jpg","hash":"79f2162d57679771b2e21b5aa0c05808f5531602","modified":1499521663526},{"_id":"public/2016/08/31/理解notify notifyall sleep/线程状态.png","hash":"0716019dc5c338a2b07197e0cd5f593d4dedc504","modified":1499521663526},{"_id":"public/2017/02/25/centos7BCM驱动安装/demo.png","hash":"bcc155b1952c95c1e4f710668c1fbf66c3fec530","modified":1499521663526},{"_id":"public/2017/04/06/java类加载/classloader.png","hash":"115f0a25001eacaa48002434a18be8f456631a18","modified":1499521663526},{"_id":"public/2017/04/06/java类加载/jiazai.png","hash":"1308ab67c3f6bfe33453e811b98a0e62f0bd2199","modified":1499521663527},{"_id":"public/2017/03/31/java注解/doc.jpg","hash":"03a06b49ab366ff3c94cea331ed365b09468e929","modified":1499521663527},{"_id":"public/2017/03/31/java注解/decode.jpg","hash":"e030ecf761e8d22dc3b1c0384117c43b2da8cda1","modified":1499521663527},{"_id":"public/2016/04/20/java中的编码问题/reader.png","hash":"4cf16c765f0952a9134bc5097270d3a6b2679f76","modified":1499521663527},{"_id":"public/2016/04/20/java中的编码问题/utf8.png","hash":"f4a2eb95b15e12d6957c07099fafd42d9b6c035e","modified":1499521663527},{"_id":"public/2016/04/20/java中的编码问题/writer.png","hash":"3ac4dcf3e18dc011372297be5069f387fef0e9f9","modified":1499521663527},{"_id":"public/2016/09/10/理解java内存模型/内存模型.png","hash":"9afbd38d84a83cd56288172cc45fc627867113c2","modified":1499521663527},{"_id":"public/2016/09/10/理解java内存模型/volatile.png","hash":"66e532f81e9747722754733ee0361d3e28bf3ce1","modified":1499521663527},{"_id":"public/2017/05/08/java线程池的使用/pool_uml.png","hash":"ab72db6cf9ff2dd6943b38dd16213cbdb77ab51b","modified":1499521663527},{"_id":"public/2017/05/08/java线程池的使用/pool_execute.jpg","hash":"6738a0ea3f5971bd8ef12ed01cb14356906faab4","modified":1499521663527},{"_id":"public/2016/12/07/java远程调试学习/jdpa.png","hash":"d0fc92e1d6b23a66eb753304c6ca06df2f91357d","modified":1499521663527},{"_id":"public/2016/12/07/java远程调试学习/setting.png","hash":"5cdc18528edb9e01c731b8c4c5057467670ea59e","modified":1499521663527},{"_id":"public/2016/09/24/记录这周工作遇到的坑/compiler.png","hash":"9ac5d2d7f2e76b216a82cf9eaea2034857c18127","modified":1499521665492},{"_id":"public/2016/09/24/记录这周工作遇到的坑/error.png","hash":"016f7b6c6d5ef72cc405baa5777bf2077d178931","modified":1499521665494},{"_id":"public/2016/09/24/记录这周工作遇到的坑/gengeration.png","hash":"acd8916c32713eb373fed19198b000b0516080e6","modified":1499521665524},{"_id":"public/2016/09/25/ssl总结/zhifubao.png","hash":"861fb5b3e7686cab022872e16f93eee43f2f657c","modified":1499521665524},{"_id":"public/2016/09/25/ssl总结/zhufubao1.png","hash":"31d3700c1b34205b3527e551806815a179012710","modified":1499521665524},{"_id":"public/2016/09/25/ssl总结/zhufubao2.png","hash":"670fb52cc2d6a871af24621ff34613d80f47213a","modified":1499521665524},{"_id":"public/2017/07/04/Java-NIO-MappedByteBuffer/io.png","hash":"679b0afcda5c2cc0d2c345cdae8c6859ecfd1aa8","modified":1499521665524},{"_id":"public/2017/07/04/Java-NIO-MappedByteBuffer/内存文件映射.png","hash":"696dca030b18370fcce62cad28f98cda02a6d24d","modified":1499521665524},{"_id":"public/2017/07/04/Java-NIO-MappedByteBuffer/虚拟内存.png","hash":"8b33030ba4c25226940d528dd4cb4a0f42514dc4","modified":1499521665524},{"_id":"public/2017/07/04/Java-NIO-MappedByteBuffer/页表.jpg","hash":"d75ec558e79f1c4af7a9381d4b704d0ad10a49d6","modified":1499521665524},{"_id":"public/2017/07/04/Java-NIO-MappedByteBuffer/页表1.png","hash":"d21ec18481468da2b783dffd9747c24cdfaeba16","modified":1499521665524},{"_id":"public/2016/09/19/Spring项目打包为jar/2.png","hash":"7ff532cc98f22996c89a2a590954c113e2de486f","modified":1499521665524},{"_id":"public/2016/09/19/Spring项目打包为jar/3.png","hash":"a6c93e41c454ca4d89a2c5153ff74ac3c9eec04a","modified":1499521665524},{"_id":"public/2016/09/19/Spring项目打包为jar/4.png","hash":"644dca24dfefc583f2b222e967962d2de68452bb","modified":1499521665524},{"_id":"public/2016/09/19/Spring项目打包为jar/5.png","hash":"7c9911eab320a22ef1a310dfb15a8996aa37de2b","modified":1499521665525},{"_id":"public/2017/06/24/并发场景下缓存的创建/1.png","hash":"db1cf1da8d437ec6beca3bd764de5d6536fb60f0","modified":1499521665525},{"_id":"public/2017/06/24/并发场景下缓存的创建/2.png","hash":"9b933eed4530d215aee750b86fd5373964adb977","modified":1499521665525},{"_id":"public/2017/06/28/java-NIO-Buffer/2.png","hash":"e241dc86d757f3001f13c25a00b9ea8610b6d510","modified":1499521665525},{"_id":"public/2017/06/24/并发场景下缓存的创建/3.png","hash":"bfdba04f42d2876098a72cfd019f235361f94af0","modified":1499521665525},{"_id":"public/2017/06/28/java-NIO-Buffer/3.png","hash":"570d12baf84bdffb2221a0a221a638567f8d65b2","modified":1499521665525},{"_id":"public/2017/06/28/java-NIO-Buffer/buffer.png","hash":"c3584d02febd812ec1d726edd76f3a057d3ec648","modified":1499521665525},{"_id":"public/2017/06/28/java-NIO-Buffer/buffer_api.png","hash":"bb331854fad535456fa658ca0ff7097f149d8512","modified":1499521665525},{"_id":"public/2017/03/04/linux分区/fen.png","hash":"de50e2303147c158b8a7b7cc2a37f73dd5684024","modified":1499521665525},{"_id":"public/2017/03/04/linux分区/kuozhan.png","hash":"df39a6db64d871444b8dfaf6b60230b5b5dd35e7","modified":1499521665525},{"_id":"public/2017/03/04/linux分区/cipan.png","hash":"1e77c52d0c861bc5fd7510e831d568abf572678f","modified":1499521665525},{"_id":"public/2017/03/04/linux分区/yindao.jpg","hash":"6a6e4a3550ac8e515a08c22c71f1197b353a815e","modified":1499521665525},{"_id":"public/2017/03/04/linux分区/zhumian.jpg","hash":"8b553452a7eab6e787183f5b39f1c35e7302de2d","modified":1499521665525},{"_id":"public/2017/03/28/java代理机制/1.png","hash":"56ebe545cbaf4dc499f7cad5850d8abaa1300bf1","modified":1499521665525},{"_id":"public/2017/03/28/java代理机制/2.png","hash":"8bdbbb357ab36dd4fd07c36616a9693538738929","modified":1499521665525},{"_id":"public/2017/03/28/java代理机制/3.png","hash":"a87ecd9f56c1d3c3d430512faccdf919814c849f","modified":1499521665525},{"_id":"public/2017/03/28/java代理机制/4.png","hash":"f654d9216ca853f0c48d5b09882580a366fc6fd7","modified":1499521665526},{"_id":"public/2017/03/28/java代理机制/5.png","hash":"69bce396b216a2cd2a54f5c0d0e27f9afdc3344a","modified":1499521665526},{"_id":"public/2017/03/28/java代理机制/Proxy.jpg","hash":"3a9e9d0a8266db70d1e842a01511830832456efb","modified":1499521665526},{"_id":"public/2017/03/28/java代理机制/seq_Proxy.jpg","hash":"8370dba164de10270140c8825538326d8701465a","modified":1499521665526},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/2.png","hash":"4dd8a8d179e898c803a879fec14afb855a34b23d","modified":1499521665526},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/3.png","hash":"d62218e89ab63a0c4a05ebfd35192b7f3c031588","modified":1499521665526},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/4.png","hash":"5ef56fc1e37d46da093fbf0b94273b45eb3cb8bd","modified":1499521665526},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/5.png","hash":"7fc75d3a44bebd24c9df7ad7e7d49d70de611325","modified":1499521665526},{"_id":"public/2017/06/05/如何从外网访问家里的电脑/2.png","hash":"54a76bd9b6ee1f73ae0e4021a44a804cba6fde1e","modified":1499521665526},{"_id":"public/2017/06/05/如何从外网访问家里的电脑/3.png","hash":"53d7edaa360b4eb3d500f3c5c7612149c6fc5fb8","modified":1499521665526},{"_id":"public/2017/06/05/如何从外网访问家里的电脑/4.png","hash":"f4be7599bb4a42c5fbf519ea7cf195aba0334737","modified":1499521665526},{"_id":"public/2017/06/05/如何从外网访问家里的电脑/5.png","hash":"f0182fc6bc760181cb033f5434dee6db72b85dfc","modified":1499521665526},{"_id":"public/2017/06/05/如何从外网访问家里的电脑/6.png","hash":"356960022e9d61aa024f55c266701eca415f034e","modified":1499521665526},{"_id":"public/2017/06/05/如何从外网访问家里的电脑/7.png","hash":"85cfa901e970d7cb7e59e48317288b4e62e1e526","modified":1499521665526},{"_id":"public/2017/03/19/I-O总结/child-817369__340.jpg","hash":"bd3bc9c879086c56a6b11fb9bf537a7aefea6bbf","modified":1499521665526},{"_id":"public/2017/03/19/I-O总结/decoder.jpg","hash":"3ade788875dedb4a1bfb181edb2e6a3124e80f82","modified":1499521665526},{"_id":"public/2017/03/19/I-O总结/encoder.jpg","hash":"d4eb18c566bc686b1ef2c570e54e30cfbba3dec3","modified":1499521665526},{"_id":"public/2017/03/19/I-O总结/decorator.jpg","hash":"7cc2521b403bd45ab7078ee7eb9557e0df6ccc65","modified":1499521665527},{"_id":"public/2017/04/26/线程池异常处理方案/callable.png","hash":"72cf5f1e0240c16f4886da841030f07df316fafc","modified":1499521665527},{"_id":"public/2017/04/26/线程池异常处理方案/future.png","hash":"558ef0b77855071e9370e3b151f0eec42a27e3ac","modified":1499521665527},{"_id":"public/2017/04/26/线程池异常处理方案/futuretask.png","hash":"13ea1762a6ea24f102b7f1f81058e42c8be09301","modified":1499521665527},{"_id":"public/2017/04/26/线程池异常处理方案/futuretask_get.png","hash":"b5008c0bc23be8843cf572e0456365a6df37068c","modified":1499521665527},{"_id":"public/2017/04/26/线程池异常处理方案/futuretask_run.png","hash":"40d4dc9dc1da15955896ceefd77c1edf28729a07","modified":1499521665527},{"_id":"public/2017/04/26/线程池异常处理方案/futuretask_report.png","hash":"eefc0f520bc31cec5b0153f51cc57c0b2c7a63f9","modified":1499521665527},{"_id":"public/2017/04/26/线程池异常处理方案/siwei.png","hash":"99d54f1ac52eb58f2e60ee79849b8c7e49469dc3","modified":1499521665527},{"_id":"public/2017/04/26/线程池异常处理方案/submit.png","hash":"a3e6fd9847c4fecff501e37c09f2004047b29ef3","modified":1499521665527},{"_id":"public/2017/04/26/线程池异常处理方案/threadpool.png","hash":"ab72db6cf9ff2dd6943b38dd16213cbdb77ab51b","modified":1499521665527},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1499521665527},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1499521665527},{"_id":"public/2017/05/02/java任务取消/java.png","hash":"6ac61c72bf12a4a30002bec098760281d89c4c3e","modified":1499521665527},{"_id":"public/2016/04/14/他可是科比·布莱恩特!/kobe.jpg","hash":"5e2e8343a4fba076d7475cc6cda941d21176be44","modified":1499521665527},{"_id":"public/2017/04/19/土豆烧肉/tudou.jpg","hash":"403c9a87655236fe1b1a7e8531aea1541a71b001","modified":1499521665527},{"_id":"public/2017/04/16/木耳炒山药/cai.jpg","hash":"8270369202c67a192d77d67acdfb751a17f0ddf7","modified":1499521665527},{"_id":"public/2017/02/25/centos7BCM驱动安装/iwconfig.png","hash":"32e3d93bd385129acf493856b8357b025adf683a","modified":1499521665527},{"_id":"public/2017/04/09/糖醋里脊/tangculiji.jpg","hash":"06861e006547407c9d02e2f7fa3808f0d6682992","modified":1499521665528},{"_id":"public/2017/06/28/java-NIO-Buffer/1.png","hash":"63491b5b534e6bbe6c48c0e9e28e896f87197bf9","modified":1499521665528},{"_id":"public/2017/04/09/糖醋里脊/wufan.jpg","hash":"1d624fa99aeee197c51c8dbc0910375c7cf0c572","modified":1499521665528},{"_id":"public/2016/12/07/java远程调试学习/remote.png","hash":"31329d2e3f6c04d6d13be67437e7a4322c31a061","modified":1499521665528},{"_id":"public/2017/07/08/Java-NIO-Channel/api.png","hash":"81b4ea714966c133809736d16d2a98de67fbc354","modified":1499521665528},{"_id":"public/2017/07/08/Java-NIO-Channel/bytechannel.png","hash":"f5a0a41a3852f3e920af3a2533deea2c3d6cbcc0","modified":1499521665528},{"_id":"public/2017/07/08/Java-NIO-Channel/channel.png","hash":"1a87397099966d5f1195e20847573f5d8a149084","modified":1499521665528},{"_id":"public/2017/07/08/Java-NIO-Channel/channel-uml.png","hash":"c13c9e65f2cdd2f1c929e6741ef7c710d327aac8","modified":1499521665528},{"_id":"public/2017/07/08/Java-NIO-Channel/filechannel.png","hash":"1c7cb1c1944cfa42f5cb26d8fb1dbd1dbc55c34d","modified":1499521665528},{"_id":"public/404.html","hash":"d6cd47ba4ab178269d9e7be773e521a3f74a738b","modified":1499521665538},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1499521665538},{"_id":"public/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1499521665538},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1499521665538},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1499521665538},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1499521665538},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1499521665538},{"_id":"public/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1499521665538},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1499521665539},{"_id":"public/js/src/utils.js","hash":"e13c9ccf70d593bdf3b8cc1d768f595abd610e6e","modified":1499521665539},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1499521665539},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1499521665539},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1499521665539},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1499521665539},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1499521665539},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1499521665539},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1499521665539},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1499521665539},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1499521665539},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1499521665539},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1499521665539},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1499521665539},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1499521665539},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1499521665539},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1499521665539},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1499521665539},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1499521665540},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1499521665540},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1499521665540},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1499521665540},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1499521665540},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1499521665540},{"_id":"public/css/main.css","hash":"8cc5970ba782355ba6872e743f5aecd973528d2a","modified":1499521665540},{"_id":"public/lib/three/three-waves.min.js","hash":"5b38ae00297ffc07f433c632c3dbf7bde4cdf39a","modified":1499521665540},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1499521665540},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1499521665540},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1499521665540},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1499521665540},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1499521665540},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1499521665540},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1499521665541},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1499521665541},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1499521665541},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1499521665541},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1499521665541},{"_id":"public/2017/07/07/java文件描述符/filedescriptors.png","hash":"1873b955899dbd6f684d77e51703e3af254ace83","modified":1499521665541},{"_id":"public/2016/09/19/Spring项目打包为jar/1.png","hash":"925c9162dc357b505520543c5c47d3dd11dc840a","modified":1499521665541},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/1.png","hash":"6ed1e52158e7dbce544e72af037ede46b38f1600","modified":1499521665541},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/6.png","hash":"b27b88bd85eb9e2dac3cc7164678ca203c3ff9c7","modified":1499521665541},{"_id":"public/2016/09/20/Eclipse编码问题终极解决方案/7.png","hash":"1558afd4f271658241ff3a5189ee10bf7f5ebbf2","modified":1499521665542},{"_id":"public/2017/06/05/如何从外网访问家里的电脑/1.png","hash":"2d42f254fc792d6e23071f6f65b4589494920085","modified":1499521665542},{"_id":"public/2017/03/19/I-O总结/stream.png","hash":"961acbb3af1a3fcbf57e4dd4fe6539808c0796f6","modified":1499521665542},{"_id":"public/2016/06/30/毕业了/graduation5.jpg","hash":"976ff6965b27f578d365ae139db1c8d5c298d757","modified":1499521665542},{"_id":"public/2016/06/30/毕业了/graduation6.jpg","hash":"4f36689e7db00afd3f2bc3b4c33480e9d1f1a99c","modified":1499521665542},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1499521665542},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1499521665542},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1499521665542},{"_id":"public/2016/09/25/ssl总结/sslprocess.jpg","hash":"449b6c730fb7f7452592972d8748cf6bbe942de8","modified":1499521665568},{"_id":"public/2016/06/30/毕业了/graduation3.jpg","hash":"54cffe443f66930659fe9d0a6ee12154ce8d5c28","modified":1499521665574},{"_id":"public/2016/06/30/毕业了/graduation8.jpg","hash":"ab88166275c1a01036fe3680407dfff9f52c3434","modified":1499521665574},{"_id":"public/2016/06/30/毕业了/graduation2.jpg","hash":"ccffa377b02496a0f2437578d7f6d35b879373a5","modified":1499521665574},{"_id":"public/2017/03/19/I-O总结/javaio.png","hash":"25d4f5daf95fac37cd3ca03cab4d82dc39ce06cf","modified":1499521665574},{"_id":"public/2016/06/30/毕业了/graduation1.jpg","hash":"55cd28acab408b9a81fd6877a47e24d20749e20c","modified":1499521665580},{"_id":"public/2016/06/30/毕业了/graduation7.jpg","hash":"4ef31ad176f81cde92dff0958cfc0b70d789e754","modified":1499521665580},{"_id":"public/2017/03/19/I-O总结/io.png","hash":"68f3e58424ea0ad2e2d87b20dbb321b4b8415787","modified":1499521665580},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1499521665584},{"_id":"public/2017/05/08/java线程池的使用/pool.jpg","hash":"03263f5d5d3540b33b4e08341ad933ad1464b1ac","modified":1499521665584},{"_id":"public/2016/06/30/毕业了/graduation4.jpg","hash":"e84c1f0a512f1aba02163ba3a8cf39460b9cb28b","modified":1499521665671},{"_id":"public/2017/03/19/I-O总结/javaio2.bmp","hash":"fbf20e5aaf5773f62162cb12f3c7beb6a37c520e","modified":1499521665681}],"Category":[{"name":"工具","_id":"cj4vch4cp0005x3gct7jfyf5u"},{"name":"编程","_id":"cj4vch4d1000cx3gchfuzp20b"},{"name":"技术","_id":"cj4vch4dk000px3gcnkpw8h12"},{"name":"生活","_id":"cj4vch4gu004ex3gcva47uy74"}],"Data":[],"Page":[{"title":"categories","date":"2017-04-19T04:22:33.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-04-19 12:22:33\ntype: \"categories\"\n---\n","updated":"2017-04-19T04:22:52.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj4vch4cc0001x3gcjhd0ecqr","content":"","excerpt":"","more":""},{"layout":"page","title":"README","comments":0,"_content":"{% codeblock lang:java %}\n name: \"于凯\"\n university: \"中国民航大学\"\n hometown: \"山西晋中\"\n coordinate: \"天津\"\n{% endcodeblock %}\n\n本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。\n\n# 博客基础\n\n[Hexo](https://hexo.io/) 一款轻量级的静态博客框架\n[hexo-theme-next](https://github.com/iissnan/hexo-theme-next) 简洁的Hexo主题\n[Markdown](https://www.gitbook.com/book/noahsoft/-makedown/details) 一款轻量级的标记语言\n\n# 技能栈\n\nJava\n\nGit\n\n设计模式\n\nLinux\n\nEclipse RCP\n\n# 书单\n\n《重构 改善既有代码的设计》  人民邮电出版社\n\n《深入理解JVM虚拟机》  机械工业出版社\n\n《大话设计模式》  清华大学出版社  \n\n《Java 并发编程实战》 机械工业出版社\n\n《鸟哥的Linux私房菜》 人民邮电出版社\n \n《大型网站技术架构》 电子工业出版社\n\n《Maven实战》 机械工业出版社\n\n《计算机网络(第5版)》 电子工业出版社\n\n","source":"page/index.md","raw":"layout: page\ntitle: README\ncomments: false\n---\n{% codeblock lang:java %}\n name: \"于凯\"\n university: \"中国民航大学\"\n hometown: \"山西晋中\"\n coordinate: \"天津\"\n{% endcodeblock %}\n\n本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。\n\n# 博客基础\n\n[Hexo](https://hexo.io/) 一款轻量级的静态博客框架\n[hexo-theme-next](https://github.com/iissnan/hexo-theme-next) 简洁的Hexo主题\n[Markdown](https://www.gitbook.com/book/noahsoft/-makedown/details) 一款轻量级的标记语言\n\n# 技能栈\n\nJava\n\nGit\n\n设计模式\n\nLinux\n\nEclipse RCP\n\n# 书单\n\n《重构 改善既有代码的设计》  人民邮电出版社\n\n《深入理解JVM虚拟机》  机械工业出版社\n\n《大话设计模式》  清华大学出版社  \n\n《Java 并发编程实战》 机械工业出版社\n\n《鸟哥的Linux私房菜》 人民邮电出版社\n \n《大型网站技术架构》 电子工业出版社\n\n《Maven实战》 机械工业出版社\n\n《计算机网络(第5版)》 电子工业出版社\n\n","date":"2017-05-29T15:07:42.768Z","updated":"2017-05-29T15:07:42.768Z","path":"page/index.html","_id":"cj4vch4ch0003x3gc6eb1m85r","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">name: <span class=\"string\">\"于凯\"</span></div><div class=\"line\">university: <span class=\"string\">\"中国民航大学\"</span></div><div class=\"line\">hometown: <span class=\"string\">\"山西晋中\"</span></div><div class=\"line\">coordinate: <span class=\"string\">\"天津\"</span></div></pre></td></tr></table></figure>\n<p>本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。</p>\n<h1 id=\"博客基础\"><a href=\"#博客基础\" class=\"headerlink\" title=\"博客基础\"></a>博客基础</h1><p><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a> 一款轻量级的静态博客框架<br><a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"external\">hexo-theme-next</a> 简洁的Hexo主题<br><a href=\"https://www.gitbook.com/book/noahsoft/-makedown/details\" target=\"_blank\" rel=\"external\">Markdown</a> 一款轻量级的标记语言</p>\n<h1 id=\"技能栈\"><a href=\"#技能栈\" class=\"headerlink\" title=\"技能栈\"></a>技能栈</h1><p>Java</p>\n<p>Git</p>\n<p>设计模式</p>\n<p>Linux</p>\n<p>Eclipse RCP</p>\n<h1 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h1><p>《重构 改善既有代码的设计》  人民邮电出版社</p>\n<p>《深入理解JVM虚拟机》  机械工业出版社</p>\n<p>《大话设计模式》  清华大学出版社  </p>\n<p>《Java 并发编程实战》 机械工业出版社</p>\n<p>《鸟哥的Linux私房菜》 人民邮电出版社</p>\n<p>《大型网站技术架构》 电子工业出版社</p>\n<p>《Maven实战》 机械工业出版社</p>\n<p>《计算机网络(第5版)》 电子工业出版社</p>\n","excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">name: <span class=\"string\">\"于凯\"</span></div><div class=\"line\">university: <span class=\"string\">\"中国民航大学\"</span></div><div class=\"line\">hometown: <span class=\"string\">\"山西晋中\"</span></div><div class=\"line\">coordinate: <span class=\"string\">\"天津\"</span></div></pre></td></tr></table></figure>\n<p>本博客的目的在于记录工作和学习中的遇到的问题及解决方法，将学到的一些知识点总结下来。</p>\n<h1 id=\"博客基础\"><a href=\"#博客基础\" class=\"headerlink\" title=\"博客基础\"></a>博客基础</h1><p><a href=\"https://hexo.io/\">Hexo</a> 一款轻量级的静态博客框架<br><a href=\"https://github.com/iissnan/hexo-theme-next\">hexo-theme-next</a> 简洁的Hexo主题<br><a href=\"https://www.gitbook.com/book/noahsoft/-makedown/details\">Markdown</a> 一款轻量级的标记语言</p>\n<h1 id=\"技能栈\"><a href=\"#技能栈\" class=\"headerlink\" title=\"技能栈\"></a>技能栈</h1><p>Java</p>\n<p>Git</p>\n<p>设计模式</p>\n<p>Linux</p>\n<p>Eclipse RCP</p>\n<h1 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h1><p>《重构 改善既有代码的设计》  人民邮电出版社</p>\n<p>《深入理解JVM虚拟机》  机械工业出版社</p>\n<p>《大话设计模式》  清华大学出版社  </p>\n<p>《Java 并发编程实战》 机械工业出版社</p>\n<p>《鸟哥的Linux私房菜》 人民邮电出版社</p>\n<p>《大型网站技术架构》 电子工业出版社</p>\n<p>《Maven实战》 机械工业出版社</p>\n<p>《计算机网络(第5版)》 电子工业出版社</p>\n"},{"title":"tags","date":"2017-04-19T04:20:51.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-04-19 12:20:51\ntype: \"tags\"\n---\n","updated":"2017-04-19T04:21:53.987Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj4vch4ct0007x3gc3d7ll5zb","content":"","excerpt":"","more":""},{"layout":"page","title":"常用工具清单","comments":0,"_content":"\n## java开发\n---\n\njava IDE : Eclipse(常用) IDEA\n\njava 覆盖率测试 : [jaCoCo](https://www.ibm.com/developerworks/cn/java/j-lo-jacoco/)\n\njava 单元测试 : junit\n\njava 构建工具 : Maven(常用) Gradle\n\njava 性能监控 : Jprofiler Jconsole\n\numl : plantuml\n\n## linux\n---\n\nOS : Centos 7\n\n命令行目录跳转：autojump\n\n命令行错误修复: [thefuck](https://github.com/nvbn/thefuck)\n\n## chrome插件\n---\n\ngithub访问：octotree\n\n下载管理器：chrono\n\nmarkdown: markdown here\n\n翻译: Google翻译\n\nssh: secure shell\n\n## 移动端(Android)\n---\n\nssh客户端 : JuiceSSH\n\n翻译 : Google翻译\n\nGitHub : OctoDroid\n\n笔记 ：印象笔记\n\n记账 : 口袋记账\n\n## 其他工具\n---\n\n版本控制工具 : [git](https://git-scm.com/book/zh/v2) git客户端[sourcetree](https://www.sourcetreeapp.com/)\n\nssh客户端 : [MobaXterm](http://mobaxterm.mobatek.net/download.html)\n\ndiff 工具 : [beyond compare 3](http://www.beyondcompare.cc/)    winmerge(生成csv格式对比结果)\n\ndiff 在线对比 : [diffchecker](https://www.diffchecker.com/)\n\n抓包工具 : [wireshark](https://www.wireshark.org/)\n\n远程桌面 : teamviewer\n\n编辑器 : vscode notepad++(打开大文件)\n\n命令行浏览器 : curl(测试用的着)\n\n浏览器 : Chrome\n\n笔记工具 : 印象笔记(客户端) 印象笔记·剪藏(chrome插件)\n\n思维导图 : [XMind](http://www.xmindchina.net/)\n\n画图 : [Processon](https://www.processon.com/)\n\n微信公众号编辑器 : 135编辑器\n\n博客 : [Hexo](https://hexo.io/) \n\n搜索(Windows) : Everything\n\n翻墙\n\n- 快速安全通道(chrome插件，免费，不稳定)\n\n- [XX-Net](https://github.com/XX-net/XX-Net)\n\n- Shadowsocks(购买VPS搭建)\n\n[有哪些软件堪称「神器」，却不为大众所知？](https://www.zhihu.com/question/36546814)\n\n## 网站资源\n---\n\n[免费图片](https://pixabay.com/): 免费图片\n\n[github](www.github.com): 源代码\n\n[grepcode](http://grepcode.com/): 源码搜索\n\n[stackoverflow](https://stackoverflow.com/): 代码问题解决\n\n[vogella](http://www.vogella.com): Eclipse Rcp》\n\n[developerworks](https://www.ibm.com): java学习\n\n[uml.org.cn](http://www.uml.org.cn): java 学习\n\n[importnew](http://www.importnew.com/): java学习\n\n[Google Developers](https://developers.google.cn/): Google Developers\n\n[Git Book](https://git-scm.com/book/zh/v2): Git学习\n\n[图说设计模式](http://design-patterns.readthedocs.io/zh_CN/latest/index.html): 设计模式","source":"tools/index.md","raw":"layout: page\ntitle: 常用工具清单\ncomments: false\n---\n\n## java开发\n---\n\njava IDE : Eclipse(常用) IDEA\n\njava 覆盖率测试 : [jaCoCo](https://www.ibm.com/developerworks/cn/java/j-lo-jacoco/)\n\njava 单元测试 : junit\n\njava 构建工具 : Maven(常用) Gradle\n\njava 性能监控 : Jprofiler Jconsole\n\numl : plantuml\n\n## linux\n---\n\nOS : Centos 7\n\n命令行目录跳转：autojump\n\n命令行错误修复: [thefuck](https://github.com/nvbn/thefuck)\n\n## chrome插件\n---\n\ngithub访问：octotree\n\n下载管理器：chrono\n\nmarkdown: markdown here\n\n翻译: Google翻译\n\nssh: secure shell\n\n## 移动端(Android)\n---\n\nssh客户端 : JuiceSSH\n\n翻译 : Google翻译\n\nGitHub : OctoDroid\n\n笔记 ：印象笔记\n\n记账 : 口袋记账\n\n## 其他工具\n---\n\n版本控制工具 : [git](https://git-scm.com/book/zh/v2) git客户端[sourcetree](https://www.sourcetreeapp.com/)\n\nssh客户端 : [MobaXterm](http://mobaxterm.mobatek.net/download.html)\n\ndiff 工具 : [beyond compare 3](http://www.beyondcompare.cc/)    winmerge(生成csv格式对比结果)\n\ndiff 在线对比 : [diffchecker](https://www.diffchecker.com/)\n\n抓包工具 : [wireshark](https://www.wireshark.org/)\n\n远程桌面 : teamviewer\n\n编辑器 : vscode notepad++(打开大文件)\n\n命令行浏览器 : curl(测试用的着)\n\n浏览器 : Chrome\n\n笔记工具 : 印象笔记(客户端) 印象笔记·剪藏(chrome插件)\n\n思维导图 : [XMind](http://www.xmindchina.net/)\n\n画图 : [Processon](https://www.processon.com/)\n\n微信公众号编辑器 : 135编辑器\n\n博客 : [Hexo](https://hexo.io/) \n\n搜索(Windows) : Everything\n\n翻墙\n\n- 快速安全通道(chrome插件，免费，不稳定)\n\n- [XX-Net](https://github.com/XX-net/XX-Net)\n\n- Shadowsocks(购买VPS搭建)\n\n[有哪些软件堪称「神器」，却不为大众所知？](https://www.zhihu.com/question/36546814)\n\n## 网站资源\n---\n\n[免费图片](https://pixabay.com/): 免费图片\n\n[github](www.github.com): 源代码\n\n[grepcode](http://grepcode.com/): 源码搜索\n\n[stackoverflow](https://stackoverflow.com/): 代码问题解决\n\n[vogella](http://www.vogella.com): Eclipse Rcp》\n\n[developerworks](https://www.ibm.com): java学习\n\n[uml.org.cn](http://www.uml.org.cn): java 学习\n\n[importnew](http://www.importnew.com/): java学习\n\n[Google Developers](https://developers.google.cn/): Google Developers\n\n[Git Book](https://git-scm.com/book/zh/v2): Git学习\n\n[图说设计模式](http://design-patterns.readthedocs.io/zh_CN/latest/index.html): 设计模式","date":"2017-06-04T16:44:51.553Z","updated":"2017-06-04T16:44:51.553Z","path":"tools/index.html","_id":"cj4vch4cy0009x3gcnsv3vr36","content":"<h2 id=\"java开发\"><a href=\"#java开发\" class=\"headerlink\" title=\"java开发\"></a>java开发</h2><hr>\n<p>java IDE : Eclipse(常用) IDEA</p>\n<p>java 覆盖率测试 : <a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jacoco/\" target=\"_blank\" rel=\"external\">jaCoCo</a></p>\n<p>java 单元测试 : junit</p>\n<p>java 构建工具 : Maven(常用) Gradle</p>\n<p>java 性能监控 : Jprofiler Jconsole</p>\n<p>uml : plantuml</p>\n<h2 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h2><hr>\n<p>OS : Centos 7</p>\n<p>命令行目录跳转：autojump</p>\n<p>命令行错误修复: <a href=\"https://github.com/nvbn/thefuck\" target=\"_blank\" rel=\"external\">thefuck</a></p>\n<h2 id=\"chrome插件\"><a href=\"#chrome插件\" class=\"headerlink\" title=\"chrome插件\"></a>chrome插件</h2><hr>\n<p>github访问：octotree</p>\n<p>下载管理器：chrono</p>\n<p>markdown: markdown here</p>\n<p>翻译: Google翻译</p>\n<p>ssh: secure shell</p>\n<h2 id=\"移动端-Android\"><a href=\"#移动端-Android\" class=\"headerlink\" title=\"移动端(Android)\"></a>移动端(Android)</h2><hr>\n<p>ssh客户端 : JuiceSSH</p>\n<p>翻译 : Google翻译</p>\n<p>GitHub : OctoDroid</p>\n<p>笔记 ：印象笔记</p>\n<p>记账 : 口袋记账</p>\n<h2 id=\"其他工具\"><a href=\"#其他工具\" class=\"headerlink\" title=\"其他工具\"></a>其他工具</h2><hr>\n<p>版本控制工具 : <a href=\"https://git-scm.com/book/zh/v2\" target=\"_blank\" rel=\"external\">git</a> git客户端<a href=\"https://www.sourcetreeapp.com/\" target=\"_blank\" rel=\"external\">sourcetree</a></p>\n<p>ssh客户端 : <a href=\"http://mobaxterm.mobatek.net/download.html\" target=\"_blank\" rel=\"external\">MobaXterm</a></p>\n<p>diff 工具 : <a href=\"http://www.beyondcompare.cc/\" target=\"_blank\" rel=\"external\">beyond compare 3</a>    winmerge(生成csv格式对比结果)</p>\n<p>diff 在线对比 : <a href=\"https://www.diffchecker.com/\" target=\"_blank\" rel=\"external\">diffchecker</a></p>\n<p>抓包工具 : <a href=\"https://www.wireshark.org/\" target=\"_blank\" rel=\"external\">wireshark</a></p>\n<p>远程桌面 : teamviewer</p>\n<p>编辑器 : vscode notepad++(打开大文件)</p>\n<p>命令行浏览器 : curl(测试用的着)</p>\n<p>浏览器 : Chrome</p>\n<p>笔记工具 : 印象笔记(客户端) 印象笔记·剪藏(chrome插件)</p>\n<p>思维导图 : <a href=\"http://www.xmindchina.net/\" target=\"_blank\" rel=\"external\">XMind</a></p>\n<p>画图 : <a href=\"https://www.processon.com/\" target=\"_blank\" rel=\"external\">Processon</a></p>\n<p>微信公众号编辑器 : 135编辑器</p>\n<p>博客 : <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a> </p>\n<p>搜索(Windows) : Everything</p>\n<p>翻墙</p>\n<ul>\n<li><p>快速安全通道(chrome插件，免费，不稳定)</p>\n</li>\n<li><p><a href=\"https://github.com/XX-net/XX-Net\" target=\"_blank\" rel=\"external\">XX-Net</a></p>\n</li>\n<li><p>Shadowsocks(购买VPS搭建)</p>\n</li>\n</ul>\n<p><a href=\"https://www.zhihu.com/question/36546814\" target=\"_blank\" rel=\"external\">有哪些软件堪称「神器」，却不为大众所知？</a></p>\n<h2 id=\"网站资源\"><a href=\"#网站资源\" class=\"headerlink\" title=\"网站资源\"></a>网站资源</h2><hr>\n<p><a href=\"https://pixabay.com/\" target=\"_blank\" rel=\"external\">免费图片</a>: 免费图片</p>\n<p><a href=\"www.github.com\">github</a>: 源代码</p>\n<p><a href=\"http://grepcode.com/\" target=\"_blank\" rel=\"external\">grepcode</a>: 源码搜索</p>\n<p><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"external\">stackoverflow</a>: 代码问题解决</p>\n<p><a href=\"http://www.vogella.com\" target=\"_blank\" rel=\"external\">vogella</a>: Eclipse Rcp》</p>\n<p><a href=\"https://www.ibm.com\" target=\"_blank\" rel=\"external\">developerworks</a>: java学习</p>\n<p><a href=\"http://www.uml.org.cn\" target=\"_blank\" rel=\"external\">uml.org.cn</a>: java 学习</p>\n<p><a href=\"http://www.importnew.com/\" target=\"_blank\" rel=\"external\">importnew</a>: java学习</p>\n<p><a href=\"https://developers.google.cn/\" target=\"_blank\" rel=\"external\">Google Developers</a>: Google Developers</p>\n<p><a href=\"https://git-scm.com/book/zh/v2\" target=\"_blank\" rel=\"external\">Git Book</a>: Git学习</p>\n<p><a href=\"http://design-patterns.readthedocs.io/zh_CN/latest/index.html\" target=\"_blank\" rel=\"external\">图说设计模式</a>: 设计模式</p>\n","excerpt":"","more":"<h2 id=\"java开发\"><a href=\"#java开发\" class=\"headerlink\" title=\"java开发\"></a>java开发</h2><hr>\n<p>java IDE : Eclipse(常用) IDEA</p>\n<p>java 覆盖率测试 : <a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jacoco/\">jaCoCo</a></p>\n<p>java 单元测试 : junit</p>\n<p>java 构建工具 : Maven(常用) Gradle</p>\n<p>java 性能监控 : Jprofiler Jconsole</p>\n<p>uml : plantuml</p>\n<h2 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h2><hr>\n<p>OS : Centos 7</p>\n<p>命令行目录跳转：autojump</p>\n<p>命令行错误修复: <a href=\"https://github.com/nvbn/thefuck\">thefuck</a></p>\n<h2 id=\"chrome插件\"><a href=\"#chrome插件\" class=\"headerlink\" title=\"chrome插件\"></a>chrome插件</h2><hr>\n<p>github访问：octotree</p>\n<p>下载管理器：chrono</p>\n<p>markdown: markdown here</p>\n<p>翻译: Google翻译</p>\n<p>ssh: secure shell</p>\n<h2 id=\"移动端-Android\"><a href=\"#移动端-Android\" class=\"headerlink\" title=\"移动端(Android)\"></a>移动端(Android)</h2><hr>\n<p>ssh客户端 : JuiceSSH</p>\n<p>翻译 : Google翻译</p>\n<p>GitHub : OctoDroid</p>\n<p>笔记 ：印象笔记</p>\n<p>记账 : 口袋记账</p>\n<h2 id=\"其他工具\"><a href=\"#其他工具\" class=\"headerlink\" title=\"其他工具\"></a>其他工具</h2><hr>\n<p>版本控制工具 : <a href=\"https://git-scm.com/book/zh/v2\">git</a> git客户端<a href=\"https://www.sourcetreeapp.com/\">sourcetree</a></p>\n<p>ssh客户端 : <a href=\"http://mobaxterm.mobatek.net/download.html\">MobaXterm</a></p>\n<p>diff 工具 : <a href=\"http://www.beyondcompare.cc/\">beyond compare 3</a>    winmerge(生成csv格式对比结果)</p>\n<p>diff 在线对比 : <a href=\"https://www.diffchecker.com/\">diffchecker</a></p>\n<p>抓包工具 : <a href=\"https://www.wireshark.org/\">wireshark</a></p>\n<p>远程桌面 : teamviewer</p>\n<p>编辑器 : vscode notepad++(打开大文件)</p>\n<p>命令行浏览器 : curl(测试用的着)</p>\n<p>浏览器 : Chrome</p>\n<p>笔记工具 : 印象笔记(客户端) 印象笔记·剪藏(chrome插件)</p>\n<p>思维导图 : <a href=\"http://www.xmindchina.net/\">XMind</a></p>\n<p>画图 : <a href=\"https://www.processon.com/\">Processon</a></p>\n<p>微信公众号编辑器 : 135编辑器</p>\n<p>博客 : <a href=\"https://hexo.io/\">Hexo</a> </p>\n<p>搜索(Windows) : Everything</p>\n<p>翻墙</p>\n<ul>\n<li><p>快速安全通道(chrome插件，免费，不稳定)</p>\n</li>\n<li><p><a href=\"https://github.com/XX-net/XX-Net\">XX-Net</a></p>\n</li>\n<li><p>Shadowsocks(购买VPS搭建)</p>\n</li>\n</ul>\n<p><a href=\"https://www.zhihu.com/question/36546814\">有哪些软件堪称「神器」，却不为大众所知？</a></p>\n<h2 id=\"网站资源\"><a href=\"#网站资源\" class=\"headerlink\" title=\"网站资源\"></a>网站资源</h2><hr>\n<p><a href=\"https://pixabay.com/\">免费图片</a>: 免费图片</p>\n<p><a href=\"www.github.com\">github</a>: 源代码</p>\n<p><a href=\"http://grepcode.com/\">grepcode</a>: 源码搜索</p>\n<p><a href=\"https://stackoverflow.com/\">stackoverflow</a>: 代码问题解决</p>\n<p><a href=\"http://www.vogella.com\">vogella</a>: Eclipse Rcp》</p>\n<p><a href=\"https://www.ibm.com\">developerworks</a>: java学习</p>\n<p><a href=\"http://www.uml.org.cn\">uml.org.cn</a>: java 学习</p>\n<p><a href=\"http://www.importnew.com/\">importnew</a>: java学习</p>\n<p><a href=\"https://developers.google.cn/\">Google Developers</a>: Google Developers</p>\n<p><a href=\"https://git-scm.com/book/zh/v2\">Git Book</a>: Git学习</p>\n<p><a href=\"http://design-patterns.readthedocs.io/zh_CN/latest/index.html\">图说设计模式</a>: 设计模式</p>\n"}],"Post":[{"layout":"post","title":"Linux的五个查找命令","date":"2017-02-26T01:17:33.000Z","_content":"> 最近一直在读[阮一峰老师的博客](http://www.ruanyifeng.com),今天读到一篇介绍Linux查找命令的文章。恰好最近在学习linux，所以转载过来，当作一篇备忘录。\n\n> 原文链接：[Linux的五个查找命令](http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html)\n\n使用电脑的时候，经常需要查找文件。\n\n在Linux中，有很多方法可以做到这一点。国外网站LinuxHaxor总结了五条命令，你可以看看自己知道几条。大多数程序员，可能经常使用其中的2到3条，对这5条命令都很熟悉的人应该是不多的。\n\n## find \n\nfind是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。\n\nfind的使用格式如下：\n```\n　　$ find <指定目录> <指定条件> <指定动作>\n　　- <指定目录>： 所要搜索的目录及其所有子目录。默认为当前目录。\n　　- <指定条件>： 所要搜索的文件的特征。\n　　- <指定动作>： 对搜索结果进行特定的处理。\n```\n如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。\n\nfind的使用实例：\n```\n　　$ find . -name 'my*'\n搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。\n　　$ find . -name 'my*' -ls\n搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。\n　　$ find . -type f -mmin -10\n搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。\n```\n<!-- more -->\n## locate\n\nlocate命令其实是\"find -name\"的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。\n\nlocate命令的使用实例：\n```\n　　$ locate /etc/sh\n搜索etc目录下所有以sh开头的文件。\n　　$ locate ~/m\n搜索用户主目录下，所有以m开头的文件。\n　　$ locate -i ~/m\n搜索用户主目录下，所有以m开头的文件，并且忽略大小写。\n```\n\n## whereis\n\nwhereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。\n\nwhereis命令的使用实例：\n```\n　　$ whereis grep\n```\n\n## which\n\nwhich命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n\nwhich命令的使用实例：\n```\n　　$ which grep\n```\n\n## type\n\ntype命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。\n\ntype命令的使用实例：\n```\n　　$ type cd\n系统会提示，cd是shell的自带命令（build-in）。\n　　$ type grep\n系统会提示，grep是一个外部命令，并显示该命令的路径。\n　　$ type -p grep\n加上-p参数后，就相当于which命令。\n```","source":"_posts/Linux的五个查找命令.md","raw":"---\nlayout: post\ntitle: Linux的五个查找命令\ndate: 2017-02-26 09:17:33\ncategories: 工具\ntags: linux\n---\n> 最近一直在读[阮一峰老师的博客](http://www.ruanyifeng.com),今天读到一篇介绍Linux查找命令的文章。恰好最近在学习linux，所以转载过来，当作一篇备忘录。\n\n> 原文链接：[Linux的五个查找命令](http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html)\n\n使用电脑的时候，经常需要查找文件。\n\n在Linux中，有很多方法可以做到这一点。国外网站LinuxHaxor总结了五条命令，你可以看看自己知道几条。大多数程序员，可能经常使用其中的2到3条，对这5条命令都很熟悉的人应该是不多的。\n\n## find \n\nfind是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。\n\nfind的使用格式如下：\n```\n　　$ find <指定目录> <指定条件> <指定动作>\n　　- <指定目录>： 所要搜索的目录及其所有子目录。默认为当前目录。\n　　- <指定条件>： 所要搜索的文件的特征。\n　　- <指定动作>： 对搜索结果进行特定的处理。\n```\n如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。\n\nfind的使用实例：\n```\n　　$ find . -name 'my*'\n搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。\n　　$ find . -name 'my*' -ls\n搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。\n　　$ find . -type f -mmin -10\n搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。\n```\n<!-- more -->\n## locate\n\nlocate命令其实是\"find -name\"的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。\n\nlocate命令的使用实例：\n```\n　　$ locate /etc/sh\n搜索etc目录下所有以sh开头的文件。\n　　$ locate ~/m\n搜索用户主目录下，所有以m开头的文件。\n　　$ locate -i ~/m\n搜索用户主目录下，所有以m开头的文件，并且忽略大小写。\n```\n\n## whereis\n\nwhereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。\n\nwhereis命令的使用实例：\n```\n　　$ whereis grep\n```\n\n## which\n\nwhich命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n\nwhich命令的使用实例：\n```\n　　$ which grep\n```\n\n## type\n\ntype命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。\n\ntype命令的使用实例：\n```\n　　$ type cd\n系统会提示，cd是shell的自带命令（build-in）。\n　　$ type grep\n系统会提示，grep是一个外部命令，并显示该命令的路径。\n　　$ type -p grep\n加上-p参数后，就相当于which命令。\n```","slug":"Linux的五个查找命令","published":1,"updated":"2017-04-11T13:08:38.834Z","comments":1,"photos":[],"link":"","_id":"cj4vch4c40000x3gchkvgw2bl","content":"<blockquote>\n<p>最近一直在读<a href=\"http://www.ruanyifeng.com\" target=\"_blank\" rel=\"external\">阮一峰老师的博客</a>,今天读到一篇介绍Linux查找命令的文章。恰好最近在学习linux，所以转载过来，当作一篇备忘录。</p>\n<p>原文链接：<a href=\"http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html\" target=\"_blank\" rel=\"external\">Linux的五个查找命令</a></p>\n</blockquote>\n<p>使用电脑的时候，经常需要查找文件。</p>\n<p>在Linux中，有很多方法可以做到这一点。国外网站LinuxHaxor总结了五条命令，你可以看看自己知道几条。大多数程序员，可能经常使用其中的2到3条，对这5条命令都很熟悉的人应该是不多的。</p>\n<h2 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h2><p>find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。</p>\n<p>find的使用格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</div><div class=\"line\">　　- &lt;指定目录&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。</div><div class=\"line\">　　- &lt;指定条件&gt;： 所要搜索的文件的特征。</div><div class=\"line\">　　- &lt;指定动作&gt;： 对搜索结果进行特定的处理。</div></pre></td></tr></table></figure></p>\n<p>如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p>\n<p>find的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ find . -name &apos;my*&apos;</div><div class=\"line\">搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。</div><div class=\"line\">　　$ find . -name &apos;my*&apos; -ls</div><div class=\"line\">搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。</div><div class=\"line\">　　$ find . -type f -mmin -10</div><div class=\"line\">搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"locate\"><a href=\"#locate\" class=\"headerlink\" title=\"locate\"></a>locate</h2><p>locate命令其实是”find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</p>\n<p>locate命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ locate /etc/sh</div><div class=\"line\">搜索etc目录下所有以sh开头的文件。</div><div class=\"line\">　　$ locate ~/m</div><div class=\"line\">搜索用户主目录下，所有以m开头的文件。</div><div class=\"line\">　　$ locate -i ~/m</div><div class=\"line\">搜索用户主目录下，所有以m开头的文件，并且忽略大小写。</div></pre></td></tr></table></figure></p>\n<h2 id=\"whereis\"><a href=\"#whereis\" class=\"headerlink\" title=\"whereis\"></a>whereis</h2><p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>\n<p>whereis命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ whereis grep</div></pre></td></tr></table></figure></p>\n<h2 id=\"which\"><a href=\"#which\" class=\"headerlink\" title=\"which\"></a>which</h2><p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>\n<p>which命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ which grep</div></pre></td></tr></table></figure></p>\n<h2 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h2><p>type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。</p>\n<p>type命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ type cd</div><div class=\"line\">系统会提示，cd是shell的自带命令（build-in）。</div><div class=\"line\">　　$ type grep</div><div class=\"line\">系统会提示，grep是一个外部命令，并显示该命令的路径。</div><div class=\"line\">　　$ type -p grep</div><div class=\"line\">加上-p参数后，就相当于which命令。</div></pre></td></tr></table></figure></p>\n","excerpt":"<blockquote>\n<p>最近一直在读<a href=\"http://www.ruanyifeng.com\">阮一峰老师的博客</a>,今天读到一篇介绍Linux查找命令的文章。恰好最近在学习linux，所以转载过来，当作一篇备忘录。</p>\n<p>原文链接：<a href=\"http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html\">Linux的五个查找命令</a></p>\n</blockquote>\n<p>使用电脑的时候，经常需要查找文件。</p>\n<p>在Linux中，有很多方法可以做到这一点。国外网站LinuxHaxor总结了五条命令，你可以看看自己知道几条。大多数程序员，可能经常使用其中的2到3条，对这5条命令都很熟悉的人应该是不多的。</p>\n<h2 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h2><p>find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。</p>\n<p>find的使用格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</div><div class=\"line\">　　- &lt;指定目录&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。</div><div class=\"line\">　　- &lt;指定条件&gt;： 所要搜索的文件的特征。</div><div class=\"line\">　　- &lt;指定动作&gt;： 对搜索结果进行特定的处理。</div></pre></td></tr></table></figure></p>\n<p>如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p>\n<p>find的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ find . -name &apos;my*&apos;</div><div class=\"line\">搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。</div><div class=\"line\">　　$ find . -name &apos;my*&apos; -ls</div><div class=\"line\">搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。</div><div class=\"line\">　　$ find . -type f -mmin -10</div><div class=\"line\">搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。</div></pre></td></tr></table></figure></p>","more":"<h2 id=\"locate\"><a href=\"#locate\" class=\"headerlink\" title=\"locate\"></a>locate</h2><p>locate命令其实是”find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</p>\n<p>locate命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ locate /etc/sh</div><div class=\"line\">搜索etc目录下所有以sh开头的文件。</div><div class=\"line\">　　$ locate ~/m</div><div class=\"line\">搜索用户主目录下，所有以m开头的文件。</div><div class=\"line\">　　$ locate -i ~/m</div><div class=\"line\">搜索用户主目录下，所有以m开头的文件，并且忽略大小写。</div></pre></td></tr></table></figure></p>\n<h2 id=\"whereis\"><a href=\"#whereis\" class=\"headerlink\" title=\"whereis\"></a>whereis</h2><p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>\n<p>whereis命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ whereis grep</div></pre></td></tr></table></figure></p>\n<h2 id=\"which\"><a href=\"#which\" class=\"headerlink\" title=\"which\"></a>which</h2><p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>\n<p>which命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ which grep</div></pre></td></tr></table></figure></p>\n<h2 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h2><p>type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。</p>\n<p>type命令的使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　$ type cd</div><div class=\"line\">系统会提示，cd是shell的自带命令（build-in）。</div><div class=\"line\">　　$ type grep</div><div class=\"line\">系统会提示，grep是一个外部命令，并显示该命令的路径。</div><div class=\"line\">　　$ type -p grep</div><div class=\"line\">加上-p参数后，就相当于which命令。</div></pre></td></tr></table></figure></p>"},{"layout":"post","title":"Java-NIO-MappedByteBuffer","date":"2017-07-03T23:56:08.000Z","_content":"> java nio 学习第二篇--内存映射文件\n\n## 内核空间与用户空间\n\nKernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。\n\n内核空间中存放的是内核代码和数据。内核空间是操作系统所在区域。内核代码有特别的权力：它能与设备控制器通讯，控制着用户区域进程的运行状态，等等。最重要的是，所有 I/O 都直接或间接通过内核空间。\n\n用户空间是常规进程所在区域，进程的用户空间中存放的是用户程序的代码和数据。\n\nLinux使用两级保护机制：0级供内核使用，3级供用户程序使用。\n\n当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行，CPU可执行任何指令。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。\n\n32位Linux的虚拟地址空间为0～4G。Linux内核将这4G字节的空间分为两部分。将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间）。每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的。最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。\n\n```java\nstr = \"my string\" // 用户空间\nx = x + 2\nfile.write(str) // 切换到内核空间\n \ny = x + 4 // 切换回用户空间\n```\n\n<!-- more -->\n\n上面代码中，第一行和第二行都是简单的赋值运算，在 User space 执行。第三行需要写入文件，就要切换到 Kernel space，因为用户不能直接写文件，必须通过内核安排。第四行又是赋值运算，就切换回 User space。\n\n## 分页存储\n\n操作系统在运行程序时，需要为每一个进程分配内存。比如A进程需要200m，B进程需要300m，c进程需要100m。那么操作系统应该如何为他们分配这些内存呢？\n\n一种想法是直接分配连续的内存。操作系统维护一个内存列表，每次申请内存时就去这个列表中寻找合适的连续内存块，分配给用户进程。这样会带来一个问题，那就是内存碎片化。由于程序申请内存的大小是不规律的，在经过多次分配之后，内存空间就会变得零碎，产生很多不连续的小的内存碎片，这些碎片无法被程序使用(因为碎片化的内存不是连续的，也不够大)。\n\n可以通过‘紧凑’的方法将这些碎片拼接成可用的大块内存空间，但是必须要付出很大的开销。因此产生了离散化的分配方式：允许直接将一个紧凑直接分散的装入到许多不相邻的内存块当中。就可以充分的利用内存空间。\n\n离散分配其中之一的分配方式就是分页：将用户程序的地址空间分为若干个固定大小的区域，称为页。比如，每个页为1kb。相应的将内存空间也分为若干个物理块，和页的大小相同。这样就可以将用户程序的任一页放入任一物理块当中，实现了离散分配。\n\n在分页系统中，允许将进程的各个页离散的存储在内存的任一物理块当中，为了保证进程能够正确运行，即能够在内存中找到每个页面所对应的物理块，系统为每一个进程建立了一张页面映像表，简称页表。在进程地址空间内的所有页，依次在页表中有一页表项，其中记录了相应页在内存中的物理块号。\n\n{% asset_img 页表.jpg 页表 %}\n\n在配置了页表之后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。\n\n## 虚拟内存\n\n所有现代操作系统都使用虚拟内存。虚拟内存意为使用虚假(或虚拟)地址取代物理(硬件RAM)内存地址。这样做好处颇多，总结起来可分为两大类： \n\n1. 一个以上的虚拟地址可指向同一个物理内存地址。 \n\n2. 虚拟内存空间可大于实际可用的硬件内存。\n\n那么，这是如何做到的呢？\n\n我们会同时运行多个进程，而每个进程占用的内存大小不固定，但是这些进程所需要的内存大小加起来却会超过我们实际的物理内存(比如4g内存)，用户感觉到的内存容量会比实际内存容量大的多。这是因为：\n\n应用程序在运行之前没有必要将之全部装入内存，而仅需将那些当前要运行的少数页面装入内存便可运行，其余部分暂留在磁盘上。程序在运行时，如果他要访问的页已经调入内存，便可继续执行下去；但如果程序所要访问的页面尚未调入内存(缺页)，便发出缺页请求(页错误)，此时操作系统将利用请求调页功能将他们调入内存，以便程序能够继续执行下去。如果此时内存已满，无法再装入新的页，操作系统还需再利用页的置换功能，将内存中暂时不用的页调到磁盘上，腾出足够的内存空间后，再将要访问的页调入内存，使程序继续执行下去。这样，可以使一个或多个大的用户程序在较小的内存空间中运行。\n\n联想一下Linux系统在硬盘分区时需要让我们选择一个swap分区，结合上面的知识，可知这个swap分区就是上面置换时提到的磁盘。摘抄一段百度百科对[swap](http://baike.baidu.com/item/Swap%E5%88%86%E5%8C%BA)的定义：\n\n> Swap分区在系统的物理内存不够用的时候，把硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。\n\n因此，虚拟内存的实现利用了上面提到的分页存储的方法，同时，需要存储系统需要增加页面置换和页面调度功能。\n\n我们知道页表的基本作用就是将用户地址空间中的逻辑地址映射为内存空间中的物理地址，为了满足页面的换进换出功能，在页表中增加几个字段：\n\n{% asset_img 页表1.png 页表 %}\n\n对上面字段的解释：\n\n1. 状态位P: 由于在请求分页系统中，只将应用程序的一部分调入内存，还有一部分在磁盘上，所以需要在页表中增加一个存在位字段，指示该夜是否已调入内存，供应用程序参考。\n\n2. 访问字段A：用于记录本页在一段时间内的访问次数，或已有多长时间未被访问，提供给置换算法在选择换出页面时参考。\n\n3. 修改位M：标识该页在调入内存后是否被修改过。由于内存中的每一页都在外存上保留一个副本，因此，在置换该页时，若未被修改，就不需要将该页再写回到外存，减少磁盘交互的次数；若已被修改，则必须将该页重写到外存上，保证外存中所保留的副本是最新的。\n\n4. 外存地址：指出该页在外存上的地址，通常是物理块号，供调入该页时参考。\n\n回想一下，在前面 ***内核空间与用户空间* 这一节当中，提到了 Linux的虚拟地址空间为0～4G，从0x00000000到0xFFFFFFFF。这里的虚拟地址，经过MMU的转换，可以映射为物理页号。每一个进程都维护自己的虚拟地址，从虚拟地址中分配内存，实际上底层将这些虚拟地址，通过查询页表映射到物理块号，然后进行相应的置换或者读入。实际上，是所有的进程共享这些物理内存，此时的物理内存相当于一个池(联想 线程池？)。\n\n{% asset_img 虚拟内存.png 虚拟内存 %}\n\n## IO原理\n\n有了上面的基础，我们再来看一下操作系统中的IO：\n\n{% asset_img io.png IO %}\n\n进程使用read()系统调用，要求其缓冲区被填满。内核随即向磁盘控制硬件发出命令，要求其从磁盘读取数据。磁盘控制器把数据直接写入内核内存缓冲区，这一步通过 DMA 完成，无需主CPU协助。一旦磁盘控制器把缓冲区装满，内核即把数据从内核空间的临时缓冲区拷贝到进程执行read()调用时指定的缓冲区。\n\n我们可能会觉得，把数据从内核空间拷贝到用户空间似乎有些多余。为什么不直接让磁盘控制器把数据送到用户空间的缓冲区呢？这样做有几个问题。首先，硬件通常不能直接访问用户空间。其次，像磁盘这样基于块存储的硬件设备操作的是固定大小的数据块，而用户进程请求的可能是任意大小的或非对齐的数据块。在数据往来于用户空间与存储设备的过程中，内核负责数据的分解、再组合工作，因此充当着中间人的角色。\n\n采用分页技术的**操作系统**执行 I/O 的全过程可总结为以下几步：\n\n1. 确定请求的数据分布在文件系统的哪些页(磁盘扇区组)。磁盘上的文件内容和元数据可能跨越多个文件系统页，而且这些页可能也不连续。\n\n2. 在内核空间分配足够数量的内存页，以容纳得到确定的文件系统页。\n\n3. 在内存页与磁盘上的文件系统页之间建立映射。\n\n4. 为每一个内存页产生页错误。\n\n5. 虚拟内存系统俘获页错误，安排页面调入，从磁盘上读取页内容，使页有效。\n\n6. 一旦页面调入操作完成，文件系统即对原始数据进行解析，取得所需文件内容或属性信息。\n\n## 内存映射文件\n\n传统的文件 I/O 是通过用户进程发布read()和write()系统调用来传输数据的。比如`FileInputStream.read(byte b[])`，实际上是调用了read()系统调用完成数据的读取。回想[上一篇文章](http://yukai.space/2017/06/28/java-NIO-Buffer/)，`FileInputStream.read(byte b[])`会造成几次数据拷贝呢？\n\n1. 从磁盘到内核缓冲区的拷贝\n\n2. 内核缓冲区到JVM进程直接缓冲区的拷贝\n\n3. JVM直接缓冲区到`FileInputStream.read(byte b[])`中byte数组b指向的堆内存的拷贝\n\n可见，传统的IO要经历至少三次数据拷贝才可以把数据读出来，即使是使用直接缓冲区DirectBuffer，也需要至少两次拷贝过程。\n\n我们知道，设备控制器不能通过 DMA 直接存储到用户空间，但是利用虚拟内存**一个以上的虚拟地址可指向同一个物理内存地址**这个特点，则可以把内核空间地址与用户空间的虚拟地址映射到同一个物理地址，这样，DMA 硬件(只能访问物理内存地址)就可以填充对内核与用户空间进程同时可见的缓冲区。\n\n{% asset_img 内存文件映射.png 内存文件映射 %}\n\n这样的话，就省去了内核与用户空间的往来拷贝，但前提条件是，内核与用户缓冲区必须使用相同的页对齐，缓冲区的大小还必须是磁盘控制器块大小的倍数。\n\n内存映射 I/O 使用文件系统建立从用户空间直到可用文件系统页的虚拟内存映射。这样做有几个好处：\n\n- 用户进程把文件数据当作内存，所以无需发布read()或write()系统调用。\n\n- 当用户进程碰触到映射内存空间，页错误会自动产生，从而将文件数据从磁盘读进内存。如果用户修改了映射内存空间，相关页会自动标记为脏，随后刷新到磁盘，文件得到更新。\n\n- 操作系统的虚拟内存子系统会对页进行智能高速缓存，自动根据系统负载进行内存管理。\n\n- 数据总是按页对齐的，无需执行缓冲区拷贝。\n\n- 大型文件使用映射，无需耗费大量内存，即可进行数据拷贝。\n\n## MappedByteBuffer\n\n了解了上面的内容，我们知道在操作系统和硬件层面实际上是为我们提供了内存映射文件这样的机制的。在java1.4之后，java也提供了对应的接口，可以让我们利用操作系统这一特性，提高文件读写性能，那就是MappedByteBuffer。\n\nMappedByteBuffer继承自ByteBuffer，MappedByteBuffer被abstract修饰，所以他不能被实例化。我们可以调用`FileChannel.map()`方法获取一个MappedByteBuffer：\n\n```\nFileInputStream inputStream = new FileInputStream(file);\nFileChannel channel = inputStream.getChannel();\nMappedByteBuffer map = channel.map(MapMode.READ_WRITE, 0, file.length());\n```\n\n这个MappedByteBuffer实际上是其子类DirectByteBuffer实例的引用。也就是说，我们获得的MappedByteBuffer实际上是DirectBuffer类型的缓冲区。也就是说，使用MappedByteBuffer并不会消耗Java虚拟机内存堆。\n\n```java\npublic abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {\n    // 这里仅列出部分API\n    public abstract MappedByteBuffer map(MapMode mode, long position, long size)\n    public static class MapMode\n    {\n        public static final MapMode READ_ONLY\n        public static final MapMode READ_WRITE\n        public static final MapMode PRIVATE\n    }\n}\n```\n\n我们可以创建一个MappedByteBuffer来代表一个文件中字节的某个子范围。例如，要映射100到299(包含299)位置的字节，可以使用下面的代码：`buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 100, 200);`\n\n如果要映射整个文件则使用：`buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());`\n\n文件映射可以是可写的或只读的。前两种映射模式MapMode.READ_ONLY和MapMode.READ_WRITE意义是很明显的，它们表示希望获取的映射只读还是允许修改映射的文件。请求的映射模式将受被调用map()方法的FileChannel对象的访问权限所限制。如果通道是以只读的权限打开的却请求MapMode.READ_WRITE模式，那么map()方法会抛出一个NonWritableChannelException异常；如果在一个没有读权限的通道上请求MapMode.READ_ONLY映射模式，那么将产生NonReadableChannelException异常。\n\n第三种模式MapMode.PRIVATE表示想要一个写时拷贝(copy-on-write)的映射。这意味着通过put()方法所做的任何修改都会导致产生一个私有的数据副本并且该副本中的数据只有MappedByteBuffer实例可以看到。该过程不会对底层文件做任何修改。尽管写时拷贝的映射可以防止底层文件被修改，但也必须以read/write权限来打开文件以建立MapMode.PRIVATE映射。只有这样，返回的MappedByteBuffer对象才能允许使用put()方法。\n\n一个映射一旦建立之后将保持有效，直到MappedByteBuffer对象被施以垃圾收集动作为止。关闭相关联的FileChannel不会破坏映射，只有丢弃缓冲区对象本身才会破坏该映射。\n\nMappedByteBuffer主要用在对大文件的读写或对实时性要求比较高的程序当中。\n\n> For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory.\n\n参考[java doc FileChannel.map](https://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html)\n\n## 参考\n\n[Java nio入门教程详解(三)](http://www.365mini.com/page/java-nio-course-3.htm)\n\n[Java nio入门教程详解(二十一)](http://www.365mini.com/page/java-nio-course-21.htm)\n\n《计算机操作系统(第四版)》 西安电子科技大学出版社","source":"_posts/Java-NIO-MappedByteBuffer.md","raw":"---\nlayout: post\ntitle: Java-NIO-MappedByteBuffer\ndate: 2017-07-04 07:56:08\ncategories: 编程\ntags: java\n---\n> java nio 学习第二篇--内存映射文件\n\n## 内核空间与用户空间\n\nKernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。\n\n内核空间中存放的是内核代码和数据。内核空间是操作系统所在区域。内核代码有特别的权力：它能与设备控制器通讯，控制着用户区域进程的运行状态，等等。最重要的是，所有 I/O 都直接或间接通过内核空间。\n\n用户空间是常规进程所在区域，进程的用户空间中存放的是用户程序的代码和数据。\n\nLinux使用两级保护机制：0级供内核使用，3级供用户程序使用。\n\n当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行，CPU可执行任何指令。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。\n\n32位Linux的虚拟地址空间为0～4G。Linux内核将这4G字节的空间分为两部分。将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间）。每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的。最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。\n\n```java\nstr = \"my string\" // 用户空间\nx = x + 2\nfile.write(str) // 切换到内核空间\n \ny = x + 4 // 切换回用户空间\n```\n\n<!-- more -->\n\n上面代码中，第一行和第二行都是简单的赋值运算，在 User space 执行。第三行需要写入文件，就要切换到 Kernel space，因为用户不能直接写文件，必须通过内核安排。第四行又是赋值运算，就切换回 User space。\n\n## 分页存储\n\n操作系统在运行程序时，需要为每一个进程分配内存。比如A进程需要200m，B进程需要300m，c进程需要100m。那么操作系统应该如何为他们分配这些内存呢？\n\n一种想法是直接分配连续的内存。操作系统维护一个内存列表，每次申请内存时就去这个列表中寻找合适的连续内存块，分配给用户进程。这样会带来一个问题，那就是内存碎片化。由于程序申请内存的大小是不规律的，在经过多次分配之后，内存空间就会变得零碎，产生很多不连续的小的内存碎片，这些碎片无法被程序使用(因为碎片化的内存不是连续的，也不够大)。\n\n可以通过‘紧凑’的方法将这些碎片拼接成可用的大块内存空间，但是必须要付出很大的开销。因此产生了离散化的分配方式：允许直接将一个紧凑直接分散的装入到许多不相邻的内存块当中。就可以充分的利用内存空间。\n\n离散分配其中之一的分配方式就是分页：将用户程序的地址空间分为若干个固定大小的区域，称为页。比如，每个页为1kb。相应的将内存空间也分为若干个物理块，和页的大小相同。这样就可以将用户程序的任一页放入任一物理块当中，实现了离散分配。\n\n在分页系统中，允许将进程的各个页离散的存储在内存的任一物理块当中，为了保证进程能够正确运行，即能够在内存中找到每个页面所对应的物理块，系统为每一个进程建立了一张页面映像表，简称页表。在进程地址空间内的所有页，依次在页表中有一页表项，其中记录了相应页在内存中的物理块号。\n\n{% asset_img 页表.jpg 页表 %}\n\n在配置了页表之后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。\n\n## 虚拟内存\n\n所有现代操作系统都使用虚拟内存。虚拟内存意为使用虚假(或虚拟)地址取代物理(硬件RAM)内存地址。这样做好处颇多，总结起来可分为两大类： \n\n1. 一个以上的虚拟地址可指向同一个物理内存地址。 \n\n2. 虚拟内存空间可大于实际可用的硬件内存。\n\n那么，这是如何做到的呢？\n\n我们会同时运行多个进程，而每个进程占用的内存大小不固定，但是这些进程所需要的内存大小加起来却会超过我们实际的物理内存(比如4g内存)，用户感觉到的内存容量会比实际内存容量大的多。这是因为：\n\n应用程序在运行之前没有必要将之全部装入内存，而仅需将那些当前要运行的少数页面装入内存便可运行，其余部分暂留在磁盘上。程序在运行时，如果他要访问的页已经调入内存，便可继续执行下去；但如果程序所要访问的页面尚未调入内存(缺页)，便发出缺页请求(页错误)，此时操作系统将利用请求调页功能将他们调入内存，以便程序能够继续执行下去。如果此时内存已满，无法再装入新的页，操作系统还需再利用页的置换功能，将内存中暂时不用的页调到磁盘上，腾出足够的内存空间后，再将要访问的页调入内存，使程序继续执行下去。这样，可以使一个或多个大的用户程序在较小的内存空间中运行。\n\n联想一下Linux系统在硬盘分区时需要让我们选择一个swap分区，结合上面的知识，可知这个swap分区就是上面置换时提到的磁盘。摘抄一段百度百科对[swap](http://baike.baidu.com/item/Swap%E5%88%86%E5%8C%BA)的定义：\n\n> Swap分区在系统的物理内存不够用的时候，把硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。\n\n因此，虚拟内存的实现利用了上面提到的分页存储的方法，同时，需要存储系统需要增加页面置换和页面调度功能。\n\n我们知道页表的基本作用就是将用户地址空间中的逻辑地址映射为内存空间中的物理地址，为了满足页面的换进换出功能，在页表中增加几个字段：\n\n{% asset_img 页表1.png 页表 %}\n\n对上面字段的解释：\n\n1. 状态位P: 由于在请求分页系统中，只将应用程序的一部分调入内存，还有一部分在磁盘上，所以需要在页表中增加一个存在位字段，指示该夜是否已调入内存，供应用程序参考。\n\n2. 访问字段A：用于记录本页在一段时间内的访问次数，或已有多长时间未被访问，提供给置换算法在选择换出页面时参考。\n\n3. 修改位M：标识该页在调入内存后是否被修改过。由于内存中的每一页都在外存上保留一个副本，因此，在置换该页时，若未被修改，就不需要将该页再写回到外存，减少磁盘交互的次数；若已被修改，则必须将该页重写到外存上，保证外存中所保留的副本是最新的。\n\n4. 外存地址：指出该页在外存上的地址，通常是物理块号，供调入该页时参考。\n\n回想一下，在前面 ***内核空间与用户空间* 这一节当中，提到了 Linux的虚拟地址空间为0～4G，从0x00000000到0xFFFFFFFF。这里的虚拟地址，经过MMU的转换，可以映射为物理页号。每一个进程都维护自己的虚拟地址，从虚拟地址中分配内存，实际上底层将这些虚拟地址，通过查询页表映射到物理块号，然后进行相应的置换或者读入。实际上，是所有的进程共享这些物理内存，此时的物理内存相当于一个池(联想 线程池？)。\n\n{% asset_img 虚拟内存.png 虚拟内存 %}\n\n## IO原理\n\n有了上面的基础，我们再来看一下操作系统中的IO：\n\n{% asset_img io.png IO %}\n\n进程使用read()系统调用，要求其缓冲区被填满。内核随即向磁盘控制硬件发出命令，要求其从磁盘读取数据。磁盘控制器把数据直接写入内核内存缓冲区，这一步通过 DMA 完成，无需主CPU协助。一旦磁盘控制器把缓冲区装满，内核即把数据从内核空间的临时缓冲区拷贝到进程执行read()调用时指定的缓冲区。\n\n我们可能会觉得，把数据从内核空间拷贝到用户空间似乎有些多余。为什么不直接让磁盘控制器把数据送到用户空间的缓冲区呢？这样做有几个问题。首先，硬件通常不能直接访问用户空间。其次，像磁盘这样基于块存储的硬件设备操作的是固定大小的数据块，而用户进程请求的可能是任意大小的或非对齐的数据块。在数据往来于用户空间与存储设备的过程中，内核负责数据的分解、再组合工作，因此充当着中间人的角色。\n\n采用分页技术的**操作系统**执行 I/O 的全过程可总结为以下几步：\n\n1. 确定请求的数据分布在文件系统的哪些页(磁盘扇区组)。磁盘上的文件内容和元数据可能跨越多个文件系统页，而且这些页可能也不连续。\n\n2. 在内核空间分配足够数量的内存页，以容纳得到确定的文件系统页。\n\n3. 在内存页与磁盘上的文件系统页之间建立映射。\n\n4. 为每一个内存页产生页错误。\n\n5. 虚拟内存系统俘获页错误，安排页面调入，从磁盘上读取页内容，使页有效。\n\n6. 一旦页面调入操作完成，文件系统即对原始数据进行解析，取得所需文件内容或属性信息。\n\n## 内存映射文件\n\n传统的文件 I/O 是通过用户进程发布read()和write()系统调用来传输数据的。比如`FileInputStream.read(byte b[])`，实际上是调用了read()系统调用完成数据的读取。回想[上一篇文章](http://yukai.space/2017/06/28/java-NIO-Buffer/)，`FileInputStream.read(byte b[])`会造成几次数据拷贝呢？\n\n1. 从磁盘到内核缓冲区的拷贝\n\n2. 内核缓冲区到JVM进程直接缓冲区的拷贝\n\n3. JVM直接缓冲区到`FileInputStream.read(byte b[])`中byte数组b指向的堆内存的拷贝\n\n可见，传统的IO要经历至少三次数据拷贝才可以把数据读出来，即使是使用直接缓冲区DirectBuffer，也需要至少两次拷贝过程。\n\n我们知道，设备控制器不能通过 DMA 直接存储到用户空间，但是利用虚拟内存**一个以上的虚拟地址可指向同一个物理内存地址**这个特点，则可以把内核空间地址与用户空间的虚拟地址映射到同一个物理地址，这样，DMA 硬件(只能访问物理内存地址)就可以填充对内核与用户空间进程同时可见的缓冲区。\n\n{% asset_img 内存文件映射.png 内存文件映射 %}\n\n这样的话，就省去了内核与用户空间的往来拷贝，但前提条件是，内核与用户缓冲区必须使用相同的页对齐，缓冲区的大小还必须是磁盘控制器块大小的倍数。\n\n内存映射 I/O 使用文件系统建立从用户空间直到可用文件系统页的虚拟内存映射。这样做有几个好处：\n\n- 用户进程把文件数据当作内存，所以无需发布read()或write()系统调用。\n\n- 当用户进程碰触到映射内存空间，页错误会自动产生，从而将文件数据从磁盘读进内存。如果用户修改了映射内存空间，相关页会自动标记为脏，随后刷新到磁盘，文件得到更新。\n\n- 操作系统的虚拟内存子系统会对页进行智能高速缓存，自动根据系统负载进行内存管理。\n\n- 数据总是按页对齐的，无需执行缓冲区拷贝。\n\n- 大型文件使用映射，无需耗费大量内存，即可进行数据拷贝。\n\n## MappedByteBuffer\n\n了解了上面的内容，我们知道在操作系统和硬件层面实际上是为我们提供了内存映射文件这样的机制的。在java1.4之后，java也提供了对应的接口，可以让我们利用操作系统这一特性，提高文件读写性能，那就是MappedByteBuffer。\n\nMappedByteBuffer继承自ByteBuffer，MappedByteBuffer被abstract修饰，所以他不能被实例化。我们可以调用`FileChannel.map()`方法获取一个MappedByteBuffer：\n\n```\nFileInputStream inputStream = new FileInputStream(file);\nFileChannel channel = inputStream.getChannel();\nMappedByteBuffer map = channel.map(MapMode.READ_WRITE, 0, file.length());\n```\n\n这个MappedByteBuffer实际上是其子类DirectByteBuffer实例的引用。也就是说，我们获得的MappedByteBuffer实际上是DirectBuffer类型的缓冲区。也就是说，使用MappedByteBuffer并不会消耗Java虚拟机内存堆。\n\n```java\npublic abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {\n    // 这里仅列出部分API\n    public abstract MappedByteBuffer map(MapMode mode, long position, long size)\n    public static class MapMode\n    {\n        public static final MapMode READ_ONLY\n        public static final MapMode READ_WRITE\n        public static final MapMode PRIVATE\n    }\n}\n```\n\n我们可以创建一个MappedByteBuffer来代表一个文件中字节的某个子范围。例如，要映射100到299(包含299)位置的字节，可以使用下面的代码：`buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 100, 200);`\n\n如果要映射整个文件则使用：`buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());`\n\n文件映射可以是可写的或只读的。前两种映射模式MapMode.READ_ONLY和MapMode.READ_WRITE意义是很明显的，它们表示希望获取的映射只读还是允许修改映射的文件。请求的映射模式将受被调用map()方法的FileChannel对象的访问权限所限制。如果通道是以只读的权限打开的却请求MapMode.READ_WRITE模式，那么map()方法会抛出一个NonWritableChannelException异常；如果在一个没有读权限的通道上请求MapMode.READ_ONLY映射模式，那么将产生NonReadableChannelException异常。\n\n第三种模式MapMode.PRIVATE表示想要一个写时拷贝(copy-on-write)的映射。这意味着通过put()方法所做的任何修改都会导致产生一个私有的数据副本并且该副本中的数据只有MappedByteBuffer实例可以看到。该过程不会对底层文件做任何修改。尽管写时拷贝的映射可以防止底层文件被修改，但也必须以read/write权限来打开文件以建立MapMode.PRIVATE映射。只有这样，返回的MappedByteBuffer对象才能允许使用put()方法。\n\n一个映射一旦建立之后将保持有效，直到MappedByteBuffer对象被施以垃圾收集动作为止。关闭相关联的FileChannel不会破坏映射，只有丢弃缓冲区对象本身才会破坏该映射。\n\nMappedByteBuffer主要用在对大文件的读写或对实时性要求比较高的程序当中。\n\n> For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory.\n\n参考[java doc FileChannel.map](https://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html)\n\n## 参考\n\n[Java nio入门教程详解(三)](http://www.365mini.com/page/java-nio-course-3.htm)\n\n[Java nio入门教程详解(二十一)](http://www.365mini.com/page/java-nio-course-21.htm)\n\n《计算机操作系统(第四版)》 西安电子科技大学出版社","slug":"Java-NIO-MappedByteBuffer","published":1,"updated":"2017-07-04T00:00:44.523Z","comments":1,"photos":[],"link":"","_id":"cj4vch4ce0002x3gc2nw17j6i","content":"<blockquote>\n<p>java nio 学习第二篇–内存映射文件</p>\n</blockquote>\n<h2 id=\"内核空间与用户空间\"><a href=\"#内核空间与用户空间\" class=\"headerlink\" title=\"内核空间与用户空间\"></a>内核空间与用户空间</h2><p>Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p>\n<p>内核空间中存放的是内核代码和数据。内核空间是操作系统所在区域。内核代码有特别的权力：它能与设备控制器通讯，控制着用户区域进程的运行状态，等等。最重要的是，所有 I/O 都直接或间接通过内核空间。</p>\n<p>用户空间是常规进程所在区域，进程的用户空间中存放的是用户程序的代码和数据。</p>\n<p>Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。</p>\n<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行，CPU可执行任何指令。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。</p>\n<p>32位Linux的虚拟地址空间为0～4G。Linux内核将这4G字节的空间分为两部分。将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间）。每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的。最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">str = <span class=\"string\">\"my string\"</span> <span class=\"comment\">// 用户空间</span></div><div class=\"line\">x = x + <span class=\"number\">2</span></div><div class=\"line\">file.write(str) <span class=\"comment\">// 切换到内核空间</span></div><div class=\"line\"> </div><div class=\"line\">y = x + <span class=\"number\">4</span> <span class=\"comment\">// 切换回用户空间</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>上面代码中，第一行和第二行都是简单的赋值运算，在 User space 执行。第三行需要写入文件，就要切换到 Kernel space，因为用户不能直接写文件，必须通过内核安排。第四行又是赋值运算，就切换回 User space。</p>\n<h2 id=\"分页存储\"><a href=\"#分页存储\" class=\"headerlink\" title=\"分页存储\"></a>分页存储</h2><p>操作系统在运行程序时，需要为每一个进程分配内存。比如A进程需要200m，B进程需要300m，c进程需要100m。那么操作系统应该如何为他们分配这些内存呢？</p>\n<p>一种想法是直接分配连续的内存。操作系统维护一个内存列表，每次申请内存时就去这个列表中寻找合适的连续内存块，分配给用户进程。这样会带来一个问题，那就是内存碎片化。由于程序申请内存的大小是不规律的，在经过多次分配之后，内存空间就会变得零碎，产生很多不连续的小的内存碎片，这些碎片无法被程序使用(因为碎片化的内存不是连续的，也不够大)。</p>\n<p>可以通过‘紧凑’的方法将这些碎片拼接成可用的大块内存空间，但是必须要付出很大的开销。因此产生了离散化的分配方式：允许直接将一个紧凑直接分散的装入到许多不相邻的内存块当中。就可以充分的利用内存空间。</p>\n<p>离散分配其中之一的分配方式就是分页：将用户程序的地址空间分为若干个固定大小的区域，称为页。比如，每个页为1kb。相应的将内存空间也分为若干个物理块，和页的大小相同。这样就可以将用户程序的任一页放入任一物理块当中，实现了离散分配。</p>\n<p>在分页系统中，允许将进程的各个页离散的存储在内存的任一物理块当中，为了保证进程能够正确运行，即能够在内存中找到每个页面所对应的物理块，系统为每一个进程建立了一张页面映像表，简称页表。在进程地址空间内的所有页，依次在页表中有一页表项，其中记录了相应页在内存中的物理块号。</p>\n<img src=\"/2017/07/04/Java-NIO-MappedByteBuffer/页表.jpg\" alt=\"页表\" title=\"页表\">\n<p>在配置了页表之后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。</p>\n<h2 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h2><p>所有现代操作系统都使用虚拟内存。虚拟内存意为使用虚假(或虚拟)地址取代物理(硬件RAM)内存地址。这样做好处颇多，总结起来可分为两大类： </p>\n<ol>\n<li><p>一个以上的虚拟地址可指向同一个物理内存地址。 </p>\n</li>\n<li><p>虚拟内存空间可大于实际可用的硬件内存。</p>\n</li>\n</ol>\n<p>那么，这是如何做到的呢？</p>\n<p>我们会同时运行多个进程，而每个进程占用的内存大小不固定，但是这些进程所需要的内存大小加起来却会超过我们实际的物理内存(比如4g内存)，用户感觉到的内存容量会比实际内存容量大的多。这是因为：</p>\n<p>应用程序在运行之前没有必要将之全部装入内存，而仅需将那些当前要运行的少数页面装入内存便可运行，其余部分暂留在磁盘上。程序在运行时，如果他要访问的页已经调入内存，便可继续执行下去；但如果程序所要访问的页面尚未调入内存(缺页)，便发出缺页请求(页错误)，此时操作系统将利用请求调页功能将他们调入内存，以便程序能够继续执行下去。如果此时内存已满，无法再装入新的页，操作系统还需再利用页的置换功能，将内存中暂时不用的页调到磁盘上，腾出足够的内存空间后，再将要访问的页调入内存，使程序继续执行下去。这样，可以使一个或多个大的用户程序在较小的内存空间中运行。</p>\n<p>联想一下Linux系统在硬盘分区时需要让我们选择一个swap分区，结合上面的知识，可知这个swap分区就是上面置换时提到的磁盘。摘抄一段百度百科对<a href=\"http://baike.baidu.com/item/Swap%E5%88%86%E5%8C%BA\" target=\"_blank\" rel=\"external\">swap</a>的定义：</p>\n<blockquote>\n<p>Swap分区在系统的物理内存不够用的时候，把硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。</p>\n</blockquote>\n<p>因此，虚拟内存的实现利用了上面提到的分页存储的方法，同时，需要存储系统需要增加页面置换和页面调度功能。</p>\n<p>我们知道页表的基本作用就是将用户地址空间中的逻辑地址映射为内存空间中的物理地址，为了满足页面的换进换出功能，在页表中增加几个字段：</p>\n<img src=\"/2017/07/04/Java-NIO-MappedByteBuffer/页表1.png\" alt=\"页表\" title=\"页表\">\n<p>对上面字段的解释：</p>\n<ol>\n<li><p>状态位P: 由于在请求分页系统中，只将应用程序的一部分调入内存，还有一部分在磁盘上，所以需要在页表中增加一个存在位字段，指示该夜是否已调入内存，供应用程序参考。</p>\n</li>\n<li><p>访问字段A：用于记录本页在一段时间内的访问次数，或已有多长时间未被访问，提供给置换算法在选择换出页面时参考。</p>\n</li>\n<li><p>修改位M：标识该页在调入内存后是否被修改过。由于内存中的每一页都在外存上保留一个副本，因此，在置换该页时，若未被修改，就不需要将该页再写回到外存，减少磁盘交互的次数；若已被修改，则必须将该页重写到外存上，保证外存中所保留的副本是最新的。</p>\n</li>\n<li><p>外存地址：指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</p>\n</li>\n</ol>\n<p>回想一下，在前面 <em>**内核空间与用户空间</em> 这一节当中，提到了 Linux的虚拟地址空间为0～4G，从0x00000000到0xFFFFFFFF。这里的虚拟地址，经过MMU的转换，可以映射为物理页号。每一个进程都维护自己的虚拟地址，从虚拟地址中分配内存，实际上底层将这些虚拟地址，通过查询页表映射到物理块号，然后进行相应的置换或者读入。实际上，是所有的进程共享这些物理内存，此时的物理内存相当于一个池(联想 线程池？)。</p>\n<img src=\"/2017/07/04/Java-NIO-MappedByteBuffer/虚拟内存.png\" alt=\"虚拟内存\" title=\"虚拟内存\">\n<h2 id=\"IO原理\"><a href=\"#IO原理\" class=\"headerlink\" title=\"IO原理\"></a>IO原理</h2><p>有了上面的基础，我们再来看一下操作系统中的IO：</p>\n<img src=\"/2017/07/04/Java-NIO-MappedByteBuffer/io.png\" alt=\"IO\" title=\"IO\">\n<p>进程使用read()系统调用，要求其缓冲区被填满。内核随即向磁盘控制硬件发出命令，要求其从磁盘读取数据。磁盘控制器把数据直接写入内核内存缓冲区，这一步通过 DMA 完成，无需主CPU协助。一旦磁盘控制器把缓冲区装满，内核即把数据从内核空间的临时缓冲区拷贝到进程执行read()调用时指定的缓冲区。</p>\n<p>我们可能会觉得，把数据从内核空间拷贝到用户空间似乎有些多余。为什么不直接让磁盘控制器把数据送到用户空间的缓冲区呢？这样做有几个问题。首先，硬件通常不能直接访问用户空间。其次，像磁盘这样基于块存储的硬件设备操作的是固定大小的数据块，而用户进程请求的可能是任意大小的或非对齐的数据块。在数据往来于用户空间与存储设备的过程中，内核负责数据的分解、再组合工作，因此充当着中间人的角色。</p>\n<p>采用分页技术的<strong>操作系统</strong>执行 I/O 的全过程可总结为以下几步：</p>\n<ol>\n<li><p>确定请求的数据分布在文件系统的哪些页(磁盘扇区组)。磁盘上的文件内容和元数据可能跨越多个文件系统页，而且这些页可能也不连续。</p>\n</li>\n<li><p>在内核空间分配足够数量的内存页，以容纳得到确定的文件系统页。</p>\n</li>\n<li><p>在内存页与磁盘上的文件系统页之间建立映射。</p>\n</li>\n<li><p>为每一个内存页产生页错误。</p>\n</li>\n<li><p>虚拟内存系统俘获页错误，安排页面调入，从磁盘上读取页内容，使页有效。</p>\n</li>\n<li><p>一旦页面调入操作完成，文件系统即对原始数据进行解析，取得所需文件内容或属性信息。</p>\n</li>\n</ol>\n<h2 id=\"内存映射文件\"><a href=\"#内存映射文件\" class=\"headerlink\" title=\"内存映射文件\"></a>内存映射文件</h2><p>传统的文件 I/O 是通过用户进程发布read()和write()系统调用来传输数据的。比如<code>FileInputStream.read(byte b[])</code>，实际上是调用了read()系统调用完成数据的读取。回想<a href=\"http://yukai.space/2017/06/28/java-NIO-Buffer/\">上一篇文章</a>，<code>FileInputStream.read(byte b[])</code>会造成几次数据拷贝呢？</p>\n<ol>\n<li><p>从磁盘到内核缓冲区的拷贝</p>\n</li>\n<li><p>内核缓冲区到JVM进程直接缓冲区的拷贝</p>\n</li>\n<li><p>JVM直接缓冲区到<code>FileInputStream.read(byte b[])</code>中byte数组b指向的堆内存的拷贝</p>\n</li>\n</ol>\n<p>可见，传统的IO要经历至少三次数据拷贝才可以把数据读出来，即使是使用直接缓冲区DirectBuffer，也需要至少两次拷贝过程。</p>\n<p>我们知道，设备控制器不能通过 DMA 直接存储到用户空间，但是利用虚拟内存<strong>一个以上的虚拟地址可指向同一个物理内存地址</strong>这个特点，则可以把内核空间地址与用户空间的虚拟地址映射到同一个物理地址，这样，DMA 硬件(只能访问物理内存地址)就可以填充对内核与用户空间进程同时可见的缓冲区。</p>\n<img src=\"/2017/07/04/Java-NIO-MappedByteBuffer/内存文件映射.png\" alt=\"内存文件映射\" title=\"内存文件映射\">\n<p>这样的话，就省去了内核与用户空间的往来拷贝，但前提条件是，内核与用户缓冲区必须使用相同的页对齐，缓冲区的大小还必须是磁盘控制器块大小的倍数。</p>\n<p>内存映射 I/O 使用文件系统建立从用户空间直到可用文件系统页的虚拟内存映射。这样做有几个好处：</p>\n<ul>\n<li><p>用户进程把文件数据当作内存，所以无需发布read()或write()系统调用。</p>\n</li>\n<li><p>当用户进程碰触到映射内存空间，页错误会自动产生，从而将文件数据从磁盘读进内存。如果用户修改了映射内存空间，相关页会自动标记为脏，随后刷新到磁盘，文件得到更新。</p>\n</li>\n<li><p>操作系统的虚拟内存子系统会对页进行智能高速缓存，自动根据系统负载进行内存管理。</p>\n</li>\n<li><p>数据总是按页对齐的，无需执行缓冲区拷贝。</p>\n</li>\n<li><p>大型文件使用映射，无需耗费大量内存，即可进行数据拷贝。</p>\n</li>\n</ul>\n<h2 id=\"MappedByteBuffer\"><a href=\"#MappedByteBuffer\" class=\"headerlink\" title=\"MappedByteBuffer\"></a>MappedByteBuffer</h2><p>了解了上面的内容，我们知道在操作系统和硬件层面实际上是为我们提供了内存映射文件这样的机制的。在java1.4之后，java也提供了对应的接口，可以让我们利用操作系统这一特性，提高文件读写性能，那就是MappedByteBuffer。</p>\n<p>MappedByteBuffer继承自ByteBuffer，MappedByteBuffer被abstract修饰，所以他不能被实例化。我们可以调用<code>FileChannel.map()</code>方法获取一个MappedByteBuffer：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">FileInputStream inputStream = new FileInputStream(file);</div><div class=\"line\">FileChannel channel = inputStream.getChannel();</div><div class=\"line\">MappedByteBuffer map = channel.map(MapMode.READ_WRITE, 0, file.length());</div></pre></td></tr></table></figure>\n<p>这个MappedByteBuffer实际上是其子类DirectByteBuffer实例的引用。也就是说，我们获得的MappedByteBuffer实际上是DirectBuffer类型的缓冲区。也就是说，使用MappedByteBuffer并不会消耗Java虚拟机内存堆。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractChannel</span> <span class=\"keyword\">implements</span> <span class=\"title\">ByteChannel</span>, <span class=\"title\">GatheringByteChannel</span>, <span class=\"title\">ScatteringByteChannel</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> MappedByteBuffer <span class=\"title\">map</span><span class=\"params\">(MapMode mode, <span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> size)</span></span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> class MapMode</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> MapMode READ_ONLY</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> MapMode READ_WRITE</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> MapMode PRIVATE</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以创建一个MappedByteBuffer来代表一个文件中字节的某个子范围。例如，要映射100到299(包含299)位置的字节，可以使用下面的代码：<code>buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 100, 200);</code></p>\n<p>如果要映射整个文件则使用：<code>buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());</code></p>\n<p>文件映射可以是可写的或只读的。前两种映射模式MapMode.READ_ONLY和MapMode.READ_WRITE意义是很明显的，它们表示希望获取的映射只读还是允许修改映射的文件。请求的映射模式将受被调用map()方法的FileChannel对象的访问权限所限制。如果通道是以只读的权限打开的却请求MapMode.READ_WRITE模式，那么map()方法会抛出一个NonWritableChannelException异常；如果在一个没有读权限的通道上请求MapMode.READ_ONLY映射模式，那么将产生NonReadableChannelException异常。</p>\n<p>第三种模式MapMode.PRIVATE表示想要一个写时拷贝(copy-on-write)的映射。这意味着通过put()方法所做的任何修改都会导致产生一个私有的数据副本并且该副本中的数据只有MappedByteBuffer实例可以看到。该过程不会对底层文件做任何修改。尽管写时拷贝的映射可以防止底层文件被修改，但也必须以read/write权限来打开文件以建立MapMode.PRIVATE映射。只有这样，返回的MappedByteBuffer对象才能允许使用put()方法。</p>\n<p>一个映射一旦建立之后将保持有效，直到MappedByteBuffer对象被施以垃圾收集动作为止。关闭相关联的FileChannel不会破坏映射，只有丢弃缓冲区对象本身才会破坏该映射。</p>\n<p>MappedByteBuffer主要用在对大文件的读写或对实时性要求比较高的程序当中。</p>\n<blockquote>\n<p>For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory.</p>\n</blockquote>\n<p>参考<a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html\" target=\"_blank\" rel=\"external\">java doc FileChannel.map</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.365mini.com/page/java-nio-course-3.htm\" target=\"_blank\" rel=\"external\">Java nio入门教程详解(三)</a></p>\n<p><a href=\"http://www.365mini.com/page/java-nio-course-21.htm\" target=\"_blank\" rel=\"external\">Java nio入门教程详解(二十一)</a></p>\n<p>《计算机操作系统(第四版)》 西安电子科技大学出版社</p>\n","excerpt":"<blockquote>\n<p>java nio 学习第二篇–内存映射文件</p>\n</blockquote>\n<h2 id=\"内核空间与用户空间\"><a href=\"#内核空间与用户空间\" class=\"headerlink\" title=\"内核空间与用户空间\"></a>内核空间与用户空间</h2><p>Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p>\n<p>内核空间中存放的是内核代码和数据。内核空间是操作系统所在区域。内核代码有特别的权力：它能与设备控制器通讯，控制着用户区域进程的运行状态，等等。最重要的是，所有 I/O 都直接或间接通过内核空间。</p>\n<p>用户空间是常规进程所在区域，进程的用户空间中存放的是用户程序的代码和数据。</p>\n<p>Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。</p>\n<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行，CPU可执行任何指令。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。</p>\n<p>32位Linux的虚拟地址空间为0～4G。Linux内核将这4G字节的空间分为两部分。将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间）。每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的。最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">str = <span class=\"string\">\"my string\"</span> <span class=\"comment\">// 用户空间</span></div><div class=\"line\">x = x + <span class=\"number\">2</span></div><div class=\"line\">file.write(str) <span class=\"comment\">// 切换到内核空间</span></div><div class=\"line\"> </div><div class=\"line\">y = x + <span class=\"number\">4</span> <span class=\"comment\">// 切换回用户空间</span></div></pre></td></tr></table></figure>","more":"<p>上面代码中，第一行和第二行都是简单的赋值运算，在 User space 执行。第三行需要写入文件，就要切换到 Kernel space，因为用户不能直接写文件，必须通过内核安排。第四行又是赋值运算，就切换回 User space。</p>\n<h2 id=\"分页存储\"><a href=\"#分页存储\" class=\"headerlink\" title=\"分页存储\"></a>分页存储</h2><p>操作系统在运行程序时，需要为每一个进程分配内存。比如A进程需要200m，B进程需要300m，c进程需要100m。那么操作系统应该如何为他们分配这些内存呢？</p>\n<p>一种想法是直接分配连续的内存。操作系统维护一个内存列表，每次申请内存时就去这个列表中寻找合适的连续内存块，分配给用户进程。这样会带来一个问题，那就是内存碎片化。由于程序申请内存的大小是不规律的，在经过多次分配之后，内存空间就会变得零碎，产生很多不连续的小的内存碎片，这些碎片无法被程序使用(因为碎片化的内存不是连续的，也不够大)。</p>\n<p>可以通过‘紧凑’的方法将这些碎片拼接成可用的大块内存空间，但是必须要付出很大的开销。因此产生了离散化的分配方式：允许直接将一个紧凑直接分散的装入到许多不相邻的内存块当中。就可以充分的利用内存空间。</p>\n<p>离散分配其中之一的分配方式就是分页：将用户程序的地址空间分为若干个固定大小的区域，称为页。比如，每个页为1kb。相应的将内存空间也分为若干个物理块，和页的大小相同。这样就可以将用户程序的任一页放入任一物理块当中，实现了离散分配。</p>\n<p>在分页系统中，允许将进程的各个页离散的存储在内存的任一物理块当中，为了保证进程能够正确运行，即能够在内存中找到每个页面所对应的物理块，系统为每一个进程建立了一张页面映像表，简称页表。在进程地址空间内的所有页，依次在页表中有一页表项，其中记录了相应页在内存中的物理块号。</p>\n<img src=\"/2017/07/04/Java-NIO-MappedByteBuffer/页表.jpg\" alt=\"页表\" title=\"页表\">\n<p>在配置了页表之后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。</p>\n<h2 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h2><p>所有现代操作系统都使用虚拟内存。虚拟内存意为使用虚假(或虚拟)地址取代物理(硬件RAM)内存地址。这样做好处颇多，总结起来可分为两大类： </p>\n<ol>\n<li><p>一个以上的虚拟地址可指向同一个物理内存地址。 </p>\n</li>\n<li><p>虚拟内存空间可大于实际可用的硬件内存。</p>\n</li>\n</ol>\n<p>那么，这是如何做到的呢？</p>\n<p>我们会同时运行多个进程，而每个进程占用的内存大小不固定，但是这些进程所需要的内存大小加起来却会超过我们实际的物理内存(比如4g内存)，用户感觉到的内存容量会比实际内存容量大的多。这是因为：</p>\n<p>应用程序在运行之前没有必要将之全部装入内存，而仅需将那些当前要运行的少数页面装入内存便可运行，其余部分暂留在磁盘上。程序在运行时，如果他要访问的页已经调入内存，便可继续执行下去；但如果程序所要访问的页面尚未调入内存(缺页)，便发出缺页请求(页错误)，此时操作系统将利用请求调页功能将他们调入内存，以便程序能够继续执行下去。如果此时内存已满，无法再装入新的页，操作系统还需再利用页的置换功能，将内存中暂时不用的页调到磁盘上，腾出足够的内存空间后，再将要访问的页调入内存，使程序继续执行下去。这样，可以使一个或多个大的用户程序在较小的内存空间中运行。</p>\n<p>联想一下Linux系统在硬盘分区时需要让我们选择一个swap分区，结合上面的知识，可知这个swap分区就是上面置换时提到的磁盘。摘抄一段百度百科对<a href=\"http://baike.baidu.com/item/Swap%E5%88%86%E5%8C%BA\">swap</a>的定义：</p>\n<blockquote>\n<p>Swap分区在系统的物理内存不够用的时候，把硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。</p>\n</blockquote>\n<p>因此，虚拟内存的实现利用了上面提到的分页存储的方法，同时，需要存储系统需要增加页面置换和页面调度功能。</p>\n<p>我们知道页表的基本作用就是将用户地址空间中的逻辑地址映射为内存空间中的物理地址，为了满足页面的换进换出功能，在页表中增加几个字段：</p>\n<img src=\"/2017/07/04/Java-NIO-MappedByteBuffer/页表1.png\" alt=\"页表\" title=\"页表\">\n<p>对上面字段的解释：</p>\n<ol>\n<li><p>状态位P: 由于在请求分页系统中，只将应用程序的一部分调入内存，还有一部分在磁盘上，所以需要在页表中增加一个存在位字段，指示该夜是否已调入内存，供应用程序参考。</p>\n</li>\n<li><p>访问字段A：用于记录本页在一段时间内的访问次数，或已有多长时间未被访问，提供给置换算法在选择换出页面时参考。</p>\n</li>\n<li><p>修改位M：标识该页在调入内存后是否被修改过。由于内存中的每一页都在外存上保留一个副本，因此，在置换该页时，若未被修改，就不需要将该页再写回到外存，减少磁盘交互的次数；若已被修改，则必须将该页重写到外存上，保证外存中所保留的副本是最新的。</p>\n</li>\n<li><p>外存地址：指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</p>\n</li>\n</ol>\n<p>回想一下，在前面 <em>**内核空间与用户空间</em> 这一节当中，提到了 Linux的虚拟地址空间为0～4G，从0x00000000到0xFFFFFFFF。这里的虚拟地址，经过MMU的转换，可以映射为物理页号。每一个进程都维护自己的虚拟地址，从虚拟地址中分配内存，实际上底层将这些虚拟地址，通过查询页表映射到物理块号，然后进行相应的置换或者读入。实际上，是所有的进程共享这些物理内存，此时的物理内存相当于一个池(联想 线程池？)。</p>\n<img src=\"/2017/07/04/Java-NIO-MappedByteBuffer/虚拟内存.png\" alt=\"虚拟内存\" title=\"虚拟内存\">\n<h2 id=\"IO原理\"><a href=\"#IO原理\" class=\"headerlink\" title=\"IO原理\"></a>IO原理</h2><p>有了上面的基础，我们再来看一下操作系统中的IO：</p>\n<img src=\"/2017/07/04/Java-NIO-MappedByteBuffer/io.png\" alt=\"IO\" title=\"IO\">\n<p>进程使用read()系统调用，要求其缓冲区被填满。内核随即向磁盘控制硬件发出命令，要求其从磁盘读取数据。磁盘控制器把数据直接写入内核内存缓冲区，这一步通过 DMA 完成，无需主CPU协助。一旦磁盘控制器把缓冲区装满，内核即把数据从内核空间的临时缓冲区拷贝到进程执行read()调用时指定的缓冲区。</p>\n<p>我们可能会觉得，把数据从内核空间拷贝到用户空间似乎有些多余。为什么不直接让磁盘控制器把数据送到用户空间的缓冲区呢？这样做有几个问题。首先，硬件通常不能直接访问用户空间。其次，像磁盘这样基于块存储的硬件设备操作的是固定大小的数据块，而用户进程请求的可能是任意大小的或非对齐的数据块。在数据往来于用户空间与存储设备的过程中，内核负责数据的分解、再组合工作，因此充当着中间人的角色。</p>\n<p>采用分页技术的<strong>操作系统</strong>执行 I/O 的全过程可总结为以下几步：</p>\n<ol>\n<li><p>确定请求的数据分布在文件系统的哪些页(磁盘扇区组)。磁盘上的文件内容和元数据可能跨越多个文件系统页，而且这些页可能也不连续。</p>\n</li>\n<li><p>在内核空间分配足够数量的内存页，以容纳得到确定的文件系统页。</p>\n</li>\n<li><p>在内存页与磁盘上的文件系统页之间建立映射。</p>\n</li>\n<li><p>为每一个内存页产生页错误。</p>\n</li>\n<li><p>虚拟内存系统俘获页错误，安排页面调入，从磁盘上读取页内容，使页有效。</p>\n</li>\n<li><p>一旦页面调入操作完成，文件系统即对原始数据进行解析，取得所需文件内容或属性信息。</p>\n</li>\n</ol>\n<h2 id=\"内存映射文件\"><a href=\"#内存映射文件\" class=\"headerlink\" title=\"内存映射文件\"></a>内存映射文件</h2><p>传统的文件 I/O 是通过用户进程发布read()和write()系统调用来传输数据的。比如<code>FileInputStream.read(byte b[])</code>，实际上是调用了read()系统调用完成数据的读取。回想<a href=\"http://yukai.space/2017/06/28/java-NIO-Buffer/\">上一篇文章</a>，<code>FileInputStream.read(byte b[])</code>会造成几次数据拷贝呢？</p>\n<ol>\n<li><p>从磁盘到内核缓冲区的拷贝</p>\n</li>\n<li><p>内核缓冲区到JVM进程直接缓冲区的拷贝</p>\n</li>\n<li><p>JVM直接缓冲区到<code>FileInputStream.read(byte b[])</code>中byte数组b指向的堆内存的拷贝</p>\n</li>\n</ol>\n<p>可见，传统的IO要经历至少三次数据拷贝才可以把数据读出来，即使是使用直接缓冲区DirectBuffer，也需要至少两次拷贝过程。</p>\n<p>我们知道，设备控制器不能通过 DMA 直接存储到用户空间，但是利用虚拟内存<strong>一个以上的虚拟地址可指向同一个物理内存地址</strong>这个特点，则可以把内核空间地址与用户空间的虚拟地址映射到同一个物理地址，这样，DMA 硬件(只能访问物理内存地址)就可以填充对内核与用户空间进程同时可见的缓冲区。</p>\n<img src=\"/2017/07/04/Java-NIO-MappedByteBuffer/内存文件映射.png\" alt=\"内存文件映射\" title=\"内存文件映射\">\n<p>这样的话，就省去了内核与用户空间的往来拷贝，但前提条件是，内核与用户缓冲区必须使用相同的页对齐，缓冲区的大小还必须是磁盘控制器块大小的倍数。</p>\n<p>内存映射 I/O 使用文件系统建立从用户空间直到可用文件系统页的虚拟内存映射。这样做有几个好处：</p>\n<ul>\n<li><p>用户进程把文件数据当作内存，所以无需发布read()或write()系统调用。</p>\n</li>\n<li><p>当用户进程碰触到映射内存空间，页错误会自动产生，从而将文件数据从磁盘读进内存。如果用户修改了映射内存空间，相关页会自动标记为脏，随后刷新到磁盘，文件得到更新。</p>\n</li>\n<li><p>操作系统的虚拟内存子系统会对页进行智能高速缓存，自动根据系统负载进行内存管理。</p>\n</li>\n<li><p>数据总是按页对齐的，无需执行缓冲区拷贝。</p>\n</li>\n<li><p>大型文件使用映射，无需耗费大量内存，即可进行数据拷贝。</p>\n</li>\n</ul>\n<h2 id=\"MappedByteBuffer\"><a href=\"#MappedByteBuffer\" class=\"headerlink\" title=\"MappedByteBuffer\"></a>MappedByteBuffer</h2><p>了解了上面的内容，我们知道在操作系统和硬件层面实际上是为我们提供了内存映射文件这样的机制的。在java1.4之后，java也提供了对应的接口，可以让我们利用操作系统这一特性，提高文件读写性能，那就是MappedByteBuffer。</p>\n<p>MappedByteBuffer继承自ByteBuffer，MappedByteBuffer被abstract修饰，所以他不能被实例化。我们可以调用<code>FileChannel.map()</code>方法获取一个MappedByteBuffer：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">FileInputStream inputStream = new FileInputStream(file);</div><div class=\"line\">FileChannel channel = inputStream.getChannel();</div><div class=\"line\">MappedByteBuffer map = channel.map(MapMode.READ_WRITE, 0, file.length());</div></pre></td></tr></table></figure>\n<p>这个MappedByteBuffer实际上是其子类DirectByteBuffer实例的引用。也就是说，我们获得的MappedByteBuffer实际上是DirectBuffer类型的缓冲区。也就是说，使用MappedByteBuffer并不会消耗Java虚拟机内存堆。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractChannel</span> <span class=\"keyword\">implements</span> <span class=\"title\">ByteChannel</span>, <span class=\"title\">GatheringByteChannel</span>, <span class=\"title\">ScatteringByteChannel</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> MappedByteBuffer <span class=\"title\">map</span><span class=\"params\">(MapMode mode, <span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> size)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> class MapMode</div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> MapMode READ_ONLY</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> MapMode READ_WRITE</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> MapMode PRIVATE</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以创建一个MappedByteBuffer来代表一个文件中字节的某个子范围。例如，要映射100到299(包含299)位置的字节，可以使用下面的代码：<code>buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 100, 200);</code></p>\n<p>如果要映射整个文件则使用：<code>buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());</code></p>\n<p>文件映射可以是可写的或只读的。前两种映射模式MapMode.READ_ONLY和MapMode.READ_WRITE意义是很明显的，它们表示希望获取的映射只读还是允许修改映射的文件。请求的映射模式将受被调用map()方法的FileChannel对象的访问权限所限制。如果通道是以只读的权限打开的却请求MapMode.READ_WRITE模式，那么map()方法会抛出一个NonWritableChannelException异常；如果在一个没有读权限的通道上请求MapMode.READ_ONLY映射模式，那么将产生NonReadableChannelException异常。</p>\n<p>第三种模式MapMode.PRIVATE表示想要一个写时拷贝(copy-on-write)的映射。这意味着通过put()方法所做的任何修改都会导致产生一个私有的数据副本并且该副本中的数据只有MappedByteBuffer实例可以看到。该过程不会对底层文件做任何修改。尽管写时拷贝的映射可以防止底层文件被修改，但也必须以read/write权限来打开文件以建立MapMode.PRIVATE映射。只有这样，返回的MappedByteBuffer对象才能允许使用put()方法。</p>\n<p>一个映射一旦建立之后将保持有效，直到MappedByteBuffer对象被施以垃圾收集动作为止。关闭相关联的FileChannel不会破坏映射，只有丢弃缓冲区对象本身才会破坏该映射。</p>\n<p>MappedByteBuffer主要用在对大文件的读写或对实时性要求比较高的程序当中。</p>\n<blockquote>\n<p>For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data via the usual read and write methods. From the standpoint of performance it is generally only worth mapping relatively large files into memory.</p>\n</blockquote>\n<p>参考<a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html\">java doc FileChannel.map</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.365mini.com/page/java-nio-course-3.htm\">Java nio入门教程详解(三)</a></p>\n<p><a href=\"http://www.365mini.com/page/java-nio-course-21.htm\">Java nio入门教程详解(二十一)</a></p>\n<p>《计算机操作系统(第四版)》 西安电子科技大学出版社</p>"},{"layout":"post","title":"Java集合框架学习总结","date":"2016-08-16T14:50:16.000Z","_content":"\n看Jdk的源码有大概一个月时间了，中间零零散散算是把[Java的集合](https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html)看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：[Java IO](https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description)\n\n## 框架\n\n{% asset_img collection.png 集合框架 %}\n\n上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。\n\n通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。\n\n<!-- more -->\n\n## List\n\n### Iterator\n\n在总结List之前，先看一下Iterable这个接口,它只包含一个方法:\n\n```java\nIterator<T> iterator();\n```\n\n这个方法返回一个[Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。\n\n### [Collection](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)\n\nCollection 提供了集合的一些基本操作,Collection 接口提供的主要方法：\n\n```\nboolean add(Object o) 添加对象到集合；\nboolean remove(Object o) 删除指定的对象；\nint size() 返回当前集合中元素的数量；\nboolean contains(Object o) 查找集合中是否有指定的对象；\nboolean isEmpty() 判断集合是否为空；\nIterator iterator() 返回一个迭代器；\nboolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；\nboolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；\nvoid clear() 删除集合中所有元素；\nvoid removeAll(Collection c) 从集合中删除 C 集合中也有的元素；\nvoid retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。\n```\n没发现有什么好说的。\n\n### [List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)\n\nList\n\n\n\n","source":"_posts/Java集合框架学习总结.md","raw":"layout: post\ntitle: Java集合框架学习总结\ndate: 2016-08-16 22:50:16\ncategories: 编程 \ntags: \n- java\n- 源码\n---\n\n看Jdk的源码有大概一个月时间了，中间零零散散算是把[Java的集合](https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html)看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：[Java IO](https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description)\n\n## 框架\n\n{% asset_img collection.png 集合框架 %}\n\n上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。\n\n通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。\n\n<!-- more -->\n\n## List\n\n### Iterator\n\n在总结List之前，先看一下Iterable这个接口,它只包含一个方法:\n\n```java\nIterator<T> iterator();\n```\n\n这个方法返回一个[Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。\n\n### [Collection](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)\n\nCollection 提供了集合的一些基本操作,Collection 接口提供的主要方法：\n\n```\nboolean add(Object o) 添加对象到集合；\nboolean remove(Object o) 删除指定的对象；\nint size() 返回当前集合中元素的数量；\nboolean contains(Object o) 查找集合中是否有指定的对象；\nboolean isEmpty() 判断集合是否为空；\nIterator iterator() 返回一个迭代器；\nboolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；\nboolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；\nvoid clear() 删除集合中所有元素；\nvoid removeAll(Collection c) 从集合中删除 C 集合中也有的元素；\nvoid retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。\n```\n没发现有什么好说的。\n\n### [List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)\n\nList\n\n\n\n","slug":"Java集合框架学习总结","published":1,"updated":"2017-04-11T13:08:38.833Z","comments":1,"photos":[],"link":"","_id":"cj4vch4cq0006x3gcgs4w8b6d","content":"<p>看Jdk的源码有大概一个月时间了，中间零零散散算是把<a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html\" target=\"_blank\" rel=\"external\">Java的集合</a>看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description\" target=\"_blank\" rel=\"external\">Java IO</a></p>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><img src=\"/2016/08/16/Java集合框架学习总结/collection.png\" alt=\"集合框架\" title=\"集合框架\">\n<p>上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。</p>\n<p>通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。</p>\n<a id=\"more\"></a>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h3><p>在总结List之前，先看一下Iterable这个接口,它只包含一个方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Iterator&lt;T&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</div></pre></td></tr></table></figure>\n<p>这个方法返回一个<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\" target=\"_blank\" rel=\"external\">Iterator</a>，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。</p>\n<h3 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html\" target=\"_blank\" rel=\"external\">Collection</a></h3><p>Collection 提供了集合的一些基本操作,Collection 接口提供的主要方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean add(Object o) 添加对象到集合；</div><div class=\"line\">boolean remove(Object o) 删除指定的对象；</div><div class=\"line\">int size() 返回当前集合中元素的数量；</div><div class=\"line\">boolean contains(Object o) 查找集合中是否有指定的对象；</div><div class=\"line\">boolean isEmpty() 判断集合是否为空；</div><div class=\"line\">Iterator iterator() 返回一个迭代器；</div><div class=\"line\">boolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；</div><div class=\"line\">boolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；</div><div class=\"line\">void clear() 删除集合中所有元素；</div><div class=\"line\">void removeAll(Collection c) 从集合中删除 C 集合中也有的元素；</div><div class=\"line\">void retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。</div></pre></td></tr></table></figure>\n<p>没发现有什么好说的。</p>\n<h3 id=\"List-1\"><a href=\"#List-1\" class=\"headerlink\" title=\"List\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/List.html\" target=\"_blank\" rel=\"external\">List</a></h3><p>List</p>\n","excerpt":"<p>看Jdk的源码有大概一个月时间了，中间零零散散算是把<a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html\">Java的集合</a>看了个大概。源码还有很多地方不甚明白，但对java集合框架总体上有了个认识。总结一下，以后有时间再把源码理一遍。下一步的Jdk源码阅读计划是：<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html#package_description\">Java IO</a></p>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><img src=\"/2016/08/16/Java集合框架学习总结/collection.png\" alt=\"集合框架\" title=\"集合框架\">\n<p>上图并没有把所有的接口和类都列出来，只是把我认为最常用和最核心的几个类和接口的继承关系表示出来。</p>\n<p>通过上图可以看出，java集合框架主要分为两棵树，一棵继承自Collection，一棵继承自Map。接下来分四个部分总结一下。</p>","more":"<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h3><p>在总结List之前，先看一下Iterable这个接口,它只包含一个方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Iterator&lt;T&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</div></pre></td></tr></table></figure>\n<p>这个方法返回一个<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\">Iterator</a>，也就是一个迭代器，通过这个迭代器，我们可以在不了解集合内部实现的情况下遍历他,这也是设计模式中很重要的一个模式：迭代器模式(关于设计模式，待学习透彻后，会再写一篇博客总结).关于迭代器模式的好处就不再多说，顺便提一下，我们经常用到的foreach循环，内部也是通过迭代器实现的。</p>\n<h3 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html\">Collection</a></h3><p>Collection 提供了集合的一些基本操作,Collection 接口提供的主要方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean add(Object o) 添加对象到集合；</div><div class=\"line\">boolean remove(Object o) 删除指定的对象；</div><div class=\"line\">int size() 返回当前集合中元素的数量；</div><div class=\"line\">boolean contains(Object o) 查找集合中是否有指定的对象；</div><div class=\"line\">boolean isEmpty() 判断集合是否为空；</div><div class=\"line\">Iterator iterator() 返回一个迭代器；</div><div class=\"line\">boolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；</div><div class=\"line\">boolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；</div><div class=\"line\">void clear() 删除集合中所有元素；</div><div class=\"line\">void removeAll(Collection c) 从集合中删除 C 集合中也有的元素；</div><div class=\"line\">void retainAll(Collection c) 从集合中删除集合 C 中不包含的元素。</div></pre></td></tr></table></figure>\n<p>没发现有什么好说的。</p>\n<h3 id=\"List-1\"><a href=\"#List-1\" class=\"headerlink\" title=\"List\"></a><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/List.html\">List</a></h3><p>List</p>"},{"layout":"post","title":"记一次苦逼经历--关于spring项目打包为jar运行","date":"2016-09-19T13:41:48.000Z","_content":"\n上周二刚从外包那里接手了一个的项目，主要是实现了一个web服务器，客户端可以以http请求的方式通过该服务器获取一些数据库的信息，技术上主要是使用了SpringBoot和REST API。周三就来新的需求了，实现一个接口，大概看了下代码，感觉soeasy(虽然之前从没有接触过springboot和spring，说来惭愧。不过这也说明了使用框架的好处，可以快速上手)。\n\n中秋假期结束之后把这个接口弄完了。Eclipse里面跑起来完全没有问题。自信心爆棚。该服务器要求以jar包的方式运行，那就打个包吧。结果苦逼的经历开始了。\n\n由于项目没有使用任何工具构建，没有maven，也没有Gradle。想着就凑合着用Eclipse里面自带的export导出jar包的功能吧。于是:右键工程，选择export。然后java->JAR file\n\n{% asset_img 1.png export %}\n\njar包打好了。把依赖什么的都放到jar所在的同一个目录，紧接着使用 java -cp interfaceService.jar;lib/* com.XXX.Application  执行。\n\n服务器跑起来了。nice\n\n浏览器输入URL，回车，出现了这样的画面：\n\n{% asset_img 2.png 404 %}\n\n<!-- more -->\n\nwhat? 404?赶紧看看服务器打印的日志，发现dispatcherServlet初始化完之后就没有其他动作了，也没有报错信息。跟在eclipse中正常执行的情况对比了一下，eclipse在打印完这几句Log之后就开始进入controller方法了。\n\n{% asset_img 3.png log %}\n\n初步怀疑是找不到对应的controller。\n\n输入关键字：springboot jar 和404页面的提示，谷歌之。\n\n找出来一堆答案，基本都是说没有正确添加注解那一类的意思。回头看看代码，该加注解的地方都加了。而且eclipse里跑着没问题啊，说明不是注解的问题。\n\n感觉应该是打包的问题。把没用的.classpath等文件都排除，重新打包。再次执行，结果一样。\n\n把lib和properties文件都打到包里，执行，还是没用。\n\n{% asset_img 4.png export %}\n\n然后，上图这几个勾选框吸引了我的目光，查了一下这几个框勾选之后的作用，感觉跟这个关系不大，但是也都选上试了一下，失败。\n\n接着又以各种姿势谷歌了一遍，毫无结果。此刻心情比较郁闷，上网刷会微博吧，有点晕...\n\n接下来重新振作精神，再打一次包。\n\n抱着随便试试的心情，把下面的的框也选上了。\n\n{% asset_img 5.png export %}\n\n结果，这次竟然成功了！服务器返回了正确的结果。激动...原来就因为Add Directory Entries这个单选框没勾选就浪费了我两个多小时！\n\n然后各种姿势测了一下，没问题了。\n\nAdd Directory Entries谷歌之。神了，出现了很多与我这个情况一样的描述和解决办法。看来还是有人掉过坑啊！\n\n浏览了一下大家的分析，结果就是：**当使用export方式打jar包来运行spring项目时，一定要记得把Add Directory Entries这个单选框勾选上！否则会扫描不到指定的controller**\n\n原因也很简单：当勾选Add Directory Entries这个选项时，生成的jar会添加文件夹信息。spring就可以扫描到相关的包信息。具体的解释看这篇文章：[spring 扫描包不起作用](http://www.voidcn.com/blog/wangjun5159/article/p-6159159.html)\n\n其实这次遇到的问题也不算是技术上的问题，但前前后后也花了将近三个小时才解决。有三点认识：\n\n1.搜索技巧很重要，如果早一点能用spring、扫描包等关键字去搜索的话，问题早已经解决了。\n\n2.打包尽量用构建工具，避免重复劳动还不易出错。Gradle使用学习中...\n\n3.应该从问题的根源上想才会得到解决方法。比如，如果知道了spring获取controller的实现方式，或许能更快解决这个问题。(spring真的是一点都不懂，需要学习)\n\n以上\n\n\n\n","source":"_posts/Spring项目打包为jar.md","raw":"layout: post\ntitle: 记一次苦逼经历--关于spring项目打包为jar运行\ndate: 2016-09-19 21:41:48\ncategories: 技术\ntags: \n- 服务器\n- spring\n---\n\n上周二刚从外包那里接手了一个的项目，主要是实现了一个web服务器，客户端可以以http请求的方式通过该服务器获取一些数据库的信息，技术上主要是使用了SpringBoot和REST API。周三就来新的需求了，实现一个接口，大概看了下代码，感觉soeasy(虽然之前从没有接触过springboot和spring，说来惭愧。不过这也说明了使用框架的好处，可以快速上手)。\n\n中秋假期结束之后把这个接口弄完了。Eclipse里面跑起来完全没有问题。自信心爆棚。该服务器要求以jar包的方式运行，那就打个包吧。结果苦逼的经历开始了。\n\n由于项目没有使用任何工具构建，没有maven，也没有Gradle。想着就凑合着用Eclipse里面自带的export导出jar包的功能吧。于是:右键工程，选择export。然后java->JAR file\n\n{% asset_img 1.png export %}\n\njar包打好了。把依赖什么的都放到jar所在的同一个目录，紧接着使用 java -cp interfaceService.jar;lib/* com.XXX.Application  执行。\n\n服务器跑起来了。nice\n\n浏览器输入URL，回车，出现了这样的画面：\n\n{% asset_img 2.png 404 %}\n\n<!-- more -->\n\nwhat? 404?赶紧看看服务器打印的日志，发现dispatcherServlet初始化完之后就没有其他动作了，也没有报错信息。跟在eclipse中正常执行的情况对比了一下，eclipse在打印完这几句Log之后就开始进入controller方法了。\n\n{% asset_img 3.png log %}\n\n初步怀疑是找不到对应的controller。\n\n输入关键字：springboot jar 和404页面的提示，谷歌之。\n\n找出来一堆答案，基本都是说没有正确添加注解那一类的意思。回头看看代码，该加注解的地方都加了。而且eclipse里跑着没问题啊，说明不是注解的问题。\n\n感觉应该是打包的问题。把没用的.classpath等文件都排除，重新打包。再次执行，结果一样。\n\n把lib和properties文件都打到包里，执行，还是没用。\n\n{% asset_img 4.png export %}\n\n然后，上图这几个勾选框吸引了我的目光，查了一下这几个框勾选之后的作用，感觉跟这个关系不大，但是也都选上试了一下，失败。\n\n接着又以各种姿势谷歌了一遍，毫无结果。此刻心情比较郁闷，上网刷会微博吧，有点晕...\n\n接下来重新振作精神，再打一次包。\n\n抱着随便试试的心情，把下面的的框也选上了。\n\n{% asset_img 5.png export %}\n\n结果，这次竟然成功了！服务器返回了正确的结果。激动...原来就因为Add Directory Entries这个单选框没勾选就浪费了我两个多小时！\n\n然后各种姿势测了一下，没问题了。\n\nAdd Directory Entries谷歌之。神了，出现了很多与我这个情况一样的描述和解决办法。看来还是有人掉过坑啊！\n\n浏览了一下大家的分析，结果就是：**当使用export方式打jar包来运行spring项目时，一定要记得把Add Directory Entries这个单选框勾选上！否则会扫描不到指定的controller**\n\n原因也很简单：当勾选Add Directory Entries这个选项时，生成的jar会添加文件夹信息。spring就可以扫描到相关的包信息。具体的解释看这篇文章：[spring 扫描包不起作用](http://www.voidcn.com/blog/wangjun5159/article/p-6159159.html)\n\n其实这次遇到的问题也不算是技术上的问题，但前前后后也花了将近三个小时才解决。有三点认识：\n\n1.搜索技巧很重要，如果早一点能用spring、扫描包等关键字去搜索的话，问题早已经解决了。\n\n2.打包尽量用构建工具，避免重复劳动还不易出错。Gradle使用学习中...\n\n3.应该从问题的根源上想才会得到解决方法。比如，如果知道了spring获取controller的实现方式，或许能更快解决这个问题。(spring真的是一点都不懂，需要学习)\n\n以上\n\n\n\n","slug":"Spring项目打包为jar","published":1,"updated":"2017-04-11T13:08:38.834Z","comments":1,"photos":[],"link":"","_id":"cj4vch4cu0008x3gcfpi0wi5v","content":"<p>上周二刚从外包那里接手了一个的项目，主要是实现了一个web服务器，客户端可以以http请求的方式通过该服务器获取一些数据库的信息，技术上主要是使用了SpringBoot和REST API。周三就来新的需求了，实现一个接口，大概看了下代码，感觉soeasy(虽然之前从没有接触过springboot和spring，说来惭愧。不过这也说明了使用框架的好处，可以快速上手)。</p>\n<p>中秋假期结束之后把这个接口弄完了。Eclipse里面跑起来完全没有问题。自信心爆棚。该服务器要求以jar包的方式运行，那就打个包吧。结果苦逼的经历开始了。</p>\n<p>由于项目没有使用任何工具构建，没有maven，也没有Gradle。想着就凑合着用Eclipse里面自带的export导出jar包的功能吧。于是:右键工程，选择export。然后java-&gt;JAR file</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/1.png\" alt=\"export\" title=\"export\">\n<p>jar包打好了。把依赖什么的都放到jar所在的同一个目录，紧接着使用 java -cp interfaceService.jar;lib/* com.XXX.Application  执行。</p>\n<p>服务器跑起来了。nice</p>\n<p>浏览器输入URL，回车，出现了这样的画面：</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/2.png\" alt=\"404\" title=\"404\">\n<a id=\"more\"></a>\n<p>what? 404?赶紧看看服务器打印的日志，发现dispatcherServlet初始化完之后就没有其他动作了，也没有报错信息。跟在eclipse中正常执行的情况对比了一下，eclipse在打印完这几句Log之后就开始进入controller方法了。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/3.png\" alt=\"log\" title=\"log\">\n<p>初步怀疑是找不到对应的controller。</p>\n<p>输入关键字：springboot jar 和404页面的提示，谷歌之。</p>\n<p>找出来一堆答案，基本都是说没有正确添加注解那一类的意思。回头看看代码，该加注解的地方都加了。而且eclipse里跑着没问题啊，说明不是注解的问题。</p>\n<p>感觉应该是打包的问题。把没用的.classpath等文件都排除，重新打包。再次执行，结果一样。</p>\n<p>把lib和properties文件都打到包里，执行，还是没用。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/4.png\" alt=\"export\" title=\"export\">\n<p>然后，上图这几个勾选框吸引了我的目光，查了一下这几个框勾选之后的作用，感觉跟这个关系不大，但是也都选上试了一下，失败。</p>\n<p>接着又以各种姿势谷歌了一遍，毫无结果。此刻心情比较郁闷，上网刷会微博吧，有点晕…</p>\n<p>接下来重新振作精神，再打一次包。</p>\n<p>抱着随便试试的心情，把下面的的框也选上了。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/5.png\" alt=\"export\" title=\"export\">\n<p>结果，这次竟然成功了！服务器返回了正确的结果。激动…原来就因为Add Directory Entries这个单选框没勾选就浪费了我两个多小时！</p>\n<p>然后各种姿势测了一下，没问题了。</p>\n<p>Add Directory Entries谷歌之。神了，出现了很多与我这个情况一样的描述和解决办法。看来还是有人掉过坑啊！</p>\n<p>浏览了一下大家的分析，结果就是：<strong>当使用export方式打jar包来运行spring项目时，一定要记得把Add Directory Entries这个单选框勾选上！否则会扫描不到指定的controller</strong></p>\n<p>原因也很简单：当勾选Add Directory Entries这个选项时，生成的jar会添加文件夹信息。spring就可以扫描到相关的包信息。具体的解释看这篇文章：<a href=\"http://www.voidcn.com/blog/wangjun5159/article/p-6159159.html\" target=\"_blank\" rel=\"external\">spring 扫描包不起作用</a></p>\n<p>其实这次遇到的问题也不算是技术上的问题，但前前后后也花了将近三个小时才解决。有三点认识：</p>\n<p>1.搜索技巧很重要，如果早一点能用spring、扫描包等关键字去搜索的话，问题早已经解决了。</p>\n<p>2.打包尽量用构建工具，避免重复劳动还不易出错。Gradle使用学习中…</p>\n<p>3.应该从问题的根源上想才会得到解决方法。比如，如果知道了spring获取controller的实现方式，或许能更快解决这个问题。(spring真的是一点都不懂，需要学习)</p>\n<p>以上</p>\n","excerpt":"<p>上周二刚从外包那里接手了一个的项目，主要是实现了一个web服务器，客户端可以以http请求的方式通过该服务器获取一些数据库的信息，技术上主要是使用了SpringBoot和REST API。周三就来新的需求了，实现一个接口，大概看了下代码，感觉soeasy(虽然之前从没有接触过springboot和spring，说来惭愧。不过这也说明了使用框架的好处，可以快速上手)。</p>\n<p>中秋假期结束之后把这个接口弄完了。Eclipse里面跑起来完全没有问题。自信心爆棚。该服务器要求以jar包的方式运行，那就打个包吧。结果苦逼的经历开始了。</p>\n<p>由于项目没有使用任何工具构建，没有maven，也没有Gradle。想着就凑合着用Eclipse里面自带的export导出jar包的功能吧。于是:右键工程，选择export。然后java-&gt;JAR file</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/1.png\" alt=\"export\" title=\"export\">\n<p>jar包打好了。把依赖什么的都放到jar所在的同一个目录，紧接着使用 java -cp interfaceService.jar;lib/* com.XXX.Application  执行。</p>\n<p>服务器跑起来了。nice</p>\n<p>浏览器输入URL，回车，出现了这样的画面：</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/2.png\" alt=\"404\" title=\"404\">","more":"<p>what? 404?赶紧看看服务器打印的日志，发现dispatcherServlet初始化完之后就没有其他动作了，也没有报错信息。跟在eclipse中正常执行的情况对比了一下，eclipse在打印完这几句Log之后就开始进入controller方法了。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/3.png\" alt=\"log\" title=\"log\">\n<p>初步怀疑是找不到对应的controller。</p>\n<p>输入关键字：springboot jar 和404页面的提示，谷歌之。</p>\n<p>找出来一堆答案，基本都是说没有正确添加注解那一类的意思。回头看看代码，该加注解的地方都加了。而且eclipse里跑着没问题啊，说明不是注解的问题。</p>\n<p>感觉应该是打包的问题。把没用的.classpath等文件都排除，重新打包。再次执行，结果一样。</p>\n<p>把lib和properties文件都打到包里，执行，还是没用。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/4.png\" alt=\"export\" title=\"export\">\n<p>然后，上图这几个勾选框吸引了我的目光，查了一下这几个框勾选之后的作用，感觉跟这个关系不大，但是也都选上试了一下，失败。</p>\n<p>接着又以各种姿势谷歌了一遍，毫无结果。此刻心情比较郁闷，上网刷会微博吧，有点晕…</p>\n<p>接下来重新振作精神，再打一次包。</p>\n<p>抱着随便试试的心情，把下面的的框也选上了。</p>\n<img src=\"/2016/09/19/Spring项目打包为jar/5.png\" alt=\"export\" title=\"export\">\n<p>结果，这次竟然成功了！服务器返回了正确的结果。激动…原来就因为Add Directory Entries这个单选框没勾选就浪费了我两个多小时！</p>\n<p>然后各种姿势测了一下，没问题了。</p>\n<p>Add Directory Entries谷歌之。神了，出现了很多与我这个情况一样的描述和解决办法。看来还是有人掉过坑啊！</p>\n<p>浏览了一下大家的分析，结果就是：<strong>当使用export方式打jar包来运行spring项目时，一定要记得把Add Directory Entries这个单选框勾选上！否则会扫描不到指定的controller</strong></p>\n<p>原因也很简单：当勾选Add Directory Entries这个选项时，生成的jar会添加文件夹信息。spring就可以扫描到相关的包信息。具体的解释看这篇文章：<a href=\"http://www.voidcn.com/blog/wangjun5159/article/p-6159159.html\">spring 扫描包不起作用</a></p>\n<p>其实这次遇到的问题也不算是技术上的问题，但前前后后也花了将近三个小时才解决。有三点认识：</p>\n<p>1.搜索技巧很重要，如果早一点能用spring、扫描包等关键字去搜索的话，问题早已经解决了。</p>\n<p>2.打包尽量用构建工具，避免重复劳动还不易出错。Gradle使用学习中…</p>\n<p>3.应该从问题的根源上想才会得到解决方法。比如，如果知道了spring获取controller的实现方式，或许能更快解决这个问题。(spring真的是一点都不懂，需要学习)</p>\n<p>以上</p>"},{"layout":"post","title":"Java-NIO-Channel","date":"2017-07-08T12:31:23.000Z","_content":"> Java NIO 学习第三篇--Channel\n\n## Channel\n\n通道(Channel)的作用有类似于流(Stream)，用于传输文件或者网络上的数据。\n\n{% asset_img channel.png channel %}\n\n<!-- more -->\n\n上图中，箭头就相当于通道。一个不是很准确的例子：把通道想象成铁轨，缓冲区则是列车，铁轨的起始与终点则可以是socket，文件系统和我们的程序。假如当我们在代码中要写入数据到一份文件的时候，我们先把列车(缓冲区)装满，然后把列车(缓冲区)放置到铁轨上(通道)，数据就被传递到通道的另一端，文件系统。读取文件则相反，文件的内容被装到列车上，传递到程序这一侧，然后我们在代码中就可以读取这个列车中的内容(读取缓冲区)。\n\n通道与传统的流还是有一些区别的：\n\n- 通道可以同时支持读写(不是一定支持)，而流只支持单方向的操作，比如输入流只能读，输出流只能写。\n\n- 通道可以支持异步的读或写，而流是同步的。\n\n- 通道的读取或写入是通过缓冲区来进行的，而流则写入或返回字节。\n\n## FileChannel\n\n通道大致上可以分为两类：文件通道和socket通道。看一下文件通道：\n\n文件通道可以由以下几个方法获得：\n\n```java\nRandomAccessFile file = new RandomAccessFile(new File(fileName), \"rw\");\nFileChannel channel = file.getChannel();\n\nFileInputStream stream = new FileInputStream(new File(fileName));\nFileChannel channel = stream.getChannel();\n\nFileOutputStream stream = new FileOutputStream(new File(fileName));\nFileChannel channel = stream.getChannel();\n\nFileChannel channel = FileChannel.open(Paths.get(fileName));\n```\n\nFileChannel 类结构：\n\n{% asset_img filechannel.png Filechannel %}\n\n可见FileChannel实现了读写接口、聚集、发散接口，以及文件锁功能。下面会提到。\n\n看一下FileChannel的基本方法：\n\n```java\npublic abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {\n    // 这里仅列出部分API\n    public abstract long position()\n    public abstract void position (long newPosition)\n    public abstract int read (ByteBuffer dst)\n    public abstract int read (ByteBuffer dst, long position)\n    public abstract int write (ByteBuffer src)\n    public abstract int write (ByteBuffer src, long position)\n    public abstract long size()\n    public abstract void truncate (long size)\n    public abstract void force (boolean metaData)\n}\n```\n\n在通道出现之前，底层的文件操作都是通过RandomAccessFile类的方法来实现的。FileChannel模拟同样的 I/O 服务，因此它们的API自然也是很相似的。\n\n{% asset_img api.png Filechannel %}\n\n上图是FileChannel、RandomAccessFile 和 [POSIX I/O system calls](http://wiki.jikexueyuan.com/project/linux-process/posix.html) 三者在方法上的对应关系。\n\nPOSIX接口我们在上一篇文章中也略有提及，他是一个系统级别的接口。下面看一下这几个接口，主要也是和上一篇文章文件描述符的介绍做一个呼应。\n\n- position()和position(long newPosition)\n\nposition()返回当前文件的position值，position(long newPosition)将当前position设置为指定值。当字节被read()或write()方法传输时，文件position会自动更新。\n\nposition的含义与Buffer类中的position含义相似，都是指向下一个字节读取的位置。\n\n回想一下介绍文件描述符的文章当中提到，当进程打开一个文件时，内核就会创建一个新的file对象，这个file对象有一个字段loff_t f_pos描述了文件的当前位置，position相当于loff_t f_pos的映射。由此可知，如果是使用同一文件描述符读取文件，那么他们的position是相互影响的：\n\n```java\nRandomAccessFile file = new RandomAccessFile(new File(fileName), \"rw\");\nFileChannel channel = file.getChannel();\nSystem.out.println(\"position: \" + channel.position());\nfile.seek(30);\nSystem.out.println(\"position: \" + channel.position());\n```\n\n打印如下：\n\n```\nposition: 0\nposition: 30\n```\n\n这是因为，file与channel使用了同一个文件描述符。如果新建另一个相同文件的通道，那么他们之间的position不会相互影响，因为使用了不同的文件描述符，指向不同的file对象。\n\n- truncate(long size)\n\n当需要减少一个文件的size时，truncate()方法会砍掉指定的size值之外的所有数据。这个方法要求通道具有写权限。\n\n如果当前size大于给定size，超出给定size的所有字节都会被删除。如果提供的新size值大于或等于当前的文件size值，该文件不会被修改。\n\n```java\nRandomAccessFile file = new RandomAccessFile(new File(fileName), \"rw\");\nFileChannel channel = file.getChannel();\nSystem.out.println(\"size: \" + channel.size());\nSystem.out.println(\"position: \" + channel.position());\nSystem.out.println(\"trucate: 90\");\nchannel.truncate(90);\nSystem.out.println(\"size: \" + channel.size());\nSystem.out.println(\"position: \" + channel.position());\n```\n\n打印如下：\n\n```\nsize: 100\nposition: 0\ntrucate: 90\nsize: 90\nposition: 0\n```\n\n-  force (boolean metaData)\n\nforce()方法告诉通道强制将全部待定的修改都应用到磁盘的文件上。\n\n如果文件位于一个本地文件系统，那么一旦force()方法返回，即可保证从通道被创建(或上次调用force())时起的对文件所做的全部修改已经被写入到磁盘。但是，如果文件位于一个远程的文件系统，如NFS上，那么不能保证待定修改一定能同步到永久存储器。\n\nforce()方法的布尔型参数表示在方法返回值前文件的元数据(metadata)是否也要被同步更新到磁盘。元数据指文件所有者、访问权限、最后一次修改时间等信息。\n> Java NIO 学习第三篇--Channel\n\n## Channel\n\n通道(Channel)的作用有类似于流(Stream)，用于传输文件或者网络上的数据。\n\n{% asset_img channel.png channel %}\n\n上图中，箭头就相当于通道。一个不是很准确的例子：把通道想象成铁轨，缓冲区则是列车，铁轨的起始与终点则可以是socket，文件系统和我们的程序。假如当我们在代码中要写入数据到一份文件的时候，我们先把列车(缓冲区)装满，然后把列车(缓冲区)放置到铁轨上(通道)，数据就被传递到通道的另一端，文件系统。读取文件则相反，文件的内容被装到列车上，传递到程序这一侧，然后我们在代码中就可以读取这个列车中的内容(读取缓冲区)。\n\n通道与传统的流还是有一些区别的：\n\n- 通道可以同时支持读写(不是一定支持)，而流只支持单方向的操作，比如输入流只能读，输出流只能写。\n\n- 通道可以支持异步的读或写，而流是同步的。\n\n- 通道的读取或写入是通过缓冲区来进行的，而流则写入或返回字节。\n\n## [FileChannel](https://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html)\n\n通道大致上可以分为两类：文件通道和socket通道。看一下文件通道：\n\n文件通道可以由以下几个方法获得：\n\n```java\nRandomAccessFile file = new RandomAccessFile(new File(fileName), \"rw\");\nFileChannel channel = file.getChannel();\n\nFileInputStream stream = new FileInputStream(new File(fileName));\nFileChannel channel = stream.getChannel();\n\nFileOutputStream stream = new FileOutputStream(new File(fileName));\nFileChannel channel = stream.getChannel();\n\nFileChannel channel = FileChannel.open(Paths.get(fileName));\n```\n\nFileChannel 类结构：\n\n{% asset_img filechannel.png Filechannel %}\n\n可见FileChannel实现了读写接口、聚集、发散接口，以及文件锁功能。下面会提到。\n\n看一下FileChannel的基本方法：\n\n```java\npublic abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {\n    // 这里仅列出部分API\n    public abstract long position()\n    public abstract void position (long newPosition)\n    public abstract int read (ByteBuffer dst)\n    public abstract int read (ByteBuffer dst, long position)\n    public abstract int write (ByteBuffer src)\n    public abstract int write (ByteBuffer src, long position)\n    public abstract long size()\n    public abstract void truncate (long size)\n    public abstract void force (boolean metaData)\n}\n```\n\n在通道出现之前，底层的文件操作都是通过RandomAccessFile类的方法来实现的。FileChannel模拟同样的 I/O 服务，因此它们的API自然也是很相似的。\n\n{% asset_img api.png Filechannel %}\n\n上图是FileChannel、RandomAccessFile 和 [POSIX I/O system calls](http://wiki.jikexueyuan.com/project/linux-process/posix.html) 三者在方法上的对应关系。\n\nPOSIX接口我们在上一篇文章中也略有提及，他是一个系统级别的接口。下面看一下这几个接口，主要也是和上一篇文章文件描述符的介绍做一个呼应。\n\n- position()和position(long newPosition)\n\nposition()返回当前文件的position值，position(long newPosition)将当前position设置为指定值。当字节被read()或write()方法传输时，文件position会自动更新。\n\nposition的含义与Buffer类中的position含义相似，都是指向下一个字节读取的位置。\n\n回想一下介绍文件描述符的文章当中提到，当进程打开一个文件时，内核就会创建一个新的file对象，这个file对象有一个字段loff_t f_pos描述了文件的当前位置，position相当于loff_t f_pos的映射。由此可知，如果是使用同一文件描述符读取文件，那么他们的position是相互影响的：\n\n```java\nRandomAccessFile file = new RandomAccessFile(new File(fileName), \"rw\");\nFileChannel channel = file.getChannel();\nSystem.out.println(\"position: \" + channel.position());\nfile.seek(30);\nSystem.out.println(\"position: \" + channel.position());\n```\n\n打印如下：\n\n```\nposition: 0\nposition: 30\n```\n\n这是因为，file与channel使用了同一个文件描述符。如果新建另一个相同文件的通道，那么他们之间的position不会相互影响，因为使用了不同的文件描述符，指向不同的file对象。\n\n- truncate(long size)\n\n当需要减少一个文件的size时，truncate()方法会砍掉指定的size值之外的所有数据。这个方法要求通道具有写权限。\n\n如果当前size大于给定size，超出给定size的所有字节都会被删除。如果提供的新size值大于或等于当前的文件size值，该文件不会被修改。\n\n```java\nRandomAccessFile file = new RandomAccessFile(new File(fileName), \"rw\");\nFileChannel channel = file.getChannel();\nSystem.out.println(\"size: \" + channel.size());\nSystem.out.println(\"position: \" + channel.position());\nSystem.out.println(\"trucate: 90\");\nchannel.truncate(90);\nSystem.out.println(\"size: \" + channel.size());\nSystem.out.println(\"position: \" + channel.position());\n```\n\n打印如下：\n\n```\nsize: 100\nposition: 0\ntrucate: 90\nsize: 90\nposition: 0\n```\n\n-  force (boolean metaData)\n\nforce()方法告诉通道强制将全部待定的修改都应用到磁盘的文件上。\n\n如果文件位于一个本地文件系统，那么一旦force()方法返回，即可保证从通道被创建(或上次调用force())时起的对文件所做的全部修改已经被写入到磁盘。但是，如果文件位于一个远程的文件系统，如NFS上，那么不能保证待定修改一定能同步到永久存储器。\n\nforce()方法的布尔型参数表示在方法返回值前文件的元数据(metadata)是否也要被同步更新到磁盘。元数据指文件所有者、访问权限、最后一次修改时间等信息。\n\nFileChannel对象是线程安全的。如果有一个线程已经在执行会影响通道位置或文件大小的操作，那么其他尝试进行此类操作之一的线程必须等待。\n\n## ReadableByteChannel、WritableByteChannel\n\n通道可以是单向或者双向的。\n\n```java\npublic interface ReadableByteChannel extends Channel{\n    public int read (ByteBuffer dst) throws IOException;\n}\n\npublic interface WritableByteChannel extends Channel{\n    public int write (ByteBuffer src) throws IOException;\n}\n\npublic interface ByteChannel extends ReadableByteChannel, WritableByteChannel{\n}\n```\n\n{% asset_img bytechannel.png channel %}\n\n实现ReadableByteChannel或WritableByteChannel其中之一的channel是单向的，只可以读或者写。如果一个类同时实现了这两种接口，那么他就具备了双向传输的能力。\n\njava为我们提供了一个接口ByteChannel，同时继承了上述两个接口。所以，实现了ByteChannel接口的类可以读，也可以写。\n\n在**FlieChannel**这一节中我们知道，文件在不同的方式下以不同的权限打开。比如`FileInputStream.getChannel()`方法返回一个FileChannel实例，FileChannel是个抽象类，间接的实现了ByteChannel接口，也就意味着提供了read和write接口。但是`FileInputStream.getChannel()`方法返回的FileChannel实际上是只读的，很简单，因为FileInputStream本身就是个输入流啊~在这样一个通道上调用write方法将抛出NonWritableChannelException异常，因为FileInputStream对象总是以read-only的权限打开通道。看一下代码：\n\nFileInputStream.getChannel()\n\n```java\npublic FileChannel getChannel() {\n        synchronized (this) {\n            if (channel == null) {\n                // 第三个参数指定通道是否可读，第四个参数指定通道是否可写\n                channel = FileChannelImpl.open(fd, path, true, false, this);\n\n                /*\n                 * Increment fd's use count. Invoking the channel's close()\n                 * method will result in decrementing the use count set for\n                 * the channel.\n                 */\n                fd.incrementAndGetUseCount();\n            }\n            return channel;\n        }\n}\n```\n同样的，`FileOutputStream.getChannel()`返回的通道是不可读的。\n\n## InterruptibleChannel\n\nInterruptibleChannel是一个标记接口，当被通道使用时可以标示该通道是可以中断的。\n\n如果一个线程在一个通道上处于阻塞状态时被中断(另外一个线程调用该线程的interrupt()方法设置中断状态)，那么该通道将被关闭，该被阻塞线程也会产生一个ClosedByInterruptException异常。也就是说，假如一个线程的interrupt status被设置并且该线程试图访问一个通道，那么这个通道将立即被关闭，同时将抛出相同的ClosedByInterruptException异常。\n\n在[java任务取消](http://yukai.space/2017/05/02/java%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88/)中提到了，传统的java io 在读写时阻塞，是不会响应中断的。解决办法就是使用InterruptibleChannel，在线程被中断时可以关闭通道并返回。\n\n可中断的通道也是可以异步关闭。实现InterruptibleChannel接口的通道可以在任何时候被关闭，即使有另一个被阻塞的线程在等待该通道上的一个I/O操作完成。当一个通道被关闭时，休眠在该通道上的所有线程都将被唤醒并接收到一个AsynchronousCloseException异常。接着通道就被关闭并将不再可用。\n\n## Scatter/Gather\n\n发散(Scatter)读取是将数据读入多个缓冲区(缓冲区数组)的操作。通道将数据依次填满到每个缓冲区当中。\n\n汇聚(Gather)写出是将多个缓冲区(缓冲区数组)数据依次写入到通道的操作。\n\n在FileChannel中提到的两个接口，提供了发散汇聚的功能：\n\n```java\npublic interface ScatteringByteChannel extends ReadableByteChannel{\n    public long read (ByteBuffer[] dsts) throws IOException;\n    public long read (ByteBuffer[] dsts, int offset, int length) throws IOException;\n}\npublic interface GatheringByteChannel extends WritableByteChannel{\n    public long write(ByteBuffer[] srcs) throws IOException;\n    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException;\n}\n```\n\n发散汇聚在某些场景下是很有用的，比如有一个消息协议格式分为head和body(比如http协议)，我们在接收这样一个消息的时候，通常的做法是把数据一下子都读过来，然后解析他。使用通道的发散功能会使这个过程变得简单：\n\n```java\n// head数据128字节\nByteBuffer header = ByteBuffer.allocate(128);\n// body数据1024字节\nByteBuffer body   = ByteBuffer.allocate(1024);\n\nByteBuffer[] bufferArray = { header, body };\n\nchannel.read(bufferArray);\n```\n\n通道会依次填满这个buffer数组的每个buffer，如果一个buffer满了，就移动到下一个buffer。很自然的把head和body的数据分开了，但是要注意head和body的数据长度必须是固定的，因为channel只有填满一个buffer之后才会移动到下一个buffer。\n\n## FileLock\n\n摘抄一段oracle官网上FileLock的介绍吧，感觉说的挺清楚了。(因为懒，就不翻译了，读起来不是很费劲)\n\n>A token representing a lock on a region of a file.\n>A file-lock object is created each time a lock is acquired on a file via one of the lock or tryLock methods of the FileChannel class, or the lock or tryLock methods of the AsynchronousFileChannel class.\n>\n>A file-lock object is initially valid. It remains valid until the lock is released by invoking the release method, by closing the channel that was used to acquire it, or by the termination of the Java virtual machine, whichever comes first. The validity of a lock may be tested by invoking its >isValid method.\n>\n>A file lock is either exclusive or shared. A shared lock prevents other concurrently-running programs from acquiring an overlapping exclusive lock, but does allow them to acquire overlapping shared locks. An exclusive lock prevents other programs from acquiring an overlapping lock of either type. >Once it is released, a lock has no further effect on the locks that may be acquired by other programs.\n>\n>Whether a lock is exclusive or shared may be determined by invoking its isShared method. Some platforms do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.\n>\n>The locks held on a particular file by a single Java virtual machine do not overlap. The overlaps method may be used to test whether a candidate lock range overlaps an existing lock.\n>\n>A file-lock object records the file channel upon whose file the lock is held, the type and validity of the lock, and the position and size of the locked region. Only the validity of a lock is subject to change over time; all other aspects of a lock's state are immutable.\n>\n>File locks are held on behalf of the entire Java virtual machine. They are not suitable for controlling access to a file by multiple threads within the same virtual machine.\n>\n>File-lock objects are safe for use by multiple concurrent threads.\n>\n>**Platform dependencies**\n>\n>This file-locking API is intended to map directly to the native locking facility of the underlying operating system. Thus the locks held on a file should be visible to all programs that have access to the file, regardless of the language in which those programs are written.\n>\n>Whether or not a lock actually prevents another program from accessing the content of the locked region is system-dependent and therefore unspecified. The native file-locking facilities of some systems are merely advisory, meaning that programs must cooperatively observe a known locking protocol in >order to guarantee data integrity. On other systems native file locks are mandatory, meaning that if one program locks a region of a file then other programs are actually prevented from accessing that region in a way that would violate the lock. On yet other systems, whether native file locks are >advisory or mandatory is configurable on a per-file basis. To ensure consistent and correct behavior across platforms, it is strongly recommended that the locks provided by this API be used as if they were advisory locks.\n>\n>On some systems, acquiring a mandatory lock on a region of a file prevents that region from being mapped into memory, and vice versa. Programs that combine locking and mapping should be prepared for this combination to fail.\n>\n>On some systems, closing a channel releases all locks held by the Java virtual machine on the underlying file regardless of whether the locks were acquired via that channel or via another channel open on the same file. It is strongly recommended that, within a program, a unique channel be used to >acquire all locks on any given file.\n>\n>Some network filesystems permit file locking to be used with memory-mapped files only when the locked regions are page-aligned and a whole multiple of the underlying hardware's page size. Some network filesystems do not implement file locks on regions that extend past a certain position, often 230 >or 231. In general, great care should be taken when locking files that reside on network filesystems.\n\nFileLock可以由以下几个方法获得：\n\n```java\npublic abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {\n// 这里仅列出部分API\n    public final FileLock lock()\n    public abstract FileLock lock (long position, long size, boolean shared)\n    public final FileLock tryLock()\n    public abstract FileLock tryLock (long position, long size, boolean shared)\n}\n```\n\n其中，lock是阻塞的，tryLock是非阻塞的。position和size决定了锁定的区域，shared决定了文件锁是共享的还是独占的。\n\n不带参数的lock方法等价于`fileChannel.lock(0L, Long.MAX_VALUE, false)`，tryLock亦然。\n\nlock方法是响应中断的，当线程被中断时方法抛出FileLockInterruptionException异常。如果通道被另外一个线程关闭，该暂停线程将恢复并产生一个 AsynchronousCloseException异常。\n\n上面还提到了，文件锁是针对于进程级别的。如果有多个进程同时对一个文件锁定，并且其中有独占锁的话，这些锁的申请会被串行化。\n\n如果是同一个进程(Jvm实例)的多个线程同时请求同一个文件区域的lock的话，会抛出OverlappingFileLockException异常。\n\n## Channel-to-Channel\n\nFileChannel提供了接口，用于通道和通道之间的直接传输。\n\n```java\npublic abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {\n    // 这里仅列出部分API\n    public abstract long transferTo (long position, long count, WritableByteChannel target)\n    public abstract long transferFrom (ReadableByteChannel src, long position, long count)\n}\n```\n\n只有FileChannel类有这两个方法，因此Channel-to-Channel传输中通道之一必须是FileChannel。不能在socket通道之间直接传输数据，不过socket通道实现WritableByteChannel和ReadableByteChannel接口，因此文件的内容可以用transferTo()方法传输给一个socket通道，或者也可以用transferFrom()方法将数据从一个socket通道直接读取到一个文件中。\n\n直接的通道传输不会更新与某个FileChannel关联的position值。请求的数据传输将从position参数指定的位置开始，传输的字节数不超过count参数的值。实际传输的字节数会由方法返回。\n\n直接通道传输的另一端如果是socket通道并且处于非阻塞模式的话，数据的传输将具有不确定性。比如，transferFrom从socket通道读取数据，如果socket中的数据尚未准备好，那么方法将直接返回。\n\n例子：\n\n```java\nRandomAccessFile fromFile = new RandomAccessFile(\"fromFile.txt\", \"rw\");\nFileChannel      fromChannel = fromFile.getChannel();\n\nRandomAccessFile toFile = new RandomAccessFile(\"toFile.txt\", \"rw\");\nFileChannel      toChannel = toFile.getChannel();\n\nlong position = 0;\nlong count    = fromChannel.size();\n\ntoChannel.transferFrom(fromChannel, position, count);\n\n\nRandomAccessFile fromFile = new RandomAccessFile(\"fromFile.txt\", \"rw\");\nFileChannel      fromChannel = fromFile.getChannel();\n\nRandomAccessFile toFile = new RandomAccessFile(\"toFile.txt\", \"rw\");\nFileChannel      toChannel = toFile.getChannel();\n\nlong position = 0;\nlong count    = fromChannel.size();\n\nfromChannel.transferTo(position, count, toChannel);\n```\n\n## 参考\n\n[Java nio入门教程详解](http://www.365mini.com/page/java-nio-course-17.htm)\n\n## ReadableByteChannel、WritableByteChannel\n\n通道可以是单向或者双向的。\n\n```java\npublic interface ReadableByteChannel extends Channel{\n    public int read (ByteBuffer dst) throws IOException;\n}\n\npublic interface WritableByteChannel extends Channel{\n    public int write (ByteBuffer src) throws IOException;\n}\n\npublic interface ByteChannel extends ReadableByteChannel, WritableByteChannel{\n}\n```\n\n{% asset_img bytechannel.png channel %}\n\n实现ReadableByteChannel或WritableByteChannel其中之一的channel是单向的，只可以读或者写。如果一个类同时实现了这两种接口，那么他就具备了双向传输的能力。\n\njava为我们提供了一个接口ByteChannel，同时继承了上述两个接口。所以，实现了ByteChannel接口的类可以读，也可以写。\n\n在**FlieChannel**这一节中我们知道，文件在不同的方式下以不同的权限打开。比如`FileInputStream.getChannel()`方法返回一个FileChannel实例，FileChannel是个抽象类，间接的实现了ByteChannel接口，也就意味着提供了read和write接口。但是`FileInputStream.getChannel()`方法返回的FileChannel实际上是只读的，很简单，因为FileInputStream本身就是个输入流啊~在这样一个通道上调用write方法将抛出NonWritableChannelException异常，因为FileInputStream对象总是以read-only的权限打开通道。看一下代码：\n\nFileInputStream.getChannel()\n\n```java\npublic FileChannel getChannel() {\n        synchronized (this) {\n            if (channel == null) {\n                // 第三个参数指定通道是否可读，第四个参数指定通道是否可写\n                channel = FileChannelImpl.open(fd, path, true, false, this);\n\n                /*\n                 * Increment fd's use count. Invoking the channel's close()\n                 * method will result in decrementing the use count set for\n                 * the channel.\n                 */\n                fd.incrementAndGetUseCount();\n            }\n            return channel;\n        }\n}\n```\n同样的，`FileOutputStream.getChannel()`返回的通道是不可读的。\n\n## InterruptibleChannel\n\nInterruptibleChannel是一个标记接口，当被通道使用时可以标示该通道是可以中断的。\n\n如果一个线程在一个通道上处于阻塞状态时被中断(另外一个线程调用该线程的interrupt()方法设置中断状态)，那么该通道将被关闭，该被阻塞线程也会产生一个ClosedByInterruptException异常。也就是说，假如一个线程的interrupt status被设置并且该线程试图访问一个通道，那么这个通道将立即被关闭，同时将抛出相同的ClosedByInterruptException异常。\n\n在[java任务取消](http://yukai.space/2017/05/02/java%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88/)中提到了，传统的java io 在读写时阻塞，是不会响应中断的。解决办法就是使用InterruptibleChannel，在线程被中断时可以关闭通道并返回。\n\n可中断的通道也是可以异步关闭。实现InterruptibleChannel接口的通道可以在任何时候被关闭，即使有另一个被阻塞的线程在等待该通道上的一个I/O操作完成。当一个通道被关闭时，休眠在该通道上的所有线程都将被唤醒并接收到一个AsynchronousCloseException异常。接着通道就被关闭并将不再可用。\n\n## Scatter/Gather\n\n发散(Scatter)读取是将数据读入多个缓冲区(缓冲区数组)的操作。通道将数据依次填满到每个缓冲区当中。\n\n汇聚(Gather)写出是将多个缓冲区(缓冲区数组)数据依次写入到通道的操作。\n\n在FileChannel中提到的两个接口，提供了发散汇聚的功能：\n\n```java\npublic interface ScatteringByteChannel extends ReadableByteChannel{\n    public long read (ByteBuffer[] dsts) throws IOException;\n    public long read (ByteBuffer[] dsts, int offset, int length) throws IOException;\n}\npublic interface GatheringByteChannel extends WritableByteChannel{\n    public long write(ByteBuffer[] srcs) throws IOException;\n    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException;\n}\n```\n\n发散汇聚在某些场景下是很有用的，比如有一个消息协议格式分为head和body(比如http协议)，我们在接收这样一个消息的时候，通常的做法是把数据一下子都读过来，然后解析他。使用通道的发散功能会使这个过程变得简单：\n\n```java\n// head数据128字节\nByteBuffer header = ByteBuffer.allocate(128);\n// body数据1024字节\nByteBuffer body   = ByteBuffer.allocate(1024);\n\nByteBuffer[] bufferArray = { header, body };\n\nchannel.read(bufferArray);\n```\n\n通道会依次填满这个buffer数组的每个buffer，如果一个buffer满了，就移动到下一个buffer。很自然的把head和body的数据分开了，但是要注意head和body的数据长度必须是固定的，因为channel只有填满一个buffer之后才会移动到下一个buffer。\n\n## FileLock\n\n\n\n## Channel-to-Channel\n\nFileChannel提供了接口，用于通道和通道之间的直接传输。\n\n```java\npublic abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {\n    // 这里仅列出部分API\n    public abstract long transferTo (long position, long count, WritableByteChannel target)\n    public abstract long transferFrom (ReadableByteChannel src, long position, long count)\n}\n```\n\n只有FileChannel类有这两个方法，因此Channel-to-Channel传输中通道之一必须是FileChannel。不能在socket通道之间直接传输数据，不过socket通道实现WritableByteChannel和ReadableByteChannel接口，因此文件的内容可以用transferTo()方法传输给一个socket通道，或者也可以用transferFrom()方法将数据从一个socket通道直接读取到一个文件中。\n\n直接的通道传输不会更新与某个FileChannel关联的position值。请求的数据传输将从position参数指定的位置开始，传输的字节数不超过count参数的值。实际传输的字节数会由方法返回。\n\n直接通道传输的另一端如果是socket通道并且处于非阻塞模式的话，数据的传输将具有不确定性。比如，transferFrom从socket通道读取数据，如果socket中的数据尚未准备好，那么方法将直接返回。\n\n例子：\n\n```java\nRandomAccessFile fromFile = new RandomAccessFile(\"fromFile.txt\", \"rw\");\nFileChannel      fromChannel = fromFile.getChannel();\n\nRandomAccessFile toFile = new RandomAccessFile(\"toFile.txt\", \"rw\");\nFileChannel      toChannel = toFile.getChannel();\n\nlong position = 0;\nlong count    = fromChannel.size();\n\ntoChannel.transferFrom(fromChannel, position, count);\n\n\nRandomAccessFile fromFile = new RandomAccessFile(\"fromFile.txt\", \"rw\");\nFileChannel      fromChannel = fromFile.getChannel();\n\nRandomAccessFile toFile = new RandomAccessFile(\"toFile.txt\", \"rw\");\nFileChannel      toChannel = toFile.getChannel();\n\nlong position = 0;\nlong count    = fromChannel.size();\n\nfromChannel.transferTo(position, count, toChannel);\n```\n\n## 参考\n\n[Java nio入门教程详解](http://www.365mini.com/page/java-nio-course-17.htm)\n","source":"_posts/Java-NIO-Channel.md","raw":"---\nlayout: post\ntitle: Java-NIO-Channel\ndate: 2017-07-08 20:31:23\ncategories: 编程\ntags: java\n---\n> Java NIO 学习第三篇--Channel\n\n## Channel\n\n通道(Channel)的作用有类似于流(Stream)，用于传输文件或者网络上的数据。\n\n{% asset_img channel.png channel %}\n\n<!-- more -->\n\n上图中，箭头就相当于通道。一个不是很准确的例子：把通道想象成铁轨，缓冲区则是列车，铁轨的起始与终点则可以是socket，文件系统和我们的程序。假如当我们在代码中要写入数据到一份文件的时候，我们先把列车(缓冲区)装满，然后把列车(缓冲区)放置到铁轨上(通道)，数据就被传递到通道的另一端，文件系统。读取文件则相反，文件的内容被装到列车上，传递到程序这一侧，然后我们在代码中就可以读取这个列车中的内容(读取缓冲区)。\n\n通道与传统的流还是有一些区别的：\n\n- 通道可以同时支持读写(不是一定支持)，而流只支持单方向的操作，比如输入流只能读，输出流只能写。\n\n- 通道可以支持异步的读或写，而流是同步的。\n\n- 通道的读取或写入是通过缓冲区来进行的，而流则写入或返回字节。\n\n## FileChannel\n\n通道大致上可以分为两类：文件通道和socket通道。看一下文件通道：\n\n文件通道可以由以下几个方法获得：\n\n```java\nRandomAccessFile file = new RandomAccessFile(new File(fileName), \"rw\");\nFileChannel channel = file.getChannel();\n\nFileInputStream stream = new FileInputStream(new File(fileName));\nFileChannel channel = stream.getChannel();\n\nFileOutputStream stream = new FileOutputStream(new File(fileName));\nFileChannel channel = stream.getChannel();\n\nFileChannel channel = FileChannel.open(Paths.get(fileName));\n```\n\nFileChannel 类结构：\n\n{% asset_img filechannel.png Filechannel %}\n\n可见FileChannel实现了读写接口、聚集、发散接口，以及文件锁功能。下面会提到。\n\n看一下FileChannel的基本方法：\n\n```java\npublic abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {\n    // 这里仅列出部分API\n    public abstract long position()\n    public abstract void position (long newPosition)\n    public abstract int read (ByteBuffer dst)\n    public abstract int read (ByteBuffer dst, long position)\n    public abstract int write (ByteBuffer src)\n    public abstract int write (ByteBuffer src, long position)\n    public abstract long size()\n    public abstract void truncate (long size)\n    public abstract void force (boolean metaData)\n}\n```\n\n在通道出现之前，底层的文件操作都是通过RandomAccessFile类的方法来实现的。FileChannel模拟同样的 I/O 服务，因此它们的API自然也是很相似的。\n\n{% asset_img api.png Filechannel %}\n\n上图是FileChannel、RandomAccessFile 和 [POSIX I/O system calls](http://wiki.jikexueyuan.com/project/linux-process/posix.html) 三者在方法上的对应关系。\n\nPOSIX接口我们在上一篇文章中也略有提及，他是一个系统级别的接口。下面看一下这几个接口，主要也是和上一篇文章文件描述符的介绍做一个呼应。\n\n- position()和position(long newPosition)\n\nposition()返回当前文件的position值，position(long newPosition)将当前position设置为指定值。当字节被read()或write()方法传输时，文件position会自动更新。\n\nposition的含义与Buffer类中的position含义相似，都是指向下一个字节读取的位置。\n\n回想一下介绍文件描述符的文章当中提到，当进程打开一个文件时，内核就会创建一个新的file对象，这个file对象有一个字段loff_t f_pos描述了文件的当前位置，position相当于loff_t f_pos的映射。由此可知，如果是使用同一文件描述符读取文件，那么他们的position是相互影响的：\n\n```java\nRandomAccessFile file = new RandomAccessFile(new File(fileName), \"rw\");\nFileChannel channel = file.getChannel();\nSystem.out.println(\"position: \" + channel.position());\nfile.seek(30);\nSystem.out.println(\"position: \" + channel.position());\n```\n\n打印如下：\n\n```\nposition: 0\nposition: 30\n```\n\n这是因为，file与channel使用了同一个文件描述符。如果新建另一个相同文件的通道，那么他们之间的position不会相互影响，因为使用了不同的文件描述符，指向不同的file对象。\n\n- truncate(long size)\n\n当需要减少一个文件的size时，truncate()方法会砍掉指定的size值之外的所有数据。这个方法要求通道具有写权限。\n\n如果当前size大于给定size，超出给定size的所有字节都会被删除。如果提供的新size值大于或等于当前的文件size值，该文件不会被修改。\n\n```java\nRandomAccessFile file = new RandomAccessFile(new File(fileName), \"rw\");\nFileChannel channel = file.getChannel();\nSystem.out.println(\"size: \" + channel.size());\nSystem.out.println(\"position: \" + channel.position());\nSystem.out.println(\"trucate: 90\");\nchannel.truncate(90);\nSystem.out.println(\"size: \" + channel.size());\nSystem.out.println(\"position: \" + channel.position());\n```\n\n打印如下：\n\n```\nsize: 100\nposition: 0\ntrucate: 90\nsize: 90\nposition: 0\n```\n\n-  force (boolean metaData)\n\nforce()方法告诉通道强制将全部待定的修改都应用到磁盘的文件上。\n\n如果文件位于一个本地文件系统，那么一旦force()方法返回，即可保证从通道被创建(或上次调用force())时起的对文件所做的全部修改已经被写入到磁盘。但是，如果文件位于一个远程的文件系统，如NFS上，那么不能保证待定修改一定能同步到永久存储器。\n\nforce()方法的布尔型参数表示在方法返回值前文件的元数据(metadata)是否也要被同步更新到磁盘。元数据指文件所有者、访问权限、最后一次修改时间等信息。\n> Java NIO 学习第三篇--Channel\n\n## Channel\n\n通道(Channel)的作用有类似于流(Stream)，用于传输文件或者网络上的数据。\n\n{% asset_img channel.png channel %}\n\n上图中，箭头就相当于通道。一个不是很准确的例子：把通道想象成铁轨，缓冲区则是列车，铁轨的起始与终点则可以是socket，文件系统和我们的程序。假如当我们在代码中要写入数据到一份文件的时候，我们先把列车(缓冲区)装满，然后把列车(缓冲区)放置到铁轨上(通道)，数据就被传递到通道的另一端，文件系统。读取文件则相反，文件的内容被装到列车上，传递到程序这一侧，然后我们在代码中就可以读取这个列车中的内容(读取缓冲区)。\n\n通道与传统的流还是有一些区别的：\n\n- 通道可以同时支持读写(不是一定支持)，而流只支持单方向的操作，比如输入流只能读，输出流只能写。\n\n- 通道可以支持异步的读或写，而流是同步的。\n\n- 通道的读取或写入是通过缓冲区来进行的，而流则写入或返回字节。\n\n## [FileChannel](https://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html)\n\n通道大致上可以分为两类：文件通道和socket通道。看一下文件通道：\n\n文件通道可以由以下几个方法获得：\n\n```java\nRandomAccessFile file = new RandomAccessFile(new File(fileName), \"rw\");\nFileChannel channel = file.getChannel();\n\nFileInputStream stream = new FileInputStream(new File(fileName));\nFileChannel channel = stream.getChannel();\n\nFileOutputStream stream = new FileOutputStream(new File(fileName));\nFileChannel channel = stream.getChannel();\n\nFileChannel channel = FileChannel.open(Paths.get(fileName));\n```\n\nFileChannel 类结构：\n\n{% asset_img filechannel.png Filechannel %}\n\n可见FileChannel实现了读写接口、聚集、发散接口，以及文件锁功能。下面会提到。\n\n看一下FileChannel的基本方法：\n\n```java\npublic abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {\n    // 这里仅列出部分API\n    public abstract long position()\n    public abstract void position (long newPosition)\n    public abstract int read (ByteBuffer dst)\n    public abstract int read (ByteBuffer dst, long position)\n    public abstract int write (ByteBuffer src)\n    public abstract int write (ByteBuffer src, long position)\n    public abstract long size()\n    public abstract void truncate (long size)\n    public abstract void force (boolean metaData)\n}\n```\n\n在通道出现之前，底层的文件操作都是通过RandomAccessFile类的方法来实现的。FileChannel模拟同样的 I/O 服务，因此它们的API自然也是很相似的。\n\n{% asset_img api.png Filechannel %}\n\n上图是FileChannel、RandomAccessFile 和 [POSIX I/O system calls](http://wiki.jikexueyuan.com/project/linux-process/posix.html) 三者在方法上的对应关系。\n\nPOSIX接口我们在上一篇文章中也略有提及，他是一个系统级别的接口。下面看一下这几个接口，主要也是和上一篇文章文件描述符的介绍做一个呼应。\n\n- position()和position(long newPosition)\n\nposition()返回当前文件的position值，position(long newPosition)将当前position设置为指定值。当字节被read()或write()方法传输时，文件position会自动更新。\n\nposition的含义与Buffer类中的position含义相似，都是指向下一个字节读取的位置。\n\n回想一下介绍文件描述符的文章当中提到，当进程打开一个文件时，内核就会创建一个新的file对象，这个file对象有一个字段loff_t f_pos描述了文件的当前位置，position相当于loff_t f_pos的映射。由此可知，如果是使用同一文件描述符读取文件，那么他们的position是相互影响的：\n\n```java\nRandomAccessFile file = new RandomAccessFile(new File(fileName), \"rw\");\nFileChannel channel = file.getChannel();\nSystem.out.println(\"position: \" + channel.position());\nfile.seek(30);\nSystem.out.println(\"position: \" + channel.position());\n```\n\n打印如下：\n\n```\nposition: 0\nposition: 30\n```\n\n这是因为，file与channel使用了同一个文件描述符。如果新建另一个相同文件的通道，那么他们之间的position不会相互影响，因为使用了不同的文件描述符，指向不同的file对象。\n\n- truncate(long size)\n\n当需要减少一个文件的size时，truncate()方法会砍掉指定的size值之外的所有数据。这个方法要求通道具有写权限。\n\n如果当前size大于给定size，超出给定size的所有字节都会被删除。如果提供的新size值大于或等于当前的文件size值，该文件不会被修改。\n\n```java\nRandomAccessFile file = new RandomAccessFile(new File(fileName), \"rw\");\nFileChannel channel = file.getChannel();\nSystem.out.println(\"size: \" + channel.size());\nSystem.out.println(\"position: \" + channel.position());\nSystem.out.println(\"trucate: 90\");\nchannel.truncate(90);\nSystem.out.println(\"size: \" + channel.size());\nSystem.out.println(\"position: \" + channel.position());\n```\n\n打印如下：\n\n```\nsize: 100\nposition: 0\ntrucate: 90\nsize: 90\nposition: 0\n```\n\n-  force (boolean metaData)\n\nforce()方法告诉通道强制将全部待定的修改都应用到磁盘的文件上。\n\n如果文件位于一个本地文件系统，那么一旦force()方法返回，即可保证从通道被创建(或上次调用force())时起的对文件所做的全部修改已经被写入到磁盘。但是，如果文件位于一个远程的文件系统，如NFS上，那么不能保证待定修改一定能同步到永久存储器。\n\nforce()方法的布尔型参数表示在方法返回值前文件的元数据(metadata)是否也要被同步更新到磁盘。元数据指文件所有者、访问权限、最后一次修改时间等信息。\n\nFileChannel对象是线程安全的。如果有一个线程已经在执行会影响通道位置或文件大小的操作，那么其他尝试进行此类操作之一的线程必须等待。\n\n## ReadableByteChannel、WritableByteChannel\n\n通道可以是单向或者双向的。\n\n```java\npublic interface ReadableByteChannel extends Channel{\n    public int read (ByteBuffer dst) throws IOException;\n}\n\npublic interface WritableByteChannel extends Channel{\n    public int write (ByteBuffer src) throws IOException;\n}\n\npublic interface ByteChannel extends ReadableByteChannel, WritableByteChannel{\n}\n```\n\n{% asset_img bytechannel.png channel %}\n\n实现ReadableByteChannel或WritableByteChannel其中之一的channel是单向的，只可以读或者写。如果一个类同时实现了这两种接口，那么他就具备了双向传输的能力。\n\njava为我们提供了一个接口ByteChannel，同时继承了上述两个接口。所以，实现了ByteChannel接口的类可以读，也可以写。\n\n在**FlieChannel**这一节中我们知道，文件在不同的方式下以不同的权限打开。比如`FileInputStream.getChannel()`方法返回一个FileChannel实例，FileChannel是个抽象类，间接的实现了ByteChannel接口，也就意味着提供了read和write接口。但是`FileInputStream.getChannel()`方法返回的FileChannel实际上是只读的，很简单，因为FileInputStream本身就是个输入流啊~在这样一个通道上调用write方法将抛出NonWritableChannelException异常，因为FileInputStream对象总是以read-only的权限打开通道。看一下代码：\n\nFileInputStream.getChannel()\n\n```java\npublic FileChannel getChannel() {\n        synchronized (this) {\n            if (channel == null) {\n                // 第三个参数指定通道是否可读，第四个参数指定通道是否可写\n                channel = FileChannelImpl.open(fd, path, true, false, this);\n\n                /*\n                 * Increment fd's use count. Invoking the channel's close()\n                 * method will result in decrementing the use count set for\n                 * the channel.\n                 */\n                fd.incrementAndGetUseCount();\n            }\n            return channel;\n        }\n}\n```\n同样的，`FileOutputStream.getChannel()`返回的通道是不可读的。\n\n## InterruptibleChannel\n\nInterruptibleChannel是一个标记接口，当被通道使用时可以标示该通道是可以中断的。\n\n如果一个线程在一个通道上处于阻塞状态时被中断(另外一个线程调用该线程的interrupt()方法设置中断状态)，那么该通道将被关闭，该被阻塞线程也会产生一个ClosedByInterruptException异常。也就是说，假如一个线程的interrupt status被设置并且该线程试图访问一个通道，那么这个通道将立即被关闭，同时将抛出相同的ClosedByInterruptException异常。\n\n在[java任务取消](http://yukai.space/2017/05/02/java%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88/)中提到了，传统的java io 在读写时阻塞，是不会响应中断的。解决办法就是使用InterruptibleChannel，在线程被中断时可以关闭通道并返回。\n\n可中断的通道也是可以异步关闭。实现InterruptibleChannel接口的通道可以在任何时候被关闭，即使有另一个被阻塞的线程在等待该通道上的一个I/O操作完成。当一个通道被关闭时，休眠在该通道上的所有线程都将被唤醒并接收到一个AsynchronousCloseException异常。接着通道就被关闭并将不再可用。\n\n## Scatter/Gather\n\n发散(Scatter)读取是将数据读入多个缓冲区(缓冲区数组)的操作。通道将数据依次填满到每个缓冲区当中。\n\n汇聚(Gather)写出是将多个缓冲区(缓冲区数组)数据依次写入到通道的操作。\n\n在FileChannel中提到的两个接口，提供了发散汇聚的功能：\n\n```java\npublic interface ScatteringByteChannel extends ReadableByteChannel{\n    public long read (ByteBuffer[] dsts) throws IOException;\n    public long read (ByteBuffer[] dsts, int offset, int length) throws IOException;\n}\npublic interface GatheringByteChannel extends WritableByteChannel{\n    public long write(ByteBuffer[] srcs) throws IOException;\n    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException;\n}\n```\n\n发散汇聚在某些场景下是很有用的，比如有一个消息协议格式分为head和body(比如http协议)，我们在接收这样一个消息的时候，通常的做法是把数据一下子都读过来，然后解析他。使用通道的发散功能会使这个过程变得简单：\n\n```java\n// head数据128字节\nByteBuffer header = ByteBuffer.allocate(128);\n// body数据1024字节\nByteBuffer body   = ByteBuffer.allocate(1024);\n\nByteBuffer[] bufferArray = { header, body };\n\nchannel.read(bufferArray);\n```\n\n通道会依次填满这个buffer数组的每个buffer，如果一个buffer满了，就移动到下一个buffer。很自然的把head和body的数据分开了，但是要注意head和body的数据长度必须是固定的，因为channel只有填满一个buffer之后才会移动到下一个buffer。\n\n## FileLock\n\n摘抄一段oracle官网上FileLock的介绍吧，感觉说的挺清楚了。(因为懒，就不翻译了，读起来不是很费劲)\n\n>A token representing a lock on a region of a file.\n>A file-lock object is created each time a lock is acquired on a file via one of the lock or tryLock methods of the FileChannel class, or the lock or tryLock methods of the AsynchronousFileChannel class.\n>\n>A file-lock object is initially valid. It remains valid until the lock is released by invoking the release method, by closing the channel that was used to acquire it, or by the termination of the Java virtual machine, whichever comes first. The validity of a lock may be tested by invoking its >isValid method.\n>\n>A file lock is either exclusive or shared. A shared lock prevents other concurrently-running programs from acquiring an overlapping exclusive lock, but does allow them to acquire overlapping shared locks. An exclusive lock prevents other programs from acquiring an overlapping lock of either type. >Once it is released, a lock has no further effect on the locks that may be acquired by other programs.\n>\n>Whether a lock is exclusive or shared may be determined by invoking its isShared method. Some platforms do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.\n>\n>The locks held on a particular file by a single Java virtual machine do not overlap. The overlaps method may be used to test whether a candidate lock range overlaps an existing lock.\n>\n>A file-lock object records the file channel upon whose file the lock is held, the type and validity of the lock, and the position and size of the locked region. Only the validity of a lock is subject to change over time; all other aspects of a lock's state are immutable.\n>\n>File locks are held on behalf of the entire Java virtual machine. They are not suitable for controlling access to a file by multiple threads within the same virtual machine.\n>\n>File-lock objects are safe for use by multiple concurrent threads.\n>\n>**Platform dependencies**\n>\n>This file-locking API is intended to map directly to the native locking facility of the underlying operating system. Thus the locks held on a file should be visible to all programs that have access to the file, regardless of the language in which those programs are written.\n>\n>Whether or not a lock actually prevents another program from accessing the content of the locked region is system-dependent and therefore unspecified. The native file-locking facilities of some systems are merely advisory, meaning that programs must cooperatively observe a known locking protocol in >order to guarantee data integrity. On other systems native file locks are mandatory, meaning that if one program locks a region of a file then other programs are actually prevented from accessing that region in a way that would violate the lock. On yet other systems, whether native file locks are >advisory or mandatory is configurable on a per-file basis. To ensure consistent and correct behavior across platforms, it is strongly recommended that the locks provided by this API be used as if they were advisory locks.\n>\n>On some systems, acquiring a mandatory lock on a region of a file prevents that region from being mapped into memory, and vice versa. Programs that combine locking and mapping should be prepared for this combination to fail.\n>\n>On some systems, closing a channel releases all locks held by the Java virtual machine on the underlying file regardless of whether the locks were acquired via that channel or via another channel open on the same file. It is strongly recommended that, within a program, a unique channel be used to >acquire all locks on any given file.\n>\n>Some network filesystems permit file locking to be used with memory-mapped files only when the locked regions are page-aligned and a whole multiple of the underlying hardware's page size. Some network filesystems do not implement file locks on regions that extend past a certain position, often 230 >or 231. In general, great care should be taken when locking files that reside on network filesystems.\n\nFileLock可以由以下几个方法获得：\n\n```java\npublic abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {\n// 这里仅列出部分API\n    public final FileLock lock()\n    public abstract FileLock lock (long position, long size, boolean shared)\n    public final FileLock tryLock()\n    public abstract FileLock tryLock (long position, long size, boolean shared)\n}\n```\n\n其中，lock是阻塞的，tryLock是非阻塞的。position和size决定了锁定的区域，shared决定了文件锁是共享的还是独占的。\n\n不带参数的lock方法等价于`fileChannel.lock(0L, Long.MAX_VALUE, false)`，tryLock亦然。\n\nlock方法是响应中断的，当线程被中断时方法抛出FileLockInterruptionException异常。如果通道被另外一个线程关闭，该暂停线程将恢复并产生一个 AsynchronousCloseException异常。\n\n上面还提到了，文件锁是针对于进程级别的。如果有多个进程同时对一个文件锁定，并且其中有独占锁的话，这些锁的申请会被串行化。\n\n如果是同一个进程(Jvm实例)的多个线程同时请求同一个文件区域的lock的话，会抛出OverlappingFileLockException异常。\n\n## Channel-to-Channel\n\nFileChannel提供了接口，用于通道和通道之间的直接传输。\n\n```java\npublic abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {\n    // 这里仅列出部分API\n    public abstract long transferTo (long position, long count, WritableByteChannel target)\n    public abstract long transferFrom (ReadableByteChannel src, long position, long count)\n}\n```\n\n只有FileChannel类有这两个方法，因此Channel-to-Channel传输中通道之一必须是FileChannel。不能在socket通道之间直接传输数据，不过socket通道实现WritableByteChannel和ReadableByteChannel接口，因此文件的内容可以用transferTo()方法传输给一个socket通道，或者也可以用transferFrom()方法将数据从一个socket通道直接读取到一个文件中。\n\n直接的通道传输不会更新与某个FileChannel关联的position值。请求的数据传输将从position参数指定的位置开始，传输的字节数不超过count参数的值。实际传输的字节数会由方法返回。\n\n直接通道传输的另一端如果是socket通道并且处于非阻塞模式的话，数据的传输将具有不确定性。比如，transferFrom从socket通道读取数据，如果socket中的数据尚未准备好，那么方法将直接返回。\n\n例子：\n\n```java\nRandomAccessFile fromFile = new RandomAccessFile(\"fromFile.txt\", \"rw\");\nFileChannel      fromChannel = fromFile.getChannel();\n\nRandomAccessFile toFile = new RandomAccessFile(\"toFile.txt\", \"rw\");\nFileChannel      toChannel = toFile.getChannel();\n\nlong position = 0;\nlong count    = fromChannel.size();\n\ntoChannel.transferFrom(fromChannel, position, count);\n\n\nRandomAccessFile fromFile = new RandomAccessFile(\"fromFile.txt\", \"rw\");\nFileChannel      fromChannel = fromFile.getChannel();\n\nRandomAccessFile toFile = new RandomAccessFile(\"toFile.txt\", \"rw\");\nFileChannel      toChannel = toFile.getChannel();\n\nlong position = 0;\nlong count    = fromChannel.size();\n\nfromChannel.transferTo(position, count, toChannel);\n```\n\n## 参考\n\n[Java nio入门教程详解](http://www.365mini.com/page/java-nio-course-17.htm)\n\n## ReadableByteChannel、WritableByteChannel\n\n通道可以是单向或者双向的。\n\n```java\npublic interface ReadableByteChannel extends Channel{\n    public int read (ByteBuffer dst) throws IOException;\n}\n\npublic interface WritableByteChannel extends Channel{\n    public int write (ByteBuffer src) throws IOException;\n}\n\npublic interface ByteChannel extends ReadableByteChannel, WritableByteChannel{\n}\n```\n\n{% asset_img bytechannel.png channel %}\n\n实现ReadableByteChannel或WritableByteChannel其中之一的channel是单向的，只可以读或者写。如果一个类同时实现了这两种接口，那么他就具备了双向传输的能力。\n\njava为我们提供了一个接口ByteChannel，同时继承了上述两个接口。所以，实现了ByteChannel接口的类可以读，也可以写。\n\n在**FlieChannel**这一节中我们知道，文件在不同的方式下以不同的权限打开。比如`FileInputStream.getChannel()`方法返回一个FileChannel实例，FileChannel是个抽象类，间接的实现了ByteChannel接口，也就意味着提供了read和write接口。但是`FileInputStream.getChannel()`方法返回的FileChannel实际上是只读的，很简单，因为FileInputStream本身就是个输入流啊~在这样一个通道上调用write方法将抛出NonWritableChannelException异常，因为FileInputStream对象总是以read-only的权限打开通道。看一下代码：\n\nFileInputStream.getChannel()\n\n```java\npublic FileChannel getChannel() {\n        synchronized (this) {\n            if (channel == null) {\n                // 第三个参数指定通道是否可读，第四个参数指定通道是否可写\n                channel = FileChannelImpl.open(fd, path, true, false, this);\n\n                /*\n                 * Increment fd's use count. Invoking the channel's close()\n                 * method will result in decrementing the use count set for\n                 * the channel.\n                 */\n                fd.incrementAndGetUseCount();\n            }\n            return channel;\n        }\n}\n```\n同样的，`FileOutputStream.getChannel()`返回的通道是不可读的。\n\n## InterruptibleChannel\n\nInterruptibleChannel是一个标记接口，当被通道使用时可以标示该通道是可以中断的。\n\n如果一个线程在一个通道上处于阻塞状态时被中断(另外一个线程调用该线程的interrupt()方法设置中断状态)，那么该通道将被关闭，该被阻塞线程也会产生一个ClosedByInterruptException异常。也就是说，假如一个线程的interrupt status被设置并且该线程试图访问一个通道，那么这个通道将立即被关闭，同时将抛出相同的ClosedByInterruptException异常。\n\n在[java任务取消](http://yukai.space/2017/05/02/java%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88/)中提到了，传统的java io 在读写时阻塞，是不会响应中断的。解决办法就是使用InterruptibleChannel，在线程被中断时可以关闭通道并返回。\n\n可中断的通道也是可以异步关闭。实现InterruptibleChannel接口的通道可以在任何时候被关闭，即使有另一个被阻塞的线程在等待该通道上的一个I/O操作完成。当一个通道被关闭时，休眠在该通道上的所有线程都将被唤醒并接收到一个AsynchronousCloseException异常。接着通道就被关闭并将不再可用。\n\n## Scatter/Gather\n\n发散(Scatter)读取是将数据读入多个缓冲区(缓冲区数组)的操作。通道将数据依次填满到每个缓冲区当中。\n\n汇聚(Gather)写出是将多个缓冲区(缓冲区数组)数据依次写入到通道的操作。\n\n在FileChannel中提到的两个接口，提供了发散汇聚的功能：\n\n```java\npublic interface ScatteringByteChannel extends ReadableByteChannel{\n    public long read (ByteBuffer[] dsts) throws IOException;\n    public long read (ByteBuffer[] dsts, int offset, int length) throws IOException;\n}\npublic interface GatheringByteChannel extends WritableByteChannel{\n    public long write(ByteBuffer[] srcs) throws IOException;\n    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException;\n}\n```\n\n发散汇聚在某些场景下是很有用的，比如有一个消息协议格式分为head和body(比如http协议)，我们在接收这样一个消息的时候，通常的做法是把数据一下子都读过来，然后解析他。使用通道的发散功能会使这个过程变得简单：\n\n```java\n// head数据128字节\nByteBuffer header = ByteBuffer.allocate(128);\n// body数据1024字节\nByteBuffer body   = ByteBuffer.allocate(1024);\n\nByteBuffer[] bufferArray = { header, body };\n\nchannel.read(bufferArray);\n```\n\n通道会依次填满这个buffer数组的每个buffer，如果一个buffer满了，就移动到下一个buffer。很自然的把head和body的数据分开了，但是要注意head和body的数据长度必须是固定的，因为channel只有填满一个buffer之后才会移动到下一个buffer。\n\n## FileLock\n\n\n\n## Channel-to-Channel\n\nFileChannel提供了接口，用于通道和通道之间的直接传输。\n\n```java\npublic abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {\n    // 这里仅列出部分API\n    public abstract long transferTo (long position, long count, WritableByteChannel target)\n    public abstract long transferFrom (ReadableByteChannel src, long position, long count)\n}\n```\n\n只有FileChannel类有这两个方法，因此Channel-to-Channel传输中通道之一必须是FileChannel。不能在socket通道之间直接传输数据，不过socket通道实现WritableByteChannel和ReadableByteChannel接口，因此文件的内容可以用transferTo()方法传输给一个socket通道，或者也可以用transferFrom()方法将数据从一个socket通道直接读取到一个文件中。\n\n直接的通道传输不会更新与某个FileChannel关联的position值。请求的数据传输将从position参数指定的位置开始，传输的字节数不超过count参数的值。实际传输的字节数会由方法返回。\n\n直接通道传输的另一端如果是socket通道并且处于非阻塞模式的话，数据的传输将具有不确定性。比如，transferFrom从socket通道读取数据，如果socket中的数据尚未准备好，那么方法将直接返回。\n\n例子：\n\n```java\nRandomAccessFile fromFile = new RandomAccessFile(\"fromFile.txt\", \"rw\");\nFileChannel      fromChannel = fromFile.getChannel();\n\nRandomAccessFile toFile = new RandomAccessFile(\"toFile.txt\", \"rw\");\nFileChannel      toChannel = toFile.getChannel();\n\nlong position = 0;\nlong count    = fromChannel.size();\n\ntoChannel.transferFrom(fromChannel, position, count);\n\n\nRandomAccessFile fromFile = new RandomAccessFile(\"fromFile.txt\", \"rw\");\nFileChannel      fromChannel = fromFile.getChannel();\n\nRandomAccessFile toFile = new RandomAccessFile(\"toFile.txt\", \"rw\");\nFileChannel      toChannel = toFile.getChannel();\n\nlong position = 0;\nlong count    = fromChannel.size();\n\nfromChannel.transferTo(position, count, toChannel);\n```\n\n## 参考\n\n[Java nio入门教程详解](http://www.365mini.com/page/java-nio-course-17.htm)\n","slug":"Java-NIO-Channel","published":1,"updated":"2017-07-08T13:47:24.876Z","comments":1,"photos":[],"link":"","_id":"cj4vch4d0000bx3gcisiamfn0","content":"<blockquote>\n<p>Java NIO 学习第三篇–Channel</p>\n</blockquote>\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><p>通道(Channel)的作用有类似于流(Stream)，用于传输文件或者网络上的数据。</p>\n<img src=\"/2017/07/08/Java-NIO-Channel/channel.png\" alt=\"channel\" title=\"channel\">\n<a id=\"more\"></a>\n<p>上图中，箭头就相当于通道。一个不是很准确的例子：把通道想象成铁轨，缓冲区则是列车，铁轨的起始与终点则可以是socket，文件系统和我们的程序。假如当我们在代码中要写入数据到一份文件的时候，我们先把列车(缓冲区)装满，然后把列车(缓冲区)放置到铁轨上(通道)，数据就被传递到通道的另一端，文件系统。读取文件则相反，文件的内容被装到列车上，传递到程序这一侧，然后我们在代码中就可以读取这个列车中的内容(读取缓冲区)。</p>\n<p>通道与传统的流还是有一些区别的：</p>\n<ul>\n<li><p>通道可以同时支持读写(不是一定支持)，而流只支持单方向的操作，比如输入流只能读，输出流只能写。</p>\n</li>\n<li><p>通道可以支持异步的读或写，而流是同步的。</p>\n</li>\n<li><p>通道的读取或写入是通过缓冲区来进行的，而流则写入或返回字节。</p>\n</li>\n</ul>\n<h2 id=\"FileChannel\"><a href=\"#FileChannel\" class=\"headerlink\" title=\"FileChannel\"></a>FileChannel</h2><p>通道大致上可以分为两类：文件通道和socket通道。看一下文件通道：</p>\n<p>文件通道可以由以下几个方法获得：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile file = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"keyword\">new</span> File(fileName), <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel channel = file.getChannel();</div><div class=\"line\"></div><div class=\"line\">FileInputStream stream = <span class=\"keyword\">new</span> FileInputStream(<span class=\"keyword\">new</span> File(fileName));</div><div class=\"line\">FileChannel channel = stream.getChannel();</div><div class=\"line\"></div><div class=\"line\">FileOutputStream stream = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"keyword\">new</span> File(fileName));</div><div class=\"line\">FileChannel channel = stream.getChannel();</div><div class=\"line\"></div><div class=\"line\">FileChannel channel = FileChannel.open(Paths.get(fileName));</div></pre></td></tr></table></figure>\n<p>FileChannel 类结构：</p>\n<img src=\"/2017/07/08/Java-NIO-Channel/filechannel.png\" alt=\"Filechannel\" title=\"Filechannel\">\n<p>可见FileChannel实现了读写接口、聚集、发散接口，以及文件锁功能。下面会提到。</p>\n<p>看一下FileChannel的基本方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractChannel</span> <span class=\"keyword\">implements</span> <span class=\"title\">ByteChannel</span>, <span class=\"title\">GatheringByteChannel</span>, <span class=\"title\">ScatteringByteChannel</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">position</span><span class=\"params\">()</span></span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">position</span> <span class=\"params\">(<span class=\"keyword\">long</span> newPosition)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer dst)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer dst, <span class=\"keyword\">long</span> position)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">write</span> <span class=\"params\">(ByteBuffer src)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">write</span> <span class=\"params\">(ByteBuffer src, <span class=\"keyword\">long</span> position)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">size</span><span class=\"params\">()</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">truncate</span> <span class=\"params\">(<span class=\"keyword\">long</span> size)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">force</span> <span class=\"params\">(<span class=\"keyword\">boolean</span> metaData)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在通道出现之前，底层的文件操作都是通过RandomAccessFile类的方法来实现的。FileChannel模拟同样的 I/O 服务，因此它们的API自然也是很相似的。</p>\n<img src=\"/2017/07/08/Java-NIO-Channel/api.png\" alt=\"Filechannel\" title=\"Filechannel\">\n<p>上图是FileChannel、RandomAccessFile 和 <a href=\"http://wiki.jikexueyuan.com/project/linux-process/posix.html\" target=\"_blank\" rel=\"external\">POSIX I/O system calls</a> 三者在方法上的对应关系。</p>\n<p>POSIX接口我们在上一篇文章中也略有提及，他是一个系统级别的接口。下面看一下这几个接口，主要也是和上一篇文章文件描述符的介绍做一个呼应。</p>\n<ul>\n<li>position()和position(long newPosition)</li>\n</ul>\n<p>position()返回当前文件的position值，position(long newPosition)将当前position设置为指定值。当字节被read()或write()方法传输时，文件position会自动更新。</p>\n<p>position的含义与Buffer类中的position含义相似，都是指向下一个字节读取的位置。</p>\n<p>回想一下介绍文件描述符的文章当中提到，当进程打开一个文件时，内核就会创建一个新的file对象，这个file对象有一个字段loff_t f_pos描述了文件的当前位置，position相当于loff_t f_pos的映射。由此可知，如果是使用同一文件描述符读取文件，那么他们的position是相互影响的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile file = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"keyword\">new</span> File(fileName), <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel channel = file.getChannel();</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div><div class=\"line\">file.seek(<span class=\"number\">30</span>);</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">position: 0</div><div class=\"line\">position: 30</div></pre></td></tr></table></figure>\n<p>这是因为，file与channel使用了同一个文件描述符。如果新建另一个相同文件的通道，那么他们之间的position不会相互影响，因为使用了不同的文件描述符，指向不同的file对象。</p>\n<ul>\n<li>truncate(long size)</li>\n</ul>\n<p>当需要减少一个文件的size时，truncate()方法会砍掉指定的size值之外的所有数据。这个方法要求通道具有写权限。</p>\n<p>如果当前size大于给定size，超出给定size的所有字节都会被删除。如果提供的新size值大于或等于当前的文件size值，该文件不会被修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile file = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"keyword\">new</span> File(fileName), <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel channel = file.getChannel();</div><div class=\"line\">System.out.println(<span class=\"string\">\"size: \"</span> + channel.size());</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div><div class=\"line\">System.out.println(<span class=\"string\">\"trucate: 90\"</span>);</div><div class=\"line\">channel.truncate(<span class=\"number\">90</span>);</div><div class=\"line\">System.out.println(<span class=\"string\">\"size: \"</span> + channel.size());</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">size: 100</div><div class=\"line\">position: 0</div><div class=\"line\">trucate: 90</div><div class=\"line\">size: 90</div><div class=\"line\">position: 0</div></pre></td></tr></table></figure>\n<ul>\n<li>force (boolean metaData)</li>\n</ul>\n<p>force()方法告诉通道强制将全部待定的修改都应用到磁盘的文件上。</p>\n<p>如果文件位于一个本地文件系统，那么一旦force()方法返回，即可保证从通道被创建(或上次调用force())时起的对文件所做的全部修改已经被写入到磁盘。但是，如果文件位于一个远程的文件系统，如NFS上，那么不能保证待定修改一定能同步到永久存储器。</p>\n<p>force()方法的布尔型参数表示在方法返回值前文件的元数据(metadata)是否也要被同步更新到磁盘。元数据指文件所有者、访问权限、最后一次修改时间等信息。</p>\n<blockquote>\n<p>Java NIO 学习第三篇–Channel</p>\n</blockquote>\n<h2 id=\"Channel-1\"><a href=\"#Channel-1\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><p>通道(Channel)的作用有类似于流(Stream)，用于传输文件或者网络上的数据。</p>\n<img src=\"/2017/07/08/Java-NIO-Channel/channel.png\" alt=\"channel\" title=\"channel\">\n<p>上图中，箭头就相当于通道。一个不是很准确的例子：把通道想象成铁轨，缓冲区则是列车，铁轨的起始与终点则可以是socket，文件系统和我们的程序。假如当我们在代码中要写入数据到一份文件的时候，我们先把列车(缓冲区)装满，然后把列车(缓冲区)放置到铁轨上(通道)，数据就被传递到通道的另一端，文件系统。读取文件则相反，文件的内容被装到列车上，传递到程序这一侧，然后我们在代码中就可以读取这个列车中的内容(读取缓冲区)。</p>\n<p>通道与传统的流还是有一些区别的：</p>\n<ul>\n<li><p>通道可以同时支持读写(不是一定支持)，而流只支持单方向的操作，比如输入流只能读，输出流只能写。</p>\n</li>\n<li><p>通道可以支持异步的读或写，而流是同步的。</p>\n</li>\n<li><p>通道的读取或写入是通过缓冲区来进行的，而流则写入或返回字节。</p>\n</li>\n</ul>\n<h2 id=\"FileChannel-1\"><a href=\"#FileChannel-1\" class=\"headerlink\" title=\"FileChannel\"></a><a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html\" target=\"_blank\" rel=\"external\">FileChannel</a></h2><p>通道大致上可以分为两类：文件通道和socket通道。看一下文件通道：</p>\n<p>文件通道可以由以下几个方法获得：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile file = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"keyword\">new</span> File(fileName), <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel channel = file.getChannel();</div><div class=\"line\"></div><div class=\"line\">FileInputStream stream = <span class=\"keyword\">new</span> FileInputStream(<span class=\"keyword\">new</span> File(fileName));</div><div class=\"line\">FileChannel channel = stream.getChannel();</div><div class=\"line\"></div><div class=\"line\">FileOutputStream stream = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"keyword\">new</span> File(fileName));</div><div class=\"line\">FileChannel channel = stream.getChannel();</div><div class=\"line\"></div><div class=\"line\">FileChannel channel = FileChannel.open(Paths.get(fileName));</div></pre></td></tr></table></figure>\n<p>FileChannel 类结构：</p>\n<img src=\"/2017/07/08/Java-NIO-Channel/filechannel.png\" alt=\"Filechannel\" title=\"Filechannel\">\n<p>可见FileChannel实现了读写接口、聚集、发散接口，以及文件锁功能。下面会提到。</p>\n<p>看一下FileChannel的基本方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractChannel</span> <span class=\"keyword\">implements</span> <span class=\"title\">ByteChannel</span>, <span class=\"title\">GatheringByteChannel</span>, <span class=\"title\">ScatteringByteChannel</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">position</span><span class=\"params\">()</span></span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">position</span> <span class=\"params\">(<span class=\"keyword\">long</span> newPosition)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer dst)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer dst, <span class=\"keyword\">long</span> position)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">write</span> <span class=\"params\">(ByteBuffer src)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">write</span> <span class=\"params\">(ByteBuffer src, <span class=\"keyword\">long</span> position)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">size</span><span class=\"params\">()</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">truncate</span> <span class=\"params\">(<span class=\"keyword\">long</span> size)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">force</span> <span class=\"params\">(<span class=\"keyword\">boolean</span> metaData)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在通道出现之前，底层的文件操作都是通过RandomAccessFile类的方法来实现的。FileChannel模拟同样的 I/O 服务，因此它们的API自然也是很相似的。</p>\n<img src=\"/2017/07/08/Java-NIO-Channel/api.png\" alt=\"Filechannel\" title=\"Filechannel\">\n<p>上图是FileChannel、RandomAccessFile 和 <a href=\"http://wiki.jikexueyuan.com/project/linux-process/posix.html\" target=\"_blank\" rel=\"external\">POSIX I/O system calls</a> 三者在方法上的对应关系。</p>\n<p>POSIX接口我们在上一篇文章中也略有提及，他是一个系统级别的接口。下面看一下这几个接口，主要也是和上一篇文章文件描述符的介绍做一个呼应。</p>\n<ul>\n<li>position()和position(long newPosition)</li>\n</ul>\n<p>position()返回当前文件的position值，position(long newPosition)将当前position设置为指定值。当字节被read()或write()方法传输时，文件position会自动更新。</p>\n<p>position的含义与Buffer类中的position含义相似，都是指向下一个字节读取的位置。</p>\n<p>回想一下介绍文件描述符的文章当中提到，当进程打开一个文件时，内核就会创建一个新的file对象，这个file对象有一个字段loff_t f_pos描述了文件的当前位置，position相当于loff_t f_pos的映射。由此可知，如果是使用同一文件描述符读取文件，那么他们的position是相互影响的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile file = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"keyword\">new</span> File(fileName), <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel channel = file.getChannel();</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div><div class=\"line\">file.seek(<span class=\"number\">30</span>);</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">position: 0</div><div class=\"line\">position: 30</div></pre></td></tr></table></figure>\n<p>这是因为，file与channel使用了同一个文件描述符。如果新建另一个相同文件的通道，那么他们之间的position不会相互影响，因为使用了不同的文件描述符，指向不同的file对象。</p>\n<ul>\n<li>truncate(long size)</li>\n</ul>\n<p>当需要减少一个文件的size时，truncate()方法会砍掉指定的size值之外的所有数据。这个方法要求通道具有写权限。</p>\n<p>如果当前size大于给定size，超出给定size的所有字节都会被删除。如果提供的新size值大于或等于当前的文件size值，该文件不会被修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile file = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"keyword\">new</span> File(fileName), <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel channel = file.getChannel();</div><div class=\"line\">System.out.println(<span class=\"string\">\"size: \"</span> + channel.size());</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div><div class=\"line\">System.out.println(<span class=\"string\">\"trucate: 90\"</span>);</div><div class=\"line\">channel.truncate(<span class=\"number\">90</span>);</div><div class=\"line\">System.out.println(<span class=\"string\">\"size: \"</span> + channel.size());</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">size: 100</div><div class=\"line\">position: 0</div><div class=\"line\">trucate: 90</div><div class=\"line\">size: 90</div><div class=\"line\">position: 0</div></pre></td></tr></table></figure>\n<ul>\n<li>force (boolean metaData)</li>\n</ul>\n<p>force()方法告诉通道强制将全部待定的修改都应用到磁盘的文件上。</p>\n<p>如果文件位于一个本地文件系统，那么一旦force()方法返回，即可保证从通道被创建(或上次调用force())时起的对文件所做的全部修改已经被写入到磁盘。但是，如果文件位于一个远程的文件系统，如NFS上，那么不能保证待定修改一定能同步到永久存储器。</p>\n<p>force()方法的布尔型参数表示在方法返回值前文件的元数据(metadata)是否也要被同步更新到磁盘。元数据指文件所有者、访问权限、最后一次修改时间等信息。</p>\n<p>FileChannel对象是线程安全的。如果有一个线程已经在执行会影响通道位置或文件大小的操作，那么其他尝试进行此类操作之一的线程必须等待。</p>\n<h2 id=\"ReadableByteChannel、WritableByteChannel\"><a href=\"#ReadableByteChannel、WritableByteChannel\" class=\"headerlink\" title=\"ReadableByteChannel、WritableByteChannel\"></a>ReadableByteChannel、WritableByteChannel</h2><p>通道可以是单向或者双向的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ReadableByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">Channel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer dst)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WritableByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">Channel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">write</span> <span class=\"params\">(ByteBuffer src)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReadableByteChannel</span>, <span class=\"title\">WritableByteChannel</span></span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<img src=\"/2017/07/08/Java-NIO-Channel/bytechannel.png\" alt=\"channel\" title=\"channel\">\n<p>实现ReadableByteChannel或WritableByteChannel其中之一的channel是单向的，只可以读或者写。如果一个类同时实现了这两种接口，那么他就具备了双向传输的能力。</p>\n<p>java为我们提供了一个接口ByteChannel，同时继承了上述两个接口。所以，实现了ByteChannel接口的类可以读，也可以写。</p>\n<p>在<strong>FlieChannel</strong>这一节中我们知道，文件在不同的方式下以不同的权限打开。比如<code>FileInputStream.getChannel()</code>方法返回一个FileChannel实例，FileChannel是个抽象类，间接的实现了ByteChannel接口，也就意味着提供了read和write接口。但是<code>FileInputStream.getChannel()</code>方法返回的FileChannel实际上是只读的，很简单，因为FileInputStream本身就是个输入流啊~在这样一个通道上调用write方法将抛出NonWritableChannelException异常，因为FileInputStream对象总是以read-only的权限打开通道。看一下代码：</p>\n<p>FileInputStream.getChannel()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FileChannel <span class=\"title\">getChannel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (channel == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// 第三个参数指定通道是否可读，第四个参数指定通道是否可写</span></div><div class=\"line\">                channel = FileChannelImpl.open(fd, path, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">/*</span></div><div class=\"line\">                 * Increment fd's use count. Invoking the channel's close()</div><div class=\"line\">                 * method will result in decrementing the use count set for</div><div class=\"line\">                 * the channel.</div><div class=\"line\">                 */</div><div class=\"line\">                fd.incrementAndGetUseCount();</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> channel;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，<code>FileOutputStream.getChannel()</code>返回的通道是不可读的。</p>\n<h2 id=\"InterruptibleChannel\"><a href=\"#InterruptibleChannel\" class=\"headerlink\" title=\"InterruptibleChannel\"></a>InterruptibleChannel</h2><p>InterruptibleChannel是一个标记接口，当被通道使用时可以标示该通道是可以中断的。</p>\n<p>如果一个线程在一个通道上处于阻塞状态时被中断(另外一个线程调用该线程的interrupt()方法设置中断状态)，那么该通道将被关闭，该被阻塞线程也会产生一个ClosedByInterruptException异常。也就是说，假如一个线程的interrupt status被设置并且该线程试图访问一个通道，那么这个通道将立即被关闭，同时将抛出相同的ClosedByInterruptException异常。</p>\n<p>在<a href=\"http://yukai.space/2017/05/02/java%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88/\">java任务取消</a>中提到了，传统的java io 在读写时阻塞，是不会响应中断的。解决办法就是使用InterruptibleChannel，在线程被中断时可以关闭通道并返回。</p>\n<p>可中断的通道也是可以异步关闭。实现InterruptibleChannel接口的通道可以在任何时候被关闭，即使有另一个被阻塞的线程在等待该通道上的一个I/O操作完成。当一个通道被关闭时，休眠在该通道上的所有线程都将被唤醒并接收到一个AsynchronousCloseException异常。接着通道就被关闭并将不再可用。</p>\n<h2 id=\"Scatter-Gather\"><a href=\"#Scatter-Gather\" class=\"headerlink\" title=\"Scatter/Gather\"></a>Scatter/Gather</h2><p>发散(Scatter)读取是将数据读入多个缓冲区(缓冲区数组)的操作。通道将数据依次填满到每个缓冲区当中。</p>\n<p>汇聚(Gather)写出是将多个缓冲区(缓冲区数组)数据依次写入到通道的操作。</p>\n<p>在FileChannel中提到的两个接口，提供了发散汇聚的功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ScatteringByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReadableByteChannel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer[] dsts)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer[] dsts, <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> length)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GatheringByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">WritableByteChannel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">write</span><span class=\"params\">(ByteBuffer[] srcs)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">write</span><span class=\"params\">(ByteBuffer[] srcs, <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> length)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>发散汇聚在某些场景下是很有用的，比如有一个消息协议格式分为head和body(比如http协议)，我们在接收这样一个消息的时候，通常的做法是把数据一下子都读过来，然后解析他。使用通道的发散功能会使这个过程变得简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// head数据128字节</span></div><div class=\"line\">ByteBuffer header = ByteBuffer.allocate(<span class=\"number\">128</span>);</div><div class=\"line\"><span class=\"comment\">// body数据1024字节</span></div><div class=\"line\">ByteBuffer body   = ByteBuffer.allocate(<span class=\"number\">1024</span>);</div><div class=\"line\"></div><div class=\"line\">ByteBuffer[] bufferArray = &#123; header, body &#125;;</div><div class=\"line\"></div><div class=\"line\">channel.read(bufferArray);</div></pre></td></tr></table></figure>\n<p>通道会依次填满这个buffer数组的每个buffer，如果一个buffer满了，就移动到下一个buffer。很自然的把head和body的数据分开了，但是要注意head和body的数据长度必须是固定的，因为channel只有填满一个buffer之后才会移动到下一个buffer。</p>\n<h2 id=\"FileLock\"><a href=\"#FileLock\" class=\"headerlink\" title=\"FileLock\"></a>FileLock</h2><p>摘抄一段oracle官网上FileLock的介绍吧，感觉说的挺清楚了。(因为懒，就不翻译了，读起来不是很费劲)</p>\n<blockquote>\n<p>A token representing a lock on a region of a file.<br>A file-lock object is created each time a lock is acquired on a file via one of the lock or tryLock methods of the FileChannel class, or the lock or tryLock methods of the AsynchronousFileChannel class.</p>\n<p>A file-lock object is initially valid. It remains valid until the lock is released by invoking the release method, by closing the channel that was used to acquire it, or by the termination of the Java virtual machine, whichever comes first. The validity of a lock may be tested by invoking its &gt;isValid method.</p>\n<p>A file lock is either exclusive or shared. A shared lock prevents other concurrently-running programs from acquiring an overlapping exclusive lock, but does allow them to acquire overlapping shared locks. An exclusive lock prevents other programs from acquiring an overlapping lock of either type. &gt;Once it is released, a lock has no further effect on the locks that may be acquired by other programs.</p>\n<p>Whether a lock is exclusive or shared may be determined by invoking its isShared method. Some platforms do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.</p>\n<p>The locks held on a particular file by a single Java virtual machine do not overlap. The overlaps method may be used to test whether a candidate lock range overlaps an existing lock.</p>\n<p>A file-lock object records the file channel upon whose file the lock is held, the type and validity of the lock, and the position and size of the locked region. Only the validity of a lock is subject to change over time; all other aspects of a lock’s state are immutable.</p>\n<p>File locks are held on behalf of the entire Java virtual machine. They are not suitable for controlling access to a file by multiple threads within the same virtual machine.</p>\n<p>File-lock objects are safe for use by multiple concurrent threads.</p>\n<p><strong>Platform dependencies</strong></p>\n<p>This file-locking API is intended to map directly to the native locking facility of the underlying operating system. Thus the locks held on a file should be visible to all programs that have access to the file, regardless of the language in which those programs are written.</p>\n<p>Whether or not a lock actually prevents another program from accessing the content of the locked region is system-dependent and therefore unspecified. The native file-locking facilities of some systems are merely advisory, meaning that programs must cooperatively observe a known locking protocol in &gt;order to guarantee data integrity. On other systems native file locks are mandatory, meaning that if one program locks a region of a file then other programs are actually prevented from accessing that region in a way that would violate the lock. On yet other systems, whether native file locks are &gt;advisory or mandatory is configurable on a per-file basis. To ensure consistent and correct behavior across platforms, it is strongly recommended that the locks provided by this API be used as if they were advisory locks.</p>\n<p>On some systems, acquiring a mandatory lock on a region of a file prevents that region from being mapped into memory, and vice versa. Programs that combine locking and mapping should be prepared for this combination to fail.</p>\n<p>On some systems, closing a channel releases all locks held by the Java virtual machine on the underlying file regardless of whether the locks were acquired via that channel or via another channel open on the same file. It is strongly recommended that, within a program, a unique channel be used to &gt;acquire all locks on any given file.</p>\n<p>Some network filesystems permit file locking to be used with memory-mapped files only when the locked regions are page-aligned and a whole multiple of the underlying hardware’s page size. Some network filesystems do not implement file locks on regions that extend past a certain position, often 230 &gt;or 231. In general, great care should be taken when locking files that reside on network filesystems.</p>\n</blockquote>\n<p>FileLock可以由以下几个方法获得：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractChannel</span> <span class=\"keyword\">implements</span> <span class=\"title\">ByteChannel</span>, <span class=\"title\">GatheringByteChannel</span>, <span class=\"title\">ScatteringByteChannel</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> FileLock <span class=\"title\">lock</span><span class=\"params\">()</span></span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> FileLock <span class=\"title\">lock</span> <span class=\"params\">(<span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> size, <span class=\"keyword\">boolean</span> shared)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> FileLock <span class=\"title\">tryLock</span><span class=\"params\">()</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> FileLock <span class=\"title\">tryLock</span> <span class=\"params\">(<span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> size, <span class=\"keyword\">boolean</span> shared)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，lock是阻塞的，tryLock是非阻塞的。position和size决定了锁定的区域，shared决定了文件锁是共享的还是独占的。</p>\n<p>不带参数的lock方法等价于<code>fileChannel.lock(0L, Long.MAX_VALUE, false)</code>，tryLock亦然。</p>\n<p>lock方法是响应中断的，当线程被中断时方法抛出FileLockInterruptionException异常。如果通道被另外一个线程关闭，该暂停线程将恢复并产生一个 AsynchronousCloseException异常。</p>\n<p>上面还提到了，文件锁是针对于进程级别的。如果有多个进程同时对一个文件锁定，并且其中有独占锁的话，这些锁的申请会被串行化。</p>\n<p>如果是同一个进程(Jvm实例)的多个线程同时请求同一个文件区域的lock的话，会抛出OverlappingFileLockException异常。</p>\n<h2 id=\"Channel-to-Channel\"><a href=\"#Channel-to-Channel\" class=\"headerlink\" title=\"Channel-to-Channel\"></a>Channel-to-Channel</h2><p>FileChannel提供了接口，用于通道和通道之间的直接传输。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractChannel</span> <span class=\"keyword\">implements</span> <span class=\"title\">ByteChannel</span>, <span class=\"title\">GatheringByteChannel</span>, <span class=\"title\">ScatteringByteChannel</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">transferTo</span> <span class=\"params\">(<span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> count, WritableByteChannel target)</span></span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">transferFrom</span> <span class=\"params\">(ReadableByteChannel src, <span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> count)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>只有FileChannel类有这两个方法，因此Channel-to-Channel传输中通道之一必须是FileChannel。不能在socket通道之间直接传输数据，不过socket通道实现WritableByteChannel和ReadableByteChannel接口，因此文件的内容可以用transferTo()方法传输给一个socket通道，或者也可以用transferFrom()方法将数据从一个socket通道直接读取到一个文件中。</p>\n<p>直接的通道传输不会更新与某个FileChannel关联的position值。请求的数据传输将从position参数指定的位置开始，传输的字节数不超过count参数的值。实际传输的字节数会由方法返回。</p>\n<p>直接通道传输的另一端如果是socket通道并且处于非阻塞模式的话，数据的传输将具有不确定性。比如，transferFrom从socket通道读取数据，如果socket中的数据尚未准备好，那么方法将直接返回。</p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile fromFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"fromFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      fromChannel = fromFile.getChannel();</div><div class=\"line\"></div><div class=\"line\">RandomAccessFile toFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"toFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      toChannel = toFile.getChannel();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">long</span> position = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">long</span> count    = fromChannel.size();</div><div class=\"line\"></div><div class=\"line\">toChannel.transferFrom(fromChannel, position, count);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">RandomAccessFile fromFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"fromFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      fromChannel = fromFile.getChannel();</div><div class=\"line\"></div><div class=\"line\">RandomAccessFile toFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"toFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      toChannel = toFile.getChannel();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">long</span> position = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">long</span> count    = fromChannel.size();</div><div class=\"line\"></div><div class=\"line\">fromChannel.transferTo(position, count, toChannel);</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.365mini.com/page/java-nio-course-17.htm\" target=\"_blank\" rel=\"external\">Java nio入门教程详解</a></p>\n<h2 id=\"ReadableByteChannel、WritableByteChannel-1\"><a href=\"#ReadableByteChannel、WritableByteChannel-1\" class=\"headerlink\" title=\"ReadableByteChannel、WritableByteChannel\"></a>ReadableByteChannel、WritableByteChannel</h2><p>通道可以是单向或者双向的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ReadableByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">Channel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer dst)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WritableByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">Channel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">write</span> <span class=\"params\">(ByteBuffer src)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReadableByteChannel</span>, <span class=\"title\">WritableByteChannel</span></span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<img src=\"/2017/07/08/Java-NIO-Channel/bytechannel.png\" alt=\"channel\" title=\"channel\">\n<p>实现ReadableByteChannel或WritableByteChannel其中之一的channel是单向的，只可以读或者写。如果一个类同时实现了这两种接口，那么他就具备了双向传输的能力。</p>\n<p>java为我们提供了一个接口ByteChannel，同时继承了上述两个接口。所以，实现了ByteChannel接口的类可以读，也可以写。</p>\n<p>在<strong>FlieChannel</strong>这一节中我们知道，文件在不同的方式下以不同的权限打开。比如<code>FileInputStream.getChannel()</code>方法返回一个FileChannel实例，FileChannel是个抽象类，间接的实现了ByteChannel接口，也就意味着提供了read和write接口。但是<code>FileInputStream.getChannel()</code>方法返回的FileChannel实际上是只读的，很简单，因为FileInputStream本身就是个输入流啊~在这样一个通道上调用write方法将抛出NonWritableChannelException异常，因为FileInputStream对象总是以read-only的权限打开通道。看一下代码：</p>\n<p>FileInputStream.getChannel()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FileChannel <span class=\"title\">getChannel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (channel == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// 第三个参数指定通道是否可读，第四个参数指定通道是否可写</span></div><div class=\"line\">                channel = FileChannelImpl.open(fd, path, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">/*</span></div><div class=\"line\">                 * Increment fd's use count. Invoking the channel's close()</div><div class=\"line\">                 * method will result in decrementing the use count set for</div><div class=\"line\">                 * the channel.</div><div class=\"line\">                 */</div><div class=\"line\">                fd.incrementAndGetUseCount();</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> channel;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，<code>FileOutputStream.getChannel()</code>返回的通道是不可读的。</p>\n<h2 id=\"InterruptibleChannel-1\"><a href=\"#InterruptibleChannel-1\" class=\"headerlink\" title=\"InterruptibleChannel\"></a>InterruptibleChannel</h2><p>InterruptibleChannel是一个标记接口，当被通道使用时可以标示该通道是可以中断的。</p>\n<p>如果一个线程在一个通道上处于阻塞状态时被中断(另外一个线程调用该线程的interrupt()方法设置中断状态)，那么该通道将被关闭，该被阻塞线程也会产生一个ClosedByInterruptException异常。也就是说，假如一个线程的interrupt status被设置并且该线程试图访问一个通道，那么这个通道将立即被关闭，同时将抛出相同的ClosedByInterruptException异常。</p>\n<p>在<a href=\"http://yukai.space/2017/05/02/java%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88/\">java任务取消</a>中提到了，传统的java io 在读写时阻塞，是不会响应中断的。解决办法就是使用InterruptibleChannel，在线程被中断时可以关闭通道并返回。</p>\n<p>可中断的通道也是可以异步关闭。实现InterruptibleChannel接口的通道可以在任何时候被关闭，即使有另一个被阻塞的线程在等待该通道上的一个I/O操作完成。当一个通道被关闭时，休眠在该通道上的所有线程都将被唤醒并接收到一个AsynchronousCloseException异常。接着通道就被关闭并将不再可用。</p>\n<h2 id=\"Scatter-Gather-1\"><a href=\"#Scatter-Gather-1\" class=\"headerlink\" title=\"Scatter/Gather\"></a>Scatter/Gather</h2><p>发散(Scatter)读取是将数据读入多个缓冲区(缓冲区数组)的操作。通道将数据依次填满到每个缓冲区当中。</p>\n<p>汇聚(Gather)写出是将多个缓冲区(缓冲区数组)数据依次写入到通道的操作。</p>\n<p>在FileChannel中提到的两个接口，提供了发散汇聚的功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ScatteringByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReadableByteChannel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer[] dsts)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer[] dsts, <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> length)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GatheringByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">WritableByteChannel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">write</span><span class=\"params\">(ByteBuffer[] srcs)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">write</span><span class=\"params\">(ByteBuffer[] srcs, <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> length)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>发散汇聚在某些场景下是很有用的，比如有一个消息协议格式分为head和body(比如http协议)，我们在接收这样一个消息的时候，通常的做法是把数据一下子都读过来，然后解析他。使用通道的发散功能会使这个过程变得简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// head数据128字节</span></div><div class=\"line\">ByteBuffer header = ByteBuffer.allocate(<span class=\"number\">128</span>);</div><div class=\"line\"><span class=\"comment\">// body数据1024字节</span></div><div class=\"line\">ByteBuffer body   = ByteBuffer.allocate(<span class=\"number\">1024</span>);</div><div class=\"line\"></div><div class=\"line\">ByteBuffer[] bufferArray = &#123; header, body &#125;;</div><div class=\"line\"></div><div class=\"line\">channel.read(bufferArray);</div></pre></td></tr></table></figure>\n<p>通道会依次填满这个buffer数组的每个buffer，如果一个buffer满了，就移动到下一个buffer。很自然的把head和body的数据分开了，但是要注意head和body的数据长度必须是固定的，因为channel只有填满一个buffer之后才会移动到下一个buffer。</p>\n<h2 id=\"FileLock-1\"><a href=\"#FileLock-1\" class=\"headerlink\" title=\"FileLock\"></a>FileLock</h2><h2 id=\"Channel-to-Channel-1\"><a href=\"#Channel-to-Channel-1\" class=\"headerlink\" title=\"Channel-to-Channel\"></a>Channel-to-Channel</h2><p>FileChannel提供了接口，用于通道和通道之间的直接传输。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractChannel</span> <span class=\"keyword\">implements</span> <span class=\"title\">ByteChannel</span>, <span class=\"title\">GatheringByteChannel</span>, <span class=\"title\">ScatteringByteChannel</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">transferTo</span> <span class=\"params\">(<span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> count, WritableByteChannel target)</span></span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">transferFrom</span> <span class=\"params\">(ReadableByteChannel src, <span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> count)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>只有FileChannel类有这两个方法，因此Channel-to-Channel传输中通道之一必须是FileChannel。不能在socket通道之间直接传输数据，不过socket通道实现WritableByteChannel和ReadableByteChannel接口，因此文件的内容可以用transferTo()方法传输给一个socket通道，或者也可以用transferFrom()方法将数据从一个socket通道直接读取到一个文件中。</p>\n<p>直接的通道传输不会更新与某个FileChannel关联的position值。请求的数据传输将从position参数指定的位置开始，传输的字节数不超过count参数的值。实际传输的字节数会由方法返回。</p>\n<p>直接通道传输的另一端如果是socket通道并且处于非阻塞模式的话，数据的传输将具有不确定性。比如，transferFrom从socket通道读取数据，如果socket中的数据尚未准备好，那么方法将直接返回。</p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile fromFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"fromFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      fromChannel = fromFile.getChannel();</div><div class=\"line\"></div><div class=\"line\">RandomAccessFile toFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"toFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      toChannel = toFile.getChannel();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">long</span> position = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">long</span> count    = fromChannel.size();</div><div class=\"line\"></div><div class=\"line\">toChannel.transferFrom(fromChannel, position, count);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">RandomAccessFile fromFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"fromFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      fromChannel = fromFile.getChannel();</div><div class=\"line\"></div><div class=\"line\">RandomAccessFile toFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"toFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      toChannel = toFile.getChannel();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">long</span> position = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">long</span> count    = fromChannel.size();</div><div class=\"line\"></div><div class=\"line\">fromChannel.transferTo(position, count, toChannel);</div></pre></td></tr></table></figure>\n<h2 id=\"参考-1\"><a href=\"#参考-1\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.365mini.com/page/java-nio-course-17.htm\" target=\"_blank\" rel=\"external\">Java nio入门教程详解</a></p>\n","excerpt":"<blockquote>\n<p>Java NIO 学习第三篇–Channel</p>\n</blockquote>\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><p>通道(Channel)的作用有类似于流(Stream)，用于传输文件或者网络上的数据。</p>\n<img src=\"/2017/07/08/Java-NIO-Channel/channel.png\" alt=\"channel\" title=\"channel\">","more":"<p>上图中，箭头就相当于通道。一个不是很准确的例子：把通道想象成铁轨，缓冲区则是列车，铁轨的起始与终点则可以是socket，文件系统和我们的程序。假如当我们在代码中要写入数据到一份文件的时候，我们先把列车(缓冲区)装满，然后把列车(缓冲区)放置到铁轨上(通道)，数据就被传递到通道的另一端，文件系统。读取文件则相反，文件的内容被装到列车上，传递到程序这一侧，然后我们在代码中就可以读取这个列车中的内容(读取缓冲区)。</p>\n<p>通道与传统的流还是有一些区别的：</p>\n<ul>\n<li><p>通道可以同时支持读写(不是一定支持)，而流只支持单方向的操作，比如输入流只能读，输出流只能写。</p>\n</li>\n<li><p>通道可以支持异步的读或写，而流是同步的。</p>\n</li>\n<li><p>通道的读取或写入是通过缓冲区来进行的，而流则写入或返回字节。</p>\n</li>\n</ul>\n<h2 id=\"FileChannel\"><a href=\"#FileChannel\" class=\"headerlink\" title=\"FileChannel\"></a>FileChannel</h2><p>通道大致上可以分为两类：文件通道和socket通道。看一下文件通道：</p>\n<p>文件通道可以由以下几个方法获得：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile file = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"keyword\">new</span> File(fileName), <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel channel = file.getChannel();</div><div class=\"line\"></div><div class=\"line\">FileInputStream stream = <span class=\"keyword\">new</span> FileInputStream(<span class=\"keyword\">new</span> File(fileName));</div><div class=\"line\">FileChannel channel = stream.getChannel();</div><div class=\"line\"></div><div class=\"line\">FileOutputStream stream = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"keyword\">new</span> File(fileName));</div><div class=\"line\">FileChannel channel = stream.getChannel();</div><div class=\"line\"></div><div class=\"line\">FileChannel channel = FileChannel.open(Paths.get(fileName));</div></pre></td></tr></table></figure>\n<p>FileChannel 类结构：</p>\n<img src=\"/2017/07/08/Java-NIO-Channel/filechannel.png\" alt=\"Filechannel\" title=\"Filechannel\">\n<p>可见FileChannel实现了读写接口、聚集、发散接口，以及文件锁功能。下面会提到。</p>\n<p>看一下FileChannel的基本方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractChannel</span> <span class=\"keyword\">implements</span> <span class=\"title\">ByteChannel</span>, <span class=\"title\">GatheringByteChannel</span>, <span class=\"title\">ScatteringByteChannel</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">position</span><span class=\"params\">()</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">position</span> <span class=\"params\">(<span class=\"keyword\">long</span> newPosition)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer dst)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer dst, <span class=\"keyword\">long</span> position)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">write</span> <span class=\"params\">(ByteBuffer src)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">write</span> <span class=\"params\">(ByteBuffer src, <span class=\"keyword\">long</span> position)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">size</span><span class=\"params\">()</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">truncate</span> <span class=\"params\">(<span class=\"keyword\">long</span> size)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">force</span> <span class=\"params\">(<span class=\"keyword\">boolean</span> metaData)</span></div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure>\n<p>在通道出现之前，底层的文件操作都是通过RandomAccessFile类的方法来实现的。FileChannel模拟同样的 I/O 服务，因此它们的API自然也是很相似的。</p>\n<img src=\"/2017/07/08/Java-NIO-Channel/api.png\" alt=\"Filechannel\" title=\"Filechannel\">\n<p>上图是FileChannel、RandomAccessFile 和 <a href=\"http://wiki.jikexueyuan.com/project/linux-process/posix.html\">POSIX I/O system calls</a> 三者在方法上的对应关系。</p>\n<p>POSIX接口我们在上一篇文章中也略有提及，他是一个系统级别的接口。下面看一下这几个接口，主要也是和上一篇文章文件描述符的介绍做一个呼应。</p>\n<ul>\n<li>position()和position(long newPosition)</li>\n</ul>\n<p>position()返回当前文件的position值，position(long newPosition)将当前position设置为指定值。当字节被read()或write()方法传输时，文件position会自动更新。</p>\n<p>position的含义与Buffer类中的position含义相似，都是指向下一个字节读取的位置。</p>\n<p>回想一下介绍文件描述符的文章当中提到，当进程打开一个文件时，内核就会创建一个新的file对象，这个file对象有一个字段loff_t f_pos描述了文件的当前位置，position相当于loff_t f_pos的映射。由此可知，如果是使用同一文件描述符读取文件，那么他们的position是相互影响的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile file = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"keyword\">new</span> File(fileName), <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel channel = file.getChannel();</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div><div class=\"line\">file.seek(<span class=\"number\">30</span>);</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">position: 0</div><div class=\"line\">position: 30</div></pre></td></tr></table></figure>\n<p>这是因为，file与channel使用了同一个文件描述符。如果新建另一个相同文件的通道，那么他们之间的position不会相互影响，因为使用了不同的文件描述符，指向不同的file对象。</p>\n<ul>\n<li>truncate(long size)</li>\n</ul>\n<p>当需要减少一个文件的size时，truncate()方法会砍掉指定的size值之外的所有数据。这个方法要求通道具有写权限。</p>\n<p>如果当前size大于给定size，超出给定size的所有字节都会被删除。如果提供的新size值大于或等于当前的文件size值，该文件不会被修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile file = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"keyword\">new</span> File(fileName), <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel channel = file.getChannel();</div><div class=\"line\">System.out.println(<span class=\"string\">\"size: \"</span> + channel.size());</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div><div class=\"line\">System.out.println(<span class=\"string\">\"trucate: 90\"</span>);</div><div class=\"line\">channel.truncate(<span class=\"number\">90</span>);</div><div class=\"line\">System.out.println(<span class=\"string\">\"size: \"</span> + channel.size());</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">size: 100</div><div class=\"line\">position: 0</div><div class=\"line\">trucate: 90</div><div class=\"line\">size: 90</div><div class=\"line\">position: 0</div></pre></td></tr></table></figure>\n<ul>\n<li>force (boolean metaData)</li>\n</ul>\n<p>force()方法告诉通道强制将全部待定的修改都应用到磁盘的文件上。</p>\n<p>如果文件位于一个本地文件系统，那么一旦force()方法返回，即可保证从通道被创建(或上次调用force())时起的对文件所做的全部修改已经被写入到磁盘。但是，如果文件位于一个远程的文件系统，如NFS上，那么不能保证待定修改一定能同步到永久存储器。</p>\n<p>force()方法的布尔型参数表示在方法返回值前文件的元数据(metadata)是否也要被同步更新到磁盘。元数据指文件所有者、访问权限、最后一次修改时间等信息。</p>\n<blockquote>\n<p>Java NIO 学习第三篇–Channel</p>\n</blockquote>\n<h2 id=\"Channel-1\"><a href=\"#Channel-1\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><p>通道(Channel)的作用有类似于流(Stream)，用于传输文件或者网络上的数据。</p>\n<img src=\"/2017/07/08/Java-NIO-Channel/channel.png\" alt=\"channel\" title=\"channel\">\n<p>上图中，箭头就相当于通道。一个不是很准确的例子：把通道想象成铁轨，缓冲区则是列车，铁轨的起始与终点则可以是socket，文件系统和我们的程序。假如当我们在代码中要写入数据到一份文件的时候，我们先把列车(缓冲区)装满，然后把列车(缓冲区)放置到铁轨上(通道)，数据就被传递到通道的另一端，文件系统。读取文件则相反，文件的内容被装到列车上，传递到程序这一侧，然后我们在代码中就可以读取这个列车中的内容(读取缓冲区)。</p>\n<p>通道与传统的流还是有一些区别的：</p>\n<ul>\n<li><p>通道可以同时支持读写(不是一定支持)，而流只支持单方向的操作，比如输入流只能读，输出流只能写。</p>\n</li>\n<li><p>通道可以支持异步的读或写，而流是同步的。</p>\n</li>\n<li><p>通道的读取或写入是通过缓冲区来进行的，而流则写入或返回字节。</p>\n</li>\n</ul>\n<h2 id=\"FileChannel-1\"><a href=\"#FileChannel-1\" class=\"headerlink\" title=\"FileChannel\"></a><a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html\">FileChannel</a></h2><p>通道大致上可以分为两类：文件通道和socket通道。看一下文件通道：</p>\n<p>文件通道可以由以下几个方法获得：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile file = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"keyword\">new</span> File(fileName), <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel channel = file.getChannel();</div><div class=\"line\"></div><div class=\"line\">FileInputStream stream = <span class=\"keyword\">new</span> FileInputStream(<span class=\"keyword\">new</span> File(fileName));</div><div class=\"line\">FileChannel channel = stream.getChannel();</div><div class=\"line\"></div><div class=\"line\">FileOutputStream stream = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"keyword\">new</span> File(fileName));</div><div class=\"line\">FileChannel channel = stream.getChannel();</div><div class=\"line\"></div><div class=\"line\">FileChannel channel = FileChannel.open(Paths.get(fileName));</div></pre></td></tr></table></figure>\n<p>FileChannel 类结构：</p>\n<img src=\"/2017/07/08/Java-NIO-Channel/filechannel.png\" alt=\"Filechannel\" title=\"Filechannel\">\n<p>可见FileChannel实现了读写接口、聚集、发散接口，以及文件锁功能。下面会提到。</p>\n<p>看一下FileChannel的基本方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractChannel</span> <span class=\"keyword\">implements</span> <span class=\"title\">ByteChannel</span>, <span class=\"title\">GatheringByteChannel</span>, <span class=\"title\">ScatteringByteChannel</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">position</span><span class=\"params\">()</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">position</span> <span class=\"params\">(<span class=\"keyword\">long</span> newPosition)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer dst)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer dst, <span class=\"keyword\">long</span> position)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">write</span> <span class=\"params\">(ByteBuffer src)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">write</span> <span class=\"params\">(ByteBuffer src, <span class=\"keyword\">long</span> position)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">size</span><span class=\"params\">()</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">truncate</span> <span class=\"params\">(<span class=\"keyword\">long</span> size)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">force</span> <span class=\"params\">(<span class=\"keyword\">boolean</span> metaData)</span></div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure>\n<p>在通道出现之前，底层的文件操作都是通过RandomAccessFile类的方法来实现的。FileChannel模拟同样的 I/O 服务，因此它们的API自然也是很相似的。</p>\n<img src=\"/2017/07/08/Java-NIO-Channel/api.png\" alt=\"Filechannel\" title=\"Filechannel\">\n<p>上图是FileChannel、RandomAccessFile 和 <a href=\"http://wiki.jikexueyuan.com/project/linux-process/posix.html\">POSIX I/O system calls</a> 三者在方法上的对应关系。</p>\n<p>POSIX接口我们在上一篇文章中也略有提及，他是一个系统级别的接口。下面看一下这几个接口，主要也是和上一篇文章文件描述符的介绍做一个呼应。</p>\n<ul>\n<li>position()和position(long newPosition)</li>\n</ul>\n<p>position()返回当前文件的position值，position(long newPosition)将当前position设置为指定值。当字节被read()或write()方法传输时，文件position会自动更新。</p>\n<p>position的含义与Buffer类中的position含义相似，都是指向下一个字节读取的位置。</p>\n<p>回想一下介绍文件描述符的文章当中提到，当进程打开一个文件时，内核就会创建一个新的file对象，这个file对象有一个字段loff_t f_pos描述了文件的当前位置，position相当于loff_t f_pos的映射。由此可知，如果是使用同一文件描述符读取文件，那么他们的position是相互影响的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile file = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"keyword\">new</span> File(fileName), <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel channel = file.getChannel();</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div><div class=\"line\">file.seek(<span class=\"number\">30</span>);</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">position: 0</div><div class=\"line\">position: 30</div></pre></td></tr></table></figure>\n<p>这是因为，file与channel使用了同一个文件描述符。如果新建另一个相同文件的通道，那么他们之间的position不会相互影响，因为使用了不同的文件描述符，指向不同的file对象。</p>\n<ul>\n<li>truncate(long size)</li>\n</ul>\n<p>当需要减少一个文件的size时，truncate()方法会砍掉指定的size值之外的所有数据。这个方法要求通道具有写权限。</p>\n<p>如果当前size大于给定size，超出给定size的所有字节都会被删除。如果提供的新size值大于或等于当前的文件size值，该文件不会被修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile file = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"keyword\">new</span> File(fileName), <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel channel = file.getChannel();</div><div class=\"line\">System.out.println(<span class=\"string\">\"size: \"</span> + channel.size());</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div><div class=\"line\">System.out.println(<span class=\"string\">\"trucate: 90\"</span>);</div><div class=\"line\">channel.truncate(<span class=\"number\">90</span>);</div><div class=\"line\">System.out.println(<span class=\"string\">\"size: \"</span> + channel.size());</div><div class=\"line\">System.out.println(<span class=\"string\">\"position: \"</span> + channel.position());</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">size: 100</div><div class=\"line\">position: 0</div><div class=\"line\">trucate: 90</div><div class=\"line\">size: 90</div><div class=\"line\">position: 0</div></pre></td></tr></table></figure>\n<ul>\n<li>force (boolean metaData)</li>\n</ul>\n<p>force()方法告诉通道强制将全部待定的修改都应用到磁盘的文件上。</p>\n<p>如果文件位于一个本地文件系统，那么一旦force()方法返回，即可保证从通道被创建(或上次调用force())时起的对文件所做的全部修改已经被写入到磁盘。但是，如果文件位于一个远程的文件系统，如NFS上，那么不能保证待定修改一定能同步到永久存储器。</p>\n<p>force()方法的布尔型参数表示在方法返回值前文件的元数据(metadata)是否也要被同步更新到磁盘。元数据指文件所有者、访问权限、最后一次修改时间等信息。</p>\n<p>FileChannel对象是线程安全的。如果有一个线程已经在执行会影响通道位置或文件大小的操作，那么其他尝试进行此类操作之一的线程必须等待。</p>\n<h2 id=\"ReadableByteChannel、WritableByteChannel\"><a href=\"#ReadableByteChannel、WritableByteChannel\" class=\"headerlink\" title=\"ReadableByteChannel、WritableByteChannel\"></a>ReadableByteChannel、WritableByteChannel</h2><p>通道可以是单向或者双向的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ReadableByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">Channel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer dst)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WritableByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">Channel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">write</span> <span class=\"params\">(ByteBuffer src)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReadableByteChannel</span>, <span class=\"title\">WritableByteChannel</span></span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<img src=\"/2017/07/08/Java-NIO-Channel/bytechannel.png\" alt=\"channel\" title=\"channel\">\n<p>实现ReadableByteChannel或WritableByteChannel其中之一的channel是单向的，只可以读或者写。如果一个类同时实现了这两种接口，那么他就具备了双向传输的能力。</p>\n<p>java为我们提供了一个接口ByteChannel，同时继承了上述两个接口。所以，实现了ByteChannel接口的类可以读，也可以写。</p>\n<p>在<strong>FlieChannel</strong>这一节中我们知道，文件在不同的方式下以不同的权限打开。比如<code>FileInputStream.getChannel()</code>方法返回一个FileChannel实例，FileChannel是个抽象类，间接的实现了ByteChannel接口，也就意味着提供了read和write接口。但是<code>FileInputStream.getChannel()</code>方法返回的FileChannel实际上是只读的，很简单，因为FileInputStream本身就是个输入流啊~在这样一个通道上调用write方法将抛出NonWritableChannelException异常，因为FileInputStream对象总是以read-only的权限打开通道。看一下代码：</p>\n<p>FileInputStream.getChannel()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FileChannel <span class=\"title\">getChannel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (channel == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// 第三个参数指定通道是否可读，第四个参数指定通道是否可写</span></div><div class=\"line\">                channel = FileChannelImpl.open(fd, path, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">/*</div><div class=\"line\">                 * Increment fd's use count. Invoking the channel's close()</div><div class=\"line\">                 * method will result in decrementing the use count set for</div><div class=\"line\">                 * the channel.</div><div class=\"line\">                 */</span></div><div class=\"line\">                fd.incrementAndGetUseCount();</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> channel;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，<code>FileOutputStream.getChannel()</code>返回的通道是不可读的。</p>\n<h2 id=\"InterruptibleChannel\"><a href=\"#InterruptibleChannel\" class=\"headerlink\" title=\"InterruptibleChannel\"></a>InterruptibleChannel</h2><p>InterruptibleChannel是一个标记接口，当被通道使用时可以标示该通道是可以中断的。</p>\n<p>如果一个线程在一个通道上处于阻塞状态时被中断(另外一个线程调用该线程的interrupt()方法设置中断状态)，那么该通道将被关闭，该被阻塞线程也会产生一个ClosedByInterruptException异常。也就是说，假如一个线程的interrupt status被设置并且该线程试图访问一个通道，那么这个通道将立即被关闭，同时将抛出相同的ClosedByInterruptException异常。</p>\n<p>在<a href=\"http://yukai.space/2017/05/02/java%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88/\">java任务取消</a>中提到了，传统的java io 在读写时阻塞，是不会响应中断的。解决办法就是使用InterruptibleChannel，在线程被中断时可以关闭通道并返回。</p>\n<p>可中断的通道也是可以异步关闭。实现InterruptibleChannel接口的通道可以在任何时候被关闭，即使有另一个被阻塞的线程在等待该通道上的一个I/O操作完成。当一个通道被关闭时，休眠在该通道上的所有线程都将被唤醒并接收到一个AsynchronousCloseException异常。接着通道就被关闭并将不再可用。</p>\n<h2 id=\"Scatter-Gather\"><a href=\"#Scatter-Gather\" class=\"headerlink\" title=\"Scatter/Gather\"></a>Scatter/Gather</h2><p>发散(Scatter)读取是将数据读入多个缓冲区(缓冲区数组)的操作。通道将数据依次填满到每个缓冲区当中。</p>\n<p>汇聚(Gather)写出是将多个缓冲区(缓冲区数组)数据依次写入到通道的操作。</p>\n<p>在FileChannel中提到的两个接口，提供了发散汇聚的功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ScatteringByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReadableByteChannel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer[] dsts)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer[] dsts, <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> length)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GatheringByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">WritableByteChannel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">write</span><span class=\"params\">(ByteBuffer[] srcs)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">write</span><span class=\"params\">(ByteBuffer[] srcs, <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> length)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>发散汇聚在某些场景下是很有用的，比如有一个消息协议格式分为head和body(比如http协议)，我们在接收这样一个消息的时候，通常的做法是把数据一下子都读过来，然后解析他。使用通道的发散功能会使这个过程变得简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// head数据128字节</span></div><div class=\"line\">ByteBuffer header = ByteBuffer.allocate(<span class=\"number\">128</span>);</div><div class=\"line\"><span class=\"comment\">// body数据1024字节</span></div><div class=\"line\">ByteBuffer body   = ByteBuffer.allocate(<span class=\"number\">1024</span>);</div><div class=\"line\"></div><div class=\"line\">ByteBuffer[] bufferArray = &#123; header, body &#125;;</div><div class=\"line\"></div><div class=\"line\">channel.read(bufferArray);</div></pre></td></tr></table></figure>\n<p>通道会依次填满这个buffer数组的每个buffer，如果一个buffer满了，就移动到下一个buffer。很自然的把head和body的数据分开了，但是要注意head和body的数据长度必须是固定的，因为channel只有填满一个buffer之后才会移动到下一个buffer。</p>\n<h2 id=\"FileLock\"><a href=\"#FileLock\" class=\"headerlink\" title=\"FileLock\"></a>FileLock</h2><p>摘抄一段oracle官网上FileLock的介绍吧，感觉说的挺清楚了。(因为懒，就不翻译了，读起来不是很费劲)</p>\n<blockquote>\n<p>A token representing a lock on a region of a file.<br>A file-lock object is created each time a lock is acquired on a file via one of the lock or tryLock methods of the FileChannel class, or the lock or tryLock methods of the AsynchronousFileChannel class.</p>\n<p>A file-lock object is initially valid. It remains valid until the lock is released by invoking the release method, by closing the channel that was used to acquire it, or by the termination of the Java virtual machine, whichever comes first. The validity of a lock may be tested by invoking its &gt;isValid method.</p>\n<p>A file lock is either exclusive or shared. A shared lock prevents other concurrently-running programs from acquiring an overlapping exclusive lock, but does allow them to acquire overlapping shared locks. An exclusive lock prevents other programs from acquiring an overlapping lock of either type. &gt;Once it is released, a lock has no further effect on the locks that may be acquired by other programs.</p>\n<p>Whether a lock is exclusive or shared may be determined by invoking its isShared method. Some platforms do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.</p>\n<p>The locks held on a particular file by a single Java virtual machine do not overlap. The overlaps method may be used to test whether a candidate lock range overlaps an existing lock.</p>\n<p>A file-lock object records the file channel upon whose file the lock is held, the type and validity of the lock, and the position and size of the locked region. Only the validity of a lock is subject to change over time; all other aspects of a lock’s state are immutable.</p>\n<p>File locks are held on behalf of the entire Java virtual machine. They are not suitable for controlling access to a file by multiple threads within the same virtual machine.</p>\n<p>File-lock objects are safe for use by multiple concurrent threads.</p>\n<p><strong>Platform dependencies</strong></p>\n<p>This file-locking API is intended to map directly to the native locking facility of the underlying operating system. Thus the locks held on a file should be visible to all programs that have access to the file, regardless of the language in which those programs are written.</p>\n<p>Whether or not a lock actually prevents another program from accessing the content of the locked region is system-dependent and therefore unspecified. The native file-locking facilities of some systems are merely advisory, meaning that programs must cooperatively observe a known locking protocol in &gt;order to guarantee data integrity. On other systems native file locks are mandatory, meaning that if one program locks a region of a file then other programs are actually prevented from accessing that region in a way that would violate the lock. On yet other systems, whether native file locks are &gt;advisory or mandatory is configurable on a per-file basis. To ensure consistent and correct behavior across platforms, it is strongly recommended that the locks provided by this API be used as if they were advisory locks.</p>\n<p>On some systems, acquiring a mandatory lock on a region of a file prevents that region from being mapped into memory, and vice versa. Programs that combine locking and mapping should be prepared for this combination to fail.</p>\n<p>On some systems, closing a channel releases all locks held by the Java virtual machine on the underlying file regardless of whether the locks were acquired via that channel or via another channel open on the same file. It is strongly recommended that, within a program, a unique channel be used to &gt;acquire all locks on any given file.</p>\n<p>Some network filesystems permit file locking to be used with memory-mapped files only when the locked regions are page-aligned and a whole multiple of the underlying hardware’s page size. Some network filesystems do not implement file locks on regions that extend past a certain position, often 230 &gt;or 231. In general, great care should be taken when locking files that reside on network filesystems.</p>\n</blockquote>\n<p>FileLock可以由以下几个方法获得：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractChannel</span> <span class=\"keyword\">implements</span> <span class=\"title\">ByteChannel</span>, <span class=\"title\">GatheringByteChannel</span>, <span class=\"title\">ScatteringByteChannel</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> FileLock <span class=\"title\">lock</span><span class=\"params\">()</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> FileLock <span class=\"title\">lock</span> <span class=\"params\">(<span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> size, <span class=\"keyword\">boolean</span> shared)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> FileLock <span class=\"title\">tryLock</span><span class=\"params\">()</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> FileLock <span class=\"title\">tryLock</span> <span class=\"params\">(<span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> size, <span class=\"keyword\">boolean</span> shared)</span></div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure>\n<p>其中，lock是阻塞的，tryLock是非阻塞的。position和size决定了锁定的区域，shared决定了文件锁是共享的还是独占的。</p>\n<p>不带参数的lock方法等价于<code>fileChannel.lock(0L, Long.MAX_VALUE, false)</code>，tryLock亦然。</p>\n<p>lock方法是响应中断的，当线程被中断时方法抛出FileLockInterruptionException异常。如果通道被另外一个线程关闭，该暂停线程将恢复并产生一个 AsynchronousCloseException异常。</p>\n<p>上面还提到了，文件锁是针对于进程级别的。如果有多个进程同时对一个文件锁定，并且其中有独占锁的话，这些锁的申请会被串行化。</p>\n<p>如果是同一个进程(Jvm实例)的多个线程同时请求同一个文件区域的lock的话，会抛出OverlappingFileLockException异常。</p>\n<h2 id=\"Channel-to-Channel\"><a href=\"#Channel-to-Channel\" class=\"headerlink\" title=\"Channel-to-Channel\"></a>Channel-to-Channel</h2><p>FileChannel提供了接口，用于通道和通道之间的直接传输。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractChannel</span> <span class=\"keyword\">implements</span> <span class=\"title\">ByteChannel</span>, <span class=\"title\">GatheringByteChannel</span>, <span class=\"title\">ScatteringByteChannel</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">transferTo</span> <span class=\"params\">(<span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> count, WritableByteChannel target)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">transferFrom</span> <span class=\"params\">(ReadableByteChannel src, <span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> count)</span></div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure>\n<p>只有FileChannel类有这两个方法，因此Channel-to-Channel传输中通道之一必须是FileChannel。不能在socket通道之间直接传输数据，不过socket通道实现WritableByteChannel和ReadableByteChannel接口，因此文件的内容可以用transferTo()方法传输给一个socket通道，或者也可以用transferFrom()方法将数据从一个socket通道直接读取到一个文件中。</p>\n<p>直接的通道传输不会更新与某个FileChannel关联的position值。请求的数据传输将从position参数指定的位置开始，传输的字节数不超过count参数的值。实际传输的字节数会由方法返回。</p>\n<p>直接通道传输的另一端如果是socket通道并且处于非阻塞模式的话，数据的传输将具有不确定性。比如，transferFrom从socket通道读取数据，如果socket中的数据尚未准备好，那么方法将直接返回。</p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile fromFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"fromFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      fromChannel = fromFile.getChannel();</div><div class=\"line\"></div><div class=\"line\">RandomAccessFile toFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"toFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      toChannel = toFile.getChannel();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">long</span> position = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">long</span> count    = fromChannel.size();</div><div class=\"line\"></div><div class=\"line\">toChannel.transferFrom(fromChannel, position, count);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">RandomAccessFile fromFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"fromFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      fromChannel = fromFile.getChannel();</div><div class=\"line\"></div><div class=\"line\">RandomAccessFile toFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"toFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      toChannel = toFile.getChannel();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">long</span> position = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">long</span> count    = fromChannel.size();</div><div class=\"line\"></div><div class=\"line\">fromChannel.transferTo(position, count, toChannel);</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.365mini.com/page/java-nio-course-17.htm\">Java nio入门教程详解</a></p>\n<h2 id=\"ReadableByteChannel、WritableByteChannel-1\"><a href=\"#ReadableByteChannel、WritableByteChannel-1\" class=\"headerlink\" title=\"ReadableByteChannel、WritableByteChannel\"></a>ReadableByteChannel、WritableByteChannel</h2><p>通道可以是单向或者双向的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ReadableByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">Channel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer dst)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WritableByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">Channel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">write</span> <span class=\"params\">(ByteBuffer src)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReadableByteChannel</span>, <span class=\"title\">WritableByteChannel</span></span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<img src=\"/2017/07/08/Java-NIO-Channel/bytechannel.png\" alt=\"channel\" title=\"channel\">\n<p>实现ReadableByteChannel或WritableByteChannel其中之一的channel是单向的，只可以读或者写。如果一个类同时实现了这两种接口，那么他就具备了双向传输的能力。</p>\n<p>java为我们提供了一个接口ByteChannel，同时继承了上述两个接口。所以，实现了ByteChannel接口的类可以读，也可以写。</p>\n<p>在<strong>FlieChannel</strong>这一节中我们知道，文件在不同的方式下以不同的权限打开。比如<code>FileInputStream.getChannel()</code>方法返回一个FileChannel实例，FileChannel是个抽象类，间接的实现了ByteChannel接口，也就意味着提供了read和write接口。但是<code>FileInputStream.getChannel()</code>方法返回的FileChannel实际上是只读的，很简单，因为FileInputStream本身就是个输入流啊~在这样一个通道上调用write方法将抛出NonWritableChannelException异常，因为FileInputStream对象总是以read-only的权限打开通道。看一下代码：</p>\n<p>FileInputStream.getChannel()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FileChannel <span class=\"title\">getChannel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (channel == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// 第三个参数指定通道是否可读，第四个参数指定通道是否可写</span></div><div class=\"line\">                channel = FileChannelImpl.open(fd, path, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">/*</div><div class=\"line\">                 * Increment fd's use count. Invoking the channel's close()</div><div class=\"line\">                 * method will result in decrementing the use count set for</div><div class=\"line\">                 * the channel.</div><div class=\"line\">                 */</span></div><div class=\"line\">                fd.incrementAndGetUseCount();</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> channel;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，<code>FileOutputStream.getChannel()</code>返回的通道是不可读的。</p>\n<h2 id=\"InterruptibleChannel-1\"><a href=\"#InterruptibleChannel-1\" class=\"headerlink\" title=\"InterruptibleChannel\"></a>InterruptibleChannel</h2><p>InterruptibleChannel是一个标记接口，当被通道使用时可以标示该通道是可以中断的。</p>\n<p>如果一个线程在一个通道上处于阻塞状态时被中断(另外一个线程调用该线程的interrupt()方法设置中断状态)，那么该通道将被关闭，该被阻塞线程也会产生一个ClosedByInterruptException异常。也就是说，假如一个线程的interrupt status被设置并且该线程试图访问一个通道，那么这个通道将立即被关闭，同时将抛出相同的ClosedByInterruptException异常。</p>\n<p>在<a href=\"http://yukai.space/2017/05/02/java%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88/\">java任务取消</a>中提到了，传统的java io 在读写时阻塞，是不会响应中断的。解决办法就是使用InterruptibleChannel，在线程被中断时可以关闭通道并返回。</p>\n<p>可中断的通道也是可以异步关闭。实现InterruptibleChannel接口的通道可以在任何时候被关闭，即使有另一个被阻塞的线程在等待该通道上的一个I/O操作完成。当一个通道被关闭时，休眠在该通道上的所有线程都将被唤醒并接收到一个AsynchronousCloseException异常。接着通道就被关闭并将不再可用。</p>\n<h2 id=\"Scatter-Gather-1\"><a href=\"#Scatter-Gather-1\" class=\"headerlink\" title=\"Scatter/Gather\"></a>Scatter/Gather</h2><p>发散(Scatter)读取是将数据读入多个缓冲区(缓冲区数组)的操作。通道将数据依次填满到每个缓冲区当中。</p>\n<p>汇聚(Gather)写出是将多个缓冲区(缓冲区数组)数据依次写入到通道的操作。</p>\n<p>在FileChannel中提到的两个接口，提供了发散汇聚的功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ScatteringByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReadableByteChannel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer[] dsts)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">read</span> <span class=\"params\">(ByteBuffer[] dsts, <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> length)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GatheringByteChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">WritableByteChannel</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">write</span><span class=\"params\">(ByteBuffer[] srcs)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">write</span><span class=\"params\">(ByteBuffer[] srcs, <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> length)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>发散汇聚在某些场景下是很有用的，比如有一个消息协议格式分为head和body(比如http协议)，我们在接收这样一个消息的时候，通常的做法是把数据一下子都读过来，然后解析他。使用通道的发散功能会使这个过程变得简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// head数据128字节</span></div><div class=\"line\">ByteBuffer header = ByteBuffer.allocate(<span class=\"number\">128</span>);</div><div class=\"line\"><span class=\"comment\">// body数据1024字节</span></div><div class=\"line\">ByteBuffer body   = ByteBuffer.allocate(<span class=\"number\">1024</span>);</div><div class=\"line\"></div><div class=\"line\">ByteBuffer[] bufferArray = &#123; header, body &#125;;</div><div class=\"line\"></div><div class=\"line\">channel.read(bufferArray);</div></pre></td></tr></table></figure>\n<p>通道会依次填满这个buffer数组的每个buffer，如果一个buffer满了，就移动到下一个buffer。很自然的把head和body的数据分开了，但是要注意head和body的数据长度必须是固定的，因为channel只有填满一个buffer之后才会移动到下一个buffer。</p>\n<h2 id=\"FileLock-1\"><a href=\"#FileLock-1\" class=\"headerlink\" title=\"FileLock\"></a>FileLock</h2><h2 id=\"Channel-to-Channel-1\"><a href=\"#Channel-to-Channel-1\" class=\"headerlink\" title=\"Channel-to-Channel\"></a>Channel-to-Channel</h2><p>FileChannel提供了接口，用于通道和通道之间的直接传输。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileChannel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractChannel</span> <span class=\"keyword\">implements</span> <span class=\"title\">ByteChannel</span>, <span class=\"title\">GatheringByteChannel</span>, <span class=\"title\">ScatteringByteChannel</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">transferTo</span> <span class=\"params\">(<span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> count, WritableByteChannel target)</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">transferFrom</span> <span class=\"params\">(ReadableByteChannel src, <span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> count)</span></div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure>\n<p>只有FileChannel类有这两个方法，因此Channel-to-Channel传输中通道之一必须是FileChannel。不能在socket通道之间直接传输数据，不过socket通道实现WritableByteChannel和ReadableByteChannel接口，因此文件的内容可以用transferTo()方法传输给一个socket通道，或者也可以用transferFrom()方法将数据从一个socket通道直接读取到一个文件中。</p>\n<p>直接的通道传输不会更新与某个FileChannel关联的position值。请求的数据传输将从position参数指定的位置开始，传输的字节数不超过count参数的值。实际传输的字节数会由方法返回。</p>\n<p>直接通道传输的另一端如果是socket通道并且处于非阻塞模式的话，数据的传输将具有不确定性。比如，transferFrom从socket通道读取数据，如果socket中的数据尚未准备好，那么方法将直接返回。</p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">RandomAccessFile fromFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"fromFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      fromChannel = fromFile.getChannel();</div><div class=\"line\"></div><div class=\"line\">RandomAccessFile toFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"toFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      toChannel = toFile.getChannel();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">long</span> position = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">long</span> count    = fromChannel.size();</div><div class=\"line\"></div><div class=\"line\">toChannel.transferFrom(fromChannel, position, count);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">RandomAccessFile fromFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"fromFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      fromChannel = fromFile.getChannel();</div><div class=\"line\"></div><div class=\"line\">RandomAccessFile toFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"toFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</div><div class=\"line\">FileChannel      toChannel = toFile.getChannel();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">long</span> position = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">long</span> count    = fromChannel.size();</div><div class=\"line\"></div><div class=\"line\">fromChannel.transferTo(position, count, toChannel);</div></pre></td></tr></table></figure>\n<h2 id=\"参考-1\"><a href=\"#参考-1\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.365mini.com/page/java-nio-course-17.htm\">Java nio入门教程详解</a></p>"},{"layout":"post","title":"ANT编译java工程经jdk路径的设置","date":"2016-04-25T04:48:55.000Z","_content":"\n> 今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。\n\n打包过程中总是报：\n\n```java\n[javac] 警告: [options] 未与 -source 1.5 一起设置引导类路径\n[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:50: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()\n[javac] public class Driver implements java.sql.Driver {\n....\n```\n\n类似这样的一堆错误。\n\n没有过多的思考，百度之...出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。\n\n严重的浪费时间和影响心情，遂放弃。\n\n静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。\n\n后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。\n\n重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。\n\n等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’\n\n果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加\n\n```java\nexecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"\nfork=\"yes\"\n```\n<!-- more -->\n\nBuild Successfull.\n\n这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：\n\n1.不要用百度\n\n2.先思考问题原因，再寻找解决方案\n\n3.学习英语，尽量用英文搜索\n\n## 参考\n\n[Change JDK for running <ANT> task from within build xml](http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml)\n\n\n","source":"_posts/ant编译java工程jdk路径的设置.md","raw":"---\nlayout: post\ntitle:  \"ANT编译java工程经jdk路径的设置\"\ncategories: 工具\ntags: \n- java\n- ant\ndate:   2016-04-25 12:48:55\n---\n\n> 今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。\n\n打包过程中总是报：\n\n```java\n[javac] 警告: [options] 未与 -source 1.5 一起设置引导类路径\n[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:50: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()\n[javac] public class Driver implements java.sql.Driver {\n....\n```\n\n类似这样的一堆错误。\n\n没有过多的思考，百度之...出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。\n\n严重的浪费时间和影响心情，遂放弃。\n\n静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。\n\n后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。\n\n重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。\n\n等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’\n\n果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加\n\n```java\nexecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"\nfork=\"yes\"\n```\n<!-- more -->\n\nBuild Successfull.\n\n这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：\n\n1.不要用百度\n\n2.先思考问题原因，再寻找解决方案\n\n3.学习英语，尽量用英文搜索\n\n## 参考\n\n[Change JDK for running <ANT> task from within build xml](http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml)\n\n\n","slug":"ant编译java工程jdk路径的设置","published":1,"updated":"2017-04-11T13:08:38.836Z","comments":1,"photos":[],"link":"","_id":"cj4vch4d3000ex3gcxazfvf0o","content":"<blockquote>\n<p>今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。</p>\n</blockquote>\n<p>打包过程中总是报：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[javac] 警告: [options] 未与 -source <span class=\"number\">1.5</span> 一起设置引导类路径</div><div class=\"line\">[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:<span class=\"number\">50</span>: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()</div><div class=\"line\">[javac] <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>类似这样的一堆错误。</p>\n<p>没有过多的思考，百度之…出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。</p>\n<p>严重的浪费时间和影响心情，遂放弃。</p>\n<p>静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。</p>\n<p>后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。</p>\n<p>重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。</p>\n<p>等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’</p>\n<p>果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">executable=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"</span></div><div class=\"line\">fork=<span class=\"string\">\"yes\"</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>Build Successfull.</p>\n<p>这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：</p>\n<p>1.不要用百度</p>\n<p>2.先思考问题原因，再寻找解决方案</p>\n<p>3.学习英语，尽量用英文搜索</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml\" target=\"_blank\" rel=\"external\">Change JDK for running <ant> task from within build xml</ant></a></p>\n","excerpt":"<blockquote>\n<p>今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。</p>\n</blockquote>\n<p>打包过程中总是报：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[javac] 警告: [options] 未与 -source <span class=\"number\">1.5</span> 一起设置引导类路径</div><div class=\"line\">[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:<span class=\"number\">50</span>: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()</div><div class=\"line\">[javac] <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>类似这样的一堆错误。</p>\n<p>没有过多的思考，百度之…出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。</p>\n<p>严重的浪费时间和影响心情，遂放弃。</p>\n<p>静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。</p>\n<p>后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。</p>\n<p>重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。</p>\n<p>等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’</p>\n<p>果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">executable=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"</span></div><div class=\"line\">fork=<span class=\"string\">\"yes\"</span></div></pre></td></tr></table></figure>","more":"<p>Build Successfull.</p>\n<p>这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：</p>\n<p>1.不要用百度</p>\n<p>2.先思考问题原因，再寻找解决方案</p>\n<p>3.学习英语，尽量用英文搜索</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml\">Change JDK for running <ANT> task from within build xml</a></p>"},{"layout":"post","title":"centos7BCM驱动安装","date":"2017-02-25T03:22:45.000Z","_content":"> 前段时间安装了centos后，一直使用网线上网。今天是周末，安装了一下无线驱动，可以愉快的使用无线wifi上网啦～\n\n## 查看无线驱动\n\n```\niwconfig\n```\n如果没有iwconfig命令，则先安装：\n\n```\nsudo yum install wireless-tools\n```\n\n{% asset_img iwconfig.png iwconfig %}\n\n如上图显示有类似wlp7s0这样的信息，则表示无线驱动已经安装好了。若没有，则全部为no wireless extensions.\n\n没有安装无线驱动，进行下面的操作。\n\n<!-- more -->\n\n## 查看网卡型号\n\n```\nlspci |grep -i network \n```\n\n显示：\n\n```\n07:00.0 Network controller: Broadcom Limited BCM43142 802.11b/g/n (rev 01)\n```\n\n表示是BCM的网卡\n\n## 查看内核信息\n\n```\nuname -r\n```\n显示内核信息：\n```\n3.10.0-514.6.1.el7.x86_64\n```\n注意上面的发行版版本为el6,后面64为64位操作系统\n\n## 编译安装驱动程序\n\n下面只针对el7 64的情况，其他配置的系统参考：[wl-kmod](http://elrepo.org/tiki/wl-kmod)\n\n1.安装工具\n```\nyum group install 'Development Tools'\n\nyum install redhat-lsb kernel-abi-whitelists\n\nyum install kernel-devel-$(uname -r)\n```\n\n2.切换到普通用户，配置构建树\n```\nmkdir -p ~/rpmbuild/{BUILD,RPMS,SPECS,SOURCES,SRPMS}\n\necho -e \"%_topdir $(echo $HOME)/rpmbuild\\n%dist .el$(lsb_release -s -r|cut -d\".\" -f1).local\" >> ~/.rpmmacros\n```\n\n3.下载 wl-kmod*nosrc.rpm 到任意目录，比如 ～/package\n[http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm](http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm)\n\n4.下载合适的驱动\n[http://www.broadcom.com/support/802.11]( http://www.broadcom.com/support/802.11)\n\n选择64位的驱动，下载到~/rpmbuild/SOURCES/目录\n\n5.构建kmod-wl\n```\n rpmbuild --rebuild --target=`uname -m` --define 'packager yukai' ~/package/wl-kmod*nosrc.rpm\n```\n\n其中，yukai是当前登陆用户，~/package/是第三步下载的rpm文件位置\n\n6.安装kmod-wl\n\n```\nrpm -Uvh /home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm\n```\n\n第五步构建完成之后,在～/rpmbuild/RPMS/x86_64目录会有kmod-wl*rpm文件生成，安装它即可\n\n7.删除不用的文件\n\n保存/home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm文件，然后删除～/rpmbuild/\n\n```\nrm -rf ～/rpmbuild/\n```\n\n8.重启即可\n\n{% asset_img demo.png demo %}","source":"_posts/centos7BCM驱动安装.md","raw":"---\nlayout: post\ntitle: centos7BCM驱动安装\ndate: 2017-02-25 11:22:45\ncategories: 工具\ntags: linux\n---\n> 前段时间安装了centos后，一直使用网线上网。今天是周末，安装了一下无线驱动，可以愉快的使用无线wifi上网啦～\n\n## 查看无线驱动\n\n```\niwconfig\n```\n如果没有iwconfig命令，则先安装：\n\n```\nsudo yum install wireless-tools\n```\n\n{% asset_img iwconfig.png iwconfig %}\n\n如上图显示有类似wlp7s0这样的信息，则表示无线驱动已经安装好了。若没有，则全部为no wireless extensions.\n\n没有安装无线驱动，进行下面的操作。\n\n<!-- more -->\n\n## 查看网卡型号\n\n```\nlspci |grep -i network \n```\n\n显示：\n\n```\n07:00.0 Network controller: Broadcom Limited BCM43142 802.11b/g/n (rev 01)\n```\n\n表示是BCM的网卡\n\n## 查看内核信息\n\n```\nuname -r\n```\n显示内核信息：\n```\n3.10.0-514.6.1.el7.x86_64\n```\n注意上面的发行版版本为el6,后面64为64位操作系统\n\n## 编译安装驱动程序\n\n下面只针对el7 64的情况，其他配置的系统参考：[wl-kmod](http://elrepo.org/tiki/wl-kmod)\n\n1.安装工具\n```\nyum group install 'Development Tools'\n\nyum install redhat-lsb kernel-abi-whitelists\n\nyum install kernel-devel-$(uname -r)\n```\n\n2.切换到普通用户，配置构建树\n```\nmkdir -p ~/rpmbuild/{BUILD,RPMS,SPECS,SOURCES,SRPMS}\n\necho -e \"%_topdir $(echo $HOME)/rpmbuild\\n%dist .el$(lsb_release -s -r|cut -d\".\" -f1).local\" >> ~/.rpmmacros\n```\n\n3.下载 wl-kmod*nosrc.rpm 到任意目录，比如 ～/package\n[http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm](http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm)\n\n4.下载合适的驱动\n[http://www.broadcom.com/support/802.11]( http://www.broadcom.com/support/802.11)\n\n选择64位的驱动，下载到~/rpmbuild/SOURCES/目录\n\n5.构建kmod-wl\n```\n rpmbuild --rebuild --target=`uname -m` --define 'packager yukai' ~/package/wl-kmod*nosrc.rpm\n```\n\n其中，yukai是当前登陆用户，~/package/是第三步下载的rpm文件位置\n\n6.安装kmod-wl\n\n```\nrpm -Uvh /home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm\n```\n\n第五步构建完成之后,在～/rpmbuild/RPMS/x86_64目录会有kmod-wl*rpm文件生成，安装它即可\n\n7.删除不用的文件\n\n保存/home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm文件，然后删除～/rpmbuild/\n\n```\nrm -rf ～/rpmbuild/\n```\n\n8.重启即可\n\n{% asset_img demo.png demo %}","slug":"centos7BCM驱动安装","published":1,"updated":"2017-04-11T13:08:38.836Z","comments":1,"photos":[],"link":"","_id":"cj4vch4d5000gx3gcu8dhfbkn","content":"<blockquote>\n<p>前段时间安装了centos后，一直使用网线上网。今天是周末，安装了一下无线驱动，可以愉快的使用无线wifi上网啦～</p>\n</blockquote>\n<h2 id=\"查看无线驱动\"><a href=\"#查看无线驱动\" class=\"headerlink\" title=\"查看无线驱动\"></a>查看无线驱动</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">iwconfig</div></pre></td></tr></table></figure>\n<p>如果没有iwconfig命令，则先安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo yum install wireless-tools</div></pre></td></tr></table></figure>\n<img src=\"/2017/02/25/centos7BCM驱动安装/iwconfig.png\" alt=\"iwconfig\" title=\"iwconfig\">\n<p>如上图显示有类似wlp7s0这样的信息，则表示无线驱动已经安装好了。若没有，则全部为no wireless extensions.</p>\n<p>没有安装无线驱动，进行下面的操作。</p>\n<a id=\"more\"></a>\n<h2 id=\"查看网卡型号\"><a href=\"#查看网卡型号\" class=\"headerlink\" title=\"查看网卡型号\"></a>查看网卡型号</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lspci |grep -i network</div></pre></td></tr></table></figure>\n<p>显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">07:00.0 Network controller: Broadcom Limited BCM43142 802.11b/g/n (rev 01)</div></pre></td></tr></table></figure>\n<p>表示是BCM的网卡</p>\n<h2 id=\"查看内核信息\"><a href=\"#查看内核信息\" class=\"headerlink\" title=\"查看内核信息\"></a>查看内核信息</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">uname -r</div></pre></td></tr></table></figure>\n<p>显示内核信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">3.10.0-514.6.1.el7.x86_64</div></pre></td></tr></table></figure></p>\n<p>注意上面的发行版版本为el6,后面64为64位操作系统</p>\n<h2 id=\"编译安装驱动程序\"><a href=\"#编译安装驱动程序\" class=\"headerlink\" title=\"编译安装驱动程序\"></a>编译安装驱动程序</h2><p>下面只针对el7 64的情况，其他配置的系统参考：<a href=\"http://elrepo.org/tiki/wl-kmod\" target=\"_blank\" rel=\"external\">wl-kmod</a></p>\n<p>1.安装工具<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum group install &apos;Development Tools&apos;</div><div class=\"line\"></div><div class=\"line\">yum install redhat-lsb kernel-abi-whitelists</div><div class=\"line\"></div><div class=\"line\">yum install kernel-devel-$(uname -r)</div></pre></td></tr></table></figure></p>\n<p>2.切换到普通用户，配置构建树<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir -p ~/rpmbuild/&#123;BUILD,RPMS,SPECS,SOURCES,SRPMS&#125;</div><div class=\"line\"></div><div class=\"line\">echo -e &quot;%_topdir $(echo $HOME)/rpmbuild\\n%dist .el$(lsb_release -s -r|cut -d&quot;.&quot; -f1).local&quot; &gt;&gt; ~/.rpmmacros</div></pre></td></tr></table></figure></p>\n<p>3.下载 wl-kmod*nosrc.rpm 到任意目录，比如 ～/package<br><a href=\"http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm\" target=\"_blank\" rel=\"external\">http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm</a></p>\n<p>4.下载合适的驱动<br><a href=\"http://www.broadcom.com/support/802.11\" target=\"_blank\" rel=\"external\">http://www.broadcom.com/support/802.11</a></p>\n<p>选择64位的驱动，下载到~/rpmbuild/SOURCES/目录</p>\n<p>5.构建kmod-wl<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rpmbuild --rebuild --target=`uname -m` --define &apos;packager yukai&apos; ~/package/wl-kmod*nosrc.rpm</div></pre></td></tr></table></figure></p>\n<p>其中，yukai是当前登陆用户，~/package/是第三步下载的rpm文件位置</p>\n<p>6.安装kmod-wl</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rpm -Uvh /home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm</div></pre></td></tr></table></figure>\n<p>第五步构建完成之后,在～/rpmbuild/RPMS/x86_64目录会有kmod-wl*rpm文件生成，安装它即可</p>\n<p>7.删除不用的文件</p>\n<p>保存/home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm文件，然后删除～/rpmbuild/</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm -rf ～/rpmbuild/</div></pre></td></tr></table></figure>\n<p>8.重启即可</p>\n<img src=\"/2017/02/25/centos7BCM驱动安装/demo.png\" alt=\"demo\" title=\"demo\">","excerpt":"<blockquote>\n<p>前段时间安装了centos后，一直使用网线上网。今天是周末，安装了一下无线驱动，可以愉快的使用无线wifi上网啦～</p>\n</blockquote>\n<h2 id=\"查看无线驱动\"><a href=\"#查看无线驱动\" class=\"headerlink\" title=\"查看无线驱动\"></a>查看无线驱动</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">iwconfig</div></pre></td></tr></table></figure>\n<p>如果没有iwconfig命令，则先安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo yum install wireless-tools</div></pre></td></tr></table></figure>\n<img src=\"/2017/02/25/centos7BCM驱动安装/iwconfig.png\" alt=\"iwconfig\" title=\"iwconfig\">\n<p>如上图显示有类似wlp7s0这样的信息，则表示无线驱动已经安装好了。若没有，则全部为no wireless extensions.</p>\n<p>没有安装无线驱动，进行下面的操作。</p>","more":"<h2 id=\"查看网卡型号\"><a href=\"#查看网卡型号\" class=\"headerlink\" title=\"查看网卡型号\"></a>查看网卡型号</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lspci |grep -i network</div></pre></td></tr></table></figure>\n<p>显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">07:00.0 Network controller: Broadcom Limited BCM43142 802.11b/g/n (rev 01)</div></pre></td></tr></table></figure>\n<p>表示是BCM的网卡</p>\n<h2 id=\"查看内核信息\"><a href=\"#查看内核信息\" class=\"headerlink\" title=\"查看内核信息\"></a>查看内核信息</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">uname -r</div></pre></td></tr></table></figure>\n<p>显示内核信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">3.10.0-514.6.1.el7.x86_64</div></pre></td></tr></table></figure></p>\n<p>注意上面的发行版版本为el6,后面64为64位操作系统</p>\n<h2 id=\"编译安装驱动程序\"><a href=\"#编译安装驱动程序\" class=\"headerlink\" title=\"编译安装驱动程序\"></a>编译安装驱动程序</h2><p>下面只针对el7 64的情况，其他配置的系统参考：<a href=\"http://elrepo.org/tiki/wl-kmod\">wl-kmod</a></p>\n<p>1.安装工具<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum group install &apos;Development Tools&apos;</div><div class=\"line\"></div><div class=\"line\">yum install redhat-lsb kernel-abi-whitelists</div><div class=\"line\"></div><div class=\"line\">yum install kernel-devel-$(uname -r)</div></pre></td></tr></table></figure></p>\n<p>2.切换到普通用户，配置构建树<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir -p ~/rpmbuild/&#123;BUILD,RPMS,SPECS,SOURCES,SRPMS&#125;</div><div class=\"line\"></div><div class=\"line\">echo -e &quot;%_topdir $(echo $HOME)/rpmbuild\\n%dist .el$(lsb_release -s -r|cut -d&quot;.&quot; -f1).local&quot; &gt;&gt; ~/.rpmmacros</div></pre></td></tr></table></figure></p>\n<p>3.下载 wl-kmod*nosrc.rpm 到任意目录，比如 ～/package<br><a href=\"http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm\">http://elrepo.org/linux/elrepo/el7/SRPMS/wl-kmod-6_30_223_271-3.el7.elrepo.nosrc.rpm</a></p>\n<p>4.下载合适的驱动<br><a href=\"http://www.broadcom.com/support/802.11\">http://www.broadcom.com/support/802.11</a></p>\n<p>选择64位的驱动，下载到~/rpmbuild/SOURCES/目录</p>\n<p>5.构建kmod-wl<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rpmbuild --rebuild --target=`uname -m` --define &apos;packager yukai&apos; ~/package/wl-kmod*nosrc.rpm</div></pre></td></tr></table></figure></p>\n<p>其中，yukai是当前登陆用户，~/package/是第三步下载的rpm文件位置</p>\n<p>6.安装kmod-wl</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rpm -Uvh /home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm</div></pre></td></tr></table></figure>\n<p>第五步构建完成之后,在～/rpmbuild/RPMS/x86_64目录会有kmod-wl*rpm文件生成，安装它即可</p>\n<p>7.删除不用的文件</p>\n<p>保存/home/yukai/rpmbuild/RPMS/x86_64/kmod-wl*rpm文件，然后删除～/rpmbuild/</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm -rf ～/rpmbuild/</div></pre></td></tr></table></figure>\n<p>8.重启即可</p>\n<img src=\"/2017/02/25/centos7BCM驱动安装/demo.png\" alt=\"demo\" title=\"demo\">"},{"layout":"post","title":"hexo博客备份方案","date":"2017-04-11T13:40:40.000Z","_content":"周末的时候给博客换了一个[主题](https://github.com/iissnan/hexo-theme-next)，现在的博客看起来比之前的要清爽多了。\n \n{% asset_img blog.png blog %}\n<!-- more -->\n\nhexo是把生成的一套html发布到服务器上面的，我使用了github来托管自己的博客，每次发布时只把生成的html等文件发布到github，源代码并不会一同发到上面。\n\n如果是换电脑的话就很不方便了，再加上之前使用hexo generate -d发布博客的时候出了点问题，所以抽空写了一个专门用来发布博客和保存源代码的脚本，在此记录。\n\n## 脚本\n\n```\n# hexo generate -d 命令失效，将hexo分支推送到了master分支。使用此脚本进行部署\n# 将此脚步置于与blog同级目录下。\n# 部署\nroot=\"/home/yukai/project/blog\"\nfolder=\"$root/blogdeploy\"\nblog=\"$root/Hikyu.github.io\"\nif [ ! -d \"$folder\" ]; then\n  echo \"初始化...\"\n  mkdir \"$folder\"\n  cp -R \"$blog/.git/\" \"$folder/.git/\"\n  cd \"$folder\"\n  git checkout master\nfi\necho \"博客生成...\"\ncd \"$blog\"\ngit checkout hexo\nhexo generate\ncp -R \"$blog\"/public/* \"$folder\"\necho \"博客发布...\"\ncd \"$folder\"\ngit add --all .\ngit commit -m 'update'\ngit push origin master\necho \"备份博客源码到hexo分支...\"\ncd \"$blog\"\ngit add --all .\ngit commit -m 'update'\ngit push origin hexo\n```\n将上述脚本保存为deploy.sh。\n\n使用时需要将变量`root`设为博客目录的父目录。\n\n如果博客目录还不存在(换电脑)，需要使用`git clone`命令把博客源代码下载下来。\n\n修改博客源码后，执行 `sudo ./deploy.sh`进行博客发布与备份。\n\n## 原理\n \n- 发布博客\n  \n  `hexo generate -d` 可以将博客编译后发布到服务器。其原理就是将源代码中`public`目录下的内容推送到远程分支上面。\n\n  我们使用`master`分支保存发布的博客(github也规定了要发布的博客必须为master分支)。\n  \n  首先建立推送博客的目录`$folder`，并且将博客目录`$blog`下`.git`文件夹拷贝到`$folder`；\n  \n  切换到博客目录`$blog`，然后生成博客，将生成的`public`目录的内容拷贝到`$folder`；\n\n  将`$folder`中的内容推送到远程分支master，完成发布。\n\n- 源码备份\n\n  使用新的分支`hexo`来保存我们的博客源代码。\n\n  切换到博客目录`$blog`，并切换分支到hexo；\n\n  将博客目录`$blog`中的源代码内容推动到远程分支`hexo`，完成备份。\n\n\n   \n","source":"_posts/hexo博客备份方案.md","raw":"---\nlayout: post\ntitle: hexo博客备份方案\ndate: 2017-04-11 21:40:40\ncategories: 工具\ntags: \n- hexo\n---\n周末的时候给博客换了一个[主题](https://github.com/iissnan/hexo-theme-next)，现在的博客看起来比之前的要清爽多了。\n \n{% asset_img blog.png blog %}\n<!-- more -->\n\nhexo是把生成的一套html发布到服务器上面的，我使用了github来托管自己的博客，每次发布时只把生成的html等文件发布到github，源代码并不会一同发到上面。\n\n如果是换电脑的话就很不方便了，再加上之前使用hexo generate -d发布博客的时候出了点问题，所以抽空写了一个专门用来发布博客和保存源代码的脚本，在此记录。\n\n## 脚本\n\n```\n# hexo generate -d 命令失效，将hexo分支推送到了master分支。使用此脚本进行部署\n# 将此脚步置于与blog同级目录下。\n# 部署\nroot=\"/home/yukai/project/blog\"\nfolder=\"$root/blogdeploy\"\nblog=\"$root/Hikyu.github.io\"\nif [ ! -d \"$folder\" ]; then\n  echo \"初始化...\"\n  mkdir \"$folder\"\n  cp -R \"$blog/.git/\" \"$folder/.git/\"\n  cd \"$folder\"\n  git checkout master\nfi\necho \"博客生成...\"\ncd \"$blog\"\ngit checkout hexo\nhexo generate\ncp -R \"$blog\"/public/* \"$folder\"\necho \"博客发布...\"\ncd \"$folder\"\ngit add --all .\ngit commit -m 'update'\ngit push origin master\necho \"备份博客源码到hexo分支...\"\ncd \"$blog\"\ngit add --all .\ngit commit -m 'update'\ngit push origin hexo\n```\n将上述脚本保存为deploy.sh。\n\n使用时需要将变量`root`设为博客目录的父目录。\n\n如果博客目录还不存在(换电脑)，需要使用`git clone`命令把博客源代码下载下来。\n\n修改博客源码后，执行 `sudo ./deploy.sh`进行博客发布与备份。\n\n## 原理\n \n- 发布博客\n  \n  `hexo generate -d` 可以将博客编译后发布到服务器。其原理就是将源代码中`public`目录下的内容推送到远程分支上面。\n\n  我们使用`master`分支保存发布的博客(github也规定了要发布的博客必须为master分支)。\n  \n  首先建立推送博客的目录`$folder`，并且将博客目录`$blog`下`.git`文件夹拷贝到`$folder`；\n  \n  切换到博客目录`$blog`，然后生成博客，将生成的`public`目录的内容拷贝到`$folder`；\n\n  将`$folder`中的内容推送到远程分支master，完成发布。\n\n- 源码备份\n\n  使用新的分支`hexo`来保存我们的博客源代码。\n\n  切换到博客目录`$blog`，并切换分支到hexo；\n\n  将博客目录`$blog`中的源代码内容推动到远程分支`hexo`，完成备份。\n\n\n   \n","slug":"hexo博客备份方案","published":1,"updated":"2017-04-11T14:14:54.245Z","comments":1,"photos":[],"link":"","_id":"cj4vch4db000kx3gc1jf3zrzp","content":"<p>周末的时候给博客换了一个<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"external\">主题</a>，现在的博客看起来比之前的要清爽多了。</p>\n<img src=\"/2017/04/11/hexo博客备份方案/blog.png\" alt=\"blog\" title=\"blog\">\n<a id=\"more\"></a>\n<p>hexo是把生成的一套html发布到服务器上面的，我使用了github来托管自己的博客，每次发布时只把生成的html等文件发布到github，源代码并不会一同发到上面。</p>\n<p>如果是换电脑的话就很不方便了，再加上之前使用hexo generate -d发布博客的时候出了点问题，所以抽空写了一个专门用来发布博客和保存源代码的脚本，在此记录。</p>\n<h2 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"># hexo generate -d 命令失效，将hexo分支推送到了master分支。使用此脚本进行部署</div><div class=\"line\"># 将此脚步置于与blog同级目录下。</div><div class=\"line\"># 部署</div><div class=\"line\">root=&quot;/home/yukai/project/blog&quot;</div><div class=\"line\">folder=&quot;$root/blogdeploy&quot;</div><div class=\"line\">blog=&quot;$root/Hikyu.github.io&quot;</div><div class=\"line\">if [ ! -d &quot;$folder&quot; ]; then</div><div class=\"line\">  echo &quot;初始化...&quot;</div><div class=\"line\">  mkdir &quot;$folder&quot;</div><div class=\"line\">  cp -R &quot;$blog/.git/&quot; &quot;$folder/.git/&quot;</div><div class=\"line\">  cd &quot;$folder&quot;</div><div class=\"line\">  git checkout master</div><div class=\"line\">fi</div><div class=\"line\">echo &quot;博客生成...&quot;</div><div class=\"line\">cd &quot;$blog&quot;</div><div class=\"line\">git checkout hexo</div><div class=\"line\">hexo generate</div><div class=\"line\">cp -R &quot;$blog&quot;/public/* &quot;$folder&quot;</div><div class=\"line\">echo &quot;博客发布...&quot;</div><div class=\"line\">cd &quot;$folder&quot;</div><div class=\"line\">git add --all .</div><div class=\"line\">git commit -m &apos;update&apos;</div><div class=\"line\">git push origin master</div><div class=\"line\">echo &quot;备份博客源码到hexo分支...&quot;</div><div class=\"line\">cd &quot;$blog&quot;</div><div class=\"line\">git add --all .</div><div class=\"line\">git commit -m &apos;update&apos;</div><div class=\"line\">git push origin hexo</div></pre></td></tr></table></figure>\n<p>将上述脚本保存为deploy.sh。</p>\n<p>使用时需要将变量<code>root</code>设为博客目录的父目录。</p>\n<p>如果博客目录还不存在(换电脑)，需要使用<code>git clone</code>命令把博客源代码下载下来。</p>\n<p>修改博客源码后，执行 <code>sudo ./deploy.sh</code>进行博客发布与备份。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ul>\n<li><p>发布博客</p>\n<p><code>hexo generate -d</code> 可以将博客编译后发布到服务器。其原理就是将源代码中<code>public</code>目录下的内容推送到远程分支上面。</p>\n<p>我们使用<code>master</code>分支保存发布的博客(github也规定了要发布的博客必须为master分支)。</p>\n<p>首先建立推送博客的目录<code>$folder</code>，并且将博客目录<code>$blog</code>下<code>.git</code>文件夹拷贝到<code>$folder</code>；</p>\n<p>切换到博客目录<code>$blog</code>，然后生成博客，将生成的<code>public</code>目录的内容拷贝到<code>$folder</code>；</p>\n<p>将<code>$folder</code>中的内容推送到远程分支master，完成发布。</p>\n</li>\n<li><p>源码备份</p>\n<p>使用新的分支<code>hexo</code>来保存我们的博客源代码。</p>\n<p>切换到博客目录<code>$blog</code>，并切换分支到hexo；</p>\n<p>将博客目录<code>$blog</code>中的源代码内容推动到远程分支<code>hexo</code>，完成备份。</p>\n</li>\n</ul>\n","excerpt":"<p>周末的时候给博客换了一个<a href=\"https://github.com/iissnan/hexo-theme-next\">主题</a>，现在的博客看起来比之前的要清爽多了。</p>\n<img src=\"/2017/04/11/hexo博客备份方案/blog.png\" alt=\"blog\" title=\"blog\">","more":"<p>hexo是把生成的一套html发布到服务器上面的，我使用了github来托管自己的博客，每次发布时只把生成的html等文件发布到github，源代码并不会一同发到上面。</p>\n<p>如果是换电脑的话就很不方便了，再加上之前使用hexo generate -d发布博客的时候出了点问题，所以抽空写了一个专门用来发布博客和保存源代码的脚本，在此记录。</p>\n<h2 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"># hexo generate -d 命令失效，将hexo分支推送到了master分支。使用此脚本进行部署</div><div class=\"line\"># 将此脚步置于与blog同级目录下。</div><div class=\"line\"># 部署</div><div class=\"line\">root=&quot;/home/yukai/project/blog&quot;</div><div class=\"line\">folder=&quot;$root/blogdeploy&quot;</div><div class=\"line\">blog=&quot;$root/Hikyu.github.io&quot;</div><div class=\"line\">if [ ! -d &quot;$folder&quot; ]; then</div><div class=\"line\">  echo &quot;初始化...&quot;</div><div class=\"line\">  mkdir &quot;$folder&quot;</div><div class=\"line\">  cp -R &quot;$blog/.git/&quot; &quot;$folder/.git/&quot;</div><div class=\"line\">  cd &quot;$folder&quot;</div><div class=\"line\">  git checkout master</div><div class=\"line\">fi</div><div class=\"line\">echo &quot;博客生成...&quot;</div><div class=\"line\">cd &quot;$blog&quot;</div><div class=\"line\">git checkout hexo</div><div class=\"line\">hexo generate</div><div class=\"line\">cp -R &quot;$blog&quot;/public/* &quot;$folder&quot;</div><div class=\"line\">echo &quot;博客发布...&quot;</div><div class=\"line\">cd &quot;$folder&quot;</div><div class=\"line\">git add --all .</div><div class=\"line\">git commit -m &apos;update&apos;</div><div class=\"line\">git push origin master</div><div class=\"line\">echo &quot;备份博客源码到hexo分支...&quot;</div><div class=\"line\">cd &quot;$blog&quot;</div><div class=\"line\">git add --all .</div><div class=\"line\">git commit -m &apos;update&apos;</div><div class=\"line\">git push origin hexo</div></pre></td></tr></table></figure>\n<p>将上述脚本保存为deploy.sh。</p>\n<p>使用时需要将变量<code>root</code>设为博客目录的父目录。</p>\n<p>如果博客目录还不存在(换电脑)，需要使用<code>git clone</code>命令把博客源代码下载下来。</p>\n<p>修改博客源码后，执行 <code>sudo ./deploy.sh</code>进行博客发布与备份。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ul>\n<li><p>发布博客</p>\n<p><code>hexo generate -d</code> 可以将博客编译后发布到服务器。其原理就是将源代码中<code>public</code>目录下的内容推送到远程分支上面。</p>\n<p>我们使用<code>master</code>分支保存发布的博客(github也规定了要发布的博客必须为master分支)。</p>\n<p>首先建立推送博客的目录<code>$folder</code>，并且将博客目录<code>$blog</code>下<code>.git</code>文件夹拷贝到<code>$folder</code>；</p>\n<p>切换到博客目录<code>$blog</code>，然后生成博客，将生成的<code>public</code>目录的内容拷贝到<code>$folder</code>；</p>\n<p>将<code>$folder</code>中的内容推送到远程分支master，完成发布。</p>\n</li>\n<li><p>源码备份</p>\n<p>使用新的分支<code>hexo</code>来保存我们的博客源代码。</p>\n<p>切换到博客目录<code>$blog</code>，并切换分支到hexo；</p>\n<p>将博客目录<code>$blog</code>中的源代码内容推动到远程分支<code>hexo</code>，完成备份。</p>\n</li>\n</ul>"},{"layout":"post","title":"Vps使用笔记","date":"2017-02-07T13:34:16.000Z","_content":"> 今天折腾了一天，总算是把翻墙的梯子搭起来了，租了国外的vps，然后在上面搭建了shadowsocks服务，手机和电脑就可以使用shadowsocks客户端的方式科学上网了。\n> Shadowsocks 是一个由很多人参与的开源项目，感谢shadowsocks作者[@clowwindy](https://github.com/clowwindy/shadowsocks).关于shadowssocks和vpn等等翻墙方式的区别,不再一一赘述，本文只是记录梯子搭建的过程\n\n## 购买VPS\n\nVPS的概念我也不是特别清楚，就把他当成主机好了，类似于阿里云等等。\n\n购买之后，会分配给你root账户密码，你就拥有了一台国外机房的主机。\n\nVPS 可以参考 [有哪些便宜稳定，速度也不错的Linux VPS 推荐？](https://www.zhihu.com/question/20800554),我买了Vultr 日本机房的vps,充了5美刀先试试。具体的购买方法自行谷歌\n\n<!-- more -->\n\n## 搭建shadowsocks服务\n\n### 升级内核\n\n我选择了Centos7的Linux发型版本作为操作系统。\n\n使用MobaXterm(或者是其他ssh工具)连接到分配给你的主机(root密码购买成功时会给出),\n\n首先升级一下内核：wget -O- https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh | bash\n\n完成之后，重启：\n\nreboot\n\n重新登录，查看内核版本：\n\nuname -r\n\n不出意外已经更新到了最新版本。接着执行：\n\nsysctl -a|grep congestion_control\n\n如果输出选项包含：net.ipv4.tcp_congestion_control = bbr 表示安装成功，否则需要手动开启bbr模式：\n\n```\necho \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\necho \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\nsysctl -p\nsysctl\nnet.ipv4.tcp_available_congestion_control\n```\n\n再次查看：\n\nsysctl -a|grep congestion_control\n\n### 搭建服务\n\n搭建服务可以选择使用别人写好的现成的脚本，也可以自己搭建，下面介绍这两种方法：\n\n#### 使用现成脚本\n\n执行以下命令：\n\n```wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n\n首先会提示你输入密码和端口，然后开始安装。安装完成后代表shadowsocks服务已经开启了。此时可以使用shadowsocks客户端去连接这个服务器了。\n\n脚本可用的命令：\n\n启动：/etc/init.d/shadowsocks start\n\n停止：/etc/init.d/shadowsocks stop\n\n重启：/etc/init.d/shadowsocks restart\n\n状态：/etc/init.d/shadowsocks status\n\n卸载：./shadowsocks.sh uninstall\n\n支持多用户的方法：修改配置文件:/etc/shadowsocks.json\n\n```\n{    \n    \"server\":\"0.0.0.0\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{\n         \"8989\":\"password0\",\n         \"9001\":\"password1\",\n         \"9002\":\"password2\",\n         \"9003\":\"password3\",\n         \"9004\":\"password4\"\n    },\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}```\n\n#### 自行搭建\n\n首先安装shadowsocks服务：\n\n```\nyum install python-setuptools && easy_install pip\npip install shadowsocks\n```\n\n显示 “Successfully installed shadowsocks-2.6.10″。意味着Shadowsocks已经成功安装。\n\n接着，创建一个Shadowsocks配置文件。输入以下命令：\n\nvi /etc/shadowsocks.json\n\n然后在该文件中输入：\n\n```\n{\n    \"server\":\"your_server_ip\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"auooo.com\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n上面各项配置的含义已经很明显了，除了server(vps的ip)、server_port和password之外，其他默认即可。保存该文件。执行：\n\nssserver -c /etc/shadowsocks.json -d start\n\n服务就启动了，如果想要关闭，执行：\n\nssserver -c /etc/shadowsocks.json -d stop\n\n支持多用户的方法与上面的类似\n\n#### 端口问题\n\n有时候服务正常启动了，但是发现客户端还是没有办法翻墙。这时要注意检查vps开放的端口：\n\nCentos升级到7之后，使用firewalld代替了原来的iptables作为防火墙。\n\n启动：systemctl start  firewalld\n\n重启：firewall-cmd --reload\n\n查看状态：systemctl status firewalld 或者 firewall-cmd --state  \n\n查看开放的端口：firewall-cmd --list-ports\n\n增加开放端口：firewall-cmd --add-port=9001/tcp --permanent   (重启生效)\n\n9001：要开放的端口\n\ntcp：协议\n\n--permanent：永久生效，没有此参数重启后失效其他命令自行查找\n\n## 锐速加速\n\n[锐速破解版linux一键自动安装包（8月7日更新）](https://www.91yun.org/archives/683)\n\n文章开头的更新内核使用bbr加速或者锐速加速都可以，没试过哪种方式效果更好一些\n\n## vps使用ssh密钥登录\n\n使用ssh root账户和密码登录的方式是vps一开始会给出的登录主机的方式，这种方式比较简单，但是容易被别人暴力破解登录密码，控制我们的主机。\n\n所以，应该使用ssh密钥登录的方式来增强安全性。\n\n### 修改root密码\n\n第一步应该先把默认的root密码修改为自己的密码，最好复杂一点。\n\n确保自己记住了这个密码。\n\npasswd\n\n### 创建用户\n\n可以先创建一个非root用户：\n\n```\nuseradd yukai\n```\n\n创建账户密码：\n\n```\npasswd yukai \n```\n\n给予账户sudo权限：\n\n```\nvisudo\n```\n\n在 root ALL=(ALL)  ALL 下新增一行：\n\nyukai ALL=(ALL)  ALL\n\n切换到yukai这个账户：\n\nsu - yukai \n\n### 创建密钥\n\n```\nssh-keygen -t rsa\n```\n\n在 /home/yukai 下生成了一个隐藏目录：.ssh, 执行：\n\n```\ncd ~/.sshcat id_rsa.pub >> authorized_keys\nchmod 600 authorized_keys\n```\n\n将 id_rsa文件下载下来保存到本地(使用MobaXterm等工具)\n\n### 使用密钥认证登录\n\n打开MobaXterm工具，新建一个session，选择ssh，在Advanced SSH settings选项中选择 use private keygen复选框，并把上一步下载好的id_rsa选择进来。\n\n以用户yukai登录，提示输入密钥文件的密码，输入生成密钥时所填的密码，如果能够登录，则设置正确了\n\n### 禁用root用户登录和密码登录\n\n确保自己记住了root密码，并且上一步密钥认证方式登录成功。\n\n```\nsudo vi /etc/ssh/sshd_config\n```\n找到以下几项，进行如下设置：\n\n```\nRSAAuthentication yes\nPubkeyAuthentication yes\nPermitRootLogin no\nPasswordAuthentication no\n```\n\n重启ssh服务：\n\n```\nservice sshd restart\n```\n\n### 多台主机管理\n\n可以将生成的密钥文件authorized_keys保存到多个主机的相同位置：~/.ssh\n\n然后进行上面的配置。此时就可以使用一份私钥文件id_rsa登录多个主机了。\n\n## ss多用户管理\n\n前端使用ss-panel，后台使用shadowsocks-manyuser\n\n教程参见：\n\n[可能是最好的 ss-panel 部署教程](https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/)\n\n[ShadowSocks多用户管理系统搭建（moeSS+manyuser）](https://blog.linuxeye.com/426.html)\n\n## 在Linux上使用shadowsocks服务翻墙\n\n### 开启shadowsocks客户端\n\n确认安装了shadowsocks服务并从配置好的shadowsocks服务器端获得配置文件: /etc/shadowsocks/config.json\n\n```\n{\n        \"server\":\"remote-shadowsocks-server-ip-addr\",\n        \"server_port\":443,\n        \"local_address\":\"127.0.0.1\",\n        \"local_port\":1080,\n        \"password\":\"your-passwd\",\n        \"timeout\":300,\n        \"method\":\"aes-256-cfb\",\n        \"fast_open\":false,\n        \"workers\":1\n}\n```\n在config.json所在目录下运行sslocal即可：\n\nsslocal -c /etc/shadowsocks/config.json\n\n也可以手动指定参数运行：\n\nsslocal -s 服务器地址 -p 服务器端口 -l 本地端端口 -k 密码 -m 加密方法\n\n### 使用chrome代理\n\n在chrome应用商店中查找 Proxy SwitchyOmega,并安装该扩展\n\n新建情景模式，代理协议选择SOCKS5，代理服务器选择 127.0.0.1， 代理端口选择上一步中的local_port,即1080\n\n启用该扩展程序，此时可顺利使用google了 \n\n## 附录\n\n### 安装vim\n\nvim编辑器需要安装三个包：\n\n```\nvim-enhanced-7.0.109-7.el5\nvim-minimal-7.0.109-7.el5\nvim-common-7.0.109-7.el5\n```\n\n输入  `rpm -qa|grep vim` 这个命令，如何vim已经正确安装，则会显示上面三个包的名称\n\n如果缺少了其中某个，比如说： vim-enhanced这个包少了，执行：`yum -y install vim-enhanced` 命令，它会自动下载安装\n\n如果上面三个包一个都没有显示，则直接输入命令：\n\n```\nyum -y install vim*\n```\n\n### 安装net-tools\n\n```\nyum install net-tools\n```\n\n### 更改文件所有者\n\nchown -R www.www ./    将本路径下所有文件所有者改为www组的www\n\n## 参考\n\n[Shadowsocks Python版一键安装脚本](https://teddysun.com/342.html)\n\n[使用 Shadowsocks 自建翻墙服务器，实现全平台 100% 翻墙无障碍](https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/)\n\n[http://shadowsocks.org/](http://shadowsocks.org/en/download/clients.html)\n\n[shadowsocks（影梭）不完全指南](http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/)\n","source":"_posts/Vps使用笔记.md","raw":"---\nlayout: post\ntitle: Vps使用笔记\ndate: 2017-02-07 21:34:16\ncategories: 工具\ntags: linux\n---\n> 今天折腾了一天，总算是把翻墙的梯子搭起来了，租了国外的vps，然后在上面搭建了shadowsocks服务，手机和电脑就可以使用shadowsocks客户端的方式科学上网了。\n> Shadowsocks 是一个由很多人参与的开源项目，感谢shadowsocks作者[@clowwindy](https://github.com/clowwindy/shadowsocks).关于shadowssocks和vpn等等翻墙方式的区别,不再一一赘述，本文只是记录梯子搭建的过程\n\n## 购买VPS\n\nVPS的概念我也不是特别清楚，就把他当成主机好了，类似于阿里云等等。\n\n购买之后，会分配给你root账户密码，你就拥有了一台国外机房的主机。\n\nVPS 可以参考 [有哪些便宜稳定，速度也不错的Linux VPS 推荐？](https://www.zhihu.com/question/20800554),我买了Vultr 日本机房的vps,充了5美刀先试试。具体的购买方法自行谷歌\n\n<!-- more -->\n\n## 搭建shadowsocks服务\n\n### 升级内核\n\n我选择了Centos7的Linux发型版本作为操作系统。\n\n使用MobaXterm(或者是其他ssh工具)连接到分配给你的主机(root密码购买成功时会给出),\n\n首先升级一下内核：wget -O- https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh | bash\n\n完成之后，重启：\n\nreboot\n\n重新登录，查看内核版本：\n\nuname -r\n\n不出意外已经更新到了最新版本。接着执行：\n\nsysctl -a|grep congestion_control\n\n如果输出选项包含：net.ipv4.tcp_congestion_control = bbr 表示安装成功，否则需要手动开启bbr模式：\n\n```\necho \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\necho \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\nsysctl -p\nsysctl\nnet.ipv4.tcp_available_congestion_control\n```\n\n再次查看：\n\nsysctl -a|grep congestion_control\n\n### 搭建服务\n\n搭建服务可以选择使用别人写好的现成的脚本，也可以自己搭建，下面介绍这两种方法：\n\n#### 使用现成脚本\n\n执行以下命令：\n\n```wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n\n首先会提示你输入密码和端口，然后开始安装。安装完成后代表shadowsocks服务已经开启了。此时可以使用shadowsocks客户端去连接这个服务器了。\n\n脚本可用的命令：\n\n启动：/etc/init.d/shadowsocks start\n\n停止：/etc/init.d/shadowsocks stop\n\n重启：/etc/init.d/shadowsocks restart\n\n状态：/etc/init.d/shadowsocks status\n\n卸载：./shadowsocks.sh uninstall\n\n支持多用户的方法：修改配置文件:/etc/shadowsocks.json\n\n```\n{    \n    \"server\":\"0.0.0.0\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{\n         \"8989\":\"password0\",\n         \"9001\":\"password1\",\n         \"9002\":\"password2\",\n         \"9003\":\"password3\",\n         \"9004\":\"password4\"\n    },\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}```\n\n#### 自行搭建\n\n首先安装shadowsocks服务：\n\n```\nyum install python-setuptools && easy_install pip\npip install shadowsocks\n```\n\n显示 “Successfully installed shadowsocks-2.6.10″。意味着Shadowsocks已经成功安装。\n\n接着，创建一个Shadowsocks配置文件。输入以下命令：\n\nvi /etc/shadowsocks.json\n\n然后在该文件中输入：\n\n```\n{\n    \"server\":\"your_server_ip\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"auooo.com\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n上面各项配置的含义已经很明显了，除了server(vps的ip)、server_port和password之外，其他默认即可。保存该文件。执行：\n\nssserver -c /etc/shadowsocks.json -d start\n\n服务就启动了，如果想要关闭，执行：\n\nssserver -c /etc/shadowsocks.json -d stop\n\n支持多用户的方法与上面的类似\n\n#### 端口问题\n\n有时候服务正常启动了，但是发现客户端还是没有办法翻墙。这时要注意检查vps开放的端口：\n\nCentos升级到7之后，使用firewalld代替了原来的iptables作为防火墙。\n\n启动：systemctl start  firewalld\n\n重启：firewall-cmd --reload\n\n查看状态：systemctl status firewalld 或者 firewall-cmd --state  \n\n查看开放的端口：firewall-cmd --list-ports\n\n增加开放端口：firewall-cmd --add-port=9001/tcp --permanent   (重启生效)\n\n9001：要开放的端口\n\ntcp：协议\n\n--permanent：永久生效，没有此参数重启后失效其他命令自行查找\n\n## 锐速加速\n\n[锐速破解版linux一键自动安装包（8月7日更新）](https://www.91yun.org/archives/683)\n\n文章开头的更新内核使用bbr加速或者锐速加速都可以，没试过哪种方式效果更好一些\n\n## vps使用ssh密钥登录\n\n使用ssh root账户和密码登录的方式是vps一开始会给出的登录主机的方式，这种方式比较简单，但是容易被别人暴力破解登录密码，控制我们的主机。\n\n所以，应该使用ssh密钥登录的方式来增强安全性。\n\n### 修改root密码\n\n第一步应该先把默认的root密码修改为自己的密码，最好复杂一点。\n\n确保自己记住了这个密码。\n\npasswd\n\n### 创建用户\n\n可以先创建一个非root用户：\n\n```\nuseradd yukai\n```\n\n创建账户密码：\n\n```\npasswd yukai \n```\n\n给予账户sudo权限：\n\n```\nvisudo\n```\n\n在 root ALL=(ALL)  ALL 下新增一行：\n\nyukai ALL=(ALL)  ALL\n\n切换到yukai这个账户：\n\nsu - yukai \n\n### 创建密钥\n\n```\nssh-keygen -t rsa\n```\n\n在 /home/yukai 下生成了一个隐藏目录：.ssh, 执行：\n\n```\ncd ~/.sshcat id_rsa.pub >> authorized_keys\nchmod 600 authorized_keys\n```\n\n将 id_rsa文件下载下来保存到本地(使用MobaXterm等工具)\n\n### 使用密钥认证登录\n\n打开MobaXterm工具，新建一个session，选择ssh，在Advanced SSH settings选项中选择 use private keygen复选框，并把上一步下载好的id_rsa选择进来。\n\n以用户yukai登录，提示输入密钥文件的密码，输入生成密钥时所填的密码，如果能够登录，则设置正确了\n\n### 禁用root用户登录和密码登录\n\n确保自己记住了root密码，并且上一步密钥认证方式登录成功。\n\n```\nsudo vi /etc/ssh/sshd_config\n```\n找到以下几项，进行如下设置：\n\n```\nRSAAuthentication yes\nPubkeyAuthentication yes\nPermitRootLogin no\nPasswordAuthentication no\n```\n\n重启ssh服务：\n\n```\nservice sshd restart\n```\n\n### 多台主机管理\n\n可以将生成的密钥文件authorized_keys保存到多个主机的相同位置：~/.ssh\n\n然后进行上面的配置。此时就可以使用一份私钥文件id_rsa登录多个主机了。\n\n## ss多用户管理\n\n前端使用ss-panel，后台使用shadowsocks-manyuser\n\n教程参见：\n\n[可能是最好的 ss-panel 部署教程](https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/)\n\n[ShadowSocks多用户管理系统搭建（moeSS+manyuser）](https://blog.linuxeye.com/426.html)\n\n## 在Linux上使用shadowsocks服务翻墙\n\n### 开启shadowsocks客户端\n\n确认安装了shadowsocks服务并从配置好的shadowsocks服务器端获得配置文件: /etc/shadowsocks/config.json\n\n```\n{\n        \"server\":\"remote-shadowsocks-server-ip-addr\",\n        \"server_port\":443,\n        \"local_address\":\"127.0.0.1\",\n        \"local_port\":1080,\n        \"password\":\"your-passwd\",\n        \"timeout\":300,\n        \"method\":\"aes-256-cfb\",\n        \"fast_open\":false,\n        \"workers\":1\n}\n```\n在config.json所在目录下运行sslocal即可：\n\nsslocal -c /etc/shadowsocks/config.json\n\n也可以手动指定参数运行：\n\nsslocal -s 服务器地址 -p 服务器端口 -l 本地端端口 -k 密码 -m 加密方法\n\n### 使用chrome代理\n\n在chrome应用商店中查找 Proxy SwitchyOmega,并安装该扩展\n\n新建情景模式，代理协议选择SOCKS5，代理服务器选择 127.0.0.1， 代理端口选择上一步中的local_port,即1080\n\n启用该扩展程序，此时可顺利使用google了 \n\n## 附录\n\n### 安装vim\n\nvim编辑器需要安装三个包：\n\n```\nvim-enhanced-7.0.109-7.el5\nvim-minimal-7.0.109-7.el5\nvim-common-7.0.109-7.el5\n```\n\n输入  `rpm -qa|grep vim` 这个命令，如何vim已经正确安装，则会显示上面三个包的名称\n\n如果缺少了其中某个，比如说： vim-enhanced这个包少了，执行：`yum -y install vim-enhanced` 命令，它会自动下载安装\n\n如果上面三个包一个都没有显示，则直接输入命令：\n\n```\nyum -y install vim*\n```\n\n### 安装net-tools\n\n```\nyum install net-tools\n```\n\n### 更改文件所有者\n\nchown -R www.www ./    将本路径下所有文件所有者改为www组的www\n\n## 参考\n\n[Shadowsocks Python版一键安装脚本](https://teddysun.com/342.html)\n\n[使用 Shadowsocks 自建翻墙服务器，实现全平台 100% 翻墙无障碍](https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/)\n\n[http://shadowsocks.org/](http://shadowsocks.org/en/download/clients.html)\n\n[shadowsocks（影梭）不完全指南](http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/)\n","slug":"Vps使用笔记","published":1,"updated":"2017-04-11T13:08:38.836Z","comments":1,"photos":[],"link":"","_id":"cj4vch4dh000nx3gclbltd9bg","content":"<blockquote>\n<p>今天折腾了一天，总算是把翻墙的梯子搭起来了，租了国外的vps，然后在上面搭建了shadowsocks服务，手机和电脑就可以使用shadowsocks客户端的方式科学上网了。<br>Shadowsocks 是一个由很多人参与的开源项目，感谢shadowsocks作者<a href=\"https://github.com/clowwindy/shadowsocks\" target=\"_blank\" rel=\"external\">@clowwindy</a>.关于shadowssocks和vpn等等翻墙方式的区别,不再一一赘述，本文只是记录梯子搭建的过程</p>\n</blockquote>\n<h2 id=\"购买VPS\"><a href=\"#购买VPS\" class=\"headerlink\" title=\"购买VPS\"></a>购买VPS</h2><p>VPS的概念我也不是特别清楚，就把他当成主机好了，类似于阿里云等等。</p>\n<p>购买之后，会分配给你root账户密码，你就拥有了一台国外机房的主机。</p>\n<p>VPS 可以参考 <a href=\"https://www.zhihu.com/question/20800554\" target=\"_blank\" rel=\"external\">有哪些便宜稳定，速度也不错的Linux VPS 推荐？</a>,我买了Vultr 日本机房的vps,充了5美刀先试试。具体的购买方法自行谷歌</p>\n<a id=\"more\"></a>\n<h2 id=\"搭建shadowsocks服务\"><a href=\"#搭建shadowsocks服务\" class=\"headerlink\" title=\"搭建shadowsocks服务\"></a>搭建shadowsocks服务</h2><h3 id=\"升级内核\"><a href=\"#升级内核\" class=\"headerlink\" title=\"升级内核\"></a>升级内核</h3><p>我选择了Centos7的Linux发型版本作为操作系统。</p>\n<p>使用MobaXterm(或者是其他ssh工具)连接到分配给你的主机(root密码购买成功时会给出),</p>\n<p>首先升级一下内核：wget -O- <a href=\"https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh\" target=\"_blank\" rel=\"external\">https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh</a> | bash</p>\n<p>完成之后，重启：</p>\n<p>reboot</p>\n<p>重新登录，查看内核版本：</p>\n<p>uname -r</p>\n<p>不出意外已经更新到了最新版本。接着执行：</p>\n<p>sysctl -a|grep congestion_control</p>\n<p>如果输出选项包含：net.ipv4.tcp_congestion_control = bbr 表示安装成功，否则需要手动开启bbr模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">sysctl -p</div><div class=\"line\">sysctl</div><div class=\"line\">net.ipv4.tcp_available_congestion_control</div></pre></td></tr></table></figure>\n<p>再次查看：</p>\n<p>sysctl -a|grep congestion_control</p>\n<h3 id=\"搭建服务\"><a href=\"#搭建服务\" class=\"headerlink\" title=\"搭建服务\"></a>搭建服务</h3><p>搭建服务可以选择使用别人写好的现成的脚本，也可以自己搭建，下面介绍这两种方法：</p>\n<h4 id=\"使用现成脚本\"><a href=\"#使用现成脚本\" class=\"headerlink\" title=\"使用现成脚本\"></a>使用现成脚本</h4><p>执行以下命令：</p>\n<figure class=\"highlight plain\"><figcaption><span>--no-check-certificate</span><a href=\"https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\" target=\"_blank\" rel=\"external\">link</a></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x shadowsocks.sh</div><div class=\"line\">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</div></pre></td></tr></table></figure>\n<p>首先会提示你输入密码和端口，然后开始安装。安装完成后代表shadowsocks服务已经开启了。此时可以使用shadowsocks客户端去连接这个服务器了。</p>\n<p>脚本可用的命令：</p>\n<p>启动：/etc/init.d/shadowsocks start</p>\n<p>停止：/etc/init.d/shadowsocks stop</p>\n<p>重启：/etc/init.d/shadowsocks restart</p>\n<p>状态：/etc/init.d/shadowsocks status</p>\n<p>卸载：./shadowsocks.sh uninstall</p>\n<p>支持多用户的方法：修改配置文件:/etc/shadowsocks.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;    </div><div class=\"line\">    &quot;server&quot;:&quot;0.0.0.0&quot;,</div><div class=\"line\">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;port_password&quot;:&#123;</div><div class=\"line\">         &quot;8989&quot;:&quot;password0&quot;,</div><div class=\"line\">         &quot;9001&quot;:&quot;password1&quot;,</div><div class=\"line\">         &quot;9002&quot;:&quot;password2&quot;,</div><div class=\"line\">         &quot;9003&quot;:&quot;password3&quot;,</div><div class=\"line\">         &quot;9004&quot;:&quot;password4&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"自行搭建\"><a href=\"#自行搭建\" class=\"headerlink\" title=\"自行搭建\"></a>自行搭建</h4><p>首先安装shadowsocks服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</div><div class=\"line\">pip install shadowsocks</div></pre></td></tr></table></figure>\n<p>显示 “Successfully installed shadowsocks-2.6.10″。意味着Shadowsocks已经成功安装。</p>\n<p>接着，创建一个Shadowsocks配置文件。输入以下命令：</p>\n<p>vi /etc/shadowsocks.json</p>\n<p>然后在该文件中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;server&quot;:&quot;your_server_ip&quot;,</div><div class=\"line\">    &quot;server_port&quot;:8388,</div><div class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;password&quot;:&quot;auooo.com&quot;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面各项配置的含义已经很明显了，除了server(vps的ip)、server_port和password之外，其他默认即可。保存该文件。执行：</p>\n<p>ssserver -c /etc/shadowsocks.json -d start</p>\n<p>服务就启动了，如果想要关闭，执行：</p>\n<p>ssserver -c /etc/shadowsocks.json -d stop</p>\n<p>支持多用户的方法与上面的类似</p>\n<h4 id=\"端口问题\"><a href=\"#端口问题\" class=\"headerlink\" title=\"端口问题\"></a>端口问题</h4><p>有时候服务正常启动了，但是发现客户端还是没有办法翻墙。这时要注意检查vps开放的端口：</p>\n<p>Centos升级到7之后，使用firewalld代替了原来的iptables作为防火墙。</p>\n<p>启动：systemctl start  firewalld</p>\n<p>重启：firewall-cmd –reload</p>\n<p>查看状态：systemctl status firewalld 或者 firewall-cmd –state  </p>\n<p>查看开放的端口：firewall-cmd –list-ports</p>\n<p>增加开放端口：firewall-cmd –add-port=9001/tcp –permanent   (重启生效)</p>\n<p>9001：要开放的端口</p>\n<p>tcp：协议</p>\n<p>–permanent：永久生效，没有此参数重启后失效其他命令自行查找</p>\n<h2 id=\"锐速加速\"><a href=\"#锐速加速\" class=\"headerlink\" title=\"锐速加速\"></a>锐速加速</h2><p><a href=\"https://www.91yun.org/archives/683\" target=\"_blank\" rel=\"external\">锐速破解版linux一键自动安装包（8月7日更新）</a></p>\n<p>文章开头的更新内核使用bbr加速或者锐速加速都可以，没试过哪种方式效果更好一些</p>\n<h2 id=\"vps使用ssh密钥登录\"><a href=\"#vps使用ssh密钥登录\" class=\"headerlink\" title=\"vps使用ssh密钥登录\"></a>vps使用ssh密钥登录</h2><p>使用ssh root账户和密码登录的方式是vps一开始会给出的登录主机的方式，这种方式比较简单，但是容易被别人暴力破解登录密码，控制我们的主机。</p>\n<p>所以，应该使用ssh密钥登录的方式来增强安全性。</p>\n<h3 id=\"修改root密码\"><a href=\"#修改root密码\" class=\"headerlink\" title=\"修改root密码\"></a>修改root密码</h3><p>第一步应该先把默认的root密码修改为自己的密码，最好复杂一点。</p>\n<p>确保自己记住了这个密码。</p>\n<p>passwd</p>\n<h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><p>可以先创建一个非root用户：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">useradd yukai</div></pre></td></tr></table></figure>\n<p>创建账户密码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">passwd yukai</div></pre></td></tr></table></figure>\n<p>给予账户sudo权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">visudo</div></pre></td></tr></table></figure>\n<p>在 root ALL=(ALL)  ALL 下新增一行：</p>\n<p>yukai ALL=(ALL)  ALL</p>\n<p>切换到yukai这个账户：</p>\n<p>su - yukai </p>\n<h3 id=\"创建密钥\"><a href=\"#创建密钥\" class=\"headerlink\" title=\"创建密钥\"></a>创建密钥</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen -t rsa</div></pre></td></tr></table></figure>\n<p>在 /home/yukai 下生成了一个隐藏目录：.ssh, 执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~/.sshcat id_rsa.pub &gt;&gt; authorized_keys</div><div class=\"line\">chmod 600 authorized_keys</div></pre></td></tr></table></figure>\n<p>将 id_rsa文件下载下来保存到本地(使用MobaXterm等工具)</p>\n<h3 id=\"使用密钥认证登录\"><a href=\"#使用密钥认证登录\" class=\"headerlink\" title=\"使用密钥认证登录\"></a>使用密钥认证登录</h3><p>打开MobaXterm工具，新建一个session，选择ssh，在Advanced SSH settings选项中选择 use private keygen复选框，并把上一步下载好的id_rsa选择进来。</p>\n<p>以用户yukai登录，提示输入密钥文件的密码，输入生成密钥时所填的密码，如果能够登录，则设置正确了</p>\n<h3 id=\"禁用root用户登录和密码登录\"><a href=\"#禁用root用户登录和密码登录\" class=\"headerlink\" title=\"禁用root用户登录和密码登录\"></a>禁用root用户登录和密码登录</h3><p>确保自己记住了root密码，并且上一步密钥认证方式登录成功。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo vi /etc/ssh/sshd_config</div></pre></td></tr></table></figure>\n<p>找到以下几项，进行如下设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">RSAAuthentication yes</div><div class=\"line\">PubkeyAuthentication yes</div><div class=\"line\">PermitRootLogin no</div><div class=\"line\">PasswordAuthentication no</div></pre></td></tr></table></figure>\n<p>重启ssh服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service sshd restart</div></pre></td></tr></table></figure>\n<h3 id=\"多台主机管理\"><a href=\"#多台主机管理\" class=\"headerlink\" title=\"多台主机管理\"></a>多台主机管理</h3><p>可以将生成的密钥文件authorized_keys保存到多个主机的相同位置：~/.ssh</p>\n<p>然后进行上面的配置。此时就可以使用一份私钥文件id_rsa登录多个主机了。</p>\n<h2 id=\"ss多用户管理\"><a href=\"#ss多用户管理\" class=\"headerlink\" title=\"ss多用户管理\"></a>ss多用户管理</h2><p>前端使用ss-panel，后台使用shadowsocks-manyuser</p>\n<p>教程参见：</p>\n<p><a href=\"https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/\" target=\"_blank\" rel=\"external\">可能是最好的 ss-panel 部署教程</a></p>\n<p><a href=\"https://blog.linuxeye.com/426.html\" target=\"_blank\" rel=\"external\">ShadowSocks多用户管理系统搭建（moeSS+manyuser）</a></p>\n<h2 id=\"在Linux上使用shadowsocks服务翻墙\"><a href=\"#在Linux上使用shadowsocks服务翻墙\" class=\"headerlink\" title=\"在Linux上使用shadowsocks服务翻墙\"></a>在Linux上使用shadowsocks服务翻墙</h2><h3 id=\"开启shadowsocks客户端\"><a href=\"#开启shadowsocks客户端\" class=\"headerlink\" title=\"开启shadowsocks客户端\"></a>开启shadowsocks客户端</h3><p>确认安装了shadowsocks服务并从配置好的shadowsocks服务器端获得配置文件: /etc/shadowsocks/config.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">        &quot;server&quot;:&quot;remote-shadowsocks-server-ip-addr&quot;,</div><div class=\"line\">        &quot;server_port&quot;:443,</div><div class=\"line\">        &quot;local_address&quot;:&quot;127.0.0.1&quot;,</div><div class=\"line\">        &quot;local_port&quot;:1080,</div><div class=\"line\">        &quot;password&quot;:&quot;your-passwd&quot;,</div><div class=\"line\">        &quot;timeout&quot;:300,</div><div class=\"line\">        &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">        &quot;fast_open&quot;:false,</div><div class=\"line\">        &quot;workers&quot;:1</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在config.json所在目录下运行sslocal即可：</p>\n<p>sslocal -c /etc/shadowsocks/config.json</p>\n<p>也可以手动指定参数运行：</p>\n<p>sslocal -s 服务器地址 -p 服务器端口 -l 本地端端口 -k 密码 -m 加密方法</p>\n<h3 id=\"使用chrome代理\"><a href=\"#使用chrome代理\" class=\"headerlink\" title=\"使用chrome代理\"></a>使用chrome代理</h3><p>在chrome应用商店中查找 Proxy SwitchyOmega,并安装该扩展</p>\n<p>新建情景模式，代理协议选择SOCKS5，代理服务器选择 127.0.0.1， 代理端口选择上一步中的local_port,即1080</p>\n<p>启用该扩展程序，此时可顺利使用google了 </p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"安装vim\"><a href=\"#安装vim\" class=\"headerlink\" title=\"安装vim\"></a>安装vim</h3><p>vim编辑器需要安装三个包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim-enhanced-7.0.109-7.el5</div><div class=\"line\">vim-minimal-7.0.109-7.el5</div><div class=\"line\">vim-common-7.0.109-7.el5</div></pre></td></tr></table></figure>\n<p>输入  <code>rpm -qa|grep vim</code> 这个命令，如何vim已经正确安装，则会显示上面三个包的名称</p>\n<p>如果缺少了其中某个，比如说： vim-enhanced这个包少了，执行：<code>yum -y install vim-enhanced</code> 命令，它会自动下载安装</p>\n<p>如果上面三个包一个都没有显示，则直接输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum -y install vim*</div></pre></td></tr></table></figure>\n<h3 id=\"安装net-tools\"><a href=\"#安装net-tools\" class=\"headerlink\" title=\"安装net-tools\"></a>安装net-tools</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install net-tools</div></pre></td></tr></table></figure>\n<h3 id=\"更改文件所有者\"><a href=\"#更改文件所有者\" class=\"headerlink\" title=\"更改文件所有者\"></a>更改文件所有者</h3><p>chown -R www.www ./    将本路径下所有文件所有者改为www组的www</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://teddysun.com/342.html\" target=\"_blank\" rel=\"external\">Shadowsocks Python版一键安装脚本</a></p>\n<p><a href=\"https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/\" target=\"_blank\" rel=\"external\">使用 Shadowsocks 自建翻墙服务器，实现全平台 100% 翻墙无障碍</a></p>\n<p><a href=\"http://shadowsocks.org/en/download/clients.html\" target=\"_blank\" rel=\"external\">http://shadowsocks.org/</a></p>\n<p><a href=\"http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/\" target=\"_blank\" rel=\"external\">shadowsocks（影梭）不完全指南</a></p>\n","excerpt":"<blockquote>\n<p>今天折腾了一天，总算是把翻墙的梯子搭起来了，租了国外的vps，然后在上面搭建了shadowsocks服务，手机和电脑就可以使用shadowsocks客户端的方式科学上网了。<br>Shadowsocks 是一个由很多人参与的开源项目，感谢shadowsocks作者<a href=\"https://github.com/clowwindy/shadowsocks\">@clowwindy</a>.关于shadowssocks和vpn等等翻墙方式的区别,不再一一赘述，本文只是记录梯子搭建的过程</p>\n</blockquote>\n<h2 id=\"购买VPS\"><a href=\"#购买VPS\" class=\"headerlink\" title=\"购买VPS\"></a>购买VPS</h2><p>VPS的概念我也不是特别清楚，就把他当成主机好了，类似于阿里云等等。</p>\n<p>购买之后，会分配给你root账户密码，你就拥有了一台国外机房的主机。</p>\n<p>VPS 可以参考 <a href=\"https://www.zhihu.com/question/20800554\">有哪些便宜稳定，速度也不错的Linux VPS 推荐？</a>,我买了Vultr 日本机房的vps,充了5美刀先试试。具体的购买方法自行谷歌</p>","more":"<h2 id=\"搭建shadowsocks服务\"><a href=\"#搭建shadowsocks服务\" class=\"headerlink\" title=\"搭建shadowsocks服务\"></a>搭建shadowsocks服务</h2><h3 id=\"升级内核\"><a href=\"#升级内核\" class=\"headerlink\" title=\"升级内核\"></a>升级内核</h3><p>我选择了Centos7的Linux发型版本作为操作系统。</p>\n<p>使用MobaXterm(或者是其他ssh工具)连接到分配给你的主机(root密码购买成功时会给出),</p>\n<p>首先升级一下内核：wget -O- <a href=\"https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh\">https://zhujiwiki.com/usr/uploads/2016/12/install_bbr_centos.sh</a> | bash</p>\n<p>完成之后，重启：</p>\n<p>reboot</p>\n<p>重新登录，查看内核版本：</p>\n<p>uname -r</p>\n<p>不出意外已经更新到了最新版本。接着执行：</p>\n<p>sysctl -a|grep congestion_control</p>\n<p>如果输出选项包含：net.ipv4.tcp_congestion_control = bbr 表示安装成功，否则需要手动开启bbr模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</div><div class=\"line\">sysctl -p</div><div class=\"line\">sysctl</div><div class=\"line\">net.ipv4.tcp_available_congestion_control</div></pre></td></tr></table></figure>\n<p>再次查看：</p>\n<p>sysctl -a|grep congestion_control</p>\n<h3 id=\"搭建服务\"><a href=\"#搭建服务\" class=\"headerlink\" title=\"搭建服务\"></a>搭建服务</h3><p>搭建服务可以选择使用别人写好的现成的脚本，也可以自己搭建，下面介绍这两种方法：</p>\n<h4 id=\"使用现成脚本\"><a href=\"#使用现成脚本\" class=\"headerlink\" title=\"使用现成脚本\"></a>使用现成脚本</h4><p>执行以下命令：</p>\n<figure class=\"highlight plain\"><figcaption><span>--no-check-certificate</span><a href=\"https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\">link</a></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x shadowsocks.sh</div><div class=\"line\">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</div></pre></td></tr></table></figure>\n<p>首先会提示你输入密码和端口，然后开始安装。安装完成后代表shadowsocks服务已经开启了。此时可以使用shadowsocks客户端去连接这个服务器了。</p>\n<p>脚本可用的命令：</p>\n<p>启动：/etc/init.d/shadowsocks start</p>\n<p>停止：/etc/init.d/shadowsocks stop</p>\n<p>重启：/etc/init.d/shadowsocks restart</p>\n<p>状态：/etc/init.d/shadowsocks status</p>\n<p>卸载：./shadowsocks.sh uninstall</p>\n<p>支持多用户的方法：修改配置文件:/etc/shadowsocks.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;    </div><div class=\"line\">    &quot;server&quot;:&quot;0.0.0.0&quot;,</div><div class=\"line\">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;port_password&quot;:&#123;</div><div class=\"line\">         &quot;8989&quot;:&quot;password0&quot;,</div><div class=\"line\">         &quot;9001&quot;:&quot;password1&quot;,</div><div class=\"line\">         &quot;9002&quot;:&quot;password2&quot;,</div><div class=\"line\">         &quot;9003&quot;:&quot;password3&quot;,</div><div class=\"line\">         &quot;9004&quot;:&quot;password4&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"自行搭建\"><a href=\"#自行搭建\" class=\"headerlink\" title=\"自行搭建\"></a>自行搭建</h4><p>首先安装shadowsocks服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</div><div class=\"line\">pip install shadowsocks</div></pre></td></tr></table></figure>\n<p>显示 “Successfully installed shadowsocks-2.6.10″。意味着Shadowsocks已经成功安装。</p>\n<p>接着，创建一个Shadowsocks配置文件。输入以下命令：</p>\n<p>vi /etc/shadowsocks.json</p>\n<p>然后在该文件中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;server&quot;:&quot;your_server_ip&quot;,</div><div class=\"line\">    &quot;server_port&quot;:8388,</div><div class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;password&quot;:&quot;auooo.com&quot;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面各项配置的含义已经很明显了，除了server(vps的ip)、server_port和password之外，其他默认即可。保存该文件。执行：</p>\n<p>ssserver -c /etc/shadowsocks.json -d start</p>\n<p>服务就启动了，如果想要关闭，执行：</p>\n<p>ssserver -c /etc/shadowsocks.json -d stop</p>\n<p>支持多用户的方法与上面的类似</p>\n<h4 id=\"端口问题\"><a href=\"#端口问题\" class=\"headerlink\" title=\"端口问题\"></a>端口问题</h4><p>有时候服务正常启动了，但是发现客户端还是没有办法翻墙。这时要注意检查vps开放的端口：</p>\n<p>Centos升级到7之后，使用firewalld代替了原来的iptables作为防火墙。</p>\n<p>启动：systemctl start  firewalld</p>\n<p>重启：firewall-cmd –reload</p>\n<p>查看状态：systemctl status firewalld 或者 firewall-cmd –state  </p>\n<p>查看开放的端口：firewall-cmd –list-ports</p>\n<p>增加开放端口：firewall-cmd –add-port=9001/tcp –permanent   (重启生效)</p>\n<p>9001：要开放的端口</p>\n<p>tcp：协议</p>\n<p>–permanent：永久生效，没有此参数重启后失效其他命令自行查找</p>\n<h2 id=\"锐速加速\"><a href=\"#锐速加速\" class=\"headerlink\" title=\"锐速加速\"></a>锐速加速</h2><p><a href=\"https://www.91yun.org/archives/683\">锐速破解版linux一键自动安装包（8月7日更新）</a></p>\n<p>文章开头的更新内核使用bbr加速或者锐速加速都可以，没试过哪种方式效果更好一些</p>\n<h2 id=\"vps使用ssh密钥登录\"><a href=\"#vps使用ssh密钥登录\" class=\"headerlink\" title=\"vps使用ssh密钥登录\"></a>vps使用ssh密钥登录</h2><p>使用ssh root账户和密码登录的方式是vps一开始会给出的登录主机的方式，这种方式比较简单，但是容易被别人暴力破解登录密码，控制我们的主机。</p>\n<p>所以，应该使用ssh密钥登录的方式来增强安全性。</p>\n<h3 id=\"修改root密码\"><a href=\"#修改root密码\" class=\"headerlink\" title=\"修改root密码\"></a>修改root密码</h3><p>第一步应该先把默认的root密码修改为自己的密码，最好复杂一点。</p>\n<p>确保自己记住了这个密码。</p>\n<p>passwd</p>\n<h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><p>可以先创建一个非root用户：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">useradd yukai</div></pre></td></tr></table></figure>\n<p>创建账户密码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">passwd yukai</div></pre></td></tr></table></figure>\n<p>给予账户sudo权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">visudo</div></pre></td></tr></table></figure>\n<p>在 root ALL=(ALL)  ALL 下新增一行：</p>\n<p>yukai ALL=(ALL)  ALL</p>\n<p>切换到yukai这个账户：</p>\n<p>su - yukai </p>\n<h3 id=\"创建密钥\"><a href=\"#创建密钥\" class=\"headerlink\" title=\"创建密钥\"></a>创建密钥</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen -t rsa</div></pre></td></tr></table></figure>\n<p>在 /home/yukai 下生成了一个隐藏目录：.ssh, 执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~/.sshcat id_rsa.pub &gt;&gt; authorized_keys</div><div class=\"line\">chmod 600 authorized_keys</div></pre></td></tr></table></figure>\n<p>将 id_rsa文件下载下来保存到本地(使用MobaXterm等工具)</p>\n<h3 id=\"使用密钥认证登录\"><a href=\"#使用密钥认证登录\" class=\"headerlink\" title=\"使用密钥认证登录\"></a>使用密钥认证登录</h3><p>打开MobaXterm工具，新建一个session，选择ssh，在Advanced SSH settings选项中选择 use private keygen复选框，并把上一步下载好的id_rsa选择进来。</p>\n<p>以用户yukai登录，提示输入密钥文件的密码，输入生成密钥时所填的密码，如果能够登录，则设置正确了</p>\n<h3 id=\"禁用root用户登录和密码登录\"><a href=\"#禁用root用户登录和密码登录\" class=\"headerlink\" title=\"禁用root用户登录和密码登录\"></a>禁用root用户登录和密码登录</h3><p>确保自己记住了root密码，并且上一步密钥认证方式登录成功。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo vi /etc/ssh/sshd_config</div></pre></td></tr></table></figure>\n<p>找到以下几项，进行如下设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">RSAAuthentication yes</div><div class=\"line\">PubkeyAuthentication yes</div><div class=\"line\">PermitRootLogin no</div><div class=\"line\">PasswordAuthentication no</div></pre></td></tr></table></figure>\n<p>重启ssh服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service sshd restart</div></pre></td></tr></table></figure>\n<h3 id=\"多台主机管理\"><a href=\"#多台主机管理\" class=\"headerlink\" title=\"多台主机管理\"></a>多台主机管理</h3><p>可以将生成的密钥文件authorized_keys保存到多个主机的相同位置：~/.ssh</p>\n<p>然后进行上面的配置。此时就可以使用一份私钥文件id_rsa登录多个主机了。</p>\n<h2 id=\"ss多用户管理\"><a href=\"#ss多用户管理\" class=\"headerlink\" title=\"ss多用户管理\"></a>ss多用户管理</h2><p>前端使用ss-panel，后台使用shadowsocks-manyuser</p>\n<p>教程参见：</p>\n<p><a href=\"https://blessing.studio/build-shadowsocks-sharing-site-with-ss-panel/\">可能是最好的 ss-panel 部署教程</a></p>\n<p><a href=\"https://blog.linuxeye.com/426.html\">ShadowSocks多用户管理系统搭建（moeSS+manyuser）</a></p>\n<h2 id=\"在Linux上使用shadowsocks服务翻墙\"><a href=\"#在Linux上使用shadowsocks服务翻墙\" class=\"headerlink\" title=\"在Linux上使用shadowsocks服务翻墙\"></a>在Linux上使用shadowsocks服务翻墙</h2><h3 id=\"开启shadowsocks客户端\"><a href=\"#开启shadowsocks客户端\" class=\"headerlink\" title=\"开启shadowsocks客户端\"></a>开启shadowsocks客户端</h3><p>确认安装了shadowsocks服务并从配置好的shadowsocks服务器端获得配置文件: /etc/shadowsocks/config.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">        &quot;server&quot;:&quot;remote-shadowsocks-server-ip-addr&quot;,</div><div class=\"line\">        &quot;server_port&quot;:443,</div><div class=\"line\">        &quot;local_address&quot;:&quot;127.0.0.1&quot;,</div><div class=\"line\">        &quot;local_port&quot;:1080,</div><div class=\"line\">        &quot;password&quot;:&quot;your-passwd&quot;,</div><div class=\"line\">        &quot;timeout&quot;:300,</div><div class=\"line\">        &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">        &quot;fast_open&quot;:false,</div><div class=\"line\">        &quot;workers&quot;:1</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在config.json所在目录下运行sslocal即可：</p>\n<p>sslocal -c /etc/shadowsocks/config.json</p>\n<p>也可以手动指定参数运行：</p>\n<p>sslocal -s 服务器地址 -p 服务器端口 -l 本地端端口 -k 密码 -m 加密方法</p>\n<h3 id=\"使用chrome代理\"><a href=\"#使用chrome代理\" class=\"headerlink\" title=\"使用chrome代理\"></a>使用chrome代理</h3><p>在chrome应用商店中查找 Proxy SwitchyOmega,并安装该扩展</p>\n<p>新建情景模式，代理协议选择SOCKS5，代理服务器选择 127.0.0.1， 代理端口选择上一步中的local_port,即1080</p>\n<p>启用该扩展程序，此时可顺利使用google了 </p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"安装vim\"><a href=\"#安装vim\" class=\"headerlink\" title=\"安装vim\"></a>安装vim</h3><p>vim编辑器需要安装三个包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim-enhanced-7.0.109-7.el5</div><div class=\"line\">vim-minimal-7.0.109-7.el5</div><div class=\"line\">vim-common-7.0.109-7.el5</div></pre></td></tr></table></figure>\n<p>输入  <code>rpm -qa|grep vim</code> 这个命令，如何vim已经正确安装，则会显示上面三个包的名称</p>\n<p>如果缺少了其中某个，比如说： vim-enhanced这个包少了，执行：<code>yum -y install vim-enhanced</code> 命令，它会自动下载安装</p>\n<p>如果上面三个包一个都没有显示，则直接输入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum -y install vim*</div></pre></td></tr></table></figure>\n<h3 id=\"安装net-tools\"><a href=\"#安装net-tools\" class=\"headerlink\" title=\"安装net-tools\"></a>安装net-tools</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install net-tools</div></pre></td></tr></table></figure>\n<h3 id=\"更改文件所有者\"><a href=\"#更改文件所有者\" class=\"headerlink\" title=\"更改文件所有者\"></a>更改文件所有者</h3><p>chown -R www.www ./    将本路径下所有文件所有者改为www组的www</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://teddysun.com/342.html\">Shadowsocks Python版一键安装脚本</a></p>\n<p><a href=\"https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/\">使用 Shadowsocks 自建翻墙服务器，实现全平台 100% 翻墙无障碍</a></p>\n<p><a href=\"http://shadowsocks.org/en/download/clients.html\">http://shadowsocks.org/</a></p>\n<p><a href=\"http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/\">shadowsocks（影梭）不完全指南</a></p>"},{"layout":"post","title":"java编程技巧","date":"2016-07-24T04:48:55.000Z","_content":"\n>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~\n\n **1**. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层\n\n **2**. if语句中,判断条件尽量不要使用if(!...)的形式，这样只会使代码更加难以理解\n\n **3**. 循环内不要不断创建对象引用，而应该：\n\n```java\n     Object obj = null;\n     for (int i = 0; i <= count; i++) { \n      obj = new Object(); \n     }\n```\n\n<!-- more -->\n\n **4**. 不要在循环条件中重复计算变量，比如：\n\n```java\n    for (int i = 0; i <= obj.size(); i++){...}\n```\n\n **5**. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字\n\n **6**. 尽量采用懒加载的策略，即在需要的时候才创建,例如：\n\n```java\n    String str = \"aaa\";\n    if (i == 1) { \n       list.add(str);\n    }\n```\n\n建议替换为：\n\n```java\n\n\tif (i == 1) { \n     String str = \"aaa\"; list.add(str);\n   }\n```\n\n\n **7**. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码\n\n **8**. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能\n\n **9**. 使用&& ,\\|\\| 操作符时，将首先需要满足的条件置于操作符之前。因为&& 和 \\|\\| 具有短路性。另外，体会if(e. key==k\\|\\|k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用\\|\\|将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）\n\n **10**. 尽量用for each语句代替for循环\n\n **11**. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。\n\n **12**. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。\n       \n```java\n    if(\"hello\".equals(variable)){...}\n```\n\n **13**. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：\n\n```java\n    if(string.indexof(character) != -1){...}`\n```\n\n应改为：\n\n```java\n    if(string.indexof(character) >0 ){...}\n```\n\n **14**. 避免意外的赋值，比如：\n \n```java\n    if(variable == 5){...}`\n```\n\n应改为：\n\n```java\n    if(5 == variable){...}\n```\n\n避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出`if(variable = 5)`这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~\n\n **15**. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：\n\n```java\n\tif(array.length > 0){...}\n```\n\n应改为：\n\n```java\n\tif(array != null && array.length > 0){...}\n```\n\n\n **16**. 确保只有一个退出点。比如：\n\n```java\n    private boolean isEligible(int age){\n\n    \tif(age > 18) {\n\n    \t\treturn true;\n\n    \t} else {\n\n            return false;\n    \t}\n\n    }\n```\n\n应改为：\n\n```java\n    private boolean isEligible(int age){\n    \tboolean result;\n\n    \tif(age > 18) {\n\n    \t\tresult = true;\n\n    \t} else {\n\n            result = false;\n    \t}\n\n    \treturn result;\n    }\n```\n\n **17**. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。\n\n```java\n \tprivate boolean isEligible(final int age){...}\n```\n\n **18**. 把多个if语句组合成单一if语句。比如：\n\n```java\n\tif(age > 18){\n\t\tif(!man){...}\n\t}\n```\n\n应改为：\n\n```java\n\tif(age > 18 && !man){...}\n```\n\n **19**.  尽量不返回null\n\n null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。\n\n **20**. if嵌套不超过三层。\n\n **21**. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)\n\n实现RandomAccess接口的代表类：ArrayList\n未实现RandomAccess接口的代表类：LinkedList\n\n\n\n","source":"_posts/java_Tips.md","raw":"---\nlayout: post\ntitle: \"java编程技巧\"\ncategories: 编程\ntags: \n- java\ndate:   2016-7-24 12:48:55\n---\n\n>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~\n\n **1**. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层\n\n **2**. if语句中,判断条件尽量不要使用if(!...)的形式，这样只会使代码更加难以理解\n\n **3**. 循环内不要不断创建对象引用，而应该：\n\n```java\n     Object obj = null;\n     for (int i = 0; i <= count; i++) { \n      obj = new Object(); \n     }\n```\n\n<!-- more -->\n\n **4**. 不要在循环条件中重复计算变量，比如：\n\n```java\n    for (int i = 0; i <= obj.size(); i++){...}\n```\n\n **5**. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字\n\n **6**. 尽量采用懒加载的策略，即在需要的时候才创建,例如：\n\n```java\n    String str = \"aaa\";\n    if (i == 1) { \n       list.add(str);\n    }\n```\n\n建议替换为：\n\n```java\n\n\tif (i == 1) { \n     String str = \"aaa\"; list.add(str);\n   }\n```\n\n\n **7**. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码\n\n **8**. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能\n\n **9**. 使用&& ,\\|\\| 操作符时，将首先需要满足的条件置于操作符之前。因为&& 和 \\|\\| 具有短路性。另外，体会if(e. key==k\\|\\|k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用\\|\\|将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）\n\n **10**. 尽量用for each语句代替for循环\n\n **11**. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。\n\n **12**. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。\n       \n```java\n    if(\"hello\".equals(variable)){...}\n```\n\n **13**. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：\n\n```java\n    if(string.indexof(character) != -1){...}`\n```\n\n应改为：\n\n```java\n    if(string.indexof(character) >0 ){...}\n```\n\n **14**. 避免意外的赋值，比如：\n \n```java\n    if(variable == 5){...}`\n```\n\n应改为：\n\n```java\n    if(5 == variable){...}\n```\n\n避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出`if(variable = 5)`这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~\n\n **15**. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：\n\n```java\n\tif(array.length > 0){...}\n```\n\n应改为：\n\n```java\n\tif(array != null && array.length > 0){...}\n```\n\n\n **16**. 确保只有一个退出点。比如：\n\n```java\n    private boolean isEligible(int age){\n\n    \tif(age > 18) {\n\n    \t\treturn true;\n\n    \t} else {\n\n            return false;\n    \t}\n\n    }\n```\n\n应改为：\n\n```java\n    private boolean isEligible(int age){\n    \tboolean result;\n\n    \tif(age > 18) {\n\n    \t\tresult = true;\n\n    \t} else {\n\n            result = false;\n    \t}\n\n    \treturn result;\n    }\n```\n\n **17**. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。\n\n```java\n \tprivate boolean isEligible(final int age){...}\n```\n\n **18**. 把多个if语句组合成单一if语句。比如：\n\n```java\n\tif(age > 18){\n\t\tif(!man){...}\n\t}\n```\n\n应改为：\n\n```java\n\tif(age > 18 && !man){...}\n```\n\n **19**.  尽量不返回null\n\n null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。\n\n **20**. if嵌套不超过三层。\n\n **21**. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)\n\n实现RandomAccess接口的代表类：ArrayList\n未实现RandomAccess接口的代表类：LinkedList\n\n\n\n","slug":"java_Tips","published":1,"updated":"2017-04-11T13:08:38.837Z","comments":1,"photos":[],"link":"","_id":"cj4vch4dk000rx3gcn8icwiby","content":"<blockquote>\n<p>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~</p>\n</blockquote>\n<p> <strong>1</strong>. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层</p>\n<p> <strong>2</strong>. if语句中,判断条件尽量不要使用if(!…)的形式，这样只会使代码更加难以理解</p>\n<p> <strong>3</strong>. 循环内不要不断创建对象引用，而应该：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= count; i++) &#123; </div><div class=\"line\"> obj = <span class=\"keyword\">new</span> Object(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p> <strong>4</strong>. 不要在循环条件中重复计算变量，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= obj.size(); i++)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>5</strong>. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字</p>\n<p> <strong>6</strong>. 尽量采用懒加载的策略，即在需要的时候才创建,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str = <span class=\"string\">\"aaa\"</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">   list.add(str);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>建议替换为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">    String str = <span class=\"string\">\"aaa\"</span>; list.add(str);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p> <strong>7</strong>. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码</p>\n<p> <strong>8</strong>. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能</p>\n<p> <strong>9</strong>. 使用&amp;&amp; ,|| 操作符时，将首先需要满足的条件置于操作符之前。因为&amp;&amp; 和 || 具有短路性。另外，体会if(e. key==k||k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用||将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）</p>\n<p> <strong>10</strong>. 尽量用for each语句代替for循环</p>\n<p> <strong>11</strong>. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。</p>\n<p> <strong>12</strong>. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">\"hello\"</span>.equals(variable))&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>13</strong>. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) != -<span class=\"number\">1</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) &gt;<span class=\"number\">0</span> )&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>14</strong>. 避免意外的赋值，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(variable == <span class=\"number\">5</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">5</span> == variable)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出<code>if(variable = 5)</code>这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~</p>\n<p> <strong>15</strong>. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array != <span class=\"keyword\">null</span> &amp;&amp; array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>16</strong>. 确保只有一个退出点。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">boolean</span> result;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tresult = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        result = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>17</strong>. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>18</strong>. 把多个if语句组合成单一if语句。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>)&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(!man)&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span> &amp;&amp; !man)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>19</strong>.  尽量不返回null</p>\n<p> null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。</p>\n<p> <strong>20</strong>. if嵌套不超过三层。</p>\n<p> <strong>21</strong>. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)</p>\n<p>实现RandomAccess接口的代表类：ArrayList<br>未实现RandomAccess接口的代表类：LinkedList</p>\n","excerpt":"<blockquote>\n<p>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~</p>\n</blockquote>\n<p> <strong>1</strong>. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层</p>\n<p> <strong>2</strong>. if语句中,判断条件尽量不要使用if(!…)的形式，这样只会使代码更加难以理解</p>\n<p> <strong>3</strong>. 循环内不要不断创建对象引用，而应该：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= count; i++) &#123; </div><div class=\"line\"> obj = <span class=\"keyword\">new</span> Object(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p> <strong>4</strong>. 不要在循环条件中重复计算变量，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= obj.size(); i++)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>5</strong>. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字</p>\n<p> <strong>6</strong>. 尽量采用懒加载的策略，即在需要的时候才创建,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str = <span class=\"string\">\"aaa\"</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">   list.add(str);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>建议替换为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">    String str = <span class=\"string\">\"aaa\"</span>; list.add(str);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p> <strong>7</strong>. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码</p>\n<p> <strong>8</strong>. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能</p>\n<p> <strong>9</strong>. 使用&amp;&amp; ,|| 操作符时，将首先需要满足的条件置于操作符之前。因为&amp;&amp; 和 || 具有短路性。另外，体会if(e. key==k||k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用||将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）</p>\n<p> <strong>10</strong>. 尽量用for each语句代替for循环</p>\n<p> <strong>11</strong>. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。</p>\n<p> <strong>12</strong>. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">\"hello\"</span>.equals(variable))&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>13</strong>. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) != -<span class=\"number\">1</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) &gt;<span class=\"number\">0</span> )&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>14</strong>. 避免意外的赋值，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(variable == <span class=\"number\">5</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">5</span> == variable)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出<code>if(variable = 5)</code>这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~</p>\n<p> <strong>15</strong>. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array != <span class=\"keyword\">null</span> &amp;&amp; array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>16</strong>. 确保只有一个退出点。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">boolean</span> result;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tresult = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        result = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>17</strong>. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>18</strong>. 把多个if语句组合成单一if语句。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>)&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(!man)&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span> &amp;&amp; !man)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>19</strong>.  尽量不返回null</p>\n<p> null可以表达两种意思，一种是不存在、为空，一种是出现错误。返回null会让调用者感到迷惑，同时也会因为传递null造成很多意想不到的错误。可以针对需要返回null的情况为null专门构造一个类，比如函数返回一个connection，可以为返回null的情况实现一个名为FakeConnection的类，返回这个类的对象。需要把null放进“容器数据结构”里面的情况同理。</p>\n<p> <strong>20</strong>. if嵌套不超过三层。</p>\n<p> <strong>21</strong>. 实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。(for each底层通过Iterator实现)</p>\n<p>实现RandomAccess接口的代表类：ArrayList<br>未实现RandomAccess接口的代表类：LinkedList</p>"},{"layout":"post","title":"java中的ThreadLocal","date":"2016-06-21T04:48:55.000Z","_content":"\n> 今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal...\n\n## **问题背景**：\n\n每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：\n\n```java\nLsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());\n```\n\n其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。\n\n遂改之：\n\n```java\nLsnVo lv = ((DispatchConnection) conn).getLsnVo();\n```\n\n<!-- more -->\n\n将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。\n\n曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。\n\n后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！\n\nPS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29\n\nso,按照上面的改法问题解决了。\n\n那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。\n\n这就是ThreadLocal的一个典型应用场景。\n\n## **ThreadLocal原理**：\n\n使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。\n\nThreadLocal的set和get方法：\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n}\n\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            return (T)map.get(this);\n\n        // Maps are constructed lazily.  if the map for this thread\n        // doesn't exist, create it, with this ThreadLocal and its\n        // initial value as its only entry.\n        T value = initialValue();\n        createMap(t, value);\n        return value;\n}\n```\n\n可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。\n\n很容易明白他的工作原理。\n\n## **应用场景**\n\n之前看了网上很多资料说ThreadLocal的应用场景：\n\n1.解决了多线程共享对象的问题，\n\n2.实现线程间的数据隔离，每个线程都有他自己的变量副本。\n\n对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。\n\n对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。\n\n我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：\n\n1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。\n\n2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。\n\n所以，使用ThreadLocal的场景应该是这样：**这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。**\n\nPS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。\n\n另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。\n\n我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。\n\n## **2016/11/01更新**\n\n今天在地铁上看到了一篇不错的文章，介绍ThreadLocal内存泄漏的实例–ThreadLocal 内存泄露的实例分析.\n\n另外，该作者的另一篇blog，讲解ThreadLocal的原理，也很清晰深入分析 ThreadLocal 内存泄漏问题\n\n拜读完作者的文章后，回家又翻了一遍ThreadLocal的源码，认为和作者所要解释的一致，并且对ThreadLocal的理解更加深了。\n\n> ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread\n\n上面的话出自java doc\n\noracle鼓励我们将ThreadLocal对象声明为一个private static类型的变量A。结合上述文章和源码来看，A的生命周期将变得和保存他的类对象一样长，这样ThreadLocalMap中设置的A的弱引用就失去了弱引用的作用，该键A对应的value也不会得到释放，直到此线程销毁。这样一来，如果是使用了线程池的话，当该线程复用时，很有可能会取得错误的值，造成业务逻辑混乱。\n\n解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\n--------------------\n另外，有一个例子展示了ThreadLocal的应用场景，现在贴过来。同样来自java doc。例子虽然很简单，但是我觉得很生动的展示了Threadlocal的一个应用场景，让人豁然开朗。\n\n试想如果不采用ThreadLocal的话，我自己的做法应该会在创建的线程类里面增加一个字段，用来标明线程的id。但是这么做有两点问题：\n\n第一，增加了字段，挺low。\n\n第二，有很大的限制，你只能为自己实现的线程类里面加字段。但是往往有些线程不是我们自己定义的。\n\n这个例子很好的说明了怎么实现一个线程变量。\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\npublic class ThreadId {\n     // Atomic integer containing the next thread ID to be assigned\n     private static final AtomicInteger nextId = new AtomicInteger(0);\n     // Thread local variable containing each thread's ID\n     private static final ThreadLocal<Integer> threadId =\n         new ThreadLocal<Integer>() {\n             @Override protected Integer initialValue() {\n                 return nextId.getAndIncrement();\n         }\n     };\n     // Returns the current thread's unique ID, assigning it if necessary\n     public static int get() {\n         return threadId.get();\n     }\n}\n```\n","source":"_posts/java中的ThreadLocal.md","raw":"---\nlayout: post\ntitle:  \"java中的ThreadLocal\"\ncategories: 编程\ntags: \n- java\n- 多线程\ndate:   2016-06-21 12:48:55\n---\n\n> 今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal...\n\n## **问题背景**：\n\n每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：\n\n```java\nLsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());\n```\n\n其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。\n\n遂改之：\n\n```java\nLsnVo lv = ((DispatchConnection) conn).getLsnVo();\n```\n\n<!-- more -->\n\n将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。\n\n曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。\n\n后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！\n\nPS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29\n\nso,按照上面的改法问题解决了。\n\n那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。\n\n这就是ThreadLocal的一个典型应用场景。\n\n## **ThreadLocal原理**：\n\n使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。\n\nThreadLocal的set和get方法：\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n}\n\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            return (T)map.get(this);\n\n        // Maps are constructed lazily.  if the map for this thread\n        // doesn't exist, create it, with this ThreadLocal and its\n        // initial value as its only entry.\n        T value = initialValue();\n        createMap(t, value);\n        return value;\n}\n```\n\n可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。\n\n很容易明白他的工作原理。\n\n## **应用场景**\n\n之前看了网上很多资料说ThreadLocal的应用场景：\n\n1.解决了多线程共享对象的问题，\n\n2.实现线程间的数据隔离，每个线程都有他自己的变量副本。\n\n对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。\n\n对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。\n\n我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：\n\n1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。\n\n2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。\n\n所以，使用ThreadLocal的场景应该是这样：**这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。**\n\nPS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。\n\n另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。\n\n我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。\n\n## **2016/11/01更新**\n\n今天在地铁上看到了一篇不错的文章，介绍ThreadLocal内存泄漏的实例–ThreadLocal 内存泄露的实例分析.\n\n另外，该作者的另一篇blog，讲解ThreadLocal的原理，也很清晰深入分析 ThreadLocal 内存泄漏问题\n\n拜读完作者的文章后，回家又翻了一遍ThreadLocal的源码，认为和作者所要解释的一致，并且对ThreadLocal的理解更加深了。\n\n> ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread\n\n上面的话出自java doc\n\noracle鼓励我们将ThreadLocal对象声明为一个private static类型的变量A。结合上述文章和源码来看，A的生命周期将变得和保存他的类对象一样长，这样ThreadLocalMap中设置的A的弱引用就失去了弱引用的作用，该键A对应的value也不会得到释放，直到此线程销毁。这样一来，如果是使用了线程池的话，当该线程复用时，很有可能会取得错误的值，造成业务逻辑混乱。\n\n解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\n--------------------\n另外，有一个例子展示了ThreadLocal的应用场景，现在贴过来。同样来自java doc。例子虽然很简单，但是我觉得很生动的展示了Threadlocal的一个应用场景，让人豁然开朗。\n\n试想如果不采用ThreadLocal的话，我自己的做法应该会在创建的线程类里面增加一个字段，用来标明线程的id。但是这么做有两点问题：\n\n第一，增加了字段，挺low。\n\n第二，有很大的限制，你只能为自己实现的线程类里面加字段。但是往往有些线程不是我们自己定义的。\n\n这个例子很好的说明了怎么实现一个线程变量。\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\npublic class ThreadId {\n     // Atomic integer containing the next thread ID to be assigned\n     private static final AtomicInteger nextId = new AtomicInteger(0);\n     // Thread local variable containing each thread's ID\n     private static final ThreadLocal<Integer> threadId =\n         new ThreadLocal<Integer>() {\n             @Override protected Integer initialValue() {\n                 return nextId.getAndIncrement();\n         }\n     };\n     // Returns the current thread's unique ID, assigning it if necessary\n     public static int get() {\n         return threadId.get();\n     }\n}\n```\n","slug":"java中的ThreadLocal","published":1,"updated":"2017-04-11T13:08:38.838Z","comments":1,"photos":[],"link":"","_id":"cj4vch4dp000ux3gch4yg8st0","content":"<blockquote>\n<p>今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal…</p>\n</blockquote>\n<h2 id=\"问题背景：\"><a href=\"#问题背景：\" class=\"headerlink\" title=\"问题背景：\"></a><strong>问题背景</strong>：</h2><p>每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());</div></pre></td></tr></table></figure>\n<p>其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。</p>\n<p>遂改之：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((DispatchConnection) conn).getLsnVo();</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。</p>\n<p>曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。</p>\n<p>后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！</p>\n<p>PS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29</p>\n<p>so,按照上面的改法问题解决了。</p>\n<p>那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。</p>\n<p>这就是ThreadLocal的一个典型应用场景。</p>\n<h2 id=\"ThreadLocal原理：\"><a href=\"#ThreadLocal原理：\" class=\"headerlink\" title=\"ThreadLocal原理：\"></a><strong>ThreadLocal原理</strong>：</h2><p>使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。</p>\n<p>ThreadLocal的set和get方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> (T)map.get(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Maps are constructed lazily.  if the map for this thread</span></div><div class=\"line\">        <span class=\"comment\">// doesn't exist, create it, with this ThreadLocal and its</span></div><div class=\"line\">        <span class=\"comment\">// initial value as its only entry.</span></div><div class=\"line\">        T value = initialValue();</div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。</p>\n<p>很容易明白他的工作原理。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h2><p>之前看了网上很多资料说ThreadLocal的应用场景：</p>\n<p>1.解决了多线程共享对象的问题，</p>\n<p>2.实现线程间的数据隔离，每个线程都有他自己的变量副本。</p>\n<p>对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。</p>\n<p>对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。</p>\n<p>我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：</p>\n<p>1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。</p>\n<p>2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。</p>\n<p>所以，使用ThreadLocal的场景应该是这样：<strong>这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。</strong></p>\n<p>PS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。</p>\n<p>另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。</p>\n<p>我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。</p>\n<h2 id=\"2016-11-01更新\"><a href=\"#2016-11-01更新\" class=\"headerlink\" title=\"2016/11/01更新\"></a><strong>2016/11/01更新</strong></h2><p>今天在地铁上看到了一篇不错的文章，介绍ThreadLocal内存泄漏的实例–ThreadLocal 内存泄露的实例分析.</p>\n<p>另外，该作者的另一篇blog，讲解ThreadLocal的原理，也很清晰深入分析 ThreadLocal 内存泄漏问题</p>\n<p>拜读完作者的文章后，回家又翻了一遍ThreadLocal的源码，认为和作者所要解释的一致，并且对ThreadLocal的理解更加深了。</p>\n<blockquote>\n<p>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread</p>\n</blockquote>\n<p>上面的话出自java doc</p>\n<p>oracle鼓励我们将ThreadLocal对象声明为一个private static类型的变量A。结合上述文章和源码来看，A的生命周期将变得和保存他的类对象一样长，这样ThreadLocalMap中设置的A的弱引用就失去了弱引用的作用，该键A对应的value也不会得到释放，直到此线程销毁。这样一来，如果是使用了线程池的话，当该线程复用时，很有可能会取得错误的值，造成业务逻辑混乱。</p>\n<h2 id=\"解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\"><a href=\"#解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\" class=\"headerlink\" title=\"解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\"></a>解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。</h2><p>另外，有一个例子展示了ThreadLocal的应用场景，现在贴过来。同样来自java doc。例子虽然很简单，但是我觉得很生动的展示了Threadlocal的一个应用场景，让人豁然开朗。</p>\n<p>试想如果不采用ThreadLocal的话，我自己的做法应该会在创建的线程类里面增加一个字段，用来标明线程的id。但是这么做有两点问题：</p>\n<p>第一，增加了字段，挺low。</p>\n<p>第二，有很大的限制，你只能为自己实现的线程类里面加字段。但是往往有些线程不是我们自己定义的。</p>\n<p>这个例子很好的说明了怎么实现一个线程变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadId</span> </span>&#123;</div><div class=\"line\">     <span class=\"comment\">// Atomic integer containing the next thread ID to be assigned</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicInteger nextId = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</div><div class=\"line\">     <span class=\"comment\">// Thread local variable containing each thread's ID</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Integer&gt; threadId =</div><div class=\"line\">         <span class=\"keyword\">new</span> ThreadLocal&lt;Integer&gt;() &#123;</div><div class=\"line\">             <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                 <span class=\"keyword\">return</span> nextId.getAndIncrement();</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;;</div><div class=\"line\">     <span class=\"comment\">// Returns the current thread's unique ID, assigning it if necessary</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> threadId.get();</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal…</p>\n</blockquote>\n<h2 id=\"问题背景：\"><a href=\"#问题背景：\" class=\"headerlink\" title=\"问题背景：\"></a><strong>问题背景</strong>：</h2><p>每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());</div></pre></td></tr></table></figure>\n<p>其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。</p>\n<p>遂改之：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((DispatchConnection) conn).getLsnVo();</div></pre></td></tr></table></figure>","more":"<p>将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。</p>\n<p>曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。</p>\n<p>后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！</p>\n<p>PS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29</p>\n<p>so,按照上面的改法问题解决了。</p>\n<p>那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。</p>\n<p>这就是ThreadLocal的一个典型应用场景。</p>\n<h2 id=\"ThreadLocal原理：\"><a href=\"#ThreadLocal原理：\" class=\"headerlink\" title=\"ThreadLocal原理：\"></a><strong>ThreadLocal原理</strong>：</h2><p>使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。</p>\n<p>ThreadLocal的set和get方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> (T)map.get(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Maps are constructed lazily.  if the map for this thread</span></div><div class=\"line\">        <span class=\"comment\">// doesn't exist, create it, with this ThreadLocal and its</span></div><div class=\"line\">        <span class=\"comment\">// initial value as its only entry.</span></div><div class=\"line\">        T value = initialValue();</div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。</p>\n<p>很容易明白他的工作原理。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h2><p>之前看了网上很多资料说ThreadLocal的应用场景：</p>\n<p>1.解决了多线程共享对象的问题，</p>\n<p>2.实现线程间的数据隔离，每个线程都有他自己的变量副本。</p>\n<p>对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。</p>\n<p>对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。</p>\n<p>我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：</p>\n<p>1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。</p>\n<p>2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。</p>\n<p>所以，使用ThreadLocal的场景应该是这样：<strong>这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。</strong></p>\n<p>PS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。</p>\n<p>另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。</p>\n<p>我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。</p>\n<h2 id=\"2016-11-01更新\"><a href=\"#2016-11-01更新\" class=\"headerlink\" title=\"2016/11/01更新\"></a><strong>2016/11/01更新</strong></h2><p>今天在地铁上看到了一篇不错的文章，介绍ThreadLocal内存泄漏的实例–ThreadLocal 内存泄露的实例分析.</p>\n<p>另外，该作者的另一篇blog，讲解ThreadLocal的原理，也很清晰深入分析 ThreadLocal 内存泄漏问题</p>\n<p>拜读完作者的文章后，回家又翻了一遍ThreadLocal的源码，认为和作者所要解释的一致，并且对ThreadLocal的理解更加深了。</p>\n<blockquote>\n<p>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread</p>\n</blockquote>\n<p>上面的话出自java doc</p>\n<p>oracle鼓励我们将ThreadLocal对象声明为一个private static类型的变量A。结合上述文章和源码来看，A的生命周期将变得和保存他的类对象一样长，这样ThreadLocalMap中设置的A的弱引用就失去了弱引用的作用，该键A对应的value也不会得到释放，直到此线程销毁。这样一来，如果是使用了线程池的话，当该线程复用时，很有可能会取得错误的值，造成业务逻辑混乱。</p>\n<h2 id=\"解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\"><a href=\"#解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\" class=\"headerlink\" title=\"解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。\"></a>解决这个问题的方法就是当ThreadLocal不再使用时，一定要及时调用ThreadLocal的remove方法把已经存储的值清掉。</h2><p>另外，有一个例子展示了ThreadLocal的应用场景，现在贴过来。同样来自java doc。例子虽然很简单，但是我觉得很生动的展示了Threadlocal的一个应用场景，让人豁然开朗。</p>\n<p>试想如果不采用ThreadLocal的话，我自己的做法应该会在创建的线程类里面增加一个字段，用来标明线程的id。但是这么做有两点问题：</p>\n<p>第一，增加了字段，挺low。</p>\n<p>第二，有很大的限制，你只能为自己实现的线程类里面加字段。但是往往有些线程不是我们自己定义的。</p>\n<p>这个例子很好的说明了怎么实现一个线程变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadId</span> </span>&#123;</div><div class=\"line\">     <span class=\"comment\">// Atomic integer containing the next thread ID to be assigned</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicInteger nextId = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</div><div class=\"line\">     <span class=\"comment\">// Thread local variable containing each thread's ID</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Integer&gt; threadId =</div><div class=\"line\">         <span class=\"keyword\">new</span> ThreadLocal&lt;Integer&gt;() &#123;</div><div class=\"line\">             <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                 <span class=\"keyword\">return</span> nextId.getAndIncrement();</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;;</div><div class=\"line\">     <span class=\"comment\">// Returns the current thread's unique ID, assigning it if necessary</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> threadId.get();</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"layout":"post","title":"Java-NIO-Buffer","date":"2017-06-28T12:36:36.000Z","_content":"> 最近在看java nio方面的知识，打算写几篇博客总结一下，就从Buffer开始吧\n\n## Buffer\n\njava NIO库是在jdk1.4中引入的，NIO与IO之间的第一个区别在于，IO是面向流的，而NIO是面向块的。\n\n所谓的面向流是指：系统一次一个字节的处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。\n\n所谓的面向块是指：以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。\n\n按块的方式处理数据要比按流的方式处理数据快，因为按块的方式读取或写入数据所执行的系统调用要远少于一次一个字节的方式，类似于BufferedInputStream的方式。\n\n上面所说的块，在NIO中就是Buffer对象。\n\n一个 Buffer(缓冲区) 实质上是一个容器对象，它包含一些要写入或者刚读出的数据。在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 仅仅 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。\n\n举例来说，ByteBuffer实质上是对byte数组进行了封装，其内部是一个byte数组，ByteBuffer对象提供了一些实用的API供我们去操作这个数组，完成一些读取或写入的功能。我们所要学习的，就是理解在调用这些API的时候，Buffer处理数组的方式。\n\n除了boolean类型之外，java为每种基本类型都封装了对应的Buffer对象。\n\n{% asset_img buffer.png Buffer %}\n\n<!-- more -->\n\n## 状态变量\n\nBuffer使用四个值指定了缓冲区在某个时刻的状态：\n\n**容量(Capacity)**：缓冲区能够容纳的数据元素的最大数量\n\n实际上，这个值指定了底层数组的大小。这一值在缓冲区创建时被设定，并且永远不能被改变。\n\n**位置(Position)**：下一个要被读或写的元素的索引\n\nposition 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。比如，从通道中读三个字节到缓冲区中，那么缓冲区的 position 将会设置为3，指向数组中第四个元素。\n\n初始的position值为0。\n\n**边界(Limit)**：缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。\n\n在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。\n\n当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。\n\n**标记(Mark)**：一个备忘位置。\n\n调用 mark()来设定 mark = postion。调用 reset()设定 position = mark。\n\n初始的mark值为-1。\n\n上面四个属性遵循以下的关系：\n\n`0 <= mark <= position <= limit <= capacity`\n\n## API\n\n{% asset_img buffer_api.png Buffer %}\n\n- **创建**\n\n在了解这些api之前，首先需要知道如何创建一个Buffer对象：\n\n在上一个小节中提到的7种缓冲区类没有一种是可以直接实例化的，他们都是抽象类，但都包含了静态工厂方法创建相应的实例。以ByteBuffer为例：(对于其他六中缓冲区类也适用)\n\n`ByteBuffer buffer = ByteBuffer.allocate(1024);`\n\nallocate方法分配了一个具有指定大小底层数组的缓冲区对象，这个大小也就是上面提到的Capacity。\n\n我们也可以使用已经存在的数组来作为缓冲区对象的底层数组：\n\n```java\nbyte array[] = new byte[1024];\nByteBuffer buffer = ByteBuffer.wrap(array);\n```\n\n此时，buffer对象的底层数组指向了array，这意味着直接修改array数组也会使buffer对象读取的数据产生变化。\n\n```java\nbyte[] bs = new byte[10];\nByteBuffer buffer = ByteBuffer.wrap(bs);\nSystem.out.println(buffer.toString());\n```\n\n打印如下：\n\n```\njava.nio.HeapByteBuffer[pos=0 lim=10 cap=10]\n```\n\n可见，新初始化的Buffer实例中，position = 0，limit=capacity=10\n\n- **存取**\n\n注意到Buffer类中并没有提供get或者put函数。实际上每一个Buffer对象都有这两个函数，但它们所采用的参数类型，以及它们返回的数据类型，对每个子类来说都是唯一的，所以它们不能在顶层Buffer类中被抽象地声明。这些存取方法被定义在Buffer类的子类当中，我们一ByteBuffer为例：\n\n```java\npublic abstract byte get();\npublic abstract byte get (int index);\npublic abstract ByteBuffer put (byte b);\npublic abstract ByteBuffer put (int index, byte b);\n```\n\nByteBuffer实际上还提供了 `get(byte[] dst, int offset, int length)`这样的接口，其内部实现也是循环调用了get()方法。\n\nget和put可以是相对的或者是绝对的。\n\n相对方案是不带有索引参数的函数。当相对函数被调用时，位置在返回时前进一。\n\n绝对存取不会影响缓冲区的位置属性(Position、Limit、Capacity、Mark)。\n\n```java\nbuffer.put((byte)'h').put((byte)'e').put((byte)'l').put((byte)'l').put((byte)'o');\nprint(buffer, bs);\nbuffer.put(0, (byte)'y').put((byte)'y');\nprint(buffer, bs);\n\n//观察Buffer底层存储情况\npublic static void print(Buffer buffer, byte[] bs) {\n\t\tSystem.out.println(buffer.toString());\n\t\tfor (int i = 0; i < bs.length; i++) {\n\t\t\tif (bs[i] != 0) {\n\t\t\t\tchar c = (char)bs[i];\n\t\t\t\tSystem.out.print(c);\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\"$\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n```\n打印如下：\n\n```\njava.nio.HeapByteBuffer[pos=5 lim=10 cap=10]\nhello$$$$$\njava.nio.HeapByteBuffer[pos=6 lim=10 cap=10]\nyelloy$$$$\n```\n可以看到，存入5个字节之后，position增加为5，limit与capacity不变。\n调用buffer.put(0, (byte)'y')，将bs[0]的数据改写为(byte)'y'，position并没有改变。\n\n- **Buffer.flip()**\n\n我们想要将刚刚写入的数据读出的话应该怎么做？应该将position设为0：buffer.position(0)，就可以从正确的位置开始获取数据。但是它是怎样知道何时到达我们所插入数据末端的呢？这就是边界属性被引入的目的。边界属性指明了缓冲区有效内容的末端。我们需要将limit设置为当前位置：buffer.limit(buffer.position())。\n\n`buffer.limit(buffer.position()).position(0);`\n\nBuffer已经提供了一个方法封装了这些操作：\n\n```java\npublic final Buffer flip() {\n        limit = position;\n        position = 0;\n        mark = -1;\n        return this;\n}\n```\n```java\nbuffer.flip();\nprint(buffer, bs);\n```\n\n打印如下：\n\n```\njava.nio.HeapByteBuffer[pos=0 lim=6 cap=10]\nyelloy$$$$\n```\n\n调用buffer.flip()后，limit设置为当前position值，position重置为0.\n\n- **Buffer.rewind()**\n\n紧接着上面的程序：\n\n```java\nSystem.out.println((char)buffer.get());\nSystem.out.println((char)buffer.get(3));\nprint(buffer, bs);\n\t\t\nbuffer.rewind();\nprint(buffer, bs);\n```\n\n打印如下：\n\n```\ny\nl\njava.nio.HeapByteBuffer[pos=1 lim=6 cap=10]\nyelloy$$$$\njava.nio.HeapByteBuffer[pos=0 lim=6 cap=10]\nyelloy$$$$\n```\n\n可以看到，rewind()方法与filp()相似，但是不影响limit，他只是将position设为0，这样就可以从新读取已经读过的数据了。\n\n```java\npublic final Buffer rewind() {\n        position = 0;\n        mark = -1;\n        return this;\n}\n```\n\n- **Buffer.mark()、Buffer.reset()**\n\n```java\npublic final Buffer mark() {\n        mark = position;\n        return this;\n}\n\npublic final Buffer reset() {\n        int m = mark;\n        if (m < 0)\n            throw new InvalidMarkException();\n        position = m;\n        return this;\n}\n```\nBuffer.mark(),使缓冲区能够记住一个位置并在之后将其返回。\n\n缓冲区的标记在mark()函数被调用之前是未定义的，调用时标记被设为当前位置的值。reset()函数将位置设为当前的标记值。如果标记值未定义，调用reset()将导致InvalidMarkException异常。\n\n```java\nbuffer.position(2);\nbuffer.mark();\nprint(buffer, bs);\nbuffer.position(4);\nprint(buffer, bs);\nbuffer.reset();\nprint(buffer, bs);\n```\n\n打印如下：\n\n```\njava.nio.HeapByteBuffer[pos=2 lim=6 cap=10]\nyelloy$$$$\njava.nio.HeapByteBuffer[pos=4 lim=6 cap=10]\nyelloy$$$$\njava.nio.HeapByteBuffer[pos=2 lim=6 cap=10]\nyelloy$$$$\n```\n\n- **Buffer.remaining()、Buffer.hasRemaining()**\n\nremaining()函数将返回从当前位置到上界还剩余的元素数目。\n\nhasRemaining()会返回是否已经达到缓冲区的边界。\n\n```java\npublic final int remaining() {\n        return limit - position;\n}\n\npublic final boolean hasRemaining() {\n        return position < limit;\n}\n```\n有两种方法读取缓冲区的所有剩余数据：\n\n```java\n// 第一种\nfor (int i = 0; buffer.hasRemaining(), i++) {\n    myByteArray [i] = buffer.get();\n}\n\n// 第二种\nint count = buffer.remaining();\nfor (int i = 0; i < count, i++) {\n    myByteArray [i] = buffer.get();\n}\n```\n\n- **Buffer.clear()**\n\nclear()函数将缓冲区重置为空状态。它并不改变缓冲区中的任何数据元素，而是仅仅将上界设为容量的值，并把位置设回 0。\n\n```java\npublic final Buffer clear() {\n        position = 0;\n        limit = capacity;\n        mark = -1;\n        return this;\n}\n```\n\n- **ByteBuffer.compact()**\n\ncompact()方法并不是Buffer接口中定义的，而是属于ByteBuffer。\n\n如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用compact()方法。\n\ncompact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。\n\n```java\nprint(buffer, bs);\nSystem.out.println(buffer.remaining());\nbuffer.compact();\nprint(buffer, bs);\n```\n打印如下：\n\n```\njava.nio.HeapByteBuffer[pos=2 lim=6 cap=10]\nyelloy$$$$\n4\njava.nio.HeapByteBuffer[pos=4 lim=10 cap=10]\nlloyoy$$$$\n```\n\n- **ByteBuffer.equals()、ByteBuffer.compareTo()**\n\n可以使用equals()和compareTo()方法两个Buffer。\n\n下面提到的剩余元素是从 position到limit之间的元素。\n\n**equals()**\n\n当满足下列条件时，表示两个Buffer相等：\n\n有相同的类型（byte、char、int等）。\n\nBuffer中剩余的byte、char等的个数相等。\n\nBuffer中所有剩余的byte、char等都相同。\n\n在每个缓冲区中应被get()函数返回的剩余数据元素序列必须一致。\n\nequals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。\n\n**compareTo()**\n\ncompareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：\n\n第一个不相等的元素小于另一个Buffer中对应的元素 。\n\n所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。\n\n## 只读缓冲区\n\n可以使用asReadOnlyBuffer()函数来生成一个只读的缓冲区视图。\n\n这个新的缓冲区不允许使用put()，并且其isReadOnly()函数将会返回true。对这一只读缓冲区的put()函数的调用尝试会导致抛出ReadOnlyBufferException异常。\n\n两个缓冲区共享数据元素，拥有同样的容量，但每个缓冲区拥有各自的位置，上界和标记属性。对一个缓冲区内的数据元素所做的改变会反映在另外一个缓冲区上。\n\n## 复制缓冲区\n\nduplicate()函数创建了一个与原始缓冲区相似的新缓冲区。两个缓冲区共享数据元素，拥有同样的容量，但每个缓冲区拥有各自的位置，上界和标记属性。对一个缓冲区内的数据元素所做的改变会反映在另外一个缓冲区上。这一副本缓冲区具有与原始缓冲区同样的数据视图。如果原始的缓冲区为只读，或者为直接缓冲区，新的缓冲区将继承这些属性。\n\n复制一个缓冲区会创建一个新的Buffer对象，但并不复制数据。原始缓冲区和副本都会操作同样的数据元素。\n\n## 直接缓冲区\n\n直接ByteBuffer是通过调用ByteBuffer.allocateDirect(int capacity)函数来创建的。\n\n什么是直接缓冲区(DirectByteBuffer)呢？直接缓冲区意味着所分配的这段内存是堆外内存，而我们通过ByteBuffer.allocate(int capacity)或者ByteBuffer.wrap(byte[] array)分配的内存是堆内存，其返回的实例为HeapByteBuffer，HeapByteBuffer中持有一个byte数组，这个数组所占有的内存是堆内内存。\n\n[Netty之Java堆外内存扫盲贴](http://calvin1978.blogcn.com/articles/directbytebuffer.html)了解java堆外内存。\n\nsun.nio.ch.FileChannelImpl.read(ByteBuffer dst)\n\n{% asset_img 1.png sun.nio.ch.FileChannelImpl.read %}\n\nsun.nio.ch.IOUtil.read(FileDescriptor fd, ByteBuffer dst, long position,NativeDispatcher nd, Object lock)\n\n{% asset_img 2.png sun.nio.ch.IOUtil.read %}\n\n观察上面两段代码发现，我们通过一个文件通道去填充一个ByteBuffer时，先执行`sun.nio.ch.FileChannelImpl.read(ByteBuffer dst)`方法，其中调用了`sun.nio.ch.IOUtil.read(FileDescriptor fd, ByteBuffer dst, long position,NativeDispatcher nd, Object lock)`方法，观察这个方法，发现其中会做一个判断：如果是直接缓冲区(DirectBuffer)，直接调用`readIntoNativeBuffer(fd, dst, position, nd, lock)`并返回；如果是非直接缓冲区(HeapByteBuffer)，先获取一个直接缓冲区，然后使用该直接缓冲区作为参数调用`readIntoNativeBuffer(fd, dst, position, nd, lock)`，然后将填充完毕的DirectBuffer的内容复制到HeapByteBuffer当中，然后返回。\n\n直接缓冲区的内存分配调用了sun.misc.Unsafe.allocateMemory(size),返回了内存基地址，实际上就是malloc。\n\n看一下[java doc](https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html)对DirectBuffer的说明：\n\n> A byte buffer is either direct or non-direct. Given a direct byte buffer, the Java virtual machine will make a best effort to perform native I/O operations directly upon it. That is, it will attempt to avoid copying the buffer's content to (or from) an intermediate buffer before (or after) each invocation of one of the underlying operating system's native I/O operations.\n\n给定一个直接字节缓冲区，Java 虚拟机将尽最大努力直接对它执行本机 I/O 操作。也就是说，它会在每一次调用底层操作系统的本机 I/O 操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据)。\n\n结合上面的代码，就可以理解这段话的含义。\n\n那么，为什么需要直接缓冲区，也就是堆外内存来执行IO呢？\n\n以读操作为例，数据从底层硬件读到内核缓冲区之后，操作系统会从内核空间复制数据到用户空间，此时的用户进程空间就是jvm，这意味着 I/O 操作的目标内存区域必须是连续的字节序列。在 Java 中，数组是对象，在 JVM 中，字节数组可能不会在内存中连续存储。因此，这个连续的字节序列就是直接缓冲区中分配的内存空间。需要直接缓冲区来当一个中间人，完成数据的写入或者读取。\n\n其实，在传统BIO中，也是这么做的，同样需要一个堆外内存来充当这个中间人：比如FileInputStream.read(byte b[], int off, int len):\n\nFileInputStream.read(byte b[], int off, int len)调用了readBytes(byte b[], int off, int len)方法，这个方法是一个本地方法：\n\n```java\nJNIEXPORT jint JNICALL  \nJava_java_io_FileInputStream_readBytes(JNIEnv *env, jobject this,  \n        jbyteArray bytes, jint off, jint len) {//除了前两个参数，后三个就是readBytes方法传递进来的，字节数组、起始位置、长度三个参数  \nreturn readBytes(env, this, bytes, off, len, fis_fd);  \n}  \n```\n\n```java\njint\nreadBytes(JNIEnv *env, jobject this, jbyteArray bytes,\n          jint off, jint len, jfieldID fid)\n{\n    jint nread;\n    char stackBuf[BUF_SIZE];\n    char *buf = NULL;\n    FD fd;\n \n    if (IS_NULL(bytes)) {\n        JNU_ThrowNullPointerException(env, NULL);\n        return -1;\n    }\n \n    if (outOfBounds(env, off, len, bytes)) {\n        JNU_ThrowByName(env, \"java/lang/IndexOutOfBoundsException\", NULL);\n        return -1;\n    }\n \n    if (len == 0) {\n        return 0;\n    } else if (len > BUF_SIZE) {\n        buf = malloc(len);// buf的分配\n        if (buf == NULL) {\n            JNU_ThrowOutOfMemoryError(env, NULL);\n            return 0;\n        }\n    } else {\n        buf = stackBuf;\n    }\n \n    fd = GET_FD(this, fid);\n    if (fd == -1) {\n        JNU_ThrowIOException(env, \"Stream Closed\");\n        nread = -1;\n    } else {\n        nread = IO_Read(fd, buf, len);// buf是使用malloc分配的直接缓冲区，也就是堆外内存\n        if (nread > 0) {\n            (*env)->SetByteArrayRegion(env, bytes, off, nread, (jbyte *)buf);// 将直接缓冲区的内容copy到bytes数组中\n        } else if (nread == JVM_IO_ERR) {\n            JNU_ThrowIOExceptionWithLastError(env, \"Read error\");\n        } else if (nread == JVM_IO_INTR) {\n            JNU_ThrowByName(env, \"java/io/InterruptedIOException\", NULL);\n        } else { /* EOF */\n            nread = -1;\n        }\n    }\n \n    if (buf != stackBuf) {\n        free(buf);\n    }\n    return nread;\n}\n```\n可以看到，这个方法其实最关键的就是IO_Read这个宏定义的处理，而IO_Read其实只是代表了一个方法名称叫handleRead，我们去看一下handleRead的源码。\n\n```java\nJNIEXPORT  \nsize_t  \nhandleRead(jlong fd, void *buf, jint len)  \n{  \n    DWORD read = 0;  \n    BOOL result = 0;  \n    HANDLE h = (HANDLE)fd;  \n    if (h == INVALID_HANDLE_VALUE) {\n        return -1;  \n    }  \n    result = ReadFile(h,          \n                      buf,       \n                      len,       \n                      &read,      \n                      NULL);     \n    if (result == 0) {\n        int error = GetLastError();  \n        if (error == ERROR_BROKEN_PIPE) {  \n            return 0; \n        }  \n        return -1;  \n    }  \n    return read;  \n}  \n```\n\n通过上面的代码可以发现，传统的BIO也是把操作系统返回的数据放到直接缓冲区当中，然后在copy回我们传入的byte数组当中。\n\n所有的缓冲区都提供了一个叫做isDirect()的boolean函数，来测试特定缓冲区是否为直接缓冲区。\n\n> A direct byte buffer may be created by invoking the allocateDirect factory method of this class. The buffers returned by this method typically have somewhat higher allocation and deallocation costs than non-direct buffers. The contents of direct buffers may reside outside of the normal garbage-collected heap, and so their impact upon the memory footprint of an application might not be obvious. It is therefore recommended that direct buffers be allocated primarily for large, long-lived buffers that are subject to the underlying system's native I/O operations. In general it is best to allocate direct buffers only when they yield a measureable gain in program performance.\n\n直接缓冲区虽然避免了复制内存带来的消耗，但直接缓冲区使用的内存是通过调用本地操作系统方面的代码分配的，绕过了标准 JVM 堆栈。建立和销毁直接缓冲区会明显比具有堆栈的缓冲区更加破费，并且可能带来不易察觉的内存泄漏，或oom问题。所以，如果对于性能要求不是很严格，一般情况下，使用非直接缓冲区就足够了。\n\n## 缓冲区分片\n\nslice() 方法根据现有的缓冲区创建一种 子缓冲区 。也就是说，它创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据。\n\n现在我们对这个缓冲区 分片 ，以创建一个包含槽 3 到槽 6 的子缓冲区。在某种意义上，子缓冲区就像原来的缓冲区中的一个 窗口。\n\n窗口的起始和结束位置通过设置 position 和 limit 值来指定，然后调用 Buffer 的 slice() 方法：\n\n```java\nprint(buffer, bs);\nbuffer.position( 3 ).limit( 7 );\nByteBuffer slice = buffer.slice();\nprint(slice, slice.array());\n```\n\n打印如下：\n\n```\njava.nio.HeapByteBuffer[pos=4 lim=10 cap=10]\nlloyoy$$$$\njava.nio.HeapByteBuffer[pos=0 lim=4 cap=4]\nlloyoy$$$$\n```\n\nslice 是缓冲区的 子缓冲区 。不过， slice 和 buffer 共享同一个底层数据数组。\n\n## 类型视图缓冲区\n\n我们知道，Buffer可以作为通道执行IO的源头或者目标，但是通道只接受ByteBuffer类型的参数。比如read(ByteBuffer dst)。\n\n我们在进行IO操作时，可能会使用各种ByteBuffer类去读取文件内容，接收来自网络连接的数据使用各种ByteBuffer类去读取文件内容，接收来自网络连接的数据等。一旦数据到达了您的 ByteBuffer，我们需要对他进行一些操作。ByteBuffer类允许创建视图来将byte型缓冲区字节数据映射为其它的原始数据类型。例如，asLongBuffer()函数创建一个将八个字节型数据当成一个 long 型数据来存取的视图缓冲区。\n\n```java\npublic abstract class ByteBuffer extends Buffer implements Comparable{\n    // 这里仅列出部分API\n    public abstract CharBuffer asCharBuffer();\n    public abstract ShortBuffer asShortBuffer();\n    public abstract IntBuffer asIntBuffer();\n    public abstract LongBuffer asLongBuffer();\n    public abstract FloatBuffer asFloatBuffer();\n    public abstract DoubleBuffer asDoubleBuffer();\n}\n```\n\n```java\nbuffer.clear();\nbuffer.order(ByteOrder.BIG_ENDIAN);//指定字节序\nbuffer.put (0, (byte)0);\nbuffer.put (1, (byte)'H');\nbuffer.put (2, (byte)0);\nbuffer.put (3, (byte)'i');\nbuffer.put (4, (byte)0);\nbuffer.put (5, (byte)'!');\nbuffer.put (6, (byte)0);\n\nCharBuffer charBuffer = buffer.asCharBuffer();\nSystem.out.println(\"pos=\" + charBuffer.position() + \" limit=\" + charBuffer.limit() + \" cap=\" + charBuffer.capacity());;\nprint(charBuffer, bs);\n```\n\n打印如下：\n\n```\npos=0 limit=5 cap=5\nHi!   \n$H$i$!$$$$\n```\n\n新的缓冲区的容量是字节缓冲区中存在的元素数量除以视图类型中组成一个数据类型的字节数。视图缓冲区的第一个元素从创建它的ByteBuffer对象的位置开始(positon()函数的返回值)。\n\n{% asset_img 3.png 类型长度 %}\n\n## 测试代码\n\n前面提到的测试代码汇总：\n\n```java\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.CharBuffer;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tbyte[] bs = new byte[10];\n\t\tByteBuffer buffer = ByteBuffer.wrap(bs);\n\t\tSystem.out.println(buffer.toString());\n\t\t// put\n\t\tbuffer.put((byte)'h').put((byte)'e').put((byte)'l').put((byte)'l').put((byte)'o');\n\t\tprint(buffer, bs);\n\t\tbuffer.put(0, (byte)'y').put((byte)'y');\n\t\tprint(buffer, bs);\n\t\t\n\t\t//flip\n\t\tbuffer.flip();\n\t\tprint(buffer, bs);\n\t\t\n\t\t// rewind\n\t\tSystem.out.println((char)buffer.get());\n\t\tSystem.out.println((char)buffer.get(3));\n\t\tprint(buffer, bs);\n\t\t\n\t\tbuffer.rewind();\n\t\tprint(buffer, bs);\n\t\t\n\t\t// mark reset\n\t\tbuffer.position(2);\n\t\tbuffer.mark();\n\t\tprint(buffer, bs);\n\t\tbuffer.position(4);\n\t\tprint(buffer, bs);\n\t\tbuffer.reset();\n\t\tprint(buffer, bs);\n\t\t\n\t\t// compact\n\t\tSystem.out.println(buffer.remaining());\n\t\tbuffer.compact();\n\t\tprint(buffer, bs);\n\t\t\n\t\t// slice\n\t\tbuffer.position( 3 ).limit( 7 );\n\t\tByteBuffer slice = buffer.slice();\n\t\tprint(slice, slice.array());\n\t\t\n\t\t// asCharBuffer\n\t\tbuffer.clear();\n\t\tbuffer.order(ByteOrder.BIG_ENDIAN);\n\t\tbuffer.put (0, (byte)0);\n        buffer.put (1, (byte)'H');\n        buffer.put (2, (byte)0);\n        buffer.put (3, (byte)'i');\n        buffer.put (4, (byte)0);\n        buffer.put (5, (byte)'!');\n        buffer.put (6, (byte)0);\n\t\tCharBuffer charBuffer = buffer.asCharBuffer();\n\t\tSystem.out.println(\"pos=\" + charBuffer.position() + \" limit=\" + charBuffer.limit() + \" cap=\" + charBuffer.capacity());;\n\t\tprint(charBuffer, bs);\n\t}\n\t\n\tpublic static void print(Buffer buffer, byte[] bs) {\n\t\tSystem.out.println(buffer.toString());\n\t\tfor (int i = 0; i < bs.length; i++) {\n\t\t\tif (bs[i] != 0) {\n\t\t\t\tchar c = (char)bs[i];\n\t\t\t\tSystem.out.print(c);\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\"$\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n}\n```\n\n## 参考\n\n[Why is Traditional Java I/O Uninterruptable?](https://www.ksmpartners.com/2013/07/why-is-traditional-java-io-uninterruptable/)\n\n[JNI探秘-----FileInputStream的read方法详解](http://blog.csdn.net/zuoxiaolong8810/article/details/9974525)\n\n[NIO 入门](https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html)\n\n[Java NIO Buffer](http://tutorials.jenkov.com/java-nio/buffers.html)","source":"_posts/java-NIO-Buffer.md","raw":"---\nlayout: post\ntitle: Java-NIO-Buffer\ndate: 2017-06-28 20:36:36\ncategories: 编程\ntags: java\n---\n> 最近在看java nio方面的知识，打算写几篇博客总结一下，就从Buffer开始吧\n\n## Buffer\n\njava NIO库是在jdk1.4中引入的，NIO与IO之间的第一个区别在于，IO是面向流的，而NIO是面向块的。\n\n所谓的面向流是指：系统一次一个字节的处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。\n\n所谓的面向块是指：以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。\n\n按块的方式处理数据要比按流的方式处理数据快，因为按块的方式读取或写入数据所执行的系统调用要远少于一次一个字节的方式，类似于BufferedInputStream的方式。\n\n上面所说的块，在NIO中就是Buffer对象。\n\n一个 Buffer(缓冲区) 实质上是一个容器对象，它包含一些要写入或者刚读出的数据。在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 仅仅 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。\n\n举例来说，ByteBuffer实质上是对byte数组进行了封装，其内部是一个byte数组，ByteBuffer对象提供了一些实用的API供我们去操作这个数组，完成一些读取或写入的功能。我们所要学习的，就是理解在调用这些API的时候，Buffer处理数组的方式。\n\n除了boolean类型之外，java为每种基本类型都封装了对应的Buffer对象。\n\n{% asset_img buffer.png Buffer %}\n\n<!-- more -->\n\n## 状态变量\n\nBuffer使用四个值指定了缓冲区在某个时刻的状态：\n\n**容量(Capacity)**：缓冲区能够容纳的数据元素的最大数量\n\n实际上，这个值指定了底层数组的大小。这一值在缓冲区创建时被设定，并且永远不能被改变。\n\n**位置(Position)**：下一个要被读或写的元素的索引\n\nposition 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。比如，从通道中读三个字节到缓冲区中，那么缓冲区的 position 将会设置为3，指向数组中第四个元素。\n\n初始的position值为0。\n\n**边界(Limit)**：缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。\n\n在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。\n\n当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。\n\n**标记(Mark)**：一个备忘位置。\n\n调用 mark()来设定 mark = postion。调用 reset()设定 position = mark。\n\n初始的mark值为-1。\n\n上面四个属性遵循以下的关系：\n\n`0 <= mark <= position <= limit <= capacity`\n\n## API\n\n{% asset_img buffer_api.png Buffer %}\n\n- **创建**\n\n在了解这些api之前，首先需要知道如何创建一个Buffer对象：\n\n在上一个小节中提到的7种缓冲区类没有一种是可以直接实例化的，他们都是抽象类，但都包含了静态工厂方法创建相应的实例。以ByteBuffer为例：(对于其他六中缓冲区类也适用)\n\n`ByteBuffer buffer = ByteBuffer.allocate(1024);`\n\nallocate方法分配了一个具有指定大小底层数组的缓冲区对象，这个大小也就是上面提到的Capacity。\n\n我们也可以使用已经存在的数组来作为缓冲区对象的底层数组：\n\n```java\nbyte array[] = new byte[1024];\nByteBuffer buffer = ByteBuffer.wrap(array);\n```\n\n此时，buffer对象的底层数组指向了array，这意味着直接修改array数组也会使buffer对象读取的数据产生变化。\n\n```java\nbyte[] bs = new byte[10];\nByteBuffer buffer = ByteBuffer.wrap(bs);\nSystem.out.println(buffer.toString());\n```\n\n打印如下：\n\n```\njava.nio.HeapByteBuffer[pos=0 lim=10 cap=10]\n```\n\n可见，新初始化的Buffer实例中，position = 0，limit=capacity=10\n\n- **存取**\n\n注意到Buffer类中并没有提供get或者put函数。实际上每一个Buffer对象都有这两个函数，但它们所采用的参数类型，以及它们返回的数据类型，对每个子类来说都是唯一的，所以它们不能在顶层Buffer类中被抽象地声明。这些存取方法被定义在Buffer类的子类当中，我们一ByteBuffer为例：\n\n```java\npublic abstract byte get();\npublic abstract byte get (int index);\npublic abstract ByteBuffer put (byte b);\npublic abstract ByteBuffer put (int index, byte b);\n```\n\nByteBuffer实际上还提供了 `get(byte[] dst, int offset, int length)`这样的接口，其内部实现也是循环调用了get()方法。\n\nget和put可以是相对的或者是绝对的。\n\n相对方案是不带有索引参数的函数。当相对函数被调用时，位置在返回时前进一。\n\n绝对存取不会影响缓冲区的位置属性(Position、Limit、Capacity、Mark)。\n\n```java\nbuffer.put((byte)'h').put((byte)'e').put((byte)'l').put((byte)'l').put((byte)'o');\nprint(buffer, bs);\nbuffer.put(0, (byte)'y').put((byte)'y');\nprint(buffer, bs);\n\n//观察Buffer底层存储情况\npublic static void print(Buffer buffer, byte[] bs) {\n\t\tSystem.out.println(buffer.toString());\n\t\tfor (int i = 0; i < bs.length; i++) {\n\t\t\tif (bs[i] != 0) {\n\t\t\t\tchar c = (char)bs[i];\n\t\t\t\tSystem.out.print(c);\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\"$\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n```\n打印如下：\n\n```\njava.nio.HeapByteBuffer[pos=5 lim=10 cap=10]\nhello$$$$$\njava.nio.HeapByteBuffer[pos=6 lim=10 cap=10]\nyelloy$$$$\n```\n可以看到，存入5个字节之后，position增加为5，limit与capacity不变。\n调用buffer.put(0, (byte)'y')，将bs[0]的数据改写为(byte)'y'，position并没有改变。\n\n- **Buffer.flip()**\n\n我们想要将刚刚写入的数据读出的话应该怎么做？应该将position设为0：buffer.position(0)，就可以从正确的位置开始获取数据。但是它是怎样知道何时到达我们所插入数据末端的呢？这就是边界属性被引入的目的。边界属性指明了缓冲区有效内容的末端。我们需要将limit设置为当前位置：buffer.limit(buffer.position())。\n\n`buffer.limit(buffer.position()).position(0);`\n\nBuffer已经提供了一个方法封装了这些操作：\n\n```java\npublic final Buffer flip() {\n        limit = position;\n        position = 0;\n        mark = -1;\n        return this;\n}\n```\n```java\nbuffer.flip();\nprint(buffer, bs);\n```\n\n打印如下：\n\n```\njava.nio.HeapByteBuffer[pos=0 lim=6 cap=10]\nyelloy$$$$\n```\n\n调用buffer.flip()后，limit设置为当前position值，position重置为0.\n\n- **Buffer.rewind()**\n\n紧接着上面的程序：\n\n```java\nSystem.out.println((char)buffer.get());\nSystem.out.println((char)buffer.get(3));\nprint(buffer, bs);\n\t\t\nbuffer.rewind();\nprint(buffer, bs);\n```\n\n打印如下：\n\n```\ny\nl\njava.nio.HeapByteBuffer[pos=1 lim=6 cap=10]\nyelloy$$$$\njava.nio.HeapByteBuffer[pos=0 lim=6 cap=10]\nyelloy$$$$\n```\n\n可以看到，rewind()方法与filp()相似，但是不影响limit，他只是将position设为0，这样就可以从新读取已经读过的数据了。\n\n```java\npublic final Buffer rewind() {\n        position = 0;\n        mark = -1;\n        return this;\n}\n```\n\n- **Buffer.mark()、Buffer.reset()**\n\n```java\npublic final Buffer mark() {\n        mark = position;\n        return this;\n}\n\npublic final Buffer reset() {\n        int m = mark;\n        if (m < 0)\n            throw new InvalidMarkException();\n        position = m;\n        return this;\n}\n```\nBuffer.mark(),使缓冲区能够记住一个位置并在之后将其返回。\n\n缓冲区的标记在mark()函数被调用之前是未定义的，调用时标记被设为当前位置的值。reset()函数将位置设为当前的标记值。如果标记值未定义，调用reset()将导致InvalidMarkException异常。\n\n```java\nbuffer.position(2);\nbuffer.mark();\nprint(buffer, bs);\nbuffer.position(4);\nprint(buffer, bs);\nbuffer.reset();\nprint(buffer, bs);\n```\n\n打印如下：\n\n```\njava.nio.HeapByteBuffer[pos=2 lim=6 cap=10]\nyelloy$$$$\njava.nio.HeapByteBuffer[pos=4 lim=6 cap=10]\nyelloy$$$$\njava.nio.HeapByteBuffer[pos=2 lim=6 cap=10]\nyelloy$$$$\n```\n\n- **Buffer.remaining()、Buffer.hasRemaining()**\n\nremaining()函数将返回从当前位置到上界还剩余的元素数目。\n\nhasRemaining()会返回是否已经达到缓冲区的边界。\n\n```java\npublic final int remaining() {\n        return limit - position;\n}\n\npublic final boolean hasRemaining() {\n        return position < limit;\n}\n```\n有两种方法读取缓冲区的所有剩余数据：\n\n```java\n// 第一种\nfor (int i = 0; buffer.hasRemaining(), i++) {\n    myByteArray [i] = buffer.get();\n}\n\n// 第二种\nint count = buffer.remaining();\nfor (int i = 0; i < count, i++) {\n    myByteArray [i] = buffer.get();\n}\n```\n\n- **Buffer.clear()**\n\nclear()函数将缓冲区重置为空状态。它并不改变缓冲区中的任何数据元素，而是仅仅将上界设为容量的值，并把位置设回 0。\n\n```java\npublic final Buffer clear() {\n        position = 0;\n        limit = capacity;\n        mark = -1;\n        return this;\n}\n```\n\n- **ByteBuffer.compact()**\n\ncompact()方法并不是Buffer接口中定义的，而是属于ByteBuffer。\n\n如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用compact()方法。\n\ncompact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。\n\n```java\nprint(buffer, bs);\nSystem.out.println(buffer.remaining());\nbuffer.compact();\nprint(buffer, bs);\n```\n打印如下：\n\n```\njava.nio.HeapByteBuffer[pos=2 lim=6 cap=10]\nyelloy$$$$\n4\njava.nio.HeapByteBuffer[pos=4 lim=10 cap=10]\nlloyoy$$$$\n```\n\n- **ByteBuffer.equals()、ByteBuffer.compareTo()**\n\n可以使用equals()和compareTo()方法两个Buffer。\n\n下面提到的剩余元素是从 position到limit之间的元素。\n\n**equals()**\n\n当满足下列条件时，表示两个Buffer相等：\n\n有相同的类型（byte、char、int等）。\n\nBuffer中剩余的byte、char等的个数相等。\n\nBuffer中所有剩余的byte、char等都相同。\n\n在每个缓冲区中应被get()函数返回的剩余数据元素序列必须一致。\n\nequals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。\n\n**compareTo()**\n\ncompareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：\n\n第一个不相等的元素小于另一个Buffer中对应的元素 。\n\n所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。\n\n## 只读缓冲区\n\n可以使用asReadOnlyBuffer()函数来生成一个只读的缓冲区视图。\n\n这个新的缓冲区不允许使用put()，并且其isReadOnly()函数将会返回true。对这一只读缓冲区的put()函数的调用尝试会导致抛出ReadOnlyBufferException异常。\n\n两个缓冲区共享数据元素，拥有同样的容量，但每个缓冲区拥有各自的位置，上界和标记属性。对一个缓冲区内的数据元素所做的改变会反映在另外一个缓冲区上。\n\n## 复制缓冲区\n\nduplicate()函数创建了一个与原始缓冲区相似的新缓冲区。两个缓冲区共享数据元素，拥有同样的容量，但每个缓冲区拥有各自的位置，上界和标记属性。对一个缓冲区内的数据元素所做的改变会反映在另外一个缓冲区上。这一副本缓冲区具有与原始缓冲区同样的数据视图。如果原始的缓冲区为只读，或者为直接缓冲区，新的缓冲区将继承这些属性。\n\n复制一个缓冲区会创建一个新的Buffer对象，但并不复制数据。原始缓冲区和副本都会操作同样的数据元素。\n\n## 直接缓冲区\n\n直接ByteBuffer是通过调用ByteBuffer.allocateDirect(int capacity)函数来创建的。\n\n什么是直接缓冲区(DirectByteBuffer)呢？直接缓冲区意味着所分配的这段内存是堆外内存，而我们通过ByteBuffer.allocate(int capacity)或者ByteBuffer.wrap(byte[] array)分配的内存是堆内存，其返回的实例为HeapByteBuffer，HeapByteBuffer中持有一个byte数组，这个数组所占有的内存是堆内内存。\n\n[Netty之Java堆外内存扫盲贴](http://calvin1978.blogcn.com/articles/directbytebuffer.html)了解java堆外内存。\n\nsun.nio.ch.FileChannelImpl.read(ByteBuffer dst)\n\n{% asset_img 1.png sun.nio.ch.FileChannelImpl.read %}\n\nsun.nio.ch.IOUtil.read(FileDescriptor fd, ByteBuffer dst, long position,NativeDispatcher nd, Object lock)\n\n{% asset_img 2.png sun.nio.ch.IOUtil.read %}\n\n观察上面两段代码发现，我们通过一个文件通道去填充一个ByteBuffer时，先执行`sun.nio.ch.FileChannelImpl.read(ByteBuffer dst)`方法，其中调用了`sun.nio.ch.IOUtil.read(FileDescriptor fd, ByteBuffer dst, long position,NativeDispatcher nd, Object lock)`方法，观察这个方法，发现其中会做一个判断：如果是直接缓冲区(DirectBuffer)，直接调用`readIntoNativeBuffer(fd, dst, position, nd, lock)`并返回；如果是非直接缓冲区(HeapByteBuffer)，先获取一个直接缓冲区，然后使用该直接缓冲区作为参数调用`readIntoNativeBuffer(fd, dst, position, nd, lock)`，然后将填充完毕的DirectBuffer的内容复制到HeapByteBuffer当中，然后返回。\n\n直接缓冲区的内存分配调用了sun.misc.Unsafe.allocateMemory(size),返回了内存基地址，实际上就是malloc。\n\n看一下[java doc](https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html)对DirectBuffer的说明：\n\n> A byte buffer is either direct or non-direct. Given a direct byte buffer, the Java virtual machine will make a best effort to perform native I/O operations directly upon it. That is, it will attempt to avoid copying the buffer's content to (or from) an intermediate buffer before (or after) each invocation of one of the underlying operating system's native I/O operations.\n\n给定一个直接字节缓冲区，Java 虚拟机将尽最大努力直接对它执行本机 I/O 操作。也就是说，它会在每一次调用底层操作系统的本机 I/O 操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据)。\n\n结合上面的代码，就可以理解这段话的含义。\n\n那么，为什么需要直接缓冲区，也就是堆外内存来执行IO呢？\n\n以读操作为例，数据从底层硬件读到内核缓冲区之后，操作系统会从内核空间复制数据到用户空间，此时的用户进程空间就是jvm，这意味着 I/O 操作的目标内存区域必须是连续的字节序列。在 Java 中，数组是对象，在 JVM 中，字节数组可能不会在内存中连续存储。因此，这个连续的字节序列就是直接缓冲区中分配的内存空间。需要直接缓冲区来当一个中间人，完成数据的写入或者读取。\n\n其实，在传统BIO中，也是这么做的，同样需要一个堆外内存来充当这个中间人：比如FileInputStream.read(byte b[], int off, int len):\n\nFileInputStream.read(byte b[], int off, int len)调用了readBytes(byte b[], int off, int len)方法，这个方法是一个本地方法：\n\n```java\nJNIEXPORT jint JNICALL  \nJava_java_io_FileInputStream_readBytes(JNIEnv *env, jobject this,  \n        jbyteArray bytes, jint off, jint len) {//除了前两个参数，后三个就是readBytes方法传递进来的，字节数组、起始位置、长度三个参数  \nreturn readBytes(env, this, bytes, off, len, fis_fd);  \n}  \n```\n\n```java\njint\nreadBytes(JNIEnv *env, jobject this, jbyteArray bytes,\n          jint off, jint len, jfieldID fid)\n{\n    jint nread;\n    char stackBuf[BUF_SIZE];\n    char *buf = NULL;\n    FD fd;\n \n    if (IS_NULL(bytes)) {\n        JNU_ThrowNullPointerException(env, NULL);\n        return -1;\n    }\n \n    if (outOfBounds(env, off, len, bytes)) {\n        JNU_ThrowByName(env, \"java/lang/IndexOutOfBoundsException\", NULL);\n        return -1;\n    }\n \n    if (len == 0) {\n        return 0;\n    } else if (len > BUF_SIZE) {\n        buf = malloc(len);// buf的分配\n        if (buf == NULL) {\n            JNU_ThrowOutOfMemoryError(env, NULL);\n            return 0;\n        }\n    } else {\n        buf = stackBuf;\n    }\n \n    fd = GET_FD(this, fid);\n    if (fd == -1) {\n        JNU_ThrowIOException(env, \"Stream Closed\");\n        nread = -1;\n    } else {\n        nread = IO_Read(fd, buf, len);// buf是使用malloc分配的直接缓冲区，也就是堆外内存\n        if (nread > 0) {\n            (*env)->SetByteArrayRegion(env, bytes, off, nread, (jbyte *)buf);// 将直接缓冲区的内容copy到bytes数组中\n        } else if (nread == JVM_IO_ERR) {\n            JNU_ThrowIOExceptionWithLastError(env, \"Read error\");\n        } else if (nread == JVM_IO_INTR) {\n            JNU_ThrowByName(env, \"java/io/InterruptedIOException\", NULL);\n        } else { /* EOF */\n            nread = -1;\n        }\n    }\n \n    if (buf != stackBuf) {\n        free(buf);\n    }\n    return nread;\n}\n```\n可以看到，这个方法其实最关键的就是IO_Read这个宏定义的处理，而IO_Read其实只是代表了一个方法名称叫handleRead，我们去看一下handleRead的源码。\n\n```java\nJNIEXPORT  \nsize_t  \nhandleRead(jlong fd, void *buf, jint len)  \n{  \n    DWORD read = 0;  \n    BOOL result = 0;  \n    HANDLE h = (HANDLE)fd;  \n    if (h == INVALID_HANDLE_VALUE) {\n        return -1;  \n    }  \n    result = ReadFile(h,          \n                      buf,       \n                      len,       \n                      &read,      \n                      NULL);     \n    if (result == 0) {\n        int error = GetLastError();  \n        if (error == ERROR_BROKEN_PIPE) {  \n            return 0; \n        }  \n        return -1;  \n    }  \n    return read;  \n}  \n```\n\n通过上面的代码可以发现，传统的BIO也是把操作系统返回的数据放到直接缓冲区当中，然后在copy回我们传入的byte数组当中。\n\n所有的缓冲区都提供了一个叫做isDirect()的boolean函数，来测试特定缓冲区是否为直接缓冲区。\n\n> A direct byte buffer may be created by invoking the allocateDirect factory method of this class. The buffers returned by this method typically have somewhat higher allocation and deallocation costs than non-direct buffers. The contents of direct buffers may reside outside of the normal garbage-collected heap, and so their impact upon the memory footprint of an application might not be obvious. It is therefore recommended that direct buffers be allocated primarily for large, long-lived buffers that are subject to the underlying system's native I/O operations. In general it is best to allocate direct buffers only when they yield a measureable gain in program performance.\n\n直接缓冲区虽然避免了复制内存带来的消耗，但直接缓冲区使用的内存是通过调用本地操作系统方面的代码分配的，绕过了标准 JVM 堆栈。建立和销毁直接缓冲区会明显比具有堆栈的缓冲区更加破费，并且可能带来不易察觉的内存泄漏，或oom问题。所以，如果对于性能要求不是很严格，一般情况下，使用非直接缓冲区就足够了。\n\n## 缓冲区分片\n\nslice() 方法根据现有的缓冲区创建一种 子缓冲区 。也就是说，它创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据。\n\n现在我们对这个缓冲区 分片 ，以创建一个包含槽 3 到槽 6 的子缓冲区。在某种意义上，子缓冲区就像原来的缓冲区中的一个 窗口。\n\n窗口的起始和结束位置通过设置 position 和 limit 值来指定，然后调用 Buffer 的 slice() 方法：\n\n```java\nprint(buffer, bs);\nbuffer.position( 3 ).limit( 7 );\nByteBuffer slice = buffer.slice();\nprint(slice, slice.array());\n```\n\n打印如下：\n\n```\njava.nio.HeapByteBuffer[pos=4 lim=10 cap=10]\nlloyoy$$$$\njava.nio.HeapByteBuffer[pos=0 lim=4 cap=4]\nlloyoy$$$$\n```\n\nslice 是缓冲区的 子缓冲区 。不过， slice 和 buffer 共享同一个底层数据数组。\n\n## 类型视图缓冲区\n\n我们知道，Buffer可以作为通道执行IO的源头或者目标，但是通道只接受ByteBuffer类型的参数。比如read(ByteBuffer dst)。\n\n我们在进行IO操作时，可能会使用各种ByteBuffer类去读取文件内容，接收来自网络连接的数据使用各种ByteBuffer类去读取文件内容，接收来自网络连接的数据等。一旦数据到达了您的 ByteBuffer，我们需要对他进行一些操作。ByteBuffer类允许创建视图来将byte型缓冲区字节数据映射为其它的原始数据类型。例如，asLongBuffer()函数创建一个将八个字节型数据当成一个 long 型数据来存取的视图缓冲区。\n\n```java\npublic abstract class ByteBuffer extends Buffer implements Comparable{\n    // 这里仅列出部分API\n    public abstract CharBuffer asCharBuffer();\n    public abstract ShortBuffer asShortBuffer();\n    public abstract IntBuffer asIntBuffer();\n    public abstract LongBuffer asLongBuffer();\n    public abstract FloatBuffer asFloatBuffer();\n    public abstract DoubleBuffer asDoubleBuffer();\n}\n```\n\n```java\nbuffer.clear();\nbuffer.order(ByteOrder.BIG_ENDIAN);//指定字节序\nbuffer.put (0, (byte)0);\nbuffer.put (1, (byte)'H');\nbuffer.put (2, (byte)0);\nbuffer.put (3, (byte)'i');\nbuffer.put (4, (byte)0);\nbuffer.put (5, (byte)'!');\nbuffer.put (6, (byte)0);\n\nCharBuffer charBuffer = buffer.asCharBuffer();\nSystem.out.println(\"pos=\" + charBuffer.position() + \" limit=\" + charBuffer.limit() + \" cap=\" + charBuffer.capacity());;\nprint(charBuffer, bs);\n```\n\n打印如下：\n\n```\npos=0 limit=5 cap=5\nHi!   \n$H$i$!$$$$\n```\n\n新的缓冲区的容量是字节缓冲区中存在的元素数量除以视图类型中组成一个数据类型的字节数。视图缓冲区的第一个元素从创建它的ByteBuffer对象的位置开始(positon()函数的返回值)。\n\n{% asset_img 3.png 类型长度 %}\n\n## 测试代码\n\n前面提到的测试代码汇总：\n\n```java\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.CharBuffer;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tbyte[] bs = new byte[10];\n\t\tByteBuffer buffer = ByteBuffer.wrap(bs);\n\t\tSystem.out.println(buffer.toString());\n\t\t// put\n\t\tbuffer.put((byte)'h').put((byte)'e').put((byte)'l').put((byte)'l').put((byte)'o');\n\t\tprint(buffer, bs);\n\t\tbuffer.put(0, (byte)'y').put((byte)'y');\n\t\tprint(buffer, bs);\n\t\t\n\t\t//flip\n\t\tbuffer.flip();\n\t\tprint(buffer, bs);\n\t\t\n\t\t// rewind\n\t\tSystem.out.println((char)buffer.get());\n\t\tSystem.out.println((char)buffer.get(3));\n\t\tprint(buffer, bs);\n\t\t\n\t\tbuffer.rewind();\n\t\tprint(buffer, bs);\n\t\t\n\t\t// mark reset\n\t\tbuffer.position(2);\n\t\tbuffer.mark();\n\t\tprint(buffer, bs);\n\t\tbuffer.position(4);\n\t\tprint(buffer, bs);\n\t\tbuffer.reset();\n\t\tprint(buffer, bs);\n\t\t\n\t\t// compact\n\t\tSystem.out.println(buffer.remaining());\n\t\tbuffer.compact();\n\t\tprint(buffer, bs);\n\t\t\n\t\t// slice\n\t\tbuffer.position( 3 ).limit( 7 );\n\t\tByteBuffer slice = buffer.slice();\n\t\tprint(slice, slice.array());\n\t\t\n\t\t// asCharBuffer\n\t\tbuffer.clear();\n\t\tbuffer.order(ByteOrder.BIG_ENDIAN);\n\t\tbuffer.put (0, (byte)0);\n        buffer.put (1, (byte)'H');\n        buffer.put (2, (byte)0);\n        buffer.put (3, (byte)'i');\n        buffer.put (4, (byte)0);\n        buffer.put (5, (byte)'!');\n        buffer.put (6, (byte)0);\n\t\tCharBuffer charBuffer = buffer.asCharBuffer();\n\t\tSystem.out.println(\"pos=\" + charBuffer.position() + \" limit=\" + charBuffer.limit() + \" cap=\" + charBuffer.capacity());;\n\t\tprint(charBuffer, bs);\n\t}\n\t\n\tpublic static void print(Buffer buffer, byte[] bs) {\n\t\tSystem.out.println(buffer.toString());\n\t\tfor (int i = 0; i < bs.length; i++) {\n\t\t\tif (bs[i] != 0) {\n\t\t\t\tchar c = (char)bs[i];\n\t\t\t\tSystem.out.print(c);\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\"$\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n}\n```\n\n## 参考\n\n[Why is Traditional Java I/O Uninterruptable?](https://www.ksmpartners.com/2013/07/why-is-traditional-java-io-uninterruptable/)\n\n[JNI探秘-----FileInputStream的read方法详解](http://blog.csdn.net/zuoxiaolong8810/article/details/9974525)\n\n[NIO 入门](https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html)\n\n[Java NIO Buffer](http://tutorials.jenkov.com/java-nio/buffers.html)","slug":"java-NIO-Buffer","published":1,"updated":"2017-06-29T12:35:48.298Z","comments":1,"photos":[],"link":"","_id":"cj4vch4dr000zx3gctknkgebc","content":"<blockquote>\n<p>最近在看java nio方面的知识，打算写几篇博客总结一下，就从Buffer开始吧</p>\n</blockquote>\n<h2 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h2><p>java NIO库是在jdk1.4中引入的，NIO与IO之间的第一个区别在于，IO是面向流的，而NIO是面向块的。</p>\n<p>所谓的面向流是指：系统一次一个字节的处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。</p>\n<p>所谓的面向块是指：以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。</p>\n<p>按块的方式处理数据要比按流的方式处理数据快，因为按块的方式读取或写入数据所执行的系统调用要远少于一次一个字节的方式，类似于BufferedInputStream的方式。</p>\n<p>上面所说的块，在NIO中就是Buffer对象。</p>\n<p>一个 Buffer(缓冲区) 实质上是一个容器对象，它包含一些要写入或者刚读出的数据。在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 仅仅 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>\n<p>举例来说，ByteBuffer实质上是对byte数组进行了封装，其内部是一个byte数组，ByteBuffer对象提供了一些实用的API供我们去操作这个数组，完成一些读取或写入的功能。我们所要学习的，就是理解在调用这些API的时候，Buffer处理数组的方式。</p>\n<p>除了boolean类型之外，java为每种基本类型都封装了对应的Buffer对象。</p>\n<img src=\"/2017/06/28/java-NIO-Buffer/buffer.png\" alt=\"Buffer\" title=\"Buffer\">\n<a id=\"more\"></a>\n<h2 id=\"状态变量\"><a href=\"#状态变量\" class=\"headerlink\" title=\"状态变量\"></a>状态变量</h2><p>Buffer使用四个值指定了缓冲区在某个时刻的状态：</p>\n<p><strong>容量(Capacity)</strong>：缓冲区能够容纳的数据元素的最大数量</p>\n<p>实际上，这个值指定了底层数组的大小。这一值在缓冲区创建时被设定，并且永远不能被改变。</p>\n<p><strong>位置(Position)</strong>：下一个要被读或写的元素的索引</p>\n<p>position 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。比如，从通道中读三个字节到缓冲区中，那么缓冲区的 position 将会设置为3，指向数组中第四个元素。</p>\n<p>初始的position值为0。</p>\n<p><strong>边界(Limit)</strong>：缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。</p>\n<p>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。</p>\n<p>当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。</p>\n<p><strong>标记(Mark)</strong>：一个备忘位置。</p>\n<p>调用 mark()来设定 mark = postion。调用 reset()设定 position = mark。</p>\n<p>初始的mark值为-1。</p>\n<p>上面四个属性遵循以下的关系：</p>\n<p><code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></p>\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><img src=\"/2017/06/28/java-NIO-Buffer/buffer_api.png\" alt=\"Buffer\" title=\"Buffer\">\n<ul>\n<li><strong>创建</strong></li>\n</ul>\n<p>在了解这些api之前，首先需要知道如何创建一个Buffer对象：</p>\n<p>在上一个小节中提到的7种缓冲区类没有一种是可以直接实例化的，他们都是抽象类，但都包含了静态工厂方法创建相应的实例。以ByteBuffer为例：(对于其他六中缓冲区类也适用)</p>\n<p><code>ByteBuffer buffer = ByteBuffer.allocate(1024);</code></p>\n<p>allocate方法分配了一个具有指定大小底层数组的缓冲区对象，这个大小也就是上面提到的Capacity。</p>\n<p>我们也可以使用已经存在的数组来作为缓冲区对象的底层数组：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">byte</span> array[] = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</div><div class=\"line\">ByteBuffer buffer = ByteBuffer.wrap(array);</div></pre></td></tr></table></figure>\n<p>此时，buffer对象的底层数组指向了array，这意味着直接修改array数组也会使buffer对象读取的数据产生变化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">byte</span>[] bs = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10</span>];</div><div class=\"line\">ByteBuffer buffer = ByteBuffer.wrap(bs);</div><div class=\"line\">System.out.println(buffer.toString());</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.HeapByteBuffer[pos=0 lim=10 cap=10]</div></pre></td></tr></table></figure>\n<p>可见，新初始化的Buffer实例中，position = 0，limit=capacity=10</p>\n<ul>\n<li><strong>存取</strong></li>\n</ul>\n<p>注意到Buffer类中并没有提供get或者put函数。实际上每一个Buffer对象都有这两个函数，但它们所采用的参数类型，以及它们返回的数据类型，对每个子类来说都是唯一的，所以它们不能在顶层Buffer类中被抽象地声明。这些存取方法被定义在Buffer类的子类当中，我们一ByteBuffer为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">byte</span> <span class=\"title\">get</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">byte</span> <span class=\"title\">get</span> <span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ByteBuffer <span class=\"title\">put</span> <span class=\"params\">(<span class=\"keyword\">byte</span> b)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ByteBuffer <span class=\"title\">put</span> <span class=\"params\">(<span class=\"keyword\">int</span> index, <span class=\"keyword\">byte</span> b)</span></span>;</div></pre></td></tr></table></figure>\n<p>ByteBuffer实际上还提供了 <code>get(byte[] dst, int offset, int length)</code>这样的接口，其内部实现也是循环调用了get()方法。</p>\n<p>get和put可以是相对的或者是绝对的。</p>\n<p>相对方案是不带有索引参数的函数。当相对函数被调用时，位置在返回时前进一。</p>\n<p>绝对存取不会影响缓冲区的位置属性(Position、Limit、Capacity、Mark)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">buffer.put((<span class=\"keyword\">byte</span>)<span class=\"string\">'h'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'e'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'l'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'l'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'o'</span>);</div><div class=\"line\">print(buffer, bs);</div><div class=\"line\">buffer.put(<span class=\"number\">0</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'y'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'y'</span>);</div><div class=\"line\">print(buffer, bs);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//观察Buffer底层存储情况</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(Buffer buffer, <span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(buffer.toString());</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; bs.length; i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (bs[i] != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">char</span> c = (<span class=\"keyword\">char</span>)bs[i];</div><div class=\"line\">\t\t\t\tSystem.out.print(c);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">\"$\"</span>);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"\"</span>);</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.HeapByteBuffer[pos=5 lim=10 cap=10]</div><div class=\"line\">hello$$$$$</div><div class=\"line\">java.nio.HeapByteBuffer[pos=6 lim=10 cap=10]</div><div class=\"line\">yelloy$$$$</div></pre></td></tr></table></figure>\n<p>可以看到，存入5个字节之后，position增加为5，limit与capacity不变。<br>调用buffer.put(0, (byte)’y’)，将bs[0]的数据改写为(byte)’y’，position并没有改变。</p>\n<ul>\n<li><strong>Buffer.flip()</strong></li>\n</ul>\n<p>我们想要将刚刚写入的数据读出的话应该怎么做？应该将position设为0：buffer.position(0)，就可以从正确的位置开始获取数据。但是它是怎样知道何时到达我们所插入数据末端的呢？这就是边界属性被引入的目的。边界属性指明了缓冲区有效内容的末端。我们需要将limit设置为当前位置：buffer.limit(buffer.position())。</p>\n<p><code>buffer.limit(buffer.position()).position(0);</code></p>\n<p>Buffer已经提供了一个方法封装了这些操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">flip</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        limit = position;</div><div class=\"line\">        position = <span class=\"number\">0</span>;</div><div class=\"line\">        mark = -<span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">buffer.flip();</div><div class=\"line\">print(buffer, bs);</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.HeapByteBuffer[pos=0 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div></pre></td></tr></table></figure>\n<p>调用buffer.flip()后，limit设置为当前position值，position重置为0.</p>\n<ul>\n<li><strong>Buffer.rewind()</strong></li>\n</ul>\n<p>紧接着上面的程序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">System.out.println((<span class=\"keyword\">char</span>)buffer.get());</div><div class=\"line\">System.out.println((<span class=\"keyword\">char</span>)buffer.get(<span class=\"number\">3</span>));</div><div class=\"line\">print(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">buffer.rewind();</div><div class=\"line\">print(buffer, bs);</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">y</div><div class=\"line\">l</div><div class=\"line\">java.nio.HeapByteBuffer[pos=1 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div><div class=\"line\">java.nio.HeapByteBuffer[pos=0 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div></pre></td></tr></table></figure>\n<p>可以看到，rewind()方法与filp()相似，但是不影响limit，他只是将position设为0，这样就可以从新读取已经读过的数据了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">rewind</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        position = <span class=\"number\">0</span>;</div><div class=\"line\">        mark = -<span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>Buffer.mark()、Buffer.reset()</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">mark</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        mark = position;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">reset</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> m = mark;</div><div class=\"line\">        <span class=\"keyword\">if</span> (m &lt; <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvalidMarkException();</div><div class=\"line\">        position = m;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Buffer.mark(),使缓冲区能够记住一个位置并在之后将其返回。</p>\n<p>缓冲区的标记在mark()函数被调用之前是未定义的，调用时标记被设为当前位置的值。reset()函数将位置设为当前的标记值。如果标记值未定义，调用reset()将导致InvalidMarkException异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">buffer.position(<span class=\"number\">2</span>);</div><div class=\"line\">buffer.mark();</div><div class=\"line\">print(buffer, bs);</div><div class=\"line\">buffer.position(<span class=\"number\">4</span>);</div><div class=\"line\">print(buffer, bs);</div><div class=\"line\">buffer.reset();</div><div class=\"line\">print(buffer, bs);</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.HeapByteBuffer[pos=2 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div><div class=\"line\">java.nio.HeapByteBuffer[pos=4 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div><div class=\"line\">java.nio.HeapByteBuffer[pos=2 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>Buffer.remaining()、Buffer.hasRemaining()</strong></li>\n</ul>\n<p>remaining()函数将返回从当前位置到上界还剩余的元素数目。</p>\n<p>hasRemaining()会返回是否已经达到缓冲区的边界。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">remaining</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> limit - position;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasRemaining</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> position &lt; limit;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有两种方法读取缓冲区的所有剩余数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 第一种</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; buffer.hasRemaining(), i++) &#123;</div><div class=\"line\">    myByteArray [i] = buffer.get();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第二种</span></div><div class=\"line\"><span class=\"keyword\">int</span> count = buffer.remaining();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count, i++) &#123;</div><div class=\"line\">    myByteArray [i] = buffer.get();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>Buffer.clear()</strong></li>\n</ul>\n<p>clear()函数将缓冲区重置为空状态。它并不改变缓冲区中的任何数据元素，而是仅仅将上界设为容量的值，并把位置设回 0。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        position = <span class=\"number\">0</span>;</div><div class=\"line\">        limit = capacity;</div><div class=\"line\">        mark = -<span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>ByteBuffer.compact()</strong></li>\n</ul>\n<p>compact()方法并不是Buffer接口中定义的，而是属于ByteBuffer。</p>\n<p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用compact()方法。</p>\n<p>compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(buffer, bs);</div><div class=\"line\">System.out.println(buffer.remaining());</div><div class=\"line\">buffer.compact();</div><div class=\"line\">print(buffer, bs);</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.HeapByteBuffer[pos=2 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div><div class=\"line\">4</div><div class=\"line\">java.nio.HeapByteBuffer[pos=4 lim=10 cap=10]</div><div class=\"line\">lloyoy$$$$</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>ByteBuffer.equals()、ByteBuffer.compareTo()</strong></li>\n</ul>\n<p>可以使用equals()和compareTo()方法两个Buffer。</p>\n<p>下面提到的剩余元素是从 position到limit之间的元素。</p>\n<p><strong>equals()</strong></p>\n<p>当满足下列条件时，表示两个Buffer相等：</p>\n<p>有相同的类型（byte、char、int等）。</p>\n<p>Buffer中剩余的byte、char等的个数相等。</p>\n<p>Buffer中所有剩余的byte、char等都相同。</p>\n<p>在每个缓冲区中应被get()函数返回的剩余数据元素序列必须一致。</p>\n<p>equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。</p>\n<p><strong>compareTo()</strong></p>\n<p>compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p>\n<p>第一个不相等的元素小于另一个Buffer中对应的元素 。</p>\n<p>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</p>\n<h2 id=\"只读缓冲区\"><a href=\"#只读缓冲区\" class=\"headerlink\" title=\"只读缓冲区\"></a>只读缓冲区</h2><p>可以使用asReadOnlyBuffer()函数来生成一个只读的缓冲区视图。</p>\n<p>这个新的缓冲区不允许使用put()，并且其isReadOnly()函数将会返回true。对这一只读缓冲区的put()函数的调用尝试会导致抛出ReadOnlyBufferException异常。</p>\n<p>两个缓冲区共享数据元素，拥有同样的容量，但每个缓冲区拥有各自的位置，上界和标记属性。对一个缓冲区内的数据元素所做的改变会反映在另外一个缓冲区上。</p>\n<h2 id=\"复制缓冲区\"><a href=\"#复制缓冲区\" class=\"headerlink\" title=\"复制缓冲区\"></a>复制缓冲区</h2><p>duplicate()函数创建了一个与原始缓冲区相似的新缓冲区。两个缓冲区共享数据元素，拥有同样的容量，但每个缓冲区拥有各自的位置，上界和标记属性。对一个缓冲区内的数据元素所做的改变会反映在另外一个缓冲区上。这一副本缓冲区具有与原始缓冲区同样的数据视图。如果原始的缓冲区为只读，或者为直接缓冲区，新的缓冲区将继承这些属性。</p>\n<p>复制一个缓冲区会创建一个新的Buffer对象，但并不复制数据。原始缓冲区和副本都会操作同样的数据元素。</p>\n<h2 id=\"直接缓冲区\"><a href=\"#直接缓冲区\" class=\"headerlink\" title=\"直接缓冲区\"></a>直接缓冲区</h2><p>直接ByteBuffer是通过调用ByteBuffer.allocateDirect(int capacity)函数来创建的。</p>\n<p>什么是直接缓冲区(DirectByteBuffer)呢？直接缓冲区意味着所分配的这段内存是堆外内存，而我们通过ByteBuffer.allocate(int capacity)或者ByteBuffer.wrap(byte[] array)分配的内存是堆内存，其返回的实例为HeapByteBuffer，HeapByteBuffer中持有一个byte数组，这个数组所占有的内存是堆内内存。</p>\n<p><a href=\"http://calvin1978.blogcn.com/articles/directbytebuffer.html\" target=\"_blank\" rel=\"external\">Netty之Java堆外内存扫盲贴</a>了解java堆外内存。</p>\n<p>sun.nio.ch.FileChannelImpl.read(ByteBuffer dst)</p>\n<img src=\"/2017/06/28/java-NIO-Buffer/1.png\" alt=\"sun.nio.ch.FileChannelImpl.read\" title=\"sun.nio.ch.FileChannelImpl.read\">\n<p>sun.nio.ch.IOUtil.read(FileDescriptor fd, ByteBuffer dst, long position,NativeDispatcher nd, Object lock)</p>\n<img src=\"/2017/06/28/java-NIO-Buffer/2.png\" alt=\"sun.nio.ch.IOUtil.read\" title=\"sun.nio.ch.IOUtil.read\">\n<p>观察上面两段代码发现，我们通过一个文件通道去填充一个ByteBuffer时，先执行<code>sun.nio.ch.FileChannelImpl.read(ByteBuffer dst)</code>方法，其中调用了<code>sun.nio.ch.IOUtil.read(FileDescriptor fd, ByteBuffer dst, long position,NativeDispatcher nd, Object lock)</code>方法，观察这个方法，发现其中会做一个判断：如果是直接缓冲区(DirectBuffer)，直接调用<code>readIntoNativeBuffer(fd, dst, position, nd, lock)</code>并返回；如果是非直接缓冲区(HeapByteBuffer)，先获取一个直接缓冲区，然后使用该直接缓冲区作为参数调用<code>readIntoNativeBuffer(fd, dst, position, nd, lock)</code>，然后将填充完毕的DirectBuffer的内容复制到HeapByteBuffer当中，然后返回。</p>\n<p>直接缓冲区的内存分配调用了sun.misc.Unsafe.allocateMemory(size),返回了内存基地址，实际上就是malloc。</p>\n<p>看一下<a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html\" target=\"_blank\" rel=\"external\">java doc</a>对DirectBuffer的说明：</p>\n<blockquote>\n<p>A byte buffer is either direct or non-direct. Given a direct byte buffer, the Java virtual machine will make a best effort to perform native I/O operations directly upon it. That is, it will attempt to avoid copying the buffer’s content to (or from) an intermediate buffer before (or after) each invocation of one of the underlying operating system’s native I/O operations.</p>\n</blockquote>\n<p>给定一个直接字节缓冲区，Java 虚拟机将尽最大努力直接对它执行本机 I/O 操作。也就是说，它会在每一次调用底层操作系统的本机 I/O 操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据)。</p>\n<p>结合上面的代码，就可以理解这段话的含义。</p>\n<p>那么，为什么需要直接缓冲区，也就是堆外内存来执行IO呢？</p>\n<p>以读操作为例，数据从底层硬件读到内核缓冲区之后，操作系统会从内核空间复制数据到用户空间，此时的用户进程空间就是jvm，这意味着 I/O 操作的目标内存区域必须是连续的字节序列。在 Java 中，数组是对象，在 JVM 中，字节数组可能不会在内存中连续存储。因此，这个连续的字节序列就是直接缓冲区中分配的内存空间。需要直接缓冲区来当一个中间人，完成数据的写入或者读取。</p>\n<p>其实，在传统BIO中，也是这么做的，同样需要一个堆外内存来充当这个中间人：比如FileInputStream.read(byte b[], int off, int len):</p>\n<p>FileInputStream.read(byte b[], int off, int len)调用了readBytes(byte b[], int off, int len)方法，这个方法是一个本地方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">JNIEXPORT jint JNICALL  </span></div><div class=\"line\"><span class=\"title\">Java_java_io_FileInputStream_readBytes</span><span class=\"params\">(JNIEnv *env, jobject <span class=\"keyword\">this</span>,  </span></div><div class=\"line\">        jbyteArray bytes, jint off, jint len) &#123;<span class=\"comment\">//除了前两个参数，后三个就是readBytes方法传递进来的，字节数组、起始位置、长度三个参数  </span></div><div class=\"line\"><span class=\"keyword\">return</span> readBytes(env, <span class=\"keyword\">this</span>, bytes, off, len, fis_fd);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">jint</span></div><div class=\"line\"><span class=\"title\">readBytes</span><span class=\"params\">(JNIEnv *env, jobject <span class=\"keyword\">this</span>, jbyteArray bytes,</span></div><div class=\"line\">          jint off, jint len, jfieldID fid)</div><div class=\"line\">&#123;</div><div class=\"line\">    jint nread;</div><div class=\"line\">    <span class=\"keyword\">char</span> stackBuf[BUF_SIZE];</div><div class=\"line\">    <span class=\"keyword\">char</span> *buf = NULL;</div><div class=\"line\">    FD fd;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (IS_NULL(bytes)) &#123;</div><div class=\"line\">        JNU_ThrowNullPointerException(env, NULL);</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (outOfBounds(env, off, len, bytes)) &#123;</div><div class=\"line\">        JNU_ThrowByName(env, <span class=\"string\">\"java/lang/IndexOutOfBoundsException\"</span>, NULL);</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len &gt; BUF_SIZE) &#123;</div><div class=\"line\">        buf = malloc(len);<span class=\"comment\">// buf的分配</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (buf == NULL) &#123;</div><div class=\"line\">            JNU_ThrowOutOfMemoryError(env, NULL);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        buf = stackBuf;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    fd = GET_FD(<span class=\"keyword\">this</span>, fid);</div><div class=\"line\">    <span class=\"keyword\">if</span> (fd == -<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        JNU_ThrowIOException(env, <span class=\"string\">\"Stream Closed\"</span>);</div><div class=\"line\">        nread = -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        nread = IO_Read(fd, buf, len);<span class=\"comment\">// buf是使用malloc分配的直接缓冲区，也就是堆外内存</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (nread &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            (*env)-&gt;SetByteArrayRegion(env, bytes, off, nread, (jbyte *)buf);<span class=\"comment\">// 将直接缓冲区的内容copy到bytes数组中</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nread == JVM_IO_ERR) &#123;</div><div class=\"line\">            JNU_ThrowIOExceptionWithLastError(env, <span class=\"string\">\"Read error\"</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nread == JVM_IO_INTR) &#123;</div><div class=\"line\">            JNU_ThrowByName(env, <span class=\"string\">\"java/io/InterruptedIOException\"</span>, NULL);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* EOF */</span></div><div class=\"line\">            nread = -<span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (buf != stackBuf) &#123;</div><div class=\"line\">        free(buf);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> nread;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这个方法其实最关键的就是IO_Read这个宏定义的处理，而IO_Read其实只是代表了一个方法名称叫handleRead，我们去看一下handleRead的源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">JNIEXPORT  </span></div><div class=\"line\">size_t  </div><div class=\"line\"><span class=\"title\">handleRead</span><span class=\"params\">(jlong fd, <span class=\"keyword\">void</span> *buf, jint len)</span>  </div><div class=\"line\">&#123;  </div><div class=\"line\">    DWORD read = <span class=\"number\">0</span>;  </div><div class=\"line\">    BOOL result = <span class=\"number\">0</span>;  </div><div class=\"line\">    HANDLE h = (HANDLE)fd;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (h == INVALID_HANDLE_VALUE) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    result = ReadFile(h,          </div><div class=\"line\">                      buf,       </div><div class=\"line\">                      len,       </div><div class=\"line\">                      &amp;read,      </div><div class=\"line\">                      NULL);     </div><div class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> error = GetLastError();  </div><div class=\"line\">        <span class=\"keyword\">if</span> (error == ERROR_BROKEN_PIPE) &#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> read;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过上面的代码可以发现，传统的BIO也是把操作系统返回的数据放到直接缓冲区当中，然后在copy回我们传入的byte数组当中。</p>\n<p>所有的缓冲区都提供了一个叫做isDirect()的boolean函数，来测试特定缓冲区是否为直接缓冲区。</p>\n<blockquote>\n<p>A direct byte buffer may be created by invoking the allocateDirect factory method of this class. The buffers returned by this method typically have somewhat higher allocation and deallocation costs than non-direct buffers. The contents of direct buffers may reside outside of the normal garbage-collected heap, and so their impact upon the memory footprint of an application might not be obvious. It is therefore recommended that direct buffers be allocated primarily for large, long-lived buffers that are subject to the underlying system’s native I/O operations. In general it is best to allocate direct buffers only when they yield a measureable gain in program performance.</p>\n</blockquote>\n<p>直接缓冲区虽然避免了复制内存带来的消耗，但直接缓冲区使用的内存是通过调用本地操作系统方面的代码分配的，绕过了标准 JVM 堆栈。建立和销毁直接缓冲区会明显比具有堆栈的缓冲区更加破费，并且可能带来不易察觉的内存泄漏，或oom问题。所以，如果对于性能要求不是很严格，一般情况下，使用非直接缓冲区就足够了。</p>\n<h2 id=\"缓冲区分片\"><a href=\"#缓冲区分片\" class=\"headerlink\" title=\"缓冲区分片\"></a>缓冲区分片</h2><p>slice() 方法根据现有的缓冲区创建一种 子缓冲区 。也就是说，它创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据。</p>\n<p>现在我们对这个缓冲区 分片 ，以创建一个包含槽 3 到槽 6 的子缓冲区。在某种意义上，子缓冲区就像原来的缓冲区中的一个 窗口。</p>\n<p>窗口的起始和结束位置通过设置 position 和 limit 值来指定，然后调用 Buffer 的 slice() 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(buffer, bs);</div><div class=\"line\">buffer.position( <span class=\"number\">3</span> ).limit( <span class=\"number\">7</span> );</div><div class=\"line\">ByteBuffer slice = buffer.slice();</div><div class=\"line\">print(slice, slice.array());</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.HeapByteBuffer[pos=4 lim=10 cap=10]</div><div class=\"line\">lloyoy$$$$</div><div class=\"line\">java.nio.HeapByteBuffer[pos=0 lim=4 cap=4]</div><div class=\"line\">lloyoy$$$$</div></pre></td></tr></table></figure>\n<p>slice 是缓冲区的 子缓冲区 。不过， slice 和 buffer 共享同一个底层数据数组。</p>\n<h2 id=\"类型视图缓冲区\"><a href=\"#类型视图缓冲区\" class=\"headerlink\" title=\"类型视图缓冲区\"></a>类型视图缓冲区</h2><p>我们知道，Buffer可以作为通道执行IO的源头或者目标，但是通道只接受ByteBuffer类型的参数。比如read(ByteBuffer dst)。</p>\n<p>我们在进行IO操作时，可能会使用各种ByteBuffer类去读取文件内容，接收来自网络连接的数据使用各种ByteBuffer类去读取文件内容，接收来自网络连接的数据等。一旦数据到达了您的 ByteBuffer，我们需要对他进行一些操作。ByteBuffer类允许创建视图来将byte型缓冲区字节数据映射为其它的原始数据类型。例如，asLongBuffer()函数创建一个将八个字节型数据当成一个 long 型数据来存取的视图缓冲区。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ByteBuffer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Buffer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> CharBuffer <span class=\"title\">asCharBuffer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ShortBuffer <span class=\"title\">asShortBuffer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> IntBuffer <span class=\"title\">asIntBuffer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> LongBuffer <span class=\"title\">asLongBuffer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> FloatBuffer <span class=\"title\">asFloatBuffer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> DoubleBuffer <span class=\"title\">asDoubleBuffer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">buffer.clear();</div><div class=\"line\">buffer.order(ByteOrder.BIG_ENDIAN);<span class=\"comment\">//指定字节序</span></div><div class=\"line\">buffer.put (<span class=\"number\">0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">buffer.put (<span class=\"number\">1</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'H'</span>);</div><div class=\"line\">buffer.put (<span class=\"number\">2</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">buffer.put (<span class=\"number\">3</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'i'</span>);</div><div class=\"line\">buffer.put (<span class=\"number\">4</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">buffer.put (<span class=\"number\">5</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'!'</span>);</div><div class=\"line\">buffer.put (<span class=\"number\">6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">CharBuffer charBuffer = buffer.asCharBuffer();</div><div class=\"line\">System.out.println(<span class=\"string\">\"pos=\"</span> + charBuffer.position() + <span class=\"string\">\" limit=\"</span> + charBuffer.limit() + <span class=\"string\">\" cap=\"</span> + charBuffer.capacity());;</div><div class=\"line\">print(charBuffer, bs);</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pos=0 limit=5 cap=5</div><div class=\"line\">Hi!   </div><div class=\"line\">$H$i$!$$$$</div></pre></td></tr></table></figure>\n<p>新的缓冲区的容量是字节缓冲区中存在的元素数量除以视图类型中组成一个数据类型的字节数。视图缓冲区的第一个元素从创建它的ByteBuffer对象的位置开始(positon()函数的返回值)。</p>\n<img src=\"/2017/06/28/java-NIO-Buffer/3.png\" alt=\"类型长度\" title=\"类型长度\">\n<h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><p>前面提到的测试代码汇总：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.nio.Buffer;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteOrder;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.CharBuffer;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">byte</span>[] bs = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10</span>];</div><div class=\"line\">\t\tByteBuffer buffer = ByteBuffer.wrap(bs);</div><div class=\"line\">\t\tSystem.out.println(buffer.toString());</div><div class=\"line\">\t\t<span class=\"comment\">// put</span></div><div class=\"line\">\t\tbuffer.put((<span class=\"keyword\">byte</span>)<span class=\"string\">'h'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'e'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'l'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'l'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'o'</span>);</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\tbuffer.put(<span class=\"number\">0</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'y'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'y'</span>);</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">//flip</span></div><div class=\"line\">\t\tbuffer.flip();</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">// rewind</span></div><div class=\"line\">\t\tSystem.out.println((<span class=\"keyword\">char</span>)buffer.get());</div><div class=\"line\">\t\tSystem.out.println((<span class=\"keyword\">char</span>)buffer.get(<span class=\"number\">3</span>));</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tbuffer.rewind();</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">// mark reset</span></div><div class=\"line\">\t\tbuffer.position(<span class=\"number\">2</span>);</div><div class=\"line\">\t\tbuffer.mark();</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\tbuffer.position(<span class=\"number\">4</span>);</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\tbuffer.reset();</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">// compact</span></div><div class=\"line\">\t\tSystem.out.println(buffer.remaining());</div><div class=\"line\">\t\tbuffer.compact();</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">// slice</span></div><div class=\"line\">\t\tbuffer.position( <span class=\"number\">3</span> ).limit( <span class=\"number\">7</span> );</div><div class=\"line\">\t\tByteBuffer slice = buffer.slice();</div><div class=\"line\">\t\tprint(slice, slice.array());</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">// asCharBuffer</span></div><div class=\"line\">\t\tbuffer.clear();</div><div class=\"line\">\t\tbuffer.order(ByteOrder.BIG_ENDIAN);</div><div class=\"line\">\t\tbuffer.put (<span class=\"number\">0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">        buffer.put (<span class=\"number\">1</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'H'</span>);</div><div class=\"line\">        buffer.put (<span class=\"number\">2</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">        buffer.put (<span class=\"number\">3</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'i'</span>);</div><div class=\"line\">        buffer.put (<span class=\"number\">4</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">        buffer.put (<span class=\"number\">5</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'!'</span>);</div><div class=\"line\">        buffer.put (<span class=\"number\">6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">\t\tCharBuffer charBuffer = buffer.asCharBuffer();</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"pos=\"</span> + charBuffer.position() + <span class=\"string\">\" limit=\"</span> + charBuffer.limit() + <span class=\"string\">\" cap=\"</span> + charBuffer.capacity());;</div><div class=\"line\">\t\tprint(charBuffer, bs);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(Buffer buffer, <span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(buffer.toString());</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; bs.length; i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (bs[i] != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">char</span> c = (<span class=\"keyword\">char</span>)bs[i];</div><div class=\"line\">\t\t\t\tSystem.out.print(c);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">\"$\"</span>);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.ksmpartners.com/2013/07/why-is-traditional-java-io-uninterruptable/\" target=\"_blank\" rel=\"external\">Why is Traditional Java I/O Uninterruptable?</a></p>\n<p><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9974525\" target=\"_blank\" rel=\"external\">JNI探秘—–FileInputStream的read方法详解</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html\" target=\"_blank\" rel=\"external\">NIO 入门</a></p>\n<p><a href=\"http://tutorials.jenkov.com/java-nio/buffers.html\" target=\"_blank\" rel=\"external\">Java NIO Buffer</a></p>\n","excerpt":"<blockquote>\n<p>最近在看java nio方面的知识，打算写几篇博客总结一下，就从Buffer开始吧</p>\n</blockquote>\n<h2 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h2><p>java NIO库是在jdk1.4中引入的，NIO与IO之间的第一个区别在于，IO是面向流的，而NIO是面向块的。</p>\n<p>所谓的面向流是指：系统一次一个字节的处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。</p>\n<p>所谓的面向块是指：以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。</p>\n<p>按块的方式处理数据要比按流的方式处理数据快，因为按块的方式读取或写入数据所执行的系统调用要远少于一次一个字节的方式，类似于BufferedInputStream的方式。</p>\n<p>上面所说的块，在NIO中就是Buffer对象。</p>\n<p>一个 Buffer(缓冲区) 实质上是一个容器对象，它包含一些要写入或者刚读出的数据。在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 仅仅 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>\n<p>举例来说，ByteBuffer实质上是对byte数组进行了封装，其内部是一个byte数组，ByteBuffer对象提供了一些实用的API供我们去操作这个数组，完成一些读取或写入的功能。我们所要学习的，就是理解在调用这些API的时候，Buffer处理数组的方式。</p>\n<p>除了boolean类型之外，java为每种基本类型都封装了对应的Buffer对象。</p>\n<img src=\"/2017/06/28/java-NIO-Buffer/buffer.png\" alt=\"Buffer\" title=\"Buffer\">","more":"<h2 id=\"状态变量\"><a href=\"#状态变量\" class=\"headerlink\" title=\"状态变量\"></a>状态变量</h2><p>Buffer使用四个值指定了缓冲区在某个时刻的状态：</p>\n<p><strong>容量(Capacity)</strong>：缓冲区能够容纳的数据元素的最大数量</p>\n<p>实际上，这个值指定了底层数组的大小。这一值在缓冲区创建时被设定，并且永远不能被改变。</p>\n<p><strong>位置(Position)</strong>：下一个要被读或写的元素的索引</p>\n<p>position 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。比如，从通道中读三个字节到缓冲区中，那么缓冲区的 position 将会设置为3，指向数组中第四个元素。</p>\n<p>初始的position值为0。</p>\n<p><strong>边界(Limit)</strong>：缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。</p>\n<p>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。</p>\n<p>当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。</p>\n<p><strong>标记(Mark)</strong>：一个备忘位置。</p>\n<p>调用 mark()来设定 mark = postion。调用 reset()设定 position = mark。</p>\n<p>初始的mark值为-1。</p>\n<p>上面四个属性遵循以下的关系：</p>\n<p><code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></p>\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><img src=\"/2017/06/28/java-NIO-Buffer/buffer_api.png\" alt=\"Buffer\" title=\"Buffer\">\n<ul>\n<li><strong>创建</strong></li>\n</ul>\n<p>在了解这些api之前，首先需要知道如何创建一个Buffer对象：</p>\n<p>在上一个小节中提到的7种缓冲区类没有一种是可以直接实例化的，他们都是抽象类，但都包含了静态工厂方法创建相应的实例。以ByteBuffer为例：(对于其他六中缓冲区类也适用)</p>\n<p><code>ByteBuffer buffer = ByteBuffer.allocate(1024);</code></p>\n<p>allocate方法分配了一个具有指定大小底层数组的缓冲区对象，这个大小也就是上面提到的Capacity。</p>\n<p>我们也可以使用已经存在的数组来作为缓冲区对象的底层数组：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">byte</span> array[] = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</div><div class=\"line\">ByteBuffer buffer = ByteBuffer.wrap(array);</div></pre></td></tr></table></figure>\n<p>此时，buffer对象的底层数组指向了array，这意味着直接修改array数组也会使buffer对象读取的数据产生变化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">byte</span>[] bs = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10</span>];</div><div class=\"line\">ByteBuffer buffer = ByteBuffer.wrap(bs);</div><div class=\"line\">System.out.println(buffer.toString());</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.HeapByteBuffer[pos=0 lim=10 cap=10]</div></pre></td></tr></table></figure>\n<p>可见，新初始化的Buffer实例中，position = 0，limit=capacity=10</p>\n<ul>\n<li><strong>存取</strong></li>\n</ul>\n<p>注意到Buffer类中并没有提供get或者put函数。实际上每一个Buffer对象都有这两个函数，但它们所采用的参数类型，以及它们返回的数据类型，对每个子类来说都是唯一的，所以它们不能在顶层Buffer类中被抽象地声明。这些存取方法被定义在Buffer类的子类当中，我们一ByteBuffer为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">byte</span> <span class=\"title\">get</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">byte</span> <span class=\"title\">get</span> <span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ByteBuffer <span class=\"title\">put</span> <span class=\"params\">(<span class=\"keyword\">byte</span> b)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ByteBuffer <span class=\"title\">put</span> <span class=\"params\">(<span class=\"keyword\">int</span> index, <span class=\"keyword\">byte</span> b)</span></span>;</div></pre></td></tr></table></figure>\n<p>ByteBuffer实际上还提供了 <code>get(byte[] dst, int offset, int length)</code>这样的接口，其内部实现也是循环调用了get()方法。</p>\n<p>get和put可以是相对的或者是绝对的。</p>\n<p>相对方案是不带有索引参数的函数。当相对函数被调用时，位置在返回时前进一。</p>\n<p>绝对存取不会影响缓冲区的位置属性(Position、Limit、Capacity、Mark)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">buffer.put((<span class=\"keyword\">byte</span>)<span class=\"string\">'h'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'e'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'l'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'l'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'o'</span>);</div><div class=\"line\">print(buffer, bs);</div><div class=\"line\">buffer.put(<span class=\"number\">0</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'y'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'y'</span>);</div><div class=\"line\">print(buffer, bs);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//观察Buffer底层存储情况</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(Buffer buffer, <span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(buffer.toString());</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; bs.length; i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (bs[i] != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">char</span> c = (<span class=\"keyword\">char</span>)bs[i];</div><div class=\"line\">\t\t\t\tSystem.out.print(c);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">\"$\"</span>);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"\"</span>);</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.HeapByteBuffer[pos=5 lim=10 cap=10]</div><div class=\"line\">hello$$$$$</div><div class=\"line\">java.nio.HeapByteBuffer[pos=6 lim=10 cap=10]</div><div class=\"line\">yelloy$$$$</div></pre></td></tr></table></figure>\n<p>可以看到，存入5个字节之后，position增加为5，limit与capacity不变。<br>调用buffer.put(0, (byte)’y’)，将bs[0]的数据改写为(byte)’y’，position并没有改变。</p>\n<ul>\n<li><strong>Buffer.flip()</strong></li>\n</ul>\n<p>我们想要将刚刚写入的数据读出的话应该怎么做？应该将position设为0：buffer.position(0)，就可以从正确的位置开始获取数据。但是它是怎样知道何时到达我们所插入数据末端的呢？这就是边界属性被引入的目的。边界属性指明了缓冲区有效内容的末端。我们需要将limit设置为当前位置：buffer.limit(buffer.position())。</p>\n<p><code>buffer.limit(buffer.position()).position(0);</code></p>\n<p>Buffer已经提供了一个方法封装了这些操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">flip</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        limit = position;</div><div class=\"line\">        position = <span class=\"number\">0</span>;</div><div class=\"line\">        mark = -<span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">buffer.flip();</div><div class=\"line\">print(buffer, bs);</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.HeapByteBuffer[pos=0 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div></pre></td></tr></table></figure>\n<p>调用buffer.flip()后，limit设置为当前position值，position重置为0.</p>\n<ul>\n<li><strong>Buffer.rewind()</strong></li>\n</ul>\n<p>紧接着上面的程序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">System.out.println((<span class=\"keyword\">char</span>)buffer.get());</div><div class=\"line\">System.out.println((<span class=\"keyword\">char</span>)buffer.get(<span class=\"number\">3</span>));</div><div class=\"line\">print(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">buffer.rewind();</div><div class=\"line\">print(buffer, bs);</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">y</div><div class=\"line\">l</div><div class=\"line\">java.nio.HeapByteBuffer[pos=1 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div><div class=\"line\">java.nio.HeapByteBuffer[pos=0 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div></pre></td></tr></table></figure>\n<p>可以看到，rewind()方法与filp()相似，但是不影响limit，他只是将position设为0，这样就可以从新读取已经读过的数据了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">rewind</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        position = <span class=\"number\">0</span>;</div><div class=\"line\">        mark = -<span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>Buffer.mark()、Buffer.reset()</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">mark</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        mark = position;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">reset</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> m = mark;</div><div class=\"line\">        <span class=\"keyword\">if</span> (m &lt; <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvalidMarkException();</div><div class=\"line\">        position = m;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Buffer.mark(),使缓冲区能够记住一个位置并在之后将其返回。</p>\n<p>缓冲区的标记在mark()函数被调用之前是未定义的，调用时标记被设为当前位置的值。reset()函数将位置设为当前的标记值。如果标记值未定义，调用reset()将导致InvalidMarkException异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">buffer.position(<span class=\"number\">2</span>);</div><div class=\"line\">buffer.mark();</div><div class=\"line\">print(buffer, bs);</div><div class=\"line\">buffer.position(<span class=\"number\">4</span>);</div><div class=\"line\">print(buffer, bs);</div><div class=\"line\">buffer.reset();</div><div class=\"line\">print(buffer, bs);</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.HeapByteBuffer[pos=2 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div><div class=\"line\">java.nio.HeapByteBuffer[pos=4 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div><div class=\"line\">java.nio.HeapByteBuffer[pos=2 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>Buffer.remaining()、Buffer.hasRemaining()</strong></li>\n</ul>\n<p>remaining()函数将返回从当前位置到上界还剩余的元素数目。</p>\n<p>hasRemaining()会返回是否已经达到缓冲区的边界。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">remaining</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> limit - position;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasRemaining</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> position &lt; limit;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有两种方法读取缓冲区的所有剩余数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 第一种</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; buffer.hasRemaining(), i++) &#123;</div><div class=\"line\">    myByteArray [i] = buffer.get();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第二种</span></div><div class=\"line\"><span class=\"keyword\">int</span> count = buffer.remaining();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count, i++) &#123;</div><div class=\"line\">    myByteArray [i] = buffer.get();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>Buffer.clear()</strong></li>\n</ul>\n<p>clear()函数将缓冲区重置为空状态。它并不改变缓冲区中的任何数据元素，而是仅仅将上界设为容量的值，并把位置设回 0。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        position = <span class=\"number\">0</span>;</div><div class=\"line\">        limit = capacity;</div><div class=\"line\">        mark = -<span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>ByteBuffer.compact()</strong></li>\n</ul>\n<p>compact()方法并不是Buffer接口中定义的，而是属于ByteBuffer。</p>\n<p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用compact()方法。</p>\n<p>compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(buffer, bs);</div><div class=\"line\">System.out.println(buffer.remaining());</div><div class=\"line\">buffer.compact();</div><div class=\"line\">print(buffer, bs);</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.HeapByteBuffer[pos=2 lim=6 cap=10]</div><div class=\"line\">yelloy$$$$</div><div class=\"line\">4</div><div class=\"line\">java.nio.HeapByteBuffer[pos=4 lim=10 cap=10]</div><div class=\"line\">lloyoy$$$$</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>ByteBuffer.equals()、ByteBuffer.compareTo()</strong></li>\n</ul>\n<p>可以使用equals()和compareTo()方法两个Buffer。</p>\n<p>下面提到的剩余元素是从 position到limit之间的元素。</p>\n<p><strong>equals()</strong></p>\n<p>当满足下列条件时，表示两个Buffer相等：</p>\n<p>有相同的类型（byte、char、int等）。</p>\n<p>Buffer中剩余的byte、char等的个数相等。</p>\n<p>Buffer中所有剩余的byte、char等都相同。</p>\n<p>在每个缓冲区中应被get()函数返回的剩余数据元素序列必须一致。</p>\n<p>equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。</p>\n<p><strong>compareTo()</strong></p>\n<p>compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p>\n<p>第一个不相等的元素小于另一个Buffer中对应的元素 。</p>\n<p>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</p>\n<h2 id=\"只读缓冲区\"><a href=\"#只读缓冲区\" class=\"headerlink\" title=\"只读缓冲区\"></a>只读缓冲区</h2><p>可以使用asReadOnlyBuffer()函数来生成一个只读的缓冲区视图。</p>\n<p>这个新的缓冲区不允许使用put()，并且其isReadOnly()函数将会返回true。对这一只读缓冲区的put()函数的调用尝试会导致抛出ReadOnlyBufferException异常。</p>\n<p>两个缓冲区共享数据元素，拥有同样的容量，但每个缓冲区拥有各自的位置，上界和标记属性。对一个缓冲区内的数据元素所做的改变会反映在另外一个缓冲区上。</p>\n<h2 id=\"复制缓冲区\"><a href=\"#复制缓冲区\" class=\"headerlink\" title=\"复制缓冲区\"></a>复制缓冲区</h2><p>duplicate()函数创建了一个与原始缓冲区相似的新缓冲区。两个缓冲区共享数据元素，拥有同样的容量，但每个缓冲区拥有各自的位置，上界和标记属性。对一个缓冲区内的数据元素所做的改变会反映在另外一个缓冲区上。这一副本缓冲区具有与原始缓冲区同样的数据视图。如果原始的缓冲区为只读，或者为直接缓冲区，新的缓冲区将继承这些属性。</p>\n<p>复制一个缓冲区会创建一个新的Buffer对象，但并不复制数据。原始缓冲区和副本都会操作同样的数据元素。</p>\n<h2 id=\"直接缓冲区\"><a href=\"#直接缓冲区\" class=\"headerlink\" title=\"直接缓冲区\"></a>直接缓冲区</h2><p>直接ByteBuffer是通过调用ByteBuffer.allocateDirect(int capacity)函数来创建的。</p>\n<p>什么是直接缓冲区(DirectByteBuffer)呢？直接缓冲区意味着所分配的这段内存是堆外内存，而我们通过ByteBuffer.allocate(int capacity)或者ByteBuffer.wrap(byte[] array)分配的内存是堆内存，其返回的实例为HeapByteBuffer，HeapByteBuffer中持有一个byte数组，这个数组所占有的内存是堆内内存。</p>\n<p><a href=\"http://calvin1978.blogcn.com/articles/directbytebuffer.html\">Netty之Java堆外内存扫盲贴</a>了解java堆外内存。</p>\n<p>sun.nio.ch.FileChannelImpl.read(ByteBuffer dst)</p>\n<img src=\"/2017/06/28/java-NIO-Buffer/1.png\" alt=\"sun.nio.ch.FileChannelImpl.read\" title=\"sun.nio.ch.FileChannelImpl.read\">\n<p>sun.nio.ch.IOUtil.read(FileDescriptor fd, ByteBuffer dst, long position,NativeDispatcher nd, Object lock)</p>\n<img src=\"/2017/06/28/java-NIO-Buffer/2.png\" alt=\"sun.nio.ch.IOUtil.read\" title=\"sun.nio.ch.IOUtil.read\">\n<p>观察上面两段代码发现，我们通过一个文件通道去填充一个ByteBuffer时，先执行<code>sun.nio.ch.FileChannelImpl.read(ByteBuffer dst)</code>方法，其中调用了<code>sun.nio.ch.IOUtil.read(FileDescriptor fd, ByteBuffer dst, long position,NativeDispatcher nd, Object lock)</code>方法，观察这个方法，发现其中会做一个判断：如果是直接缓冲区(DirectBuffer)，直接调用<code>readIntoNativeBuffer(fd, dst, position, nd, lock)</code>并返回；如果是非直接缓冲区(HeapByteBuffer)，先获取一个直接缓冲区，然后使用该直接缓冲区作为参数调用<code>readIntoNativeBuffer(fd, dst, position, nd, lock)</code>，然后将填充完毕的DirectBuffer的内容复制到HeapByteBuffer当中，然后返回。</p>\n<p>直接缓冲区的内存分配调用了sun.misc.Unsafe.allocateMemory(size),返回了内存基地址，实际上就是malloc。</p>\n<p>看一下<a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html\">java doc</a>对DirectBuffer的说明：</p>\n<blockquote>\n<p>A byte buffer is either direct or non-direct. Given a direct byte buffer, the Java virtual machine will make a best effort to perform native I/O operations directly upon it. That is, it will attempt to avoid copying the buffer’s content to (or from) an intermediate buffer before (or after) each invocation of one of the underlying operating system’s native I/O operations.</p>\n</blockquote>\n<p>给定一个直接字节缓冲区，Java 虚拟机将尽最大努力直接对它执行本机 I/O 操作。也就是说，它会在每一次调用底层操作系统的本机 I/O 操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据)。</p>\n<p>结合上面的代码，就可以理解这段话的含义。</p>\n<p>那么，为什么需要直接缓冲区，也就是堆外内存来执行IO呢？</p>\n<p>以读操作为例，数据从底层硬件读到内核缓冲区之后，操作系统会从内核空间复制数据到用户空间，此时的用户进程空间就是jvm，这意味着 I/O 操作的目标内存区域必须是连续的字节序列。在 Java 中，数组是对象，在 JVM 中，字节数组可能不会在内存中连续存储。因此，这个连续的字节序列就是直接缓冲区中分配的内存空间。需要直接缓冲区来当一个中间人，完成数据的写入或者读取。</p>\n<p>其实，在传统BIO中，也是这么做的，同样需要一个堆外内存来充当这个中间人：比如FileInputStream.read(byte b[], int off, int len):</p>\n<p>FileInputStream.read(byte b[], int off, int len)调用了readBytes(byte b[], int off, int len)方法，这个方法是一个本地方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">JNIEXPORT jint JNICALL  </div><div class=\"line\"><span class=\"title\">Java_java_io_FileInputStream_readBytes</span><span class=\"params\">(JNIEnv *env, jobject <span class=\"keyword\">this</span>,  </div><div class=\"line\">        jbyteArray bytes, jint off, jint len)</span> </span>&#123;<span class=\"comment\">//除了前两个参数，后三个就是readBytes方法传递进来的，字节数组、起始位置、长度三个参数  </span></div><div class=\"line\"><span class=\"keyword\">return</span> readBytes(env, <span class=\"keyword\">this</span>, bytes, off, len, fis_fd);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">jint</div><div class=\"line\"><span class=\"title\">readBytes</span><span class=\"params\">(JNIEnv *env, jobject <span class=\"keyword\">this</span>, jbyteArray bytes,</div><div class=\"line\">          jint off, jint len, jfieldID fid)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    jint nread;</div><div class=\"line\">    <span class=\"keyword\">char</span> stackBuf[BUF_SIZE];</div><div class=\"line\">    <span class=\"keyword\">char</span> *buf = NULL;</div><div class=\"line\">    FD fd;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (IS_NULL(bytes)) &#123;</div><div class=\"line\">        JNU_ThrowNullPointerException(env, NULL);</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (outOfBounds(env, off, len, bytes)) &#123;</div><div class=\"line\">        JNU_ThrowByName(env, <span class=\"string\">\"java/lang/IndexOutOfBoundsException\"</span>, NULL);</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len &gt; BUF_SIZE) &#123;</div><div class=\"line\">        buf = malloc(len);<span class=\"comment\">// buf的分配</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (buf == NULL) &#123;</div><div class=\"line\">            JNU_ThrowOutOfMemoryError(env, NULL);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        buf = stackBuf;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    fd = GET_FD(<span class=\"keyword\">this</span>, fid);</div><div class=\"line\">    <span class=\"keyword\">if</span> (fd == -<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        JNU_ThrowIOException(env, <span class=\"string\">\"Stream Closed\"</span>);</div><div class=\"line\">        nread = -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        nread = IO_Read(fd, buf, len);<span class=\"comment\">// buf是使用malloc分配的直接缓冲区，也就是堆外内存</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (nread &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            (*env)-&gt;SetByteArrayRegion(env, bytes, off, nread, (jbyte *)buf);<span class=\"comment\">// 将直接缓冲区的内容copy到bytes数组中</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nread == JVM_IO_ERR) &#123;</div><div class=\"line\">            JNU_ThrowIOExceptionWithLastError(env, <span class=\"string\">\"Read error\"</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nread == JVM_IO_INTR) &#123;</div><div class=\"line\">            JNU_ThrowByName(env, <span class=\"string\">\"java/io/InterruptedIOException\"</span>, NULL);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* EOF */</span></div><div class=\"line\">            nread = -<span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (buf != stackBuf) &#123;</div><div class=\"line\">        free(buf);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> nread;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这个方法其实最关键的就是IO_Read这个宏定义的处理，而IO_Read其实只是代表了一个方法名称叫handleRead，我们去看一下handleRead的源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">JNIEXPORT  </div><div class=\"line\">size_t  </div><div class=\"line\"><span class=\"title\">handleRead</span><span class=\"params\">(jlong fd, <span class=\"keyword\">void</span> *buf, jint len)</span>  </div><div class=\"line\"></span>&#123;  </div><div class=\"line\">    DWORD read = <span class=\"number\">0</span>;  </div><div class=\"line\">    BOOL result = <span class=\"number\">0</span>;  </div><div class=\"line\">    HANDLE h = (HANDLE)fd;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (h == INVALID_HANDLE_VALUE) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    result = ReadFile(h,          </div><div class=\"line\">                      buf,       </div><div class=\"line\">                      len,       </div><div class=\"line\">                      &amp;read,      </div><div class=\"line\">                      NULL);     </div><div class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> error = GetLastError();  </div><div class=\"line\">        <span class=\"keyword\">if</span> (error == ERROR_BROKEN_PIPE) &#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> read;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过上面的代码可以发现，传统的BIO也是把操作系统返回的数据放到直接缓冲区当中，然后在copy回我们传入的byte数组当中。</p>\n<p>所有的缓冲区都提供了一个叫做isDirect()的boolean函数，来测试特定缓冲区是否为直接缓冲区。</p>\n<blockquote>\n<p>A direct byte buffer may be created by invoking the allocateDirect factory method of this class. The buffers returned by this method typically have somewhat higher allocation and deallocation costs than non-direct buffers. The contents of direct buffers may reside outside of the normal garbage-collected heap, and so their impact upon the memory footprint of an application might not be obvious. It is therefore recommended that direct buffers be allocated primarily for large, long-lived buffers that are subject to the underlying system’s native I/O operations. In general it is best to allocate direct buffers only when they yield a measureable gain in program performance.</p>\n</blockquote>\n<p>直接缓冲区虽然避免了复制内存带来的消耗，但直接缓冲区使用的内存是通过调用本地操作系统方面的代码分配的，绕过了标准 JVM 堆栈。建立和销毁直接缓冲区会明显比具有堆栈的缓冲区更加破费，并且可能带来不易察觉的内存泄漏，或oom问题。所以，如果对于性能要求不是很严格，一般情况下，使用非直接缓冲区就足够了。</p>\n<h2 id=\"缓冲区分片\"><a href=\"#缓冲区分片\" class=\"headerlink\" title=\"缓冲区分片\"></a>缓冲区分片</h2><p>slice() 方法根据现有的缓冲区创建一种 子缓冲区 。也就是说，它创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据。</p>\n<p>现在我们对这个缓冲区 分片 ，以创建一个包含槽 3 到槽 6 的子缓冲区。在某种意义上，子缓冲区就像原来的缓冲区中的一个 窗口。</p>\n<p>窗口的起始和结束位置通过设置 position 和 limit 值来指定，然后调用 Buffer 的 slice() 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(buffer, bs);</div><div class=\"line\">buffer.position( <span class=\"number\">3</span> ).limit( <span class=\"number\">7</span> );</div><div class=\"line\">ByteBuffer slice = buffer.slice();</div><div class=\"line\">print(slice, slice.array());</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.HeapByteBuffer[pos=4 lim=10 cap=10]</div><div class=\"line\">lloyoy$$$$</div><div class=\"line\">java.nio.HeapByteBuffer[pos=0 lim=4 cap=4]</div><div class=\"line\">lloyoy$$$$</div></pre></td></tr></table></figure>\n<p>slice 是缓冲区的 子缓冲区 。不过， slice 和 buffer 共享同一个底层数据数组。</p>\n<h2 id=\"类型视图缓冲区\"><a href=\"#类型视图缓冲区\" class=\"headerlink\" title=\"类型视图缓冲区\"></a>类型视图缓冲区</h2><p>我们知道，Buffer可以作为通道执行IO的源头或者目标，但是通道只接受ByteBuffer类型的参数。比如read(ByteBuffer dst)。</p>\n<p>我们在进行IO操作时，可能会使用各种ByteBuffer类去读取文件内容，接收来自网络连接的数据使用各种ByteBuffer类去读取文件内容，接收来自网络连接的数据等。一旦数据到达了您的 ByteBuffer，我们需要对他进行一些操作。ByteBuffer类允许创建视图来将byte型缓冲区字节数据映射为其它的原始数据类型。例如，asLongBuffer()函数创建一个将八个字节型数据当成一个 long 型数据来存取的视图缓冲区。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ByteBuffer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Buffer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 这里仅列出部分API</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> CharBuffer <span class=\"title\">asCharBuffer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ShortBuffer <span class=\"title\">asShortBuffer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> IntBuffer <span class=\"title\">asIntBuffer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> LongBuffer <span class=\"title\">asLongBuffer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> FloatBuffer <span class=\"title\">asFloatBuffer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> DoubleBuffer <span class=\"title\">asDoubleBuffer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">buffer.clear();</div><div class=\"line\">buffer.order(ByteOrder.BIG_ENDIAN);<span class=\"comment\">//指定字节序</span></div><div class=\"line\">buffer.put (<span class=\"number\">0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">buffer.put (<span class=\"number\">1</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'H'</span>);</div><div class=\"line\">buffer.put (<span class=\"number\">2</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">buffer.put (<span class=\"number\">3</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'i'</span>);</div><div class=\"line\">buffer.put (<span class=\"number\">4</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">buffer.put (<span class=\"number\">5</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'!'</span>);</div><div class=\"line\">buffer.put (<span class=\"number\">6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">CharBuffer charBuffer = buffer.asCharBuffer();</div><div class=\"line\">System.out.println(<span class=\"string\">\"pos=\"</span> + charBuffer.position() + <span class=\"string\">\" limit=\"</span> + charBuffer.limit() + <span class=\"string\">\" cap=\"</span> + charBuffer.capacity());;</div><div class=\"line\">print(charBuffer, bs);</div></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pos=0 limit=5 cap=5</div><div class=\"line\">Hi!   </div><div class=\"line\">$H$i$!$$$$</div></pre></td></tr></table></figure>\n<p>新的缓冲区的容量是字节缓冲区中存在的元素数量除以视图类型中组成一个数据类型的字节数。视图缓冲区的第一个元素从创建它的ByteBuffer对象的位置开始(positon()函数的返回值)。</p>\n<img src=\"/2017/06/28/java-NIO-Buffer/3.png\" alt=\"类型长度\" title=\"类型长度\">\n<h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><p>前面提到的测试代码汇总：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.nio.Buffer;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteOrder;</div><div class=\"line\"><span class=\"keyword\">import</span> java.nio.CharBuffer;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">byte</span>[] bs = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10</span>];</div><div class=\"line\">\t\tByteBuffer buffer = ByteBuffer.wrap(bs);</div><div class=\"line\">\t\tSystem.out.println(buffer.toString());</div><div class=\"line\">\t\t<span class=\"comment\">// put</span></div><div class=\"line\">\t\tbuffer.put((<span class=\"keyword\">byte</span>)<span class=\"string\">'h'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'e'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'l'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'l'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'o'</span>);</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\tbuffer.put(<span class=\"number\">0</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'y'</span>).put((<span class=\"keyword\">byte</span>)<span class=\"string\">'y'</span>);</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">//flip</span></div><div class=\"line\">\t\tbuffer.flip();</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">// rewind</span></div><div class=\"line\">\t\tSystem.out.println((<span class=\"keyword\">char</span>)buffer.get());</div><div class=\"line\">\t\tSystem.out.println((<span class=\"keyword\">char</span>)buffer.get(<span class=\"number\">3</span>));</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tbuffer.rewind();</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">// mark reset</span></div><div class=\"line\">\t\tbuffer.position(<span class=\"number\">2</span>);</div><div class=\"line\">\t\tbuffer.mark();</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\tbuffer.position(<span class=\"number\">4</span>);</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\tbuffer.reset();</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">// compact</span></div><div class=\"line\">\t\tSystem.out.println(buffer.remaining());</div><div class=\"line\">\t\tbuffer.compact();</div><div class=\"line\">\t\tprint(buffer, bs);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">// slice</span></div><div class=\"line\">\t\tbuffer.position( <span class=\"number\">3</span> ).limit( <span class=\"number\">7</span> );</div><div class=\"line\">\t\tByteBuffer slice = buffer.slice();</div><div class=\"line\">\t\tprint(slice, slice.array());</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">// asCharBuffer</span></div><div class=\"line\">\t\tbuffer.clear();</div><div class=\"line\">\t\tbuffer.order(ByteOrder.BIG_ENDIAN);</div><div class=\"line\">\t\tbuffer.put (<span class=\"number\">0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">        buffer.put (<span class=\"number\">1</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'H'</span>);</div><div class=\"line\">        buffer.put (<span class=\"number\">2</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">        buffer.put (<span class=\"number\">3</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'i'</span>);</div><div class=\"line\">        buffer.put (<span class=\"number\">4</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">        buffer.put (<span class=\"number\">5</span>, (<span class=\"keyword\">byte</span>)<span class=\"string\">'!'</span>);</div><div class=\"line\">        buffer.put (<span class=\"number\">6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0</span>);</div><div class=\"line\">\t\tCharBuffer charBuffer = buffer.asCharBuffer();</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"pos=\"</span> + charBuffer.position() + <span class=\"string\">\" limit=\"</span> + charBuffer.limit() + <span class=\"string\">\" cap=\"</span> + charBuffer.capacity());;</div><div class=\"line\">\t\tprint(charBuffer, bs);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(Buffer buffer, <span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(buffer.toString());</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; bs.length; i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (bs[i] != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">char</span> c = (<span class=\"keyword\">char</span>)bs[i];</div><div class=\"line\">\t\t\t\tSystem.out.print(c);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">\"$\"</span>);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.ksmpartners.com/2013/07/why-is-traditional-java-io-uninterruptable/\">Why is Traditional Java I/O Uninterruptable?</a></p>\n<p><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9974525\">JNI探秘—–FileInputStream的read方法详解</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html\">NIO 入门</a></p>\n<p><a href=\"http://tutorials.jenkov.com/java-nio/buffers.html\">Java NIO Buffer</a></p>"},{"layout":"post","title":"通过HashMap认识equals与hashcode","date":"2016-04-28T04:48:55.000Z","_content":"\n>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。\n\n## 什么是hashcode,hashcode的作用是什么\n\nhashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。\n\n理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，根据hashcode可以找到记录的位置。\n\n按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。\n\nhashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。\n\n注：以下代码均来自jdk1.7\n\nString中hashCode()方法的实现：\n\n```java\npublic int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            char val[] = value;\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n}\n```\n<!-- more -->\n## 什么是equals(Object obj)方法\n\nequals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：\n\n```java\npublic boolean equals(Object obj) {\n        return (this == obj);\n}\n```\n\n也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。\n\n这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。\n\nString中equals(Object obj)方法的实现：\n\n```java\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String) anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                            return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n}\n```\n\n## 在java中hashcode方法与equals方法的作用\n\n首先看一下HashMap中的put方法：\n\n```java\npublic V put(K key, V value) {\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n        if (key == null)\n            return putForNullKey(value);\n        int hash = hash(key);//得到hash值\n        int i = indexFor(hash, table.length);//找到槽\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n\n        modCount++;\n        addEntry(hash, key, value, i);\n        return null;\n    }\n\n```\n\n我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。\n\n首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：\n\n```java\nfinal int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n可以看到，这个方法里调用了key本身的hashCode方法，得到了key的hashcode，然后对该hashcode进行了一些移位操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，通过他可以找到记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？\n\n其实这样做的目的是为下面的函数做准备的，我们看接下来要执行的代码：\n\n`int i = indexFor(hash, table.length);`找到所谓的槽，也就是记录存在的位置。\n\n```\n/**\n  * Returns index for hash code h.\n  */\nstatic int indexFor(int h, int length) {\n     // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";\n    return h & (length-1);\n}\n```\n可以看到，indexFor(int h, int length)如何通过hashcode得到记录的位置。indexFor方法内部是一个取模运算，h是我们通过上面的hash方法得到的，length是散列表的长度。HashMap中的散列表是一个数组，通过取模运算能保证indexFor方法的返回值(记录的位置)一定在这个数组内，没有超过其长度。因为h往往是一个很大的数字(int可以表示40亿这么大的数字)，而散列表的初始长度是可以由我们指定的(默认是16),另一方面，就算给他这么大的数组，内存也是放不下的。所以取模运算是必须的。经过取模运算得到的才是真正的槽值。\n\n回到上一个问题，**为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？而不是直接使用key的hashcode的**？\n\n想明白这个问题，参考[JDK 源码中 HashMap 的 hash 方法原理是什么？](https://www.zhihu.com/question/20733617)。我们上面也说了这样做的目的是为indexFor方法做准备的，总的来说就是为了让取模运算不会出现一种极端情况：**大量的不同的h经过取模后返回同样的槽值**。这样会带来严重的性能问题，也就是严重的冲突情况导致性能下降。关于冲突，看下文。\n\n要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。\n\n散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？\n\n比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？也就是说，无限多的元素通过散列函数映射到有穷集合上，一定会产生冲突。这也是我们理解hashcode的一个重要的点：**不同的对象(equals返回false)可以有相同的hashcode**。\n\n那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：\n\n{% asset_img entry.png 冲突 %}\n\n其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3....为散列表的索引位置。\n\n接下来的代码  `for (Entry<K,V> e = table[i]; e != null; e = e.next)`就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：`addEntry(hash, key, value, i);`.\n\n那么，怎么判断两个关键码在逻辑上是否相同呢？\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`\n\n可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：·`e.hash == hash `。为什么要加这样的判断？回头看看indexFor方法，经过取模运算后，不同的hashcode可以被散列在同一个槽中。通过这句代码可以将那些因为取模运算散列到同一个槽里的不同对象排除。\n\n我们知道**不同的对象(equals返回false)可以有相同的hashcode**。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：**相同的对象(equals返回true)hashcode一定相等**。\n\n`e.hash == hash && ((k = e.key) == key`：这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断**关键码是否相等**，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。\n\n`key.equals(k)`：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`这句代码中其实包含了一种短路思想，\\|\\| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。\n\n至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。\n\n## 总结\n\n通过上面的分析，我们知道了hashcode与equals的几个关键：\n\n#### 1.**不同的对象(equals返回false)可以有相同的hashcode**\n\n#### 2.**相同的对象(equals返回true)hashcode一定相等**\n\n#### 3.**若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义**（对1、2的遵守）\n\n[关于如何重写equals方法与hashCode方法](http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java)\n\n## equals与==\n\n\"==\" 比较的是两个对象的内存地址，是物理意义上的相等\n\nequals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等\n\n两个对象进行比较：\n\n**== 返回true，则equals一定返回true**；\n\n**equals返回true，== 不一定返回true**。\n\n\n\n\n\n\n\n","source":"_posts/java中的equals与hashcode.md","raw":"---\nlayout: post\ntitle:  \"通过HashMap认识equals与hashcode\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-28 12:48:55\n---\n\n>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。\n\n## 什么是hashcode,hashcode的作用是什么\n\nhashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。\n\n理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，根据hashcode可以找到记录的位置。\n\n按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。\n\nhashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。\n\n注：以下代码均来自jdk1.7\n\nString中hashCode()方法的实现：\n\n```java\npublic int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            char val[] = value;\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n}\n```\n<!-- more -->\n## 什么是equals(Object obj)方法\n\nequals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：\n\n```java\npublic boolean equals(Object obj) {\n        return (this == obj);\n}\n```\n\n也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。\n\n这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。\n\nString中equals(Object obj)方法的实现：\n\n```java\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String) anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                            return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n}\n```\n\n## 在java中hashcode方法与equals方法的作用\n\n首先看一下HashMap中的put方法：\n\n```java\npublic V put(K key, V value) {\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n        if (key == null)\n            return putForNullKey(value);\n        int hash = hash(key);//得到hash值\n        int i = indexFor(hash, table.length);//找到槽\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n\n        modCount++;\n        addEntry(hash, key, value, i);\n        return null;\n    }\n\n```\n\n我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。\n\n首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：\n\n```java\nfinal int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n可以看到，这个方法里调用了key本身的hashCode方法，得到了key的hashcode，然后对该hashcode进行了一些移位操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，通过他可以找到记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？\n\n其实这样做的目的是为下面的函数做准备的，我们看接下来要执行的代码：\n\n`int i = indexFor(hash, table.length);`找到所谓的槽，也就是记录存在的位置。\n\n```\n/**\n  * Returns index for hash code h.\n  */\nstatic int indexFor(int h, int length) {\n     // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";\n    return h & (length-1);\n}\n```\n可以看到，indexFor(int h, int length)如何通过hashcode得到记录的位置。indexFor方法内部是一个取模运算，h是我们通过上面的hash方法得到的，length是散列表的长度。HashMap中的散列表是一个数组，通过取模运算能保证indexFor方法的返回值(记录的位置)一定在这个数组内，没有超过其长度。因为h往往是一个很大的数字(int可以表示40亿这么大的数字)，而散列表的初始长度是可以由我们指定的(默认是16),另一方面，就算给他这么大的数组，内存也是放不下的。所以取模运算是必须的。经过取模运算得到的才是真正的槽值。\n\n回到上一个问题，**为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？而不是直接使用key的hashcode的**？\n\n想明白这个问题，参考[JDK 源码中 HashMap 的 hash 方法原理是什么？](https://www.zhihu.com/question/20733617)。我们上面也说了这样做的目的是为indexFor方法做准备的，总的来说就是为了让取模运算不会出现一种极端情况：**大量的不同的h经过取模后返回同样的槽值**。这样会带来严重的性能问题，也就是严重的冲突情况导致性能下降。关于冲突，看下文。\n\n要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。\n\n散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？\n\n比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？也就是说，无限多的元素通过散列函数映射到有穷集合上，一定会产生冲突。这也是我们理解hashcode的一个重要的点：**不同的对象(equals返回false)可以有相同的hashcode**。\n\n那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：\n\n{% asset_img entry.png 冲突 %}\n\n其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3....为散列表的索引位置。\n\n接下来的代码  `for (Entry<K,V> e = table[i]; e != null; e = e.next)`就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：`addEntry(hash, key, value, i);`.\n\n那么，怎么判断两个关键码在逻辑上是否相同呢？\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`\n\n可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：·`e.hash == hash `。为什么要加这样的判断？回头看看indexFor方法，经过取模运算后，不同的hashcode可以被散列在同一个槽中。通过这句代码可以将那些因为取模运算散列到同一个槽里的不同对象排除。\n\n我们知道**不同的对象(equals返回false)可以有相同的hashcode**。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：**相同的对象(equals返回true)hashcode一定相等**。\n\n`e.hash == hash && ((k = e.key) == key`：这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断**关键码是否相等**，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。\n\n`key.equals(k)`：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`这句代码中其实包含了一种短路思想，\\|\\| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。\n\n至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。\n\n## 总结\n\n通过上面的分析，我们知道了hashcode与equals的几个关键：\n\n#### 1.**不同的对象(equals返回false)可以有相同的hashcode**\n\n#### 2.**相同的对象(equals返回true)hashcode一定相等**\n\n#### 3.**若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义**（对1、2的遵守）\n\n[关于如何重写equals方法与hashCode方法](http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java)\n\n## equals与==\n\n\"==\" 比较的是两个对象的内存地址，是物理意义上的相等\n\nequals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等\n\n两个对象进行比较：\n\n**== 返回true，则equals一定返回true**；\n\n**equals返回true，== 不一定返回true**。\n\n\n\n\n\n\n\n","slug":"java中的equals与hashcode","published":1,"updated":"2017-04-11T13:08:38.838Z","comments":1,"photos":[],"link":"","_id":"cj4vch4dt0012x3gciy0ynjrz","content":"<blockquote>\n<p>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。</p>\n</blockquote>\n<h2 id=\"什么是hashcode-hashcode的作用是什么\"><a href=\"#什么是hashcode-hashcode的作用是什么\" class=\"headerlink\" title=\"什么是hashcode,hashcode的作用是什么\"></a>什么是hashcode,hashcode的作用是什么</h2><p>hashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。</p>\n<p>理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，根据hashcode可以找到记录的位置。</p>\n<p>按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。</p>\n<p>hashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。</p>\n<p>注：以下代码均来自jdk1.7</p>\n<p>String中hashCode()方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hash;</div><div class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">char</span> val[] = value;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</div><div class=\"line\">                h = <span class=\"number\">31</span> * h + val[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            hash = h;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> h;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"什么是equals-Object-obj-方法\"><a href=\"#什么是equals-Object-obj-方法\" class=\"headerlink\" title=\"什么是equals(Object obj)方法\"></a>什么是equals(Object obj)方法</h2><p>equals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。</p>\n<p>这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。</p>\n<p>String中equals(Object obj)方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            String anotherString = (String) anObject;</div><div class=\"line\">            <span class=\"keyword\">int</span> n = value.length;</div><div class=\"line\">            <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> v1[] = value;</div><div class=\"line\">                <span class=\"keyword\">char</span> v2[] = anotherString.value;</div><div class=\"line\">                <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (v1[i] != v2[i])</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                    i++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"在java中hashcode方法与equals方法的作用\"><a href=\"#在java中hashcode方法与equals方法的作用\" class=\"headerlink\" title=\"在java中hashcode方法与equals方法的作用\"></a>在java中hashcode方法与equals方法的作用</h2><p>首先看一下HashMap中的put方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</div><div class=\"line\">            inflateTable(threshold);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> putForNullKey(value);</div><div class=\"line\">        <span class=\"keyword\">int</span> hash = hash(key);<span class=\"comment\">//得到hash值</span></div><div class=\"line\">        <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//找到槽</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\">            Object k;</div><div class=\"line\">            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class=\"line\">                V oldValue = e.value;</div><div class=\"line\">                e.value = value;</div><div class=\"line\">                e.recordAccess(<span class=\"keyword\">this</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        modCount++;</div><div class=\"line\">        addEntry(hash, key, value, i);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。</p>\n<p>首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hashSeed;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != h &amp;&amp; k <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        h ^= k.hashCode();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></div><div class=\"line\">        <span class=\"comment\">// constant multiples at each bit position have a bounded</span></div><div class=\"line\">        <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></div><div class=\"line\">        h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这个方法里调用了key本身的hashCode方法，得到了key的hashcode，然后对该hashcode进行了一些移位操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，通过他可以找到记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？</p>\n<p>其实这样做的目的是为下面的函数做准备的，我们看接下来要执行的代码：</p>\n<p><code>int i = indexFor(hash, table.length);</code>找到所谓的槽，也就是记录存在的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">  * Returns index for hash code h.</div><div class=\"line\">  */</div><div class=\"line\">static int indexFor(int h, int length) &#123;</div><div class=\"line\">     // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</div><div class=\"line\">    return h &amp; (length-1);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，indexFor(int h, int length)如何通过hashcode得到记录的位置。indexFor方法内部是一个取模运算，h是我们通过上面的hash方法得到的，length是散列表的长度。HashMap中的散列表是一个数组，通过取模运算能保证indexFor方法的返回值(记录的位置)一定在这个数组内，没有超过其长度。因为h往往是一个很大的数字(int可以表示40亿这么大的数字)，而散列表的初始长度是可以由我们指定的(默认是16),另一方面，就算给他这么大的数组，内存也是放不下的。所以取模运算是必须的。经过取模运算得到的才是真正的槽值。</p>\n<p>回到上一个问题，<strong>为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？而不是直接使用key的hashcode的</strong>？</p>\n<p>想明白这个问题，参考<a href=\"https://www.zhihu.com/question/20733617\" target=\"_blank\" rel=\"external\">JDK 源码中 HashMap 的 hash 方法原理是什么？</a>。我们上面也说了这样做的目的是为indexFor方法做准备的，总的来说就是为了让取模运算不会出现一种极端情况：<strong>大量的不同的h经过取模后返回同样的槽值</strong>。这样会带来严重的性能问题，也就是严重的冲突情况导致性能下降。关于冲突，看下文。</p>\n<p>要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。</p>\n<p>散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？</p>\n<p>比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？也就是说，无限多的元素通过散列函数映射到有穷集合上，一定会产生冲突。这也是我们理解hashcode的一个重要的点：<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。</p>\n<p>那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：</p>\n<img src=\"/2016/04/28/java中的equals与hashcode/entry.png\" alt=\"冲突\" title=\"冲突\">\n<p>其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3….为散列表的索引位置。</p>\n<p>接下来的代码  <code>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next)</code>就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：<code>addEntry(hash, key, value, i);</code>.</p>\n<p>那么，怎么判断两个关键码在逻辑上是否相同呢？</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code></p>\n<p>可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：·<code>e.hash == hash</code>。为什么要加这样的判断？回头看看indexFor方法，经过取模运算后，不同的hashcode可以被散列在同一个槽中。通过这句代码可以将那些因为取模运算散列到同一个槽里的不同对象排除。</p>\n<p>我们知道<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：<strong>相同的对象(equals返回true)hashcode一定相等</strong>。</p>\n<p><code>e.hash == hash &amp;&amp; ((k = e.key) == key</code>：这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断<strong>关键码是否相等</strong>，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。</p>\n<p><code>key.equals(k)</code>：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>这句代码中其实包含了一种短路思想，|| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。</p>\n<p>至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面的分析，我们知道了hashcode与equals的几个关键：</p>\n<h4 id=\"1-不同的对象-equals返回false-可以有相同的hashcode\"><a href=\"#1-不同的对象-equals返回false-可以有相同的hashcode\" class=\"headerlink\" title=\"1.不同的对象(equals返回false)可以有相同的hashcode\"></a>1.<strong>不同的对象(equals返回false)可以有相同的hashcode</strong></h4><h4 id=\"2-相同的对象-equals返回true-hashcode一定相等\"><a href=\"#2-相同的对象-equals返回true-hashcode一定相等\" class=\"headerlink\" title=\"2.相同的对象(equals返回true)hashcode一定相等\"></a>2.<strong>相同的对象(equals返回true)hashcode一定相等</strong></h4><h4 id=\"3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"><a href=\"#3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\" class=\"headerlink\" title=\"3.若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"></a>3.<strong>若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义</strong>（对1、2的遵守）</h4><p><a href=\"http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java\" target=\"_blank\" rel=\"external\">关于如何重写equals方法与hashCode方法</a></p>\n<h2 id=\"equals与\"><a href=\"#equals与\" class=\"headerlink\" title=\"equals与==\"></a>equals与==</h2><p>“==” 比较的是两个对象的内存地址，是物理意义上的相等</p>\n<p>equals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等</p>\n<p>两个对象进行比较：</p>\n<p><strong>== 返回true，则equals一定返回true</strong>；</p>\n<p><strong>equals返回true，== 不一定返回true</strong>。</p>\n","excerpt":"<blockquote>\n<p>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。</p>\n</blockquote>\n<h2 id=\"什么是hashcode-hashcode的作用是什么\"><a href=\"#什么是hashcode-hashcode的作用是什么\" class=\"headerlink\" title=\"什么是hashcode,hashcode的作用是什么\"></a>什么是hashcode,hashcode的作用是什么</h2><p>hashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。</p>\n<p>理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，根据hashcode可以找到记录的位置。</p>\n<p>按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。</p>\n<p>hashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。</p>\n<p>注：以下代码均来自jdk1.7</p>\n<p>String中hashCode()方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hash;</div><div class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">char</span> val[] = value;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</div><div class=\"line\">                h = <span class=\"number\">31</span> * h + val[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            hash = h;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> h;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<h2 id=\"什么是equals-Object-obj-方法\"><a href=\"#什么是equals-Object-obj-方法\" class=\"headerlink\" title=\"什么是equals(Object obj)方法\"></a>什么是equals(Object obj)方法</h2><p>equals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。</p>\n<p>这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。</p>\n<p>String中equals(Object obj)方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            String anotherString = (String) anObject;</div><div class=\"line\">            <span class=\"keyword\">int</span> n = value.length;</div><div class=\"line\">            <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> v1[] = value;</div><div class=\"line\">                <span class=\"keyword\">char</span> v2[] = anotherString.value;</div><div class=\"line\">                <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (v1[i] != v2[i])</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                    i++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"在java中hashcode方法与equals方法的作用\"><a href=\"#在java中hashcode方法与equals方法的作用\" class=\"headerlink\" title=\"在java中hashcode方法与equals方法的作用\"></a>在java中hashcode方法与equals方法的作用</h2><p>首先看一下HashMap中的put方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</div><div class=\"line\">            inflateTable(threshold);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> putForNullKey(value);</div><div class=\"line\">        <span class=\"keyword\">int</span> hash = hash(key);<span class=\"comment\">//得到hash值</span></div><div class=\"line\">        <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//找到槽</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\">            Object k;</div><div class=\"line\">            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class=\"line\">                V oldValue = e.value;</div><div class=\"line\">                e.value = value;</div><div class=\"line\">                e.recordAccess(<span class=\"keyword\">this</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        modCount++;</div><div class=\"line\">        addEntry(hash, key, value, i);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。</p>\n<p>首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hashSeed;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != h &amp;&amp; k <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        h ^= k.hashCode();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></div><div class=\"line\">        <span class=\"comment\">// constant multiples at each bit position have a bounded</span></div><div class=\"line\">        <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></div><div class=\"line\">        h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这个方法里调用了key本身的hashCode方法，得到了key的hashcode，然后对该hashcode进行了一些移位操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，通过他可以找到记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？</p>\n<p>其实这样做的目的是为下面的函数做准备的，我们看接下来要执行的代码：</p>\n<p><code>int i = indexFor(hash, table.length);</code>找到所谓的槽，也就是记录存在的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">  * Returns index for hash code h.</div><div class=\"line\">  */</div><div class=\"line\">static int indexFor(int h, int length) &#123;</div><div class=\"line\">     // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</div><div class=\"line\">    return h &amp; (length-1);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，indexFor(int h, int length)如何通过hashcode得到记录的位置。indexFor方法内部是一个取模运算，h是我们通过上面的hash方法得到的，length是散列表的长度。HashMap中的散列表是一个数组，通过取模运算能保证indexFor方法的返回值(记录的位置)一定在这个数组内，没有超过其长度。因为h往往是一个很大的数字(int可以表示40亿这么大的数字)，而散列表的初始长度是可以由我们指定的(默认是16),另一方面，就算给他这么大的数组，内存也是放不下的。所以取模运算是必须的。经过取模运算得到的才是真正的槽值。</p>\n<p>回到上一个问题，<strong>为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？而不是直接使用key的hashcode的</strong>？</p>\n<p>想明白这个问题，参考<a href=\"https://www.zhihu.com/question/20733617\">JDK 源码中 HashMap 的 hash 方法原理是什么？</a>。我们上面也说了这样做的目的是为indexFor方法做准备的，总的来说就是为了让取模运算不会出现一种极端情况：<strong>大量的不同的h经过取模后返回同样的槽值</strong>。这样会带来严重的性能问题，也就是严重的冲突情况导致性能下降。关于冲突，看下文。</p>\n<p>要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。</p>\n<p>散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？</p>\n<p>比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？也就是说，无限多的元素通过散列函数映射到有穷集合上，一定会产生冲突。这也是我们理解hashcode的一个重要的点：<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。</p>\n<p>那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：</p>\n<img src=\"/2016/04/28/java中的equals与hashcode/entry.png\" alt=\"冲突\" title=\"冲突\">\n<p>其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3….为散列表的索引位置。</p>\n<p>接下来的代码  <code>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next)</code>就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：<code>addEntry(hash, key, value, i);</code>.</p>\n<p>那么，怎么判断两个关键码在逻辑上是否相同呢？</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code></p>\n<p>可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：·<code>e.hash == hash</code>。为什么要加这样的判断？回头看看indexFor方法，经过取模运算后，不同的hashcode可以被散列在同一个槽中。通过这句代码可以将那些因为取模运算散列到同一个槽里的不同对象排除。</p>\n<p>我们知道<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：<strong>相同的对象(equals返回true)hashcode一定相等</strong>。</p>\n<p><code>e.hash == hash &amp;&amp; ((k = e.key) == key</code>：这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断<strong>关键码是否相等</strong>，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。</p>\n<p><code>key.equals(k)</code>：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>这句代码中其实包含了一种短路思想，|| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。</p>\n<p>至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面的分析，我们知道了hashcode与equals的几个关键：</p>\n<h4 id=\"1-不同的对象-equals返回false-可以有相同的hashcode\"><a href=\"#1-不同的对象-equals返回false-可以有相同的hashcode\" class=\"headerlink\" title=\"1.不同的对象(equals返回false)可以有相同的hashcode\"></a>1.<strong>不同的对象(equals返回false)可以有相同的hashcode</strong></h4><h4 id=\"2-相同的对象-equals返回true-hashcode一定相等\"><a href=\"#2-相同的对象-equals返回true-hashcode一定相等\" class=\"headerlink\" title=\"2.相同的对象(equals返回true)hashcode一定相等\"></a>2.<strong>相同的对象(equals返回true)hashcode一定相等</strong></h4><h4 id=\"3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"><a href=\"#3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\" class=\"headerlink\" title=\"3.若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"></a>3.<strong>若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义</strong>（对1、2的遵守）</h4><p><a href=\"http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java\">关于如何重写equals方法与hashCode方法</a></p>\n<h2 id=\"equals与\"><a href=\"#equals与\" class=\"headerlink\" title=\"equals与==\"></a>equals与==</h2><p>“==” 比较的是两个对象的内存地址，是物理意义上的相等</p>\n<p>equals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等</p>\n<p>两个对象进行比较：</p>\n<p><strong>== 返回true，则equals一定返回true</strong>；</p>\n<p><strong>equals返回true，== 不一定返回true</strong>。</p>"},{"layout":"post","title":"java 中的int/byte转换","date":"2016-11-24T14:48:55.000Z","_content":"\n## 前言\n\n好久没有动博客了，看了下，将近两个月了吧。最近的两个月里面变懒了，没有了记录的动力。。。最近好像也没啥收获，惭愧。之前电脑中病毒之后(cryptolcker)，还好没有神马重要的东西，索性把硬盘重新格式化一遍，重做了系统。保留一套windows（实在受不了win10的自动更新了...）,又装了一套opensuse的系统。希望可以坚持学点linux。\n\n这段时间没有怎么看书，说一下读书情况。《重构》这本还是没有看完，读了大半。《深入理解jvm虚拟机》这本算是大致上浏览了一遍，发现确实是一本挺好的java书籍，日后还需多加翻阅理解。《大话设计模式》也是浏览了一遍，其中比较常见的模式有时候也可以用到，需要的时候再看吧。双十一买了一本《java并发编程实战》，看了大半，似懂非懂，但也是有收获的。不得不吐槽一下该书的翻译，实在是不敢恭维，但是想想自己的英语水平，目前还是忍了。。\n\n必须要振作起精神来了，总觉得自己每天无所事事呢。接下来的计划.....还是把并发编程这块看完吧，虽然没有什么实战的机会，总比不看强。要多写总结了，不然看了跟不看差不多。异常、反射、动态代理、注解等等这些也要学习然后做一个记录。网络、io、并发这三块，并发还在看，也要做好记录，然后网络这部分把大学课本重读一遍，至于io不知道有什么好的书籍，放到最后规划学习把。\n\n嗯，又想起来最近还写了一个自动打卡的程序，增加了短信通知的功能。总觉得有些不诚信的感觉呢，但是没有迟到早退过呀，好玩罢了。读了webmagic的core部分的源码，感觉理解起来轻松许多。记得大学那会看这个的时候还是一头雾水，结果现在两个小时就把代码搞清楚了（主要是代码量也不大拉）。嗯，说明自己还是在进步的麻，哈哈哈。下载了junit的源码都没有看过，有空研究把。\n\n终于要进入正题了。这次的记录很短很简单，是关于java中int和byte之间的转换的。虽然简单，但是以前就是拿来即用，没有搞清楚其中的原理，在byte这块就很纠结（只能说基础比较差），今天来学习一下。\n\n--------------------------------------------------\n\n## 正文\n\njava中:\n\nbyte: 1字节    int: 4字节\n\n```java\nint i = -123\nbyte x = (byte)i; //-123\n```\nps：([]代表几进制，()代表前面的内容重复几次)\n\nps:\n\n-123[2] = 11111111(3)10000101\n\nint 强转为 byte，直接截取低8位即10000101\n\njava把byte当做有符号处理，故此时x=-123\n\n```java\nint j = (int)x; //-123\n```\nps:\n\nbyte强转为int，高24位补1(自动扩展)\n\n此时，j[2]=11111111(3)11101010\n\n即，j=-123\n\n负数似乎没有问题...\n\n--------------------------------------------------\n```java\nint i = 234;\nbyte x = (byte)i; //-22\n```\nps:\n\n234[2] = 00000000(3)11101010\n\nint 强转为 byte，直接截取低8位即11101010\n\njava把byte当做有符号处理，故此时x=-22\n\n```java\nint j = (int)x; //-22\n```\nps:\n\nbyte强转为int，高24位补1（自动扩展）\n\n此时，j[2]=11111111(3)11101010\n\n即，j=-22\n\n可见，byte单纯的强转为int是行不通的。(注意，示例中int强转为一个byte,如果int值超过255,发生数据丢失，正确的int转为4字节byte方法见下文)\n\n--------------------------------------------------\n```java\nint i = 234;\nbyte x = (byte)i; //-22\nint j = x & 0xFF; //j=234\n```\nps:\n\nx & 0xFF = 00000000(3)11101010\n\n即，j=234\n\n可见0xFF的作用...\n\n--------------------------------------------------\n\n- http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/\n\nbyte short char 他们三者在计算时，首先会转换为int类型,故下面几个表达式进行|运算时，是int类型之间的|运算，存在自动扩展(移位操作也会出现这种情况,即int转byte的时候),不进行& 0xFF的运算，则有可能造成第一种情况的出现。\n\n- java字节序\n\njava为大端字节序（bigendian）：高字节数据存放在低地址处，低字节数据存放在高地址处。\n\n0x01020304\n\n故b[0]=0x01,b[1]=0x02,b[2]=0x03,b[3]=0x04\n\n```java\n//byte 数组与 int 的相互转换  \npublic static int byteArrayToInt(byte[] b) {  \n    return   b[3] & 0xFF |  \n            (b[2] & 0xFF) << 8 |  \n            (b[1] & 0xFF) << 16 |  \n            (b[0] & 0xFF) << 24;  \n}  \n  \npublic static byte[] intToByteArray(int a) {  \n    return new byte[] {  \n        (byte) ((a >> 24) & 0xFF),  \n        (byte) ((a >> 16) & 0xFF),     \n        (byte) ((a >> 8) & 0xFF),     \n        (byte) (a & 0xFF)  \n    };  \n}  \n```\n","source":"_posts/java中的int\\byte互转.md","raw":"---\nlayout: post\ntitle:  \"java 中的int/byte转换\"\ncategories: 编程\ntags: \n- java\ndate:   2016-11-24 22:48:55\n---\n\n## 前言\n\n好久没有动博客了，看了下，将近两个月了吧。最近的两个月里面变懒了，没有了记录的动力。。。最近好像也没啥收获，惭愧。之前电脑中病毒之后(cryptolcker)，还好没有神马重要的东西，索性把硬盘重新格式化一遍，重做了系统。保留一套windows（实在受不了win10的自动更新了...）,又装了一套opensuse的系统。希望可以坚持学点linux。\n\n这段时间没有怎么看书，说一下读书情况。《重构》这本还是没有看完，读了大半。《深入理解jvm虚拟机》这本算是大致上浏览了一遍，发现确实是一本挺好的java书籍，日后还需多加翻阅理解。《大话设计模式》也是浏览了一遍，其中比较常见的模式有时候也可以用到，需要的时候再看吧。双十一买了一本《java并发编程实战》，看了大半，似懂非懂，但也是有收获的。不得不吐槽一下该书的翻译，实在是不敢恭维，但是想想自己的英语水平，目前还是忍了。。\n\n必须要振作起精神来了，总觉得自己每天无所事事呢。接下来的计划.....还是把并发编程这块看完吧，虽然没有什么实战的机会，总比不看强。要多写总结了，不然看了跟不看差不多。异常、反射、动态代理、注解等等这些也要学习然后做一个记录。网络、io、并发这三块，并发还在看，也要做好记录，然后网络这部分把大学课本重读一遍，至于io不知道有什么好的书籍，放到最后规划学习把。\n\n嗯，又想起来最近还写了一个自动打卡的程序，增加了短信通知的功能。总觉得有些不诚信的感觉呢，但是没有迟到早退过呀，好玩罢了。读了webmagic的core部分的源码，感觉理解起来轻松许多。记得大学那会看这个的时候还是一头雾水，结果现在两个小时就把代码搞清楚了（主要是代码量也不大拉）。嗯，说明自己还是在进步的麻，哈哈哈。下载了junit的源码都没有看过，有空研究把。\n\n终于要进入正题了。这次的记录很短很简单，是关于java中int和byte之间的转换的。虽然简单，但是以前就是拿来即用，没有搞清楚其中的原理，在byte这块就很纠结（只能说基础比较差），今天来学习一下。\n\n--------------------------------------------------\n\n## 正文\n\njava中:\n\nbyte: 1字节    int: 4字节\n\n```java\nint i = -123\nbyte x = (byte)i; //-123\n```\nps：([]代表几进制，()代表前面的内容重复几次)\n\nps:\n\n-123[2] = 11111111(3)10000101\n\nint 强转为 byte，直接截取低8位即10000101\n\njava把byte当做有符号处理，故此时x=-123\n\n```java\nint j = (int)x; //-123\n```\nps:\n\nbyte强转为int，高24位补1(自动扩展)\n\n此时，j[2]=11111111(3)11101010\n\n即，j=-123\n\n负数似乎没有问题...\n\n--------------------------------------------------\n```java\nint i = 234;\nbyte x = (byte)i; //-22\n```\nps:\n\n234[2] = 00000000(3)11101010\n\nint 强转为 byte，直接截取低8位即11101010\n\njava把byte当做有符号处理，故此时x=-22\n\n```java\nint j = (int)x; //-22\n```\nps:\n\nbyte强转为int，高24位补1（自动扩展）\n\n此时，j[2]=11111111(3)11101010\n\n即，j=-22\n\n可见，byte单纯的强转为int是行不通的。(注意，示例中int强转为一个byte,如果int值超过255,发生数据丢失，正确的int转为4字节byte方法见下文)\n\n--------------------------------------------------\n```java\nint i = 234;\nbyte x = (byte)i; //-22\nint j = x & 0xFF; //j=234\n```\nps:\n\nx & 0xFF = 00000000(3)11101010\n\n即，j=234\n\n可见0xFF的作用...\n\n--------------------------------------------------\n\n- http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/\n\nbyte short char 他们三者在计算时，首先会转换为int类型,故下面几个表达式进行|运算时，是int类型之间的|运算，存在自动扩展(移位操作也会出现这种情况,即int转byte的时候),不进行& 0xFF的运算，则有可能造成第一种情况的出现。\n\n- java字节序\n\njava为大端字节序（bigendian）：高字节数据存放在低地址处，低字节数据存放在高地址处。\n\n0x01020304\n\n故b[0]=0x01,b[1]=0x02,b[2]=0x03,b[3]=0x04\n\n```java\n//byte 数组与 int 的相互转换  \npublic static int byteArrayToInt(byte[] b) {  \n    return   b[3] & 0xFF |  \n            (b[2] & 0xFF) << 8 |  \n            (b[1] & 0xFF) << 16 |  \n            (b[0] & 0xFF) << 24;  \n}  \n  \npublic static byte[] intToByteArray(int a) {  \n    return new byte[] {  \n        (byte) ((a >> 24) & 0xFF),  \n        (byte) ((a >> 16) & 0xFF),     \n        (byte) ((a >> 8) & 0xFF),     \n        (byte) (a & 0xFF)  \n    };  \n}  \n```\n","slug":"java中的int\\byte互转","published":1,"updated":"2017-04-11T13:08:38.838Z","comments":1,"photos":[],"link":"","_id":"cj4vch4dx0016x3gc2gritirj","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>好久没有动博客了，看了下，将近两个月了吧。最近的两个月里面变懒了，没有了记录的动力。。。最近好像也没啥收获，惭愧。之前电脑中病毒之后(cryptolcker)，还好没有神马重要的东西，索性把硬盘重新格式化一遍，重做了系统。保留一套windows（实在受不了win10的自动更新了…）,又装了一套opensuse的系统。希望可以坚持学点linux。</p>\n<p>这段时间没有怎么看书，说一下读书情况。《重构》这本还是没有看完，读了大半。《深入理解jvm虚拟机》这本算是大致上浏览了一遍，发现确实是一本挺好的java书籍，日后还需多加翻阅理解。《大话设计模式》也是浏览了一遍，其中比较常见的模式有时候也可以用到，需要的时候再看吧。双十一买了一本《java并发编程实战》，看了大半，似懂非懂，但也是有收获的。不得不吐槽一下该书的翻译，实在是不敢恭维，但是想想自己的英语水平，目前还是忍了。。</p>\n<p>必须要振作起精神来了，总觉得自己每天无所事事呢。接下来的计划…..还是把并发编程这块看完吧，虽然没有什么实战的机会，总比不看强。要多写总结了，不然看了跟不看差不多。异常、反射、动态代理、注解等等这些也要学习然后做一个记录。网络、io、并发这三块，并发还在看，也要做好记录，然后网络这部分把大学课本重读一遍，至于io不知道有什么好的书籍，放到最后规划学习把。</p>\n<p>嗯，又想起来最近还写了一个自动打卡的程序，增加了短信通知的功能。总觉得有些不诚信的感觉呢，但是没有迟到早退过呀，好玩罢了。读了webmagic的core部分的源码，感觉理解起来轻松许多。记得大学那会看这个的时候还是一头雾水，结果现在两个小时就把代码搞清楚了（主要是代码量也不大拉）。嗯，说明自己还是在进步的麻，哈哈哈。下载了junit的源码都没有看过，有空研究把。</p>\n<p>终于要进入正题了。这次的记录很短很简单，是关于java中int和byte之间的转换的。虽然简单，但是以前就是拿来即用，没有搞清楚其中的原理，在byte这块就很纠结（只能说基础比较差），今天来学习一下。</p>\n<hr>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>java中:</p>\n<p>byte: 1字节    int: 4字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = -<span class=\"number\">123</span></div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-123</span></div></pre></td></tr></table></figure>\n<p>ps：([]代表几进制，()代表前面的内容重复几次)</p>\n<p>ps:</p>\n<p>-123[2] = 11111111(3)10000101</p>\n<p>int 强转为 byte，直接截取低8位即10000101</p>\n<p>java把byte当做有符号处理，故此时x=-123</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j = (<span class=\"keyword\">int</span>)x; <span class=\"comment\">//-123</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>byte强转为int，高24位补1(自动扩展)</p>\n<p>此时，j[2]=11111111(3)11101010</p>\n<p>即，j=-123</p>\n<p>负数似乎没有问题…</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">234</span>;</div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-22</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>234[2] = 00000000(3)11101010</p>\n<p>int 强转为 byte，直接截取低8位即11101010</p>\n<p>java把byte当做有符号处理，故此时x=-22</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j = (<span class=\"keyword\">int</span>)x; <span class=\"comment\">//-22</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>byte强转为int，高24位补1（自动扩展）</p>\n<p>此时，j[2]=11111111(3)11101010</p>\n<p>即，j=-22</p>\n<p>可见，byte单纯的强转为int是行不通的。(注意，示例中int强转为一个byte,如果int值超过255,发生数据丢失，正确的int转为4字节byte方法见下文)</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">234</span>;</div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-22</span></div><div class=\"line\"><span class=\"keyword\">int</span> j = x &amp; <span class=\"number\">0xFF</span>; <span class=\"comment\">//j=234</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>x &amp; 0xFF = 00000000(3)11101010</p>\n<p>即，j=234</p>\n<p>可见0xFF的作用…</p>\n<hr>\n<ul>\n<li><a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/\">http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</a></li>\n</ul>\n<p>byte short char 他们三者在计算时，首先会转换为int类型,故下面几个表达式进行|运算时，是int类型之间的|运算，存在自动扩展(移位操作也会出现这种情况,即int转byte的时候),不进行&amp; 0xFF的运算，则有可能造成第一种情况的出现。</p>\n<ul>\n<li>java字节序</li>\n</ul>\n<p>java为大端字节序（bigendian）：高字节数据存放在低地址处，低字节数据存放在高地址处。</p>\n<p>0x01020304</p>\n<p>故b[0]=0x01,b[1]=0x02,b[2]=0x03,b[3]=0x04</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//byte 数组与 int 的相互转换  </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">byteArrayToInt</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span>   b[<span class=\"number\">3</span>] &amp; <span class=\"number\">0xFF</span> |  </div><div class=\"line\">            (b[<span class=\"number\">2</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">8</span> |  </div><div class=\"line\">            (b[<span class=\"number\">1</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">16</span> |  </div><div class=\"line\">            (b[<span class=\"number\">0</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">24</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] intToByteArray(<span class=\"keyword\">int</span> a) &#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[] &#123;  </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">24</span>) &amp; <span class=\"number\">0xFF</span>),  </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>),     </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xFF</span>),     </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) (a &amp; <span class=\"number\">0xFF</span>)  </div><div class=\"line\">    &#125;;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>好久没有动博客了，看了下，将近两个月了吧。最近的两个月里面变懒了，没有了记录的动力。。。最近好像也没啥收获，惭愧。之前电脑中病毒之后(cryptolcker)，还好没有神马重要的东西，索性把硬盘重新格式化一遍，重做了系统。保留一套windows（实在受不了win10的自动更新了…）,又装了一套opensuse的系统。希望可以坚持学点linux。</p>\n<p>这段时间没有怎么看书，说一下读书情况。《重构》这本还是没有看完，读了大半。《深入理解jvm虚拟机》这本算是大致上浏览了一遍，发现确实是一本挺好的java书籍，日后还需多加翻阅理解。《大话设计模式》也是浏览了一遍，其中比较常见的模式有时候也可以用到，需要的时候再看吧。双十一买了一本《java并发编程实战》，看了大半，似懂非懂，但也是有收获的。不得不吐槽一下该书的翻译，实在是不敢恭维，但是想想自己的英语水平，目前还是忍了。。</p>\n<p>必须要振作起精神来了，总觉得自己每天无所事事呢。接下来的计划…..还是把并发编程这块看完吧，虽然没有什么实战的机会，总比不看强。要多写总结了，不然看了跟不看差不多。异常、反射、动态代理、注解等等这些也要学习然后做一个记录。网络、io、并发这三块，并发还在看，也要做好记录，然后网络这部分把大学课本重读一遍，至于io不知道有什么好的书籍，放到最后规划学习把。</p>\n<p>嗯，又想起来最近还写了一个自动打卡的程序，增加了短信通知的功能。总觉得有些不诚信的感觉呢，但是没有迟到早退过呀，好玩罢了。读了webmagic的core部分的源码，感觉理解起来轻松许多。记得大学那会看这个的时候还是一头雾水，结果现在两个小时就把代码搞清楚了（主要是代码量也不大拉）。嗯，说明自己还是在进步的麻，哈哈哈。下载了junit的源码都没有看过，有空研究把。</p>\n<p>终于要进入正题了。这次的记录很短很简单，是关于java中int和byte之间的转换的。虽然简单，但是以前就是拿来即用，没有搞清楚其中的原理，在byte这块就很纠结（只能说基础比较差），今天来学习一下。</p>\n<hr>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>java中:</p>\n<p>byte: 1字节    int: 4字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = -<span class=\"number\">123</span></div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-123</span></div></pre></td></tr></table></figure>\n<p>ps：([]代表几进制，()代表前面的内容重复几次)</p>\n<p>ps:</p>\n<p>-123[2] = 11111111(3)10000101</p>\n<p>int 强转为 byte，直接截取低8位即10000101</p>\n<p>java把byte当做有符号处理，故此时x=-123</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j = (<span class=\"keyword\">int</span>)x; <span class=\"comment\">//-123</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>byte强转为int，高24位补1(自动扩展)</p>\n<p>此时，j[2]=11111111(3)11101010</p>\n<p>即，j=-123</p>\n<p>负数似乎没有问题…</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">234</span>;</div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-22</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>234[2] = 00000000(3)11101010</p>\n<p>int 强转为 byte，直接截取低8位即11101010</p>\n<p>java把byte当做有符号处理，故此时x=-22</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j = (<span class=\"keyword\">int</span>)x; <span class=\"comment\">//-22</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>byte强转为int，高24位补1（自动扩展）</p>\n<p>此时，j[2]=11111111(3)11101010</p>\n<p>即，j=-22</p>\n<p>可见，byte单纯的强转为int是行不通的。(注意，示例中int强转为一个byte,如果int值超过255,发生数据丢失，正确的int转为4字节byte方法见下文)</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">234</span>;</div><div class=\"line\"><span class=\"keyword\">byte</span> x = (<span class=\"keyword\">byte</span>)i; <span class=\"comment\">//-22</span></div><div class=\"line\"><span class=\"keyword\">int</span> j = x &amp; <span class=\"number\">0xFF</span>; <span class=\"comment\">//j=234</span></div></pre></td></tr></table></figure>\n<p>ps:</p>\n<p>x &amp; 0xFF = 00000000(3)11101010</p>\n<p>即，j=234</p>\n<p>可见0xFF的作用…</p>\n<hr>\n<ul>\n<li><a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/\">http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</a></li>\n</ul>\n<p>byte short char 他们三者在计算时，首先会转换为int类型,故下面几个表达式进行|运算时，是int类型之间的|运算，存在自动扩展(移位操作也会出现这种情况,即int转byte的时候),不进行&amp; 0xFF的运算，则有可能造成第一种情况的出现。</p>\n<ul>\n<li>java字节序</li>\n</ul>\n<p>java为大端字节序（bigendian）：高字节数据存放在低地址处，低字节数据存放在高地址处。</p>\n<p>0x01020304</p>\n<p>故b[0]=0x01,b[1]=0x02,b[2]=0x03,b[3]=0x04</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//byte 数组与 int 的相互转换  </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">byteArrayToInt</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span>   b[<span class=\"number\">3</span>] &amp; <span class=\"number\">0xFF</span> |  </div><div class=\"line\">            (b[<span class=\"number\">2</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">8</span> |  </div><div class=\"line\">            (b[<span class=\"number\">1</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">16</span> |  </div><div class=\"line\">            (b[<span class=\"number\">0</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">24</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] intToByteArray(<span class=\"keyword\">int</span> a) &#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[] &#123;  </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">24</span>) &amp; <span class=\"number\">0xFF</span>),  </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xFF</span>),     </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) ((a &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xFF</span>),     </div><div class=\"line\">        (<span class=\"keyword\">byte</span>) (a &amp; <span class=\"number\">0xFF</span>)  </div><div class=\"line\">    &#125;;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"java中的枚举","date":"2016-06-30T04:48:55.000Z","_content":"\n> 已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。\n\nJava中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。\n  \n## 使用场景：\n\n每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。\n\n## 与 public static final 的常量定义方式进行比较：\n\n在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：\n\n```java\npublic class State {\n\tpublic static final int Normal = 0;//正常\n\tpublic static final int Update = 1;//已更新\n\tpublic static final int Delete = 2;//已删除\n}\n```\n<!-- more -->\n使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：\n\n```java\npublic void doSomething(int state){\n\tswitch(state){\n\t\tcase State.Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Update:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n1. 在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。\n\n2. 另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。\n\n3. 因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。\n\n那如果换成枚举常量呢？\n\n```java\npublic enum State {\n\tNormal,Update,Delete\n}\n```\n\n类型安全检查：\n\n```java\npublic void doSomething(State state){\n\tswitch(state){\n\t\tcase Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase Update:\n\t\t  ...\n\t\t  break;\n\t\tcase Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。\n\n另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。\n\n## 枚举类型的使用\n\n- **常量**：\n\n```java\npublic enum State{\n\tNormal,Update,Delete\n}\n```\n\n遍历枚举常量：\n\n```java\n   for(State state:State.values()){\n   \t\tSystem.out.println(state);\n   }\n```\n\n- **自定义属性、方法**：\n\n```java\npublic enum State{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }    \n}\n\npublic void test(){\n\tfor (State state : State.values()) {\n\t    //输出：正常:0 已更新:1 已删除:2\n\t\tSystem.out.println(state);\n\t}\n}\n```\n\n实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。\n其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。\n\n因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。\n\n- **实现接口**\n\n```java\npublic interface HandleState{\n\tvoid printState();\n}\n\npublic enum State implements HandleState{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }  \n\n    public void printState() {\n\t\tSystem.out.println(this);\n\t}\n}\n```\n\n可以看到，枚举和一般的类一样都可以实现接口。\n\n- **Enum 相关工具类**\n\nJDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。\n\n## 参考\n\n[java enum的用法详解[转]](https://hacpai.com/article/1437056657634)\n\n[Java 语言中Enum类型的使用介绍](https://www.ibm.com/developerworks/cn/java/j-lo-enum/)","source":"_posts/java中的枚举.md","raw":"---\nlayout: post\ntitle:  \"java中的枚举\"\ncategories: 编程\ntags: \n- java\ndate:   2016-06-30 12:48:55\n---\n\n> 已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。\n\nJava中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。\n  \n## 使用场景：\n\n每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。\n\n## 与 public static final 的常量定义方式进行比较：\n\n在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：\n\n```java\npublic class State {\n\tpublic static final int Normal = 0;//正常\n\tpublic static final int Update = 1;//已更新\n\tpublic static final int Delete = 2;//已删除\n}\n```\n<!-- more -->\n使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：\n\n```java\npublic void doSomething(int state){\n\tswitch(state){\n\t\tcase State.Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Update:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n1. 在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。\n\n2. 另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。\n\n3. 因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。\n\n那如果换成枚举常量呢？\n\n```java\npublic enum State {\n\tNormal,Update,Delete\n}\n```\n\n类型安全检查：\n\n```java\npublic void doSomething(State state){\n\tswitch(state){\n\t\tcase Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase Update:\n\t\t  ...\n\t\t  break;\n\t\tcase Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。\n\n另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。\n\n## 枚举类型的使用\n\n- **常量**：\n\n```java\npublic enum State{\n\tNormal,Update,Delete\n}\n```\n\n遍历枚举常量：\n\n```java\n   for(State state:State.values()){\n   \t\tSystem.out.println(state);\n   }\n```\n\n- **自定义属性、方法**：\n\n```java\npublic enum State{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }    \n}\n\npublic void test(){\n\tfor (State state : State.values()) {\n\t    //输出：正常:0 已更新:1 已删除:2\n\t\tSystem.out.println(state);\n\t}\n}\n```\n\n实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。\n其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。\n\n因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。\n\n- **实现接口**\n\n```java\npublic interface HandleState{\n\tvoid printState();\n}\n\npublic enum State implements HandleState{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }  \n\n    public void printState() {\n\t\tSystem.out.println(this);\n\t}\n}\n```\n\n可以看到，枚举和一般的类一样都可以实现接口。\n\n- **Enum 相关工具类**\n\nJDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。\n\n## 参考\n\n[java enum的用法详解[转]](https://hacpai.com/article/1437056657634)\n\n[Java 语言中Enum类型的使用介绍](https://www.ibm.com/developerworks/cn/java/j-lo-enum/)","slug":"java中的枚举","published":1,"updated":"2017-04-11T13:08:38.839Z","comments":1,"photos":[],"link":"","_id":"cj4vch4e40019x3gcwabbztnf","content":"<blockquote>\n<p>已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。</p>\n</blockquote>\n<p>Java中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。</p>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><p>每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。</p>\n<h2 id=\"与-public-static-final-的常量定义方式进行比较：\"><a href=\"#与-public-static-final-的常量定义方式进行比较：\" class=\"headerlink\" title=\"与 public static final 的常量定义方式进行比较：\"></a>与 public static final 的常量定义方式进行比较：</h2><p>在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">State</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Normal = <span class=\"number\">0</span>;<span class=\"comment\">//正常</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Update = <span class=\"number\">1</span>;<span class=\"comment\">//已更新</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Delete = <span class=\"number\">2</span>;<span class=\"comment\">//已删除</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。</p>\n</li>\n<li><p>另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。</p>\n</li>\n<li><p>因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。</p>\n</li>\n</ol>\n<p>那如果换成枚举常量呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类型安全检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(State state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。</p>\n<p>另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。</p>\n<h2 id=\"枚举类型的使用\"><a href=\"#枚举类型的使用\" class=\"headerlink\" title=\"枚举类型的使用\"></a>枚举类型的使用</h2><ul>\n<li><strong>常量</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遍历枚举常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(State state:State.values())&#123;</div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>自定义属性、方法</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (State state : State.values()) &#123;</div><div class=\"line\">\t    <span class=\"comment\">//输出：正常:0 已更新:1 已删除:2</span></div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。<br>其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(“正常”,0),Update(“已更新”,1),Delete(“已删除”,2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。</p>\n<p>因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。</p>\n<ul>\n<li><strong>实现接口</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandleState</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State implements HandleState&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，枚举和一般的类一样都可以实现接口。</p>\n<ul>\n<li><strong>Enum 相关工具类</strong></li>\n</ul>\n<p>JDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://hacpai.com/article/1437056657634\" target=\"_blank\" rel=\"external\">java enum的用法详解[转]</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-enum/\" target=\"_blank\" rel=\"external\">Java 语言中Enum类型的使用介绍</a></p>\n","excerpt":"<blockquote>\n<p>已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。</p>\n</blockquote>\n<p>Java中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。</p>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><p>每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。</p>\n<h2 id=\"与-public-static-final-的常量定义方式进行比较：\"><a href=\"#与-public-static-final-的常量定义方式进行比较：\" class=\"headerlink\" title=\"与 public static final 的常量定义方式进行比较：\"></a>与 public static final 的常量定义方式进行比较：</h2><p>在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">State</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Normal = <span class=\"number\">0</span>;<span class=\"comment\">//正常</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Update = <span class=\"number\">1</span>;<span class=\"comment\">//已更新</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Delete = <span class=\"number\">2</span>;<span class=\"comment\">//已删除</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。</p>\n</li>\n<li><p>另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。</p>\n</li>\n<li><p>因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。</p>\n</li>\n</ol>\n<p>那如果换成枚举常量呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类型安全检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(State state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。</p>\n<p>另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。</p>\n<h2 id=\"枚举类型的使用\"><a href=\"#枚举类型的使用\" class=\"headerlink\" title=\"枚举类型的使用\"></a>枚举类型的使用</h2><ul>\n<li><strong>常量</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遍历枚举常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(State state:State.values())&#123;</div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>自定义属性、方法</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (State state : State.values()) &#123;</div><div class=\"line\">\t    <span class=\"comment\">//输出：正常:0 已更新:1 已删除:2</span></div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。<br>其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(“正常”,0),Update(“已更新”,1),Delete(“已删除”,2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。</p>\n<p>因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。</p>\n<ul>\n<li><strong>实现接口</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandleState</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State implements HandleState&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，枚举和一般的类一样都可以实现接口。</p>\n<ul>\n<li><strong>Enum 相关工具类</strong></li>\n</ul>\n<p>JDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://hacpai.com/article/1437056657634\">java enum的用法详解[转]</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-enum/\">Java 语言中Enum类型的使用介绍</a></p>"},{"layout":"post","title":"java中的类型转换","date":"2016-04-28T04:48:55.000Z","_content":"\n>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：\n\n## **基本类型**\n\n- **基本类型优先级**\n\n首先来看java中的基本类型有哪些：\n\nbyte：byte数据类型是一个8位有符号二进制补码整数。\n\nshort：short数据类型为16位有符号二进制补码整数。\n\nint：int数据类型是一个32位有符号二进制补码整数\n\nlong: long数据类型是一个64位二进制补码整数\n\nfloat: float数据类型是单精度、32位、符合IEEE 754标准的浮点数\n\nboolean: boolean数据类型只有两个可能的值：true和false\n\ndouble: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；\n\nchar: char数据类型是一个16位的Unicode字符\n\n基本类型优先级由低到高排序：\n\n(byte short char) int long float double\n\n其中，byte short char 平级\n\n<!-- more -->\n\n- **转换规则**\n\n1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算\n\n3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。\n\n2.byte short char 他们三者在计算时，首先会转换为int类型\n\n3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。\n\n4.boolean不能与其他类型转换\n\n\n## **类类型**\n\n类类型之间的转换有以下几个规则：\n\n1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。\n\n2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。\n\n3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。\n  \n说的比较拗口，用代码来解释吧。\n\n```java\npublic class Test {\n\n    class Father {}\n\t\n    class Son extends Father{}\n\t\n    class Daughter extends Father {}\n\n    @org.junit.Test\n    public void test(){\n        Father fatherApp;\n        Son sonApp;\n        Daughter daughterApp;\n        Father fatherIns=new Father();\n        Son sonIns=new Son();\n        Daughter daughterIns=new Daughter();\n\t\t\n        //目标类型为父类，源类型为子类，自动转换\n        fatherApp=sonIns;   \n        //源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。\n        sonApp=(Son) fatherIns;\n        //源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        \n        sonApp=(Son) fatherApp;\n        //目标类型与源类型不存在父子关系，编译无法通过\n        daughterApp=sonIns;  \n\t\t\n    }\t\n}\n```\n\n\n\n## **参考**\n\n[Java 7之基础类型第1篇 - Java数据类型](http://blog.csdn.net/mazhimazh/article/details/16799925)\n\n[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)\n\n[ Java中的类型转换](http://blog.csdn.net/darxin/article/details/5163043)\n","source":"_posts/java中的类型转换.md","raw":"---\nlayout: post\ntitle:  \"java中的类型转换\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-28 12:48:55\n---\n\n>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：\n\n## **基本类型**\n\n- **基本类型优先级**\n\n首先来看java中的基本类型有哪些：\n\nbyte：byte数据类型是一个8位有符号二进制补码整数。\n\nshort：short数据类型为16位有符号二进制补码整数。\n\nint：int数据类型是一个32位有符号二进制补码整数\n\nlong: long数据类型是一个64位二进制补码整数\n\nfloat: float数据类型是单精度、32位、符合IEEE 754标准的浮点数\n\nboolean: boolean数据类型只有两个可能的值：true和false\n\ndouble: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；\n\nchar: char数据类型是一个16位的Unicode字符\n\n基本类型优先级由低到高排序：\n\n(byte short char) int long float double\n\n其中，byte short char 平级\n\n<!-- more -->\n\n- **转换规则**\n\n1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算\n\n3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。\n\n2.byte short char 他们三者在计算时，首先会转换为int类型\n\n3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。\n\n4.boolean不能与其他类型转换\n\n\n## **类类型**\n\n类类型之间的转换有以下几个规则：\n\n1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。\n\n2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。\n\n3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。\n  \n说的比较拗口，用代码来解释吧。\n\n```java\npublic class Test {\n\n    class Father {}\n\t\n    class Son extends Father{}\n\t\n    class Daughter extends Father {}\n\n    @org.junit.Test\n    public void test(){\n        Father fatherApp;\n        Son sonApp;\n        Daughter daughterApp;\n        Father fatherIns=new Father();\n        Son sonIns=new Son();\n        Daughter daughterIns=new Daughter();\n\t\t\n        //目标类型为父类，源类型为子类，自动转换\n        fatherApp=sonIns;   \n        //源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。\n        sonApp=(Son) fatherIns;\n        //源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        \n        sonApp=(Son) fatherApp;\n        //目标类型与源类型不存在父子关系，编译无法通过\n        daughterApp=sonIns;  \n\t\t\n    }\t\n}\n```\n\n\n\n## **参考**\n\n[Java 7之基础类型第1篇 - Java数据类型](http://blog.csdn.net/mazhimazh/article/details/16799925)\n\n[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)\n\n[ Java中的类型转换](http://blog.csdn.net/darxin/article/details/5163043)\n","slug":"java中的类型转换","published":1,"updated":"2017-04-11T13:08:38.839Z","comments":1,"photos":[],"link":"","_id":"cj4vch4e6001dx3gcddwjrk2s","content":"<blockquote>\n<p>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：</p>\n</blockquote>\n<h2 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a><strong>基本类型</strong></h2><ul>\n<li><strong>基本类型优先级</strong></li>\n</ul>\n<p>首先来看java中的基本类型有哪些：</p>\n<p>byte：byte数据类型是一个8位有符号二进制补码整数。</p>\n<p>short：short数据类型为16位有符号二进制补码整数。</p>\n<p>int：int数据类型是一个32位有符号二进制补码整数</p>\n<p>long: long数据类型是一个64位二进制补码整数</p>\n<p>float: float数据类型是单精度、32位、符合IEEE 754标准的浮点数</p>\n<p>boolean: boolean数据类型只有两个可能的值：true和false</p>\n<p>double: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</p>\n<p>char: char数据类型是一个16位的Unicode字符</p>\n<p>基本类型优先级由低到高排序：</p>\n<p>(byte short char) int long float double</p>\n<p>其中，byte short char 平级</p>\n<a id=\"more\"></a>\n<ul>\n<li><strong>转换规则</strong></li>\n</ul>\n<p>1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算</p>\n<p>3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。</p>\n<p>2.byte short char 他们三者在计算时，首先会转换为int类型</p>\n<p>3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。</p>\n<p>4.boolean不能与其他类型转换</p>\n<h2 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a><strong>类类型</strong></h2><p>类类型之间的转换有以下几个规则：</p>\n<p>1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。</p>\n<p>2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。</p>\n<p>3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。</p>\n<p>说的比较拗口，用代码来解释吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@org</span>.junit.<span class=\"function\">Test</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span>&#123;</div><div class=\"line\">        Father fatherApp;</div><div class=\"line\">        Son sonApp;</div><div class=\"line\">        Daughter daughterApp;</div><div class=\"line\">        Father fatherIns=<span class=\"keyword\">new</span> Father();</div><div class=\"line\">        Son sonIns=<span class=\"keyword\">new</span> Son();</div><div class=\"line\">        Daughter daughterIns=<span class=\"keyword\">new</span> Daughter();</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\">//目标类型为父类，源类型为子类，自动转换</span></div><div class=\"line\">        fatherApp=sonIns;   </div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。</span></div><div class=\"line\">        sonApp=(Son) fatherIns;</div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        </span></div><div class=\"line\">        sonApp=(Son) fatherApp;</div><div class=\"line\">        <span class=\"comment\">//目标类型与源类型不存在父子关系，编译无法通过</span></div><div class=\"line\">        daughterApp=sonIns;  </div><div class=\"line\">\t\t</div><div class=\"line\">    &#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://blog.csdn.net/mazhimazh/article/details/16799925\" target=\"_blank\" rel=\"external\">Java 7之基础类型第1篇 - Java数据类型</a></p>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\" target=\"_blank\" rel=\"external\">The Java™ Tutorials</a></p>\n<p><a href=\"http://blog.csdn.net/darxin/article/details/5163043\" target=\"_blank\" rel=\"external\"> Java中的类型转换</a></p>\n","excerpt":"<blockquote>\n<p>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：</p>\n</blockquote>\n<h2 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a><strong>基本类型</strong></h2><ul>\n<li><strong>基本类型优先级</strong></li>\n</ul>\n<p>首先来看java中的基本类型有哪些：</p>\n<p>byte：byte数据类型是一个8位有符号二进制补码整数。</p>\n<p>short：short数据类型为16位有符号二进制补码整数。</p>\n<p>int：int数据类型是一个32位有符号二进制补码整数</p>\n<p>long: long数据类型是一个64位二进制补码整数</p>\n<p>float: float数据类型是单精度、32位、符合IEEE 754标准的浮点数</p>\n<p>boolean: boolean数据类型只有两个可能的值：true和false</p>\n<p>double: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</p>\n<p>char: char数据类型是一个16位的Unicode字符</p>\n<p>基本类型优先级由低到高排序：</p>\n<p>(byte short char) int long float double</p>\n<p>其中，byte short char 平级</p>","more":"<ul>\n<li><strong>转换规则</strong></li>\n</ul>\n<p>1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算</p>\n<p>3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。</p>\n<p>2.byte short char 他们三者在计算时，首先会转换为int类型</p>\n<p>3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。</p>\n<p>4.boolean不能与其他类型转换</p>\n<h2 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a><strong>类类型</strong></h2><p>类类型之间的转换有以下几个规则：</p>\n<p>1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。</p>\n<p>2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。</p>\n<p>3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。</p>\n<p>说的比较拗口，用代码来解释吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@org</span>.junit.<span class=\"function\">Test</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        Father fatherApp;</div><div class=\"line\">        Son sonApp;</div><div class=\"line\">        Daughter daughterApp;</div><div class=\"line\">        Father fatherIns=<span class=\"keyword\">new</span> Father();</div><div class=\"line\">        Son sonIns=<span class=\"keyword\">new</span> Son();</div><div class=\"line\">        Daughter daughterIns=<span class=\"keyword\">new</span> Daughter();</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\">//目标类型为父类，源类型为子类，自动转换</span></div><div class=\"line\">        fatherApp=sonIns;   </div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。</span></div><div class=\"line\">        sonApp=(Son) fatherIns;</div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        </span></div><div class=\"line\">        sonApp=(Son) fatherApp;</div><div class=\"line\">        <span class=\"comment\">//目标类型与源类型不存在父子关系，编译无法通过</span></div><div class=\"line\">        daughterApp=sonIns;  </div><div class=\"line\">\t\t</div><div class=\"line\">    &#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://blog.csdn.net/mazhimazh/article/details/16799925\">Java 7之基础类型第1篇 - Java数据类型</a></p>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\">The Java™ Tutorials</a></p>\n<p><a href=\"http://blog.csdn.net/darxin/article/details/5163043\"> Java中的类型转换</a></p>"},{"layout":"post","title":"java中的路径","date":"2016-12-04T11:03:00.000Z","_content":"\n>每次写java代码的时候，免不了需要加载一些外部资源，比如配置文件等等。每当需要读取这些文件时，都是去网上谷歌，写过就忘。于是今天来总结一些java中有关路径的一些用法。\n\n## 绝对路径\n\n无论是在linux还是windows中，路径都分为绝对路径和相对路径两种。\n\n绝对路径就是系统中唯一能够定位资源的某个URI，即完整的描述文件的路径就是绝对路径。比如：\n\nlinux中的绝对路径：/home/yukai/test.txt\n\nwindows中的绝对路径：E:\\yukai\\test.txt\n\n绝对路径都是以根目录起始的。\n\n## 相对路径\n\n相对路径即目标文件相对与某个基准目录的路径。比如:\n\n存在文件： \n\nA: /home/yukai/test.txt \n\nB: /home/yukai/test1.txt \n\nC: /home/yukai/test/test.txt\n\n那么：\n\n若基准目录为A, B的路径表示为\"test1.txt\"\n\n若基准目录为B, C的路径表示为\"test/test.txt\"\n\n若基准目录为C, B的路径表示为\"../test1.txt\"\n\n另外，“./”表示当前目录，“../”表示上级目录\n\n<!-- more -->\n\n## java io定位文件资源\n\n那么，我们在java中如何读取某个文件？上代码：\n\n```\n// 目录结构\nsrc\n |\n |--test\n |   |\n |   |--PathTest.java \n |\nresource\n |\n |--data.txt\n```\n\n```java\npublic class PathTest {\n\n\tpublic static String  dataFilePath = \"resource/data.txty\";\n\t\n\tpublic static String getUserDir() {\n\t\t//打印运行程序的目录，即启动java程序的目录\n\t\tString userDir = System.getProperty(\"user.dir\");\n\t\tSystem.out.println(\"运行java的工作目录 System.getProperty(\\\"user.dir\\\")： \" + userDir);\n\t\treturn userDir;\n\t}\n\t\n\tpublic static void testDataPath1() {\n\t\tString msg = \">> Path = System.getProperty(\\\"user.dir\\\") + \\\"resource/data.txt\\\"\";\n\t\tString userDir = getUserDir();\n\t\t//等同于 \"resource/data.txt\"\n\t\tString filePath = userDir + System.getProperty(\"file.separator\") + dataFilePath;\n\t\tprintFileContent(filePath ,msg);\n\t}\n\t\n\tpublic static void testDataPath2() {\n\t\tString msg = \"Path = \\\"resource/data.txt\\\"\";\n\t\tString filePath = dataFilePath;\n\t\tprintFileContent(filePath, msg);\n\t}\n\t\n\tpublic static void testDataPath3() {\n\t\tString msg = \"Path = \\\"./resource/data.txt\\\"\";\n\t\tString filePath = \"./resource/data.txt\";\n\t\tprintFileContent(filePath, msg);\n\t}\n\t\n\tprivate static void printFileContent(String filePath, String msg) {\n\t\tSystem.out.println(\"****************************\");\n\t\tSystem.out.println(msg);\n\t\tFile file = new File(filePath);\n\t\tInputStream stream;\n\t\ttry {\n\t\t\tstream = new FileInputStream(file);\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\t\tString line = null;\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tSystem.out.println(\"****************************\");\n\t\t} \n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttestDataPath1();\n\t\ttestDataPath2();\n\t\ttestDataPath3();\n\t}\n\n}\n```\n其中`testDataPath2`、`testDataPath1`、`testDataPath3`这三个方法的效果是一样的。\n\n`System.getProperty(\"user.dir\")`这个方法获取了当前的工作目录，也就是启动jvm的目录。例如：\n\nps: 更多关于System.getProperty()的介绍：[System Properties](http://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html)\n\n你的java程序位于：/home/yukai/code/test.jar \n\n若你在目录/home/yukai下使用命令 `java -cp code/test.jar test.PathTest` 启动java程序时，目录/home/yukai就是你的工作目录。\n\n在`testDataPath2`当中，直接使用\"resource/data.txty\"来作为文件读取路径时，java会默认为基准目录为当前的工作目录，\"resource/data.txty\"此时就是相对于这个基准目录的路径。\n也就是说，java会把工作目录与\"resource/data.txty\"拼接起来，作为一个绝对路径去读取文件，也就是`testDataPath1`中的例子。\n\n有Eclipse中启动你的java工程的目录就是工程根目录，工程根目录也就是工作目录，如果你读取文件的方式类似于`testDataPath2`的话，他会在工程根目录下找你的文件。\n有时候我们会遇到，在Eclipse中读取文件没有问题，但是打成jar包之后运行(像上面运行jar包的例子)就会报找不到文件的错误。那么此时就要检查你的当前工作目录下(/home/yukai)是否有这些文件的存在了。\n\n## File.getPath & File.getAbsolutePath & File.getCanonicalPath\n\n```java\npublic static void testGetPath() {\n\t\tFile file = new File(\"./resource/data.txt\");\n\t\tSystem.out.println(\"File.getPath(): \" + file.getPath());\n\t\tSystem.out.println(\"File.getAbsolutePath(): \"+ file.getAbsolutePath());\n\t\ttry {\n\t\t\tSystem.out.println(\"File.getCanonicalPath(): \" + file.getCanonicalPath());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n上述代码运行结果：\n\n```\nFile.getPath(): ./resource/data.txt\nFile.getAbsolutePath(): /home/yukai/workspace/test/./resource/data.txt\nFile.getCanonicalPath(): /home/yukai/workspace/test/resource/data.txt\n```\n摘抄一段[stackoverflow](http://stackoverflow.com/questions/1099300/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath)上的答案:\n\n```\ngetPath() gets the path string that the File object was constructed with, and it may be relative current directory.\n\ngetAbsolutePath() gets the path string after resolving it against the current directory if it's relative, resulting in a fully qualified path.\n\ngetCanonicalPath() gets the path string after resolving any relative path against current directory, and removes any relative pathing (. and ..), and any file system links to return a path which the file system considers the canonical means to reference the file system object to which it points.\n```\n\n## 读取classpath下的文件\n\n```java\npublic static void getClassPath() {\n\t\tSystem.out.println(\"PathTest.class.getResource(\\\"/\\\"): \" + PathTest.class.getResource(\"/\"));\n\t\tSystem.out.println(\"PathTest.class.getResource(\\\"\\\"): \" + PathTest.class.getResource(\"\"));\n\t\t\n\t\tSystem.out.println(\"PathTest.class.getClassLoader().getResource(\\\"/\\\"): \" + PathTest.class.getClassLoader().getResource(\"/\"));\n\t\tSystem.out.println(\"PathTest.class.getClassLoader().getResource(\\\"\\\"): \" + PathTest.class.getClassLoader().getResource(\"\"));\n}\n```\n\n运行结果(Eclipse)：\n\n```\n//以“/”开头，表示相对于package根目录\nPathTest.class.getResource(\"/\"): file:/home/yukai/workspace/test/bin/\n//不以“/”开头，表示相对于class文件所在目录\nPathTest.class.getResource(\"\"): file:/home/yukai/workspace/test/bin/test/\n//\nPathTest.class.getClassLoader().getResource(\"/\"): null\n//getClassLoader().getResource(\"\")不以“/”开头，相对于package根目录\nPathTest.class.getClassLoader().getResource(\"\"): file:/home/yukai/workspace/test/bin/\n```\n## 获取jar包路径\n\njava开发中常常需要取得程序生成的jar包所在的路径，比如生成一些log文件的时候，需要把该程序生成的log放到jar包的的同级目录下。\n此时，我们需要知道jar包所在的位置，注意，不是启动jvm实例的位置。\n\n```\nURL url = Config.class.getProtectionDomain().getCodeSource().getLocation();\nString path = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null).getPath(); \nif (path != null) {   \n   if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {      \n          path = path.substring(0, path.length() - 1);    \n   }    \n   if (path.endsWith(\".jar\")) {        \n          int index = path.lastIndexOf(\"/\");\n          if (index != -1) {           \n                path = path.substring(0, index);\n          }\n          defultLogPath = path + File.separator + \"log\";\n   } else { \n       defultLogPath = path + File.separator + \"..\" + File.separator + \"log\" ;\n   }\n}\n```\n\n## Path.java\n\njdk1.7之后，新增了一个类File,位于java.nio.file下，该类提供了一些路径的操作。\n\n具体的使用不一一介绍，用到时可查找oracle的官方手册，已经写的很详细了：[Path Operations](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html)\n","source":"_posts/java中的路径.md","raw":"---\nlayout: post\ntitle: \"java中的路径\"\ncategories: 编程\ndate: 2016-12-04 19:03:00\n---\n\n>每次写java代码的时候，免不了需要加载一些外部资源，比如配置文件等等。每当需要读取这些文件时，都是去网上谷歌，写过就忘。于是今天来总结一些java中有关路径的一些用法。\n\n## 绝对路径\n\n无论是在linux还是windows中，路径都分为绝对路径和相对路径两种。\n\n绝对路径就是系统中唯一能够定位资源的某个URI，即完整的描述文件的路径就是绝对路径。比如：\n\nlinux中的绝对路径：/home/yukai/test.txt\n\nwindows中的绝对路径：E:\\yukai\\test.txt\n\n绝对路径都是以根目录起始的。\n\n## 相对路径\n\n相对路径即目标文件相对与某个基准目录的路径。比如:\n\n存在文件： \n\nA: /home/yukai/test.txt \n\nB: /home/yukai/test1.txt \n\nC: /home/yukai/test/test.txt\n\n那么：\n\n若基准目录为A, B的路径表示为\"test1.txt\"\n\n若基准目录为B, C的路径表示为\"test/test.txt\"\n\n若基准目录为C, B的路径表示为\"../test1.txt\"\n\n另外，“./”表示当前目录，“../”表示上级目录\n\n<!-- more -->\n\n## java io定位文件资源\n\n那么，我们在java中如何读取某个文件？上代码：\n\n```\n// 目录结构\nsrc\n |\n |--test\n |   |\n |   |--PathTest.java \n |\nresource\n |\n |--data.txt\n```\n\n```java\npublic class PathTest {\n\n\tpublic static String  dataFilePath = \"resource/data.txty\";\n\t\n\tpublic static String getUserDir() {\n\t\t//打印运行程序的目录，即启动java程序的目录\n\t\tString userDir = System.getProperty(\"user.dir\");\n\t\tSystem.out.println(\"运行java的工作目录 System.getProperty(\\\"user.dir\\\")： \" + userDir);\n\t\treturn userDir;\n\t}\n\t\n\tpublic static void testDataPath1() {\n\t\tString msg = \">> Path = System.getProperty(\\\"user.dir\\\") + \\\"resource/data.txt\\\"\";\n\t\tString userDir = getUserDir();\n\t\t//等同于 \"resource/data.txt\"\n\t\tString filePath = userDir + System.getProperty(\"file.separator\") + dataFilePath;\n\t\tprintFileContent(filePath ,msg);\n\t}\n\t\n\tpublic static void testDataPath2() {\n\t\tString msg = \"Path = \\\"resource/data.txt\\\"\";\n\t\tString filePath = dataFilePath;\n\t\tprintFileContent(filePath, msg);\n\t}\n\t\n\tpublic static void testDataPath3() {\n\t\tString msg = \"Path = \\\"./resource/data.txt\\\"\";\n\t\tString filePath = \"./resource/data.txt\";\n\t\tprintFileContent(filePath, msg);\n\t}\n\t\n\tprivate static void printFileContent(String filePath, String msg) {\n\t\tSystem.out.println(\"****************************\");\n\t\tSystem.out.println(msg);\n\t\tFile file = new File(filePath);\n\t\tInputStream stream;\n\t\ttry {\n\t\t\tstream = new FileInputStream(file);\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\t\tString line = null;\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tSystem.out.println(\"****************************\");\n\t\t} \n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttestDataPath1();\n\t\ttestDataPath2();\n\t\ttestDataPath3();\n\t}\n\n}\n```\n其中`testDataPath2`、`testDataPath1`、`testDataPath3`这三个方法的效果是一样的。\n\n`System.getProperty(\"user.dir\")`这个方法获取了当前的工作目录，也就是启动jvm的目录。例如：\n\nps: 更多关于System.getProperty()的介绍：[System Properties](http://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html)\n\n你的java程序位于：/home/yukai/code/test.jar \n\n若你在目录/home/yukai下使用命令 `java -cp code/test.jar test.PathTest` 启动java程序时，目录/home/yukai就是你的工作目录。\n\n在`testDataPath2`当中，直接使用\"resource/data.txty\"来作为文件读取路径时，java会默认为基准目录为当前的工作目录，\"resource/data.txty\"此时就是相对于这个基准目录的路径。\n也就是说，java会把工作目录与\"resource/data.txty\"拼接起来，作为一个绝对路径去读取文件，也就是`testDataPath1`中的例子。\n\n有Eclipse中启动你的java工程的目录就是工程根目录，工程根目录也就是工作目录，如果你读取文件的方式类似于`testDataPath2`的话，他会在工程根目录下找你的文件。\n有时候我们会遇到，在Eclipse中读取文件没有问题，但是打成jar包之后运行(像上面运行jar包的例子)就会报找不到文件的错误。那么此时就要检查你的当前工作目录下(/home/yukai)是否有这些文件的存在了。\n\n## File.getPath & File.getAbsolutePath & File.getCanonicalPath\n\n```java\npublic static void testGetPath() {\n\t\tFile file = new File(\"./resource/data.txt\");\n\t\tSystem.out.println(\"File.getPath(): \" + file.getPath());\n\t\tSystem.out.println(\"File.getAbsolutePath(): \"+ file.getAbsolutePath());\n\t\ttry {\n\t\t\tSystem.out.println(\"File.getCanonicalPath(): \" + file.getCanonicalPath());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n上述代码运行结果：\n\n```\nFile.getPath(): ./resource/data.txt\nFile.getAbsolutePath(): /home/yukai/workspace/test/./resource/data.txt\nFile.getCanonicalPath(): /home/yukai/workspace/test/resource/data.txt\n```\n摘抄一段[stackoverflow](http://stackoverflow.com/questions/1099300/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath)上的答案:\n\n```\ngetPath() gets the path string that the File object was constructed with, and it may be relative current directory.\n\ngetAbsolutePath() gets the path string after resolving it against the current directory if it's relative, resulting in a fully qualified path.\n\ngetCanonicalPath() gets the path string after resolving any relative path against current directory, and removes any relative pathing (. and ..), and any file system links to return a path which the file system considers the canonical means to reference the file system object to which it points.\n```\n\n## 读取classpath下的文件\n\n```java\npublic static void getClassPath() {\n\t\tSystem.out.println(\"PathTest.class.getResource(\\\"/\\\"): \" + PathTest.class.getResource(\"/\"));\n\t\tSystem.out.println(\"PathTest.class.getResource(\\\"\\\"): \" + PathTest.class.getResource(\"\"));\n\t\t\n\t\tSystem.out.println(\"PathTest.class.getClassLoader().getResource(\\\"/\\\"): \" + PathTest.class.getClassLoader().getResource(\"/\"));\n\t\tSystem.out.println(\"PathTest.class.getClassLoader().getResource(\\\"\\\"): \" + PathTest.class.getClassLoader().getResource(\"\"));\n}\n```\n\n运行结果(Eclipse)：\n\n```\n//以“/”开头，表示相对于package根目录\nPathTest.class.getResource(\"/\"): file:/home/yukai/workspace/test/bin/\n//不以“/”开头，表示相对于class文件所在目录\nPathTest.class.getResource(\"\"): file:/home/yukai/workspace/test/bin/test/\n//\nPathTest.class.getClassLoader().getResource(\"/\"): null\n//getClassLoader().getResource(\"\")不以“/”开头，相对于package根目录\nPathTest.class.getClassLoader().getResource(\"\"): file:/home/yukai/workspace/test/bin/\n```\n## 获取jar包路径\n\njava开发中常常需要取得程序生成的jar包所在的路径，比如生成一些log文件的时候，需要把该程序生成的log放到jar包的的同级目录下。\n此时，我们需要知道jar包所在的位置，注意，不是启动jvm实例的位置。\n\n```\nURL url = Config.class.getProtectionDomain().getCodeSource().getLocation();\nString path = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null).getPath(); \nif (path != null) {   \n   if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {      \n          path = path.substring(0, path.length() - 1);    \n   }    \n   if (path.endsWith(\".jar\")) {        \n          int index = path.lastIndexOf(\"/\");\n          if (index != -1) {           \n                path = path.substring(0, index);\n          }\n          defultLogPath = path + File.separator + \"log\";\n   } else { \n       defultLogPath = path + File.separator + \"..\" + File.separator + \"log\" ;\n   }\n}\n```\n\n## Path.java\n\njdk1.7之后，新增了一个类File,位于java.nio.file下，该类提供了一些路径的操作。\n\n具体的使用不一一介绍，用到时可查找oracle的官方手册，已经写的很详细了：[Path Operations](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html)\n","slug":"java中的路径","published":1,"updated":"2017-04-11T13:08:38.840Z","comments":1,"photos":[],"link":"","_id":"cj4vch4e8001gx3gcn7xlim1t","content":"<blockquote>\n<p>每次写java代码的时候，免不了需要加载一些外部资源，比如配置文件等等。每当需要读取这些文件时，都是去网上谷歌，写过就忘。于是今天来总结一些java中有关路径的一些用法。</p>\n</blockquote>\n<h2 id=\"绝对路径\"><a href=\"#绝对路径\" class=\"headerlink\" title=\"绝对路径\"></a>绝对路径</h2><p>无论是在linux还是windows中，路径都分为绝对路径和相对路径两种。</p>\n<p>绝对路径就是系统中唯一能够定位资源的某个URI，即完整的描述文件的路径就是绝对路径。比如：</p>\n<p>linux中的绝对路径：/home/yukai/test.txt</p>\n<p>windows中的绝对路径：E:\\yukai\\test.txt</p>\n<p>绝对路径都是以根目录起始的。</p>\n<h2 id=\"相对路径\"><a href=\"#相对路径\" class=\"headerlink\" title=\"相对路径\"></a>相对路径</h2><p>相对路径即目标文件相对与某个基准目录的路径。比如:</p>\n<p>存在文件： </p>\n<p>A: /home/yukai/test.txt </p>\n<p>B: /home/yukai/test1.txt </p>\n<p>C: /home/yukai/test/test.txt</p>\n<p>那么：</p>\n<p>若基准目录为A, B的路径表示为”test1.txt”</p>\n<p>若基准目录为B, C的路径表示为”test/test.txt”</p>\n<p>若基准目录为C, B的路径表示为”../test1.txt”</p>\n<p>另外，“./”表示当前目录，“../”表示上级目录</p>\n<a id=\"more\"></a>\n<h2 id=\"java-io定位文件资源\"><a href=\"#java-io定位文件资源\" class=\"headerlink\" title=\"java io定位文件资源\"></a>java io定位文件资源</h2><p>那么，我们在java中如何读取某个文件？上代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 目录结构</div><div class=\"line\">src</div><div class=\"line\"> |</div><div class=\"line\"> |--test</div><div class=\"line\"> |   |</div><div class=\"line\"> |   |--PathTest.java </div><div class=\"line\"> |</div><div class=\"line\">resource</div><div class=\"line\"> |</div><div class=\"line\"> |--data.txt</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PathTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String  dataFilePath = <span class=\"string\">\"resource/data.txty\"</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getUserDir</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//打印运行程序的目录，即启动java程序的目录</span></div><div class=\"line\">\t\tString userDir = System.getProperty(<span class=\"string\">\"user.dir\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行java的工作目录 System.getProperty(\\\"user.dir\\\")： \"</span> + userDir);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> userDir;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"&gt;&gt; Path = System.getProperty(\\\"user.dir\\\") + \\\"resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString userDir = getUserDir();</div><div class=\"line\">\t\t<span class=\"comment\">//等同于 \"resource/data.txt\"</span></div><div class=\"line\">\t\tString filePath = userDir + System.getProperty(<span class=\"string\">\"file.separator\"</span>) + dataFilePath;</div><div class=\"line\">\t\tprintFileContent(filePath ,msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"Path = \\\"resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString filePath = dataFilePath;</div><div class=\"line\">\t\tprintFileContent(filePath, msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath3</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"Path = \\\"./resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString filePath = <span class=\"string\">\"./resource/data.txt\"</span>;</div><div class=\"line\">\t\tprintFileContent(filePath, msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printFileContent</span><span class=\"params\">(String filePath, String msg)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"****************************\"</span>);</div><div class=\"line\">\t\tSystem.out.println(msg);</div><div class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(filePath);</div><div class=\"line\">\t\tInputStream stream;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tstream = <span class=\"keyword\">new</span> FileInputStream(file);</div><div class=\"line\">\t\t\tBufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(stream));</div><div class=\"line\">\t\t\tString line = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> ((line = reader.readLine()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"****************************\"</span>);</div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\ttestDataPath1();</div><div class=\"line\">\t\ttestDataPath2();</div><div class=\"line\">\t\ttestDataPath3();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中<code>testDataPath2</code>、<code>testDataPath1</code>、<code>testDataPath3</code>这三个方法的效果是一样的。</p>\n<p><code>System.getProperty(&quot;user.dir&quot;)</code>这个方法获取了当前的工作目录，也就是启动jvm的目录。例如：</p>\n<p>ps: 更多关于System.getProperty()的介绍：<a href=\"http://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html\" target=\"_blank\" rel=\"external\">System Properties</a></p>\n<p>你的java程序位于：/home/yukai/code/test.jar </p>\n<p>若你在目录/home/yukai下使用命令 <code>java -cp code/test.jar test.PathTest</code> 启动java程序时，目录/home/yukai就是你的工作目录。</p>\n<p>在<code>testDataPath2</code>当中，直接使用”resource/data.txty”来作为文件读取路径时，java会默认为基准目录为当前的工作目录，”resource/data.txty”此时就是相对于这个基准目录的路径。<br>也就是说，java会把工作目录与”resource/data.txty”拼接起来，作为一个绝对路径去读取文件，也就是<code>testDataPath1</code>中的例子。</p>\n<p>有Eclipse中启动你的java工程的目录就是工程根目录，工程根目录也就是工作目录，如果你读取文件的方式类似于<code>testDataPath2</code>的话，他会在工程根目录下找你的文件。<br>有时候我们会遇到，在Eclipse中读取文件没有问题，但是打成jar包之后运行(像上面运行jar包的例子)就会报找不到文件的错误。那么此时就要检查你的当前工作目录下(/home/yukai)是否有这些文件的存在了。</p>\n<h2 id=\"File-getPath-amp-File-getAbsolutePath-amp-File-getCanonicalPath\"><a href=\"#File-getPath-amp-File-getAbsolutePath-amp-File-getCanonicalPath\" class=\"headerlink\" title=\"File.getPath &amp; File.getAbsolutePath &amp; File.getCanonicalPath\"></a>File.getPath &amp; File.getAbsolutePath &amp; File.getCanonicalPath</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGetPath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"./resource/data.txt\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"File.getPath(): \"</span> + file.getPath());</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"File.getAbsolutePath(): \"</span>+ file.getAbsolutePath());</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"File.getCanonicalPath(): \"</span> + file.getCanonicalPath());</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">File.getPath(): ./resource/data.txt</div><div class=\"line\">File.getAbsolutePath(): /home/yukai/workspace/test/./resource/data.txt</div><div class=\"line\">File.getCanonicalPath(): /home/yukai/workspace/test/resource/data.txt</div></pre></td></tr></table></figure>\n<p>摘抄一段<a href=\"http://stackoverflow.com/questions/1099300/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath\" target=\"_blank\" rel=\"external\">stackoverflow</a>上的答案:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">getPath() gets the path string that the File object was constructed with, and it may be relative current directory.</div><div class=\"line\"></div><div class=\"line\">getAbsolutePath() gets the path string after resolving it against the current directory if it&apos;s relative, resulting in a fully qualified path.</div><div class=\"line\"></div><div class=\"line\">getCanonicalPath() gets the path string after resolving any relative path against current directory, and removes any relative pathing (. and ..), and any file system links to return a path which the file system considers the canonical means to reference the file system object to which it points.</div></pre></td></tr></table></figure>\n<h2 id=\"读取classpath下的文件\"><a href=\"#读取classpath下的文件\" class=\"headerlink\" title=\"读取classpath下的文件\"></a>读取classpath下的文件</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getClassPath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getResource(\\\"/\\\"): \"</span> + PathTest.class.getResource(<span class=\"string\">\"/\"</span>));</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getResource(\\\"\\\"): \"</span> + PathTest.class.getResource(<span class=\"string\">\"\"</span>));</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getClassLoader().getResource(\\\"/\\\"): \"</span> + PathTest.class.getClassLoader().getResource(<span class=\"string\">\"/\"</span>));</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getClassLoader().getResource(\\\"\\\"): \"</span> + PathTest.class.getClassLoader().getResource(<span class=\"string\">\"\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果(Eclipse)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以“/”开头，表示相对于package根目录</div><div class=\"line\">PathTest.class.getResource(&quot;/&quot;): file:/home/yukai/workspace/test/bin/</div><div class=\"line\">//不以“/”开头，表示相对于class文件所在目录</div><div class=\"line\">PathTest.class.getResource(&quot;&quot;): file:/home/yukai/workspace/test/bin/test/</div><div class=\"line\">//</div><div class=\"line\">PathTest.class.getClassLoader().getResource(&quot;/&quot;): null</div><div class=\"line\">//getClassLoader().getResource(&quot;&quot;)不以“/”开头，相对于package根目录</div><div class=\"line\">PathTest.class.getClassLoader().getResource(&quot;&quot;): file:/home/yukai/workspace/test/bin/</div></pre></td></tr></table></figure>\n<h2 id=\"获取jar包路径\"><a href=\"#获取jar包路径\" class=\"headerlink\" title=\"获取jar包路径\"></a>获取jar包路径</h2><p>java开发中常常需要取得程序生成的jar包所在的路径，比如生成一些log文件的时候，需要把该程序生成的log放到jar包的的同级目录下。<br>此时，我们需要知道jar包所在的位置，注意，不是启动jvm实例的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">URL url = Config.class.getProtectionDomain().getCodeSource().getLocation();</div><div class=\"line\">String path = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null).getPath(); </div><div class=\"line\">if (path != null) &#123;   </div><div class=\"line\">   if (path.endsWith(&quot;/&quot;) || path.endsWith(&quot;\\\\&quot;)) &#123;      </div><div class=\"line\">          path = path.substring(0, path.length() - 1);    </div><div class=\"line\">   &#125;    </div><div class=\"line\">   if (path.endsWith(&quot;.jar&quot;)) &#123;        </div><div class=\"line\">          int index = path.lastIndexOf(&quot;/&quot;);</div><div class=\"line\">          if (index != -1) &#123;           </div><div class=\"line\">                path = path.substring(0, index);</div><div class=\"line\">          &#125;</div><div class=\"line\">          defultLogPath = path + File.separator + &quot;log&quot;;</div><div class=\"line\">   &#125; else &#123; </div><div class=\"line\">       defultLogPath = path + File.separator + &quot;..&quot; + File.separator + &quot;log&quot; ;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Path-java\"><a href=\"#Path-java\" class=\"headerlink\" title=\"Path.java\"></a>Path.java</h2><p>jdk1.7之后，新增了一个类File,位于java.nio.file下，该类提供了一些路径的操作。</p>\n<p>具体的使用不一一介绍，用到时可查找oracle的官方手册，已经写的很详细了：<a href=\"https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html\" target=\"_blank\" rel=\"external\">Path Operations</a></p>\n","excerpt":"<blockquote>\n<p>每次写java代码的时候，免不了需要加载一些外部资源，比如配置文件等等。每当需要读取这些文件时，都是去网上谷歌，写过就忘。于是今天来总结一些java中有关路径的一些用法。</p>\n</blockquote>\n<h2 id=\"绝对路径\"><a href=\"#绝对路径\" class=\"headerlink\" title=\"绝对路径\"></a>绝对路径</h2><p>无论是在linux还是windows中，路径都分为绝对路径和相对路径两种。</p>\n<p>绝对路径就是系统中唯一能够定位资源的某个URI，即完整的描述文件的路径就是绝对路径。比如：</p>\n<p>linux中的绝对路径：/home/yukai/test.txt</p>\n<p>windows中的绝对路径：E:\\yukai\\test.txt</p>\n<p>绝对路径都是以根目录起始的。</p>\n<h2 id=\"相对路径\"><a href=\"#相对路径\" class=\"headerlink\" title=\"相对路径\"></a>相对路径</h2><p>相对路径即目标文件相对与某个基准目录的路径。比如:</p>\n<p>存在文件： </p>\n<p>A: /home/yukai/test.txt </p>\n<p>B: /home/yukai/test1.txt </p>\n<p>C: /home/yukai/test/test.txt</p>\n<p>那么：</p>\n<p>若基准目录为A, B的路径表示为”test1.txt”</p>\n<p>若基准目录为B, C的路径表示为”test/test.txt”</p>\n<p>若基准目录为C, B的路径表示为”../test1.txt”</p>\n<p>另外，“./”表示当前目录，“../”表示上级目录</p>","more":"<h2 id=\"java-io定位文件资源\"><a href=\"#java-io定位文件资源\" class=\"headerlink\" title=\"java io定位文件资源\"></a>java io定位文件资源</h2><p>那么，我们在java中如何读取某个文件？上代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 目录结构</div><div class=\"line\">src</div><div class=\"line\"> |</div><div class=\"line\"> |--test</div><div class=\"line\"> |   |</div><div class=\"line\"> |   |--PathTest.java </div><div class=\"line\"> |</div><div class=\"line\">resource</div><div class=\"line\"> |</div><div class=\"line\"> |--data.txt</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PathTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String  dataFilePath = <span class=\"string\">\"resource/data.txty\"</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getUserDir</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//打印运行程序的目录，即启动java程序的目录</span></div><div class=\"line\">\t\tString userDir = System.getProperty(<span class=\"string\">\"user.dir\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行java的工作目录 System.getProperty(\\\"user.dir\\\")： \"</span> + userDir);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> userDir;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"&gt;&gt; Path = System.getProperty(\\\"user.dir\\\") + \\\"resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString userDir = getUserDir();</div><div class=\"line\">\t\t<span class=\"comment\">//等同于 \"resource/data.txt\"</span></div><div class=\"line\">\t\tString filePath = userDir + System.getProperty(<span class=\"string\">\"file.separator\"</span>) + dataFilePath;</div><div class=\"line\">\t\tprintFileContent(filePath ,msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"Path = \\\"resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString filePath = dataFilePath;</div><div class=\"line\">\t\tprintFileContent(filePath, msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataPath3</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString msg = <span class=\"string\">\"Path = \\\"./resource/data.txt\\\"\"</span>;</div><div class=\"line\">\t\tString filePath = <span class=\"string\">\"./resource/data.txt\"</span>;</div><div class=\"line\">\t\tprintFileContent(filePath, msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printFileContent</span><span class=\"params\">(String filePath, String msg)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"****************************\"</span>);</div><div class=\"line\">\t\tSystem.out.println(msg);</div><div class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(filePath);</div><div class=\"line\">\t\tInputStream stream;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tstream = <span class=\"keyword\">new</span> FileInputStream(file);</div><div class=\"line\">\t\t\tBufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(stream));</div><div class=\"line\">\t\t\tString line = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> ((line = reader.readLine()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"****************************\"</span>);</div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\ttestDataPath1();</div><div class=\"line\">\t\ttestDataPath2();</div><div class=\"line\">\t\ttestDataPath3();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中<code>testDataPath2</code>、<code>testDataPath1</code>、<code>testDataPath3</code>这三个方法的效果是一样的。</p>\n<p><code>System.getProperty(&quot;user.dir&quot;)</code>这个方法获取了当前的工作目录，也就是启动jvm的目录。例如：</p>\n<p>ps: 更多关于System.getProperty()的介绍：<a href=\"http://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html\">System Properties</a></p>\n<p>你的java程序位于：/home/yukai/code/test.jar </p>\n<p>若你在目录/home/yukai下使用命令 <code>java -cp code/test.jar test.PathTest</code> 启动java程序时，目录/home/yukai就是你的工作目录。</p>\n<p>在<code>testDataPath2</code>当中，直接使用”resource/data.txty”来作为文件读取路径时，java会默认为基准目录为当前的工作目录，”resource/data.txty”此时就是相对于这个基准目录的路径。<br>也就是说，java会把工作目录与”resource/data.txty”拼接起来，作为一个绝对路径去读取文件，也就是<code>testDataPath1</code>中的例子。</p>\n<p>有Eclipse中启动你的java工程的目录就是工程根目录，工程根目录也就是工作目录，如果你读取文件的方式类似于<code>testDataPath2</code>的话，他会在工程根目录下找你的文件。<br>有时候我们会遇到，在Eclipse中读取文件没有问题，但是打成jar包之后运行(像上面运行jar包的例子)就会报找不到文件的错误。那么此时就要检查你的当前工作目录下(/home/yukai)是否有这些文件的存在了。</p>\n<h2 id=\"File-getPath-amp-File-getAbsolutePath-amp-File-getCanonicalPath\"><a href=\"#File-getPath-amp-File-getAbsolutePath-amp-File-getCanonicalPath\" class=\"headerlink\" title=\"File.getPath &amp; File.getAbsolutePath &amp; File.getCanonicalPath\"></a>File.getPath &amp; File.getAbsolutePath &amp; File.getCanonicalPath</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGetPath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"./resource/data.txt\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"File.getPath(): \"</span> + file.getPath());</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"File.getAbsolutePath(): \"</span>+ file.getAbsolutePath());</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"File.getCanonicalPath(): \"</span> + file.getCanonicalPath());</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">File.getPath(): ./resource/data.txt</div><div class=\"line\">File.getAbsolutePath(): /home/yukai/workspace/test/./resource/data.txt</div><div class=\"line\">File.getCanonicalPath(): /home/yukai/workspace/test/resource/data.txt</div></pre></td></tr></table></figure>\n<p>摘抄一段<a href=\"http://stackoverflow.com/questions/1099300/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath\">stackoverflow</a>上的答案:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">getPath() gets the path string that the File object was constructed with, and it may be relative current directory.</div><div class=\"line\"></div><div class=\"line\">getAbsolutePath() gets the path string after resolving it against the current directory if it&apos;s relative, resulting in a fully qualified path.</div><div class=\"line\"></div><div class=\"line\">getCanonicalPath() gets the path string after resolving any relative path against current directory, and removes any relative pathing (. and ..), and any file system links to return a path which the file system considers the canonical means to reference the file system object to which it points.</div></pre></td></tr></table></figure>\n<h2 id=\"读取classpath下的文件\"><a href=\"#读取classpath下的文件\" class=\"headerlink\" title=\"读取classpath下的文件\"></a>读取classpath下的文件</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getClassPath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getResource(\\\"/\\\"): \"</span> + PathTest.class.getResource(<span class=\"string\">\"/\"</span>));</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getResource(\\\"\\\"): \"</span> + PathTest.class.getResource(<span class=\"string\">\"\"</span>));</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getClassLoader().getResource(\\\"/\\\"): \"</span> + PathTest.class.getClassLoader().getResource(<span class=\"string\">\"/\"</span>));</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PathTest.class.getClassLoader().getResource(\\\"\\\"): \"</span> + PathTest.class.getClassLoader().getResource(<span class=\"string\">\"\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果(Eclipse)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以“/”开头，表示相对于package根目录</div><div class=\"line\">PathTest.class.getResource(&quot;/&quot;): file:/home/yukai/workspace/test/bin/</div><div class=\"line\">//不以“/”开头，表示相对于class文件所在目录</div><div class=\"line\">PathTest.class.getResource(&quot;&quot;): file:/home/yukai/workspace/test/bin/test/</div><div class=\"line\">//</div><div class=\"line\">PathTest.class.getClassLoader().getResource(&quot;/&quot;): null</div><div class=\"line\">//getClassLoader().getResource(&quot;&quot;)不以“/”开头，相对于package根目录</div><div class=\"line\">PathTest.class.getClassLoader().getResource(&quot;&quot;): file:/home/yukai/workspace/test/bin/</div></pre></td></tr></table></figure>\n<h2 id=\"获取jar包路径\"><a href=\"#获取jar包路径\" class=\"headerlink\" title=\"获取jar包路径\"></a>获取jar包路径</h2><p>java开发中常常需要取得程序生成的jar包所在的路径，比如生成一些log文件的时候，需要把该程序生成的log放到jar包的的同级目录下。<br>此时，我们需要知道jar包所在的位置，注意，不是启动jvm实例的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">URL url = Config.class.getProtectionDomain().getCodeSource().getLocation();</div><div class=\"line\">String path = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null).getPath(); </div><div class=\"line\">if (path != null) &#123;   </div><div class=\"line\">   if (path.endsWith(&quot;/&quot;) || path.endsWith(&quot;\\\\&quot;)) &#123;      </div><div class=\"line\">          path = path.substring(0, path.length() - 1);    </div><div class=\"line\">   &#125;    </div><div class=\"line\">   if (path.endsWith(&quot;.jar&quot;)) &#123;        </div><div class=\"line\">          int index = path.lastIndexOf(&quot;/&quot;);</div><div class=\"line\">          if (index != -1) &#123;           </div><div class=\"line\">                path = path.substring(0, index);</div><div class=\"line\">          &#125;</div><div class=\"line\">          defultLogPath = path + File.separator + &quot;log&quot;;</div><div class=\"line\">   &#125; else &#123; </div><div class=\"line\">       defultLogPath = path + File.separator + &quot;..&quot; + File.separator + &quot;log&quot; ;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Path-java\"><a href=\"#Path-java\" class=\"headerlink\" title=\"Path.java\"></a>Path.java</h2><p>jdk1.7之后，新增了一个类File,位于java.nio.file下，该类提供了一些路径的操作。</p>\n<p>具体的使用不一一介绍，用到时可查找oracle的官方手册，已经写的很详细了：<a href=\"https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html\">Path Operations</a></p>"},{"layout":"post","title":"java中的编码问题","date":"2016-04-20T04:48:55.000Z","_content":"\n>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。\n\n2016/9/11 更新：今天在网上看到一篇讲解有关编码的文章 [Java中字符编码和字符串所占字节数](http://blog.csdn.net/zklth/article/details/7016886),个人认为作者写的十分清晰明了。把文章中的例子看懂的话再遇到乱码的情况解决起来应该不难！\n\n## 编码\n什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。\n\n- #### **[Ascii编码](http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&fromid=99077&type=syn)**\n\n标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。\n\n- #### **[GB2312](http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&fromid=483170&type=syn)**\n\nGB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。\n\n- #### **[UTF-8](http://baike.baidu.com/view/25412.htm)**\n\n事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是[Unicode编码](http://baike.baidu.com/item/unicode)\n事实上，Unicode也是一套字符集。\n\n<!-- more -->\n\n**字符集**简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字\"严\"。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？\n\n这是因为：\n\n比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n\n**字符编码**就是用来解决以上所说的如何存储字符对应二进制编码问题的。\n\nUTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8的编码规则很简单，只有两条： \n\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 \n\n2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n\n下面以utf-8为例，看下编码的过程。\n\n{% asset_img utf8.png utf-8 %}\n\n根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。\n\n以汉字”严”为例，演示如何实现UTF-8编码。\n\n已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。\n\n还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。\n\n## java 中的编码\n\n- #### **class文件与内存中的编码**\n\n{% asset_img javaencode.jpg %}\n\n上图说明了java编码转换的过程\n\n首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。\n\njava程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。\n\n**总结**:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。\n\n- #### **InputStreamReader与OutputStreamWriter**\n\n{% asset_img reader.png %}\n{% asset_img writer.png %}\n\nReader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。\n\n写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。\n\n```java\n String file = \"c:/stream.txt\"; \n String charset = \"UTF-8\"; \n // 写字符换转成字节流\n FileOutputStream outputStream = new FileOutputStream(file); \n OutputStreamWriter writer = new OutputStreamWriter( \n outputStream, charset); \n try { \n    writer.write(\"这是要保存的中文字符\"); \n } finally { \n    writer.close(); \n } \n // 读取字节转换成字符\n FileInputStream inputStream = new FileInputStream(file); \n InputStreamReader reader = new InputStreamReader( \n inputStream, charset); \n StringBuffer buffer = new StringBuffer(); \n char[] buf = new char[64]; \n int count = 0; \n try { \n    while ((count = reader.read(buf)) != -1) { \n        buffer.append(buf, 0, count); \n    } \n } finally { \n    reader.close(); \n }\n```\n\n- #### **String与byte[]**\n\n利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。\n\n```java\nString str=\"中\";  \n// 将内存中的str(utf-16)转换为系统默认编码的字节数组\nbyte[] bytes1 = str.getBytes();  \n// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 \nbyte[] bytes2 = str.getBytes(\"ISO-8859-1\");\n// 正常显示中    \nSystem.out.println(new String(bytes1));  \n// 输出\"?\"      \nSystem.out.println(new String(bytes2));      \n```\n\n利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。\n\n```java\n// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”\nbyte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31};  \n// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符\nString str1 = new String(bytes);                      \n// 将bytes按照ISO-8859-1解码，产生Unicode字符\nString str2= new String(bytes,\"ISO-8859-1\");          \n// 中1  将Unicode字符转换为GBK编码输出\nSystem.out.println(str1);                             \n\n/*\n *在ISO-8859-1编码方式中没有对应0xD6和0xD0\n *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”\n *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。\n */ \nSystem.out.println(str2);    // ??1                             \n```\n\n- #### **CharSet**\n\n从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。\n\n```java\nCharset charset = Charset.forName(\"UTF-8\");   \nByteBuffer byteBuffer = charset.encode(string);   \nCharBuffer charBuffer = charset.decode(byteBuffer); \n```\n\n## 延伸 byte\n\n字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。\n\n无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。\n\n有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.\n\n## 参考\n\n[十分钟搞清字符集和字符编码](http://cenalulu.github.io/linux/character-encoding/)\n\n[字符编码笔记：ASCII，Unicode和UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n[java编码转换过程](http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html)\n\n[Java 7之基础 - 编码与解码](http://blog.csdn.net/mazhimazh/article/details/19327421)\n\n[深入分析 Java 中的中文编码问题](https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/)","source":"_posts/java中的编码问题.md","raw":"---\nlayout: post\ntitle:  \"java中的编码问题\"\ncategories: 编程\ntags: \n- java\n- 编码\ndate:   2016-04-20 12:48:55\n---\n\n>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。\n\n2016/9/11 更新：今天在网上看到一篇讲解有关编码的文章 [Java中字符编码和字符串所占字节数](http://blog.csdn.net/zklth/article/details/7016886),个人认为作者写的十分清晰明了。把文章中的例子看懂的话再遇到乱码的情况解决起来应该不难！\n\n## 编码\n什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。\n\n- #### **[Ascii编码](http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&fromid=99077&type=syn)**\n\n标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。\n\n- #### **[GB2312](http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&fromid=483170&type=syn)**\n\nGB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。\n\n- #### **[UTF-8](http://baike.baidu.com/view/25412.htm)**\n\n事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是[Unicode编码](http://baike.baidu.com/item/unicode)\n事实上，Unicode也是一套字符集。\n\n<!-- more -->\n\n**字符集**简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字\"严\"。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？\n\n这是因为：\n\n比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n\n**字符编码**就是用来解决以上所说的如何存储字符对应二进制编码问题的。\n\nUTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8的编码规则很简单，只有两条： \n\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 \n\n2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n\n下面以utf-8为例，看下编码的过程。\n\n{% asset_img utf8.png utf-8 %}\n\n根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。\n\n以汉字”严”为例，演示如何实现UTF-8编码。\n\n已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。\n\n还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。\n\n## java 中的编码\n\n- #### **class文件与内存中的编码**\n\n{% asset_img javaencode.jpg %}\n\n上图说明了java编码转换的过程\n\n首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。\n\njava程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。\n\n**总结**:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。\n\n- #### **InputStreamReader与OutputStreamWriter**\n\n{% asset_img reader.png %}\n{% asset_img writer.png %}\n\nReader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。\n\n写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。\n\n```java\n String file = \"c:/stream.txt\"; \n String charset = \"UTF-8\"; \n // 写字符换转成字节流\n FileOutputStream outputStream = new FileOutputStream(file); \n OutputStreamWriter writer = new OutputStreamWriter( \n outputStream, charset); \n try { \n    writer.write(\"这是要保存的中文字符\"); \n } finally { \n    writer.close(); \n } \n // 读取字节转换成字符\n FileInputStream inputStream = new FileInputStream(file); \n InputStreamReader reader = new InputStreamReader( \n inputStream, charset); \n StringBuffer buffer = new StringBuffer(); \n char[] buf = new char[64]; \n int count = 0; \n try { \n    while ((count = reader.read(buf)) != -1) { \n        buffer.append(buf, 0, count); \n    } \n } finally { \n    reader.close(); \n }\n```\n\n- #### **String与byte[]**\n\n利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。\n\n```java\nString str=\"中\";  \n// 将内存中的str(utf-16)转换为系统默认编码的字节数组\nbyte[] bytes1 = str.getBytes();  \n// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 \nbyte[] bytes2 = str.getBytes(\"ISO-8859-1\");\n// 正常显示中    \nSystem.out.println(new String(bytes1));  \n// 输出\"?\"      \nSystem.out.println(new String(bytes2));      \n```\n\n利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。\n\n```java\n// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”\nbyte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31};  \n// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符\nString str1 = new String(bytes);                      \n// 将bytes按照ISO-8859-1解码，产生Unicode字符\nString str2= new String(bytes,\"ISO-8859-1\");          \n// 中1  将Unicode字符转换为GBK编码输出\nSystem.out.println(str1);                             \n\n/*\n *在ISO-8859-1编码方式中没有对应0xD6和0xD0\n *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”\n *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。\n */ \nSystem.out.println(str2);    // ??1                             \n```\n\n- #### **CharSet**\n\n从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。\n\n```java\nCharset charset = Charset.forName(\"UTF-8\");   \nByteBuffer byteBuffer = charset.encode(string);   \nCharBuffer charBuffer = charset.decode(byteBuffer); \n```\n\n## 延伸 byte\n\n字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。\n\n无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。\n\n有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.\n\n## 参考\n\n[十分钟搞清字符集和字符编码](http://cenalulu.github.io/linux/character-encoding/)\n\n[字符编码笔记：ASCII，Unicode和UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n[java编码转换过程](http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html)\n\n[Java 7之基础 - 编码与解码](http://blog.csdn.net/mazhimazh/article/details/19327421)\n\n[深入分析 Java 中的中文编码问题](https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/)","slug":"java中的编码问题","published":1,"updated":"2017-04-11T13:08:38.839Z","comments":1,"photos":[],"link":"","_id":"cj4vch4eg001kx3gc3een0w3k","content":"<blockquote>\n<p>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。</p>\n</blockquote>\n<p>2016/9/11 更新：今天在网上看到一篇讲解有关编码的文章 <a href=\"http://blog.csdn.net/zklth/article/details/7016886\" target=\"_blank\" rel=\"external\">Java中字符编码和字符串所占字节数</a>,个人认为作者写的十分清晰明了。把文章中的例子看懂的话再遇到乱码的情况解决起来应该不难！</p>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。</p>\n<ul>\n<li><h4 id=\"Ascii编码\"><a href=\"#Ascii编码\" class=\"headerlink\" title=\"Ascii编码\"></a><strong><a href=\"http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&amp;fromid=99077&amp;type=syn\" target=\"_blank\" rel=\"external\">Ascii编码</a></strong></h4></li>\n</ul>\n<p>标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。</p>\n<ul>\n<li><h4 id=\"GB2312\"><a href=\"#GB2312\" class=\"headerlink\" title=\"GB2312\"></a><strong><a href=\"http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&amp;fromid=483170&amp;type=syn\" target=\"_blank\" rel=\"external\">GB2312</a></strong></h4></li>\n</ul>\n<p>GB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p>\n<ul>\n<li><h4 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a><strong><a href=\"http://baike.baidu.com/view/25412.htm\" target=\"_blank\" rel=\"external\">UTF-8</a></strong></h4></li>\n</ul>\n<p>事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是<a href=\"http://baike.baidu.com/item/unicode\" target=\"_blank\" rel=\"external\">Unicode编码</a><br>事实上，Unicode也是一套字符集。</p>\n<a id=\"more\"></a>\n<p><strong>字符集</strong>简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？</p>\n<p>这是因为：</p>\n<p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。<br>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>\n<p><strong>字符编码</strong>就是用来解决以上所说的如何存储字符对应二进制编码问题的。</p>\n<p>UTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<p>UTF-8的编码规则很简单，只有两条： </p>\n<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </p>\n<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>\n<p>下面以utf-8为例，看下编码的过程。</p>\n<img src=\"/2016/04/20/java中的编码问题/utf8.png\" alt=\"utf-8\" title=\"utf-8\">\n<p>根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。</p>\n<p>以汉字”严”为例，演示如何实现UTF-8编码。</p>\n<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。</p>\n<p>还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。</p>\n<h2 id=\"java-中的编码\"><a href=\"#java-中的编码\" class=\"headerlink\" title=\"java 中的编码\"></a>java 中的编码</h2><ul>\n<li><h4 id=\"class文件与内存中的编码\"><a href=\"#class文件与内存中的编码\" class=\"headerlink\" title=\"class文件与内存中的编码\"></a><strong>class文件与内存中的编码</strong></h4></li>\n</ul>\n\n<p>上图说明了java编码转换的过程</p>\n<p>首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。</p>\n<p>java程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。</p>\n<p><strong>总结</strong>:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。</p>\n<ul>\n<li><h4 id=\"InputStreamReader与OutputStreamWriter\"><a href=\"#InputStreamReader与OutputStreamWriter\" class=\"headerlink\" title=\"InputStreamReader与OutputStreamWriter\"></a><strong>InputStreamReader与OutputStreamWriter</strong></h4></li>\n</ul>\n<img src=\"/2016/04/20/java中的编码问题/reader.png\" alt=\"reader.png\" title=\"\">\n<img src=\"/2016/04/20/java中的编码问题/writer.png\" alt=\"writer.png\" title=\"\">\n<p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。</p>\n<p>写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">String file = <span class=\"string\">\"c:/stream.txt\"</span>; </div><div class=\"line\">String charset = <span class=\"string\">\"UTF-8\"</span>; </div><div class=\"line\"><span class=\"comment\">// 写字符换转成字节流</span></div><div class=\"line\">FileOutputStream outputStream = <span class=\"keyword\">new</span> FileOutputStream(file); </div><div class=\"line\">OutputStreamWriter writer = <span class=\"keyword\">new</span> OutputStreamWriter( </div><div class=\"line\">outputStream, charset); </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   writer.write(<span class=\"string\">\"这是要保存的中文字符\"</span>); </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   writer.close(); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"comment\">// 读取字节转换成字符</span></div><div class=\"line\">FileInputStream inputStream = <span class=\"keyword\">new</span> FileInputStream(file); </div><div class=\"line\">InputStreamReader reader = <span class=\"keyword\">new</span> InputStreamReader( </div><div class=\"line\">inputStream, charset); </div><div class=\"line\">StringBuffer buffer = <span class=\"keyword\">new</span> StringBuffer(); </div><div class=\"line\"><span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>]; </div><div class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   <span class=\"keyword\">while</span> ((count = reader.read(buf)) != -<span class=\"number\">1</span>) &#123; </div><div class=\"line\">       buffer.append(buf, <span class=\"number\">0</span>, count); </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   reader.close(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"String与byte\"><a href=\"#String与byte\" class=\"headerlink\" title=\"String与byte[]\"></a><strong>String与byte[]</strong></h4></li>\n</ul>\n<p>利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"string\">\"中\"</span>;  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为系统默认编码的字节数组</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = str.getBytes();  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 </span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = str.getBytes(<span class=\"string\">\"ISO-8859-1\"</span>);</div><div class=\"line\"><span class=\"comment\">// 正常显示中    </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes1));  </div><div class=\"line\"><span class=\"comment\">// 输出\"?\"      </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes2));</div></pre></td></tr></table></figure>\n<p>利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes = &#123;(<span class=\"keyword\">byte</span>)<span class=\"number\">0xD6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0xD0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0x31</span>&#125;;  </div><div class=\"line\"><span class=\"comment\">// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符</span></div><div class=\"line\">String str1 = <span class=\"keyword\">new</span> String(bytes);                      </div><div class=\"line\"><span class=\"comment\">// 将bytes按照ISO-8859-1解码，产生Unicode字符</span></div><div class=\"line\">String str2= <span class=\"keyword\">new</span> String(bytes,<span class=\"string\">\"ISO-8859-1\"</span>);          </div><div class=\"line\"><span class=\"comment\">// 中1  将Unicode字符转换为GBK编码输出</span></div><div class=\"line\">System.out.println(str1);                             </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> *在ISO-8859-1编码方式中没有对应0xD6和0xD0</div><div class=\"line\"> *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”</div><div class=\"line\"> *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。</div><div class=\"line\"> */ </div><div class=\"line\">System.out.println(str2);    <span class=\"comment\">// ??1</span></div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"CharSet\"><a href=\"#CharSet\" class=\"headerlink\" title=\"CharSet\"></a><strong>CharSet</strong></h4></li>\n</ul>\n<p>从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(<span class=\"string\">\"UTF-8\"</span>);   </div><div class=\"line\">ByteBuffer byteBuffer = charset.encode(string);   </div><div class=\"line\">CharBuffer charBuffer = charset.decode(byteBuffer);</div></pre></td></tr></table></figure>\n<h2 id=\"延伸-byte\"><a href=\"#延伸-byte\" class=\"headerlink\" title=\"延伸 byte\"></a>延伸 byte</h2><p>字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。</p>\n<p>无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。</p>\n<p>有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://cenalulu.github.io/linux/character-encoding/\" target=\"_blank\" rel=\"external\">十分钟搞清字符集和字符编码</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\" target=\"_blank\" rel=\"external\">字符编码笔记：ASCII，Unicode和UTF-8</a></p>\n<p><a href=\"http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html\" target=\"_blank\" rel=\"external\">java编码转换过程</a></p>\n<p><a href=\"http://blog.csdn.net/mazhimazh/article/details/19327421\" target=\"_blank\" rel=\"external\">Java 7之基础 - 编码与解码</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/\" target=\"_blank\" rel=\"external\">深入分析 Java 中的中文编码问题</a></p>\n","excerpt":"<blockquote>\n<p>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。</p>\n</blockquote>\n<p>2016/9/11 更新：今天在网上看到一篇讲解有关编码的文章 <a href=\"http://blog.csdn.net/zklth/article/details/7016886\">Java中字符编码和字符串所占字节数</a>,个人认为作者写的十分清晰明了。把文章中的例子看懂的话再遇到乱码的情况解决起来应该不难！</p>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。</p>\n<ul>\n<li><h4 id=\"Ascii编码\"><a href=\"#Ascii编码\" class=\"headerlink\" title=\"Ascii编码\"></a><strong><a href=\"http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&amp;fromid=99077&amp;type=syn\">Ascii编码</a></strong></h4></li>\n</ul>\n<p>标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。</p>\n<ul>\n<li><h4 id=\"GB2312\"><a href=\"#GB2312\" class=\"headerlink\" title=\"GB2312\"></a><strong><a href=\"http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&amp;fromid=483170&amp;type=syn\">GB2312</a></strong></h4></li>\n</ul>\n<p>GB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p>\n<ul>\n<li><h4 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a><strong><a href=\"http://baike.baidu.com/view/25412.htm\">UTF-8</a></strong></h4></li>\n</ul>\n<p>事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是<a href=\"http://baike.baidu.com/item/unicode\">Unicode编码</a><br>事实上，Unicode也是一套字符集。</p>","more":"<p><strong>字符集</strong>简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？</p>\n<p>这是因为：</p>\n<p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。<br>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>\n<p><strong>字符编码</strong>就是用来解决以上所说的如何存储字符对应二进制编码问题的。</p>\n<p>UTF-8就是在互联网上使用最广的一种Unicode的实现方式。即，UTF-8就是对应Unicode字符集的一种字符编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<p>UTF-8的编码规则很简单，只有两条： </p>\n<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </p>\n<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>\n<p>下面以utf-8为例，看下编码的过程。</p>\n<img src=\"/2016/04/20/java中的编码问题/utf8.png\" alt=\"utf-8\" title=\"utf-8\">\n<p>根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。</p>\n<p>以汉字”严”为例，演示如何实现UTF-8编码。</p>\n<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。</p>\n<p>还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。</p>\n<h2 id=\"java-中的编码\"><a href=\"#java-中的编码\" class=\"headerlink\" title=\"java 中的编码\"></a>java 中的编码</h2><ul>\n<li><h4 id=\"class文件与内存中的编码\"><a href=\"#class文件与内存中的编码\" class=\"headerlink\" title=\"class文件与内存中的编码\"></a><strong>class文件与内存中的编码</strong></h4></li>\n</ul>\n\n<p>上图说明了java编码转换的过程</p>\n<p>首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。</p>\n<p>java程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。</p>\n<p><strong>总结</strong>:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。</p>\n<ul>\n<li><h4 id=\"InputStreamReader与OutputStreamWriter\"><a href=\"#InputStreamReader与OutputStreamWriter\" class=\"headerlink\" title=\"InputStreamReader与OutputStreamWriter\"></a><strong>InputStreamReader与OutputStreamWriter</strong></h4></li>\n</ul>\n<img src=\"/2016/04/20/java中的编码问题/reader.png\" alt=\"reader.png\" title=\"\">\n<img src=\"/2016/04/20/java中的编码问题/writer.png\" alt=\"writer.png\" title=\"\">\n<p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。</p>\n<p>写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">String file = <span class=\"string\">\"c:/stream.txt\"</span>; </div><div class=\"line\">String charset = <span class=\"string\">\"UTF-8\"</span>; </div><div class=\"line\"><span class=\"comment\">// 写字符换转成字节流</span></div><div class=\"line\">FileOutputStream outputStream = <span class=\"keyword\">new</span> FileOutputStream(file); </div><div class=\"line\">OutputStreamWriter writer = <span class=\"keyword\">new</span> OutputStreamWriter( </div><div class=\"line\">outputStream, charset); </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   writer.write(<span class=\"string\">\"这是要保存的中文字符\"</span>); </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   writer.close(); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"comment\">// 读取字节转换成字符</span></div><div class=\"line\">FileInputStream inputStream = <span class=\"keyword\">new</span> FileInputStream(file); </div><div class=\"line\">InputStreamReader reader = <span class=\"keyword\">new</span> InputStreamReader( </div><div class=\"line\">inputStream, charset); </div><div class=\"line\">StringBuffer buffer = <span class=\"keyword\">new</span> StringBuffer(); </div><div class=\"line\"><span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>]; </div><div class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   <span class=\"keyword\">while</span> ((count = reader.read(buf)) != -<span class=\"number\">1</span>) &#123; </div><div class=\"line\">       buffer.append(buf, <span class=\"number\">0</span>, count); </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   reader.close(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"String与byte\"><a href=\"#String与byte\" class=\"headerlink\" title=\"String与byte[]\"></a><strong>String与byte[]</strong></h4></li>\n</ul>\n<p>利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"string\">\"中\"</span>;  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为系统默认编码的字节数组</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = str.getBytes();  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 </span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = str.getBytes(<span class=\"string\">\"ISO-8859-1\"</span>);</div><div class=\"line\"><span class=\"comment\">// 正常显示中    </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes1));  </div><div class=\"line\"><span class=\"comment\">// 输出\"?\"      </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes2));</div></pre></td></tr></table></figure>\n<p>利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes = &#123;(<span class=\"keyword\">byte</span>)<span class=\"number\">0xD6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0xD0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0x31</span>&#125;;  </div><div class=\"line\"><span class=\"comment\">// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符</span></div><div class=\"line\">String str1 = <span class=\"keyword\">new</span> String(bytes);                      </div><div class=\"line\"><span class=\"comment\">// 将bytes按照ISO-8859-1解码，产生Unicode字符</span></div><div class=\"line\">String str2= <span class=\"keyword\">new</span> String(bytes,<span class=\"string\">\"ISO-8859-1\"</span>);          </div><div class=\"line\"><span class=\"comment\">// 中1  将Unicode字符转换为GBK编码输出</span></div><div class=\"line\">System.out.println(str1);                             </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\"> *在ISO-8859-1编码方式中没有对应0xD6和0xD0</div><div class=\"line\"> *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”</div><div class=\"line\"> *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。</div><div class=\"line\"> */</span> </div><div class=\"line\">System.out.println(str2);    <span class=\"comment\">// ??1</span></div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"CharSet\"><a href=\"#CharSet\" class=\"headerlink\" title=\"CharSet\"></a><strong>CharSet</strong></h4></li>\n</ul>\n<p>从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(<span class=\"string\">\"UTF-8\"</span>);   </div><div class=\"line\">ByteBuffer byteBuffer = charset.encode(string);   </div><div class=\"line\">CharBuffer charBuffer = charset.decode(byteBuffer);</div></pre></td></tr></table></figure>\n<h2 id=\"延伸-byte\"><a href=\"#延伸-byte\" class=\"headerlink\" title=\"延伸 byte\"></a>延伸 byte</h2><p>字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。</p>\n<p>无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。</p>\n<p>有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://cenalulu.github.io/linux/character-encoding/\">十分钟搞清字符集和字符编码</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\">字符编码笔记：ASCII，Unicode和UTF-8</a></p>\n<p><a href=\"http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html\">java编码转换过程</a></p>\n<p><a href=\"http://blog.csdn.net/mazhimazh/article/details/19327421\">Java 7之基础 - 编码与解码</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/\">深入分析 Java 中的中文编码问题</a></p>"},{"layout":"post","title":"java代理机制","date":"2017-03-28T08:15:35.000Z","_content":"## 代理模式\n\n代理模式，顾名思义，即一个客户不想或者不能直接访问一个对象，需要通过一个称为代理的第三方对象来实现间接引用。代理对象的作用就是客户端和目标对象\n之间的一个中介，通过代理对象可以隐藏不让用户看到的内容或实现额外的服务。\n\n代理机制应用的场景有很多：比如在代理对象中实现缓存，验证，权限控制等功能，真正的业务逻辑封装在真实对象中。RMI远程方法调用也用到了代理。当你调用一个远程方法的时候，相当于调用这个方法的代理对象，\n在代理对象中封装了网络请求等部分，真实对象存在于另一个进程上。重构老旧代码的时候也常常会用到代理模式。\n\n代理分两种：静态代理和动态代理\n\n## 静态代理\n\n静态代理即在代码中手动实现代理模式。代理模式涉及到三个角色：\n\n真实对象RealSubject、抽象主题Subject、代理对象Proxy\n\n{% asset_img Proxy.jpg Proxy %}\n\n{% asset_img seq_Proxy.jpg seq_Proxy %}\n\n<!-- more -->\n\n```\npublic class ProxyTest {\n\tpublic static void main(String[] args) {\n\t\tnew Proxy(\"hello\").request();\n\t}\n}\ninterface Subject {\n\tvoid request();\n}\nclass Proxy implements Subject{\n\tString str;\n\tRealSubject subject;\n\tpublic Proxy(String string) {\n\t\tstr = string;\n\t\tsubject = new RealSubject(str);\n\t}\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"代理对象验证机制....\");\n\t\tsubject.request();\n\t}\n\t\n}\n\nclass RealSubject implements Subject{\n\tString str;\n\tpublic RealSubject(String string) {\n\t\tstr = string;\n\t}\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"真实对象打印str: \" + str);\n\t}\n\t\n}\n```\n输出：\n```\n代理对象验证机制....\n真实对象打印str: hello\n```\n上面的代码模拟了一个代理对象实现验证机制的过程。可以看到，代码很简单，代理模式也很好理解。\n（我们在真实生活中不也有代理么,,比如黄牛，帮你买到你买不到的火车票）\n\n## JDK动态代理实现\n\n动态代理时较为高级的一种代理模式。典型的应用有Spring AOP，RMI。\n\n在上面的静态代理模式中，真实对象是事先存在的，并且作为代理对象的内部成员属性。一个真实的对象必须对应一个代理对象，如果真实对象很多的话会导致类膨胀。\n\n另外，如何在事先不知道真实对象的情况下使用代理代理对象，这都是动态代理需要解决的问题。\n\n比如有n个类需要在执行前打印几行日志，而这n个类是无法通过源代码修改的(从jar包中引入的)。通过静态代理实现的话将会有n个新的代理类产生，而使用动态代理的话，只需一个类即可。\n\n动态代理的实现方式有很多，我们只讨论JDK中的动态代理实现。\n\n```\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class DynamicProxyTest {\n\tpublic static void main(String[] args) {\n\t\tSubject subject = (Subject) new DynamicProxy().bind(new RealSubject(\"hello\"));\n\t\tsubject.request();\n\t}\n}\n\ninterface Subject {\n\tvoid request();\n}\n\nclass RealSubject implements Subject{\n\tString str;\n\tpublic RealSubject(String string) {\n\t\tstr = string;\n\t}\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"真实对象打印str: \" + str);\n\t}\n}\n\nclass DynamicProxy implements InvocationHandler {\n\tObject object;\n\tpublic Object bind(Object object) {\n\t\tthis.object = object;\n\t\treturn Proxy.newProxyInstance(object.getClass().getClassLoader(), \n\t\t\t\tobject.getClass().getInterfaces(), this);\n\t}\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\tSystem.out.println(\"代理对象验证...\");\n\t\treturn method.invoke(object, args);\n\t}\n}\n```\n输出：\n```\n代理对象验证...\n真实对象打印str: hello\n```\n可以看到，动态代理实现了与静态代理一样的功能，但他的优点在于代理的真实对象不是确定的，可以在运行时指定，增大了灵活性。如果我们有很多的真实对象需要代理访问，并且他们代理对象中的内容\n都实现了相同的功能，那么我们只需要一个动态代理类即可。\n\n## 动态代理原理\n\n我们通过观察java.lang.reflect.Proxy的源码来了解动态代理的原理。下面的代码截取自openjdk7-b147 (安利一个不错的搜索java源码的网站:http://grepcode.com)\n\n{% asset_img 1.png Proxy %}\n\n上面的方法截取自Proxy.newProxyInstance，可以看到，调用getProxyClass方法获取到一个代理类class对象，然后使用该class对象通过反射方法实例化一个对象返回。\n\n接下来观察getProxyClass方法。\n\n{% asset_img 2.png Proxy %}\n\n这部分代码截取自getProxyClass，先从缓存中查询是否已经生成过对应的class，若有，则直接返回该对象，没有，则继续下一步生成class\n\n{% asset_img 3.png Proxy %}\n\n这部分代码是代理类class对象的生成过程。其中：\n\n`byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);`这行代码调用ProxyGenerator.generateProxyClass返回了代理类class对象的字节码byte序列，\n`proxyClass = defineClass0(loader, proxyName,proxyClassFile, 0, proxyClassFile.length);`这一行则进行了类加载的工作，最终生成了代理类class对象。\n\n{% asset_img 4.png Proxy %}\n\ngenerateProxyClass，其中的gen.generateClassFile()方法实现了字节码的生成。\n\n{% asset_img 5.png Proxy %}\n\ngenerateClassFile方法的实现。开头调用的三个addProxyMethod方法将object类中的hashcode、equals、toString方法重写，故对这三个方法的调用会传递到InvocationHandler.invoke方法当中。\n注意，除了上述三个方法之外，调用代理类中Object定义的其他方法不会传递到invoke方法当中，也就是说，调用这些方法会执行Object中的默认实现。\n\n如果想要查看ProxyGenerator.generateProxyClass这个方法在运行时产生的代理类中写了些什么，可以在main方法中加入：\n\n```\nSystem.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");\n```\n\n运行时会将生成的class文件保存到硬盘当中：$Proxy0.class\n\n```\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\n\npublic final class $Proxy0\n  extends Proxy\n  implements Subject\n{\n  private static Method m1;\n  private static Method m3;\n  private static Method m0;\n  private static Method m2;\n  \n  public $Proxy0(InvocationHandler paramInvocationHandler)\n  {\n    super(paramInvocationHandler);\n  }\n  \n  public final boolean equals(Object paramObject)\n  {\n    try\n    {\n      return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue();\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final void request()\n  {\n    try\n    {\n      this.h.invoke(this, m3, null);\n      return;\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final int hashCode()\n  {\n    try\n    {\n      return ((Integer)this.h.invoke(this, m0, null)).intValue();\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final String toString()\n  {\n    try\n    {\n      return (String)this.h.invoke(this, m2, null);\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  static\n  {\n    try\n    {\n      m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] { Class.forName(\"java.lang.Object\") });\n      m3 = Class.forName(\"Subject\").getMethod(\"request\", new Class[0]);\n      m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]);\n      m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]);\n      return;\n    }\n    catch (NoSuchMethodException localNoSuchMethodException)\n    {\n      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());\n    }\n    catch (ClassNotFoundException localClassNotFoundException)\n    {\n      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());\n    }\n  }\n}\n```\n上面的代码很好理解。可以看到equals、hashCode、toString以及我们Subject接口request方法的实现中都是调用了InvocationHandler.invoke方法，而这个InvocationHandler实例就是我们在Proxy.newProxyInstance中传入的对象。\n\n综上，可以看到实现动态代理的几个步骤：\n\n1.实现InvocationHandler\n\n2.获得动态代理类，这一步又涉及到运行时代理类字节码的生成和类加载\n\n3.通过反射机制（getConstructor(InvocationHandler.class)）获取代理类的实例并返回该对象\n\n4.调用代理对象的目标方法（也就是request方法，代理类也实现了Subject这个接口），调用转发到InvocationHandler.invoke方法当中，执行invoke的逻辑（我们自己的InvocationHandler实现）\n\n至此，我们就了解了动态代理的运行原理。动态代理的机制也有一些缺陷，比如他代理的必须是接口方法。看一下我们上面生成的$Proxy0.class，可知这个代理类已经默认继承了类Proxy，所以，他只能通过实现我们提供的接口来代理我们的方法。在invoke方法中，我们可以通过对传入的代理类、方法和参数来进行判断，对不同的方法实现不同的业务逻辑。\n","source":"_posts/java代理机制.md","raw":"---\nlayout: post\ntitle: java代理机制\ndate: 2017-03-28 16:15:35\ncategories: 编程\ntags: java\n---\n## 代理模式\n\n代理模式，顾名思义，即一个客户不想或者不能直接访问一个对象，需要通过一个称为代理的第三方对象来实现间接引用。代理对象的作用就是客户端和目标对象\n之间的一个中介，通过代理对象可以隐藏不让用户看到的内容或实现额外的服务。\n\n代理机制应用的场景有很多：比如在代理对象中实现缓存，验证，权限控制等功能，真正的业务逻辑封装在真实对象中。RMI远程方法调用也用到了代理。当你调用一个远程方法的时候，相当于调用这个方法的代理对象，\n在代理对象中封装了网络请求等部分，真实对象存在于另一个进程上。重构老旧代码的时候也常常会用到代理模式。\n\n代理分两种：静态代理和动态代理\n\n## 静态代理\n\n静态代理即在代码中手动实现代理模式。代理模式涉及到三个角色：\n\n真实对象RealSubject、抽象主题Subject、代理对象Proxy\n\n{% asset_img Proxy.jpg Proxy %}\n\n{% asset_img seq_Proxy.jpg seq_Proxy %}\n\n<!-- more -->\n\n```\npublic class ProxyTest {\n\tpublic static void main(String[] args) {\n\t\tnew Proxy(\"hello\").request();\n\t}\n}\ninterface Subject {\n\tvoid request();\n}\nclass Proxy implements Subject{\n\tString str;\n\tRealSubject subject;\n\tpublic Proxy(String string) {\n\t\tstr = string;\n\t\tsubject = new RealSubject(str);\n\t}\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"代理对象验证机制....\");\n\t\tsubject.request();\n\t}\n\t\n}\n\nclass RealSubject implements Subject{\n\tString str;\n\tpublic RealSubject(String string) {\n\t\tstr = string;\n\t}\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"真实对象打印str: \" + str);\n\t}\n\t\n}\n```\n输出：\n```\n代理对象验证机制....\n真实对象打印str: hello\n```\n上面的代码模拟了一个代理对象实现验证机制的过程。可以看到，代码很简单，代理模式也很好理解。\n（我们在真实生活中不也有代理么,,比如黄牛，帮你买到你买不到的火车票）\n\n## JDK动态代理实现\n\n动态代理时较为高级的一种代理模式。典型的应用有Spring AOP，RMI。\n\n在上面的静态代理模式中，真实对象是事先存在的，并且作为代理对象的内部成员属性。一个真实的对象必须对应一个代理对象，如果真实对象很多的话会导致类膨胀。\n\n另外，如何在事先不知道真实对象的情况下使用代理代理对象，这都是动态代理需要解决的问题。\n\n比如有n个类需要在执行前打印几行日志，而这n个类是无法通过源代码修改的(从jar包中引入的)。通过静态代理实现的话将会有n个新的代理类产生，而使用动态代理的话，只需一个类即可。\n\n动态代理的实现方式有很多，我们只讨论JDK中的动态代理实现。\n\n```\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class DynamicProxyTest {\n\tpublic static void main(String[] args) {\n\t\tSubject subject = (Subject) new DynamicProxy().bind(new RealSubject(\"hello\"));\n\t\tsubject.request();\n\t}\n}\n\ninterface Subject {\n\tvoid request();\n}\n\nclass RealSubject implements Subject{\n\tString str;\n\tpublic RealSubject(String string) {\n\t\tstr = string;\n\t}\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"真实对象打印str: \" + str);\n\t}\n}\n\nclass DynamicProxy implements InvocationHandler {\n\tObject object;\n\tpublic Object bind(Object object) {\n\t\tthis.object = object;\n\t\treturn Proxy.newProxyInstance(object.getClass().getClassLoader(), \n\t\t\t\tobject.getClass().getInterfaces(), this);\n\t}\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\tSystem.out.println(\"代理对象验证...\");\n\t\treturn method.invoke(object, args);\n\t}\n}\n```\n输出：\n```\n代理对象验证...\n真实对象打印str: hello\n```\n可以看到，动态代理实现了与静态代理一样的功能，但他的优点在于代理的真实对象不是确定的，可以在运行时指定，增大了灵活性。如果我们有很多的真实对象需要代理访问，并且他们代理对象中的内容\n都实现了相同的功能，那么我们只需要一个动态代理类即可。\n\n## 动态代理原理\n\n我们通过观察java.lang.reflect.Proxy的源码来了解动态代理的原理。下面的代码截取自openjdk7-b147 (安利一个不错的搜索java源码的网站:http://grepcode.com)\n\n{% asset_img 1.png Proxy %}\n\n上面的方法截取自Proxy.newProxyInstance，可以看到，调用getProxyClass方法获取到一个代理类class对象，然后使用该class对象通过反射方法实例化一个对象返回。\n\n接下来观察getProxyClass方法。\n\n{% asset_img 2.png Proxy %}\n\n这部分代码截取自getProxyClass，先从缓存中查询是否已经生成过对应的class，若有，则直接返回该对象，没有，则继续下一步生成class\n\n{% asset_img 3.png Proxy %}\n\n这部分代码是代理类class对象的生成过程。其中：\n\n`byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);`这行代码调用ProxyGenerator.generateProxyClass返回了代理类class对象的字节码byte序列，\n`proxyClass = defineClass0(loader, proxyName,proxyClassFile, 0, proxyClassFile.length);`这一行则进行了类加载的工作，最终生成了代理类class对象。\n\n{% asset_img 4.png Proxy %}\n\ngenerateProxyClass，其中的gen.generateClassFile()方法实现了字节码的生成。\n\n{% asset_img 5.png Proxy %}\n\ngenerateClassFile方法的实现。开头调用的三个addProxyMethod方法将object类中的hashcode、equals、toString方法重写，故对这三个方法的调用会传递到InvocationHandler.invoke方法当中。\n注意，除了上述三个方法之外，调用代理类中Object定义的其他方法不会传递到invoke方法当中，也就是说，调用这些方法会执行Object中的默认实现。\n\n如果想要查看ProxyGenerator.generateProxyClass这个方法在运行时产生的代理类中写了些什么，可以在main方法中加入：\n\n```\nSystem.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");\n```\n\n运行时会将生成的class文件保存到硬盘当中：$Proxy0.class\n\n```\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\n\npublic final class $Proxy0\n  extends Proxy\n  implements Subject\n{\n  private static Method m1;\n  private static Method m3;\n  private static Method m0;\n  private static Method m2;\n  \n  public $Proxy0(InvocationHandler paramInvocationHandler)\n  {\n    super(paramInvocationHandler);\n  }\n  \n  public final boolean equals(Object paramObject)\n  {\n    try\n    {\n      return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue();\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final void request()\n  {\n    try\n    {\n      this.h.invoke(this, m3, null);\n      return;\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final int hashCode()\n  {\n    try\n    {\n      return ((Integer)this.h.invoke(this, m0, null)).intValue();\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  public final String toString()\n  {\n    try\n    {\n      return (String)this.h.invoke(this, m2, null);\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n  \n  static\n  {\n    try\n    {\n      m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] { Class.forName(\"java.lang.Object\") });\n      m3 = Class.forName(\"Subject\").getMethod(\"request\", new Class[0]);\n      m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]);\n      m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]);\n      return;\n    }\n    catch (NoSuchMethodException localNoSuchMethodException)\n    {\n      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());\n    }\n    catch (ClassNotFoundException localClassNotFoundException)\n    {\n      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());\n    }\n  }\n}\n```\n上面的代码很好理解。可以看到equals、hashCode、toString以及我们Subject接口request方法的实现中都是调用了InvocationHandler.invoke方法，而这个InvocationHandler实例就是我们在Proxy.newProxyInstance中传入的对象。\n\n综上，可以看到实现动态代理的几个步骤：\n\n1.实现InvocationHandler\n\n2.获得动态代理类，这一步又涉及到运行时代理类字节码的生成和类加载\n\n3.通过反射机制（getConstructor(InvocationHandler.class)）获取代理类的实例并返回该对象\n\n4.调用代理对象的目标方法（也就是request方法，代理类也实现了Subject这个接口），调用转发到InvocationHandler.invoke方法当中，执行invoke的逻辑（我们自己的InvocationHandler实现）\n\n至此，我们就了解了动态代理的运行原理。动态代理的机制也有一些缺陷，比如他代理的必须是接口方法。看一下我们上面生成的$Proxy0.class，可知这个代理类已经默认继承了类Proxy，所以，他只能通过实现我们提供的接口来代理我们的方法。在invoke方法中，我们可以通过对传入的代理类、方法和参数来进行判断，对不同的方法实现不同的业务逻辑。\n","slug":"java代理机制","published":1,"updated":"2017-04-11T13:08:38.840Z","comments":1,"photos":[],"link":"","_id":"cj4vch4ei001nx3gc6pg6nwgy","content":"<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>代理模式，顾名思义，即一个客户不想或者不能直接访问一个对象，需要通过一个称为代理的第三方对象来实现间接引用。代理对象的作用就是客户端和目标对象<br>之间的一个中介，通过代理对象可以隐藏不让用户看到的内容或实现额外的服务。</p>\n<p>代理机制应用的场景有很多：比如在代理对象中实现缓存，验证，权限控制等功能，真正的业务逻辑封装在真实对象中。RMI远程方法调用也用到了代理。当你调用一个远程方法的时候，相当于调用这个方法的代理对象，<br>在代理对象中封装了网络请求等部分，真实对象存在于另一个进程上。重构老旧代码的时候也常常会用到代理模式。</p>\n<p>代理分两种：静态代理和动态代理</p>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><p>静态代理即在代码中手动实现代理模式。代理模式涉及到三个角色：</p>\n<p>真实对象RealSubject、抽象主题Subject、代理对象Proxy</p>\n<img src=\"/2017/03/28/java代理机制/Proxy.jpg\" alt=\"Proxy\" title=\"Proxy\">\n<img src=\"/2017/03/28/java代理机制/seq_Proxy.jpg\" alt=\"seq_Proxy\" title=\"seq_Proxy\">\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ProxyTest &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tnew Proxy(&quot;hello&quot;).request();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">interface Subject &#123;</div><div class=\"line\">\tvoid request();</div><div class=\"line\">&#125;</div><div class=\"line\">class Proxy implements Subject&#123;</div><div class=\"line\">\tString str;</div><div class=\"line\">\tRealSubject subject;</div><div class=\"line\">\tpublic Proxy(String string) &#123;</div><div class=\"line\">\t\tstr = string;</div><div class=\"line\">\t\tsubject = new RealSubject(str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void request() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;代理对象验证机制....&quot;);</div><div class=\"line\">\t\tsubject.request();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class RealSubject implements Subject&#123;</div><div class=\"line\">\tString str;</div><div class=\"line\">\tpublic RealSubject(String string) &#123;</div><div class=\"line\">\t\tstr = string;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void request() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;真实对象打印str: &quot; + str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">代理对象验证机制....</div><div class=\"line\">真实对象打印str: hello</div></pre></td></tr></table></figure></p>\n<p>上面的代码模拟了一个代理对象实现验证机制的过程。可以看到，代码很简单，代理模式也很好理解。<br>（我们在真实生活中不也有代理么,,比如黄牛，帮你买到你买不到的火车票）</p>\n<h2 id=\"JDK动态代理实现\"><a href=\"#JDK动态代理实现\" class=\"headerlink\" title=\"JDK动态代理实现\"></a>JDK动态代理实现</h2><p>动态代理时较为高级的一种代理模式。典型的应用有Spring AOP，RMI。</p>\n<p>在上面的静态代理模式中，真实对象是事先存在的，并且作为代理对象的内部成员属性。一个真实的对象必须对应一个代理对象，如果真实对象很多的话会导致类膨胀。</p>\n<p>另外，如何在事先不知道真实对象的情况下使用代理代理对象，这都是动态代理需要解决的问题。</p>\n<p>比如有n个类需要在执行前打印几行日志，而这n个类是无法通过源代码修改的(从jar包中引入的)。通过静态代理实现的话将会有n个新的代理类产生，而使用动态代理的话，只需一个类即可。</p>\n<p>动态代理的实现方式有很多，我们只讨论JDK中的动态代理实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">import java.lang.reflect.InvocationHandler;</div><div class=\"line\">import java.lang.reflect.Method;</div><div class=\"line\">import java.lang.reflect.Proxy;</div><div class=\"line\"></div><div class=\"line\">public class DynamicProxyTest &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tSubject subject = (Subject) new DynamicProxy().bind(new RealSubject(&quot;hello&quot;));</div><div class=\"line\">\t\tsubject.request();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">interface Subject &#123;</div><div class=\"line\">\tvoid request();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class RealSubject implements Subject&#123;</div><div class=\"line\">\tString str;</div><div class=\"line\">\tpublic RealSubject(String string) &#123;</div><div class=\"line\">\t\tstr = string;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void request() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;真实对象打印str: &quot; + str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class DynamicProxy implements InvocationHandler &#123;</div><div class=\"line\">\tObject object;</div><div class=\"line\">\tpublic Object bind(Object object) &#123;</div><div class=\"line\">\t\tthis.object = object;</div><div class=\"line\">\t\treturn Proxy.newProxyInstance(object.getClass().getClassLoader(), </div><div class=\"line\">\t\t\t\tobject.getClass().getInterfaces(), this);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic Object invoke(Object proxy, Method method, Object[] args)</div><div class=\"line\">\t\t\tthrows Throwable &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;代理对象验证...&quot;);</div><div class=\"line\">\t\treturn method.invoke(object, args);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">代理对象验证...</div><div class=\"line\">真实对象打印str: hello</div></pre></td></tr></table></figure></p>\n<p>可以看到，动态代理实现了与静态代理一样的功能，但他的优点在于代理的真实对象不是确定的，可以在运行时指定，增大了灵活性。如果我们有很多的真实对象需要代理访问，并且他们代理对象中的内容<br>都实现了相同的功能，那么我们只需要一个动态代理类即可。</p>\n<h2 id=\"动态代理原理\"><a href=\"#动态代理原理\" class=\"headerlink\" title=\"动态代理原理\"></a>动态代理原理</h2><p>我们通过观察java.lang.reflect.Proxy的源码来了解动态代理的原理。下面的代码截取自openjdk7-b147 (安利一个不错的搜索java源码的网站:<a href=\"http://grepcode.com\" target=\"_blank\" rel=\"external\">http://grepcode.com</a>)</p>\n<img src=\"/2017/03/28/java代理机制/1.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>上面的方法截取自Proxy.newProxyInstance，可以看到，调用getProxyClass方法获取到一个代理类class对象，然后使用该class对象通过反射方法实例化一个对象返回。</p>\n<p>接下来观察getProxyClass方法。</p>\n<img src=\"/2017/03/28/java代理机制/2.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>这部分代码截取自getProxyClass，先从缓存中查询是否已经生成过对应的class，若有，则直接返回该对象，没有，则继续下一步生成class</p>\n<img src=\"/2017/03/28/java代理机制/3.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>这部分代码是代理类class对象的生成过程。其中：</p>\n<p><code>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);</code>这行代码调用ProxyGenerator.generateProxyClass返回了代理类class对象的字节码byte序列，<br><code>proxyClass = defineClass0(loader, proxyName,proxyClassFile, 0, proxyClassFile.length);</code>这一行则进行了类加载的工作，最终生成了代理类class对象。</p>\n<img src=\"/2017/03/28/java代理机制/4.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>generateProxyClass，其中的gen.generateClassFile()方法实现了字节码的生成。</p>\n<img src=\"/2017/03/28/java代理机制/5.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>generateClassFile方法的实现。开头调用的三个addProxyMethod方法将object类中的hashcode、equals、toString方法重写，故对这三个方法的调用会传递到InvocationHandler.invoke方法当中。<br>注意，除了上述三个方法之外，调用代理类中Object定义的其他方法不会传递到invoke方法当中，也就是说，调用这些方法会执行Object中的默认实现。</p>\n<p>如果想要查看ProxyGenerator.generateProxyClass这个方法在运行时产生的代理类中写了些什么，可以在main方法中加入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</div></pre></td></tr></table></figure>\n<p>运行时会将生成的class文件保存到硬盘当中：$Proxy0.class</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div></pre></td><td class=\"code\"><pre><div class=\"line\">import java.lang.reflect.InvocationHandler;</div><div class=\"line\">import java.lang.reflect.Method;</div><div class=\"line\">import java.lang.reflect.Proxy;</div><div class=\"line\">import java.lang.reflect.UndeclaredThrowableException;</div><div class=\"line\"></div><div class=\"line\">public final class $Proxy0</div><div class=\"line\">  extends Proxy</div><div class=\"line\">  implements Subject</div><div class=\"line\">&#123;</div><div class=\"line\">  private static Method m1;</div><div class=\"line\">  private static Method m3;</div><div class=\"line\">  private static Method m0;</div><div class=\"line\">  private static Method m2;</div><div class=\"line\">  </div><div class=\"line\">  public $Proxy0(InvocationHandler paramInvocationHandler)</div><div class=\"line\">  &#123;</div><div class=\"line\">    super(paramInvocationHandler);</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final boolean equals(Object paramObject)</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final void request()</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      this.h.invoke(this, m3, null);</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final int hashCode()</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      return ((Integer)this.h.invoke(this, m0, null)).intValue();</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final String toString()</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      return (String)this.h.invoke(this, m2, null);</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  static</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</div><div class=\"line\">      m3 = Class.forName(&quot;Subject&quot;).getMethod(&quot;request&quot;, new Class[0]);</div><div class=\"line\">      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</div><div class=\"line\">      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (NoSuchMethodException localNoSuchMethodException)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (ClassNotFoundException localClassNotFoundException)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码很好理解。可以看到equals、hashCode、toString以及我们Subject接口request方法的实现中都是调用了InvocationHandler.invoke方法，而这个InvocationHandler实例就是我们在Proxy.newProxyInstance中传入的对象。</p>\n<p>综上，可以看到实现动态代理的几个步骤：</p>\n<p>1.实现InvocationHandler</p>\n<p>2.获得动态代理类，这一步又涉及到运行时代理类字节码的生成和类加载</p>\n<p>3.通过反射机制（getConstructor(InvocationHandler.class)）获取代理类的实例并返回该对象</p>\n<p>4.调用代理对象的目标方法（也就是request方法，代理类也实现了Subject这个接口），调用转发到InvocationHandler.invoke方法当中，执行invoke的逻辑（我们自己的InvocationHandler实现）</p>\n<p>至此，我们就了解了动态代理的运行原理。动态代理的机制也有一些缺陷，比如他代理的必须是接口方法。看一下我们上面生成的$Proxy0.class，可知这个代理类已经默认继承了类Proxy，所以，他只能通过实现我们提供的接口来代理我们的方法。在invoke方法中，我们可以通过对传入的代理类、方法和参数来进行判断，对不同的方法实现不同的业务逻辑。</p>\n","excerpt":"<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>代理模式，顾名思义，即一个客户不想或者不能直接访问一个对象，需要通过一个称为代理的第三方对象来实现间接引用。代理对象的作用就是客户端和目标对象<br>之间的一个中介，通过代理对象可以隐藏不让用户看到的内容或实现额外的服务。</p>\n<p>代理机制应用的场景有很多：比如在代理对象中实现缓存，验证，权限控制等功能，真正的业务逻辑封装在真实对象中。RMI远程方法调用也用到了代理。当你调用一个远程方法的时候，相当于调用这个方法的代理对象，<br>在代理对象中封装了网络请求等部分，真实对象存在于另一个进程上。重构老旧代码的时候也常常会用到代理模式。</p>\n<p>代理分两种：静态代理和动态代理</p>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><p>静态代理即在代码中手动实现代理模式。代理模式涉及到三个角色：</p>\n<p>真实对象RealSubject、抽象主题Subject、代理对象Proxy</p>\n<img src=\"/2017/03/28/java代理机制/Proxy.jpg\" alt=\"Proxy\" title=\"Proxy\">\n<img src=\"/2017/03/28/java代理机制/seq_Proxy.jpg\" alt=\"seq_Proxy\" title=\"seq_Proxy\">","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ProxyTest &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tnew Proxy(&quot;hello&quot;).request();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">interface Subject &#123;</div><div class=\"line\">\tvoid request();</div><div class=\"line\">&#125;</div><div class=\"line\">class Proxy implements Subject&#123;</div><div class=\"line\">\tString str;</div><div class=\"line\">\tRealSubject subject;</div><div class=\"line\">\tpublic Proxy(String string) &#123;</div><div class=\"line\">\t\tstr = string;</div><div class=\"line\">\t\tsubject = new RealSubject(str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void request() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;代理对象验证机制....&quot;);</div><div class=\"line\">\t\tsubject.request();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class RealSubject implements Subject&#123;</div><div class=\"line\">\tString str;</div><div class=\"line\">\tpublic RealSubject(String string) &#123;</div><div class=\"line\">\t\tstr = string;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void request() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;真实对象打印str: &quot; + str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">代理对象验证机制....</div><div class=\"line\">真实对象打印str: hello</div></pre></td></tr></table></figure></p>\n<p>上面的代码模拟了一个代理对象实现验证机制的过程。可以看到，代码很简单，代理模式也很好理解。<br>（我们在真实生活中不也有代理么,,比如黄牛，帮你买到你买不到的火车票）</p>\n<h2 id=\"JDK动态代理实现\"><a href=\"#JDK动态代理实现\" class=\"headerlink\" title=\"JDK动态代理实现\"></a>JDK动态代理实现</h2><p>动态代理时较为高级的一种代理模式。典型的应用有Spring AOP，RMI。</p>\n<p>在上面的静态代理模式中，真实对象是事先存在的，并且作为代理对象的内部成员属性。一个真实的对象必须对应一个代理对象，如果真实对象很多的话会导致类膨胀。</p>\n<p>另外，如何在事先不知道真实对象的情况下使用代理代理对象，这都是动态代理需要解决的问题。</p>\n<p>比如有n个类需要在执行前打印几行日志，而这n个类是无法通过源代码修改的(从jar包中引入的)。通过静态代理实现的话将会有n个新的代理类产生，而使用动态代理的话，只需一个类即可。</p>\n<p>动态代理的实现方式有很多，我们只讨论JDK中的动态代理实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">import java.lang.reflect.InvocationHandler;</div><div class=\"line\">import java.lang.reflect.Method;</div><div class=\"line\">import java.lang.reflect.Proxy;</div><div class=\"line\"></div><div class=\"line\">public class DynamicProxyTest &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tSubject subject = (Subject) new DynamicProxy().bind(new RealSubject(&quot;hello&quot;));</div><div class=\"line\">\t\tsubject.request();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">interface Subject &#123;</div><div class=\"line\">\tvoid request();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class RealSubject implements Subject&#123;</div><div class=\"line\">\tString str;</div><div class=\"line\">\tpublic RealSubject(String string) &#123;</div><div class=\"line\">\t\tstr = string;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void request() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;真实对象打印str: &quot; + str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class DynamicProxy implements InvocationHandler &#123;</div><div class=\"line\">\tObject object;</div><div class=\"line\">\tpublic Object bind(Object object) &#123;</div><div class=\"line\">\t\tthis.object = object;</div><div class=\"line\">\t\treturn Proxy.newProxyInstance(object.getClass().getClassLoader(), </div><div class=\"line\">\t\t\t\tobject.getClass().getInterfaces(), this);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic Object invoke(Object proxy, Method method, Object[] args)</div><div class=\"line\">\t\t\tthrows Throwable &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;代理对象验证...&quot;);</div><div class=\"line\">\t\treturn method.invoke(object, args);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">代理对象验证...</div><div class=\"line\">真实对象打印str: hello</div></pre></td></tr></table></figure></p>\n<p>可以看到，动态代理实现了与静态代理一样的功能，但他的优点在于代理的真实对象不是确定的，可以在运行时指定，增大了灵活性。如果我们有很多的真实对象需要代理访问，并且他们代理对象中的内容<br>都实现了相同的功能，那么我们只需要一个动态代理类即可。</p>\n<h2 id=\"动态代理原理\"><a href=\"#动态代理原理\" class=\"headerlink\" title=\"动态代理原理\"></a>动态代理原理</h2><p>我们通过观察java.lang.reflect.Proxy的源码来了解动态代理的原理。下面的代码截取自openjdk7-b147 (安利一个不错的搜索java源码的网站:<a href=\"http://grepcode.com\">http://grepcode.com</a>)</p>\n<img src=\"/2017/03/28/java代理机制/1.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>上面的方法截取自Proxy.newProxyInstance，可以看到，调用getProxyClass方法获取到一个代理类class对象，然后使用该class对象通过反射方法实例化一个对象返回。</p>\n<p>接下来观察getProxyClass方法。</p>\n<img src=\"/2017/03/28/java代理机制/2.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>这部分代码截取自getProxyClass，先从缓存中查询是否已经生成过对应的class，若有，则直接返回该对象，没有，则继续下一步生成class</p>\n<img src=\"/2017/03/28/java代理机制/3.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>这部分代码是代理类class对象的生成过程。其中：</p>\n<p><code>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);</code>这行代码调用ProxyGenerator.generateProxyClass返回了代理类class对象的字节码byte序列，<br><code>proxyClass = defineClass0(loader, proxyName,proxyClassFile, 0, proxyClassFile.length);</code>这一行则进行了类加载的工作，最终生成了代理类class对象。</p>\n<img src=\"/2017/03/28/java代理机制/4.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>generateProxyClass，其中的gen.generateClassFile()方法实现了字节码的生成。</p>\n<img src=\"/2017/03/28/java代理机制/5.png\" alt=\"Proxy\" title=\"Proxy\">\n<p>generateClassFile方法的实现。开头调用的三个addProxyMethod方法将object类中的hashcode、equals、toString方法重写，故对这三个方法的调用会传递到InvocationHandler.invoke方法当中。<br>注意，除了上述三个方法之外，调用代理类中Object定义的其他方法不会传递到invoke方法当中，也就是说，调用这些方法会执行Object中的默认实现。</p>\n<p>如果想要查看ProxyGenerator.generateProxyClass这个方法在运行时产生的代理类中写了些什么，可以在main方法中加入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</div></pre></td></tr></table></figure>\n<p>运行时会将生成的class文件保存到硬盘当中：$Proxy0.class</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div></pre></td><td class=\"code\"><pre><div class=\"line\">import java.lang.reflect.InvocationHandler;</div><div class=\"line\">import java.lang.reflect.Method;</div><div class=\"line\">import java.lang.reflect.Proxy;</div><div class=\"line\">import java.lang.reflect.UndeclaredThrowableException;</div><div class=\"line\"></div><div class=\"line\">public final class $Proxy0</div><div class=\"line\">  extends Proxy</div><div class=\"line\">  implements Subject</div><div class=\"line\">&#123;</div><div class=\"line\">  private static Method m1;</div><div class=\"line\">  private static Method m3;</div><div class=\"line\">  private static Method m0;</div><div class=\"line\">  private static Method m2;</div><div class=\"line\">  </div><div class=\"line\">  public $Proxy0(InvocationHandler paramInvocationHandler)</div><div class=\"line\">  &#123;</div><div class=\"line\">    super(paramInvocationHandler);</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final boolean equals(Object paramObject)</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final void request()</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      this.h.invoke(this, m3, null);</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final int hashCode()</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      return ((Integer)this.h.invoke(this, m0, null)).intValue();</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  public final String toString()</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      return (String)this.h.invoke(this, m2, null);</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Error|RuntimeException localError)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw localError;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Throwable localThrowable)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  static</div><div class=\"line\">  &#123;</div><div class=\"line\">    try</div><div class=\"line\">    &#123;</div><div class=\"line\">      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</div><div class=\"line\">      m3 = Class.forName(&quot;Subject&quot;).getMethod(&quot;request&quot;, new Class[0]);</div><div class=\"line\">      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</div><div class=\"line\">      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (NoSuchMethodException localNoSuchMethodException)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (ClassNotFoundException localClassNotFoundException)</div><div class=\"line\">    &#123;</div><div class=\"line\">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码很好理解。可以看到equals、hashCode、toString以及我们Subject接口request方法的实现中都是调用了InvocationHandler.invoke方法，而这个InvocationHandler实例就是我们在Proxy.newProxyInstance中传入的对象。</p>\n<p>综上，可以看到实现动态代理的几个步骤：</p>\n<p>1.实现InvocationHandler</p>\n<p>2.获得动态代理类，这一步又涉及到运行时代理类字节码的生成和类加载</p>\n<p>3.通过反射机制（getConstructor(InvocationHandler.class)）获取代理类的实例并返回该对象</p>\n<p>4.调用代理对象的目标方法（也就是request方法，代理类也实现了Subject这个接口），调用转发到InvocationHandler.invoke方法当中，执行invoke的逻辑（我们自己的InvocationHandler实现）</p>\n<p>至此，我们就了解了动态代理的运行原理。动态代理的机制也有一些缺陷，比如他代理的必须是接口方法。看一下我们上面生成的$Proxy0.class，可知这个代理类已经默认继承了类Proxy，所以，他只能通过实现我们提供的接口来代理我们的方法。在invoke方法中，我们可以通过对传入的代理类、方法和参数来进行判断，对不同的方法实现不同的业务逻辑。</p>"},{"layout":"post","title":"java任务取消","date":"2017-05-02T11:45:14.000Z","_content":"> 最近在用思维导图做读书笔记，虽然感觉没有网上所说的那么神奇，但是用来做笔记还是可以的。总结梳理了一下java取消任务执方面的一些内容，也是《java并发编程实战》的读书笔记。\n\n{% asset_img java.png 任务取消 %}\n\n<!-- more -->\n\n## 取消原因\n\n取消一个任务执行的理由有很多，通常有以下几个\n\n- 用户请求取消\n\n  通常用户点击“取消”按钮发出取消命令\n\n- 有时间限制的操作\n\n  计时任务，超时时就会取消任务执行并返回\n\n- 应用程序逻辑\n\n  比如有多个任务对一个问题进行分解和搜索解决方案，如果其中某个任务找到解决方案，其他并行的任务就可以取消了\n\n- 发生错误\n\n  比如爬虫程序下载网页到本地硬盘，如果盘满了之后爬取任务应该被取消\n\n- 关闭\n\n  程序或服务被关闭，则正在执行的任务也应该取消，而不是继续执行\n\n\n## 取消线程执行\n\n任务的取消执行，其实最后都会落到线程的终止上(任务都是由线程来执行)。在java中没有一种安全的抢占式方法来终止线程(Thread.stop 是不安全的终止线程执行的方法，已经废弃掉了)，所以需要一种很好的协作机制来平滑的关闭任务。\n\n### 自然结束\n\n中断线程的最好方法是让代码自然执行到结束，而不是从外部强制打断他。为此可以设置一个“任务取消标志”，任务代码会定期的查看这个标志，如果发现标志被设定了，则任务提前结束。\n\n```java\npublic class SomeJob {\n\tprivate List<String> list = new ArrayList<>();\n\tprivate volatile boolean canceled = false;\n\n\tpublic void run() {\n\t\twhile (!canceled) {\n\t\t\tString res = getResult();\n\t\t\tsynchronized (this) {\n\t\t\t\tlist.add(res);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String getResult() {\n\t\t// do something...\n\t\treturn \"\";\n\t}\n\t\n\tpublic void cancel() {\n\t\tthis.canceled = true;\n\t}\n}\n```\n上面的代码中，设置了一个volatile类型的变量canceled，所以其他线程对这个变量的修改对所有线程都是可见的(可见性)。每次循环执行某个操作之前都会检查这个变量是否被其他线程设置为true，如果为true则提前退出。\n\n这是很常见的一种取消任务执行的手段，但是也有他的弊端，比如：\n\n```java\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class SomeJob {\n\tprivate BlockingQueue<String> list = new LinkedBlockingQueue<>(100);\n\tprivate volatile boolean canceled = false;\n\n\tpublic void run() {\n\t\ttry {\n\t\t\twhile (!canceled) {\n\t\t\t\tString res = getResult();\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tlist.put(res);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate String getResult() {\n\t\t// do something...\n\t\treturn \"\";\n\t}\n\n\tpublic void cancel() {\n\t\tthis.canceled = true;\n\t}\n}\n\n```\n上面将list替换为支持阻塞的BlockingQueue，他是一个有界队列，当调用list的put操作时，如果队列已经填满，那么将会一直阻塞直到队列有空余位置为止。如果恰好执行put操作是阻塞了，此时我们调用了cancel方法，那么什么时候检查canceled标志是不确定的，响应性很差，极端情况下，有可能永远也不会去再下一次轮询中检查canceled标志，试想我们执行了取消后，消费队列的线程已经停止，此时put操作又阻塞，那么将会一直阻塞下去，这个线程失去响应。\n\n### 线程中断\n\n通过线程自己的中断机制，可以解决上述问题。\n\n每个线程都有一个boolean类型的变量，表示中断状态。当中断线程时，这个线程的中断状态将被设置为true。在Thread中有三个方法可以设置或访问这个变量：\n\n- Thread.interrupt: 中断目标线程\n\n- Thread.isInterrupted: 返回线程的中断状态\n\n- Thread.interrupted: 清除线程的中断状态，并返回之前的值\n\n调用interrupt并不意味着立即停止目标线程正在进行的任务，而只是将中断状态设置为true：他并不会正真中断一个正在运行的线程，而只是发出了一种中断请求，线程可以看到这个中断状态，然后在合适的时刻处理。\n\n#### 中断请求\n\n##### 响应中断阻塞\n\n上面提到的中断请求，有些方法会处理这些请求，从而结束现在正在进行的任务。像上面代码中的BlockingQueue.put方法，当他在阻塞状态时，依然能够发现中断请求并提前返回，所以解决上面代码中的问题只需要对执行代码的线程thread调用thread.interrupt方法，BlockingQueue.put就可以从阻塞状态中恢复回来，从而完成取消。类似这样的支持中断的阻塞就叫做响应中断阻塞，主要有以下几个：\n\n- Thread.sleep \n\n- Object.wait\n\n- Thread.join\n\n这些支持中断的阻塞在响应中断时执行的操作包括：\n\n- 清除中断状态\n\n- 抛出InterruptedException，表示阻塞操作由于中断而提前结束\n\njvm并不能保证这些阻塞方法检测到中断的速度，但在实际情况中响应速度还是很快的。\n\n利用线程本身的中断状态作为取消机制，我们可以将上面的代码再改造一下：\n\n```java\npublic class SomeJob {\n\tprivate BlockingQueue<String> list = new LinkedBlockingQueue<>();\n\n\tpublic void run() {\n\t\ttry {\n\t\t\twhile (!Thread.currentThread().isInterrupted()) {\n\t\t\t\tString res = getResult();\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tlist.put(res);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\tSystem.out.println(\"任务被取消...\");\n\t\t}\n\t}\n\n\tprivate String getResult() {\n\t\t// do something...\n\t\treturn \"\";\n\t}\n\n\tpublic void cancel(Thread thread) {\n\t\tthread.interrupt();\n\t}\n}\n```\n任务代码在每次轮询操作前检查当前线程的状态，如果被中断了就退出。cancel方法是对当前执行任务的线程进行中断。\n\n注意，调用cancel方法的是另一线程，传入的线程实例则是执行run方法的工作者线程，故在执行cancel方法后run方法可以检测到中断。\n\n##### 不响应中断阻塞\n\n并非所有的阻塞方法和阻塞机制都能够响应中断请求，比如正在read或write上阻塞的socket就不会响应中断，调用线程的interrupt方法只能设置线程的中断状态，除此以外没有任何作用，因为这些阻塞方法并不会去检查线程中断状态，也不会处理中断。这些阻塞就是不响应中断阻塞。主要有以下几个：\n\n- java.io包中的同步socket io: 从socket中获取的InputStream和OutputStream中的read或write方法都不会响应中断，解决办法是关闭这个socket，使得正在执行read或write方法而被阻塞的线程抛出一个SocketException\n\n- java.io包中的同步IO: 当中断一个正在InterruptibleChannel上等待的线程时，将抛出ClosedByInterruptException并关闭链路。\n\n- Selector的异步IO: 如果一个线程在调用Selector.select方法时阻塞了，那么调用close或wakeup方法会使线程抛出ClosedSelectorException并返回\n\n- 获得某个锁: 如果一个线程由于等待某个内置锁而阻塞，将无法响应中断。Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。(BlockingQueue.put可以响应中断缘于此)\n\n一个简单的例子，取消socket任务：\n\n```java\npublic class CanceledThread extends Thread {\n\tprivate final Socket socket;\n\tprivate final InputStream stream;\n\tpublic CanceledThread(Socket socket) throws IOException {\n\t\tthis.socket = socket;\n\t\tthis.stream = socket.getInputStream();\n\t}\n\t@Override\n\tpublic void interrupt() {\n\t\ttry {\n\t\t\tsocket.close();\n\t\t} catch (Exception e) {\n\t\t\t// do nothing\n\t\t} finally {\n\t\t\tsuper.interrupt();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tbyte[] bytes = new byte[1024];\n\t\t\twhile (true) {\n\t\t\t\tint count = stream.read(bytes);\n\t\t\t\tif (count < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (count > 0) {\n\t\t\t\t\t// 处理读到 bytes\n\t\t\t\t}\n \t\t\t\t\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// 可能捕捉到InterruptedException 或 SocketException\n\t\t\t// 线程退出\n\t\t}\n\t}\n}\n\n```\n在上面的代码中，即使socket的stream在read过程中阻塞了，也可以中断阻塞并返回。\n\n#### 中断处理\n\n上文提到，当调用可中断的阻塞库函数时，会抛出InterruptedException，这个异常会出现在我们的任务代码中(任务代码调用了这些阻塞方法)，有三种方法处理这个异常：\n\n- 不处理，或者在捕捉到异常后打印日志以及做一些资源回收工作\n\n  确定我们的任务代码可以这么做时才这么做。这意味这这个任务完全可以在这个线程中取消，不必再向上层报告或需要更上层的代码处理。\n\n- 传递异常，从而使你的方法也成为可中断的阻塞方法\n\n  简单的将异常抛出，让上层代码处理，这意味着需要上层代码再做一些资源回收等工作。\n\n- 恢复中断状态，从而使调用栈中的上层代码能够对其进行处理\n\n  如果不想或无法(Runnable中)传递InterruptedException时，可以通过再次调用interrupt来恢复中断状态。此时上层代码就可以捕捉到这个中断，从而作出处理。\n\nThreadPoolExcutor就是处理中断的一个例子：当其拥有的工作者线程检测到中断时，他会检查线程池是否正在关闭。如果是，他会在结束前执行一些线程清理工作，否则他可能创建一个新线程将线程池恢复到合理的规模。\n\n## 取消任务\n\n### 终止线程池\n\n线程池的生命周期是由ExcutorService控制的。ExcutorService提供了两种关闭线程池的方法：\n\n- shutdownNow\n\n  强行关闭线程池，首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单(在任务队列当中的)\n\n  关闭速度快，但是有风险，正在执行中的任务可能在执行一半的时候被结束\n\n- shutdown\n\n  正常关闭线程池，一直等到队列中的所有任务都执行完后才关闭，在此期间不接受新任务\n\n  关闭速度慢，却更加安全\n\n### 终止基于线程的服务\n\n在写程序时往往会用到日志，在代码中插入println也是一种日志行为。为了避免由于日志为服务带来性能损耗和并发风险(多个线程同时打印日志有可能引发并发问题)，我们往往将打印日志任务放到某个队列中，由专门的线程从队列中取出任务进行打印。下面设计这样一个日志服务：\n\n```java\npublic class LogService {\n\tprivate final BlockingQueue<String> queue;\n\tprivate final PrintWriter writer;\n\tprivate final LoggerThread thread;\n\tprivate boolean isShutDown = false;\n\tprivate int reservations = 0;\n\n\tpublic LogService(PrintWriter writer) {\n\t\tthis.writer = writer;\n\t\tthread = new LoggerThread();\n\t\tqueue = new LinkedBlockingQueue<>();\n\t}\n\t\n\tpublic void shutdown() {\n\t\tsynchronized (this) {\n\t\t\tisShutDown = true;\n\t\t}\n\t\tthread.interrupt();\n\t}\n\t\n\tpublic void log(String msg) throws InterruptedException {\n\t\tsynchronized (this) {\n\t\t\tif (isShutDown) {\n\t\t\t\tthrow new IllegalStateException(\"日志服务已经关闭...\");\n\t\t\t}\n\t\t\treservations ++;\n\t\t}\n\t\tqueue.put(msg);\n\t}\n\n\tclass LoggerThread extends Thread {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsynchronized (LogService.this) {\n\t\t\t\t\t\t\tif (isShutDown && reservations == 0) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tString msg = queue.take();\n\t\t\t\t\t\t\tsynchronized (LogService.this) {\n\t\t\t\t\t\t\t\treservations--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twriter.println(msg);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t// retry\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\twriter.close();\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n当关闭日志服务时，日志服务不再会接收新的日志打印请求，并且会将队列中剩余的所有打印任务执行完毕，最后结束。如果此时日志打印线程恰好在queue.take方法中阻塞了，关闭日志服务时也能很好的从阻塞中恢复过来，结束服务。\n","source":"_posts/java任务取消.md","raw":"---\nlayout: post\ntitle: java任务取消\ndate: 2017-05-02 19:45:14\ncategories: 编程\ntags:\n- java\n- 多线程\n---\n> 最近在用思维导图做读书笔记，虽然感觉没有网上所说的那么神奇，但是用来做笔记还是可以的。总结梳理了一下java取消任务执方面的一些内容，也是《java并发编程实战》的读书笔记。\n\n{% asset_img java.png 任务取消 %}\n\n<!-- more -->\n\n## 取消原因\n\n取消一个任务执行的理由有很多，通常有以下几个\n\n- 用户请求取消\n\n  通常用户点击“取消”按钮发出取消命令\n\n- 有时间限制的操作\n\n  计时任务，超时时就会取消任务执行并返回\n\n- 应用程序逻辑\n\n  比如有多个任务对一个问题进行分解和搜索解决方案，如果其中某个任务找到解决方案，其他并行的任务就可以取消了\n\n- 发生错误\n\n  比如爬虫程序下载网页到本地硬盘，如果盘满了之后爬取任务应该被取消\n\n- 关闭\n\n  程序或服务被关闭，则正在执行的任务也应该取消，而不是继续执行\n\n\n## 取消线程执行\n\n任务的取消执行，其实最后都会落到线程的终止上(任务都是由线程来执行)。在java中没有一种安全的抢占式方法来终止线程(Thread.stop 是不安全的终止线程执行的方法，已经废弃掉了)，所以需要一种很好的协作机制来平滑的关闭任务。\n\n### 自然结束\n\n中断线程的最好方法是让代码自然执行到结束，而不是从外部强制打断他。为此可以设置一个“任务取消标志”，任务代码会定期的查看这个标志，如果发现标志被设定了，则任务提前结束。\n\n```java\npublic class SomeJob {\n\tprivate List<String> list = new ArrayList<>();\n\tprivate volatile boolean canceled = false;\n\n\tpublic void run() {\n\t\twhile (!canceled) {\n\t\t\tString res = getResult();\n\t\t\tsynchronized (this) {\n\t\t\t\tlist.add(res);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String getResult() {\n\t\t// do something...\n\t\treturn \"\";\n\t}\n\t\n\tpublic void cancel() {\n\t\tthis.canceled = true;\n\t}\n}\n```\n上面的代码中，设置了一个volatile类型的变量canceled，所以其他线程对这个变量的修改对所有线程都是可见的(可见性)。每次循环执行某个操作之前都会检查这个变量是否被其他线程设置为true，如果为true则提前退出。\n\n这是很常见的一种取消任务执行的手段，但是也有他的弊端，比如：\n\n```java\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class SomeJob {\n\tprivate BlockingQueue<String> list = new LinkedBlockingQueue<>(100);\n\tprivate volatile boolean canceled = false;\n\n\tpublic void run() {\n\t\ttry {\n\t\t\twhile (!canceled) {\n\t\t\t\tString res = getResult();\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tlist.put(res);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate String getResult() {\n\t\t// do something...\n\t\treturn \"\";\n\t}\n\n\tpublic void cancel() {\n\t\tthis.canceled = true;\n\t}\n}\n\n```\n上面将list替换为支持阻塞的BlockingQueue，他是一个有界队列，当调用list的put操作时，如果队列已经填满，那么将会一直阻塞直到队列有空余位置为止。如果恰好执行put操作是阻塞了，此时我们调用了cancel方法，那么什么时候检查canceled标志是不确定的，响应性很差，极端情况下，有可能永远也不会去再下一次轮询中检查canceled标志，试想我们执行了取消后，消费队列的线程已经停止，此时put操作又阻塞，那么将会一直阻塞下去，这个线程失去响应。\n\n### 线程中断\n\n通过线程自己的中断机制，可以解决上述问题。\n\n每个线程都有一个boolean类型的变量，表示中断状态。当中断线程时，这个线程的中断状态将被设置为true。在Thread中有三个方法可以设置或访问这个变量：\n\n- Thread.interrupt: 中断目标线程\n\n- Thread.isInterrupted: 返回线程的中断状态\n\n- Thread.interrupted: 清除线程的中断状态，并返回之前的值\n\n调用interrupt并不意味着立即停止目标线程正在进行的任务，而只是将中断状态设置为true：他并不会正真中断一个正在运行的线程，而只是发出了一种中断请求，线程可以看到这个中断状态，然后在合适的时刻处理。\n\n#### 中断请求\n\n##### 响应中断阻塞\n\n上面提到的中断请求，有些方法会处理这些请求，从而结束现在正在进行的任务。像上面代码中的BlockingQueue.put方法，当他在阻塞状态时，依然能够发现中断请求并提前返回，所以解决上面代码中的问题只需要对执行代码的线程thread调用thread.interrupt方法，BlockingQueue.put就可以从阻塞状态中恢复回来，从而完成取消。类似这样的支持中断的阻塞就叫做响应中断阻塞，主要有以下几个：\n\n- Thread.sleep \n\n- Object.wait\n\n- Thread.join\n\n这些支持中断的阻塞在响应中断时执行的操作包括：\n\n- 清除中断状态\n\n- 抛出InterruptedException，表示阻塞操作由于中断而提前结束\n\njvm并不能保证这些阻塞方法检测到中断的速度，但在实际情况中响应速度还是很快的。\n\n利用线程本身的中断状态作为取消机制，我们可以将上面的代码再改造一下：\n\n```java\npublic class SomeJob {\n\tprivate BlockingQueue<String> list = new LinkedBlockingQueue<>();\n\n\tpublic void run() {\n\t\ttry {\n\t\t\twhile (!Thread.currentThread().isInterrupted()) {\n\t\t\t\tString res = getResult();\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tlist.put(res);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\tSystem.out.println(\"任务被取消...\");\n\t\t}\n\t}\n\n\tprivate String getResult() {\n\t\t// do something...\n\t\treturn \"\";\n\t}\n\n\tpublic void cancel(Thread thread) {\n\t\tthread.interrupt();\n\t}\n}\n```\n任务代码在每次轮询操作前检查当前线程的状态，如果被中断了就退出。cancel方法是对当前执行任务的线程进行中断。\n\n注意，调用cancel方法的是另一线程，传入的线程实例则是执行run方法的工作者线程，故在执行cancel方法后run方法可以检测到中断。\n\n##### 不响应中断阻塞\n\n并非所有的阻塞方法和阻塞机制都能够响应中断请求，比如正在read或write上阻塞的socket就不会响应中断，调用线程的interrupt方法只能设置线程的中断状态，除此以外没有任何作用，因为这些阻塞方法并不会去检查线程中断状态，也不会处理中断。这些阻塞就是不响应中断阻塞。主要有以下几个：\n\n- java.io包中的同步socket io: 从socket中获取的InputStream和OutputStream中的read或write方法都不会响应中断，解决办法是关闭这个socket，使得正在执行read或write方法而被阻塞的线程抛出一个SocketException\n\n- java.io包中的同步IO: 当中断一个正在InterruptibleChannel上等待的线程时，将抛出ClosedByInterruptException并关闭链路。\n\n- Selector的异步IO: 如果一个线程在调用Selector.select方法时阻塞了，那么调用close或wakeup方法会使线程抛出ClosedSelectorException并返回\n\n- 获得某个锁: 如果一个线程由于等待某个内置锁而阻塞，将无法响应中断。Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。(BlockingQueue.put可以响应中断缘于此)\n\n一个简单的例子，取消socket任务：\n\n```java\npublic class CanceledThread extends Thread {\n\tprivate final Socket socket;\n\tprivate final InputStream stream;\n\tpublic CanceledThread(Socket socket) throws IOException {\n\t\tthis.socket = socket;\n\t\tthis.stream = socket.getInputStream();\n\t}\n\t@Override\n\tpublic void interrupt() {\n\t\ttry {\n\t\t\tsocket.close();\n\t\t} catch (Exception e) {\n\t\t\t// do nothing\n\t\t} finally {\n\t\t\tsuper.interrupt();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tbyte[] bytes = new byte[1024];\n\t\t\twhile (true) {\n\t\t\t\tint count = stream.read(bytes);\n\t\t\t\tif (count < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (count > 0) {\n\t\t\t\t\t// 处理读到 bytes\n\t\t\t\t}\n \t\t\t\t\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// 可能捕捉到InterruptedException 或 SocketException\n\t\t\t// 线程退出\n\t\t}\n\t}\n}\n\n```\n在上面的代码中，即使socket的stream在read过程中阻塞了，也可以中断阻塞并返回。\n\n#### 中断处理\n\n上文提到，当调用可中断的阻塞库函数时，会抛出InterruptedException，这个异常会出现在我们的任务代码中(任务代码调用了这些阻塞方法)，有三种方法处理这个异常：\n\n- 不处理，或者在捕捉到异常后打印日志以及做一些资源回收工作\n\n  确定我们的任务代码可以这么做时才这么做。这意味这这个任务完全可以在这个线程中取消，不必再向上层报告或需要更上层的代码处理。\n\n- 传递异常，从而使你的方法也成为可中断的阻塞方法\n\n  简单的将异常抛出，让上层代码处理，这意味着需要上层代码再做一些资源回收等工作。\n\n- 恢复中断状态，从而使调用栈中的上层代码能够对其进行处理\n\n  如果不想或无法(Runnable中)传递InterruptedException时，可以通过再次调用interrupt来恢复中断状态。此时上层代码就可以捕捉到这个中断，从而作出处理。\n\nThreadPoolExcutor就是处理中断的一个例子：当其拥有的工作者线程检测到中断时，他会检查线程池是否正在关闭。如果是，他会在结束前执行一些线程清理工作，否则他可能创建一个新线程将线程池恢复到合理的规模。\n\n## 取消任务\n\n### 终止线程池\n\n线程池的生命周期是由ExcutorService控制的。ExcutorService提供了两种关闭线程池的方法：\n\n- shutdownNow\n\n  强行关闭线程池，首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单(在任务队列当中的)\n\n  关闭速度快，但是有风险，正在执行中的任务可能在执行一半的时候被结束\n\n- shutdown\n\n  正常关闭线程池，一直等到队列中的所有任务都执行完后才关闭，在此期间不接受新任务\n\n  关闭速度慢，却更加安全\n\n### 终止基于线程的服务\n\n在写程序时往往会用到日志，在代码中插入println也是一种日志行为。为了避免由于日志为服务带来性能损耗和并发风险(多个线程同时打印日志有可能引发并发问题)，我们往往将打印日志任务放到某个队列中，由专门的线程从队列中取出任务进行打印。下面设计这样一个日志服务：\n\n```java\npublic class LogService {\n\tprivate final BlockingQueue<String> queue;\n\tprivate final PrintWriter writer;\n\tprivate final LoggerThread thread;\n\tprivate boolean isShutDown = false;\n\tprivate int reservations = 0;\n\n\tpublic LogService(PrintWriter writer) {\n\t\tthis.writer = writer;\n\t\tthread = new LoggerThread();\n\t\tqueue = new LinkedBlockingQueue<>();\n\t}\n\t\n\tpublic void shutdown() {\n\t\tsynchronized (this) {\n\t\t\tisShutDown = true;\n\t\t}\n\t\tthread.interrupt();\n\t}\n\t\n\tpublic void log(String msg) throws InterruptedException {\n\t\tsynchronized (this) {\n\t\t\tif (isShutDown) {\n\t\t\t\tthrow new IllegalStateException(\"日志服务已经关闭...\");\n\t\t\t}\n\t\t\treservations ++;\n\t\t}\n\t\tqueue.put(msg);\n\t}\n\n\tclass LoggerThread extends Thread {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsynchronized (LogService.this) {\n\t\t\t\t\t\t\tif (isShutDown && reservations == 0) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tString msg = queue.take();\n\t\t\t\t\t\t\tsynchronized (LogService.this) {\n\t\t\t\t\t\t\t\treservations--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twriter.println(msg);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t// retry\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\twriter.close();\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n当关闭日志服务时，日志服务不再会接收新的日志打印请求，并且会将队列中剩余的所有打印任务执行完毕，最后结束。如果此时日志打印线程恰好在queue.take方法中阻塞了，关闭日志服务时也能很好的从阻塞中恢复过来，结束服务。\n","slug":"java任务取消","published":1,"updated":"2017-05-04T12:05:47.444Z","comments":1,"photos":[],"link":"","_id":"cj4vch4ek001qx3gc42f6y1s2","content":"<blockquote>\n<p>最近在用思维导图做读书笔记，虽然感觉没有网上所说的那么神奇，但是用来做笔记还是可以的。总结梳理了一下java取消任务执方面的一些内容，也是《java并发编程实战》的读书笔记。</p>\n</blockquote>\n<img src=\"/2017/05/02/java任务取消/java.png\" alt=\"任务取消\" title=\"任务取消\">\n<a id=\"more\"></a>\n<h2 id=\"取消原因\"><a href=\"#取消原因\" class=\"headerlink\" title=\"取消原因\"></a>取消原因</h2><p>取消一个任务执行的理由有很多，通常有以下几个</p>\n<ul>\n<li><p>用户请求取消</p>\n<p>通常用户点击“取消”按钮发出取消命令</p>\n</li>\n<li><p>有时间限制的操作</p>\n<p>计时任务，超时时就会取消任务执行并返回</p>\n</li>\n<li><p>应用程序逻辑</p>\n<p>比如有多个任务对一个问题进行分解和搜索解决方案，如果其中某个任务找到解决方案，其他并行的任务就可以取消了</p>\n</li>\n<li><p>发生错误</p>\n<p>比如爬虫程序下载网页到本地硬盘，如果盘满了之后爬取任务应该被取消</p>\n</li>\n<li><p>关闭</p>\n<p>程序或服务被关闭，则正在执行的任务也应该取消，而不是继续执行</p>\n</li>\n</ul>\n<h2 id=\"取消线程执行\"><a href=\"#取消线程执行\" class=\"headerlink\" title=\"取消线程执行\"></a>取消线程执行</h2><p>任务的取消执行，其实最后都会落到线程的终止上(任务都是由线程来执行)。在java中没有一种安全的抢占式方法来终止线程(Thread.stop 是不安全的终止线程执行的方法，已经废弃掉了)，所以需要一种很好的协作机制来平滑的关闭任务。</p>\n<h3 id=\"自然结束\"><a href=\"#自然结束\" class=\"headerlink\" title=\"自然结束\"></a>自然结束</h3><p>中断线程的最好方法是让代码自然执行到结束，而不是从外部强制打断他。为此可以设置一个“任务取消标志”，任务代码会定期的查看这个标志，如果发现标志被设定了，则任务提前结束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeJob</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> canceled = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (!canceled) &#123;</div><div class=\"line\">\t\t\tString res = getResult();</div><div class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\t\tlist.add(res);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// do something...</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.canceled = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码中，设置了一个volatile类型的变量canceled，所以其他线程对这个变量的修改对所有线程都是可见的(可见性)。每次循环执行某个操作之前都会检查这个变量是否被其他线程设置为true，如果为true则提前退出。</p>\n<p>这是很常见的一种取消任务执行的手段，但是也有他的弊端，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.BlockingQueue;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.LinkedBlockingQueue;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeJob</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> BlockingQueue&lt;String&gt; list = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;(<span class=\"number\">100</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> canceled = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> (!canceled) &#123;</div><div class=\"line\">\t\t\t\tString res = getResult();</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\t\t\tlist.put(res);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// do something...</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.canceled = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面将list替换为支持阻塞的BlockingQueue，他是一个有界队列，当调用list的put操作时，如果队列已经填满，那么将会一直阻塞直到队列有空余位置为止。如果恰好执行put操作是阻塞了，此时我们调用了cancel方法，那么什么时候检查canceled标志是不确定的，响应性很差，极端情况下，有可能永远也不会去再下一次轮询中检查canceled标志，试想我们执行了取消后，消费队列的线程已经停止，此时put操作又阻塞，那么将会一直阻塞下去，这个线程失去响应。</p>\n<h3 id=\"线程中断\"><a href=\"#线程中断\" class=\"headerlink\" title=\"线程中断\"></a>线程中断</h3><p>通过线程自己的中断机制，可以解决上述问题。</p>\n<p>每个线程都有一个boolean类型的变量，表示中断状态。当中断线程时，这个线程的中断状态将被设置为true。在Thread中有三个方法可以设置或访问这个变量：</p>\n<ul>\n<li><p>Thread.interrupt: 中断目标线程</p>\n</li>\n<li><p>Thread.isInterrupted: 返回线程的中断状态</p>\n</li>\n<li><p>Thread.interrupted: 清除线程的中断状态，并返回之前的值</p>\n</li>\n</ul>\n<p>调用interrupt并不意味着立即停止目标线程正在进行的任务，而只是将中断状态设置为true：他并不会正真中断一个正在运行的线程，而只是发出了一种中断请求，线程可以看到这个中断状态，然后在合适的时刻处理。</p>\n<h4 id=\"中断请求\"><a href=\"#中断请求\" class=\"headerlink\" title=\"中断请求\"></a>中断请求</h4><h5 id=\"响应中断阻塞\"><a href=\"#响应中断阻塞\" class=\"headerlink\" title=\"响应中断阻塞\"></a>响应中断阻塞</h5><p>上面提到的中断请求，有些方法会处理这些请求，从而结束现在正在进行的任务。像上面代码中的BlockingQueue.put方法，当他在阻塞状态时，依然能够发现中断请求并提前返回，所以解决上面代码中的问题只需要对执行代码的线程thread调用thread.interrupt方法，BlockingQueue.put就可以从阻塞状态中恢复回来，从而完成取消。类似这样的支持中断的阻塞就叫做响应中断阻塞，主要有以下几个：</p>\n<ul>\n<li><p>Thread.sleep </p>\n</li>\n<li><p>Object.wait</p>\n</li>\n<li><p>Thread.join</p>\n</li>\n</ul>\n<p>这些支持中断的阻塞在响应中断时执行的操作包括：</p>\n<ul>\n<li><p>清除中断状态</p>\n</li>\n<li><p>抛出InterruptedException，表示阻塞操作由于中断而提前结束</p>\n</li>\n</ul>\n<p>jvm并不能保证这些阻塞方法检测到中断的速度，但在实际情况中响应速度还是很快的。</p>\n<p>利用线程本身的中断状态作为取消机制，我们可以将上面的代码再改造一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeJob</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> BlockingQueue&lt;String&gt; list = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> (!Thread.currentThread().isInterrupted()) &#123;</div><div class=\"line\">\t\t\t\tString res = getResult();</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\t\t\tlist.put(res);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"任务被取消...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// do something...</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">(Thread thread)</span> </span>&#123;</div><div class=\"line\">\t\tthread.interrupt();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>任务代码在每次轮询操作前检查当前线程的状态，如果被中断了就退出。cancel方法是对当前执行任务的线程进行中断。</p>\n<p>注意，调用cancel方法的是另一线程，传入的线程实例则是执行run方法的工作者线程，故在执行cancel方法后run方法可以检测到中断。</p>\n<h5 id=\"不响应中断阻塞\"><a href=\"#不响应中断阻塞\" class=\"headerlink\" title=\"不响应中断阻塞\"></a>不响应中断阻塞</h5><p>并非所有的阻塞方法和阻塞机制都能够响应中断请求，比如正在read或write上阻塞的socket就不会响应中断，调用线程的interrupt方法只能设置线程的中断状态，除此以外没有任何作用，因为这些阻塞方法并不会去检查线程中断状态，也不会处理中断。这些阻塞就是不响应中断阻塞。主要有以下几个：</p>\n<ul>\n<li><p>java.io包中的同步socket io: 从socket中获取的InputStream和OutputStream中的read或write方法都不会响应中断，解决办法是关闭这个socket，使得正在执行read或write方法而被阻塞的线程抛出一个SocketException</p>\n</li>\n<li><p>java.io包中的同步IO: 当中断一个正在InterruptibleChannel上等待的线程时，将抛出ClosedByInterruptException并关闭链路。</p>\n</li>\n<li><p>Selector的异步IO: 如果一个线程在调用Selector.select方法时阻塞了，那么调用close或wakeup方法会使线程抛出ClosedSelectorException并返回</p>\n</li>\n<li><p>获得某个锁: 如果一个线程由于等待某个内置锁而阻塞，将无法响应中断。Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。(BlockingQueue.put可以响应中断缘于此)</p>\n</li>\n</ul>\n<p>一个简单的例子，取消socket任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CanceledThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Socket socket;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> InputStream stream;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CanceledThread</span><span class=\"params\">(Socket socket)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.socket = socket;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.stream = socket.getInputStream();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsocket.close();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// do nothing</span></div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">super</span>.interrupt();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> count = stream.read(bytes);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 处理读到 bytes</span></div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"> \t\t\t\t</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 可能捕捉到InterruptedException 或 SocketException</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 线程退出</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在上面的代码中，即使socket的stream在read过程中阻塞了，也可以中断阻塞并返回。</p>\n<h4 id=\"中断处理\"><a href=\"#中断处理\" class=\"headerlink\" title=\"中断处理\"></a>中断处理</h4><p>上文提到，当调用可中断的阻塞库函数时，会抛出InterruptedException，这个异常会出现在我们的任务代码中(任务代码调用了这些阻塞方法)，有三种方法处理这个异常：</p>\n<ul>\n<li><p>不处理，或者在捕捉到异常后打印日志以及做一些资源回收工作</p>\n<p>确定我们的任务代码可以这么做时才这么做。这意味这这个任务完全可以在这个线程中取消，不必再向上层报告或需要更上层的代码处理。</p>\n</li>\n<li><p>传递异常，从而使你的方法也成为可中断的阻塞方法</p>\n<p>简单的将异常抛出，让上层代码处理，这意味着需要上层代码再做一些资源回收等工作。</p>\n</li>\n<li><p>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理</p>\n<p>如果不想或无法(Runnable中)传递InterruptedException时，可以通过再次调用interrupt来恢复中断状态。此时上层代码就可以捕捉到这个中断，从而作出处理。</p>\n</li>\n</ul>\n<p>ThreadPoolExcutor就是处理中断的一个例子：当其拥有的工作者线程检测到中断时，他会检查线程池是否正在关闭。如果是，他会在结束前执行一些线程清理工作，否则他可能创建一个新线程将线程池恢复到合理的规模。</p>\n<h2 id=\"取消任务\"><a href=\"#取消任务\" class=\"headerlink\" title=\"取消任务\"></a>取消任务</h2><h3 id=\"终止线程池\"><a href=\"#终止线程池\" class=\"headerlink\" title=\"终止线程池\"></a>终止线程池</h3><p>线程池的生命周期是由ExcutorService控制的。ExcutorService提供了两种关闭线程池的方法：</p>\n<ul>\n<li><p>shutdownNow</p>\n<p>强行关闭线程池，首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单(在任务队列当中的)</p>\n<p>关闭速度快，但是有风险，正在执行中的任务可能在执行一半的时候被结束</p>\n</li>\n<li><p>shutdown</p>\n<p>正常关闭线程池，一直等到队列中的所有任务都执行完后才关闭，在此期间不接受新任务</p>\n<p>关闭速度慢，却更加安全</p>\n</li>\n</ul>\n<h3 id=\"终止基于线程的服务\"><a href=\"#终止基于线程的服务\" class=\"headerlink\" title=\"终止基于线程的服务\"></a>终止基于线程的服务</h3><p>在写程序时往往会用到日志，在代码中插入println也是一种日志行为。为了避免由于日志为服务带来性能损耗和并发风险(多个线程同时打印日志有可能引发并发问题)，我们往往将打印日志任务放到某个队列中，由专门的线程从队列中取出任务进行打印。下面设计这样一个日志服务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogService</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;String&gt; queue;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PrintWriter writer;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LoggerThread thread;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isShutDown = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> reservations = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LogService</span><span class=\"params\">(PrintWriter writer)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.writer = writer;</div><div class=\"line\">\t\tthread = <span class=\"keyword\">new</span> LoggerThread();</div><div class=\"line\">\t\tqueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\tisShutDown = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tthread.interrupt();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">(String msg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (isShutDown) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"日志服务已经关闭...\"</span>);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\treservations ++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tqueue.put(msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">synchronized</span> (LogService.<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span> (isShutDown &amp;&amp; reservations == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t\tString msg = queue.take();</div><div class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">synchronized</span> (LogService.<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t\treservations--;</div><div class=\"line\">\t\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t\twriter.println(msg);</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// retry</span></div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\t\twriter.close();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当关闭日志服务时，日志服务不再会接收新的日志打印请求，并且会将队列中剩余的所有打印任务执行完毕，最后结束。如果此时日志打印线程恰好在queue.take方法中阻塞了，关闭日志服务时也能很好的从阻塞中恢复过来，结束服务。</p>\n","excerpt":"<blockquote>\n<p>最近在用思维导图做读书笔记，虽然感觉没有网上所说的那么神奇，但是用来做笔记还是可以的。总结梳理了一下java取消任务执方面的一些内容，也是《java并发编程实战》的读书笔记。</p>\n</blockquote>\n<img src=\"/2017/05/02/java任务取消/java.png\" alt=\"任务取消\" title=\"任务取消\">","more":"<h2 id=\"取消原因\"><a href=\"#取消原因\" class=\"headerlink\" title=\"取消原因\"></a>取消原因</h2><p>取消一个任务执行的理由有很多，通常有以下几个</p>\n<ul>\n<li><p>用户请求取消</p>\n<p>通常用户点击“取消”按钮发出取消命令</p>\n</li>\n<li><p>有时间限制的操作</p>\n<p>计时任务，超时时就会取消任务执行并返回</p>\n</li>\n<li><p>应用程序逻辑</p>\n<p>比如有多个任务对一个问题进行分解和搜索解决方案，如果其中某个任务找到解决方案，其他并行的任务就可以取消了</p>\n</li>\n<li><p>发生错误</p>\n<p>比如爬虫程序下载网页到本地硬盘，如果盘满了之后爬取任务应该被取消</p>\n</li>\n<li><p>关闭</p>\n<p>程序或服务被关闭，则正在执行的任务也应该取消，而不是继续执行</p>\n</li>\n</ul>\n<h2 id=\"取消线程执行\"><a href=\"#取消线程执行\" class=\"headerlink\" title=\"取消线程执行\"></a>取消线程执行</h2><p>任务的取消执行，其实最后都会落到线程的终止上(任务都是由线程来执行)。在java中没有一种安全的抢占式方法来终止线程(Thread.stop 是不安全的终止线程执行的方法，已经废弃掉了)，所以需要一种很好的协作机制来平滑的关闭任务。</p>\n<h3 id=\"自然结束\"><a href=\"#自然结束\" class=\"headerlink\" title=\"自然结束\"></a>自然结束</h3><p>中断线程的最好方法是让代码自然执行到结束，而不是从外部强制打断他。为此可以设置一个“任务取消标志”，任务代码会定期的查看这个标志，如果发现标志被设定了，则任务提前结束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeJob</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> canceled = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (!canceled) &#123;</div><div class=\"line\">\t\t\tString res = getResult();</div><div class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\t\tlist.add(res);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// do something...</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.canceled = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码中，设置了一个volatile类型的变量canceled，所以其他线程对这个变量的修改对所有线程都是可见的(可见性)。每次循环执行某个操作之前都会检查这个变量是否被其他线程设置为true，如果为true则提前退出。</p>\n<p>这是很常见的一种取消任务执行的手段，但是也有他的弊端，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.BlockingQueue;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.LinkedBlockingQueue;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeJob</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> BlockingQueue&lt;String&gt; list = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;(<span class=\"number\">100</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> canceled = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> (!canceled) &#123;</div><div class=\"line\">\t\t\t\tString res = getResult();</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\t\t\tlist.put(res);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// do something...</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.canceled = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面将list替换为支持阻塞的BlockingQueue，他是一个有界队列，当调用list的put操作时，如果队列已经填满，那么将会一直阻塞直到队列有空余位置为止。如果恰好执行put操作是阻塞了，此时我们调用了cancel方法，那么什么时候检查canceled标志是不确定的，响应性很差，极端情况下，有可能永远也不会去再下一次轮询中检查canceled标志，试想我们执行了取消后，消费队列的线程已经停止，此时put操作又阻塞，那么将会一直阻塞下去，这个线程失去响应。</p>\n<h3 id=\"线程中断\"><a href=\"#线程中断\" class=\"headerlink\" title=\"线程中断\"></a>线程中断</h3><p>通过线程自己的中断机制，可以解决上述问题。</p>\n<p>每个线程都有一个boolean类型的变量，表示中断状态。当中断线程时，这个线程的中断状态将被设置为true。在Thread中有三个方法可以设置或访问这个变量：</p>\n<ul>\n<li><p>Thread.interrupt: 中断目标线程</p>\n</li>\n<li><p>Thread.isInterrupted: 返回线程的中断状态</p>\n</li>\n<li><p>Thread.interrupted: 清除线程的中断状态，并返回之前的值</p>\n</li>\n</ul>\n<p>调用interrupt并不意味着立即停止目标线程正在进行的任务，而只是将中断状态设置为true：他并不会正真中断一个正在运行的线程，而只是发出了一种中断请求，线程可以看到这个中断状态，然后在合适的时刻处理。</p>\n<h4 id=\"中断请求\"><a href=\"#中断请求\" class=\"headerlink\" title=\"中断请求\"></a>中断请求</h4><h5 id=\"响应中断阻塞\"><a href=\"#响应中断阻塞\" class=\"headerlink\" title=\"响应中断阻塞\"></a>响应中断阻塞</h5><p>上面提到的中断请求，有些方法会处理这些请求，从而结束现在正在进行的任务。像上面代码中的BlockingQueue.put方法，当他在阻塞状态时，依然能够发现中断请求并提前返回，所以解决上面代码中的问题只需要对执行代码的线程thread调用thread.interrupt方法，BlockingQueue.put就可以从阻塞状态中恢复回来，从而完成取消。类似这样的支持中断的阻塞就叫做响应中断阻塞，主要有以下几个：</p>\n<ul>\n<li><p>Thread.sleep </p>\n</li>\n<li><p>Object.wait</p>\n</li>\n<li><p>Thread.join</p>\n</li>\n</ul>\n<p>这些支持中断的阻塞在响应中断时执行的操作包括：</p>\n<ul>\n<li><p>清除中断状态</p>\n</li>\n<li><p>抛出InterruptedException，表示阻塞操作由于中断而提前结束</p>\n</li>\n</ul>\n<p>jvm并不能保证这些阻塞方法检测到中断的速度，但在实际情况中响应速度还是很快的。</p>\n<p>利用线程本身的中断状态作为取消机制，我们可以将上面的代码再改造一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeJob</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> BlockingQueue&lt;String&gt; list = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> (!Thread.currentThread().isInterrupted()) &#123;</div><div class=\"line\">\t\t\t\tString res = getResult();</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\t\t\tlist.put(res);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"任务被取消...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// do something...</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">(Thread thread)</span> </span>&#123;</div><div class=\"line\">\t\tthread.interrupt();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>任务代码在每次轮询操作前检查当前线程的状态，如果被中断了就退出。cancel方法是对当前执行任务的线程进行中断。</p>\n<p>注意，调用cancel方法的是另一线程，传入的线程实例则是执行run方法的工作者线程，故在执行cancel方法后run方法可以检测到中断。</p>\n<h5 id=\"不响应中断阻塞\"><a href=\"#不响应中断阻塞\" class=\"headerlink\" title=\"不响应中断阻塞\"></a>不响应中断阻塞</h5><p>并非所有的阻塞方法和阻塞机制都能够响应中断请求，比如正在read或write上阻塞的socket就不会响应中断，调用线程的interrupt方法只能设置线程的中断状态，除此以外没有任何作用，因为这些阻塞方法并不会去检查线程中断状态，也不会处理中断。这些阻塞就是不响应中断阻塞。主要有以下几个：</p>\n<ul>\n<li><p>java.io包中的同步socket io: 从socket中获取的InputStream和OutputStream中的read或write方法都不会响应中断，解决办法是关闭这个socket，使得正在执行read或write方法而被阻塞的线程抛出一个SocketException</p>\n</li>\n<li><p>java.io包中的同步IO: 当中断一个正在InterruptibleChannel上等待的线程时，将抛出ClosedByInterruptException并关闭链路。</p>\n</li>\n<li><p>Selector的异步IO: 如果一个线程在调用Selector.select方法时阻塞了，那么调用close或wakeup方法会使线程抛出ClosedSelectorException并返回</p>\n</li>\n<li><p>获得某个锁: 如果一个线程由于等待某个内置锁而阻塞，将无法响应中断。Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。(BlockingQueue.put可以响应中断缘于此)</p>\n</li>\n</ul>\n<p>一个简单的例子，取消socket任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CanceledThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Socket socket;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> InputStream stream;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CanceledThread</span><span class=\"params\">(Socket socket)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.socket = socket;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.stream = socket.getInputStream();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsocket.close();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// do nothing</span></div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">super</span>.interrupt();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> count = stream.read(bytes);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 处理读到 bytes</span></div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"> \t\t\t\t</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 可能捕捉到InterruptedException 或 SocketException</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 线程退出</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在上面的代码中，即使socket的stream在read过程中阻塞了，也可以中断阻塞并返回。</p>\n<h4 id=\"中断处理\"><a href=\"#中断处理\" class=\"headerlink\" title=\"中断处理\"></a>中断处理</h4><p>上文提到，当调用可中断的阻塞库函数时，会抛出InterruptedException，这个异常会出现在我们的任务代码中(任务代码调用了这些阻塞方法)，有三种方法处理这个异常：</p>\n<ul>\n<li><p>不处理，或者在捕捉到异常后打印日志以及做一些资源回收工作</p>\n<p>确定我们的任务代码可以这么做时才这么做。这意味这这个任务完全可以在这个线程中取消，不必再向上层报告或需要更上层的代码处理。</p>\n</li>\n<li><p>传递异常，从而使你的方法也成为可中断的阻塞方法</p>\n<p>简单的将异常抛出，让上层代码处理，这意味着需要上层代码再做一些资源回收等工作。</p>\n</li>\n<li><p>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理</p>\n<p>如果不想或无法(Runnable中)传递InterruptedException时，可以通过再次调用interrupt来恢复中断状态。此时上层代码就可以捕捉到这个中断，从而作出处理。</p>\n</li>\n</ul>\n<p>ThreadPoolExcutor就是处理中断的一个例子：当其拥有的工作者线程检测到中断时，他会检查线程池是否正在关闭。如果是，他会在结束前执行一些线程清理工作，否则他可能创建一个新线程将线程池恢复到合理的规模。</p>\n<h2 id=\"取消任务\"><a href=\"#取消任务\" class=\"headerlink\" title=\"取消任务\"></a>取消任务</h2><h3 id=\"终止线程池\"><a href=\"#终止线程池\" class=\"headerlink\" title=\"终止线程池\"></a>终止线程池</h3><p>线程池的生命周期是由ExcutorService控制的。ExcutorService提供了两种关闭线程池的方法：</p>\n<ul>\n<li><p>shutdownNow</p>\n<p>强行关闭线程池，首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单(在任务队列当中的)</p>\n<p>关闭速度快，但是有风险，正在执行中的任务可能在执行一半的时候被结束</p>\n</li>\n<li><p>shutdown</p>\n<p>正常关闭线程池，一直等到队列中的所有任务都执行完后才关闭，在此期间不接受新任务</p>\n<p>关闭速度慢，却更加安全</p>\n</li>\n</ul>\n<h3 id=\"终止基于线程的服务\"><a href=\"#终止基于线程的服务\" class=\"headerlink\" title=\"终止基于线程的服务\"></a>终止基于线程的服务</h3><p>在写程序时往往会用到日志，在代码中插入println也是一种日志行为。为了避免由于日志为服务带来性能损耗和并发风险(多个线程同时打印日志有可能引发并发问题)，我们往往将打印日志任务放到某个队列中，由专门的线程从队列中取出任务进行打印。下面设计这样一个日志服务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogService</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;String&gt; queue;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PrintWriter writer;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LoggerThread thread;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isShutDown = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> reservations = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LogService</span><span class=\"params\">(PrintWriter writer)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.writer = writer;</div><div class=\"line\">\t\tthread = <span class=\"keyword\">new</span> LoggerThread();</div><div class=\"line\">\t\tqueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\tisShutDown = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tthread.interrupt();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">(String msg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (isShutDown) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"日志服务已经关闭...\"</span>);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\treservations ++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tqueue.put(msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">synchronized</span> (LogService.<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span> (isShutDown &amp;&amp; reservations == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t\tString msg = queue.take();</div><div class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">synchronized</span> (LogService.<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t\treservations--;</div><div class=\"line\">\t\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t\twriter.println(msg);</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// retry</span></div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\t\twriter.close();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当关闭日志服务时，日志服务不再会接收新的日志打印请求，并且会将队列中剩余的所有打印任务执行完毕，最后结束。如果此时日志打印线程恰好在queue.take方法中阻塞了，关闭日志服务时也能很好的从阻塞中恢复过来，结束服务。</p>"},{"layout":"post","date":"2016-07-18T04:48:55.000Z","title":"ANT的使用","_content":"\n>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和[Ant](http://ant.apache.org/)打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。\n\n## 教程\n\nAnt是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。\n\n[Ant Tutorial](http://www.tutorialspoint.com/ant/index.htm)\n\n[Ant 实践](http://www.uml.org.cn/j2ee/j2ee091302.htm#content)\n\n另外附上Ant常用命令：\n\n[Overview of Apache Ant Tasks](https://ant.apache.org/manual/tasksoverview.html)\n\n## 实践\n\n下面是自己写的build.xml。存在这里，以后用到可以参考。\n\n下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。\n\n<!-- more -->\n\n- **build.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n    Oscar XcluseterHibernate Ant build file\n-->\n<project name=\"OSCAR-XCLUSETER-HIBERNATE\" default=\"usage\" basedir=\".\">\n\t<target name=\"build\" depends=\"clean\" />\n\n\t<target name=\"init\" description=\"default init\">\n\t\t<property file=\"build.properties\" />\n\n\t\t<!-- Project Properties -->\n\t\t<property name=\"project\" value=\"oscarXcluseterHibernate3\" />\n\t\t<property name=\"name\" value=\"OSCAR HIBERNATE\" />\n\t\t<tstamp>\n\t\t\t<format property=\"year\" pattern=\"yyyy\" locale=\"zh_CN\" />\n\t\t\t<format property=\"builddate\" pattern=\"yyMMdd\" locale=\"zh_CN\" />\n\t\t</tstamp>\n\t\t<property name=\"version\" value=\"${version.major}.${version.minor}.${version.revision}${version.suffix}\" />\n\t\t<property name=\"version.number\" value=\"${version.major}.${version.minor}.${version.revision}\" />\n\t\t<property name=\"version.major.minor\" value=\"${version.major}.${version.minor}\" />\n\n\t\t<property name=\"final.name\" value=\"${project}\" />\n\t\t<property name=\"vesrion.build\" value=\"build${builddate} ${version.subbuild} ${version.buildID} for ALL \" />\n\n\t\t<!-- Build Defaults -->\n\t\t<property name=\"src.dir\" value=\"${basedir}/src\" />\n\t\t<property name=\"lib.dir\" value=\"${basedir}/lib\" />\n\t\t<property name=\"build.home\" value=\"${basedir}\" />\n\t\t<property name=\"build.src\" value=\"${basedir}/build\" />\n\t\t<property name=\"build.dest\" value=\"${basedir}/antClasses\" />\n\t\t<property name=\"build.release\" value=\"${basedir}/release\" />\n\t\t<property name=\"build.tmp\" value=\"${basedir}/tmp\" />\n\n\t\t<!-- JAR artifacts -->\n\t\t<property name=\"hiberante3.jar\" value=\"${lib.dir}/hibernate3.jar\" />\n\n\t\t<!-- Version info filter set -->\n\t\t<tstamp>\n\t\t\t<format property=\"DSTAMP\" pattern=\"yyyyMMdd\" locale=\"zh_CN\" />\n\t\t\t<format property=\"TSTAMP\" pattern=\"hhmm\" />\n\t\t</tstamp>\n\t\t<filterset id=\"version.filters\">\n\t\t\t<filter token=\"VERSION_NUMBER\" value=\"${version.number}\" />\n\t\t\t<filter token=\"BUNDLE_NAME\" value=\"${vesrion.name}\" />\n\t\t\t<filter token=\"BUNDLE_VERSION\" value=\"${version}${DSTAMP}${TSTAMP}\" />\n\t\t\t<filter token=\"BUILD_VERSION\" value=\"${vesrion.build}\" />\n\t\t</filterset>\n\t\t<path id=\"classpath\">\n\t\t\t<pathelement location=\"${hiberante3.jar}\" />\n\t\t</path>\n\t</target>\n\n\t<target name=\"usage\" depends=\"init\">\n\t\t<echo message=\"${name} Build file\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" available targets are:\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"   package  --> generates oscarXcluseterHibernate file\" />\n\t\t<echo message=\"   build    --> compiles the source code\" />\n\t\t<echo message=\"   clean    --> cleans up the directory\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" See the comments inside the build.xml file for more details.\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"\" />\n\t</target>\n\n\t<!-- Just build -->\n\t<target name=\"compile-prepare\" depends=\"init\" description=\"Prepare for compile\">\n\n\t\t<!-- create directories -->\n\t\t<mkdir dir=\"${build.src}\" />\n\t\t<mkdir dir=\"${build.dest}\" />\n\n\t\t<!-- copy src files -->\n\t\t<copy todir=\"${build.src}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${src.dir}\">\n\t\t\t\t<exclude name=\"**/*.MF\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"compile\" depends=\"compile-prepare\" description=\"compile the project\">\n\n\t\t<!-- Compiles the source directory  -->\n\t\t<javac srcdir=\"${build.src}\" \n\t\t\tdestdir=\"${build.dest}\" \n\t\t\tdebug=\"${build.debug}\" \n\t\t\tdeprecation=\"${build.deprecation}\" \n\t\t\tsource=\"${build.source}\" \n\t\t\ttarget=\"${build.target}\" \n\t\t\tcompiler=\"${build.compiler}\" \n\t\t\toptimize=\"${build.optimize}\" \n\t\t\tincludes=\"**/*.java\" \n\t\t\texcludes=\"**/CVS/**,**/.svn/**\" \n\t\t\tencoding=\"GB18030\"\n\t\t\tincludeantruntime=\"false\"\n\t\t\texecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"\n\t\t\tfork=\"yes\">\n\t\t\t<classpath refid=\"classpath\" />\n\t\t</javac>\n\n\t\t<!-- copy src files exclude java file-->\n\t\t<copy todir=\"${build.dest}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${build.src}\">\n\t\t\t\t<exclude name=\"**/*.java\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"build-manifests\" depends=\"init,compile-prepare\">\n\t\t<!-- Filtering tokens for JAR manifests-->\n\t\t<filter token=\"source.jdk\" value=\"${build.source}\" />\n\t\t<filter token=\"target.jdk\" value=\"${build.target}\" />\n\t\t<mkdir dir=\"${build.tmp}\" />\n\t\t<copy todir=\"${build.tmp}\" overwrite=\"yes\" filtering=\"yes\" encoding=\"GB18030\">\n\t\t\t<filterset refid=\"version.filters\" />\n\t\t\t<fileset dir=\"src/META-INF\" includes=\"MANIFEST.MF\" />\n\t\t</copy>\n\t</target>\n\n\t<target name=\"package\" depends=\"compile,build-manifests\" description=\"create jar file\">\n\t\t<mkdir dir=\"${build.release}\" />\n\t\t<jar jarfile=\"${build.release}/${final.name}.jar\" manifest=\"${build.tmp}/MANIFEST.MF\" basedir=\"${build.dest}\" includes=\"**\" />\n\t</target>\n\n\t<target name=\"clean\" depends=\"package\">\n\t\t<delete dir=\"${build.src}\" />\n\t\t<delete dir=\"${build.dest}\" />\n\t\t<delete dir=\"${build.tmp}\" />\n\t</target>\n</project>\n\n```\n\n- **build.properties**\n\n```java\n\n# -----------------------------------------------------------------------------\n# build.properties\n#\n# This is an example \"build.properties\" file, used to customize building \n# OSCAR-JDBC for your local environment.  It defines the location of all external\n# modules that OSCAR-JDBC depends on.\n# -----------------------------------------------------------------------------\n\n# ----- Version Control Flags -----\nvesrion.name=Main\nversion.major=1\nversion.minor=0\nversion.revision=0\nversion.suffix=x\nversion.subbuild=001\nversion.buildID=00000000\n\nbuild.source=1.5\nbuild.target=1.5\nbuild.debug=false\nbuild.optimize=true\nbuild.compiler=javac1.5\n\n```","source":"_posts/Ant的使用.md","raw":"---\nlayout: post\ndate:   2016-07-18 12:48:55\ntitle:  \"ANT的使用\"\ncategories: 工具\ntags: \n- java\n- ant\n---\n\n>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和[Ant](http://ant.apache.org/)打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。\n\n## 教程\n\nAnt是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。\n\n[Ant Tutorial](http://www.tutorialspoint.com/ant/index.htm)\n\n[Ant 实践](http://www.uml.org.cn/j2ee/j2ee091302.htm#content)\n\n另外附上Ant常用命令：\n\n[Overview of Apache Ant Tasks](https://ant.apache.org/manual/tasksoverview.html)\n\n## 实践\n\n下面是自己写的build.xml。存在这里，以后用到可以参考。\n\n下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。\n\n<!-- more -->\n\n- **build.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n    Oscar XcluseterHibernate Ant build file\n-->\n<project name=\"OSCAR-XCLUSETER-HIBERNATE\" default=\"usage\" basedir=\".\">\n\t<target name=\"build\" depends=\"clean\" />\n\n\t<target name=\"init\" description=\"default init\">\n\t\t<property file=\"build.properties\" />\n\n\t\t<!-- Project Properties -->\n\t\t<property name=\"project\" value=\"oscarXcluseterHibernate3\" />\n\t\t<property name=\"name\" value=\"OSCAR HIBERNATE\" />\n\t\t<tstamp>\n\t\t\t<format property=\"year\" pattern=\"yyyy\" locale=\"zh_CN\" />\n\t\t\t<format property=\"builddate\" pattern=\"yyMMdd\" locale=\"zh_CN\" />\n\t\t</tstamp>\n\t\t<property name=\"version\" value=\"${version.major}.${version.minor}.${version.revision}${version.suffix}\" />\n\t\t<property name=\"version.number\" value=\"${version.major}.${version.minor}.${version.revision}\" />\n\t\t<property name=\"version.major.minor\" value=\"${version.major}.${version.minor}\" />\n\n\t\t<property name=\"final.name\" value=\"${project}\" />\n\t\t<property name=\"vesrion.build\" value=\"build${builddate} ${version.subbuild} ${version.buildID} for ALL \" />\n\n\t\t<!-- Build Defaults -->\n\t\t<property name=\"src.dir\" value=\"${basedir}/src\" />\n\t\t<property name=\"lib.dir\" value=\"${basedir}/lib\" />\n\t\t<property name=\"build.home\" value=\"${basedir}\" />\n\t\t<property name=\"build.src\" value=\"${basedir}/build\" />\n\t\t<property name=\"build.dest\" value=\"${basedir}/antClasses\" />\n\t\t<property name=\"build.release\" value=\"${basedir}/release\" />\n\t\t<property name=\"build.tmp\" value=\"${basedir}/tmp\" />\n\n\t\t<!-- JAR artifacts -->\n\t\t<property name=\"hiberante3.jar\" value=\"${lib.dir}/hibernate3.jar\" />\n\n\t\t<!-- Version info filter set -->\n\t\t<tstamp>\n\t\t\t<format property=\"DSTAMP\" pattern=\"yyyyMMdd\" locale=\"zh_CN\" />\n\t\t\t<format property=\"TSTAMP\" pattern=\"hhmm\" />\n\t\t</tstamp>\n\t\t<filterset id=\"version.filters\">\n\t\t\t<filter token=\"VERSION_NUMBER\" value=\"${version.number}\" />\n\t\t\t<filter token=\"BUNDLE_NAME\" value=\"${vesrion.name}\" />\n\t\t\t<filter token=\"BUNDLE_VERSION\" value=\"${version}${DSTAMP}${TSTAMP}\" />\n\t\t\t<filter token=\"BUILD_VERSION\" value=\"${vesrion.build}\" />\n\t\t</filterset>\n\t\t<path id=\"classpath\">\n\t\t\t<pathelement location=\"${hiberante3.jar}\" />\n\t\t</path>\n\t</target>\n\n\t<target name=\"usage\" depends=\"init\">\n\t\t<echo message=\"${name} Build file\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" available targets are:\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"   package  --> generates oscarXcluseterHibernate file\" />\n\t\t<echo message=\"   build    --> compiles the source code\" />\n\t\t<echo message=\"   clean    --> cleans up the directory\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" See the comments inside the build.xml file for more details.\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"\" />\n\t</target>\n\n\t<!-- Just build -->\n\t<target name=\"compile-prepare\" depends=\"init\" description=\"Prepare for compile\">\n\n\t\t<!-- create directories -->\n\t\t<mkdir dir=\"${build.src}\" />\n\t\t<mkdir dir=\"${build.dest}\" />\n\n\t\t<!-- copy src files -->\n\t\t<copy todir=\"${build.src}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${src.dir}\">\n\t\t\t\t<exclude name=\"**/*.MF\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"compile\" depends=\"compile-prepare\" description=\"compile the project\">\n\n\t\t<!-- Compiles the source directory  -->\n\t\t<javac srcdir=\"${build.src}\" \n\t\t\tdestdir=\"${build.dest}\" \n\t\t\tdebug=\"${build.debug}\" \n\t\t\tdeprecation=\"${build.deprecation}\" \n\t\t\tsource=\"${build.source}\" \n\t\t\ttarget=\"${build.target}\" \n\t\t\tcompiler=\"${build.compiler}\" \n\t\t\toptimize=\"${build.optimize}\" \n\t\t\tincludes=\"**/*.java\" \n\t\t\texcludes=\"**/CVS/**,**/.svn/**\" \n\t\t\tencoding=\"GB18030\"\n\t\t\tincludeantruntime=\"false\"\n\t\t\texecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"\n\t\t\tfork=\"yes\">\n\t\t\t<classpath refid=\"classpath\" />\n\t\t</javac>\n\n\t\t<!-- copy src files exclude java file-->\n\t\t<copy todir=\"${build.dest}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${build.src}\">\n\t\t\t\t<exclude name=\"**/*.java\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"build-manifests\" depends=\"init,compile-prepare\">\n\t\t<!-- Filtering tokens for JAR manifests-->\n\t\t<filter token=\"source.jdk\" value=\"${build.source}\" />\n\t\t<filter token=\"target.jdk\" value=\"${build.target}\" />\n\t\t<mkdir dir=\"${build.tmp}\" />\n\t\t<copy todir=\"${build.tmp}\" overwrite=\"yes\" filtering=\"yes\" encoding=\"GB18030\">\n\t\t\t<filterset refid=\"version.filters\" />\n\t\t\t<fileset dir=\"src/META-INF\" includes=\"MANIFEST.MF\" />\n\t\t</copy>\n\t</target>\n\n\t<target name=\"package\" depends=\"compile,build-manifests\" description=\"create jar file\">\n\t\t<mkdir dir=\"${build.release}\" />\n\t\t<jar jarfile=\"${build.release}/${final.name}.jar\" manifest=\"${build.tmp}/MANIFEST.MF\" basedir=\"${build.dest}\" includes=\"**\" />\n\t</target>\n\n\t<target name=\"clean\" depends=\"package\">\n\t\t<delete dir=\"${build.src}\" />\n\t\t<delete dir=\"${build.dest}\" />\n\t\t<delete dir=\"${build.tmp}\" />\n\t</target>\n</project>\n\n```\n\n- **build.properties**\n\n```java\n\n# -----------------------------------------------------------------------------\n# build.properties\n#\n# This is an example \"build.properties\" file, used to customize building \n# OSCAR-JDBC for your local environment.  It defines the location of all external\n# modules that OSCAR-JDBC depends on.\n# -----------------------------------------------------------------------------\n\n# ----- Version Control Flags -----\nvesrion.name=Main\nversion.major=1\nversion.minor=0\nversion.revision=0\nversion.suffix=x\nversion.subbuild=001\nversion.buildID=00000000\n\nbuild.source=1.5\nbuild.target=1.5\nbuild.debug=false\nbuild.optimize=true\nbuild.compiler=javac1.5\n\n```","slug":"Ant的使用","published":1,"updated":"2017-04-11T13:08:38.816Z","comments":1,"photos":[],"link":"","_id":"cj4vch4em001ux3gcv08z0ehf","content":"<blockquote>\n<p>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和<a href=\"http://ant.apache.org/\" target=\"_blank\" rel=\"external\">Ant</a>打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。</p>\n</blockquote>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><p>Ant是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。</p>\n<p><a href=\"http://www.tutorialspoint.com/ant/index.htm\" target=\"_blank\" rel=\"external\">Ant Tutorial</a></p>\n<p><a href=\"http://www.uml.org.cn/j2ee/j2ee091302.htm#content\" target=\"_blank\" rel=\"external\">Ant 实践</a></p>\n<p>另外附上Ant常用命令：</p>\n<p><a href=\"https://ant.apache.org/manual/tasksoverview.html\" target=\"_blank\" rel=\"external\">Overview of Apache Ant Tasks</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>下面是自己写的build.xml。存在这里，以后用到可以参考。</p>\n<p>下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。</p>\n<a id=\"more\"></a>\n<ul>\n<li><strong>build.xml</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"comment\">&lt;!--</span></div><div class=\"line\">    Oscar XcluseterHibernate Ant build file</div><div class=\"line\">--&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">name</span>=<span class=\"string\">\"OSCAR-XCLUSETER-HIBERNATE\"</span> <span class=\"attr\">default</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\".\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"clean\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"default init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">file</span>=<span class=\"string\">\"build.properties\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Project Properties --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"project\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"oscarXcluseterHibernate3\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"OSCAR HIBERNATE\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"year\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyy\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"builddate\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;$&#123;version.suffix&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.number\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.major.minor\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"final.name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;project&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"vesrion.build\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"build$&#123;builddate&#125; $&#123;version.subbuild&#125; $&#123;version.buildID&#125; for ALL \"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Build Defaults --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"src.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/src\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lib.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/lib\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.home\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.src\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/build\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.dest\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/antClasses\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.release\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/release\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.tmp\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/tmp\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- JAR artifacts --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hiberante3.jar\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;lib.dir&#125;/hibernate3.jar\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Version info filter set --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"DSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"TSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"hhmm\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">id</span>=<span class=\"string\">\"version.filters\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"VERSION_NUMBER\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.number&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_NAME\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.name&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version&#125;$&#123;DSTAMP&#125;$&#123;TSTAMP&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUILD_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.build&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">filterset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"classpath\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">pathelement</span> <span class=\"attr\">location</span>=<span class=\"string\">\"$&#123;hiberante3.jar&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"$&#123;name&#125; Build file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" available targets are:\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   package  --&gt; generates oscarXcluseterHibernate file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   build    --&gt; compiles the source code\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   clean    --&gt; cleans up the directory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" See the comments inside the build.xml file for more details.\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- Just build --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"Prepare for compile\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- create directories --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;src.dir&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"compile the project\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Compiles the source directory  --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">javac</span> <span class=\"attr\">srcdir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> </span></div><div class=\"line\">\t\t\t<span class=\"attr\">destdir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">debug</span>=<span class=\"string\">\"$&#123;build.debug&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">deprecation</span>=<span class=\"string\">\"$&#123;build.deprecation&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">source</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">target</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">compiler</span>=<span class=\"string\">\"$&#123;build.compiler&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">optimize</span>=<span class=\"string\">\"$&#123;build.optimize&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">includes</span>=<span class=\"string\">\"**/*.java\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">excludes</span>=<span class=\"string\">\"**/CVS/**,**/.svn/**\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">includeantruntime</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">executable</span>=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">fork</span>=<span class=\"string\">\"yes\"</span>&gt;</div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">classpath</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"classpath\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">javac</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files exclude java file--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.java\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build-manifests\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init,compile-prepare\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Filtering tokens for JAR manifests--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"source.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"target.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">filtering</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"version.filters\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"src/META-INF\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"MANIFEST.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"package\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile,build-manifests\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"create jar file\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.release&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">jar</span> <span class=\"attr\">jarfile</span>=<span class=\"string\">\"$&#123;build.release&#125;/$&#123;final.name&#125;.jar\"</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"$&#123;build.tmp&#125;/MANIFEST.MF\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"**\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"clean\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"package\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li><strong>build.properties</strong></li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"># build.properties</div><div class=\"line\">#</div><div class=\"line\"># This is an example \"build.properties\" file, used to customize building </div><div class=\"line\"># OSCAR-JDBC for your local environment.  It defines the location of all external</div><div class=\"line\"># modules that OSCAR-JDBC depends on.</div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\"># ----- Version Control Flags -----</div><div class=\"line\">vesrion.name=Main</div><div class=\"line\">version.major=1</div><div class=\"line\">version.minor=0</div><div class=\"line\">version.revision=0</div><div class=\"line\">version.suffix=x</div><div class=\"line\">version.subbuild=001</div><div class=\"line\">version.buildID=00000000</div><div class=\"line\"></div><div class=\"line\">build.source=1.5</div><div class=\"line\">build.target=1.5</div><div class=\"line\">build.debug=false</div><div class=\"line\">build.optimize=true</div><div class=\"line\">build.compiler=javac1.5</div></pre></td></tr></table></figure>","excerpt":"<blockquote>\n<p>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和<a href=\"http://ant.apache.org/\">Ant</a>打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。</p>\n</blockquote>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><p>Ant是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。</p>\n<p><a href=\"http://www.tutorialspoint.com/ant/index.htm\">Ant Tutorial</a></p>\n<p><a href=\"http://www.uml.org.cn/j2ee/j2ee091302.htm#content\">Ant 实践</a></p>\n<p>另外附上Ant常用命令：</p>\n<p><a href=\"https://ant.apache.org/manual/tasksoverview.html\">Overview of Apache Ant Tasks</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>下面是自己写的build.xml。存在这里，以后用到可以参考。</p>\n<p>下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。</p>","more":"<ul>\n<li><strong>build.xml</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"comment\">&lt;!--</div><div class=\"line\">    Oscar XcluseterHibernate Ant build file</div><div class=\"line\">--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">name</span>=<span class=\"string\">\"OSCAR-XCLUSETER-HIBERNATE\"</span> <span class=\"attr\">default</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\".\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"clean\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"default init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">file</span>=<span class=\"string\">\"build.properties\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Project Properties --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"project\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"oscarXcluseterHibernate3\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"OSCAR HIBERNATE\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"year\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyy\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"builddate\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;$&#123;version.suffix&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.number\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.major.minor\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"final.name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;project&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"vesrion.build\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"build$&#123;builddate&#125; $&#123;version.subbuild&#125; $&#123;version.buildID&#125; for ALL \"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Build Defaults --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"src.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/src\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lib.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/lib\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.home\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.src\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/build\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.dest\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/antClasses\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.release\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/release\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.tmp\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/tmp\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- JAR artifacts --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hiberante3.jar\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;lib.dir&#125;/hibernate3.jar\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Version info filter set --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"DSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"TSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"hhmm\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">id</span>=<span class=\"string\">\"version.filters\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"VERSION_NUMBER\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.number&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_NAME\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.name&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version&#125;$&#123;DSTAMP&#125;$&#123;TSTAMP&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUILD_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.build&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">filterset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"classpath\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">pathelement</span> <span class=\"attr\">location</span>=<span class=\"string\">\"$&#123;hiberante3.jar&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"$&#123;name&#125; Build file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" available targets are:\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   package  --&gt; generates oscarXcluseterHibernate file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   build    --&gt; compiles the source code\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   clean    --&gt; cleans up the directory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" See the comments inside the build.xml file for more details.\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- Just build --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"Prepare for compile\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- create directories --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;src.dir&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"compile the project\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Compiles the source directory  --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">javac</span> <span class=\"attr\">srcdir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">destdir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">debug</span>=<span class=\"string\">\"$&#123;build.debug&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">deprecation</span>=<span class=\"string\">\"$&#123;build.deprecation&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">source</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">target</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">compiler</span>=<span class=\"string\">\"$&#123;build.compiler&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">optimize</span>=<span class=\"string\">\"$&#123;build.optimize&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">includes</span>=<span class=\"string\">\"**/*.java\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">excludes</span>=<span class=\"string\">\"**/CVS/**,**/.svn/**\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">includeantruntime</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">executable</span>=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">fork</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">classpath</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"classpath\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">javac</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files exclude java file--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.java\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build-manifests\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init,compile-prepare\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Filtering tokens for JAR manifests--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"source.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"target.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">filtering</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"version.filters\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"src/META-INF\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"MANIFEST.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"package\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile,build-manifests\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"create jar file\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.release&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">jar</span> <span class=\"attr\">jarfile</span>=<span class=\"string\">\"$&#123;build.release&#125;/$&#123;final.name&#125;.jar\"</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"$&#123;build.tmp&#125;/MANIFEST.MF\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"**\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"clean\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"package\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li><strong>build.properties</strong></li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"># build.properties</div><div class=\"line\">#</div><div class=\"line\"># This is an example \"build.properties\" file, used to customize building </div><div class=\"line\"># OSCAR-JDBC for your local environment.  It defines the location of all external</div><div class=\"line\"># modules that OSCAR-JDBC depends on.</div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\"># ----- Version Control Flags -----</div><div class=\"line\">vesrion.name=Main</div><div class=\"line\">version.major=1</div><div class=\"line\">version.minor=0</div><div class=\"line\">version.revision=0</div><div class=\"line\">version.suffix=x</div><div class=\"line\">version.subbuild=001</div><div class=\"line\">version.buildID=00000000</div><div class=\"line\"></div><div class=\"line\">build.source=1.5</div><div class=\"line\">build.target=1.5</div><div class=\"line\">build.debug=false</div><div class=\"line\">build.optimize=true</div><div class=\"line\">build.compiler=javac1.5</div></pre></td></tr></table></figure>"},{"layout":"post","title":"java国际化","date":"2017-02-19T11:32:40.000Z","_content":"\n> 使用java编写一个带GUI程序或者其他需要给用户传递文字信息的程序的时候，就很有可能需要用到国际化的知识，来总结一下。\n\n所谓的国际化，就是使编写的程序可以适应不同的语言环境，比如，在中文环境下，可以与用户使用中文交互，在英文环境下则切换为英文。而这个切换过程不需要修改代码或者仅仅修改少量的代码。java给我们提供了这样的实现。\n\n## java文件国际化\n\n我们通过将与界面显示有关系的资源提取出来到资源文件中，然后读取不同的资源文件来达到国际化的目的。在java中，这些是通过ResourceBundle这个类来实现的。\n\nResourceBundle分为两种，一种是ListResourceBundle,另一种是PropertyResourceBundle。下面介绍这两种ResourceBundle的使用方法：\n\n首先列出demo工程的代码结构：\n\n```\nTestResourceBundle\n|\n|--src\n    |\n    |--kyu\n        |\n        |--bundle\n        |    |\n        |    |--ListResourceTranslator.java\n        |    |\n        |    |--PropertyResourceTranslator.java\n        |    |\n        |    |--ResourceTranslator.java\n        |\n        |--test\n        |   |\n        |   |--App.java\n        |\n        |--Errors_en_Us.java\n        |\n        |--Errors_zh_CN.java\n        |\n        |--Errors.java\n        |\n        |--Errors_en_Us.properties\n        |\n        |--Errors_zh_CN.properties\n        |\n        |--Errors.properties\n        \n```\n\n<!-- more -->\n\n### PropertyResourceBundle\n\n1. 首先需要建立若干语言的properties文件： 自定义名_语言代码_国别代码.properties\n\n比如：errors_en_US.properties, errors_zh_CN.properties\n\n其中的语言代码和国别代码，分别是你要国际化的语言。需要几种语言，就添加几个properties文件。\n\n[国别代码](https://worldwide.espacenet.com/help?locale=cn_EP&method=handleHelpTopic&topic=countrycodes)\n\n[语言代码](http://www.lingoes.cn/zh/translator/langcode.htm)\n\n通过打印java所支持的语言和国家查看：\n\n```\nprivate static void printLocal() {\n\t\tLocale[] localeList = Locale.getAvailableLocales();\n\t\tfor (int i = 0; i < localeList.length; i++) {\n\t\t\tSystem.out.println(localeList[i].getDisplayCountry() + \": \" + localeList[i].getCountry());\n\t\t\tSystem.out.println(localeList[i].getDisplayLanguage() + \": \" + localeList[i].getLanguage());\n\t\t}\n}\n```\n\n2. 建立默认语言的properties文件：自定义名.properties\n\n比如：errors.properties\n\n当所需语言的properties文件不存在的时候就会默认读取这个文件中的内容\n\n注意，资源文件都必须是ISO-8859-1编码，对于中文等非西方语系，可通过JDK自带的工具native2ascii进行处理，在Eclipse中也可以安装插件SimplePropertiesEditor来处理这类文件。\n\n3. 使用\n\nResourceTranslator.java\n\n```\npackage kyu.bundle;\n\nimport java.util.Locale;\nimport java.util.ResourceBundle;\n\npublic abstract class ResourceTranslator {\n\tprotected ResourceBundle bundle;\n\tprotected Locale lc;\n\tprotected static final String PROP_FILE = \"kyu.errors\";\n\n    public String translate(String id) {\n        return bundle.getString(id);\n    }\n}\n```\n\nPropertyResourceTranslator.java\n\n```\npackage kyu.bundle;\n\nimport java.util.Locale;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\n\npublic class PropertyResourceTranslator extends ResourceTranslator{\n    public PropertyResourceTranslator() {\n        lc = Locale.getDefault();\n        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);\n    }\n    \n    public PropertyResourceTranslator(String language, String country) {\n    \tlc = new Locale(language, country);\n        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);\n    }\n\n}\n```\n\nApp.java\n\n```\npackage kyu.test;\n\nimport kyu.bundle.ListResourceTranslator;\nimport kyu.bundle.PropertyResourceTranslator;\n\npublic class App {\n\tpublic static void main(String[] args) {\n\t\ttestPropertyResource();\n\t}\n\n\tprivate static void testPropertyResource() {\n\t\tPropertyResourceTranslator translatorDefault = new PropertyResourceTranslator();\n\t\tPropertyResourceTranslator translatorZH = new PropertyResourceTranslator(\"zh\", \"CN\");\n\t\tPropertyResourceTranslator translatorEN = new PropertyResourceTranslator(\"en\", \"US\");\n\t\tString def = translatorDefault.translate(\"ERROR-001\");\n\t\tString zh = translatorZH.translate(\"ERROR-001\");\n\t\tString en = translatorEN.translate(\"ERROR-001\");\n\t\t\n\t\tSystem.out.println(\"test PropertyResourceBundle>>>>>>\");\n\t\tSystem.out.println(\"default: \" + def);\n\t\tSystem.out.println(\"zh: \" + zh);\n\t\tSystem.out.println(\"en: \" + en);\n\t}\t\n\t\n}\n```\n.properties文件内容：\n\n```\nErrors_en_Us.properties:\nERROR-001=error password\n\nErrors.properties\nERROR-001=error password\n\nErrors_zh_CN.properties\nERROR-001=密码错误\n```\n\n执行App.java的测试结果：\n\n```\ntest PropertyResourceBundle>>>>>>\ndefault: 密码错误\nzh: 密码错误\nen: error password\n```\n\n可以看到，通过指定Local构造函数的语言和国别代码，就能自动找到对应的.properties，并匹配其中的内容。\n\n当使用Locale.getDefault()时，自动检测当前的系统环境，从而选择对应的语言。\n\n还有一点要注意的是： \n\nPropertyResourceBundle.getBundle(PROP_FILE, lc); \n\n其中PROP_FILE，为properties文件的路径，此路径为properties文件的完整路径，即 所在完整包名.自定义名称\n\n### ListResourceBundle\n\nListResourceBundle的使用与PropertyResourceBundle的使用大同小异，不过是将properties文件换成了.java文件\n\nListResourceTranslator.java\n\n```\npackage kyu.bundle;\n\nimport java.util.ListResourceBundle;\nimport java.util.Locale;\n\npublic class ListResourceTranslator extends ResourceTranslator{\n\tpublic ListResourceTranslator() {\n        lc = Locale.getDefault();\n        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);\n    }\n    \n    public ListResourceTranslator(String language, String country) {\n    \tlc = new Locale(language, country);\n        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);\n    }\n}\n\n```\n\nERRORS_en_US.java\n\n```\npackage kyu;\n\nimport java.util.ListResourceBundle;\n\npublic class ERRORS_en_US extends ListResourceBundle{\n\tstatic final Object[][] contents = new String[][] { \n\t\t{ \"ERROR-001\", \"error password\" } \n\t};\n\n\tpublic Object[][] getContents() {\n\t\treturn contents;\n\t}\n}\n\n```\n\nERRORS_zh_CN.java\n\n```\npackage kyu;\n\nimport java.util.ListResourceBundle;\n\npublic class ERRORS_zh_CN extends ListResourceBundle {\n\tstatic final Object[][] contents = new String[][] { \n\t\t{ \"ERROR-001\", \"密码错误\" } \n\t};\n\n\tpublic Object[][] getContents() {\n\t\treturn contents;\n\t}\n}\n\n```\n\n继承了ListResourceBundle的类就相当于前面的properties文件，需要提供一个getContents()方法，返回对应的键值对。\n\n同样的，要注意ListResourceBundle子类的命名规则，与properties文件相同，路径也与properties文件相同。\n\n通过App.java的测试(将对应的bundle替换)，可以得到相同的测试结果。\n\n### 使用Eclipse对java文件进行国际化\n\n在需要国际化的类文件上点击右键->Source->Externalize Strings...\n\n出现窗口，Eclipse会自动检测类文件中的字符串，在窗口中可以选择相应的字符串，最后自动生成类似于上面的PropertyResourceTranslator.java和properties文件，完成国际化。\n\n其原理与以上所讲的相同，故不再详细说明。\n\n## Eclipse RCP国际化\n\n> 最近在使用Eclipse RCP这项技术开发程序，其中也有国际化相关的东西，总结下来。\n\n[Eclipse RCP and Plugin Internationalization - Tutorial](http://www.vogella.com/tutorials/EclipseInternationalization/article.html)\n\n上面这篇文章详细的说明了Eclipse RCP工程中的国际化问题，可以作为一个备忘录。下面介绍一下eclipse rcp中比较常用到的国际化方式：\n\n### plugin.xml文件国际化\n\nplugin.xml文件中保存了扩展点等相关的信息，当扩展点与界面UI相关时，就需要用到国际化\n\n1. 在工程的根目录下面建立一个plugin.properties资源文件，此文件类似于我们上面提到的errors.properties。当然，也可以建立plugin_zh.properties等文件，这些文件名中的plugin是可以自由定义的。\n\n2. 在 MANIFEST.MF文件中增加代码行：Bundle-Localization: plugin\n\n   注意，这个plugin与上面的properties文件名保持一致。\n\n3. plugin.xml配置文件对资源文件进行引用时, 在引用的key前面加一个%，比如：\n\n```\n<view\n    id=\"org.jkiss.dbeaver.core.databaseNavigator\"\n    category=\"org.jkiss.dbeaver.core.category\"\n    class=\"org.jkiss.dbeaver.ui.navigator.database.DatabaseNavigatorView\"\n    allowMultiple=\"false\"\n    icon=\"icons/databases.png\"\n    name=\"%view.database.navigator.title\"/>\n<view\n```\n\n### 类文件国际化\n\n与前面所介绍的java类文件国际化相同，也可以通过选择类文件点击右键->Source->Externalize Strings...\n\nEclipse IDE会自动帮你完成国际化的一些工作，同样也生成了相关的类和properties文件，但不同的是，生成的类文件内容类似于：\n\n```\npackage test;\n\nimport org.eclipse.osgi.util.NLS;\n\npublic class Messages extends NLS {\n        private static final String BUNDLE_NAME\n                = \"test.messages\"; //$NON-NLS-1$\n        public static String View_0;\n        public static String View_1;\n        static {\n                // initialize resource bundle\n                NLS.initializeMessages(BUNDLE_NAME, Messages.class);\n        }\n\n        private Messages() {\n        }\n}\n```\n\n当然，我们也可以手动建立这些文件进行国际化操作~~不再详细说明，可以通过观察IDE的行为进行我们手动的国际化操作~","source":"_posts/java国际化.md","raw":"---\nlayout: post\ntitle: java国际化\ndate: 2017-02-19 19:32:40\ncategories: 技术\ntags: java\n---\n\n> 使用java编写一个带GUI程序或者其他需要给用户传递文字信息的程序的时候，就很有可能需要用到国际化的知识，来总结一下。\n\n所谓的国际化，就是使编写的程序可以适应不同的语言环境，比如，在中文环境下，可以与用户使用中文交互，在英文环境下则切换为英文。而这个切换过程不需要修改代码或者仅仅修改少量的代码。java给我们提供了这样的实现。\n\n## java文件国际化\n\n我们通过将与界面显示有关系的资源提取出来到资源文件中，然后读取不同的资源文件来达到国际化的目的。在java中，这些是通过ResourceBundle这个类来实现的。\n\nResourceBundle分为两种，一种是ListResourceBundle,另一种是PropertyResourceBundle。下面介绍这两种ResourceBundle的使用方法：\n\n首先列出demo工程的代码结构：\n\n```\nTestResourceBundle\n|\n|--src\n    |\n    |--kyu\n        |\n        |--bundle\n        |    |\n        |    |--ListResourceTranslator.java\n        |    |\n        |    |--PropertyResourceTranslator.java\n        |    |\n        |    |--ResourceTranslator.java\n        |\n        |--test\n        |   |\n        |   |--App.java\n        |\n        |--Errors_en_Us.java\n        |\n        |--Errors_zh_CN.java\n        |\n        |--Errors.java\n        |\n        |--Errors_en_Us.properties\n        |\n        |--Errors_zh_CN.properties\n        |\n        |--Errors.properties\n        \n```\n\n<!-- more -->\n\n### PropertyResourceBundle\n\n1. 首先需要建立若干语言的properties文件： 自定义名_语言代码_国别代码.properties\n\n比如：errors_en_US.properties, errors_zh_CN.properties\n\n其中的语言代码和国别代码，分别是你要国际化的语言。需要几种语言，就添加几个properties文件。\n\n[国别代码](https://worldwide.espacenet.com/help?locale=cn_EP&method=handleHelpTopic&topic=countrycodes)\n\n[语言代码](http://www.lingoes.cn/zh/translator/langcode.htm)\n\n通过打印java所支持的语言和国家查看：\n\n```\nprivate static void printLocal() {\n\t\tLocale[] localeList = Locale.getAvailableLocales();\n\t\tfor (int i = 0; i < localeList.length; i++) {\n\t\t\tSystem.out.println(localeList[i].getDisplayCountry() + \": \" + localeList[i].getCountry());\n\t\t\tSystem.out.println(localeList[i].getDisplayLanguage() + \": \" + localeList[i].getLanguage());\n\t\t}\n}\n```\n\n2. 建立默认语言的properties文件：自定义名.properties\n\n比如：errors.properties\n\n当所需语言的properties文件不存在的时候就会默认读取这个文件中的内容\n\n注意，资源文件都必须是ISO-8859-1编码，对于中文等非西方语系，可通过JDK自带的工具native2ascii进行处理，在Eclipse中也可以安装插件SimplePropertiesEditor来处理这类文件。\n\n3. 使用\n\nResourceTranslator.java\n\n```\npackage kyu.bundle;\n\nimport java.util.Locale;\nimport java.util.ResourceBundle;\n\npublic abstract class ResourceTranslator {\n\tprotected ResourceBundle bundle;\n\tprotected Locale lc;\n\tprotected static final String PROP_FILE = \"kyu.errors\";\n\n    public String translate(String id) {\n        return bundle.getString(id);\n    }\n}\n```\n\nPropertyResourceTranslator.java\n\n```\npackage kyu.bundle;\n\nimport java.util.Locale;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\n\npublic class PropertyResourceTranslator extends ResourceTranslator{\n    public PropertyResourceTranslator() {\n        lc = Locale.getDefault();\n        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);\n    }\n    \n    public PropertyResourceTranslator(String language, String country) {\n    \tlc = new Locale(language, country);\n        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);\n    }\n\n}\n```\n\nApp.java\n\n```\npackage kyu.test;\n\nimport kyu.bundle.ListResourceTranslator;\nimport kyu.bundle.PropertyResourceTranslator;\n\npublic class App {\n\tpublic static void main(String[] args) {\n\t\ttestPropertyResource();\n\t}\n\n\tprivate static void testPropertyResource() {\n\t\tPropertyResourceTranslator translatorDefault = new PropertyResourceTranslator();\n\t\tPropertyResourceTranslator translatorZH = new PropertyResourceTranslator(\"zh\", \"CN\");\n\t\tPropertyResourceTranslator translatorEN = new PropertyResourceTranslator(\"en\", \"US\");\n\t\tString def = translatorDefault.translate(\"ERROR-001\");\n\t\tString zh = translatorZH.translate(\"ERROR-001\");\n\t\tString en = translatorEN.translate(\"ERROR-001\");\n\t\t\n\t\tSystem.out.println(\"test PropertyResourceBundle>>>>>>\");\n\t\tSystem.out.println(\"default: \" + def);\n\t\tSystem.out.println(\"zh: \" + zh);\n\t\tSystem.out.println(\"en: \" + en);\n\t}\t\n\t\n}\n```\n.properties文件内容：\n\n```\nErrors_en_Us.properties:\nERROR-001=error password\n\nErrors.properties\nERROR-001=error password\n\nErrors_zh_CN.properties\nERROR-001=密码错误\n```\n\n执行App.java的测试结果：\n\n```\ntest PropertyResourceBundle>>>>>>\ndefault: 密码错误\nzh: 密码错误\nen: error password\n```\n\n可以看到，通过指定Local构造函数的语言和国别代码，就能自动找到对应的.properties，并匹配其中的内容。\n\n当使用Locale.getDefault()时，自动检测当前的系统环境，从而选择对应的语言。\n\n还有一点要注意的是： \n\nPropertyResourceBundle.getBundle(PROP_FILE, lc); \n\n其中PROP_FILE，为properties文件的路径，此路径为properties文件的完整路径，即 所在完整包名.自定义名称\n\n### ListResourceBundle\n\nListResourceBundle的使用与PropertyResourceBundle的使用大同小异，不过是将properties文件换成了.java文件\n\nListResourceTranslator.java\n\n```\npackage kyu.bundle;\n\nimport java.util.ListResourceBundle;\nimport java.util.Locale;\n\npublic class ListResourceTranslator extends ResourceTranslator{\n\tpublic ListResourceTranslator() {\n        lc = Locale.getDefault();\n        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);\n    }\n    \n    public ListResourceTranslator(String language, String country) {\n    \tlc = new Locale(language, country);\n        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);\n    }\n}\n\n```\n\nERRORS_en_US.java\n\n```\npackage kyu;\n\nimport java.util.ListResourceBundle;\n\npublic class ERRORS_en_US extends ListResourceBundle{\n\tstatic final Object[][] contents = new String[][] { \n\t\t{ \"ERROR-001\", \"error password\" } \n\t};\n\n\tpublic Object[][] getContents() {\n\t\treturn contents;\n\t}\n}\n\n```\n\nERRORS_zh_CN.java\n\n```\npackage kyu;\n\nimport java.util.ListResourceBundle;\n\npublic class ERRORS_zh_CN extends ListResourceBundle {\n\tstatic final Object[][] contents = new String[][] { \n\t\t{ \"ERROR-001\", \"密码错误\" } \n\t};\n\n\tpublic Object[][] getContents() {\n\t\treturn contents;\n\t}\n}\n\n```\n\n继承了ListResourceBundle的类就相当于前面的properties文件，需要提供一个getContents()方法，返回对应的键值对。\n\n同样的，要注意ListResourceBundle子类的命名规则，与properties文件相同，路径也与properties文件相同。\n\n通过App.java的测试(将对应的bundle替换)，可以得到相同的测试结果。\n\n### 使用Eclipse对java文件进行国际化\n\n在需要国际化的类文件上点击右键->Source->Externalize Strings...\n\n出现窗口，Eclipse会自动检测类文件中的字符串，在窗口中可以选择相应的字符串，最后自动生成类似于上面的PropertyResourceTranslator.java和properties文件，完成国际化。\n\n其原理与以上所讲的相同，故不再详细说明。\n\n## Eclipse RCP国际化\n\n> 最近在使用Eclipse RCP这项技术开发程序，其中也有国际化相关的东西，总结下来。\n\n[Eclipse RCP and Plugin Internationalization - Tutorial](http://www.vogella.com/tutorials/EclipseInternationalization/article.html)\n\n上面这篇文章详细的说明了Eclipse RCP工程中的国际化问题，可以作为一个备忘录。下面介绍一下eclipse rcp中比较常用到的国际化方式：\n\n### plugin.xml文件国际化\n\nplugin.xml文件中保存了扩展点等相关的信息，当扩展点与界面UI相关时，就需要用到国际化\n\n1. 在工程的根目录下面建立一个plugin.properties资源文件，此文件类似于我们上面提到的errors.properties。当然，也可以建立plugin_zh.properties等文件，这些文件名中的plugin是可以自由定义的。\n\n2. 在 MANIFEST.MF文件中增加代码行：Bundle-Localization: plugin\n\n   注意，这个plugin与上面的properties文件名保持一致。\n\n3. plugin.xml配置文件对资源文件进行引用时, 在引用的key前面加一个%，比如：\n\n```\n<view\n    id=\"org.jkiss.dbeaver.core.databaseNavigator\"\n    category=\"org.jkiss.dbeaver.core.category\"\n    class=\"org.jkiss.dbeaver.ui.navigator.database.DatabaseNavigatorView\"\n    allowMultiple=\"false\"\n    icon=\"icons/databases.png\"\n    name=\"%view.database.navigator.title\"/>\n<view\n```\n\n### 类文件国际化\n\n与前面所介绍的java类文件国际化相同，也可以通过选择类文件点击右键->Source->Externalize Strings...\n\nEclipse IDE会自动帮你完成国际化的一些工作，同样也生成了相关的类和properties文件，但不同的是，生成的类文件内容类似于：\n\n```\npackage test;\n\nimport org.eclipse.osgi.util.NLS;\n\npublic class Messages extends NLS {\n        private static final String BUNDLE_NAME\n                = \"test.messages\"; //$NON-NLS-1$\n        public static String View_0;\n        public static String View_1;\n        static {\n                // initialize resource bundle\n                NLS.initializeMessages(BUNDLE_NAME, Messages.class);\n        }\n\n        private Messages() {\n        }\n}\n```\n\n当然，我们也可以手动建立这些文件进行国际化操作~~不再详细说明，可以通过观察IDE的行为进行我们手动的国际化操作~","slug":"java国际化","published":1,"updated":"2017-04-11T13:08:38.842Z","comments":1,"photos":[],"link":"","_id":"cj4vch4ep001xx3gcqmbixfae","content":"<blockquote>\n<p>使用java编写一个带GUI程序或者其他需要给用户传递文字信息的程序的时候，就很有可能需要用到国际化的知识，来总结一下。</p>\n</blockquote>\n<p>所谓的国际化，就是使编写的程序可以适应不同的语言环境，比如，在中文环境下，可以与用户使用中文交互，在英文环境下则切换为英文。而这个切换过程不需要修改代码或者仅仅修改少量的代码。java给我们提供了这样的实现。</p>\n<h2 id=\"java文件国际化\"><a href=\"#java文件国际化\" class=\"headerlink\" title=\"java文件国际化\"></a>java文件国际化</h2><p>我们通过将与界面显示有关系的资源提取出来到资源文件中，然后读取不同的资源文件来达到国际化的目的。在java中，这些是通过ResourceBundle这个类来实现的。</p>\n<p>ResourceBundle分为两种，一种是ListResourceBundle,另一种是PropertyResourceBundle。下面介绍这两种ResourceBundle的使用方法：</p>\n<p>首先列出demo工程的代码结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">TestResourceBundle</div><div class=\"line\">|</div><div class=\"line\">|--src</div><div class=\"line\">    |</div><div class=\"line\">    |--kyu</div><div class=\"line\">        |</div><div class=\"line\">        |--bundle</div><div class=\"line\">        |    |</div><div class=\"line\">        |    |--ListResourceTranslator.java</div><div class=\"line\">        |    |</div><div class=\"line\">        |    |--PropertyResourceTranslator.java</div><div class=\"line\">        |    |</div><div class=\"line\">        |    |--ResourceTranslator.java</div><div class=\"line\">        |</div><div class=\"line\">        |--test</div><div class=\"line\">        |   |</div><div class=\"line\">        |   |--App.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_en_Us.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_zh_CN.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_en_Us.properties</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_zh_CN.properties</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors.properties</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"PropertyResourceBundle\"><a href=\"#PropertyResourceBundle\" class=\"headerlink\" title=\"PropertyResourceBundle\"></a>PropertyResourceBundle</h3><ol>\n<li>首先需要建立若干语言的properties文件： 自定义名<em>语言代码</em>国别代码.properties</li>\n</ol>\n<p>比如：errors_en_US.properties, errors_zh_CN.properties</p>\n<p>其中的语言代码和国别代码，分别是你要国际化的语言。需要几种语言，就添加几个properties文件。</p>\n<p><a href=\"https://worldwide.espacenet.com/help?locale=cn_EP&amp;method=handleHelpTopic&amp;topic=countrycodes\" target=\"_blank\" rel=\"external\">国别代码</a></p>\n<p><a href=\"http://www.lingoes.cn/zh/translator/langcode.htm\" target=\"_blank\" rel=\"external\">语言代码</a></p>\n<p>通过打印java所支持的语言和国家查看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void printLocal() &#123;</div><div class=\"line\">\t\tLocale[] localeList = Locale.getAvailableLocales();</div><div class=\"line\">\t\tfor (int i = 0; i &lt; localeList.length; i++) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(localeList[i].getDisplayCountry() + &quot;: &quot; + localeList[i].getCountry());</div><div class=\"line\">\t\t\tSystem.out.println(localeList[i].getDisplayLanguage() + &quot;: &quot; + localeList[i].getLanguage());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>建立默认语言的properties文件：自定义名.properties</li>\n</ol>\n<p>比如：errors.properties</p>\n<p>当所需语言的properties文件不存在的时候就会默认读取这个文件中的内容</p>\n<p>注意，资源文件都必须是ISO-8859-1编码，对于中文等非西方语系，可通过JDK自带的工具native2ascii进行处理，在Eclipse中也可以安装插件SimplePropertiesEditor来处理这类文件。</p>\n<ol>\n<li>使用</li>\n</ol>\n<p>ResourceTranslator.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.bundle;</div><div class=\"line\"></div><div class=\"line\">import java.util.Locale;</div><div class=\"line\">import java.util.ResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public abstract class ResourceTranslator &#123;</div><div class=\"line\">\tprotected ResourceBundle bundle;</div><div class=\"line\">\tprotected Locale lc;</div><div class=\"line\">\tprotected static final String PROP_FILE = &quot;kyu.errors&quot;;</div><div class=\"line\"></div><div class=\"line\">    public String translate(String id) &#123;</div><div class=\"line\">        return bundle.getString(id);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>PropertyResourceTranslator.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.bundle;</div><div class=\"line\"></div><div class=\"line\">import java.util.Locale;</div><div class=\"line\">import java.util.PropertyResourceBundle;</div><div class=\"line\">import java.util.ResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public class PropertyResourceTranslator extends ResourceTranslator&#123;</div><div class=\"line\">    public PropertyResourceTranslator() &#123;</div><div class=\"line\">        lc = Locale.getDefault();</div><div class=\"line\">        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    public PropertyResourceTranslator(String language, String country) &#123;</div><div class=\"line\">    \tlc = new Locale(language, country);</div><div class=\"line\">        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>App.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.test;</div><div class=\"line\"></div><div class=\"line\">import kyu.bundle.ListResourceTranslator;</div><div class=\"line\">import kyu.bundle.PropertyResourceTranslator;</div><div class=\"line\"></div><div class=\"line\">public class App &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\ttestPropertyResource();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tprivate static void testPropertyResource() &#123;</div><div class=\"line\">\t\tPropertyResourceTranslator translatorDefault = new PropertyResourceTranslator();</div><div class=\"line\">\t\tPropertyResourceTranslator translatorZH = new PropertyResourceTranslator(&quot;zh&quot;, &quot;CN&quot;);</div><div class=\"line\">\t\tPropertyResourceTranslator translatorEN = new PropertyResourceTranslator(&quot;en&quot;, &quot;US&quot;);</div><div class=\"line\">\t\tString def = translatorDefault.translate(&quot;ERROR-001&quot;);</div><div class=\"line\">\t\tString zh = translatorZH.translate(&quot;ERROR-001&quot;);</div><div class=\"line\">\t\tString en = translatorEN.translate(&quot;ERROR-001&quot;);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(&quot;test PropertyResourceBundle&gt;&gt;&gt;&gt;&gt;&gt;&quot;);</div><div class=\"line\">\t\tSystem.out.println(&quot;default: &quot; + def);</div><div class=\"line\">\t\tSystem.out.println(&quot;zh: &quot; + zh);</div><div class=\"line\">\t\tSystem.out.println(&quot;en: &quot; + en);</div><div class=\"line\">\t&#125;\t</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>.properties文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Errors_en_Us.properties:</div><div class=\"line\">ERROR-001=error password</div><div class=\"line\"></div><div class=\"line\">Errors.properties</div><div class=\"line\">ERROR-001=error password</div><div class=\"line\"></div><div class=\"line\">Errors_zh_CN.properties</div><div class=\"line\">ERROR-001=密码错误</div></pre></td></tr></table></figure>\n<p>执行App.java的测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">test PropertyResourceBundle&gt;&gt;&gt;&gt;&gt;&gt;</div><div class=\"line\">default: 密码错误</div><div class=\"line\">zh: 密码错误</div><div class=\"line\">en: error password</div></pre></td></tr></table></figure>\n<p>可以看到，通过指定Local构造函数的语言和国别代码，就能自动找到对应的.properties，并匹配其中的内容。</p>\n<p>当使用Locale.getDefault()时，自动检测当前的系统环境，从而选择对应的语言。</p>\n<p>还有一点要注意的是： </p>\n<p>PropertyResourceBundle.getBundle(PROP_FILE, lc); </p>\n<p>其中PROP_FILE，为properties文件的路径，此路径为properties文件的完整路径，即 所在完整包名.自定义名称</p>\n<h3 id=\"ListResourceBundle\"><a href=\"#ListResourceBundle\" class=\"headerlink\" title=\"ListResourceBundle\"></a>ListResourceBundle</h3><p>ListResourceBundle的使用与PropertyResourceBundle的使用大同小异，不过是将properties文件换成了.java文件</p>\n<p>ListResourceTranslator.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.bundle;</div><div class=\"line\"></div><div class=\"line\">import java.util.ListResourceBundle;</div><div class=\"line\">import java.util.Locale;</div><div class=\"line\"></div><div class=\"line\">public class ListResourceTranslator extends ResourceTranslator&#123;</div><div class=\"line\">\tpublic ListResourceTranslator() &#123;</div><div class=\"line\">        lc = Locale.getDefault();</div><div class=\"line\">        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    public ListResourceTranslator(String language, String country) &#123;</div><div class=\"line\">    \tlc = new Locale(language, country);</div><div class=\"line\">        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ERRORS_en_US.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu;</div><div class=\"line\"></div><div class=\"line\">import java.util.ListResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public class ERRORS_en_US extends ListResourceBundle&#123;</div><div class=\"line\">\tstatic final Object[][] contents = new String[][] &#123; </div><div class=\"line\">\t\t&#123; &quot;ERROR-001&quot;, &quot;error password&quot; &#125; </div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\tpublic Object[][] getContents() &#123;</div><div class=\"line\">\t\treturn contents;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ERRORS_zh_CN.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu;</div><div class=\"line\"></div><div class=\"line\">import java.util.ListResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public class ERRORS_zh_CN extends ListResourceBundle &#123;</div><div class=\"line\">\tstatic final Object[][] contents = new String[][] &#123; </div><div class=\"line\">\t\t&#123; &quot;ERROR-001&quot;, &quot;密码错误&quot; &#125; </div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\tpublic Object[][] getContents() &#123;</div><div class=\"line\">\t\treturn contents;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>继承了ListResourceBundle的类就相当于前面的properties文件，需要提供一个getContents()方法，返回对应的键值对。</p>\n<p>同样的，要注意ListResourceBundle子类的命名规则，与properties文件相同，路径也与properties文件相同。</p>\n<p>通过App.java的测试(将对应的bundle替换)，可以得到相同的测试结果。</p>\n<h3 id=\"使用Eclipse对java文件进行国际化\"><a href=\"#使用Eclipse对java文件进行国际化\" class=\"headerlink\" title=\"使用Eclipse对java文件进行国际化\"></a>使用Eclipse对java文件进行国际化</h3><p>在需要国际化的类文件上点击右键-&gt;Source-&gt;Externalize Strings…</p>\n<p>出现窗口，Eclipse会自动检测类文件中的字符串，在窗口中可以选择相应的字符串，最后自动生成类似于上面的PropertyResourceTranslator.java和properties文件，完成国际化。</p>\n<p>其原理与以上所讲的相同，故不再详细说明。</p>\n<h2 id=\"Eclipse-RCP国际化\"><a href=\"#Eclipse-RCP国际化\" class=\"headerlink\" title=\"Eclipse RCP国际化\"></a>Eclipse RCP国际化</h2><blockquote>\n<p>最近在使用Eclipse RCP这项技术开发程序，其中也有国际化相关的东西，总结下来。</p>\n</blockquote>\n<p><a href=\"http://www.vogella.com/tutorials/EclipseInternationalization/article.html\" target=\"_blank\" rel=\"external\">Eclipse RCP and Plugin Internationalization - Tutorial</a></p>\n<p>上面这篇文章详细的说明了Eclipse RCP工程中的国际化问题，可以作为一个备忘录。下面介绍一下eclipse rcp中比较常用到的国际化方式：</p>\n<h3 id=\"plugin-xml文件国际化\"><a href=\"#plugin-xml文件国际化\" class=\"headerlink\" title=\"plugin.xml文件国际化\"></a>plugin.xml文件国际化</h3><p>plugin.xml文件中保存了扩展点等相关的信息，当扩展点与界面UI相关时，就需要用到国际化</p>\n<ol>\n<li><p>在工程的根目录下面建立一个plugin.properties资源文件，此文件类似于我们上面提到的errors.properties。当然，也可以建立plugin_zh.properties等文件，这些文件名中的plugin是可以自由定义的。</p>\n</li>\n<li><p>在 MANIFEST.MF文件中增加代码行：Bundle-Localization: plugin</p>\n<p>注意，这个plugin与上面的properties文件名保持一致。</p>\n</li>\n<li><p>plugin.xml配置文件对资源文件进行引用时, 在引用的key前面加一个%，比如：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view</div><div class=\"line\">    id=&quot;org.jkiss.dbeaver.core.databaseNavigator&quot;</div><div class=\"line\">    category=&quot;org.jkiss.dbeaver.core.category&quot;</div><div class=\"line\">    class=&quot;org.jkiss.dbeaver.ui.navigator.database.DatabaseNavigatorView&quot;</div><div class=\"line\">    allowMultiple=&quot;false&quot;</div><div class=\"line\">    icon=&quot;icons/databases.png&quot;</div><div class=\"line\">    name=&quot;%view.database.navigator.title&quot;/&gt;</div><div class=\"line\">&lt;view</div></pre></td></tr></table></figure>\n<h3 id=\"类文件国际化\"><a href=\"#类文件国际化\" class=\"headerlink\" title=\"类文件国际化\"></a>类文件国际化</h3><p>与前面所介绍的java类文件国际化相同，也可以通过选择类文件点击右键-&gt;Source-&gt;Externalize Strings…</p>\n<p>Eclipse IDE会自动帮你完成国际化的一些工作，同样也生成了相关的类和properties文件，但不同的是，生成的类文件内容类似于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">package test;</div><div class=\"line\"></div><div class=\"line\">import org.eclipse.osgi.util.NLS;</div><div class=\"line\"></div><div class=\"line\">public class Messages extends NLS &#123;</div><div class=\"line\">        private static final String BUNDLE_NAME</div><div class=\"line\">                = &quot;test.messages&quot;; //$NON-NLS-1$</div><div class=\"line\">        public static String View_0;</div><div class=\"line\">        public static String View_1;</div><div class=\"line\">        static &#123;</div><div class=\"line\">                // initialize resource bundle</div><div class=\"line\">                NLS.initializeMessages(BUNDLE_NAME, Messages.class);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        private Messages() &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当然，我们也可以手动建立这些文件进行国际化操作~~不再详细说明，可以通过观察IDE的行为进行我们手动的国际化操作~</p>\n","excerpt":"<blockquote>\n<p>使用java编写一个带GUI程序或者其他需要给用户传递文字信息的程序的时候，就很有可能需要用到国际化的知识，来总结一下。</p>\n</blockquote>\n<p>所谓的国际化，就是使编写的程序可以适应不同的语言环境，比如，在中文环境下，可以与用户使用中文交互，在英文环境下则切换为英文。而这个切换过程不需要修改代码或者仅仅修改少量的代码。java给我们提供了这样的实现。</p>\n<h2 id=\"java文件国际化\"><a href=\"#java文件国际化\" class=\"headerlink\" title=\"java文件国际化\"></a>java文件国际化</h2><p>我们通过将与界面显示有关系的资源提取出来到资源文件中，然后读取不同的资源文件来达到国际化的目的。在java中，这些是通过ResourceBundle这个类来实现的。</p>\n<p>ResourceBundle分为两种，一种是ListResourceBundle,另一种是PropertyResourceBundle。下面介绍这两种ResourceBundle的使用方法：</p>\n<p>首先列出demo工程的代码结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">TestResourceBundle</div><div class=\"line\">|</div><div class=\"line\">|--src</div><div class=\"line\">    |</div><div class=\"line\">    |--kyu</div><div class=\"line\">        |</div><div class=\"line\">        |--bundle</div><div class=\"line\">        |    |</div><div class=\"line\">        |    |--ListResourceTranslator.java</div><div class=\"line\">        |    |</div><div class=\"line\">        |    |--PropertyResourceTranslator.java</div><div class=\"line\">        |    |</div><div class=\"line\">        |    |--ResourceTranslator.java</div><div class=\"line\">        |</div><div class=\"line\">        |--test</div><div class=\"line\">        |   |</div><div class=\"line\">        |   |--App.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_en_Us.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_zh_CN.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors.java</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_en_Us.properties</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors_zh_CN.properties</div><div class=\"line\">        |</div><div class=\"line\">        |--Errors.properties</div></pre></td></tr></table></figure>","more":"<h3 id=\"PropertyResourceBundle\"><a href=\"#PropertyResourceBundle\" class=\"headerlink\" title=\"PropertyResourceBundle\"></a>PropertyResourceBundle</h3><ol>\n<li>首先需要建立若干语言的properties文件： 自定义名<em>语言代码</em>国别代码.properties</li>\n</ol>\n<p>比如：errors_en_US.properties, errors_zh_CN.properties</p>\n<p>其中的语言代码和国别代码，分别是你要国际化的语言。需要几种语言，就添加几个properties文件。</p>\n<p><a href=\"https://worldwide.espacenet.com/help?locale=cn_EP&amp;method=handleHelpTopic&amp;topic=countrycodes\">国别代码</a></p>\n<p><a href=\"http://www.lingoes.cn/zh/translator/langcode.htm\">语言代码</a></p>\n<p>通过打印java所支持的语言和国家查看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void printLocal() &#123;</div><div class=\"line\">\t\tLocale[] localeList = Locale.getAvailableLocales();</div><div class=\"line\">\t\tfor (int i = 0; i &lt; localeList.length; i++) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(localeList[i].getDisplayCountry() + &quot;: &quot; + localeList[i].getCountry());</div><div class=\"line\">\t\t\tSystem.out.println(localeList[i].getDisplayLanguage() + &quot;: &quot; + localeList[i].getLanguage());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>建立默认语言的properties文件：自定义名.properties</li>\n</ol>\n<p>比如：errors.properties</p>\n<p>当所需语言的properties文件不存在的时候就会默认读取这个文件中的内容</p>\n<p>注意，资源文件都必须是ISO-8859-1编码，对于中文等非西方语系，可通过JDK自带的工具native2ascii进行处理，在Eclipse中也可以安装插件SimplePropertiesEditor来处理这类文件。</p>\n<ol>\n<li>使用</li>\n</ol>\n<p>ResourceTranslator.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.bundle;</div><div class=\"line\"></div><div class=\"line\">import java.util.Locale;</div><div class=\"line\">import java.util.ResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public abstract class ResourceTranslator &#123;</div><div class=\"line\">\tprotected ResourceBundle bundle;</div><div class=\"line\">\tprotected Locale lc;</div><div class=\"line\">\tprotected static final String PROP_FILE = &quot;kyu.errors&quot;;</div><div class=\"line\"></div><div class=\"line\">    public String translate(String id) &#123;</div><div class=\"line\">        return bundle.getString(id);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>PropertyResourceTranslator.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.bundle;</div><div class=\"line\"></div><div class=\"line\">import java.util.Locale;</div><div class=\"line\">import java.util.PropertyResourceBundle;</div><div class=\"line\">import java.util.ResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public class PropertyResourceTranslator extends ResourceTranslator&#123;</div><div class=\"line\">    public PropertyResourceTranslator() &#123;</div><div class=\"line\">        lc = Locale.getDefault();</div><div class=\"line\">        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    public PropertyResourceTranslator(String language, String country) &#123;</div><div class=\"line\">    \tlc = new Locale(language, country);</div><div class=\"line\">        bundle = PropertyResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>App.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.test;</div><div class=\"line\"></div><div class=\"line\">import kyu.bundle.ListResourceTranslator;</div><div class=\"line\">import kyu.bundle.PropertyResourceTranslator;</div><div class=\"line\"></div><div class=\"line\">public class App &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\ttestPropertyResource();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tprivate static void testPropertyResource() &#123;</div><div class=\"line\">\t\tPropertyResourceTranslator translatorDefault = new PropertyResourceTranslator();</div><div class=\"line\">\t\tPropertyResourceTranslator translatorZH = new PropertyResourceTranslator(&quot;zh&quot;, &quot;CN&quot;);</div><div class=\"line\">\t\tPropertyResourceTranslator translatorEN = new PropertyResourceTranslator(&quot;en&quot;, &quot;US&quot;);</div><div class=\"line\">\t\tString def = translatorDefault.translate(&quot;ERROR-001&quot;);</div><div class=\"line\">\t\tString zh = translatorZH.translate(&quot;ERROR-001&quot;);</div><div class=\"line\">\t\tString en = translatorEN.translate(&quot;ERROR-001&quot;);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(&quot;test PropertyResourceBundle&gt;&gt;&gt;&gt;&gt;&gt;&quot;);</div><div class=\"line\">\t\tSystem.out.println(&quot;default: &quot; + def);</div><div class=\"line\">\t\tSystem.out.println(&quot;zh: &quot; + zh);</div><div class=\"line\">\t\tSystem.out.println(&quot;en: &quot; + en);</div><div class=\"line\">\t&#125;\t</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>.properties文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Errors_en_Us.properties:</div><div class=\"line\">ERROR-001=error password</div><div class=\"line\"></div><div class=\"line\">Errors.properties</div><div class=\"line\">ERROR-001=error password</div><div class=\"line\"></div><div class=\"line\">Errors_zh_CN.properties</div><div class=\"line\">ERROR-001=密码错误</div></pre></td></tr></table></figure>\n<p>执行App.java的测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">test PropertyResourceBundle&gt;&gt;&gt;&gt;&gt;&gt;</div><div class=\"line\">default: 密码错误</div><div class=\"line\">zh: 密码错误</div><div class=\"line\">en: error password</div></pre></td></tr></table></figure>\n<p>可以看到，通过指定Local构造函数的语言和国别代码，就能自动找到对应的.properties，并匹配其中的内容。</p>\n<p>当使用Locale.getDefault()时，自动检测当前的系统环境，从而选择对应的语言。</p>\n<p>还有一点要注意的是： </p>\n<p>PropertyResourceBundle.getBundle(PROP_FILE, lc); </p>\n<p>其中PROP_FILE，为properties文件的路径，此路径为properties文件的完整路径，即 所在完整包名.自定义名称</p>\n<h3 id=\"ListResourceBundle\"><a href=\"#ListResourceBundle\" class=\"headerlink\" title=\"ListResourceBundle\"></a>ListResourceBundle</h3><p>ListResourceBundle的使用与PropertyResourceBundle的使用大同小异，不过是将properties文件换成了.java文件</p>\n<p>ListResourceTranslator.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu.bundle;</div><div class=\"line\"></div><div class=\"line\">import java.util.ListResourceBundle;</div><div class=\"line\">import java.util.Locale;</div><div class=\"line\"></div><div class=\"line\">public class ListResourceTranslator extends ResourceTranslator&#123;</div><div class=\"line\">\tpublic ListResourceTranslator() &#123;</div><div class=\"line\">        lc = Locale.getDefault();</div><div class=\"line\">        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    public ListResourceTranslator(String language, String country) &#123;</div><div class=\"line\">    \tlc = new Locale(language, country);</div><div class=\"line\">        bundle = ListResourceBundle.getBundle(PROP_FILE, lc);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ERRORS_en_US.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu;</div><div class=\"line\"></div><div class=\"line\">import java.util.ListResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public class ERRORS_en_US extends ListResourceBundle&#123;</div><div class=\"line\">\tstatic final Object[][] contents = new String[][] &#123; </div><div class=\"line\">\t\t&#123; &quot;ERROR-001&quot;, &quot;error password&quot; &#125; </div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\tpublic Object[][] getContents() &#123;</div><div class=\"line\">\t\treturn contents;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ERRORS_zh_CN.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">package kyu;</div><div class=\"line\"></div><div class=\"line\">import java.util.ListResourceBundle;</div><div class=\"line\"></div><div class=\"line\">public class ERRORS_zh_CN extends ListResourceBundle &#123;</div><div class=\"line\">\tstatic final Object[][] contents = new String[][] &#123; </div><div class=\"line\">\t\t&#123; &quot;ERROR-001&quot;, &quot;密码错误&quot; &#125; </div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\tpublic Object[][] getContents() &#123;</div><div class=\"line\">\t\treturn contents;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>继承了ListResourceBundle的类就相当于前面的properties文件，需要提供一个getContents()方法，返回对应的键值对。</p>\n<p>同样的，要注意ListResourceBundle子类的命名规则，与properties文件相同，路径也与properties文件相同。</p>\n<p>通过App.java的测试(将对应的bundle替换)，可以得到相同的测试结果。</p>\n<h3 id=\"使用Eclipse对java文件进行国际化\"><a href=\"#使用Eclipse对java文件进行国际化\" class=\"headerlink\" title=\"使用Eclipse对java文件进行国际化\"></a>使用Eclipse对java文件进行国际化</h3><p>在需要国际化的类文件上点击右键-&gt;Source-&gt;Externalize Strings…</p>\n<p>出现窗口，Eclipse会自动检测类文件中的字符串，在窗口中可以选择相应的字符串，最后自动生成类似于上面的PropertyResourceTranslator.java和properties文件，完成国际化。</p>\n<p>其原理与以上所讲的相同，故不再详细说明。</p>\n<h2 id=\"Eclipse-RCP国际化\"><a href=\"#Eclipse-RCP国际化\" class=\"headerlink\" title=\"Eclipse RCP国际化\"></a>Eclipse RCP国际化</h2><blockquote>\n<p>最近在使用Eclipse RCP这项技术开发程序，其中也有国际化相关的东西，总结下来。</p>\n</blockquote>\n<p><a href=\"http://www.vogella.com/tutorials/EclipseInternationalization/article.html\">Eclipse RCP and Plugin Internationalization - Tutorial</a></p>\n<p>上面这篇文章详细的说明了Eclipse RCP工程中的国际化问题，可以作为一个备忘录。下面介绍一下eclipse rcp中比较常用到的国际化方式：</p>\n<h3 id=\"plugin-xml文件国际化\"><a href=\"#plugin-xml文件国际化\" class=\"headerlink\" title=\"plugin.xml文件国际化\"></a>plugin.xml文件国际化</h3><p>plugin.xml文件中保存了扩展点等相关的信息，当扩展点与界面UI相关时，就需要用到国际化</p>\n<ol>\n<li><p>在工程的根目录下面建立一个plugin.properties资源文件，此文件类似于我们上面提到的errors.properties。当然，也可以建立plugin_zh.properties等文件，这些文件名中的plugin是可以自由定义的。</p>\n</li>\n<li><p>在 MANIFEST.MF文件中增加代码行：Bundle-Localization: plugin</p>\n<p>注意，这个plugin与上面的properties文件名保持一致。</p>\n</li>\n<li><p>plugin.xml配置文件对资源文件进行引用时, 在引用的key前面加一个%，比如：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view</div><div class=\"line\">    id=&quot;org.jkiss.dbeaver.core.databaseNavigator&quot;</div><div class=\"line\">    category=&quot;org.jkiss.dbeaver.core.category&quot;</div><div class=\"line\">    class=&quot;org.jkiss.dbeaver.ui.navigator.database.DatabaseNavigatorView&quot;</div><div class=\"line\">    allowMultiple=&quot;false&quot;</div><div class=\"line\">    icon=&quot;icons/databases.png&quot;</div><div class=\"line\">    name=&quot;%view.database.navigator.title&quot;/&gt;</div><div class=\"line\">&lt;view</div></pre></td></tr></table></figure>\n<h3 id=\"类文件国际化\"><a href=\"#类文件国际化\" class=\"headerlink\" title=\"类文件国际化\"></a>类文件国际化</h3><p>与前面所介绍的java类文件国际化相同，也可以通过选择类文件点击右键-&gt;Source-&gt;Externalize Strings…</p>\n<p>Eclipse IDE会自动帮你完成国际化的一些工作，同样也生成了相关的类和properties文件，但不同的是，生成的类文件内容类似于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">package test;</div><div class=\"line\"></div><div class=\"line\">import org.eclipse.osgi.util.NLS;</div><div class=\"line\"></div><div class=\"line\">public class Messages extends NLS &#123;</div><div class=\"line\">        private static final String BUNDLE_NAME</div><div class=\"line\">                = &quot;test.messages&quot;; //$NON-NLS-1$</div><div class=\"line\">        public static String View_0;</div><div class=\"line\">        public static String View_1;</div><div class=\"line\">        static &#123;</div><div class=\"line\">                // initialize resource bundle</div><div class=\"line\">                NLS.initializeMessages(BUNDLE_NAME, Messages.class);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        private Messages() &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当然，我们也可以手动建立这些文件进行国际化操作~~不再详细说明，可以通过观察IDE的行为进行我们手动的国际化操作~</p>"},{"layout":"post","title":"java序列化与反序列化","date":"2017-03-22T12:14:46.000Z","_content":"\n## 什么是序列化\n\n所谓的序列化，即把java对象以二进制形式保存到内存、文件或者进行网络传输。从二进制的形式恢复成为java对象，即反序列化。\n\n通过序列化可以将对象持久化，或者从一个地方传输到另一个地方。这方面的应用有RMI，远程方法调用。\n\njava中实现序列化有两种方式，实现Serializable接口或者Externalizable接口。这篇总结只讨论Serializable的情况。\n\n```\npublic class SerializeTest implements Serializable{\n\t    private static final long serialVersionUID = 1L;\n\t\tpublic String str;\n\t\tpublic SerializeTest(String str) {\n\t\t\t   this.str = str;\n\t\t}\n\t\t\n\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t\t   SerializeTest test = new SerializeTest(\"hello\");\n\t\t\t   ByteArrayOutputStream oStream = new ByteArrayOutputStream();\n\t\t\t   ObjectOutputStream objectOutputStream = new ObjectOutputStream(oStream);\n\t\t\t   objectOutputStream.writeObject(test);//序列化\n\t\t\t   \n\t\t\t   ObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(oStream.toByteArray()));\n\t\t\t   SerializeTest obj = (SerializeTest) inputStream.readObject();//反序列化\n\t\t\t   System.out.println(obj.str);\n\t\t}\n}\n```\n上面的代码演示了类SerializeTest实现序列化和反序列化的过程。\n\n<!-- more -->\n\n所有的序列化和反序列化过程都是java默认实现的，你只需要实现接口Serializable，就能得到一个实现了序列化的类。\n通过ObjectOutputStream和ObjectInputStream分别将序列化对象输出或者写入到某个流当中。流的目的地可以是内存字节数组(上例)、文件、或者网络。\n\n下面研究一下序列化过程中的几个问题：\n\n## 静态变量如何序列化\n\n```\npublic class SeriaUtil {\n\t    ByteArrayInputStream bInputStream;\n\t    ByteArrayOutputStream byOutputStream;\n\t    ObjectOutputStream outputStream ;\n\t    ObjectInputStream inputStream;\n\t    \n        public void seria(Object test) throws IOException {\n        \tif (byOutputStream == null) {\n        \t\tbyOutputStream = new ByteArrayOutputStream();\n\t\t\t}\n        \tif (outputStream == null) {\n        \t\toutputStream = new ObjectOutputStream(byOutputStream);\n\t\t\t}\n\t\t    outputStream.writeObject(test);\n//\t\t   System.out.println(byOutputStream.toByteArray().length); \n        }\n        \n        public Object  reSeria() throws IOException, ClassNotFoundException {\n\t        \tif (bInputStream == null) {\n\t\t\t\t\t  bInputStream = new ByteArrayInputStream(byOutputStream.toByteArray());\n\t\t\t\t}\n\t        \tif (inputStream == null) {\n\t        \t\tinputStream = new ObjectInputStream(bInputStream);\n\t\t\t\t}\n\t\t\t    Object obj =  inputStream.readObject();\n\t\t\t    return obj;\n        }\n}\n\npublic class StaticTest implements Serializable{\n\tprivate static final long serialVersionUID = 1L;\n\tpublic static int A = 0;\n\tpublic static String B = \"hello\";\n\t\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t    //先序列化类，此时 A=0 B = hello\n\t\t    SeriaUtil seriaUtil = new SeriaUtil();\n\t\t    StaticTest test = new StaticTest();\n\t\t    seriaUtil.seria(test);\n\t\t    //修改 静态变量的值\n\t\t    StaticTest.A = 1;\n\t\t    StaticTest.B = \"world\";\n\t\t    \n\t\t    StaticTest obj = (StaticTest) seriaUtil.reSeria();\n\t\t    //输出 A = 1 B = world\n\t\t    System.out.println(obj.A);\n\t\t    System.out.println(obj.B);\n\t}\n}\n```\n上面的代码说明了，静态变量不会被序列化。\n\n序列化StaticTest实例test时，静态变量 A=0 B=\"hello\"，序列化之后，修改StaticTest类的静态变量值，A=1 B=\"world\"，\n此时反序列化得到之前序列化的实例对象赋给obj，发现obj的静态变量变为A=1 B=\"world\"，说明静态变量并未序列化成功。\n\n事实上，在序列化对象时，会忽略对象中的静态变量。很好理解，静态变量是属于类的，而不是某个对象的状态。我们序列化面向的是对象，是想要将对象的状态保存下来，所以\n静态变量不会被序列化。反序列化得到的对象中的静态变量的值是当前jvm中静态变量的值。静态变量对于同一个jvm中同一个类加载器加载的类来说，是一样的。对于同一个静态变量，不会存在同一个类的不同实例拥有不同的值。\n\n## 同一对象序列化两次，反序列化后得到的两个对象是否相等\n\n这个问题提到的相等，是指是否为同一对象，即==关系\n\n在某些情况下，确保这种关系是很重要的。比如王经理和李经理拥有同一个办公室，即存在引用关系：\n\n```\npublic class Manager{\n    Room room;\n    public Manager(Room r){\n        room = r;\n    }\n}\n\npublic class Room{}\n\npublic class APP{\n    public void main(String args[]){\n        Room room = new Room();\n        Manager wang = new Manager(room);\n        Manager li = new Manager(room);\n    }\n}\n```\n反序列化之后，wang，li，room的这种引用关系不应该发生变化。通过代码验证一下：\n\n```\npublic class ReferenceTest implements Serializable{\n\t\tpublic String a;\n\t\tpublic ReferenceTest() {\n\t\t\ta = \"hah\";\n\t\t}\n\t\tpublic static void main(String[] args) throws Exception {\n\t\t\t  System.out.println(\"构造对象********************\");\n\t\t\t  ReferenceTest test = new ReferenceTest();\n\t\t\t  System.out.println(\"序列化**********************\");\n\t\t\t  SeriaUtil util = new SeriaUtil();\n\t\t\t  util.seria(test);\n\t\t\t  util.seria(test);//第二次序列化该对象\n\t\t\t  System.out.println(\"反序列化**********************\");\n\t\t\t  ReferenceTest obj = (ReferenceTest) util.reSeria();\n\t\t\t  ReferenceTest obj1 = (ReferenceTest) util.reSeria();\n\t\t\t  System.out.println(obj == obj1);//true\n\t\t\t  System.out.println(obj == test);//false\n\t\t}\n}\n```\n上面的例子证明（System.out.println(obj == obj1);//true），同一对象序列化多次之后，反序列化得到的多个对象相等，即内存地址一致。\n\n使用同一个ObjectOutputStream对象序列化某个实例时，如果该实例还没有被序列化过，则序列化，若之前已经序列化过，则不再进行序列化，只是做一个标记而已。\n所以在反序列化时，可以保持原有的引用关系。\n\nSystem.out.println(obj == test);//false   也可以理解，反序列化之后重建了该对象，内存地址必然是新分配的，故obj != test\n\n## 父类没有实现Serializable，父类中的变量如何序列化\n\n```\npublic class SuperTest{\n       public String superB;\n       public SuperTest() {\n    \t   superB = \"hehe\";\n    \t   System.out.println(\"super 无参构造函数\");\n       }\n       \n       public SuperTest(String b){\n    \t   System.out.println(\"super 有参构造函数\");\n    \t   superB = b;\n       }\n\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t\t  System.out.println(\"构造对象*******************\");\n\t\t\t  SonTest sonTest = new SonTest(\"son\", \"super\");\n\t\t\t  System.out.println(\"序列化*********************\");\n\t\t\t  SeriaUtil  seriaUtil = new SeriaUtil();\n\t\t\t  seriaUtil.seria(sonTest);\n\t\t\t  System.out.println(\"反序列化******************\");\n\t\t\t  SonTest obj = (SonTest) seriaUtil.reSeria();\n\t\t\t  System.out.println(obj.sonA);\n\t\t\t  System.out.println(obj.superB);\n\t\t}\n}\n\nclass SonTest extends SuperTest  implements Serializable{\n\t private static final long serialVersionUID = 1L;\n\t public String sonA;\n\t public SonTest() {\n\t\t System.out.println(\"son 无参构造函数\");\n\t }\n\t \n\t public SonTest(String a, String b) {\n\t\t super(b);\n\t\t System.out.println(\"son 有参构造函数\");\n\t\t sonA = a;\n\t }\n}\n```\n输出：\n\n构造对象*******************\nsuper 有参构造函数\nson 有参构造函数\n序列化*********************\n反序列化******************\nsuper 无参构造函数\nson\nhehe\n\n通过上面的代码可以看出，父类如果没有实现serializable，反序列化时会调用父类的无参构造函数初始化父类当中的变量。\n\n所以，我们可以通过显示声明父类的无参构造函数，并在其中初始化变量值来控制反序列化后父类变量的值。\n\n## transient使用\n\n实现了serializable接口的类在序列化时默认会将所有的非静态变量进行序列化。我们可以控制某些字段不被默认的序列化机制序列化。\n\n比如，有些字段是跟当前系统环境相关的或者涉及到隐私的，需要保密的。这些字段是不可以被序列化到文件中或者通过网络传输的。我们可以通过为这些字段声明\ntransient关键字，保证其不被序列化。\n\n被关键字transient声明的变量不会被序列化，反序列化时该变量会被自动填充为null（int 为0）。我们也可以为这些字段实现自己的序列化机制。\n\n```\npublic class TransientTest implements Serializable{\n\t   private static final long serialVersionUID = 1L;\n\t\tpublic transient String  str;\n\t    public TransientTest() {\n\t    \tstr = \"hello\";\n\t    }\n\t    \n\t    private void writeObject(ObjectOutputStream out) throws IOException {\n\t        out.defaultWriteObject();\n\t        String encryption = \"key\" + str;\n\t        out.writeObject(encryption);\n\t    }\n\n\t    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n\t        in.defaultReadObject();\n\t       String encryption =  (String) in.readObject();\n\t       str = encryption.substring(\"key\".length(), encryption.length());\n\t    }\n\t    \n\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t\t  TransientTest test = new TransientTest();\n\t\t\t  SeriaUtil util = new SeriaUtil();\n\t\t\t  util.seria(test);\n\t\t\t  TransientTest reSeria = (TransientTest) util.reSeria();\n\t\t\t  System.out.println(reSeria.str);//hello\n\t\t}\n}\n```\n通过实现writeObject和readObject实现自己的序列化机制。上面的代码模拟了一个加密的序列化过程。\n\n## 成员变量没有实现序列化\n\n序列化某个实例时，如果这个实例含有对象类型的成员变量，那么同时会触发该变量的序列化机制。这时就要求这个成员变量也实现Serializable接口，如果没有实现该接口，抛出异常。\n\n```\npublic class VariableTest implements Serializable{\n\tVariable variable ;\n\tpublic VariableTest() {\n\t\tvariable = new Variable();\n\t}\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t    System.out.println(\"构造对象*************\");\n\t\t    VariableTest variableTest = new VariableTest();\n\t\t    System.out.println(\"序列化**************\");\n\t\t    SeriaUtil util = new SeriaUtil();\n\t\t    //抛出异常：java.io.NotSerializableException\n\t\t    util.seria(variableTest);\n\t\t    System.out.println(\"反序列化****************\");\n\t\t    VariableTest obj = (VariableTest) util.reSeria();\n\t\t    System.out.println(obj.variable.a);//抛出异常：Exception in thread \"main\" java.io.NotSerializableException: space.kyu.Variable\n\t}\n}\nclass Variable {\n\tpublic String a;\n\tpublic Variable(){\n\t\ta = \"hehe\";\n\t}\n}\n```\n\n## 单例模式下的序列化\n\n```\npublic class SingleTest implements Serializable{\n\tpublic static SingleTest instance = new SingleTest();\n\tprivate SingleTest(){}\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\tSingleTest test = SingleTest.instance;\n\t\tSeriaUtil util = new SeriaUtil();\n\t\tutil.seria(test);\n\t\tSingleTest reSeria = (SingleTest) util.reSeria();\n\t\tSystem.out.println(reSeria == SingleTest.instance);//false\n\t}\n}\n```\n\n由上面的代码可以看出，有两个SingleTest实例同时存在，通过反序列化破坏了单例模式。反序列化时会开辟新的内存空间重新实例化对象，所以单例模式被破坏。\n\n为了解决这种问题，可以实现readResolve()方法。\n\n```\npublic class SingleTest implements Serializable{\n\tpublic static SingleTest instance = new SingleTest();\n\tprivate SingleTest(){}\n\tprivate Object readResolve() {\n        return SingleTest.instance;\n    }\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\tSingleTest test = SingleTest.instance;\n\t\tSeriaUtil util = new SeriaUtil();\n\t\tutil.seria(test);\n\t\tSingleTest reSeria = (SingleTest) util.reSeria();\n\t\tSystem.out.println(reSeria == SingleTest.instance);//true\n\t}\n}\n```\n\n## 序列化版本\n\n代码是在不断的演化的。1.1版本的类可以读取1.0版本的序列化文件吗？这就涉及到序列化的版本管理。\n\n每个序列化版本都有其唯一的ID，他是数据域类型和方法签名的指纹。当类的定义产生变化时，他的指纹也会跟着产生变化，对象流将拒绝读入具有不同指纹的对象。\n如果想保持早期版本的兼容，首先要获取这个类早期版本的指纹。\n\n我们可以使用 jdk自带的工具 serialver 获得这个指纹：serialver Test\n```\nstaic final long serialVersionUID = -1423859403827594712L\n```\n然后将1.1版本中Test类的serialVersionUID常量定义为上面的值，即可序列化老版本的代码。\n\n如果一个类具有名为serialVersionUID的常量，那么java就不会再主动计算这个值，而是直接将其作为这个版本类的指纹。没有特殊要求的话，一般都显示的声明serialVersionUID：`private static final long serialVersionUID = 1L;`来保证兼容性\n\n如果对象流中的对象具有在当前版本中没有的数据域，那么对象流会忽略这些数据；如果当前版本具有对象流中所没有的数据域，那么这些新加的域将被设为默认值。\n\n## 序列化与克隆\n\n反序列化重新构建对象的机制提供了一种克隆对象的简便途径，只要对应的类可序列化即可。\n\n做法很简单：直接将对象序列化到输出流当中，然后将其读回。这样产生的对象是对现有对象的一个深拷贝。\n\n```\npublic class CloneTest implements Serializable, Cloneable {\n\tpublic String str;\n\tpublic CloneTest(String str) {\n\t\tthis.str =str;\n\t}\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\tSeriaUtil util = new SeriaUtil();\n\t\ttry {\n\t\t\tutil.seria(this);\n\t\t\tCloneTest reSeria = (CloneTest) util.reSeria();\n\t\t\treturn reSeria;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t} \n\t\t\n\t}\n\tpublic static void main(String[] args) throws CloneNotSupportedException {\n\t\tCloneTest test = new CloneTest(\"hi\");\n\t\tCloneTest clone = (CloneTest) test.clone();\n\t\tSystem.out.println(clone.str);//hi\n\t\tSystem.out.println(clone == test);//false\n\t}\n}\n\n```\n这样克隆对象的优点是简单，缺点是比普通的克隆实现要慢的多。","source":"_posts/java序列化与反序列化.md","raw":"---\nlayout: post\ntitle: java序列化与反序列化\ndate: 2017-03-22 20:14:46\ncategories: 编程\ntags: java\n---\n\n## 什么是序列化\n\n所谓的序列化，即把java对象以二进制形式保存到内存、文件或者进行网络传输。从二进制的形式恢复成为java对象，即反序列化。\n\n通过序列化可以将对象持久化，或者从一个地方传输到另一个地方。这方面的应用有RMI，远程方法调用。\n\njava中实现序列化有两种方式，实现Serializable接口或者Externalizable接口。这篇总结只讨论Serializable的情况。\n\n```\npublic class SerializeTest implements Serializable{\n\t    private static final long serialVersionUID = 1L;\n\t\tpublic String str;\n\t\tpublic SerializeTest(String str) {\n\t\t\t   this.str = str;\n\t\t}\n\t\t\n\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t\t   SerializeTest test = new SerializeTest(\"hello\");\n\t\t\t   ByteArrayOutputStream oStream = new ByteArrayOutputStream();\n\t\t\t   ObjectOutputStream objectOutputStream = new ObjectOutputStream(oStream);\n\t\t\t   objectOutputStream.writeObject(test);//序列化\n\t\t\t   \n\t\t\t   ObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(oStream.toByteArray()));\n\t\t\t   SerializeTest obj = (SerializeTest) inputStream.readObject();//反序列化\n\t\t\t   System.out.println(obj.str);\n\t\t}\n}\n```\n上面的代码演示了类SerializeTest实现序列化和反序列化的过程。\n\n<!-- more -->\n\n所有的序列化和反序列化过程都是java默认实现的，你只需要实现接口Serializable，就能得到一个实现了序列化的类。\n通过ObjectOutputStream和ObjectInputStream分别将序列化对象输出或者写入到某个流当中。流的目的地可以是内存字节数组(上例)、文件、或者网络。\n\n下面研究一下序列化过程中的几个问题：\n\n## 静态变量如何序列化\n\n```\npublic class SeriaUtil {\n\t    ByteArrayInputStream bInputStream;\n\t    ByteArrayOutputStream byOutputStream;\n\t    ObjectOutputStream outputStream ;\n\t    ObjectInputStream inputStream;\n\t    \n        public void seria(Object test) throws IOException {\n        \tif (byOutputStream == null) {\n        \t\tbyOutputStream = new ByteArrayOutputStream();\n\t\t\t}\n        \tif (outputStream == null) {\n        \t\toutputStream = new ObjectOutputStream(byOutputStream);\n\t\t\t}\n\t\t    outputStream.writeObject(test);\n//\t\t   System.out.println(byOutputStream.toByteArray().length); \n        }\n        \n        public Object  reSeria() throws IOException, ClassNotFoundException {\n\t        \tif (bInputStream == null) {\n\t\t\t\t\t  bInputStream = new ByteArrayInputStream(byOutputStream.toByteArray());\n\t\t\t\t}\n\t        \tif (inputStream == null) {\n\t        \t\tinputStream = new ObjectInputStream(bInputStream);\n\t\t\t\t}\n\t\t\t    Object obj =  inputStream.readObject();\n\t\t\t    return obj;\n        }\n}\n\npublic class StaticTest implements Serializable{\n\tprivate static final long serialVersionUID = 1L;\n\tpublic static int A = 0;\n\tpublic static String B = \"hello\";\n\t\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t    //先序列化类，此时 A=0 B = hello\n\t\t    SeriaUtil seriaUtil = new SeriaUtil();\n\t\t    StaticTest test = new StaticTest();\n\t\t    seriaUtil.seria(test);\n\t\t    //修改 静态变量的值\n\t\t    StaticTest.A = 1;\n\t\t    StaticTest.B = \"world\";\n\t\t    \n\t\t    StaticTest obj = (StaticTest) seriaUtil.reSeria();\n\t\t    //输出 A = 1 B = world\n\t\t    System.out.println(obj.A);\n\t\t    System.out.println(obj.B);\n\t}\n}\n```\n上面的代码说明了，静态变量不会被序列化。\n\n序列化StaticTest实例test时，静态变量 A=0 B=\"hello\"，序列化之后，修改StaticTest类的静态变量值，A=1 B=\"world\"，\n此时反序列化得到之前序列化的实例对象赋给obj，发现obj的静态变量变为A=1 B=\"world\"，说明静态变量并未序列化成功。\n\n事实上，在序列化对象时，会忽略对象中的静态变量。很好理解，静态变量是属于类的，而不是某个对象的状态。我们序列化面向的是对象，是想要将对象的状态保存下来，所以\n静态变量不会被序列化。反序列化得到的对象中的静态变量的值是当前jvm中静态变量的值。静态变量对于同一个jvm中同一个类加载器加载的类来说，是一样的。对于同一个静态变量，不会存在同一个类的不同实例拥有不同的值。\n\n## 同一对象序列化两次，反序列化后得到的两个对象是否相等\n\n这个问题提到的相等，是指是否为同一对象，即==关系\n\n在某些情况下，确保这种关系是很重要的。比如王经理和李经理拥有同一个办公室，即存在引用关系：\n\n```\npublic class Manager{\n    Room room;\n    public Manager(Room r){\n        room = r;\n    }\n}\n\npublic class Room{}\n\npublic class APP{\n    public void main(String args[]){\n        Room room = new Room();\n        Manager wang = new Manager(room);\n        Manager li = new Manager(room);\n    }\n}\n```\n反序列化之后，wang，li，room的这种引用关系不应该发生变化。通过代码验证一下：\n\n```\npublic class ReferenceTest implements Serializable{\n\t\tpublic String a;\n\t\tpublic ReferenceTest() {\n\t\t\ta = \"hah\";\n\t\t}\n\t\tpublic static void main(String[] args) throws Exception {\n\t\t\t  System.out.println(\"构造对象********************\");\n\t\t\t  ReferenceTest test = new ReferenceTest();\n\t\t\t  System.out.println(\"序列化**********************\");\n\t\t\t  SeriaUtil util = new SeriaUtil();\n\t\t\t  util.seria(test);\n\t\t\t  util.seria(test);//第二次序列化该对象\n\t\t\t  System.out.println(\"反序列化**********************\");\n\t\t\t  ReferenceTest obj = (ReferenceTest) util.reSeria();\n\t\t\t  ReferenceTest obj1 = (ReferenceTest) util.reSeria();\n\t\t\t  System.out.println(obj == obj1);//true\n\t\t\t  System.out.println(obj == test);//false\n\t\t}\n}\n```\n上面的例子证明（System.out.println(obj == obj1);//true），同一对象序列化多次之后，反序列化得到的多个对象相等，即内存地址一致。\n\n使用同一个ObjectOutputStream对象序列化某个实例时，如果该实例还没有被序列化过，则序列化，若之前已经序列化过，则不再进行序列化，只是做一个标记而已。\n所以在反序列化时，可以保持原有的引用关系。\n\nSystem.out.println(obj == test);//false   也可以理解，反序列化之后重建了该对象，内存地址必然是新分配的，故obj != test\n\n## 父类没有实现Serializable，父类中的变量如何序列化\n\n```\npublic class SuperTest{\n       public String superB;\n       public SuperTest() {\n    \t   superB = \"hehe\";\n    \t   System.out.println(\"super 无参构造函数\");\n       }\n       \n       public SuperTest(String b){\n    \t   System.out.println(\"super 有参构造函数\");\n    \t   superB = b;\n       }\n\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t\t  System.out.println(\"构造对象*******************\");\n\t\t\t  SonTest sonTest = new SonTest(\"son\", \"super\");\n\t\t\t  System.out.println(\"序列化*********************\");\n\t\t\t  SeriaUtil  seriaUtil = new SeriaUtil();\n\t\t\t  seriaUtil.seria(sonTest);\n\t\t\t  System.out.println(\"反序列化******************\");\n\t\t\t  SonTest obj = (SonTest) seriaUtil.reSeria();\n\t\t\t  System.out.println(obj.sonA);\n\t\t\t  System.out.println(obj.superB);\n\t\t}\n}\n\nclass SonTest extends SuperTest  implements Serializable{\n\t private static final long serialVersionUID = 1L;\n\t public String sonA;\n\t public SonTest() {\n\t\t System.out.println(\"son 无参构造函数\");\n\t }\n\t \n\t public SonTest(String a, String b) {\n\t\t super(b);\n\t\t System.out.println(\"son 有参构造函数\");\n\t\t sonA = a;\n\t }\n}\n```\n输出：\n\n构造对象*******************\nsuper 有参构造函数\nson 有参构造函数\n序列化*********************\n反序列化******************\nsuper 无参构造函数\nson\nhehe\n\n通过上面的代码可以看出，父类如果没有实现serializable，反序列化时会调用父类的无参构造函数初始化父类当中的变量。\n\n所以，我们可以通过显示声明父类的无参构造函数，并在其中初始化变量值来控制反序列化后父类变量的值。\n\n## transient使用\n\n实现了serializable接口的类在序列化时默认会将所有的非静态变量进行序列化。我们可以控制某些字段不被默认的序列化机制序列化。\n\n比如，有些字段是跟当前系统环境相关的或者涉及到隐私的，需要保密的。这些字段是不可以被序列化到文件中或者通过网络传输的。我们可以通过为这些字段声明\ntransient关键字，保证其不被序列化。\n\n被关键字transient声明的变量不会被序列化，反序列化时该变量会被自动填充为null（int 为0）。我们也可以为这些字段实现自己的序列化机制。\n\n```\npublic class TransientTest implements Serializable{\n\t   private static final long serialVersionUID = 1L;\n\t\tpublic transient String  str;\n\t    public TransientTest() {\n\t    \tstr = \"hello\";\n\t    }\n\t    \n\t    private void writeObject(ObjectOutputStream out) throws IOException {\n\t        out.defaultWriteObject();\n\t        String encryption = \"key\" + str;\n\t        out.writeObject(encryption);\n\t    }\n\n\t    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n\t        in.defaultReadObject();\n\t       String encryption =  (String) in.readObject();\n\t       str = encryption.substring(\"key\".length(), encryption.length());\n\t    }\n\t    \n\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t\t  TransientTest test = new TransientTest();\n\t\t\t  SeriaUtil util = new SeriaUtil();\n\t\t\t  util.seria(test);\n\t\t\t  TransientTest reSeria = (TransientTest) util.reSeria();\n\t\t\t  System.out.println(reSeria.str);//hello\n\t\t}\n}\n```\n通过实现writeObject和readObject实现自己的序列化机制。上面的代码模拟了一个加密的序列化过程。\n\n## 成员变量没有实现序列化\n\n序列化某个实例时，如果这个实例含有对象类型的成员变量，那么同时会触发该变量的序列化机制。这时就要求这个成员变量也实现Serializable接口，如果没有实现该接口，抛出异常。\n\n```\npublic class VariableTest implements Serializable{\n\tVariable variable ;\n\tpublic VariableTest() {\n\t\tvariable = new Variable();\n\t}\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t    System.out.println(\"构造对象*************\");\n\t\t    VariableTest variableTest = new VariableTest();\n\t\t    System.out.println(\"序列化**************\");\n\t\t    SeriaUtil util = new SeriaUtil();\n\t\t    //抛出异常：java.io.NotSerializableException\n\t\t    util.seria(variableTest);\n\t\t    System.out.println(\"反序列化****************\");\n\t\t    VariableTest obj = (VariableTest) util.reSeria();\n\t\t    System.out.println(obj.variable.a);//抛出异常：Exception in thread \"main\" java.io.NotSerializableException: space.kyu.Variable\n\t}\n}\nclass Variable {\n\tpublic String a;\n\tpublic Variable(){\n\t\ta = \"hehe\";\n\t}\n}\n```\n\n## 单例模式下的序列化\n\n```\npublic class SingleTest implements Serializable{\n\tpublic static SingleTest instance = new SingleTest();\n\tprivate SingleTest(){}\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\tSingleTest test = SingleTest.instance;\n\t\tSeriaUtil util = new SeriaUtil();\n\t\tutil.seria(test);\n\t\tSingleTest reSeria = (SingleTest) util.reSeria();\n\t\tSystem.out.println(reSeria == SingleTest.instance);//false\n\t}\n}\n```\n\n由上面的代码可以看出，有两个SingleTest实例同时存在，通过反序列化破坏了单例模式。反序列化时会开辟新的内存空间重新实例化对象，所以单例模式被破坏。\n\n为了解决这种问题，可以实现readResolve()方法。\n\n```\npublic class SingleTest implements Serializable{\n\tpublic static SingleTest instance = new SingleTest();\n\tprivate SingleTest(){}\n\tprivate Object readResolve() {\n        return SingleTest.instance;\n    }\n\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\tSingleTest test = SingleTest.instance;\n\t\tSeriaUtil util = new SeriaUtil();\n\t\tutil.seria(test);\n\t\tSingleTest reSeria = (SingleTest) util.reSeria();\n\t\tSystem.out.println(reSeria == SingleTest.instance);//true\n\t}\n}\n```\n\n## 序列化版本\n\n代码是在不断的演化的。1.1版本的类可以读取1.0版本的序列化文件吗？这就涉及到序列化的版本管理。\n\n每个序列化版本都有其唯一的ID，他是数据域类型和方法签名的指纹。当类的定义产生变化时，他的指纹也会跟着产生变化，对象流将拒绝读入具有不同指纹的对象。\n如果想保持早期版本的兼容，首先要获取这个类早期版本的指纹。\n\n我们可以使用 jdk自带的工具 serialver 获得这个指纹：serialver Test\n```\nstaic final long serialVersionUID = -1423859403827594712L\n```\n然后将1.1版本中Test类的serialVersionUID常量定义为上面的值，即可序列化老版本的代码。\n\n如果一个类具有名为serialVersionUID的常量，那么java就不会再主动计算这个值，而是直接将其作为这个版本类的指纹。没有特殊要求的话，一般都显示的声明serialVersionUID：`private static final long serialVersionUID = 1L;`来保证兼容性\n\n如果对象流中的对象具有在当前版本中没有的数据域，那么对象流会忽略这些数据；如果当前版本具有对象流中所没有的数据域，那么这些新加的域将被设为默认值。\n\n## 序列化与克隆\n\n反序列化重新构建对象的机制提供了一种克隆对象的简便途径，只要对应的类可序列化即可。\n\n做法很简单：直接将对象序列化到输出流当中，然后将其读回。这样产生的对象是对现有对象的一个深拷贝。\n\n```\npublic class CloneTest implements Serializable, Cloneable {\n\tpublic String str;\n\tpublic CloneTest(String str) {\n\t\tthis.str =str;\n\t}\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\tSeriaUtil util = new SeriaUtil();\n\t\ttry {\n\t\t\tutil.seria(this);\n\t\t\tCloneTest reSeria = (CloneTest) util.reSeria();\n\t\t\treturn reSeria;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t} \n\t\t\n\t}\n\tpublic static void main(String[] args) throws CloneNotSupportedException {\n\t\tCloneTest test = new CloneTest(\"hi\");\n\t\tCloneTest clone = (CloneTest) test.clone();\n\t\tSystem.out.println(clone.str);//hi\n\t\tSystem.out.println(clone == test);//false\n\t}\n}\n\n```\n这样克隆对象的优点是简单，缺点是比普通的克隆实现要慢的多。","slug":"java序列化与反序列化","published":1,"updated":"2017-04-11T13:08:38.842Z","comments":1,"photos":[],"link":"","_id":"cj4vch4es0021x3gcys3bnp16","content":"<h2 id=\"什么是序列化\"><a href=\"#什么是序列化\" class=\"headerlink\" title=\"什么是序列化\"></a>什么是序列化</h2><p>所谓的序列化，即把java对象以二进制形式保存到内存、文件或者进行网络传输。从二进制的形式恢复成为java对象，即反序列化。</p>\n<p>通过序列化可以将对象持久化，或者从一个地方传输到另一个地方。这方面的应用有RMI，远程方法调用。</p>\n<p>java中实现序列化有两种方式，实现Serializable接口或者Externalizable接口。这篇总结只讨论Serializable的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SerializeTest implements Serializable&#123;</div><div class=\"line\">\t    private static final long serialVersionUID = 1L;</div><div class=\"line\">\t\tpublic String str;</div><div class=\"line\">\t\tpublic SerializeTest(String str) &#123;</div><div class=\"line\">\t\t\t   this.str = str;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t\t   SerializeTest test = new SerializeTest(&quot;hello&quot;);</div><div class=\"line\">\t\t\t   ByteArrayOutputStream oStream = new ByteArrayOutputStream();</div><div class=\"line\">\t\t\t   ObjectOutputStream objectOutputStream = new ObjectOutputStream(oStream);</div><div class=\"line\">\t\t\t   objectOutputStream.writeObject(test);//序列化</div><div class=\"line\">\t\t\t   </div><div class=\"line\">\t\t\t   ObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(oStream.toByteArray()));</div><div class=\"line\">\t\t\t   SerializeTest obj = (SerializeTest) inputStream.readObject();//反序列化</div><div class=\"line\">\t\t\t   System.out.println(obj.str);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码演示了类SerializeTest实现序列化和反序列化的过程。</p>\n<a id=\"more\"></a>\n<p>所有的序列化和反序列化过程都是java默认实现的，你只需要实现接口Serializable，就能得到一个实现了序列化的类。<br>通过ObjectOutputStream和ObjectInputStream分别将序列化对象输出或者写入到某个流当中。流的目的地可以是内存字节数组(上例)、文件、或者网络。</p>\n<p>下面研究一下序列化过程中的几个问题：</p>\n<h2 id=\"静态变量如何序列化\"><a href=\"#静态变量如何序列化\" class=\"headerlink\" title=\"静态变量如何序列化\"></a>静态变量如何序列化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SeriaUtil &#123;</div><div class=\"line\">\t    ByteArrayInputStream bInputStream;</div><div class=\"line\">\t    ByteArrayOutputStream byOutputStream;</div><div class=\"line\">\t    ObjectOutputStream outputStream ;</div><div class=\"line\">\t    ObjectInputStream inputStream;</div><div class=\"line\">\t    </div><div class=\"line\">        public void seria(Object test) throws IOException &#123;</div><div class=\"line\">        \tif (byOutputStream == null) &#123;</div><div class=\"line\">        \t\tbyOutputStream = new ByteArrayOutputStream();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">        \tif (outputStream == null) &#123;</div><div class=\"line\">        \t\toutputStream = new ObjectOutputStream(byOutputStream);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t    outputStream.writeObject(test);</div><div class=\"line\">//\t\t   System.out.println(byOutputStream.toByteArray().length); </div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        public Object  reSeria() throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t        \tif (bInputStream == null) &#123;</div><div class=\"line\">\t\t\t\t\t  bInputStream = new ByteArrayInputStream(byOutputStream.toByteArray());</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t        \tif (inputStream == null) &#123;</div><div class=\"line\">\t        \t\tinputStream = new ObjectInputStream(bInputStream);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t    Object obj =  inputStream.readObject();</div><div class=\"line\">\t\t\t    return obj;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class StaticTest implements Serializable&#123;</div><div class=\"line\">\tprivate static final long serialVersionUID = 1L;</div><div class=\"line\">\tpublic static int A = 0;</div><div class=\"line\">\tpublic static String B = &quot;hello&quot;;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t    //先序列化类，此时 A=0 B = hello</div><div class=\"line\">\t\t    SeriaUtil seriaUtil = new SeriaUtil();</div><div class=\"line\">\t\t    StaticTest test = new StaticTest();</div><div class=\"line\">\t\t    seriaUtil.seria(test);</div><div class=\"line\">\t\t    //修改 静态变量的值</div><div class=\"line\">\t\t    StaticTest.A = 1;</div><div class=\"line\">\t\t    StaticTest.B = &quot;world&quot;;</div><div class=\"line\">\t\t    </div><div class=\"line\">\t\t    StaticTest obj = (StaticTest) seriaUtil.reSeria();</div><div class=\"line\">\t\t    //输出 A = 1 B = world</div><div class=\"line\">\t\t    System.out.println(obj.A);</div><div class=\"line\">\t\t    System.out.println(obj.B);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码说明了，静态变量不会被序列化。</p>\n<p>序列化StaticTest实例test时，静态变量 A=0 B=”hello”，序列化之后，修改StaticTest类的静态变量值，A=1 B=”world”，<br>此时反序列化得到之前序列化的实例对象赋给obj，发现obj的静态变量变为A=1 B=”world”，说明静态变量并未序列化成功。</p>\n<p>事实上，在序列化对象时，会忽略对象中的静态变量。很好理解，静态变量是属于类的，而不是某个对象的状态。我们序列化面向的是对象，是想要将对象的状态保存下来，所以<br>静态变量不会被序列化。反序列化得到的对象中的静态变量的值是当前jvm中静态变量的值。静态变量对于同一个jvm中同一个类加载器加载的类来说，是一样的。对于同一个静态变量，不会存在同一个类的不同实例拥有不同的值。</p>\n<h2 id=\"同一对象序列化两次，反序列化后得到的两个对象是否相等\"><a href=\"#同一对象序列化两次，反序列化后得到的两个对象是否相等\" class=\"headerlink\" title=\"同一对象序列化两次，反序列化后得到的两个对象是否相等\"></a>同一对象序列化两次，反序列化后得到的两个对象是否相等</h2><p>这个问题提到的相等，是指是否为同一对象，即==关系</p>\n<p>在某些情况下，确保这种关系是很重要的。比如王经理和李经理拥有同一个办公室，即存在引用关系：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Manager&#123;</div><div class=\"line\">    Room room;</div><div class=\"line\">    public Manager(Room r)&#123;</div><div class=\"line\">        room = r;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class Room&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">public class APP&#123;</div><div class=\"line\">    public void main(String args[])&#123;</div><div class=\"line\">        Room room = new Room();</div><div class=\"line\">        Manager wang = new Manager(room);</div><div class=\"line\">        Manager li = new Manager(room);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>反序列化之后，wang，li，room的这种引用关系不应该发生变化。通过代码验证一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ReferenceTest implements Serializable&#123;</div><div class=\"line\">\t\tpublic String a;</div><div class=\"line\">\t\tpublic ReferenceTest() &#123;</div><div class=\"line\">\t\t\ta = &quot;hah&quot;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tpublic static void main(String[] args) throws Exception &#123;</div><div class=\"line\">\t\t\t  System.out.println(&quot;构造对象********************&quot;);</div><div class=\"line\">\t\t\t  ReferenceTest test = new ReferenceTest();</div><div class=\"line\">\t\t\t  System.out.println(&quot;序列化**********************&quot;);</div><div class=\"line\">\t\t\t  SeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\t\t  util.seria(test);</div><div class=\"line\">\t\t\t  util.seria(test);//第二次序列化该对象</div><div class=\"line\">\t\t\t  System.out.println(&quot;反序列化**********************&quot;);</div><div class=\"line\">\t\t\t  ReferenceTest obj = (ReferenceTest) util.reSeria();</div><div class=\"line\">\t\t\t  ReferenceTest obj1 = (ReferenceTest) util.reSeria();</div><div class=\"line\">\t\t\t  System.out.println(obj == obj1);//true</div><div class=\"line\">\t\t\t  System.out.println(obj == test);//false</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的例子证明（System.out.println(obj == obj1);//true），同一对象序列化多次之后，反序列化得到的多个对象相等，即内存地址一致。</p>\n<p>使用同一个ObjectOutputStream对象序列化某个实例时，如果该实例还没有被序列化过，则序列化，若之前已经序列化过，则不再进行序列化，只是做一个标记而已。<br>所以在反序列化时，可以保持原有的引用关系。</p>\n<p>System.out.println(obj == test);//false   也可以理解，反序列化之后重建了该对象，内存地址必然是新分配的，故obj != test</p>\n<h2 id=\"父类没有实现Serializable，父类中的变量如何序列化\"><a href=\"#父类没有实现Serializable，父类中的变量如何序列化\" class=\"headerlink\" title=\"父类没有实现Serializable，父类中的变量如何序列化\"></a>父类没有实现Serializable，父类中的变量如何序列化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SuperTest&#123;</div><div class=\"line\">       public String superB;</div><div class=\"line\">       public SuperTest() &#123;</div><div class=\"line\">    \t   superB = &quot;hehe&quot;;</div><div class=\"line\">    \t   System.out.println(&quot;super 无参构造函数&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       public SuperTest(String b)&#123;</div><div class=\"line\">    \t   System.out.println(&quot;super 有参构造函数&quot;);</div><div class=\"line\">    \t   superB = b;</div><div class=\"line\">       &#125;</div><div class=\"line\">\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t\t  System.out.println(&quot;构造对象*******************&quot;);</div><div class=\"line\">\t\t\t  SonTest sonTest = new SonTest(&quot;son&quot;, &quot;super&quot;);</div><div class=\"line\">\t\t\t  System.out.println(&quot;序列化*********************&quot;);</div><div class=\"line\">\t\t\t  SeriaUtil  seriaUtil = new SeriaUtil();</div><div class=\"line\">\t\t\t  seriaUtil.seria(sonTest);</div><div class=\"line\">\t\t\t  System.out.println(&quot;反序列化******************&quot;);</div><div class=\"line\">\t\t\t  SonTest obj = (SonTest) seriaUtil.reSeria();</div><div class=\"line\">\t\t\t  System.out.println(obj.sonA);</div><div class=\"line\">\t\t\t  System.out.println(obj.superB);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class SonTest extends SuperTest  implements Serializable&#123;</div><div class=\"line\">\t private static final long serialVersionUID = 1L;</div><div class=\"line\">\t public String sonA;</div><div class=\"line\">\t public SonTest() &#123;</div><div class=\"line\">\t\t System.out.println(&quot;son 无参构造函数&quot;);</div><div class=\"line\">\t &#125;</div><div class=\"line\">\t </div><div class=\"line\">\t public SonTest(String a, String b) &#123;</div><div class=\"line\">\t\t super(b);</div><div class=\"line\">\t\t System.out.println(&quot;son 有参构造函数&quot;);</div><div class=\"line\">\t\t sonA = a;</div><div class=\"line\">\t &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：</p>\n<p>构造对象<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong><br>super 有参构造函数<br>son 有参构造函数<br>序列化<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong><br>反序列化<strong><strong><strong><strong>**</strong></strong></strong></strong><br>super 无参构造函数<br>son<br>hehe</p>\n<p>通过上面的代码可以看出，父类如果没有实现serializable，反序列化时会调用父类的无参构造函数初始化父类当中的变量。</p>\n<p>所以，我们可以通过显示声明父类的无参构造函数，并在其中初始化变量值来控制反序列化后父类变量的值。</p>\n<h2 id=\"transient使用\"><a href=\"#transient使用\" class=\"headerlink\" title=\"transient使用\"></a>transient使用</h2><p>实现了serializable接口的类在序列化时默认会将所有的非静态变量进行序列化。我们可以控制某些字段不被默认的序列化机制序列化。</p>\n<p>比如，有些字段是跟当前系统环境相关的或者涉及到隐私的，需要保密的。这些字段是不可以被序列化到文件中或者通过网络传输的。我们可以通过为这些字段声明<br>transient关键字，保证其不被序列化。</p>\n<p>被关键字transient声明的变量不会被序列化，反序列化时该变量会被自动填充为null（int 为0）。我们也可以为这些字段实现自己的序列化机制。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TransientTest implements Serializable&#123;</div><div class=\"line\">\t   private static final long serialVersionUID = 1L;</div><div class=\"line\">\t\tpublic transient String  str;</div><div class=\"line\">\t    public TransientTest() &#123;</div><div class=\"line\">\t    \tstr = &quot;hello&quot;;</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    </div><div class=\"line\">\t    private void writeObject(ObjectOutputStream out) throws IOException &#123;</div><div class=\"line\">\t        out.defaultWriteObject();</div><div class=\"line\">\t        String encryption = &quot;key&quot; + str;</div><div class=\"line\">\t        out.writeObject(encryption);</div><div class=\"line\">\t    &#125;</div><div class=\"line\"></div><div class=\"line\">\t    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t        in.defaultReadObject();</div><div class=\"line\">\t       String encryption =  (String) in.readObject();</div><div class=\"line\">\t       str = encryption.substring(&quot;key&quot;.length(), encryption.length());</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    </div><div class=\"line\">\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t\t  TransientTest test = new TransientTest();</div><div class=\"line\">\t\t\t  SeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\t\t  util.seria(test);</div><div class=\"line\">\t\t\t  TransientTest reSeria = (TransientTest) util.reSeria();</div><div class=\"line\">\t\t\t  System.out.println(reSeria.str);//hello</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过实现writeObject和readObject实现自己的序列化机制。上面的代码模拟了一个加密的序列化过程。</p>\n<h2 id=\"成员变量没有实现序列化\"><a href=\"#成员变量没有实现序列化\" class=\"headerlink\" title=\"成员变量没有实现序列化\"></a>成员变量没有实现序列化</h2><p>序列化某个实例时，如果这个实例含有对象类型的成员变量，那么同时会触发该变量的序列化机制。这时就要求这个成员变量也实现Serializable接口，如果没有实现该接口，抛出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class VariableTest implements Serializable&#123;</div><div class=\"line\">\tVariable variable ;</div><div class=\"line\">\tpublic VariableTest() &#123;</div><div class=\"line\">\t\tvariable = new Variable();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t    System.out.println(&quot;构造对象*************&quot;);</div><div class=\"line\">\t\t    VariableTest variableTest = new VariableTest();</div><div class=\"line\">\t\t    System.out.println(&quot;序列化**************&quot;);</div><div class=\"line\">\t\t    SeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\t    //抛出异常：java.io.NotSerializableException</div><div class=\"line\">\t\t    util.seria(variableTest);</div><div class=\"line\">\t\t    System.out.println(&quot;反序列化****************&quot;);</div><div class=\"line\">\t\t    VariableTest obj = (VariableTest) util.reSeria();</div><div class=\"line\">\t\t    System.out.println(obj.variable.a);//抛出异常：Exception in thread &quot;main&quot; java.io.NotSerializableException: space.kyu.Variable</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class Variable &#123;</div><div class=\"line\">\tpublic String a;</div><div class=\"line\">\tpublic Variable()&#123;</div><div class=\"line\">\t\ta = &quot;hehe&quot;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"单例模式下的序列化\"><a href=\"#单例模式下的序列化\" class=\"headerlink\" title=\"单例模式下的序列化\"></a>单例模式下的序列化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SingleTest implements Serializable&#123;</div><div class=\"line\">\tpublic static SingleTest instance = new SingleTest();</div><div class=\"line\">\tprivate SingleTest()&#123;&#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\tSingleTest test = SingleTest.instance;</div><div class=\"line\">\t\tSeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\tutil.seria(test);</div><div class=\"line\">\t\tSingleTest reSeria = (SingleTest) util.reSeria();</div><div class=\"line\">\t\tSystem.out.println(reSeria == SingleTest.instance);//false</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由上面的代码可以看出，有两个SingleTest实例同时存在，通过反序列化破坏了单例模式。反序列化时会开辟新的内存空间重新实例化对象，所以单例模式被破坏。</p>\n<p>为了解决这种问题，可以实现readResolve()方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SingleTest implements Serializable&#123;</div><div class=\"line\">\tpublic static SingleTest instance = new SingleTest();</div><div class=\"line\">\tprivate SingleTest()&#123;&#125;</div><div class=\"line\">\tprivate Object readResolve() &#123;</div><div class=\"line\">        return SingleTest.instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\tSingleTest test = SingleTest.instance;</div><div class=\"line\">\t\tSeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\tutil.seria(test);</div><div class=\"line\">\t\tSingleTest reSeria = (SingleTest) util.reSeria();</div><div class=\"line\">\t\tSystem.out.println(reSeria == SingleTest.instance);//true</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"序列化版本\"><a href=\"#序列化版本\" class=\"headerlink\" title=\"序列化版本\"></a>序列化版本</h2><p>代码是在不断的演化的。1.1版本的类可以读取1.0版本的序列化文件吗？这就涉及到序列化的版本管理。</p>\n<p>每个序列化版本都有其唯一的ID，他是数据域类型和方法签名的指纹。当类的定义产生变化时，他的指纹也会跟着产生变化，对象流将拒绝读入具有不同指纹的对象。<br>如果想保持早期版本的兼容，首先要获取这个类早期版本的指纹。</p>\n<p>我们可以使用 jdk自带的工具 serialver 获得这个指纹：serialver Test<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">staic final long serialVersionUID = -1423859403827594712L</div></pre></td></tr></table></figure></p>\n<p>然后将1.1版本中Test类的serialVersionUID常量定义为上面的值，即可序列化老版本的代码。</p>\n<p>如果一个类具有名为serialVersionUID的常量，那么java就不会再主动计算这个值，而是直接将其作为这个版本类的指纹。没有特殊要求的话，一般都显示的声明serialVersionUID：<code>private static final long serialVersionUID = 1L;</code>来保证兼容性</p>\n<p>如果对象流中的对象具有在当前版本中没有的数据域，那么对象流会忽略这些数据；如果当前版本具有对象流中所没有的数据域，那么这些新加的域将被设为默认值。</p>\n<h2 id=\"序列化与克隆\"><a href=\"#序列化与克隆\" class=\"headerlink\" title=\"序列化与克隆\"></a>序列化与克隆</h2><p>反序列化重新构建对象的机制提供了一种克隆对象的简便途径，只要对应的类可序列化即可。</p>\n<p>做法很简单：直接将对象序列化到输出流当中，然后将其读回。这样产生的对象是对现有对象的一个深拷贝。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CloneTest implements Serializable, Cloneable &#123;</div><div class=\"line\">\tpublic String str;</div><div class=\"line\">\tpublic CloneTest(String str) &#123;</div><div class=\"line\">\t\tthis.str =str;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tprotected Object clone() throws CloneNotSupportedException &#123;</div><div class=\"line\">\t\tSeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tutil.seria(this);</div><div class=\"line\">\t\t\tCloneTest reSeria = (CloneTest) util.reSeria();</div><div class=\"line\">\t\t\treturn reSeria;</div><div class=\"line\">\t\t&#125; catch (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\treturn null;</div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws CloneNotSupportedException &#123;</div><div class=\"line\">\t\tCloneTest test = new CloneTest(&quot;hi&quot;);</div><div class=\"line\">\t\tCloneTest clone = (CloneTest) test.clone();</div><div class=\"line\">\t\tSystem.out.println(clone.str);//hi</div><div class=\"line\">\t\tSystem.out.println(clone == test);//false</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样克隆对象的优点是简单，缺点是比普通的克隆实现要慢的多。</p>\n","excerpt":"<h2 id=\"什么是序列化\"><a href=\"#什么是序列化\" class=\"headerlink\" title=\"什么是序列化\"></a>什么是序列化</h2><p>所谓的序列化，即把java对象以二进制形式保存到内存、文件或者进行网络传输。从二进制的形式恢复成为java对象，即反序列化。</p>\n<p>通过序列化可以将对象持久化，或者从一个地方传输到另一个地方。这方面的应用有RMI，远程方法调用。</p>\n<p>java中实现序列化有两种方式，实现Serializable接口或者Externalizable接口。这篇总结只讨论Serializable的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SerializeTest implements Serializable&#123;</div><div class=\"line\">\t    private static final long serialVersionUID = 1L;</div><div class=\"line\">\t\tpublic String str;</div><div class=\"line\">\t\tpublic SerializeTest(String str) &#123;</div><div class=\"line\">\t\t\t   this.str = str;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t\t   SerializeTest test = new SerializeTest(&quot;hello&quot;);</div><div class=\"line\">\t\t\t   ByteArrayOutputStream oStream = new ByteArrayOutputStream();</div><div class=\"line\">\t\t\t   ObjectOutputStream objectOutputStream = new ObjectOutputStream(oStream);</div><div class=\"line\">\t\t\t   objectOutputStream.writeObject(test);//序列化</div><div class=\"line\">\t\t\t   </div><div class=\"line\">\t\t\t   ObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(oStream.toByteArray()));</div><div class=\"line\">\t\t\t   SerializeTest obj = (SerializeTest) inputStream.readObject();//反序列化</div><div class=\"line\">\t\t\t   System.out.println(obj.str);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码演示了类SerializeTest实现序列化和反序列化的过程。</p>","more":"<p>所有的序列化和反序列化过程都是java默认实现的，你只需要实现接口Serializable，就能得到一个实现了序列化的类。<br>通过ObjectOutputStream和ObjectInputStream分别将序列化对象输出或者写入到某个流当中。流的目的地可以是内存字节数组(上例)、文件、或者网络。</p>\n<p>下面研究一下序列化过程中的几个问题：</p>\n<h2 id=\"静态变量如何序列化\"><a href=\"#静态变量如何序列化\" class=\"headerlink\" title=\"静态变量如何序列化\"></a>静态变量如何序列化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SeriaUtil &#123;</div><div class=\"line\">\t    ByteArrayInputStream bInputStream;</div><div class=\"line\">\t    ByteArrayOutputStream byOutputStream;</div><div class=\"line\">\t    ObjectOutputStream outputStream ;</div><div class=\"line\">\t    ObjectInputStream inputStream;</div><div class=\"line\">\t    </div><div class=\"line\">        public void seria(Object test) throws IOException &#123;</div><div class=\"line\">        \tif (byOutputStream == null) &#123;</div><div class=\"line\">        \t\tbyOutputStream = new ByteArrayOutputStream();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">        \tif (outputStream == null) &#123;</div><div class=\"line\">        \t\toutputStream = new ObjectOutputStream(byOutputStream);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t    outputStream.writeObject(test);</div><div class=\"line\">//\t\t   System.out.println(byOutputStream.toByteArray().length); </div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        public Object  reSeria() throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t        \tif (bInputStream == null) &#123;</div><div class=\"line\">\t\t\t\t\t  bInputStream = new ByteArrayInputStream(byOutputStream.toByteArray());</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t        \tif (inputStream == null) &#123;</div><div class=\"line\">\t        \t\tinputStream = new ObjectInputStream(bInputStream);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t    Object obj =  inputStream.readObject();</div><div class=\"line\">\t\t\t    return obj;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class StaticTest implements Serializable&#123;</div><div class=\"line\">\tprivate static final long serialVersionUID = 1L;</div><div class=\"line\">\tpublic static int A = 0;</div><div class=\"line\">\tpublic static String B = &quot;hello&quot;;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t    //先序列化类，此时 A=0 B = hello</div><div class=\"line\">\t\t    SeriaUtil seriaUtil = new SeriaUtil();</div><div class=\"line\">\t\t    StaticTest test = new StaticTest();</div><div class=\"line\">\t\t    seriaUtil.seria(test);</div><div class=\"line\">\t\t    //修改 静态变量的值</div><div class=\"line\">\t\t    StaticTest.A = 1;</div><div class=\"line\">\t\t    StaticTest.B = &quot;world&quot;;</div><div class=\"line\">\t\t    </div><div class=\"line\">\t\t    StaticTest obj = (StaticTest) seriaUtil.reSeria();</div><div class=\"line\">\t\t    //输出 A = 1 B = world</div><div class=\"line\">\t\t    System.out.println(obj.A);</div><div class=\"line\">\t\t    System.out.println(obj.B);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码说明了，静态变量不会被序列化。</p>\n<p>序列化StaticTest实例test时，静态变量 A=0 B=”hello”，序列化之后，修改StaticTest类的静态变量值，A=1 B=”world”，<br>此时反序列化得到之前序列化的实例对象赋给obj，发现obj的静态变量变为A=1 B=”world”，说明静态变量并未序列化成功。</p>\n<p>事实上，在序列化对象时，会忽略对象中的静态变量。很好理解，静态变量是属于类的，而不是某个对象的状态。我们序列化面向的是对象，是想要将对象的状态保存下来，所以<br>静态变量不会被序列化。反序列化得到的对象中的静态变量的值是当前jvm中静态变量的值。静态变量对于同一个jvm中同一个类加载器加载的类来说，是一样的。对于同一个静态变量，不会存在同一个类的不同实例拥有不同的值。</p>\n<h2 id=\"同一对象序列化两次，反序列化后得到的两个对象是否相等\"><a href=\"#同一对象序列化两次，反序列化后得到的两个对象是否相等\" class=\"headerlink\" title=\"同一对象序列化两次，反序列化后得到的两个对象是否相等\"></a>同一对象序列化两次，反序列化后得到的两个对象是否相等</h2><p>这个问题提到的相等，是指是否为同一对象，即==关系</p>\n<p>在某些情况下，确保这种关系是很重要的。比如王经理和李经理拥有同一个办公室，即存在引用关系：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Manager&#123;</div><div class=\"line\">    Room room;</div><div class=\"line\">    public Manager(Room r)&#123;</div><div class=\"line\">        room = r;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class Room&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">public class APP&#123;</div><div class=\"line\">    public void main(String args[])&#123;</div><div class=\"line\">        Room room = new Room();</div><div class=\"line\">        Manager wang = new Manager(room);</div><div class=\"line\">        Manager li = new Manager(room);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>反序列化之后，wang，li，room的这种引用关系不应该发生变化。通过代码验证一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ReferenceTest implements Serializable&#123;</div><div class=\"line\">\t\tpublic String a;</div><div class=\"line\">\t\tpublic ReferenceTest() &#123;</div><div class=\"line\">\t\t\ta = &quot;hah&quot;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tpublic static void main(String[] args) throws Exception &#123;</div><div class=\"line\">\t\t\t  System.out.println(&quot;构造对象********************&quot;);</div><div class=\"line\">\t\t\t  ReferenceTest test = new ReferenceTest();</div><div class=\"line\">\t\t\t  System.out.println(&quot;序列化**********************&quot;);</div><div class=\"line\">\t\t\t  SeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\t\t  util.seria(test);</div><div class=\"line\">\t\t\t  util.seria(test);//第二次序列化该对象</div><div class=\"line\">\t\t\t  System.out.println(&quot;反序列化**********************&quot;);</div><div class=\"line\">\t\t\t  ReferenceTest obj = (ReferenceTest) util.reSeria();</div><div class=\"line\">\t\t\t  ReferenceTest obj1 = (ReferenceTest) util.reSeria();</div><div class=\"line\">\t\t\t  System.out.println(obj == obj1);//true</div><div class=\"line\">\t\t\t  System.out.println(obj == test);//false</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的例子证明（System.out.println(obj == obj1);//true），同一对象序列化多次之后，反序列化得到的多个对象相等，即内存地址一致。</p>\n<p>使用同一个ObjectOutputStream对象序列化某个实例时，如果该实例还没有被序列化过，则序列化，若之前已经序列化过，则不再进行序列化，只是做一个标记而已。<br>所以在反序列化时，可以保持原有的引用关系。</p>\n<p>System.out.println(obj == test);//false   也可以理解，反序列化之后重建了该对象，内存地址必然是新分配的，故obj != test</p>\n<h2 id=\"父类没有实现Serializable，父类中的变量如何序列化\"><a href=\"#父类没有实现Serializable，父类中的变量如何序列化\" class=\"headerlink\" title=\"父类没有实现Serializable，父类中的变量如何序列化\"></a>父类没有实现Serializable，父类中的变量如何序列化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SuperTest&#123;</div><div class=\"line\">       public String superB;</div><div class=\"line\">       public SuperTest() &#123;</div><div class=\"line\">    \t   superB = &quot;hehe&quot;;</div><div class=\"line\">    \t   System.out.println(&quot;super 无参构造函数&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       public SuperTest(String b)&#123;</div><div class=\"line\">    \t   System.out.println(&quot;super 有参构造函数&quot;);</div><div class=\"line\">    \t   superB = b;</div><div class=\"line\">       &#125;</div><div class=\"line\">\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t\t  System.out.println(&quot;构造对象*******************&quot;);</div><div class=\"line\">\t\t\t  SonTest sonTest = new SonTest(&quot;son&quot;, &quot;super&quot;);</div><div class=\"line\">\t\t\t  System.out.println(&quot;序列化*********************&quot;);</div><div class=\"line\">\t\t\t  SeriaUtil  seriaUtil = new SeriaUtil();</div><div class=\"line\">\t\t\t  seriaUtil.seria(sonTest);</div><div class=\"line\">\t\t\t  System.out.println(&quot;反序列化******************&quot;);</div><div class=\"line\">\t\t\t  SonTest obj = (SonTest) seriaUtil.reSeria();</div><div class=\"line\">\t\t\t  System.out.println(obj.sonA);</div><div class=\"line\">\t\t\t  System.out.println(obj.superB);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class SonTest extends SuperTest  implements Serializable&#123;</div><div class=\"line\">\t private static final long serialVersionUID = 1L;</div><div class=\"line\">\t public String sonA;</div><div class=\"line\">\t public SonTest() &#123;</div><div class=\"line\">\t\t System.out.println(&quot;son 无参构造函数&quot;);</div><div class=\"line\">\t &#125;</div><div class=\"line\">\t </div><div class=\"line\">\t public SonTest(String a, String b) &#123;</div><div class=\"line\">\t\t super(b);</div><div class=\"line\">\t\t System.out.println(&quot;son 有参构造函数&quot;);</div><div class=\"line\">\t\t sonA = a;</div><div class=\"line\">\t &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：</p>\n<p>构造对象<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong><br>super 有参构造函数<br>son 有参构造函数<br>序列化<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong><br>反序列化<strong><strong><strong><strong>**</strong></strong></strong></strong><br>super 无参构造函数<br>son<br>hehe</p>\n<p>通过上面的代码可以看出，父类如果没有实现serializable，反序列化时会调用父类的无参构造函数初始化父类当中的变量。</p>\n<p>所以，我们可以通过显示声明父类的无参构造函数，并在其中初始化变量值来控制反序列化后父类变量的值。</p>\n<h2 id=\"transient使用\"><a href=\"#transient使用\" class=\"headerlink\" title=\"transient使用\"></a>transient使用</h2><p>实现了serializable接口的类在序列化时默认会将所有的非静态变量进行序列化。我们可以控制某些字段不被默认的序列化机制序列化。</p>\n<p>比如，有些字段是跟当前系统环境相关的或者涉及到隐私的，需要保密的。这些字段是不可以被序列化到文件中或者通过网络传输的。我们可以通过为这些字段声明<br>transient关键字，保证其不被序列化。</p>\n<p>被关键字transient声明的变量不会被序列化，反序列化时该变量会被自动填充为null（int 为0）。我们也可以为这些字段实现自己的序列化机制。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TransientTest implements Serializable&#123;</div><div class=\"line\">\t   private static final long serialVersionUID = 1L;</div><div class=\"line\">\t\tpublic transient String  str;</div><div class=\"line\">\t    public TransientTest() &#123;</div><div class=\"line\">\t    \tstr = &quot;hello&quot;;</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    </div><div class=\"line\">\t    private void writeObject(ObjectOutputStream out) throws IOException &#123;</div><div class=\"line\">\t        out.defaultWriteObject();</div><div class=\"line\">\t        String encryption = &quot;key&quot; + str;</div><div class=\"line\">\t        out.writeObject(encryption);</div><div class=\"line\">\t    &#125;</div><div class=\"line\"></div><div class=\"line\">\t    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t        in.defaultReadObject();</div><div class=\"line\">\t       String encryption =  (String) in.readObject();</div><div class=\"line\">\t       str = encryption.substring(&quot;key&quot;.length(), encryption.length());</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    </div><div class=\"line\">\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t\t  TransientTest test = new TransientTest();</div><div class=\"line\">\t\t\t  SeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\t\t  util.seria(test);</div><div class=\"line\">\t\t\t  TransientTest reSeria = (TransientTest) util.reSeria();</div><div class=\"line\">\t\t\t  System.out.println(reSeria.str);//hello</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过实现writeObject和readObject实现自己的序列化机制。上面的代码模拟了一个加密的序列化过程。</p>\n<h2 id=\"成员变量没有实现序列化\"><a href=\"#成员变量没有实现序列化\" class=\"headerlink\" title=\"成员变量没有实现序列化\"></a>成员变量没有实现序列化</h2><p>序列化某个实例时，如果这个实例含有对象类型的成员变量，那么同时会触发该变量的序列化机制。这时就要求这个成员变量也实现Serializable接口，如果没有实现该接口，抛出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class VariableTest implements Serializable&#123;</div><div class=\"line\">\tVariable variable ;</div><div class=\"line\">\tpublic VariableTest() &#123;</div><div class=\"line\">\t\tvariable = new Variable();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\t    System.out.println(&quot;构造对象*************&quot;);</div><div class=\"line\">\t\t    VariableTest variableTest = new VariableTest();</div><div class=\"line\">\t\t    System.out.println(&quot;序列化**************&quot;);</div><div class=\"line\">\t\t    SeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\t    //抛出异常：java.io.NotSerializableException</div><div class=\"line\">\t\t    util.seria(variableTest);</div><div class=\"line\">\t\t    System.out.println(&quot;反序列化****************&quot;);</div><div class=\"line\">\t\t    VariableTest obj = (VariableTest) util.reSeria();</div><div class=\"line\">\t\t    System.out.println(obj.variable.a);//抛出异常：Exception in thread &quot;main&quot; java.io.NotSerializableException: space.kyu.Variable</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class Variable &#123;</div><div class=\"line\">\tpublic String a;</div><div class=\"line\">\tpublic Variable()&#123;</div><div class=\"line\">\t\ta = &quot;hehe&quot;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"单例模式下的序列化\"><a href=\"#单例模式下的序列化\" class=\"headerlink\" title=\"单例模式下的序列化\"></a>单例模式下的序列化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SingleTest implements Serializable&#123;</div><div class=\"line\">\tpublic static SingleTest instance = new SingleTest();</div><div class=\"line\">\tprivate SingleTest()&#123;&#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\tSingleTest test = SingleTest.instance;</div><div class=\"line\">\t\tSeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\tutil.seria(test);</div><div class=\"line\">\t\tSingleTest reSeria = (SingleTest) util.reSeria();</div><div class=\"line\">\t\tSystem.out.println(reSeria == SingleTest.instance);//false</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由上面的代码可以看出，有两个SingleTest实例同时存在，通过反序列化破坏了单例模式。反序列化时会开辟新的内存空间重新实例化对象，所以单例模式被破坏。</p>\n<p>为了解决这种问题，可以实现readResolve()方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SingleTest implements Serializable&#123;</div><div class=\"line\">\tpublic static SingleTest instance = new SingleTest();</div><div class=\"line\">\tprivate SingleTest()&#123;&#125;</div><div class=\"line\">\tprivate Object readResolve() &#123;</div><div class=\"line\">        return SingleTest.instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">\t\tSingleTest test = SingleTest.instance;</div><div class=\"line\">\t\tSeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\tutil.seria(test);</div><div class=\"line\">\t\tSingleTest reSeria = (SingleTest) util.reSeria();</div><div class=\"line\">\t\tSystem.out.println(reSeria == SingleTest.instance);//true</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"序列化版本\"><a href=\"#序列化版本\" class=\"headerlink\" title=\"序列化版本\"></a>序列化版本</h2><p>代码是在不断的演化的。1.1版本的类可以读取1.0版本的序列化文件吗？这就涉及到序列化的版本管理。</p>\n<p>每个序列化版本都有其唯一的ID，他是数据域类型和方法签名的指纹。当类的定义产生变化时，他的指纹也会跟着产生变化，对象流将拒绝读入具有不同指纹的对象。<br>如果想保持早期版本的兼容，首先要获取这个类早期版本的指纹。</p>\n<p>我们可以使用 jdk自带的工具 serialver 获得这个指纹：serialver Test<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">staic final long serialVersionUID = -1423859403827594712L</div></pre></td></tr></table></figure></p>\n<p>然后将1.1版本中Test类的serialVersionUID常量定义为上面的值，即可序列化老版本的代码。</p>\n<p>如果一个类具有名为serialVersionUID的常量，那么java就不会再主动计算这个值，而是直接将其作为这个版本类的指纹。没有特殊要求的话，一般都显示的声明serialVersionUID：<code>private static final long serialVersionUID = 1L;</code>来保证兼容性</p>\n<p>如果对象流中的对象具有在当前版本中没有的数据域，那么对象流会忽略这些数据；如果当前版本具有对象流中所没有的数据域，那么这些新加的域将被设为默认值。</p>\n<h2 id=\"序列化与克隆\"><a href=\"#序列化与克隆\" class=\"headerlink\" title=\"序列化与克隆\"></a>序列化与克隆</h2><p>反序列化重新构建对象的机制提供了一种克隆对象的简便途径，只要对应的类可序列化即可。</p>\n<p>做法很简单：直接将对象序列化到输出流当中，然后将其读回。这样产生的对象是对现有对象的一个深拷贝。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CloneTest implements Serializable, Cloneable &#123;</div><div class=\"line\">\tpublic String str;</div><div class=\"line\">\tpublic CloneTest(String str) &#123;</div><div class=\"line\">\t\tthis.str =str;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tprotected Object clone() throws CloneNotSupportedException &#123;</div><div class=\"line\">\t\tSeriaUtil util = new SeriaUtil();</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tutil.seria(this);</div><div class=\"line\">\t\t\tCloneTest reSeria = (CloneTest) util.reSeria();</div><div class=\"line\">\t\t\treturn reSeria;</div><div class=\"line\">\t\t&#125; catch (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\treturn null;</div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static void main(String[] args) throws CloneNotSupportedException &#123;</div><div class=\"line\">\t\tCloneTest test = new CloneTest(&quot;hi&quot;);</div><div class=\"line\">\t\tCloneTest clone = (CloneTest) test.clone();</div><div class=\"line\">\t\tSystem.out.println(clone.str);//hi</div><div class=\"line\">\t\tSystem.out.println(clone == test);//false</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样克隆对象的优点是简单，缺点是比普通的克隆实现要慢的多。</p>"},{"layout":"post","title":"java异常的学习","date":"2016-12-13T13:46:52.000Z","_content":"\n>最近的写代码的过程中，遇到很多异常的处理，以前上大学的时候写代码，遇到异常直接给个try catch了事，只是停留在看懂异常能够找出异常抛出点的水平。真正写代码的时候，不了解java的异常机制给自己编程带来很多不便，基础知识很重要！学习之～～\n\n## 异常分类\n\n{% asset_img java.png java异常体系 %}\n\njava异常中的异常大体上可分为两类：Error 与 Exception，他们都继承自Throwable\n\n<!-- more -->\n\n### Error：\n\nError表示一些无法恢复的错误，会导致应用程序中断。比如我们喜闻乐见的OutOfMemoryError(内存溢出)， StackOverflowError(堆栈溢出)等，就是一种Error类型的异常。面对这种类型的异常在我们的应用程序中一般是无法挽救的，将直接导致程序错误退出。因此我们在代码中一般不必去特别关心这种类型的异常。\n\n[Error类型的异常及其子类](https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html)\n\n### Exception:\n\nException是一般常见的异常，我们的应用程序可以处理这些异常，比如NullPointerException、IndexOutOfBoundsException等等。发生这些异常时，可以选择通过捕获这些异常进行处理，使程序可以继续往下执行。\n\nException又可以分为CheckException(检测型异常)与UncheckException(非检测型异常)。\n\n在Exception的子类当中，非检测型异常为RuntimeException及其子类，剩下的异常则为检测型异常。\n\n#### 检测型异常\n\n所谓检测型异常，表示其接受编译器的检测，比如\n\n```\npublic void readFile(String filePath){\n        //编译无法通过\n\t\tFile file = new File(filePath);\n\t\tFileReader fileReader = new FileReader(file);//FileNotFoundException\n\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\tString line = null;\n\t\twhile ((line = bReader.readLine()) != null) {//IOException\n\t\t\tSystem.out.println(line);\n\t\t}\n}\n```\n编译上述代码，编译器会报错，编译无法通过。\n如果是用Eclipse等ide去写这段代码，ide通常就会告诉你这段代码有错误。原因是上述代码会抛出检测型异常IOException。有以下两种修复错误的方法：\n\n```\n//第一种\npublic void readFile(String filePath) throws IOException{\n\t\tFile file = new File(filePath);\n\t\tFileReader fileReader = new FileReader(file);\n\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\tString line = null;\n\t\twhile ((line = bReader.readLine()) != null) {\n\t\t\tSystem.out.println(line);\n\t\t}\n}\n//第二种\npublic void readFile(String filePath) {\n\t\tFile file = new File(filePath);\n\t\ttry {\n\t\t\tFileReader fileReader = new FileReader(file);\n\t\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\t\tString line = null;\n\t\t\twhile ((line = bReader.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t// TODO: handle exception\n\t\t}\n}\n```\n\n第一种方式通过声明throws关键字将该异常继续向上抛出，这种方式下，该方法就抛出了检测型异常，他的调用者就会遇到一样的问题，调用者可以选择使用这种方式继续向调用链上层抛出，或者采用第二种方式处理异常。\n\n第二种方式通过将抛出异常的代码使用try..catch块包裹起来，处理该异常。这种方式下他的调用者无需再次处理该异常。\n\n上面这种类型的异常就是检测型异常，我们必须显示的去处理他，代表的有SQLException、IOException等等。\n\n#### 非检测型异常\n\n与检测型异常相对的，编译阶段不会检测这种类型的异常，当代码中有这种类型的异常抛出时，我们不需要像上面那样显示的处理他，比如：\n\n```\npublic void test() {\n        //编译可以通过\n\t\tthrow new NullPointerException();\n}\n```\n通过throw关键字抛出了一个NullPointerException异常，该异常是RunTimeException的子类，是一个非检测类型的异常。这种类型的异常一般是由程序逻辑错误引起的，比如空指针或者数组越界等等。\n\n对于非检测类型的异常，我们也可以去使用try..catch捕获他，从而进行一些处理。如果我们没有捕获处理这个异常，系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，**这个线程也就退出了**。如果是主程序抛出的异常，**那么这整个程序也就退出了**。\n\nError实际上也是一种非检测型异常。\n\n## 异常处理\n\n### 关键字\n\n了解了异常的分类，我们就可以愉快的处理异常了。记得上大学的时候写的代码，由于不理解java的异常机制，每当遇到检测型异常时，ide会要求在代码中处理这种情况。于是简单的try..catch解决，并在catch块中 e.printStackTrace()，就解决了IDE的报警问题。现在想来，这种代码如果运行在生产环境中，将会多么可怕。\n\n通过上面的总结，我们已经了解了四个关键字：try catch throw throws.\n\nthrow表示将要抛出一个异常，后面跟一个Throwable的实例，throws置于函数的声明当中，表示该函数将会抛出何种类型的异常。\n\ntry catch 一般配合使用，还有一个关键字finally,也是与try catch 配合使用的。有这三种使用方式：\n\ntry..catch  try..finally try..catch..finally\n\ncatch 可以有多个，try只能有一个，finally可选。\n\nfinally用于保证一些资源的释放，因为一般情况下，finally中的语句总会在方法返回之前得到执行。\n\n### try catch finally执行顺序\n\ntry catch finally的执行顺序为 try->catch->finally。\n\n有多个catch时，按照catch块的先后顺序进行匹配，一旦一个异常与一个catch块匹配，则不会再与后面的catch块进行匹配。\n因此，如果我们使用多个catch块捕获异常时，如果多个catch块捕获的异常具有继承关系，注意把继承链中低层次(也就是子类)的放在前面，把继承链中高层次的(也就是父类)放在后面。\n这样做的目的很简单，就是尽量使异常被适合的catch所捕获，这样处理起来比较明确。\n\nfinally块中的代码一般是在try与catch内的控制转移语句执行之前执行的，用来做一些资源释放的操作。控制转移语句包括：return、throw、break 和 continue。\n\n关于finally块的详细解析，参考[关于 Java 中 finally 语句块的深度辨析](https://www.ibm.com/developerworks/cn/java/j-lo-finally/)\n\n另外有一点需要注意：不要在finally中return，因为finally中的return会覆盖已有的返回值，比如try或者catch中的返回值。比如：\n\n```\npublic class TestException {\n    public static void main(String[] args) {\n        String str = new TestException().readFile();\n        System.out.println(str);\n    }\n \n    public String readFile() {\n        try {\n            FileInputStream inputStream = new FileInputStream(\"D:/test.txt\");\n            int ch = inputStream.read();\n            return \"try\";\n        } catch (FileNotFoundException e) {\n            System.out.println(\"file not found\");\n            return \"FileNotFoundException\";\n        }catch (IOException e) {\n            System.out.println(\"io exception\");\n            return \"IOException\";\n        }finally{\n            System.out.println(\"finally block\");\n            //return \"finally\";\n        }\n    }\n}\n```\nD:/test.txt 并不存在，执行结果为:file not found    finally block   FileNotFoundException\n去掉finally中的注释，执行结果为：file not found    finally block   finally\n\n\n## 一些建议\n\n了解了异常机制的基本原理，不一定能够很好的处理异常。当我们遇到异常需要处理的时候，需要遵循几个原则，才能写出更好的代码：\n\n### 不要使用空的catch块\n\n正如前面所说，上学的时候遇到异常时，直接try..catch了事，只是简单地e.printStackTrace(),把堆栈打印出来了。这样可能对定位异常比较有帮助，但是对异常的处理却没有帮助，既没有处理异常，上层代码也无法得知异常的抛出，\n程序会继续运行，有可能出现无法预料的结果。当然，如果程序的逻辑容忍异常可以不用处理，那么可以不处理异常，简单的输出到日志记录即可。处理还需视实际情况而定。\n\n### 在能够处理异常的地方处理异常\n\n换句话说，就是在高层代码中处理异常。尽量将异常抛给上层调用者，由上层调用者统一进行处理。这样会使得程序流程比较清晰。\n\n### 日志打印\n\n只在必要的地方打印日志，如只在异常发生的地方输出日志，然后将异常抛到上层。这样比较容易定位异常，避免每次向上抛出异常时都打印日志，反复打印同一个异常会使得日志变得混乱\n\n### 检测异常与非检测异常的选择\n\n为可恢复的条件使用检查型异常，为编程错误使用运行时异常\n\n在web项目中，我们经常把代码层次分为controller，service,dao等几层。在dao层中一搬会抛出SQLException,这就使得他的调用者必须显示的捕获该异常或者继续抛出。这样提高了代码的耦合性，污染了上层代码。\n在比如接口的声明当中，我们为方法声明了一个检测型异常，那么他的所有实现类都必须作出同样的声明，即使实现类不会抛出异常。而且，所有的调用者都必须显示的捕获异常或者抛出异常，异常就会扩散开来，会使代码变得混乱。\n所以我们应该正确的选择检测型异常和非检测型异常。个人认为，检测型异常的意义就在于提醒用户进行处理，比如一些资源的释放等等。如果该异常出现的很普遍，需要提醒调用者进行处理，那么就是用检测型异常，否则，就使用非检测型异常。\n\n对于已经抛出的检测型异常，我们可以进行封装处理，比如对于第一种情况，污染上层代码的问题：\n\n```\n//处理前\npublic Data getDataById(Long id) throw SQLException {\n //根据 ID 查询数据库\n}\n\n//处理后\npublic Data getDataById(Long id) {\n     try{\n            //根据 ID 查询数据库\n     }catch(SQLException e){\n            //利用非检测异常封装检测异常，降低层次耦合\n            throw new RuntimeException(SQLErrorCode, e);\n     }finally{\n            //关闭连接，清理资源\n     }\n}\n\n```\n我们将一个检测型异常封装成了非检测型异常向上抛出。\n\n### 不要使用Exception捕捉所有潜在的异常\n\n针对具体的异常进行处理，而不是使用Exception捕获所有的异常。这样不利于异常情况的处理，并且如果再次向上抛出时可能会丢书原有的异常信息。 \n\n### 抛出与抽象相适应的异常\n\n换句话说，一个方法所抛出的异常应该在一个抽象层次上定义，该抽象层次与该方法做什么相一致，而不一定与方法的底层实现细节相一致。例如，一个从文件、数据库或者 JNDI 装载资源的方法在不能找到资源时，应该抛出某种 ResourceNotFound 异常（通常使用异常链来保存隐含的原因），而不是更底层的 IOException 、 SQLException 或者 NamingException 。\n\n我们有时候在捕获一个异常后抛出另一个封装后的异常信息，并且希望将原始的异常信息也保持起来，\nthrow抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？\n在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。\n\n### 多线程中的异常\n\n在java多线程程序中，所有线程都不允许抛出未捕获的检测型异常（比如sleep时的InterruptedException),\n也就是说各个线程需要自己把自己的检测型处理掉。\n这一点是通过java.lang.Runnable.run()方法声明(因为此方法声明上没有throw exception部分)进行了约束。\n但是线程依然有可能抛出非检测型异常，当此类异常跑抛出时，线程就会终结，\n而对于主线程和其他线程完全不受影响，且完全感知不到某个线程抛出的异常(也是说完全无法catch到这个异常)。\n\n如果我们不考虑线程内可能出现的异常而导致线程的终结，那么就有可能造成意想不到的后果。如果是使用线程池的话，就有可能导致线程泄漏，这样的错误可能难以察觉，\n最终导致程序挂掉或者内存溢出等等意想不到的问题，但是往往不好追踪问题出现的原因。\n[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章很好的展示了一个多线程发生异常后产生的一系列后果。\n\n对于线程可以自己处理的异常，比较好解决。我们可以在线程内部捕获异常，作一些处理，防止线程退出。比如，[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章中的一个示例：\n\n```\nprivate class SaferPoolWorker extends Thread {\n    public void run() {\n        IncomingResponse ir;\n        while (true) {\n            ir = (IncomingResponse) queue.getNext();\n            PlugIn plugIn = findPlugIn(ir.getResponseId());\n            if (plugIn != null) {\n        try {\n                    plugIn.handleMessage(ir.getResponse());\n                }\n                catch (RuntimeException e) {\n                    // Take some sort of action; \n                    // - log the exception and move on\n                    // - log the exception and restart the worker thread\n                    // - log the exception and unload the offending plug-in\n                }\n            }\n            else\n                log(\"Unknown plug-in for response \" + ir.getResponseId());\n        }\n    }\n}\n```\n但是，当子线程发生异常时，我们需要父线程或者主线程可以感知子线程的异常，也就是得到子线程产生的异常，然后做一些处理。[Java线程池异常处理最佳实践](http://blog.onlycatch.com/post/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)这篇文章给出了很好的总结，\n摘抄其总结如下：\n```\n处理线程池中的异常有两种思路： \n1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池 \n2）由线程池统一处理\n对于execute方法提交的线程，有两种处理方式 \n1）自定义线程池并实现afterExecute方法 \n2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。\n对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。\n```\n\n## 其他\n\n还发现了一个比较有趣的异常处理情况，虽然可能很少碰到，但是碰到了可以参考作者的思路。\n\n[技巧：当不能抛出异常时](https://www.ibm.com/developerworks/cn/java/j-ce/)这篇文章介绍了一种不是很常见的情况：即不能处理，也不能抛出异常(包括非检测型异常)时怎么办？\n\n## 参考\n\n[Java 异常处理的误区和经验总结](http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/)\n\n[Java异常处理和设计](http://www.importnew.com/18994.html)\n\n[Java 理论与实践: 关于异常的争论](https://www.ibm.com/developerworks/cn/java/j-jtp05254/)\n\n","source":"_posts/java异常的学习.md","raw":"---\nlayout: post\ntitle: java异常的学习\ndate: 2016-12-13 21:46:52\ntags: java\n---\n\n>最近的写代码的过程中，遇到很多异常的处理，以前上大学的时候写代码，遇到异常直接给个try catch了事，只是停留在看懂异常能够找出异常抛出点的水平。真正写代码的时候，不了解java的异常机制给自己编程带来很多不便，基础知识很重要！学习之～～\n\n## 异常分类\n\n{% asset_img java.png java异常体系 %}\n\njava异常中的异常大体上可分为两类：Error 与 Exception，他们都继承自Throwable\n\n<!-- more -->\n\n### Error：\n\nError表示一些无法恢复的错误，会导致应用程序中断。比如我们喜闻乐见的OutOfMemoryError(内存溢出)， StackOverflowError(堆栈溢出)等，就是一种Error类型的异常。面对这种类型的异常在我们的应用程序中一般是无法挽救的，将直接导致程序错误退出。因此我们在代码中一般不必去特别关心这种类型的异常。\n\n[Error类型的异常及其子类](https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html)\n\n### Exception:\n\nException是一般常见的异常，我们的应用程序可以处理这些异常，比如NullPointerException、IndexOutOfBoundsException等等。发生这些异常时，可以选择通过捕获这些异常进行处理，使程序可以继续往下执行。\n\nException又可以分为CheckException(检测型异常)与UncheckException(非检测型异常)。\n\n在Exception的子类当中，非检测型异常为RuntimeException及其子类，剩下的异常则为检测型异常。\n\n#### 检测型异常\n\n所谓检测型异常，表示其接受编译器的检测，比如\n\n```\npublic void readFile(String filePath){\n        //编译无法通过\n\t\tFile file = new File(filePath);\n\t\tFileReader fileReader = new FileReader(file);//FileNotFoundException\n\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\tString line = null;\n\t\twhile ((line = bReader.readLine()) != null) {//IOException\n\t\t\tSystem.out.println(line);\n\t\t}\n}\n```\n编译上述代码，编译器会报错，编译无法通过。\n如果是用Eclipse等ide去写这段代码，ide通常就会告诉你这段代码有错误。原因是上述代码会抛出检测型异常IOException。有以下两种修复错误的方法：\n\n```\n//第一种\npublic void readFile(String filePath) throws IOException{\n\t\tFile file = new File(filePath);\n\t\tFileReader fileReader = new FileReader(file);\n\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\tString line = null;\n\t\twhile ((line = bReader.readLine()) != null) {\n\t\t\tSystem.out.println(line);\n\t\t}\n}\n//第二种\npublic void readFile(String filePath) {\n\t\tFile file = new File(filePath);\n\t\ttry {\n\t\t\tFileReader fileReader = new FileReader(file);\n\t\t\tBufferedReader bReader = new BufferedReader(fileReader);\n\t\t\tString line = null;\n\t\t\twhile ((line = bReader.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t// TODO: handle exception\n\t\t}\n}\n```\n\n第一种方式通过声明throws关键字将该异常继续向上抛出，这种方式下，该方法就抛出了检测型异常，他的调用者就会遇到一样的问题，调用者可以选择使用这种方式继续向调用链上层抛出，或者采用第二种方式处理异常。\n\n第二种方式通过将抛出异常的代码使用try..catch块包裹起来，处理该异常。这种方式下他的调用者无需再次处理该异常。\n\n上面这种类型的异常就是检测型异常，我们必须显示的去处理他，代表的有SQLException、IOException等等。\n\n#### 非检测型异常\n\n与检测型异常相对的，编译阶段不会检测这种类型的异常，当代码中有这种类型的异常抛出时，我们不需要像上面那样显示的处理他，比如：\n\n```\npublic void test() {\n        //编译可以通过\n\t\tthrow new NullPointerException();\n}\n```\n通过throw关键字抛出了一个NullPointerException异常，该异常是RunTimeException的子类，是一个非检测类型的异常。这种类型的异常一般是由程序逻辑错误引起的，比如空指针或者数组越界等等。\n\n对于非检测类型的异常，我们也可以去使用try..catch捕获他，从而进行一些处理。如果我们没有捕获处理这个异常，系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，**这个线程也就退出了**。如果是主程序抛出的异常，**那么这整个程序也就退出了**。\n\nError实际上也是一种非检测型异常。\n\n## 异常处理\n\n### 关键字\n\n了解了异常的分类，我们就可以愉快的处理异常了。记得上大学的时候写的代码，由于不理解java的异常机制，每当遇到检测型异常时，ide会要求在代码中处理这种情况。于是简单的try..catch解决，并在catch块中 e.printStackTrace()，就解决了IDE的报警问题。现在想来，这种代码如果运行在生产环境中，将会多么可怕。\n\n通过上面的总结，我们已经了解了四个关键字：try catch throw throws.\n\nthrow表示将要抛出一个异常，后面跟一个Throwable的实例，throws置于函数的声明当中，表示该函数将会抛出何种类型的异常。\n\ntry catch 一般配合使用，还有一个关键字finally,也是与try catch 配合使用的。有这三种使用方式：\n\ntry..catch  try..finally try..catch..finally\n\ncatch 可以有多个，try只能有一个，finally可选。\n\nfinally用于保证一些资源的释放，因为一般情况下，finally中的语句总会在方法返回之前得到执行。\n\n### try catch finally执行顺序\n\ntry catch finally的执行顺序为 try->catch->finally。\n\n有多个catch时，按照catch块的先后顺序进行匹配，一旦一个异常与一个catch块匹配，则不会再与后面的catch块进行匹配。\n因此，如果我们使用多个catch块捕获异常时，如果多个catch块捕获的异常具有继承关系，注意把继承链中低层次(也就是子类)的放在前面，把继承链中高层次的(也就是父类)放在后面。\n这样做的目的很简单，就是尽量使异常被适合的catch所捕获，这样处理起来比较明确。\n\nfinally块中的代码一般是在try与catch内的控制转移语句执行之前执行的，用来做一些资源释放的操作。控制转移语句包括：return、throw、break 和 continue。\n\n关于finally块的详细解析，参考[关于 Java 中 finally 语句块的深度辨析](https://www.ibm.com/developerworks/cn/java/j-lo-finally/)\n\n另外有一点需要注意：不要在finally中return，因为finally中的return会覆盖已有的返回值，比如try或者catch中的返回值。比如：\n\n```\npublic class TestException {\n    public static void main(String[] args) {\n        String str = new TestException().readFile();\n        System.out.println(str);\n    }\n \n    public String readFile() {\n        try {\n            FileInputStream inputStream = new FileInputStream(\"D:/test.txt\");\n            int ch = inputStream.read();\n            return \"try\";\n        } catch (FileNotFoundException e) {\n            System.out.println(\"file not found\");\n            return \"FileNotFoundException\";\n        }catch (IOException e) {\n            System.out.println(\"io exception\");\n            return \"IOException\";\n        }finally{\n            System.out.println(\"finally block\");\n            //return \"finally\";\n        }\n    }\n}\n```\nD:/test.txt 并不存在，执行结果为:file not found    finally block   FileNotFoundException\n去掉finally中的注释，执行结果为：file not found    finally block   finally\n\n\n## 一些建议\n\n了解了异常机制的基本原理，不一定能够很好的处理异常。当我们遇到异常需要处理的时候，需要遵循几个原则，才能写出更好的代码：\n\n### 不要使用空的catch块\n\n正如前面所说，上学的时候遇到异常时，直接try..catch了事，只是简单地e.printStackTrace(),把堆栈打印出来了。这样可能对定位异常比较有帮助，但是对异常的处理却没有帮助，既没有处理异常，上层代码也无法得知异常的抛出，\n程序会继续运行，有可能出现无法预料的结果。当然，如果程序的逻辑容忍异常可以不用处理，那么可以不处理异常，简单的输出到日志记录即可。处理还需视实际情况而定。\n\n### 在能够处理异常的地方处理异常\n\n换句话说，就是在高层代码中处理异常。尽量将异常抛给上层调用者，由上层调用者统一进行处理。这样会使得程序流程比较清晰。\n\n### 日志打印\n\n只在必要的地方打印日志，如只在异常发生的地方输出日志，然后将异常抛到上层。这样比较容易定位异常，避免每次向上抛出异常时都打印日志，反复打印同一个异常会使得日志变得混乱\n\n### 检测异常与非检测异常的选择\n\n为可恢复的条件使用检查型异常，为编程错误使用运行时异常\n\n在web项目中，我们经常把代码层次分为controller，service,dao等几层。在dao层中一搬会抛出SQLException,这就使得他的调用者必须显示的捕获该异常或者继续抛出。这样提高了代码的耦合性，污染了上层代码。\n在比如接口的声明当中，我们为方法声明了一个检测型异常，那么他的所有实现类都必须作出同样的声明，即使实现类不会抛出异常。而且，所有的调用者都必须显示的捕获异常或者抛出异常，异常就会扩散开来，会使代码变得混乱。\n所以我们应该正确的选择检测型异常和非检测型异常。个人认为，检测型异常的意义就在于提醒用户进行处理，比如一些资源的释放等等。如果该异常出现的很普遍，需要提醒调用者进行处理，那么就是用检测型异常，否则，就使用非检测型异常。\n\n对于已经抛出的检测型异常，我们可以进行封装处理，比如对于第一种情况，污染上层代码的问题：\n\n```\n//处理前\npublic Data getDataById(Long id) throw SQLException {\n //根据 ID 查询数据库\n}\n\n//处理后\npublic Data getDataById(Long id) {\n     try{\n            //根据 ID 查询数据库\n     }catch(SQLException e){\n            //利用非检测异常封装检测异常，降低层次耦合\n            throw new RuntimeException(SQLErrorCode, e);\n     }finally{\n            //关闭连接，清理资源\n     }\n}\n\n```\n我们将一个检测型异常封装成了非检测型异常向上抛出。\n\n### 不要使用Exception捕捉所有潜在的异常\n\n针对具体的异常进行处理，而不是使用Exception捕获所有的异常。这样不利于异常情况的处理，并且如果再次向上抛出时可能会丢书原有的异常信息。 \n\n### 抛出与抽象相适应的异常\n\n换句话说，一个方法所抛出的异常应该在一个抽象层次上定义，该抽象层次与该方法做什么相一致，而不一定与方法的底层实现细节相一致。例如，一个从文件、数据库或者 JNDI 装载资源的方法在不能找到资源时，应该抛出某种 ResourceNotFound 异常（通常使用异常链来保存隐含的原因），而不是更底层的 IOException 、 SQLException 或者 NamingException 。\n\n我们有时候在捕获一个异常后抛出另一个封装后的异常信息，并且希望将原始的异常信息也保持起来，\nthrow抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？\n在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。\n\n### 多线程中的异常\n\n在java多线程程序中，所有线程都不允许抛出未捕获的检测型异常（比如sleep时的InterruptedException),\n也就是说各个线程需要自己把自己的检测型处理掉。\n这一点是通过java.lang.Runnable.run()方法声明(因为此方法声明上没有throw exception部分)进行了约束。\n但是线程依然有可能抛出非检测型异常，当此类异常跑抛出时，线程就会终结，\n而对于主线程和其他线程完全不受影响，且完全感知不到某个线程抛出的异常(也是说完全无法catch到这个异常)。\n\n如果我们不考虑线程内可能出现的异常而导致线程的终结，那么就有可能造成意想不到的后果。如果是使用线程池的话，就有可能导致线程泄漏，这样的错误可能难以察觉，\n最终导致程序挂掉或者内存溢出等等意想不到的问题，但是往往不好追踪问题出现的原因。\n[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章很好的展示了一个多线程发生异常后产生的一系列后果。\n\n对于线程可以自己处理的异常，比较好解决。我们可以在线程内部捕获异常，作一些处理，防止线程退出。比如，[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章中的一个示例：\n\n```\nprivate class SaferPoolWorker extends Thread {\n    public void run() {\n        IncomingResponse ir;\n        while (true) {\n            ir = (IncomingResponse) queue.getNext();\n            PlugIn plugIn = findPlugIn(ir.getResponseId());\n            if (plugIn != null) {\n        try {\n                    plugIn.handleMessage(ir.getResponse());\n                }\n                catch (RuntimeException e) {\n                    // Take some sort of action; \n                    // - log the exception and move on\n                    // - log the exception and restart the worker thread\n                    // - log the exception and unload the offending plug-in\n                }\n            }\n            else\n                log(\"Unknown plug-in for response \" + ir.getResponseId());\n        }\n    }\n}\n```\n但是，当子线程发生异常时，我们需要父线程或者主线程可以感知子线程的异常，也就是得到子线程产生的异常，然后做一些处理。[Java线程池异常处理最佳实践](http://blog.onlycatch.com/post/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)这篇文章给出了很好的总结，\n摘抄其总结如下：\n```\n处理线程池中的异常有两种思路： \n1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池 \n2）由线程池统一处理\n对于execute方法提交的线程，有两种处理方式 \n1）自定义线程池并实现afterExecute方法 \n2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。\n对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。\n```\n\n## 其他\n\n还发现了一个比较有趣的异常处理情况，虽然可能很少碰到，但是碰到了可以参考作者的思路。\n\n[技巧：当不能抛出异常时](https://www.ibm.com/developerworks/cn/java/j-ce/)这篇文章介绍了一种不是很常见的情况：即不能处理，也不能抛出异常(包括非检测型异常)时怎么办？\n\n## 参考\n\n[Java 异常处理的误区和经验总结](http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/)\n\n[Java异常处理和设计](http://www.importnew.com/18994.html)\n\n[Java 理论与实践: 关于异常的争论](https://www.ibm.com/developerworks/cn/java/j-jtp05254/)\n\n","slug":"java异常的学习","published":1,"updated":"2017-04-11T13:08:38.842Z","comments":1,"photos":[],"link":"","_id":"cj4vch4ew0024x3gconby8327","content":"<blockquote>\n<p>最近的写代码的过程中，遇到很多异常的处理，以前上大学的时候写代码，遇到异常直接给个try catch了事，只是停留在看懂异常能够找出异常抛出点的水平。真正写代码的时候，不了解java的异常机制给自己编程带来很多不便，基础知识很重要！学习之～～</p>\n</blockquote>\n<h2 id=\"异常分类\"><a href=\"#异常分类\" class=\"headerlink\" title=\"异常分类\"></a>异常分类</h2><img src=\"/2016/12/13/java异常的学习/java.png\" alt=\"java异常体系\" title=\"java异常体系\">\n<p>java异常中的异常大体上可分为两类：Error 与 Exception，他们都继承自Throwable</p>\n<a id=\"more\"></a>\n<h3 id=\"Error：\"><a href=\"#Error：\" class=\"headerlink\" title=\"Error：\"></a>Error：</h3><p>Error表示一些无法恢复的错误，会导致应用程序中断。比如我们喜闻乐见的OutOfMemoryError(内存溢出)， StackOverflowError(堆栈溢出)等，就是一种Error类型的异常。面对这种类型的异常在我们的应用程序中一般是无法挽救的，将直接导致程序错误退出。因此我们在代码中一般不必去特别关心这种类型的异常。</p>\n<p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html\" target=\"_blank\" rel=\"external\">Error类型的异常及其子类</a></p>\n<h3 id=\"Exception\"><a href=\"#Exception\" class=\"headerlink\" title=\"Exception:\"></a>Exception:</h3><p>Exception是一般常见的异常，我们的应用程序可以处理这些异常，比如NullPointerException、IndexOutOfBoundsException等等。发生这些异常时，可以选择通过捕获这些异常进行处理，使程序可以继续往下执行。</p>\n<p>Exception又可以分为CheckException(检测型异常)与UncheckException(非检测型异常)。</p>\n<p>在Exception的子类当中，非检测型异常为RuntimeException及其子类，剩下的异常则为检测型异常。</p>\n<h4 id=\"检测型异常\"><a href=\"#检测型异常\" class=\"headerlink\" title=\"检测型异常\"></a>检测型异常</h4><p>所谓检测型异常，表示其接受编译器的检测，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void readFile(String filePath)&#123;</div><div class=\"line\">        //编译无法通过</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\tFileReader fileReader = new FileReader(file);//FileNotFoundException</div><div class=\"line\">\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\tString line = null;</div><div class=\"line\">\t\twhile ((line = bReader.readLine()) != null) &#123;//IOException</div><div class=\"line\">\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>编译上述代码，编译器会报错，编译无法通过。<br>如果是用Eclipse等ide去写这段代码，ide通常就会告诉你这段代码有错误。原因是上述代码会抛出检测型异常IOException。有以下两种修复错误的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//第一种</div><div class=\"line\">public void readFile(String filePath) throws IOException&#123;</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\tFileReader fileReader = new FileReader(file);</div><div class=\"line\">\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\tString line = null;</div><div class=\"line\">\t\twhile ((line = bReader.readLine()) != null) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//第二种</div><div class=\"line\">public void readFile(String filePath) &#123;</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tFileReader fileReader = new FileReader(file);</div><div class=\"line\">\t\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\t\tString line = null;</div><div class=\"line\">\t\t\twhile ((line = bReader.readLine()) != null) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; catch (IOException e) &#123;</div><div class=\"line\">\t\t\t// TODO: handle exception</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一种方式通过声明throws关键字将该异常继续向上抛出，这种方式下，该方法就抛出了检测型异常，他的调用者就会遇到一样的问题，调用者可以选择使用这种方式继续向调用链上层抛出，或者采用第二种方式处理异常。</p>\n<p>第二种方式通过将抛出异常的代码使用try..catch块包裹起来，处理该异常。这种方式下他的调用者无需再次处理该异常。</p>\n<p>上面这种类型的异常就是检测型异常，我们必须显示的去处理他，代表的有SQLException、IOException等等。</p>\n<h4 id=\"非检测型异常\"><a href=\"#非检测型异常\" class=\"headerlink\" title=\"非检测型异常\"></a>非检测型异常</h4><p>与检测型异常相对的，编译阶段不会检测这种类型的异常，当代码中有这种类型的异常抛出时，我们不需要像上面那样显示的处理他，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void test() &#123;</div><div class=\"line\">        //编译可以通过</div><div class=\"line\">\t\tthrow new NullPointerException();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过throw关键字抛出了一个NullPointerException异常，该异常是RunTimeException的子类，是一个非检测类型的异常。这种类型的异常一般是由程序逻辑错误引起的，比如空指针或者数组越界等等。</p>\n<p>对于非检测类型的异常，我们也可以去使用try..catch捕获他，从而进行一些处理。如果我们没有捕获处理这个异常，系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，<strong>这个线程也就退出了</strong>。如果是主程序抛出的异常，<strong>那么这整个程序也就退出了</strong>。</p>\n<p>Error实际上也是一种非检测型异常。</p>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><p>了解了异常的分类，我们就可以愉快的处理异常了。记得上大学的时候写的代码，由于不理解java的异常机制，每当遇到检测型异常时，ide会要求在代码中处理这种情况。于是简单的try..catch解决，并在catch块中 e.printStackTrace()，就解决了IDE的报警问题。现在想来，这种代码如果运行在生产环境中，将会多么可怕。</p>\n<p>通过上面的总结，我们已经了解了四个关键字：try catch throw throws.</p>\n<p>throw表示将要抛出一个异常，后面跟一个Throwable的实例，throws置于函数的声明当中，表示该函数将会抛出何种类型的异常。</p>\n<p>try catch 一般配合使用，还有一个关键字finally,也是与try catch 配合使用的。有这三种使用方式：</p>\n<p>try..catch  try..finally try..catch..finally</p>\n<p>catch 可以有多个，try只能有一个，finally可选。</p>\n<p>finally用于保证一些资源的释放，因为一般情况下，finally中的语句总会在方法返回之前得到执行。</p>\n<h3 id=\"try-catch-finally执行顺序\"><a href=\"#try-catch-finally执行顺序\" class=\"headerlink\" title=\"try catch finally执行顺序\"></a>try catch finally执行顺序</h3><p>try catch finally的执行顺序为 try-&gt;catch-&gt;finally。</p>\n<p>有多个catch时，按照catch块的先后顺序进行匹配，一旦一个异常与一个catch块匹配，则不会再与后面的catch块进行匹配。<br>因此，如果我们使用多个catch块捕获异常时，如果多个catch块捕获的异常具有继承关系，注意把继承链中低层次(也就是子类)的放在前面，把继承链中高层次的(也就是父类)放在后面。<br>这样做的目的很简单，就是尽量使异常被适合的catch所捕获，这样处理起来比较明确。</p>\n<p>finally块中的代码一般是在try与catch内的控制转移语句执行之前执行的，用来做一些资源释放的操作。控制转移语句包括：return、throw、break 和 continue。</p>\n<p>关于finally块的详细解析，参考<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-finally/\" target=\"_blank\" rel=\"external\">关于 Java 中 finally 语句块的深度辨析</a></p>\n<p>另外有一点需要注意：不要在finally中return，因为finally中的return会覆盖已有的返回值，比如try或者catch中的返回值。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TestException &#123;</div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        String str = new TestException().readFile();</div><div class=\"line\">        System.out.println(str);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    public String readFile() &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            FileInputStream inputStream = new FileInputStream(&quot;D:/test.txt&quot;);</div><div class=\"line\">            int ch = inputStream.read();</div><div class=\"line\">            return &quot;try&quot;;</div><div class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</div><div class=\"line\">            System.out.println(&quot;file not found&quot;);</div><div class=\"line\">            return &quot;FileNotFoundException&quot;;</div><div class=\"line\">        &#125;catch (IOException e) &#123;</div><div class=\"line\">            System.out.println(&quot;io exception&quot;);</div><div class=\"line\">            return &quot;IOException&quot;;</div><div class=\"line\">        &#125;finally&#123;</div><div class=\"line\">            System.out.println(&quot;finally block&quot;);</div><div class=\"line\">            //return &quot;finally&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>D:/test.txt 并不存在，执行结果为:file not found    finally block   FileNotFoundException<br>去掉finally中的注释，执行结果为：file not found    finally block   finally</p>\n<h2 id=\"一些建议\"><a href=\"#一些建议\" class=\"headerlink\" title=\"一些建议\"></a>一些建议</h2><p>了解了异常机制的基本原理，不一定能够很好的处理异常。当我们遇到异常需要处理的时候，需要遵循几个原则，才能写出更好的代码：</p>\n<h3 id=\"不要使用空的catch块\"><a href=\"#不要使用空的catch块\" class=\"headerlink\" title=\"不要使用空的catch块\"></a>不要使用空的catch块</h3><p>正如前面所说，上学的时候遇到异常时，直接try..catch了事，只是简单地e.printStackTrace(),把堆栈打印出来了。这样可能对定位异常比较有帮助，但是对异常的处理却没有帮助，既没有处理异常，上层代码也无法得知异常的抛出，<br>程序会继续运行，有可能出现无法预料的结果。当然，如果程序的逻辑容忍异常可以不用处理，那么可以不处理异常，简单的输出到日志记录即可。处理还需视实际情况而定。</p>\n<h3 id=\"在能够处理异常的地方处理异常\"><a href=\"#在能够处理异常的地方处理异常\" class=\"headerlink\" title=\"在能够处理异常的地方处理异常\"></a>在能够处理异常的地方处理异常</h3><p>换句话说，就是在高层代码中处理异常。尽量将异常抛给上层调用者，由上层调用者统一进行处理。这样会使得程序流程比较清晰。</p>\n<h3 id=\"日志打印\"><a href=\"#日志打印\" class=\"headerlink\" title=\"日志打印\"></a>日志打印</h3><p>只在必要的地方打印日志，如只在异常发生的地方输出日志，然后将异常抛到上层。这样比较容易定位异常，避免每次向上抛出异常时都打印日志，反复打印同一个异常会使得日志变得混乱</p>\n<h3 id=\"检测异常与非检测异常的选择\"><a href=\"#检测异常与非检测异常的选择\" class=\"headerlink\" title=\"检测异常与非检测异常的选择\"></a>检测异常与非检测异常的选择</h3><p>为可恢复的条件使用检查型异常，为编程错误使用运行时异常</p>\n<p>在web项目中，我们经常把代码层次分为controller，service,dao等几层。在dao层中一搬会抛出SQLException,这就使得他的调用者必须显示的捕获该异常或者继续抛出。这样提高了代码的耦合性，污染了上层代码。<br>在比如接口的声明当中，我们为方法声明了一个检测型异常，那么他的所有实现类都必须作出同样的声明，即使实现类不会抛出异常。而且，所有的调用者都必须显示的捕获异常或者抛出异常，异常就会扩散开来，会使代码变得混乱。<br>所以我们应该正确的选择检测型异常和非检测型异常。个人认为，检测型异常的意义就在于提醒用户进行处理，比如一些资源的释放等等。如果该异常出现的很普遍，需要提醒调用者进行处理，那么就是用检测型异常，否则，就使用非检测型异常。</p>\n<p>对于已经抛出的检测型异常，我们可以进行封装处理，比如对于第一种情况，污染上层代码的问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//处理前</div><div class=\"line\">public Data getDataById(Long id) throw SQLException &#123;</div><div class=\"line\"> //根据 ID 查询数据库</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//处理后</div><div class=\"line\">public Data getDataById(Long id) &#123;</div><div class=\"line\">     try&#123;</div><div class=\"line\">            //根据 ID 查询数据库</div><div class=\"line\">     &#125;catch(SQLException e)&#123;</div><div class=\"line\">            //利用非检测异常封装检测异常，降低层次耦合</div><div class=\"line\">            throw new RuntimeException(SQLErrorCode, e);</div><div class=\"line\">     &#125;finally&#123;</div><div class=\"line\">            //关闭连接，清理资源</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们将一个检测型异常封装成了非检测型异常向上抛出。</p>\n<h3 id=\"不要使用Exception捕捉所有潜在的异常\"><a href=\"#不要使用Exception捕捉所有潜在的异常\" class=\"headerlink\" title=\"不要使用Exception捕捉所有潜在的异常\"></a>不要使用Exception捕捉所有潜在的异常</h3><p>针对具体的异常进行处理，而不是使用Exception捕获所有的异常。这样不利于异常情况的处理，并且如果再次向上抛出时可能会丢书原有的异常信息。 </p>\n<h3 id=\"抛出与抽象相适应的异常\"><a href=\"#抛出与抽象相适应的异常\" class=\"headerlink\" title=\"抛出与抽象相适应的异常\"></a>抛出与抽象相适应的异常</h3><p>换句话说，一个方法所抛出的异常应该在一个抽象层次上定义，该抽象层次与该方法做什么相一致，而不一定与方法的底层实现细节相一致。例如，一个从文件、数据库或者 JNDI 装载资源的方法在不能找到资源时，应该抛出某种 ResourceNotFound 异常（通常使用异常链来保存隐含的原因），而不是更底层的 IOException 、 SQLException 或者 NamingException 。</p>\n<p>我们有时候在捕获一个异常后抛出另一个封装后的异常信息，并且希望将原始的异常信息也保持起来，<br>throw抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？<br>在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。</p>\n<h3 id=\"多线程中的异常\"><a href=\"#多线程中的异常\" class=\"headerlink\" title=\"多线程中的异常\"></a>多线程中的异常</h3><p>在java多线程程序中，所有线程都不允许抛出未捕获的检测型异常（比如sleep时的InterruptedException),<br>也就是说各个线程需要自己把自己的检测型处理掉。<br>这一点是通过java.lang.Runnable.run()方法声明(因为此方法声明上没有throw exception部分)进行了约束。<br>但是线程依然有可能抛出非检测型异常，当此类异常跑抛出时，线程就会终结，<br>而对于主线程和其他线程完全不受影响，且完全感知不到某个线程抛出的异常(也是说完全无法catch到这个异常)。</p>\n<p>如果我们不考虑线程内可能出现的异常而导致线程的终结，那么就有可能造成意想不到的后果。如果是使用线程池的话，就有可能导致线程泄漏，这样的错误可能难以察觉，<br>最终导致程序挂掉或者内存溢出等等意想不到的问题，但是往往不好追踪问题出现的原因。<br><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\" target=\"_blank\" rel=\"external\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章很好的展示了一个多线程发生异常后产生的一系列后果。</p>\n<p>对于线程可以自己处理的异常，比较好解决。我们可以在线程内部捕获异常，作一些处理，防止线程退出。比如，<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\" target=\"_blank\" rel=\"external\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章中的一个示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">private class SaferPoolWorker extends Thread &#123;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        IncomingResponse ir;</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\">            ir = (IncomingResponse) queue.getNext();</div><div class=\"line\">            PlugIn plugIn = findPlugIn(ir.getResponseId());</div><div class=\"line\">            if (plugIn != null) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">                    plugIn.handleMessage(ir.getResponse());</div><div class=\"line\">                &#125;</div><div class=\"line\">                catch (RuntimeException e) &#123;</div><div class=\"line\">                    // Take some sort of action; </div><div class=\"line\">                    // - log the exception and move on</div><div class=\"line\">                    // - log the exception and restart the worker thread</div><div class=\"line\">                    // - log the exception and unload the offending plug-in</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            else</div><div class=\"line\">                log(&quot;Unknown plug-in for response &quot; + ir.getResponseId());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是，当子线程发生异常时，我们需要父线程或者主线程可以感知子线程的异常，也就是得到子线程产生的异常，然后做一些处理。<a href=\"http://blog.onlycatch.com/post/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\" target=\"_blank\" rel=\"external\">Java线程池异常处理最佳实践</a>这篇文章给出了很好的总结，<br>摘抄其总结如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">处理线程池中的异常有两种思路： </div><div class=\"line\">1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池 </div><div class=\"line\">2）由线程池统一处理</div><div class=\"line\">对于execute方法提交的线程，有两种处理方式 </div><div class=\"line\">1）自定义线程池并实现afterExecute方法 </div><div class=\"line\">2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。</div><div class=\"line\">对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。</div></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>还发现了一个比较有趣的异常处理情况，虽然可能很少碰到，但是碰到了可以参考作者的思路。</p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-ce/\" target=\"_blank\" rel=\"external\">技巧：当不能抛出异常时</a>这篇文章介绍了一种不是很常见的情况：即不能处理，也不能抛出异常(包括非检测型异常)时怎么办？</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/\" target=\"_blank\" rel=\"external\">Java 异常处理的误区和经验总结</a></p>\n<p><a href=\"http://www.importnew.com/18994.html\" target=\"_blank\" rel=\"external\">Java异常处理和设计</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp05254/\" target=\"_blank\" rel=\"external\">Java 理论与实践: 关于异常的争论</a></p>\n","excerpt":"<blockquote>\n<p>最近的写代码的过程中，遇到很多异常的处理，以前上大学的时候写代码，遇到异常直接给个try catch了事，只是停留在看懂异常能够找出异常抛出点的水平。真正写代码的时候，不了解java的异常机制给自己编程带来很多不便，基础知识很重要！学习之～～</p>\n</blockquote>\n<h2 id=\"异常分类\"><a href=\"#异常分类\" class=\"headerlink\" title=\"异常分类\"></a>异常分类</h2><img src=\"/2016/12/13/java异常的学习/java.png\" alt=\"java异常体系\" title=\"java异常体系\">\n<p>java异常中的异常大体上可分为两类：Error 与 Exception，他们都继承自Throwable</p>","more":"<h3 id=\"Error：\"><a href=\"#Error：\" class=\"headerlink\" title=\"Error：\"></a>Error：</h3><p>Error表示一些无法恢复的错误，会导致应用程序中断。比如我们喜闻乐见的OutOfMemoryError(内存溢出)， StackOverflowError(堆栈溢出)等，就是一种Error类型的异常。面对这种类型的异常在我们的应用程序中一般是无法挽救的，将直接导致程序错误退出。因此我们在代码中一般不必去特别关心这种类型的异常。</p>\n<p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html\">Error类型的异常及其子类</a></p>\n<h3 id=\"Exception\"><a href=\"#Exception\" class=\"headerlink\" title=\"Exception:\"></a>Exception:</h3><p>Exception是一般常见的异常，我们的应用程序可以处理这些异常，比如NullPointerException、IndexOutOfBoundsException等等。发生这些异常时，可以选择通过捕获这些异常进行处理，使程序可以继续往下执行。</p>\n<p>Exception又可以分为CheckException(检测型异常)与UncheckException(非检测型异常)。</p>\n<p>在Exception的子类当中，非检测型异常为RuntimeException及其子类，剩下的异常则为检测型异常。</p>\n<h4 id=\"检测型异常\"><a href=\"#检测型异常\" class=\"headerlink\" title=\"检测型异常\"></a>检测型异常</h4><p>所谓检测型异常，表示其接受编译器的检测，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void readFile(String filePath)&#123;</div><div class=\"line\">        //编译无法通过</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\tFileReader fileReader = new FileReader(file);//FileNotFoundException</div><div class=\"line\">\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\tString line = null;</div><div class=\"line\">\t\twhile ((line = bReader.readLine()) != null) &#123;//IOException</div><div class=\"line\">\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>编译上述代码，编译器会报错，编译无法通过。<br>如果是用Eclipse等ide去写这段代码，ide通常就会告诉你这段代码有错误。原因是上述代码会抛出检测型异常IOException。有以下两种修复错误的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//第一种</div><div class=\"line\">public void readFile(String filePath) throws IOException&#123;</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\tFileReader fileReader = new FileReader(file);</div><div class=\"line\">\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\tString line = null;</div><div class=\"line\">\t\twhile ((line = bReader.readLine()) != null) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//第二种</div><div class=\"line\">public void readFile(String filePath) &#123;</div><div class=\"line\">\t\tFile file = new File(filePath);</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tFileReader fileReader = new FileReader(file);</div><div class=\"line\">\t\t\tBufferedReader bReader = new BufferedReader(fileReader);</div><div class=\"line\">\t\t\tString line = null;</div><div class=\"line\">\t\t\twhile ((line = bReader.readLine()) != null) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(line);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; catch (IOException e) &#123;</div><div class=\"line\">\t\t\t// TODO: handle exception</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一种方式通过声明throws关键字将该异常继续向上抛出，这种方式下，该方法就抛出了检测型异常，他的调用者就会遇到一样的问题，调用者可以选择使用这种方式继续向调用链上层抛出，或者采用第二种方式处理异常。</p>\n<p>第二种方式通过将抛出异常的代码使用try..catch块包裹起来，处理该异常。这种方式下他的调用者无需再次处理该异常。</p>\n<p>上面这种类型的异常就是检测型异常，我们必须显示的去处理他，代表的有SQLException、IOException等等。</p>\n<h4 id=\"非检测型异常\"><a href=\"#非检测型异常\" class=\"headerlink\" title=\"非检测型异常\"></a>非检测型异常</h4><p>与检测型异常相对的，编译阶段不会检测这种类型的异常，当代码中有这种类型的异常抛出时，我们不需要像上面那样显示的处理他，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void test() &#123;</div><div class=\"line\">        //编译可以通过</div><div class=\"line\">\t\tthrow new NullPointerException();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过throw关键字抛出了一个NullPointerException异常，该异常是RunTimeException的子类，是一个非检测类型的异常。这种类型的异常一般是由程序逻辑错误引起的，比如空指针或者数组越界等等。</p>\n<p>对于非检测类型的异常，我们也可以去使用try..catch捕获他，从而进行一些处理。如果我们没有捕获处理这个异常，系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，<strong>这个线程也就退出了</strong>。如果是主程序抛出的异常，<strong>那么这整个程序也就退出了</strong>。</p>\n<p>Error实际上也是一种非检测型异常。</p>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><p>了解了异常的分类，我们就可以愉快的处理异常了。记得上大学的时候写的代码，由于不理解java的异常机制，每当遇到检测型异常时，ide会要求在代码中处理这种情况。于是简单的try..catch解决，并在catch块中 e.printStackTrace()，就解决了IDE的报警问题。现在想来，这种代码如果运行在生产环境中，将会多么可怕。</p>\n<p>通过上面的总结，我们已经了解了四个关键字：try catch throw throws.</p>\n<p>throw表示将要抛出一个异常，后面跟一个Throwable的实例，throws置于函数的声明当中，表示该函数将会抛出何种类型的异常。</p>\n<p>try catch 一般配合使用，还有一个关键字finally,也是与try catch 配合使用的。有这三种使用方式：</p>\n<p>try..catch  try..finally try..catch..finally</p>\n<p>catch 可以有多个，try只能有一个，finally可选。</p>\n<p>finally用于保证一些资源的释放，因为一般情况下，finally中的语句总会在方法返回之前得到执行。</p>\n<h3 id=\"try-catch-finally执行顺序\"><a href=\"#try-catch-finally执行顺序\" class=\"headerlink\" title=\"try catch finally执行顺序\"></a>try catch finally执行顺序</h3><p>try catch finally的执行顺序为 try-&gt;catch-&gt;finally。</p>\n<p>有多个catch时，按照catch块的先后顺序进行匹配，一旦一个异常与一个catch块匹配，则不会再与后面的catch块进行匹配。<br>因此，如果我们使用多个catch块捕获异常时，如果多个catch块捕获的异常具有继承关系，注意把继承链中低层次(也就是子类)的放在前面，把继承链中高层次的(也就是父类)放在后面。<br>这样做的目的很简单，就是尽量使异常被适合的catch所捕获，这样处理起来比较明确。</p>\n<p>finally块中的代码一般是在try与catch内的控制转移语句执行之前执行的，用来做一些资源释放的操作。控制转移语句包括：return、throw、break 和 continue。</p>\n<p>关于finally块的详细解析，参考<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-finally/\">关于 Java 中 finally 语句块的深度辨析</a></p>\n<p>另外有一点需要注意：不要在finally中return，因为finally中的return会覆盖已有的返回值，比如try或者catch中的返回值。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TestException &#123;</div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        String str = new TestException().readFile();</div><div class=\"line\">        System.out.println(str);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    public String readFile() &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            FileInputStream inputStream = new FileInputStream(&quot;D:/test.txt&quot;);</div><div class=\"line\">            int ch = inputStream.read();</div><div class=\"line\">            return &quot;try&quot;;</div><div class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</div><div class=\"line\">            System.out.println(&quot;file not found&quot;);</div><div class=\"line\">            return &quot;FileNotFoundException&quot;;</div><div class=\"line\">        &#125;catch (IOException e) &#123;</div><div class=\"line\">            System.out.println(&quot;io exception&quot;);</div><div class=\"line\">            return &quot;IOException&quot;;</div><div class=\"line\">        &#125;finally&#123;</div><div class=\"line\">            System.out.println(&quot;finally block&quot;);</div><div class=\"line\">            //return &quot;finally&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>D:/test.txt 并不存在，执行结果为:file not found    finally block   FileNotFoundException<br>去掉finally中的注释，执行结果为：file not found    finally block   finally</p>\n<h2 id=\"一些建议\"><a href=\"#一些建议\" class=\"headerlink\" title=\"一些建议\"></a>一些建议</h2><p>了解了异常机制的基本原理，不一定能够很好的处理异常。当我们遇到异常需要处理的时候，需要遵循几个原则，才能写出更好的代码：</p>\n<h3 id=\"不要使用空的catch块\"><a href=\"#不要使用空的catch块\" class=\"headerlink\" title=\"不要使用空的catch块\"></a>不要使用空的catch块</h3><p>正如前面所说，上学的时候遇到异常时，直接try..catch了事，只是简单地e.printStackTrace(),把堆栈打印出来了。这样可能对定位异常比较有帮助，但是对异常的处理却没有帮助，既没有处理异常，上层代码也无法得知异常的抛出，<br>程序会继续运行，有可能出现无法预料的结果。当然，如果程序的逻辑容忍异常可以不用处理，那么可以不处理异常，简单的输出到日志记录即可。处理还需视实际情况而定。</p>\n<h3 id=\"在能够处理异常的地方处理异常\"><a href=\"#在能够处理异常的地方处理异常\" class=\"headerlink\" title=\"在能够处理异常的地方处理异常\"></a>在能够处理异常的地方处理异常</h3><p>换句话说，就是在高层代码中处理异常。尽量将异常抛给上层调用者，由上层调用者统一进行处理。这样会使得程序流程比较清晰。</p>\n<h3 id=\"日志打印\"><a href=\"#日志打印\" class=\"headerlink\" title=\"日志打印\"></a>日志打印</h3><p>只在必要的地方打印日志，如只在异常发生的地方输出日志，然后将异常抛到上层。这样比较容易定位异常，避免每次向上抛出异常时都打印日志，反复打印同一个异常会使得日志变得混乱</p>\n<h3 id=\"检测异常与非检测异常的选择\"><a href=\"#检测异常与非检测异常的选择\" class=\"headerlink\" title=\"检测异常与非检测异常的选择\"></a>检测异常与非检测异常的选择</h3><p>为可恢复的条件使用检查型异常，为编程错误使用运行时异常</p>\n<p>在web项目中，我们经常把代码层次分为controller，service,dao等几层。在dao层中一搬会抛出SQLException,这就使得他的调用者必须显示的捕获该异常或者继续抛出。这样提高了代码的耦合性，污染了上层代码。<br>在比如接口的声明当中，我们为方法声明了一个检测型异常，那么他的所有实现类都必须作出同样的声明，即使实现类不会抛出异常。而且，所有的调用者都必须显示的捕获异常或者抛出异常，异常就会扩散开来，会使代码变得混乱。<br>所以我们应该正确的选择检测型异常和非检测型异常。个人认为，检测型异常的意义就在于提醒用户进行处理，比如一些资源的释放等等。如果该异常出现的很普遍，需要提醒调用者进行处理，那么就是用检测型异常，否则，就使用非检测型异常。</p>\n<p>对于已经抛出的检测型异常，我们可以进行封装处理，比如对于第一种情况，污染上层代码的问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//处理前</div><div class=\"line\">public Data getDataById(Long id) throw SQLException &#123;</div><div class=\"line\"> //根据 ID 查询数据库</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//处理后</div><div class=\"line\">public Data getDataById(Long id) &#123;</div><div class=\"line\">     try&#123;</div><div class=\"line\">            //根据 ID 查询数据库</div><div class=\"line\">     &#125;catch(SQLException e)&#123;</div><div class=\"line\">            //利用非检测异常封装检测异常，降低层次耦合</div><div class=\"line\">            throw new RuntimeException(SQLErrorCode, e);</div><div class=\"line\">     &#125;finally&#123;</div><div class=\"line\">            //关闭连接，清理资源</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们将一个检测型异常封装成了非检测型异常向上抛出。</p>\n<h3 id=\"不要使用Exception捕捉所有潜在的异常\"><a href=\"#不要使用Exception捕捉所有潜在的异常\" class=\"headerlink\" title=\"不要使用Exception捕捉所有潜在的异常\"></a>不要使用Exception捕捉所有潜在的异常</h3><p>针对具体的异常进行处理，而不是使用Exception捕获所有的异常。这样不利于异常情况的处理，并且如果再次向上抛出时可能会丢书原有的异常信息。 </p>\n<h3 id=\"抛出与抽象相适应的异常\"><a href=\"#抛出与抽象相适应的异常\" class=\"headerlink\" title=\"抛出与抽象相适应的异常\"></a>抛出与抽象相适应的异常</h3><p>换句话说，一个方法所抛出的异常应该在一个抽象层次上定义，该抽象层次与该方法做什么相一致，而不一定与方法的底层实现细节相一致。例如，一个从文件、数据库或者 JNDI 装载资源的方法在不能找到资源时，应该抛出某种 ResourceNotFound 异常（通常使用异常链来保存隐含的原因），而不是更底层的 IOException 、 SQLException 或者 NamingException 。</p>\n<p>我们有时候在捕获一个异常后抛出另一个封装后的异常信息，并且希望将原始的异常信息也保持起来，<br>throw抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？<br>在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。</p>\n<h3 id=\"多线程中的异常\"><a href=\"#多线程中的异常\" class=\"headerlink\" title=\"多线程中的异常\"></a>多线程中的异常</h3><p>在java多线程程序中，所有线程都不允许抛出未捕获的检测型异常（比如sleep时的InterruptedException),<br>也就是说各个线程需要自己把自己的检测型处理掉。<br>这一点是通过java.lang.Runnable.run()方法声明(因为此方法声明上没有throw exception部分)进行了约束。<br>但是线程依然有可能抛出非检测型异常，当此类异常跑抛出时，线程就会终结，<br>而对于主线程和其他线程完全不受影响，且完全感知不到某个线程抛出的异常(也是说完全无法catch到这个异常)。</p>\n<p>如果我们不考虑线程内可能出现的异常而导致线程的终结，那么就有可能造成意想不到的后果。如果是使用线程池的话，就有可能导致线程泄漏，这样的错误可能难以察觉，<br>最终导致程序挂掉或者内存溢出等等意想不到的问题，但是往往不好追踪问题出现的原因。<br><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章很好的展示了一个多线程发生异常后产生的一系列后果。</p>\n<p>对于线程可以自己处理的异常，比较好解决。我们可以在线程内部捕获异常，作一些处理，防止线程退出。比如，<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章中的一个示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">private class SaferPoolWorker extends Thread &#123;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        IncomingResponse ir;</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\">            ir = (IncomingResponse) queue.getNext();</div><div class=\"line\">            PlugIn plugIn = findPlugIn(ir.getResponseId());</div><div class=\"line\">            if (plugIn != null) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">                    plugIn.handleMessage(ir.getResponse());</div><div class=\"line\">                &#125;</div><div class=\"line\">                catch (RuntimeException e) &#123;</div><div class=\"line\">                    // Take some sort of action; </div><div class=\"line\">                    // - log the exception and move on</div><div class=\"line\">                    // - log the exception and restart the worker thread</div><div class=\"line\">                    // - log the exception and unload the offending plug-in</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            else</div><div class=\"line\">                log(&quot;Unknown plug-in for response &quot; + ir.getResponseId());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是，当子线程发生异常时，我们需要父线程或者主线程可以感知子线程的异常，也就是得到子线程产生的异常，然后做一些处理。<a href=\"http://blog.onlycatch.com/post/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">Java线程池异常处理最佳实践</a>这篇文章给出了很好的总结，<br>摘抄其总结如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">处理线程池中的异常有两种思路： </div><div class=\"line\">1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池 </div><div class=\"line\">2）由线程池统一处理</div><div class=\"line\">对于execute方法提交的线程，有两种处理方式 </div><div class=\"line\">1）自定义线程池并实现afterExecute方法 </div><div class=\"line\">2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。</div><div class=\"line\">对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。</div></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>还发现了一个比较有趣的异常处理情况，虽然可能很少碰到，但是碰到了可以参考作者的思路。</p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-ce/\">技巧：当不能抛出异常时</a>这篇文章介绍了一种不是很常见的情况：即不能处理，也不能抛出异常(包括非检测型异常)时怎么办？</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/\">Java 异常处理的误区和经验总结</a></p>\n<p><a href=\"http://www.importnew.com/18994.html\">Java异常处理和设计</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp05254/\">Java 理论与实践: 关于异常的争论</a></p>"},{"layout":"post","title":"Eclipse乱码问题终极解决方案","date":"2016-09-20T13:57:08.000Z","_content":"\n今天在Eclipse中导入一个新项目的时候，出现了乱码问题。研究一番...\n\n显示乱码的根本原因在于：**文件本身的编码和编辑器打开和编辑文件使用的编码不一致**。当编辑器以不同于文件的编码去解码该文件的时候，就会导致读出来乱码。大部分情况下英文显示正常是因为大部分编码都兼容ASCII，中文则会显示乱码。\n\n## 编辑器显示乱码问题\n\n在Eclipse中，设置编辑器显示和编辑文件所采用编码的方法有四种：\n\n1.Windows->Preference->General->Workspace ：修改整个工作空间\n\n{% asset_img 1.png 全局修改 %}\n\n2.右键Project->Properties->Resource ：修改某个工程\n\n{% asset_img 2.png 工程修改 %}\n\n3.右键文件->Properties ：修改某个文件\n\n{% asset_img 3.png 文件修改 %}\n\n4.Windows->Preference->General->Content types->Default encoding :全局修改某种类型的文件\n\n{% asset_img 4.png 全局文件修改 %}\n\n其中，3的优先级最高。也就是说某个文件被编辑器以哪种编码读取最终是由3中的Text file encoding决定的。一般情况下，如果我们不在3中显示指定编码(选择Other那一项)，Eclipse都会默认使用Default那一项的编码。那么，这个Default的编码又是如何决定的呢？\n\n{% asset_img 5.png 文件修改 %}\n\n注意上图中圈起来的部分：这部分表示了Default采用哪种编码是如何决定的。\n\n<!-- more -->\n\n可能会出现三种情况：\n\n1.determined from content: xxx \n\n2.determined from content type: xxx\n\n3.inherit from container \n\n其中：\n\n1表示文件内容本身指定了编码，比如下图。\n\n{% asset_img 6.png 文件修改 %}\n\nEncoding Bit Order Mark，简写为BOM，表明文件本身指定了采用哪种编码方式。编辑器会优先采用这种编码。\n\n2表示采用了针对该文件类型的全局修改，也就是上面提到的第4种设置方式。\n\n3表示继承了上一级指定的编码，这个继承关系就是我们在上面提到的：修改某个文件->修改文件所属的工程->修改整个工作空间。->表示继承于。\n\n上面这3种情况的优先级：1>2>3 。也就是说如果文件本身表明了编码方式，Eclipse优先采用这种编码解码文件。若没有指定，Eclipse会查看该文件类型是否在上面的第4种方式设置中指定了编码，如有则采用该编码。如没有指定，则从下往上搜索继承关系链中指定的编码。（继承关系链：文件->工程->工作空间）\n\n通过上面的分析明白了Eclipse 编辑器选择显示文件所采用编码的原理，相信再次遇到编辑器中的乱码问题都可以找到合适的解决方案。上面的分析不仅仅适用于java文件，同样适用于xml等其他类型文件的乱码问题。\n\n另外一定要注意：**如果通过上面4中方式的某一种修改影响了某个文件的编码，则当你再次编辑完保存该文件时，则采用此时该文件在Eclipse中指定的编码方式保存到本地。**\n\n以上的对乱码问题的分析都是基于通过修改Eclipse编辑器显示文件内容采用的编码，使其与文件本身的编码一致的方式来解决的。还有另一种思路是反过来，修改文件编码与Eclipse显示文件内容所采用的编码一致来解决乱码问题。可以使用文件编码批量转换工具进行批量转换，比如UltraCodingSwitch等。\n\n## Console显示乱码问题\n\n右键要运行的类->Run As->Run Configuratios\n\n{% asset_img 6.png Console编码 %}\n\n可修改上图中Other中的编码来指定显示打印内容的编码。\n\n## 总结\n\n通过以上分析知道了如何在Eclipse中解决乱码的问题。其实文章一开始就说了，显示乱码的根本原因在于：**文件本身的编码和编辑器打开文件使用的编码不一致**。明白了这一点，就算在其他编辑器或编译器中或者任何能够显示文本内容的遇到乱码的情况都能够找到问题的根源，从而解决乱码问题。\n\n至于文件本身的编码，可以通过一定的手段去改变。如通过记事本等工具修改编码后另存为等方式。\n\nJava中输出一段内容到文件可以通过指定流的编码来指定输出字符的编码。\n\n以上","source":"_posts/Eclipse编码问题终极解决方案.md","raw":"---\nlayout: post\ntitle: Eclipse乱码问题终极解决方案\ndate: 2016-09-20 21:57:08\ncategories: 工具\ntags: \n- Eclipse\n---\n\n今天在Eclipse中导入一个新项目的时候，出现了乱码问题。研究一番...\n\n显示乱码的根本原因在于：**文件本身的编码和编辑器打开和编辑文件使用的编码不一致**。当编辑器以不同于文件的编码去解码该文件的时候，就会导致读出来乱码。大部分情况下英文显示正常是因为大部分编码都兼容ASCII，中文则会显示乱码。\n\n## 编辑器显示乱码问题\n\n在Eclipse中，设置编辑器显示和编辑文件所采用编码的方法有四种：\n\n1.Windows->Preference->General->Workspace ：修改整个工作空间\n\n{% asset_img 1.png 全局修改 %}\n\n2.右键Project->Properties->Resource ：修改某个工程\n\n{% asset_img 2.png 工程修改 %}\n\n3.右键文件->Properties ：修改某个文件\n\n{% asset_img 3.png 文件修改 %}\n\n4.Windows->Preference->General->Content types->Default encoding :全局修改某种类型的文件\n\n{% asset_img 4.png 全局文件修改 %}\n\n其中，3的优先级最高。也就是说某个文件被编辑器以哪种编码读取最终是由3中的Text file encoding决定的。一般情况下，如果我们不在3中显示指定编码(选择Other那一项)，Eclipse都会默认使用Default那一项的编码。那么，这个Default的编码又是如何决定的呢？\n\n{% asset_img 5.png 文件修改 %}\n\n注意上图中圈起来的部分：这部分表示了Default采用哪种编码是如何决定的。\n\n<!-- more -->\n\n可能会出现三种情况：\n\n1.determined from content: xxx \n\n2.determined from content type: xxx\n\n3.inherit from container \n\n其中：\n\n1表示文件内容本身指定了编码，比如下图。\n\n{% asset_img 6.png 文件修改 %}\n\nEncoding Bit Order Mark，简写为BOM，表明文件本身指定了采用哪种编码方式。编辑器会优先采用这种编码。\n\n2表示采用了针对该文件类型的全局修改，也就是上面提到的第4种设置方式。\n\n3表示继承了上一级指定的编码，这个继承关系就是我们在上面提到的：修改某个文件->修改文件所属的工程->修改整个工作空间。->表示继承于。\n\n上面这3种情况的优先级：1>2>3 。也就是说如果文件本身表明了编码方式，Eclipse优先采用这种编码解码文件。若没有指定，Eclipse会查看该文件类型是否在上面的第4种方式设置中指定了编码，如有则采用该编码。如没有指定，则从下往上搜索继承关系链中指定的编码。（继承关系链：文件->工程->工作空间）\n\n通过上面的分析明白了Eclipse 编辑器选择显示文件所采用编码的原理，相信再次遇到编辑器中的乱码问题都可以找到合适的解决方案。上面的分析不仅仅适用于java文件，同样适用于xml等其他类型文件的乱码问题。\n\n另外一定要注意：**如果通过上面4中方式的某一种修改影响了某个文件的编码，则当你再次编辑完保存该文件时，则采用此时该文件在Eclipse中指定的编码方式保存到本地。**\n\n以上的对乱码问题的分析都是基于通过修改Eclipse编辑器显示文件内容采用的编码，使其与文件本身的编码一致的方式来解决的。还有另一种思路是反过来，修改文件编码与Eclipse显示文件内容所采用的编码一致来解决乱码问题。可以使用文件编码批量转换工具进行批量转换，比如UltraCodingSwitch等。\n\n## Console显示乱码问题\n\n右键要运行的类->Run As->Run Configuratios\n\n{% asset_img 6.png Console编码 %}\n\n可修改上图中Other中的编码来指定显示打印内容的编码。\n\n## 总结\n\n通过以上分析知道了如何在Eclipse中解决乱码的问题。其实文章一开始就说了，显示乱码的根本原因在于：**文件本身的编码和编辑器打开文件使用的编码不一致**。明白了这一点，就算在其他编辑器或编译器中或者任何能够显示文本内容的遇到乱码的情况都能够找到问题的根源，从而解决乱码问题。\n\n至于文件本身的编码，可以通过一定的手段去改变。如通过记事本等工具修改编码后另存为等方式。\n\nJava中输出一段内容到文件可以通过指定流的编码来指定输出字符的编码。\n\n以上","slug":"Eclipse编码问题终极解决方案","published":1,"updated":"2017-04-11T13:08:38.816Z","comments":1,"photos":[],"link":"","_id":"cj4vch4ey0028x3gc087lbhl2","content":"<p>今天在Eclipse中导入一个新项目的时候，出现了乱码问题。研究一番…</p>\n<p>显示乱码的根本原因在于：<strong>文件本身的编码和编辑器打开和编辑文件使用的编码不一致</strong>。当编辑器以不同于文件的编码去解码该文件的时候，就会导致读出来乱码。大部分情况下英文显示正常是因为大部分编码都兼容ASCII，中文则会显示乱码。</p>\n<h2 id=\"编辑器显示乱码问题\"><a href=\"#编辑器显示乱码问题\" class=\"headerlink\" title=\"编辑器显示乱码问题\"></a>编辑器显示乱码问题</h2><p>在Eclipse中，设置编辑器显示和编辑文件所采用编码的方法有四种：</p>\n<p>1.Windows-&gt;Preference-&gt;General-&gt;Workspace ：修改整个工作空间</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/1.png\" alt=\"全局修改\" title=\"全局修改\">\n<p>2.右键Project-&gt;Properties-&gt;Resource ：修改某个工程</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/2.png\" alt=\"工程修改\" title=\"工程修改\">\n<p>3.右键文件-&gt;Properties ：修改某个文件</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/3.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>4.Windows-&gt;Preference-&gt;General-&gt;Content types-&gt;Default encoding :全局修改某种类型的文件</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/4.png\" alt=\"全局文件修改\" title=\"全局文件修改\">\n<p>其中，3的优先级最高。也就是说某个文件被编辑器以哪种编码读取最终是由3中的Text file encoding决定的。一般情况下，如果我们不在3中显示指定编码(选择Other那一项)，Eclipse都会默认使用Default那一项的编码。那么，这个Default的编码又是如何决定的呢？</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/5.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>注意上图中圈起来的部分：这部分表示了Default采用哪种编码是如何决定的。</p>\n<a id=\"more\"></a>\n<p>可能会出现三种情况：</p>\n<p>1.determined from content: xxx </p>\n<p>2.determined from content type: xxx</p>\n<p>3.inherit from container </p>\n<p>其中：</p>\n<p>1表示文件内容本身指定了编码，比如下图。</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/6.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>Encoding Bit Order Mark，简写为BOM，表明文件本身指定了采用哪种编码方式。编辑器会优先采用这种编码。</p>\n<p>2表示采用了针对该文件类型的全局修改，也就是上面提到的第4种设置方式。</p>\n<p>3表示继承了上一级指定的编码，这个继承关系就是我们在上面提到的：修改某个文件-&gt;修改文件所属的工程-&gt;修改整个工作空间。-&gt;表示继承于。</p>\n<p>上面这3种情况的优先级：1&gt;2&gt;3 。也就是说如果文件本身表明了编码方式，Eclipse优先采用这种编码解码文件。若没有指定，Eclipse会查看该文件类型是否在上面的第4种方式设置中指定了编码，如有则采用该编码。如没有指定，则从下往上搜索继承关系链中指定的编码。（继承关系链：文件-&gt;工程-&gt;工作空间）</p>\n<p>通过上面的分析明白了Eclipse 编辑器选择显示文件所采用编码的原理，相信再次遇到编辑器中的乱码问题都可以找到合适的解决方案。上面的分析不仅仅适用于java文件，同样适用于xml等其他类型文件的乱码问题。</p>\n<p>另外一定要注意：<strong>如果通过上面4中方式的某一种修改影响了某个文件的编码，则当你再次编辑完保存该文件时，则采用此时该文件在Eclipse中指定的编码方式保存到本地。</strong></p>\n<p>以上的对乱码问题的分析都是基于通过修改Eclipse编辑器显示文件内容采用的编码，使其与文件本身的编码一致的方式来解决的。还有另一种思路是反过来，修改文件编码与Eclipse显示文件内容所采用的编码一致来解决乱码问题。可以使用文件编码批量转换工具进行批量转换，比如UltraCodingSwitch等。</p>\n<h2 id=\"Console显示乱码问题\"><a href=\"#Console显示乱码问题\" class=\"headerlink\" title=\"Console显示乱码问题\"></a>Console显示乱码问题</h2><p>右键要运行的类-&gt;Run As-&gt;Run Configuratios</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/6.png\" alt=\"Console编码\" title=\"Console编码\">\n<p>可修改上图中Other中的编码来指定显示打印内容的编码。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过以上分析知道了如何在Eclipse中解决乱码的问题。其实文章一开始就说了，显示乱码的根本原因在于：<strong>文件本身的编码和编辑器打开文件使用的编码不一致</strong>。明白了这一点，就算在其他编辑器或编译器中或者任何能够显示文本内容的遇到乱码的情况都能够找到问题的根源，从而解决乱码问题。</p>\n<p>至于文件本身的编码，可以通过一定的手段去改变。如通过记事本等工具修改编码后另存为等方式。</p>\n<p>Java中输出一段内容到文件可以通过指定流的编码来指定输出字符的编码。</p>\n<p>以上</p>\n","excerpt":"<p>今天在Eclipse中导入一个新项目的时候，出现了乱码问题。研究一番…</p>\n<p>显示乱码的根本原因在于：<strong>文件本身的编码和编辑器打开和编辑文件使用的编码不一致</strong>。当编辑器以不同于文件的编码去解码该文件的时候，就会导致读出来乱码。大部分情况下英文显示正常是因为大部分编码都兼容ASCII，中文则会显示乱码。</p>\n<h2 id=\"编辑器显示乱码问题\"><a href=\"#编辑器显示乱码问题\" class=\"headerlink\" title=\"编辑器显示乱码问题\"></a>编辑器显示乱码问题</h2><p>在Eclipse中，设置编辑器显示和编辑文件所采用编码的方法有四种：</p>\n<p>1.Windows-&gt;Preference-&gt;General-&gt;Workspace ：修改整个工作空间</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/1.png\" alt=\"全局修改\" title=\"全局修改\">\n<p>2.右键Project-&gt;Properties-&gt;Resource ：修改某个工程</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/2.png\" alt=\"工程修改\" title=\"工程修改\">\n<p>3.右键文件-&gt;Properties ：修改某个文件</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/3.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>4.Windows-&gt;Preference-&gt;General-&gt;Content types-&gt;Default encoding :全局修改某种类型的文件</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/4.png\" alt=\"全局文件修改\" title=\"全局文件修改\">\n<p>其中，3的优先级最高。也就是说某个文件被编辑器以哪种编码读取最终是由3中的Text file encoding决定的。一般情况下，如果我们不在3中显示指定编码(选择Other那一项)，Eclipse都会默认使用Default那一项的编码。那么，这个Default的编码又是如何决定的呢？</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/5.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>注意上图中圈起来的部分：这部分表示了Default采用哪种编码是如何决定的。</p>","more":"<p>可能会出现三种情况：</p>\n<p>1.determined from content: xxx </p>\n<p>2.determined from content type: xxx</p>\n<p>3.inherit from container </p>\n<p>其中：</p>\n<p>1表示文件内容本身指定了编码，比如下图。</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/6.png\" alt=\"文件修改\" title=\"文件修改\">\n<p>Encoding Bit Order Mark，简写为BOM，表明文件本身指定了采用哪种编码方式。编辑器会优先采用这种编码。</p>\n<p>2表示采用了针对该文件类型的全局修改，也就是上面提到的第4种设置方式。</p>\n<p>3表示继承了上一级指定的编码，这个继承关系就是我们在上面提到的：修改某个文件-&gt;修改文件所属的工程-&gt;修改整个工作空间。-&gt;表示继承于。</p>\n<p>上面这3种情况的优先级：1&gt;2&gt;3 。也就是说如果文件本身表明了编码方式，Eclipse优先采用这种编码解码文件。若没有指定，Eclipse会查看该文件类型是否在上面的第4种方式设置中指定了编码，如有则采用该编码。如没有指定，则从下往上搜索继承关系链中指定的编码。（继承关系链：文件-&gt;工程-&gt;工作空间）</p>\n<p>通过上面的分析明白了Eclipse 编辑器选择显示文件所采用编码的原理，相信再次遇到编辑器中的乱码问题都可以找到合适的解决方案。上面的分析不仅仅适用于java文件，同样适用于xml等其他类型文件的乱码问题。</p>\n<p>另外一定要注意：<strong>如果通过上面4中方式的某一种修改影响了某个文件的编码，则当你再次编辑完保存该文件时，则采用此时该文件在Eclipse中指定的编码方式保存到本地。</strong></p>\n<p>以上的对乱码问题的分析都是基于通过修改Eclipse编辑器显示文件内容采用的编码，使其与文件本身的编码一致的方式来解决的。还有另一种思路是反过来，修改文件编码与Eclipse显示文件内容所采用的编码一致来解决乱码问题。可以使用文件编码批量转换工具进行批量转换，比如UltraCodingSwitch等。</p>\n<h2 id=\"Console显示乱码问题\"><a href=\"#Console显示乱码问题\" class=\"headerlink\" title=\"Console显示乱码问题\"></a>Console显示乱码问题</h2><p>右键要运行的类-&gt;Run As-&gt;Run Configuratios</p>\n<img src=\"/2016/09/20/Eclipse编码问题终极解决方案/6.png\" alt=\"Console编码\" title=\"Console编码\">\n<p>可修改上图中Other中的编码来指定显示打印内容的编码。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过以上分析知道了如何在Eclipse中解决乱码的问题。其实文章一开始就说了，显示乱码的根本原因在于：<strong>文件本身的编码和编辑器打开文件使用的编码不一致</strong>。明白了这一点，就算在其他编辑器或编译器中或者任何能够显示文本内容的遇到乱码的情况都能够找到问题的根源，从而解决乱码问题。</p>\n<p>至于文件本身的编码，可以通过一定的手段去改变。如通过记事本等工具修改编码后另存为等方式。</p>\n<p>Java中输出一段内容到文件可以通过指定流的编码来指定输出字符的编码。</p>\n<p>以上</p>"},{"layout":"post","title":"java文件描述符","date":"2017-07-07T12:54:29.000Z","_content":"\n## 文件描述符\n\n在Linux中，进程是通过文件描述符（file descriptors，简称fd）而不是文件名来访问文件的，文件描述符实际上是一个整数。\n\n内核中，对应于**每个进程**都有一个文件描述符表，表示这个进程打开的所有文件。文件描述符就是这个表的索引。\n\n文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块———file对象，file对象中描述了文件的打开模式，读写位置等重要信息。\n\n{% asset_img filedescriptors.png file descriptors %}\n\n<!-- more -->\n\n当进程打开一个文件时，内核就会**创建一个新的file对象**。因此，我们在进程中使用多线程打开同一个文件，每个线程会有各自的文件描述符，每个线程也会有保存自己的读取位置，互不影响。\n\n需要注意的是，file对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的file对象，从而共享这个打开的文件。比如，如果在调用fork之前父进程已经打开文件，则fork后子进程有一个父进程描述符表的副本。父子进程共享相同的打开文件集合，因此共享相同的文件位置。\n\nfile对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为0时，内核才销毁file对象，因此某个进程关闭文件，不影响与之共享同一个file对象的进程。\n\n每个file结构体都指向一个file_operations结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中read一个文件描述符，read通过系统调用进入内核，然后找到这个文件描述符所指向的file结构体，找到file结构体所指向的file_operations结构体，调用它的read成员所指向的内核函数以完成用户请求。在用户程序中调用lseek、read、write、ioctl、open等函数，最终都由内核调用file_operations的各成员所指向的内核函数完成用户请求。file_operations结构体中的release成员用于完成用户程序的close请求，之所以叫release而不叫close是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。\n\nfile对象中包含一个指针，指向dentry对象。“dentry”是directory entry（目录项）的缩写，dentry对象代表一个独立的文件路径，如果一个文件路径被打开多次，那么会建立多个file对象，但它们都指向同一个dentry对象。为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache，其中每个节点是一个dentry结构体。\n\n每个dentry结构体都有一个指针指向inode结构体。inode结构体保存着从磁盘inode读上来的信息。在上图的例子中，有两个dentry，分别表示/home/akaedu/a和/home/akaedu/b，它们都指向同一个inode，说明这两个文件互为硬链接。inode结构体中保存着从磁盘分区的inode读上来信息，例如所有者、文件大小、文件类型和权限位等。\n\n每个进程刚刚启动的时候，文件描述符0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。\n\n## java中的FileDescriptor\n\n在java中，有着与文件描述符对应的一个类对象：FileDescriptor。我们看一下FileDescriptor与Channel的关系：\n\nFileInputStream.getChannel():\n\n```java\npublic FileChannel getChannel() {\n        synchronized (this) {\n            if (channel == null) {\n                channel = FileChannelImpl.open(fd, path, true, false, this);\n\n                /*\n                 * Increment fd's use count. Invoking the channel's close()\n                 * method will result in decrementing the use count set for\n                 * the channel.\n                 */\n                fd.incrementAndGetUseCount();\n            }\n            return channel;\n        }\n}\n```\n\n其中的`FileChannelImpl.open(fd, path, true, false, this)`参数fd就是FileDescriptor实例。\n\n看一下他是怎么产生的：\n\n```java\npublic FileInputStream(File file) throws FileNotFoundException {\n        String name = (file != null ? file.getPath() : null);\n        SecurityManager security = System.getSecurityManager();\n        if (security != null) {\n            security.checkRead(name);\n        }\n        if (name == null) {\n            throw new NullPointerException();\n        }\n        if (file.isInvalid()) {\n            throw new FileNotFoundException(\"Invalid file path\");\n        }\n        fd = new FileDescriptor();\n        fd.incrementAndGetUseCount();\n        this.path = name;\n        open(name);\n}\n\nstatic {\n    initIDs();\n}\n```\n\n注意到`initIDs()`这个静态方法：\n\n```java\njfieldID fis_fd; /* id for jobject 'fd' in java.io.FileInputStream */\n\nJNIEXPORT void JNICALL\nJava_java_io_FileInputStream_initIDs(JNIEnv *env, jclass fdClass) {\n    fis_fd = (*env)->GetFieldID(env, fdClass, \"fd\", \"Ljava/io/FileDescriptor;\");\n}\n```\n\n在`FileInputStream`类加载阶段，`fis_fd`就被初始化了，`fid_fd`相当于是`FileInputStream.fd`字段的一个内存偏移量，便于在必要时操作内存给它赋值。\n\n看一下FileDescriptor的实例化过程：\n\n```java\npublic /**/ FileDescriptor() {\n        fd = -1;\n        handle = -1;\n        useCount = new AtomicInteger();\n}\n\nstatic {\n    initIDs();\n}\n```\nFileDescriptor也有一个`initIDs`，他和`FileInputStream.initIDs`的方法类似，把设置`IO_fd_fdID`为`FileDescriptor.fd`字段的内存偏移量。\n\n```java\n/* field id for jint 'fd' in java.io.FileDescriptor */\njfieldID IO_fd_fdID;\n/**************************************************************\n * static methods to store field ID's in initializers\n */\nJNIEXPORT void JNICALL\nJava_java_io_FileDescriptor_initIDs(JNIEnv *env, jclass fdClass) {\n    IO_fd_fdID = (*env)->GetFieldID(env, fdClass, \"fd\", \"I\");\n}\n```\n\n接下来再看`FileInputStream`构造函数中的`open(name)`方法，字面上看，这个方法打开了一个文件，他也是一个本地方法，open方法直接调用了fileOpen方法，fileOpen方法如下:\n\n```java\nvoid fileOpen(JNIEnv *env, jobject this, jstring path, jfieldID fid, int flags)\n{\n    WITH_PLATFORM_STRING(env, path, ps) {\n        FD fd;\n#if defined(__linux__) || defined(_ALLBSD_SOURCE)\n        /* Remove trailing slashes, since the kernel won't */\n        char *p = (char *)ps + strlen(ps) - 1;\n        while ((p > ps) && (*p == '/'))\n            *p-- = '\\0';\n#endif\n        // 打开一个文件并获取到文件描述符\n        fd = handleOpen(ps, flags, 0666);\n        if (fd != -1) {\n            SET_FD(this, fd, fid);\n        } else {\n            throwFileNotFoundException(env, path);\n        }\n    } END_PLATFORM_STRING(env, ps);\n}\n```\n\n其中的handleOpen函数打开了一个文件描述符，相当于和文件建立了联系，并且将返回的文件描述符描述符赋值给了局部变量fd,然后调用了SET_FD宏:\n\n```java\n#define SET_FD(this, fd, fid) \\\n    if ((*env)->GetObjectField(env, (this), (fid)) != NULL) \\\n        (*env)->SetIntField(env, (*env)->GetObjectField(env, (this), (fid)),IO_fd_fdID, (fd))\n```\n\n注意到`IO_fd_fdID`，他是`FileDescriptor.fd`字段的内存偏移量。这个方法相当于设置`FileDescriptor.fd`的值等于文件描述符fd。\n\n需要注意的是，FileDescriptor有两个字段：handle和fd，上面的代码表示我们只设置了fd字段为文件描述符，没有提到handle字段，这是因为：\n\n在 win32 的实现中将 创建好的 文件句柄 设置到 handle 字段，在 linux 版本中则使用的是 FileDescriptor 的 fd 字段。\n\n由此，可知 handle 和 fd 是共存的但并不同时在使用，在 win32 平台上使用 handle 字段，在 linux 平台上使用 fd 字段。\n\n所以，FileInputStream打开文件的过程总结如下：\n\n- 创建 FileDescriptor 对象\n\n每一个 FileInputStream 有一个 FileDescriptor，代表这个流底层的文件的fd\n\n- 调用 native 方法 open, 打开文件\n\n- 内部调用 handleOpen 打开文件，返回文件描述符 fd\n\n初始化 FileDescriptor 对象\n\n- 将 文件描述符 fd 设置到，FileDescriptor 对象的 fd 中\n\n## 再谈java文件读取\n\n在[java-NIO-Buffer](http://yukai.space/2017/06/28/java-NIO-Buffer/)这篇文章中我们提到了`FileInputStream.read`方法，再来回顾一下：\n\n```java\nJNIEXPORT jint JNICALL  \nJava_java_io_FileInputStream_readBytes(JNIEnv *env, jobject this,  \n        jbyteArray bytes, jint off, jint len) {//除了前两个参数，后三个就是readBytes方法传递进来的，字节数组、起始位置、长度三个参数  \nreturn readBytes(env, this, bytes, off, len, fis_fd);  \n}\n\njint\nreadBytes(JNIEnv *env, jobject this, jbyteArray bytes,\n          jint off, jint len, jfieldID fid)\n{\n    jint nread;\n    char stackBuf[BUF_SIZE];\n    char *buf = NULL;\n    FD fd;\n \n    if (IS_NULL(bytes)) {\n        JNU_ThrowNullPointerException(env, NULL);\n        return -1;\n    }\n \n    if (outOfBounds(env, off, len, bytes)) {\n        JNU_ThrowByName(env, \"java/lang/IndexOutOfBoundsException\", NULL);\n        return -1;\n    }\n \n    if (len == 0) {\n        return 0;\n    } else if (len > BUF_SIZE) {\n        buf = malloc(len);// buf的分配\n        if (buf == NULL) {\n            JNU_ThrowOutOfMemoryError(env, NULL);\n            return 0;\n        }\n    } else {\n        buf = stackBuf;\n    }\n \n    fd = GET_FD(this, fid);\n    if (fd == -1) {\n        JNU_ThrowIOException(env, \"Stream Closed\");\n        nread = -1;\n    } else {\n        nread = IO_Read(fd, buf, len);// buf是使用malloc分配的直接缓冲区，也就是堆外内存\n        if (nread > 0) {\n            (*env)->SetByteArrayRegion(env, bytes, off, nread, (jbyte *)buf);// 将直接缓冲区的内容copy到bytes数组中\n        } else if (nread == JVM_IO_ERR) {\n            JNU_ThrowIOExceptionWithLastError(env, \"Read error\");\n        } else if (nread == JVM_IO_INTR) {\n            JNU_ThrowByName(env, \"java/io/InterruptedIOException\", NULL);\n        } else { /* EOF */\n            nread = -1;\n        }\n    }\n \n    if (buf != stackBuf) {\n        free(buf);\n    }\n    return nread;\n}\n```\n上述代码中的`fis_fd`是不是很眼熟？他就是`FileInputStream.fd`字段的内存偏移量。注意到`fd = GET_FD(this, fid);`这个方法，获取到其对应的文件描述符，然后使用该文件描述符读取文件内容，填充缓冲区。由此可见，java底层读取文件都是通过文件描述符来进行的。比如：\n\n文章开始提到**每个进程刚刚启动的时候，文件描述符0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3**，FileDescriptor中的fd为0，1，2时也表示同样的意义。\n\n```java\nFileOutputStream fileOutputStream = new FileOutputStream(FileDescriptor.out);\nfileOutputStream.write('hello world');// 控制台打印 hello world，因为fileOutputStream使用了标准输出的文件描述符\n```\n\n## 参考\n\n[linux 文件描述符表 打开文件表 inode vnode](http://blog.csdn.net/kennyrose/article/details/7595013)\n\n[linux中文件描述符fd和文件指针flip的理解](http://www.cnblogs.com/Jezze/archive/2011/12/23/2299861.html)\n\n[JNI探秘--FileDescriptor、FileInputStream 解惑](https://vinoit.me/2016/09/14/JNI-explore-FileDescriptor-and-FileInputStream/)\n","source":"_posts/java文件描述符.md","raw":"---\nlayout: post\ntitle: java文件描述符\ndate: 2017-07-07 20:54:29\ncategories: 编程\ntags: \n- java \n---\n\n## 文件描述符\n\n在Linux中，进程是通过文件描述符（file descriptors，简称fd）而不是文件名来访问文件的，文件描述符实际上是一个整数。\n\n内核中，对应于**每个进程**都有一个文件描述符表，表示这个进程打开的所有文件。文件描述符就是这个表的索引。\n\n文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块———file对象，file对象中描述了文件的打开模式，读写位置等重要信息。\n\n{% asset_img filedescriptors.png file descriptors %}\n\n<!-- more -->\n\n当进程打开一个文件时，内核就会**创建一个新的file对象**。因此，我们在进程中使用多线程打开同一个文件，每个线程会有各自的文件描述符，每个线程也会有保存自己的读取位置，互不影响。\n\n需要注意的是，file对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的file对象，从而共享这个打开的文件。比如，如果在调用fork之前父进程已经打开文件，则fork后子进程有一个父进程描述符表的副本。父子进程共享相同的打开文件集合，因此共享相同的文件位置。\n\nfile对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为0时，内核才销毁file对象，因此某个进程关闭文件，不影响与之共享同一个file对象的进程。\n\n每个file结构体都指向一个file_operations结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中read一个文件描述符，read通过系统调用进入内核，然后找到这个文件描述符所指向的file结构体，找到file结构体所指向的file_operations结构体，调用它的read成员所指向的内核函数以完成用户请求。在用户程序中调用lseek、read、write、ioctl、open等函数，最终都由内核调用file_operations的各成员所指向的内核函数完成用户请求。file_operations结构体中的release成员用于完成用户程序的close请求，之所以叫release而不叫close是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。\n\nfile对象中包含一个指针，指向dentry对象。“dentry”是directory entry（目录项）的缩写，dentry对象代表一个独立的文件路径，如果一个文件路径被打开多次，那么会建立多个file对象，但它们都指向同一个dentry对象。为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache，其中每个节点是一个dentry结构体。\n\n每个dentry结构体都有一个指针指向inode结构体。inode结构体保存着从磁盘inode读上来的信息。在上图的例子中，有两个dentry，分别表示/home/akaedu/a和/home/akaedu/b，它们都指向同一个inode，说明这两个文件互为硬链接。inode结构体中保存着从磁盘分区的inode读上来信息，例如所有者、文件大小、文件类型和权限位等。\n\n每个进程刚刚启动的时候，文件描述符0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。\n\n## java中的FileDescriptor\n\n在java中，有着与文件描述符对应的一个类对象：FileDescriptor。我们看一下FileDescriptor与Channel的关系：\n\nFileInputStream.getChannel():\n\n```java\npublic FileChannel getChannel() {\n        synchronized (this) {\n            if (channel == null) {\n                channel = FileChannelImpl.open(fd, path, true, false, this);\n\n                /*\n                 * Increment fd's use count. Invoking the channel's close()\n                 * method will result in decrementing the use count set for\n                 * the channel.\n                 */\n                fd.incrementAndGetUseCount();\n            }\n            return channel;\n        }\n}\n```\n\n其中的`FileChannelImpl.open(fd, path, true, false, this)`参数fd就是FileDescriptor实例。\n\n看一下他是怎么产生的：\n\n```java\npublic FileInputStream(File file) throws FileNotFoundException {\n        String name = (file != null ? file.getPath() : null);\n        SecurityManager security = System.getSecurityManager();\n        if (security != null) {\n            security.checkRead(name);\n        }\n        if (name == null) {\n            throw new NullPointerException();\n        }\n        if (file.isInvalid()) {\n            throw new FileNotFoundException(\"Invalid file path\");\n        }\n        fd = new FileDescriptor();\n        fd.incrementAndGetUseCount();\n        this.path = name;\n        open(name);\n}\n\nstatic {\n    initIDs();\n}\n```\n\n注意到`initIDs()`这个静态方法：\n\n```java\njfieldID fis_fd; /* id for jobject 'fd' in java.io.FileInputStream */\n\nJNIEXPORT void JNICALL\nJava_java_io_FileInputStream_initIDs(JNIEnv *env, jclass fdClass) {\n    fis_fd = (*env)->GetFieldID(env, fdClass, \"fd\", \"Ljava/io/FileDescriptor;\");\n}\n```\n\n在`FileInputStream`类加载阶段，`fis_fd`就被初始化了，`fid_fd`相当于是`FileInputStream.fd`字段的一个内存偏移量，便于在必要时操作内存给它赋值。\n\n看一下FileDescriptor的实例化过程：\n\n```java\npublic /**/ FileDescriptor() {\n        fd = -1;\n        handle = -1;\n        useCount = new AtomicInteger();\n}\n\nstatic {\n    initIDs();\n}\n```\nFileDescriptor也有一个`initIDs`，他和`FileInputStream.initIDs`的方法类似，把设置`IO_fd_fdID`为`FileDescriptor.fd`字段的内存偏移量。\n\n```java\n/* field id for jint 'fd' in java.io.FileDescriptor */\njfieldID IO_fd_fdID;\n/**************************************************************\n * static methods to store field ID's in initializers\n */\nJNIEXPORT void JNICALL\nJava_java_io_FileDescriptor_initIDs(JNIEnv *env, jclass fdClass) {\n    IO_fd_fdID = (*env)->GetFieldID(env, fdClass, \"fd\", \"I\");\n}\n```\n\n接下来再看`FileInputStream`构造函数中的`open(name)`方法，字面上看，这个方法打开了一个文件，他也是一个本地方法，open方法直接调用了fileOpen方法，fileOpen方法如下:\n\n```java\nvoid fileOpen(JNIEnv *env, jobject this, jstring path, jfieldID fid, int flags)\n{\n    WITH_PLATFORM_STRING(env, path, ps) {\n        FD fd;\n#if defined(__linux__) || defined(_ALLBSD_SOURCE)\n        /* Remove trailing slashes, since the kernel won't */\n        char *p = (char *)ps + strlen(ps) - 1;\n        while ((p > ps) && (*p == '/'))\n            *p-- = '\\0';\n#endif\n        // 打开一个文件并获取到文件描述符\n        fd = handleOpen(ps, flags, 0666);\n        if (fd != -1) {\n            SET_FD(this, fd, fid);\n        } else {\n            throwFileNotFoundException(env, path);\n        }\n    } END_PLATFORM_STRING(env, ps);\n}\n```\n\n其中的handleOpen函数打开了一个文件描述符，相当于和文件建立了联系，并且将返回的文件描述符描述符赋值给了局部变量fd,然后调用了SET_FD宏:\n\n```java\n#define SET_FD(this, fd, fid) \\\n    if ((*env)->GetObjectField(env, (this), (fid)) != NULL) \\\n        (*env)->SetIntField(env, (*env)->GetObjectField(env, (this), (fid)),IO_fd_fdID, (fd))\n```\n\n注意到`IO_fd_fdID`，他是`FileDescriptor.fd`字段的内存偏移量。这个方法相当于设置`FileDescriptor.fd`的值等于文件描述符fd。\n\n需要注意的是，FileDescriptor有两个字段：handle和fd，上面的代码表示我们只设置了fd字段为文件描述符，没有提到handle字段，这是因为：\n\n在 win32 的实现中将 创建好的 文件句柄 设置到 handle 字段，在 linux 版本中则使用的是 FileDescriptor 的 fd 字段。\n\n由此，可知 handle 和 fd 是共存的但并不同时在使用，在 win32 平台上使用 handle 字段，在 linux 平台上使用 fd 字段。\n\n所以，FileInputStream打开文件的过程总结如下：\n\n- 创建 FileDescriptor 对象\n\n每一个 FileInputStream 有一个 FileDescriptor，代表这个流底层的文件的fd\n\n- 调用 native 方法 open, 打开文件\n\n- 内部调用 handleOpen 打开文件，返回文件描述符 fd\n\n初始化 FileDescriptor 对象\n\n- 将 文件描述符 fd 设置到，FileDescriptor 对象的 fd 中\n\n## 再谈java文件读取\n\n在[java-NIO-Buffer](http://yukai.space/2017/06/28/java-NIO-Buffer/)这篇文章中我们提到了`FileInputStream.read`方法，再来回顾一下：\n\n```java\nJNIEXPORT jint JNICALL  \nJava_java_io_FileInputStream_readBytes(JNIEnv *env, jobject this,  \n        jbyteArray bytes, jint off, jint len) {//除了前两个参数，后三个就是readBytes方法传递进来的，字节数组、起始位置、长度三个参数  \nreturn readBytes(env, this, bytes, off, len, fis_fd);  \n}\n\njint\nreadBytes(JNIEnv *env, jobject this, jbyteArray bytes,\n          jint off, jint len, jfieldID fid)\n{\n    jint nread;\n    char stackBuf[BUF_SIZE];\n    char *buf = NULL;\n    FD fd;\n \n    if (IS_NULL(bytes)) {\n        JNU_ThrowNullPointerException(env, NULL);\n        return -1;\n    }\n \n    if (outOfBounds(env, off, len, bytes)) {\n        JNU_ThrowByName(env, \"java/lang/IndexOutOfBoundsException\", NULL);\n        return -1;\n    }\n \n    if (len == 0) {\n        return 0;\n    } else if (len > BUF_SIZE) {\n        buf = malloc(len);// buf的分配\n        if (buf == NULL) {\n            JNU_ThrowOutOfMemoryError(env, NULL);\n            return 0;\n        }\n    } else {\n        buf = stackBuf;\n    }\n \n    fd = GET_FD(this, fid);\n    if (fd == -1) {\n        JNU_ThrowIOException(env, \"Stream Closed\");\n        nread = -1;\n    } else {\n        nread = IO_Read(fd, buf, len);// buf是使用malloc分配的直接缓冲区，也就是堆外内存\n        if (nread > 0) {\n            (*env)->SetByteArrayRegion(env, bytes, off, nread, (jbyte *)buf);// 将直接缓冲区的内容copy到bytes数组中\n        } else if (nread == JVM_IO_ERR) {\n            JNU_ThrowIOExceptionWithLastError(env, \"Read error\");\n        } else if (nread == JVM_IO_INTR) {\n            JNU_ThrowByName(env, \"java/io/InterruptedIOException\", NULL);\n        } else { /* EOF */\n            nread = -1;\n        }\n    }\n \n    if (buf != stackBuf) {\n        free(buf);\n    }\n    return nread;\n}\n```\n上述代码中的`fis_fd`是不是很眼熟？他就是`FileInputStream.fd`字段的内存偏移量。注意到`fd = GET_FD(this, fid);`这个方法，获取到其对应的文件描述符，然后使用该文件描述符读取文件内容，填充缓冲区。由此可见，java底层读取文件都是通过文件描述符来进行的。比如：\n\n文章开始提到**每个进程刚刚启动的时候，文件描述符0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3**，FileDescriptor中的fd为0，1，2时也表示同样的意义。\n\n```java\nFileOutputStream fileOutputStream = new FileOutputStream(FileDescriptor.out);\nfileOutputStream.write('hello world');// 控制台打印 hello world，因为fileOutputStream使用了标准输出的文件描述符\n```\n\n## 参考\n\n[linux 文件描述符表 打开文件表 inode vnode](http://blog.csdn.net/kennyrose/article/details/7595013)\n\n[linux中文件描述符fd和文件指针flip的理解](http://www.cnblogs.com/Jezze/archive/2011/12/23/2299861.html)\n\n[JNI探秘--FileDescriptor、FileInputStream 解惑](https://vinoit.me/2016/09/14/JNI-explore-FileDescriptor-and-FileInputStream/)\n","slug":"java文件描述符","published":1,"updated":"2017-07-07T13:04:55.310Z","comments":1,"photos":[],"link":"","_id":"cj4vch4ez002bx3gcjoo9h8ni","content":"<h2 id=\"文件描述符\"><a href=\"#文件描述符\" class=\"headerlink\" title=\"文件描述符\"></a>文件描述符</h2><p>在Linux中，进程是通过文件描述符（file descriptors，简称fd）而不是文件名来访问文件的，文件描述符实际上是一个整数。</p>\n<p>内核中，对应于<strong>每个进程</strong>都有一个文件描述符表，表示这个进程打开的所有文件。文件描述符就是这个表的索引。</p>\n<p>文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块———file对象，file对象中描述了文件的打开模式，读写位置等重要信息。</p>\n<img src=\"/2017/07/07/java文件描述符/filedescriptors.png\" alt=\"file descriptors\" title=\"file descriptors\">\n<a id=\"more\"></a>\n<p>当进程打开一个文件时，内核就会<strong>创建一个新的file对象</strong>。因此，我们在进程中使用多线程打开同一个文件，每个线程会有各自的文件描述符，每个线程也会有保存自己的读取位置，互不影响。</p>\n<p>需要注意的是，file对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的file对象，从而共享这个打开的文件。比如，如果在调用fork之前父进程已经打开文件，则fork后子进程有一个父进程描述符表的副本。父子进程共享相同的打开文件集合，因此共享相同的文件位置。</p>\n<p>file对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为0时，内核才销毁file对象，因此某个进程关闭文件，不影响与之共享同一个file对象的进程。</p>\n<p>每个file结构体都指向一个file_operations结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中read一个文件描述符，read通过系统调用进入内核，然后找到这个文件描述符所指向的file结构体，找到file结构体所指向的file_operations结构体，调用它的read成员所指向的内核函数以完成用户请求。在用户程序中调用lseek、read、write、ioctl、open等函数，最终都由内核调用file_operations的各成员所指向的内核函数完成用户请求。file_operations结构体中的release成员用于完成用户程序的close请求，之所以叫release而不叫close是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。</p>\n<p>file对象中包含一个指针，指向dentry对象。“dentry”是directory entry（目录项）的缩写，dentry对象代表一个独立的文件路径，如果一个文件路径被打开多次，那么会建立多个file对象，但它们都指向同一个dentry对象。为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache，其中每个节点是一个dentry结构体。</p>\n<p>每个dentry结构体都有一个指针指向inode结构体。inode结构体保存着从磁盘inode读上来的信息。在上图的例子中，有两个dentry，分别表示/home/akaedu/a和/home/akaedu/b，它们都指向同一个inode，说明这两个文件互为硬链接。inode结构体中保存着从磁盘分区的inode读上来信息，例如所有者、文件大小、文件类型和权限位等。</p>\n<p>每个进程刚刚启动的时候，文件描述符0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。</p>\n<h2 id=\"java中的FileDescriptor\"><a href=\"#java中的FileDescriptor\" class=\"headerlink\" title=\"java中的FileDescriptor\"></a>java中的FileDescriptor</h2><p>在java中，有着与文件描述符对应的一个类对象：FileDescriptor。我们看一下FileDescriptor与Channel的关系：</p>\n<p>FileInputStream.getChannel():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FileChannel <span class=\"title\">getChannel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (channel == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                channel = FileChannelImpl.open(fd, path, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">/*</span></div><div class=\"line\">                 * Increment fd's use count. Invoking the channel's close()</div><div class=\"line\">                 * method will result in decrementing the use count set for</div><div class=\"line\">                 * the channel.</div><div class=\"line\">                 */</div><div class=\"line\">                fd.incrementAndGetUseCount();</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> channel;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中的<code>FileChannelImpl.open(fd, path, true, false, this)</code>参数fd就是FileDescriptor实例。</p>\n<p>看一下他是怎么产生的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</div><div class=\"line\">        String name = (file != <span class=\"keyword\">null</span> ? file.getPath() : <span class=\"keyword\">null</span>);</div><div class=\"line\">        SecurityManager security = System.getSecurityManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (security != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            security.checkRead(name);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (file.isInvalid()) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FileNotFoundException(<span class=\"string\">\"Invalid file path\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        fd = <span class=\"keyword\">new</span> FileDescriptor();</div><div class=\"line\">        fd.incrementAndGetUseCount();</div><div class=\"line\">        <span class=\"keyword\">this</span>.path = name;</div><div class=\"line\">        open(name);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> &#123;</div><div class=\"line\">    initIDs();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意到<code>initIDs()</code>这个静态方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">jfieldID fis_fd; <span class=\"comment\">/* id for jobject 'fd' in java.io.FileInputStream */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL</span></div><div class=\"line\"><span class=\"title\">Java_java_io_FileInputStream_initIDs</span><span class=\"params\">(JNIEnv *env, jclass fdClass)</span> &#123;</div><div class=\"line\">    fis_fd = (*env)-&gt;GetFieldID(env, fdClass, <span class=\"string\">\"fd\"</span>, <span class=\"string\">\"Ljava/io/FileDescriptor;\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在<code>FileInputStream</code>类加载阶段，<code>fis_fd</code>就被初始化了，<code>fid_fd</code>相当于是<code>FileInputStream.fd</code>字段的一个内存偏移量，便于在必要时操作内存给它赋值。</p>\n<p>看一下FileDescriptor的实例化过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"comment\">/**/ FileDescriptor() &#123;</span></div><div class=\"line\">        fd = -1;</div><div class=\"line\">        handle = -1;</div><div class=\"line\">        useCount = new AtomicInteger();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static &#123;</div><div class=\"line\">    initIDs();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>FileDescriptor也有一个<code>initIDs</code>，他和<code>FileInputStream.initIDs</code>的方法类似，把设置<code>IO_fd_fdID</code>为<code>FileDescriptor.fd</code>字段的内存偏移量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* field id for jint 'fd' in java.io.FileDescriptor */</span></div><div class=\"line\">jfieldID IO_fd_fdID;</div><div class=\"line\"><span class=\"comment\">/**************************************************************</span></div><div class=\"line\"> * static methods to store field ID's in initializers</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL</span></div><div class=\"line\"><span class=\"title\">Java_java_io_FileDescriptor_initIDs</span><span class=\"params\">(JNIEnv *env, jclass fdClass)</span> &#123;</div><div class=\"line\">    IO_fd_fdID = (*env)-&gt;GetFieldID(env, fdClass, <span class=\"string\">\"fd\"</span>, <span class=\"string\">\"I\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来再看<code>FileInputStream</code>构造函数中的<code>open(name)</code>方法，字面上看，这个方法打开了一个文件，他也是一个本地方法，open方法直接调用了fileOpen方法，fileOpen方法如下:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">void fileOpen(JNIEnv *env, jobject this, jstring path, jfieldID fid, int flags)</div><div class=\"line\">&#123;</div><div class=\"line\">    WITH_PLATFORM_STRING(env, path, ps) &#123;</div><div class=\"line\">        FD fd;</div><div class=\"line\">#if defined(__linux__) || defined(_ALLBSD_SOURCE)</div><div class=\"line\">        /* Remove trailing slashes, since the kernel won't */</div><div class=\"line\">        char *p = (char *)ps + strlen(ps) - 1;</div><div class=\"line\">        while ((p &gt; ps) &amp;&amp; (*p == '/'))</div><div class=\"line\">            *p-- = '\\0';</div><div class=\"line\">#endif</div><div class=\"line\">        // 打开一个文件并获取到文件描述符</div><div class=\"line\">        fd = handleOpen(ps, flags, 0666);</div><div class=\"line\">        if (fd != -1) &#123;</div><div class=\"line\">            SET_FD(this, fd, fid);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            throwFileNotFoundException(env, path);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; END_PLATFORM_STRING(env, ps);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中的handleOpen函数打开了一个文件描述符，相当于和文件建立了联系，并且将返回的文件描述符描述符赋值给了局部变量fd,然后调用了SET_FD宏:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define SET_FD(this, fd, fid) \\</div><div class=\"line\">    if ((*env)-&gt;GetObjectField(env, (this), (fid)) != NULL) \\</div><div class=\"line\">        (*env)-&gt;SetIntField(env, (*env)-&gt;GetObjectField(env, (this), (fid)),IO_fd_fdID, (fd))</div></pre></td></tr></table></figure>\n<p>注意到<code>IO_fd_fdID</code>，他是<code>FileDescriptor.fd</code>字段的内存偏移量。这个方法相当于设置<code>FileDescriptor.fd</code>的值等于文件描述符fd。</p>\n<p>需要注意的是，FileDescriptor有两个字段：handle和fd，上面的代码表示我们只设置了fd字段为文件描述符，没有提到handle字段，这是因为：</p>\n<p>在 win32 的实现中将 创建好的 文件句柄 设置到 handle 字段，在 linux 版本中则使用的是 FileDescriptor 的 fd 字段。</p>\n<p>由此，可知 handle 和 fd 是共存的但并不同时在使用，在 win32 平台上使用 handle 字段，在 linux 平台上使用 fd 字段。</p>\n<p>所以，FileInputStream打开文件的过程总结如下：</p>\n<ul>\n<li>创建 FileDescriptor 对象</li>\n</ul>\n<p>每一个 FileInputStream 有一个 FileDescriptor，代表这个流底层的文件的fd</p>\n<ul>\n<li><p>调用 native 方法 open, 打开文件</p>\n</li>\n<li><p>内部调用 handleOpen 打开文件，返回文件描述符 fd</p>\n</li>\n</ul>\n<p>初始化 FileDescriptor 对象</p>\n<ul>\n<li>将 文件描述符 fd 设置到，FileDescriptor 对象的 fd 中</li>\n</ul>\n<h2 id=\"再谈java文件读取\"><a href=\"#再谈java文件读取\" class=\"headerlink\" title=\"再谈java文件读取\"></a>再谈java文件读取</h2><p>在<a href=\"http://yukai.space/2017/06/28/java-NIO-Buffer/\">java-NIO-Buffer</a>这篇文章中我们提到了<code>FileInputStream.read</code>方法，再来回顾一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">JNIEXPORT jint JNICALL  </span></div><div class=\"line\"><span class=\"title\">Java_java_io_FileInputStream_readBytes</span><span class=\"params\">(JNIEnv *env, jobject <span class=\"keyword\">this</span>,  </span></div><div class=\"line\">        jbyteArray bytes, jint off, jint len) &#123;<span class=\"comment\">//除了前两个参数，后三个就是readBytes方法传递进来的，字节数组、起始位置、长度三个参数  </span></div><div class=\"line\"><span class=\"keyword\">return</span> readBytes(env, <span class=\"keyword\">this</span>, bytes, off, len, fis_fd);  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">jint</span></div><div class=\"line\"><span class=\"title\">readBytes</span><span class=\"params\">(JNIEnv *env, jobject <span class=\"keyword\">this</span>, jbyteArray bytes,</span></div><div class=\"line\">          jint off, jint len, jfieldID fid)</div><div class=\"line\">&#123;</div><div class=\"line\">    jint nread;</div><div class=\"line\">    <span class=\"keyword\">char</span> stackBuf[BUF_SIZE];</div><div class=\"line\">    <span class=\"keyword\">char</span> *buf = NULL;</div><div class=\"line\">    FD fd;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (IS_NULL(bytes)) &#123;</div><div class=\"line\">        JNU_ThrowNullPointerException(env, NULL);</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (outOfBounds(env, off, len, bytes)) &#123;</div><div class=\"line\">        JNU_ThrowByName(env, <span class=\"string\">\"java/lang/IndexOutOfBoundsException\"</span>, NULL);</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len &gt; BUF_SIZE) &#123;</div><div class=\"line\">        buf = malloc(len);<span class=\"comment\">// buf的分配</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (buf == NULL) &#123;</div><div class=\"line\">            JNU_ThrowOutOfMemoryError(env, NULL);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        buf = stackBuf;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    fd = GET_FD(<span class=\"keyword\">this</span>, fid);</div><div class=\"line\">    <span class=\"keyword\">if</span> (fd == -<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        JNU_ThrowIOException(env, <span class=\"string\">\"Stream Closed\"</span>);</div><div class=\"line\">        nread = -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        nread = IO_Read(fd, buf, len);<span class=\"comment\">// buf是使用malloc分配的直接缓冲区，也就是堆外内存</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (nread &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            (*env)-&gt;SetByteArrayRegion(env, bytes, off, nread, (jbyte *)buf);<span class=\"comment\">// 将直接缓冲区的内容copy到bytes数组中</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nread == JVM_IO_ERR) &#123;</div><div class=\"line\">            JNU_ThrowIOExceptionWithLastError(env, <span class=\"string\">\"Read error\"</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nread == JVM_IO_INTR) &#123;</div><div class=\"line\">            JNU_ThrowByName(env, <span class=\"string\">\"java/io/InterruptedIOException\"</span>, NULL);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* EOF */</span></div><div class=\"line\">            nread = -<span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (buf != stackBuf) &#123;</div><div class=\"line\">        free(buf);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> nread;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码中的<code>fis_fd</code>是不是很眼熟？他就是<code>FileInputStream.fd</code>字段的内存偏移量。注意到<code>fd = GET_FD(this, fid);</code>这个方法，获取到其对应的文件描述符，然后使用该文件描述符读取文件内容，填充缓冲区。由此可见，java底层读取文件都是通过文件描述符来进行的。比如：</p>\n<p>文章开始提到<strong>每个进程刚刚启动的时候，文件描述符0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3</strong>，FileDescriptor中的fd为0，1，2时也表示同样的意义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FileOutputStream fileOutputStream = <span class=\"keyword\">new</span> FileOutputStream(FileDescriptor.out);</div><div class=\"line\">fileOutputStream.write(<span class=\"string\">'hello world'</span>);<span class=\"comment\">// 控制台打印 hello world，因为fileOutputStream使用了标准输出的文件描述符</span></div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.csdn.net/kennyrose/article/details/7595013\" target=\"_blank\" rel=\"external\">linux 文件描述符表 打开文件表 inode vnode</a></p>\n<p><a href=\"http://www.cnblogs.com/Jezze/archive/2011/12/23/2299861.html\" target=\"_blank\" rel=\"external\">linux中文件描述符fd和文件指针flip的理解</a></p>\n<p><a href=\"https://vinoit.me/2016/09/14/JNI-explore-FileDescriptor-and-FileInputStream/\" target=\"_blank\" rel=\"external\">JNI探秘–FileDescriptor、FileInputStream 解惑</a></p>\n","excerpt":"<h2 id=\"文件描述符\"><a href=\"#文件描述符\" class=\"headerlink\" title=\"文件描述符\"></a>文件描述符</h2><p>在Linux中，进程是通过文件描述符（file descriptors，简称fd）而不是文件名来访问文件的，文件描述符实际上是一个整数。</p>\n<p>内核中，对应于<strong>每个进程</strong>都有一个文件描述符表，表示这个进程打开的所有文件。文件描述符就是这个表的索引。</p>\n<p>文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块———file对象，file对象中描述了文件的打开模式，读写位置等重要信息。</p>\n<img src=\"/2017/07/07/java文件描述符/filedescriptors.png\" alt=\"file descriptors\" title=\"file descriptors\">","more":"<p>当进程打开一个文件时，内核就会<strong>创建一个新的file对象</strong>。因此，我们在进程中使用多线程打开同一个文件，每个线程会有各自的文件描述符，每个线程也会有保存自己的读取位置，互不影响。</p>\n<p>需要注意的是，file对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的file对象，从而共享这个打开的文件。比如，如果在调用fork之前父进程已经打开文件，则fork后子进程有一个父进程描述符表的副本。父子进程共享相同的打开文件集合，因此共享相同的文件位置。</p>\n<p>file对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为0时，内核才销毁file对象，因此某个进程关闭文件，不影响与之共享同一个file对象的进程。</p>\n<p>每个file结构体都指向一个file_operations结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中read一个文件描述符，read通过系统调用进入内核，然后找到这个文件描述符所指向的file结构体，找到file结构体所指向的file_operations结构体，调用它的read成员所指向的内核函数以完成用户请求。在用户程序中调用lseek、read、write、ioctl、open等函数，最终都由内核调用file_operations的各成员所指向的内核函数完成用户请求。file_operations结构体中的release成员用于完成用户程序的close请求，之所以叫release而不叫close是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。</p>\n<p>file对象中包含一个指针，指向dentry对象。“dentry”是directory entry（目录项）的缩写，dentry对象代表一个独立的文件路径，如果一个文件路径被打开多次，那么会建立多个file对象，但它们都指向同一个dentry对象。为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache，其中每个节点是一个dentry结构体。</p>\n<p>每个dentry结构体都有一个指针指向inode结构体。inode结构体保存着从磁盘inode读上来的信息。在上图的例子中，有两个dentry，分别表示/home/akaedu/a和/home/akaedu/b，它们都指向同一个inode，说明这两个文件互为硬链接。inode结构体中保存着从磁盘分区的inode读上来信息，例如所有者、文件大小、文件类型和权限位等。</p>\n<p>每个进程刚刚启动的时候，文件描述符0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。</p>\n<h2 id=\"java中的FileDescriptor\"><a href=\"#java中的FileDescriptor\" class=\"headerlink\" title=\"java中的FileDescriptor\"></a>java中的FileDescriptor</h2><p>在java中，有着与文件描述符对应的一个类对象：FileDescriptor。我们看一下FileDescriptor与Channel的关系：</p>\n<p>FileInputStream.getChannel():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FileChannel <span class=\"title\">getChannel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (channel == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                channel = FileChannelImpl.open(fd, path, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">/*</div><div class=\"line\">                 * Increment fd's use count. Invoking the channel's close()</div><div class=\"line\">                 * method will result in decrementing the use count set for</div><div class=\"line\">                 * the channel.</div><div class=\"line\">                 */</span></div><div class=\"line\">                fd.incrementAndGetUseCount();</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> channel;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中的<code>FileChannelImpl.open(fd, path, true, false, this)</code>参数fd就是FileDescriptor实例。</p>\n<p>看一下他是怎么产生的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</div><div class=\"line\">        String name = (file != <span class=\"keyword\">null</span> ? file.getPath() : <span class=\"keyword\">null</span>);</div><div class=\"line\">        SecurityManager security = System.getSecurityManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (security != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            security.checkRead(name);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (file.isInvalid()) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FileNotFoundException(<span class=\"string\">\"Invalid file path\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        fd = <span class=\"keyword\">new</span> FileDescriptor();</div><div class=\"line\">        fd.incrementAndGetUseCount();</div><div class=\"line\">        <span class=\"keyword\">this</span>.path = name;</div><div class=\"line\">        open(name);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> &#123;</div><div class=\"line\">    initIDs();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意到<code>initIDs()</code>这个静态方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">jfieldID fis_fd; <span class=\"comment\">/* id for jobject 'fd' in java.io.FileInputStream */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL</div><div class=\"line\"><span class=\"title\">Java_java_io_FileInputStream_initIDs</span><span class=\"params\">(JNIEnv *env, jclass fdClass)</span> </span>&#123;</div><div class=\"line\">    fis_fd = (*env)-&gt;GetFieldID(env, fdClass, <span class=\"string\">\"fd\"</span>, <span class=\"string\">\"Ljava/io/FileDescriptor;\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在<code>FileInputStream</code>类加载阶段，<code>fis_fd</code>就被初始化了，<code>fid_fd</code>相当于是<code>FileInputStream.fd</code>字段的一个内存偏移量，便于在必要时操作内存给它赋值。</p>\n<p>看一下FileDescriptor的实例化过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"comment\">/**/ FileDescriptor() &#123;</div><div class=\"line\">        fd = -1;</div><div class=\"line\">        handle = -1;</div><div class=\"line\">        useCount = new AtomicInteger();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static &#123;</div><div class=\"line\">    initIDs();</div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure>\n<p>FileDescriptor也有一个<code>initIDs</code>，他和<code>FileInputStream.initIDs</code>的方法类似，把设置<code>IO_fd_fdID</code>为<code>FileDescriptor.fd</code>字段的内存偏移量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* field id for jint 'fd' in java.io.FileDescriptor */</span></div><div class=\"line\">jfieldID IO_fd_fdID;</div><div class=\"line\"><span class=\"comment\">/**************************************************************</div><div class=\"line\"> * static methods to store field ID's in initializers</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL</div><div class=\"line\"><span class=\"title\">Java_java_io_FileDescriptor_initIDs</span><span class=\"params\">(JNIEnv *env, jclass fdClass)</span> </span>&#123;</div><div class=\"line\">    IO_fd_fdID = (*env)-&gt;GetFieldID(env, fdClass, <span class=\"string\">\"fd\"</span>, <span class=\"string\">\"I\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来再看<code>FileInputStream</code>构造函数中的<code>open(name)</code>方法，字面上看，这个方法打开了一个文件，他也是一个本地方法，open方法直接调用了fileOpen方法，fileOpen方法如下:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">void fileOpen(JNIEnv *env, jobject this, jstring path, jfieldID fid, int flags)</div><div class=\"line\">&#123;</div><div class=\"line\">    WITH_PLATFORM_STRING(env, path, ps) &#123;</div><div class=\"line\">        FD fd;</div><div class=\"line\">#if defined(__linux__) || defined(_ALLBSD_SOURCE)</div><div class=\"line\">        /* Remove trailing slashes, since the kernel won't */</div><div class=\"line\">        char *p = (char *)ps + strlen(ps) - 1;</div><div class=\"line\">        while ((p &gt; ps) &amp;&amp; (*p == '/'))</div><div class=\"line\">            *p-- = '\\0';</div><div class=\"line\">#endif</div><div class=\"line\">        // 打开一个文件并获取到文件描述符</div><div class=\"line\">        fd = handleOpen(ps, flags, 0666);</div><div class=\"line\">        if (fd != -1) &#123;</div><div class=\"line\">            SET_FD(this, fd, fid);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            throwFileNotFoundException(env, path);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; END_PLATFORM_STRING(env, ps);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中的handleOpen函数打开了一个文件描述符，相当于和文件建立了联系，并且将返回的文件描述符描述符赋值给了局部变量fd,然后调用了SET_FD宏:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define SET_FD(this, fd, fid) \\</div><div class=\"line\">    if ((*env)-&gt;GetObjectField(env, (this), (fid)) != NULL) \\</div><div class=\"line\">        (*env)-&gt;SetIntField(env, (*env)-&gt;GetObjectField(env, (this), (fid)),IO_fd_fdID, (fd))</div></pre></td></tr></table></figure>\n<p>注意到<code>IO_fd_fdID</code>，他是<code>FileDescriptor.fd</code>字段的内存偏移量。这个方法相当于设置<code>FileDescriptor.fd</code>的值等于文件描述符fd。</p>\n<p>需要注意的是，FileDescriptor有两个字段：handle和fd，上面的代码表示我们只设置了fd字段为文件描述符，没有提到handle字段，这是因为：</p>\n<p>在 win32 的实现中将 创建好的 文件句柄 设置到 handle 字段，在 linux 版本中则使用的是 FileDescriptor 的 fd 字段。</p>\n<p>由此，可知 handle 和 fd 是共存的但并不同时在使用，在 win32 平台上使用 handle 字段，在 linux 平台上使用 fd 字段。</p>\n<p>所以，FileInputStream打开文件的过程总结如下：</p>\n<ul>\n<li>创建 FileDescriptor 对象</li>\n</ul>\n<p>每一个 FileInputStream 有一个 FileDescriptor，代表这个流底层的文件的fd</p>\n<ul>\n<li><p>调用 native 方法 open, 打开文件</p>\n</li>\n<li><p>内部调用 handleOpen 打开文件，返回文件描述符 fd</p>\n</li>\n</ul>\n<p>初始化 FileDescriptor 对象</p>\n<ul>\n<li>将 文件描述符 fd 设置到，FileDescriptor 对象的 fd 中</li>\n</ul>\n<h2 id=\"再谈java文件读取\"><a href=\"#再谈java文件读取\" class=\"headerlink\" title=\"再谈java文件读取\"></a>再谈java文件读取</h2><p>在<a href=\"http://yukai.space/2017/06/28/java-NIO-Buffer/\">java-NIO-Buffer</a>这篇文章中我们提到了<code>FileInputStream.read</code>方法，再来回顾一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">JNIEXPORT jint JNICALL  </div><div class=\"line\"><span class=\"title\">Java_java_io_FileInputStream_readBytes</span><span class=\"params\">(JNIEnv *env, jobject <span class=\"keyword\">this</span>,  </div><div class=\"line\">        jbyteArray bytes, jint off, jint len)</span> </span>&#123;<span class=\"comment\">//除了前两个参数，后三个就是readBytes方法传递进来的，字节数组、起始位置、长度三个参数  </span></div><div class=\"line\"><span class=\"keyword\">return</span> readBytes(env, <span class=\"keyword\">this</span>, bytes, off, len, fis_fd);  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">jint</div><div class=\"line\"><span class=\"title\">readBytes</span><span class=\"params\">(JNIEnv *env, jobject <span class=\"keyword\">this</span>, jbyteArray bytes,</div><div class=\"line\">          jint off, jint len, jfieldID fid)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    jint nread;</div><div class=\"line\">    <span class=\"keyword\">char</span> stackBuf[BUF_SIZE];</div><div class=\"line\">    <span class=\"keyword\">char</span> *buf = NULL;</div><div class=\"line\">    FD fd;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (IS_NULL(bytes)) &#123;</div><div class=\"line\">        JNU_ThrowNullPointerException(env, NULL);</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (outOfBounds(env, off, len, bytes)) &#123;</div><div class=\"line\">        JNU_ThrowByName(env, <span class=\"string\">\"java/lang/IndexOutOfBoundsException\"</span>, NULL);</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len &gt; BUF_SIZE) &#123;</div><div class=\"line\">        buf = malloc(len);<span class=\"comment\">// buf的分配</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (buf == NULL) &#123;</div><div class=\"line\">            JNU_ThrowOutOfMemoryError(env, NULL);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        buf = stackBuf;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    fd = GET_FD(<span class=\"keyword\">this</span>, fid);</div><div class=\"line\">    <span class=\"keyword\">if</span> (fd == -<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        JNU_ThrowIOException(env, <span class=\"string\">\"Stream Closed\"</span>);</div><div class=\"line\">        nread = -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        nread = IO_Read(fd, buf, len);<span class=\"comment\">// buf是使用malloc分配的直接缓冲区，也就是堆外内存</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (nread &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            (*env)-&gt;SetByteArrayRegion(env, bytes, off, nread, (jbyte *)buf);<span class=\"comment\">// 将直接缓冲区的内容copy到bytes数组中</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nread == JVM_IO_ERR) &#123;</div><div class=\"line\">            JNU_ThrowIOExceptionWithLastError(env, <span class=\"string\">\"Read error\"</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nread == JVM_IO_INTR) &#123;</div><div class=\"line\">            JNU_ThrowByName(env, <span class=\"string\">\"java/io/InterruptedIOException\"</span>, NULL);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* EOF */</span></div><div class=\"line\">            nread = -<span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (buf != stackBuf) &#123;</div><div class=\"line\">        free(buf);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> nread;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码中的<code>fis_fd</code>是不是很眼熟？他就是<code>FileInputStream.fd</code>字段的内存偏移量。注意到<code>fd = GET_FD(this, fid);</code>这个方法，获取到其对应的文件描述符，然后使用该文件描述符读取文件内容，填充缓冲区。由此可见，java底层读取文件都是通过文件描述符来进行的。比如：</p>\n<p>文章开始提到<strong>每个进程刚刚启动的时候，文件描述符0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3</strong>，FileDescriptor中的fd为0，1，2时也表示同样的意义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FileOutputStream fileOutputStream = <span class=\"keyword\">new</span> FileOutputStream(FileDescriptor.out);</div><div class=\"line\">fileOutputStream.write(<span class=\"string\">'hello world'</span>);<span class=\"comment\">// 控制台打印 hello world，因为fileOutputStream使用了标准输出的文件描述符</span></div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.csdn.net/kennyrose/article/details/7595013\">linux 文件描述符表 打开文件表 inode vnode</a></p>\n<p><a href=\"http://www.cnblogs.com/Jezze/archive/2011/12/23/2299861.html\">linux中文件描述符fd和文件指针flip的理解</a></p>\n<p><a href=\"https://vinoit.me/2016/09/14/JNI-explore-FileDescriptor-and-FileInputStream/\">JNI探秘–FileDescriptor、FileInputStream 解惑</a></p>"},{"layout":"post","date":"2017-02-21T04:48:55.000Z","title":"java日志框架的使用","_content":"\n> 之前在web项目中用到了日志，日志在web应用中很重要，特别是对于程序员追查bug而言。但是由于对混乱的日志框架体系不是十分清楚，导致各种jar包冲突和日志不正常输出。今天来总结一下日志框架的使用\n> 主要介绍日志门面slf4j结合日志实现log4j。关于其他的日志框架介绍和使用，参考链接里列出了前辈总结的很好的资料，相信读完之后一定会有收获。\n\n## 日志门面和实际日志框架\n\n日志框架有：jdk自带的logging(jul)，log4j1、log4j2、logback\n日志门面有：apache commons-logging、slf4j\n\n日志框架很好理解，就是提供日志api，使我们可以很轻易的，有组织有规范的输出日志。日志门面的作用是在日志记录实现的基础上提供一个封装的 API 层次，\n对日志记录 API 的使用者提供一个统一的接口，使得可以自由切换不同的日志记录实现。日志门面就好比java中的jdbc规范接口，各个数据库厂家实现的jdbc驱动程序就是实际的日志框架，\n他们遵循了这个规范，使得我们在编写java程序时不用考虑底层驱动的不同，只需调用jdbc规范接口即可。这是典型的面向对象思想。\n\n##  slf4j的使用\n\n### 简介\n\n![slf4j使用](https://www.slf4j.org/images/concrete-bindings.png)\n\n上图来自slf4j官网\n\n<!-- more -->\n\nslf4j-api.jar包含了slf4j的抽象层API，我们在代码中调用这个jar包中的接口。API层\n\nslf4j-log412.jar、slf4j-jdk14.jar等是slf4j通向具体日志实现框架的桥梁。中间层\n\nlog4j.jar等则是具体的日志实现框架。实现层\n\n\n>SLF4J does not rely on any special class loader machinery. In fact, each SLF4J binding is hardwired at compile time to use one and only one specific logging framework. For example, the slf4j-log4j12-1.7.23.jar binding is bound at compile time to use log4j. In your code, in addition to slf4j-api-1.7.23.jar, you simply drop one and only one binding of your choice onto the appropriate class path location. Do not place more than one binding on your class path. Here is a graphical illustration of the general idea.\n\n上面这段话的意思大概是，我们不应该在classpath中绑定多于一个的中间层，否则会导致jar包冲突或者输出混乱。\n\n>To switch logging frameworks, just replace slf4j bindings on your class path. For example, to switch from java.util.logging to log4j, just replace slf4j-jdk14-1.7.23.jar with slf4j-log4j12-1.7.23.jar.\n\n当我们需要将日志实现由jul切换到log4j时，仅仅把中间层替换，同时切换实现层即可，并不需要修改代码。这就是日志门面的好处。不过实际应用中，需要切换日志实现的场景貌似不是很多。\n\n### slf4j结合log4j\n\n#### 依赖\n\n需要的jar包：slf4j-api.jar、slf4j-log4j12.jar、log4j.jar\n\n对应的maven依赖：\n\n```\n<dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>slf4j-api</artifactId>\n    <version>1.7.23</version>\n</dependency>\n<dependency> \n  <groupId>org.slf4j</groupId>\n  <artifactId>slf4j-log4j12</artifactId>\n  <version>1.7.23</version>\n</dependency>\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n</dependency>\n```\n#### 使用\n\n编写log4j.properties配置文件，放到类路径下\n\n```\nlog4j.rootLogger=INFO,stdout\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.out\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n\n\n```\njava代码\n\n```\npackage space.kyu.LogTest.log4j;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Test {\n\tpublic static Logger logger = LoggerFactory.getLogger(Test.class);\n\t\n\tpublic void test() {\n\t\tlogger.info(\"info\");\n\t\tlogger.debug(\"debug\");\n\t\tlogger.warn(\"warn\");\n\t\tlogger.error(\"error\");\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Test().test();\n\t}\n}\n```\n输出\n\n```\n[INFO ] 2017-02-21 14:52:28,083 method:space.kyu.LogTest.log4j.Test.test(Test.java:10)\ninfo\n[WARN ] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:12)\nwarn\n[ERROR] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)\nerror\n```\n\n#### 原理\n\nslf4j-api.jar: org.slf4j.LoggerFactory\n```\n public static Logger getLogger(String name) {\n    ILoggerFactory iLoggerFactory = getILoggerFactory();\n     return iLoggerFactory.getLogger(name);\n }\n```\n可以看到，主要分为两部分，获取ILoggerFactory，使用ILoggerFactory获取logger.\n\nslf4j-api.jar: org.slf4j.LoggerFactory\n```\npublic static ILoggerFactory getILoggerFactory() {\n        if (INITIALIZATION_STATE == UNINITIALIZED) {\n            synchronized (LoggerFactory.class) {\n                if (INITIALIZATION_STATE == UNINITIALIZED) {\n                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n                    performInitialization();\n                }\n            }\n        }\n        switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return StaticLoggerBinder.getSingleton().getLoggerFactory();\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_FACTORY;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n        case ONGOING_INITIALIZATION:\n            // support re-entrant behavior.\n            // See also http://jira.qos.ch/browse/SLF4J-97\n            return SUBST_FACTORY;\n        }\n        throw new IllegalStateException(\"Unreachable code\");\n}\n```\n注意`return StaticLoggerBinder.getSingleton().getLoggerFactory();`这行，StaticLoggerBinder是slf4j-log4j12.jar中的类\n\nslf4j-log4j12.jar: org.slf4j.impl.StaticLoggerBinder\n```\nprivate StaticLoggerBinder() {\n        loggerFactory = new Log4jLoggerFactory();\n        try {\n            @SuppressWarnings(\"unused\")\n            Level level = Level.TRACE;\n        } catch (NoSuchFieldError nsfe) {\n            Util.report(\"This version of SLF4J requires log4j version 1.2.12 or later. See also http://www.slf4j.org/codes.html#log4j_version\");\n        }\n}\n\n```\nslf4j-log4j12.jar: org.slf4j.impl.Log4jLoggerFactory\n```\npublic Log4jLoggerFactory() {\n        loggerMap = new ConcurrentHashMap<String, Logger>();\n        // force log4j to initialize\n        org.apache.log4j.LogManager.getRootLogger();\n}\n```\n注意`org.apache.log4j.LogManager.getRootLogger();`初始化了log4j为具体的日志实现\n\n追踪源代码还可以发现，我们在代码中调用的`LoggerFactory.getLogger(Test.class);`最终返回的是org.apache.log4j.Logger实例，也就是说，日志实现最终托付给了log4j\n\n## log4j的使用\n\n### 日志组件\n\nLoggers：Logger负责捕捉事件并将其发送给合适的Appender。\n\nAppenders：也被称为Handlers，负责将日志事件记录到目标位置。在将日志事件输出之前，Appenders使用Layouts来对事件进行格式化处理。\n\nLayouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的最终形式。\n\n当Logger记录一个事件时，它将事件转发给适当的Appender。然后Appender使用Layout来对日志记录进行格式化，并将其发送给控制台、文件或者其它目标位置。\n\n### 日志级别\n\n每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：\n\norg.apache.log4j.Level\n```\n  public final static int OFF_INT = Integer.MAX_VALUE;\n  public final static int FATAL_INT = 50000;\n  public final static int ERROR_INT = 40000;\n  public final static int WARN_INT  = 30000;\n  public final static int INFO_INT  = 20000;\n  public final static int DEBUG_INT = 10000;\n    //public final static int FINE_INT = DEBUG_INT;\n  public final static int ALL_INT = Integer.MIN_VALUE;\n```\nA：off 最高等级，用于关闭所有日志记录。\n\nB：fatal 指出每个严重的错误事件将会导致应用程序的退出。\n\nC：error 指出虽然发生错误事件，但仍然不影响系统的继续运行。\n\nD：warm 表明会出现潜在的错误情形。\n\nE：info 一般和在粗粒度级别上，强调应用程序的运行全程。\n\nF：debug 一般用于细粒度级别上，对调试应用程序非常有帮助。\n\nG：all 最低等级，用于打开所有日志记录。\n\n我们一般只是用error,warn,info和debug就够了。\n\n### 配置文件编写\n\n了解了组件和日志级别，我们可以编写自己的配置文件，log4j.properties放到类路径下，如果缺少了配置文件，log4j会报错。我们也可以使用`PropertyConfigurator.configure ( String configFilename)`来指定配置文件\n\n#### 配置logger\n\n配置根logger：`log4j.rootLogger = [ level ] , appenderName, appenderName, …`\n\n比如：`log4j.rootLogger=INFO,stdout`\n\nlevel为日志级别，表示这个logger只打印级别大于等于level的日志。\n\nappenderName定义了如何处理日志，即把日志输出到哪个地方，如何输出。\n\n可以看出，一个logger可以根据appender同时输出到多个地方，logger与appender是一对多的关系。\n\n我们也可以定义自己的logger：`log4j.logger.yukai=DEBUG,stdout`\n\n#### 配置appender\n\nappender定义了日志输出的目的地：`log4j.appender.appenderName = fully.qualified.name.of.appender.class `\n\n其中，Log4j提供的常用的appender：\n\norg.apache.log4j.ConsoleAppender（控制台），\n\norg.apache.log4j.FileAppender（文件），\n\norg.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），\n\norg.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），\n\norg.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）\n\n我们还可以设置appender的属性，比如针对ConsoleAppender\n\n```\n属性\t                  描述\nlayout\t    Appender 使用 Layout 对象和与之关联的模式来格式化日志信息。\ntarget\t    目的地可以是控制台、文件，或依赖于 appender 的对象。\nlevel\t    级别用来控制过滤日志信息。\nthreshold\tAppender 可脱离于日志级别定义一个阀值级别，Appender 对象会忽略所有级别低于阀值级别的日志。\nfilter\t    Filter 对象可在级别基础之上分析日志信息，来决定 Appender 对象是否处理或忽略一条日志记录。\n```\n\n#### 配置layout\n\n一个appender可以关联某一个layout，用来格式化日志的输出。可用的layout有以下几种：\n\norg.apache.log4j.HTMLLayout（以HTML表格形式布局）， \n\norg.apache.log4j.PatternLayout（可以灵活地指定布局模式）， \n\norg.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， \n\norg.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）\n\n可用的格式：\n\n%m 输出代码中指定的消息 \n\n%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL \n\n%r 输出自应用启动到输出该log信息耗费的毫秒数 \n\n%c 输出所属的类目，通常就是所在类的全名 \n\n%t 输出产生该日志事件的线程名 \n\n%n 输出一个回车换行符，Windows平台为\"rn\"，Unix平台为\"n\" \n\n%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 \n\n%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(Test Log4.java:10)\n\n比如：\n\n```\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n\n```\n\n打印的信息：\n\n```\n[ERROR] 2017-02-21 16:41:25,563 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)\ninfo\n```\n\n#### logger的继承关系\n\n我们可以定义自己的logger：`log4j.logger.yukai=DEBUG,stdout`\n\n其中，yukai指定了这个logger的名字，可以在代码中使用它：\n\n```\npublic static Logger logger = LoggerFactory.getLogger(\"yukai\");\n```\n\n假如我们同时定义这样一个logger：`log4j.logger.yukai.child=DEBUG,stdout`\n\n就表示yukai.child这个logger继承了yukai这个logger，更java中的包有些类似\n\n在代码中使用：\n\n```\npublic static Logger logger = LoggerFactory.getLogger(\"yukai.child\");\n```\n\n使用了该logger会默认实现自身的设定和父Logger的设定。比如使用该logger打印了一条debug信息，同样的打印动作会执行两次，因为父logger的打印动作也会实现。\n\n上面提到的rootlogger就是所有looger的根logger。\n\n我们经常在代码中使用 `public static Logger logger = LoggerFactory.getLogger(Test.calss);`这样的方式，因此我们可以通过指定包名的logger来控制某个包下面所有的logger输出。比如：\n\n我们指定：`log4j.logger.space.kyu=DEBUG,stdout`,就表示space.kyu包下面的所有logger(以LoggerFactory.getLogger(Test.calss);这种方式获取的)都继承该logger的设定。这在分层的应用或功能性应用中有可以用到。\n\n可以通过配置log4j.additivity.XXX=ture/false来打开或关闭继承功能；若为 false,表示Logger 的 appender 不继承它的父Logger； 若为true，则继承，这样就兼有自身的设定和父Logger的设定。\n\n### MDC的使用\n\n> 在一个高访问量的 Web 应用中，经常要在同一时刻处理大量的用户请求。Web 服务器会为每一个请求分配一个线程，每一个线程都会向日志系统输入一些信息，通常日志系统都是按照时间顺序而不是用户顺序排列这些信息的，这些线程的交替运行会让所有用户的处理信息交错在一起，让人很难分辨出那些记录是同一个用户产生的。另外，高可用性的网站经常会使用负载均衡系统平衡网络流量，这样一个用户的操作记录很可能会分布在多个 Web 服务器上，如果我们没有一种方法来标示一条记录是哪个用户产生的，从这众多的日志信息中筛选出对我们有用的东西将是一项艰巨的工作。\n\nNDC或MDC就是用来解决这个问题的。\n\nMDC 可以看成是一个与当前线程绑定的哈希表，可以往其中添加键值对。\nMDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。\n当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。\n对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。\n\n```\npublic class App {\n\tprivate static final Logger logger = LoggerFactory.getLogger(App.class);\n\n\tpublic static void main(String[] args) {\n\t\tnew App().log(\"main thread\");\n\t\tnew Thread(){\n\t\t\tpublic void run() {\n\t\t\t\tnew App().log(\"sub thread\");\n\t\t\t};\n\t\t}.start();\n\t}\n\n\tpublic void log(String arg) {\n\t\tMDC.put(\"username\", \"Yukai\");\n\t\tlogger.info(\"This message from : {}\", arg);\n\t}\n}\n```\n\n设置appender: `log4j.appender.stdout.layout.ConversionPattern=%X{username} %d{yyyy-MM-dd HH:mm:ss} [%p] %c - %m%n`\n\n输出\n\nYukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : main thread\nYukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : sub thread\n\n## 参考\n\n[SLF4J user manual](https://www.slf4j.org/manual.html)\n\n[JDK Logging深入分析](http://blog.csdn.net/qingkangxu/article/details/7514770)\n\n[jdk-logging、log4j、logback日志介绍及原理](http://my.oschina.net/pingpangkuangmo/blog/406618)\n\n[commons-logging与jdk-logging、log4j1、log4j2、logback的集成原理](http://my.oschina.net/pingpangkuangmo/blog/407895)\n\n[slf4j与jdk-logging、log4j1、log4j2、logback的集成原理](http://my.oschina.net/pingpangkuangmo/blog/408382)\n\n[slf4j、jcl、jul、log4j1、log4j2、logback大总结](http://my.oschina.net/pingpangkuangmo/blog/410224)\n\n[Java 日志管理最佳实践](https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/)","source":"_posts/java日志使用.md","raw":"---\nlayout: post\ndate:   2017-02-21 12:48:55\ntitle:  \"java日志框架的使用\"\ncategories: 工具\ntags: \n- java\n---\n\n> 之前在web项目中用到了日志，日志在web应用中很重要，特别是对于程序员追查bug而言。但是由于对混乱的日志框架体系不是十分清楚，导致各种jar包冲突和日志不正常输出。今天来总结一下日志框架的使用\n> 主要介绍日志门面slf4j结合日志实现log4j。关于其他的日志框架介绍和使用，参考链接里列出了前辈总结的很好的资料，相信读完之后一定会有收获。\n\n## 日志门面和实际日志框架\n\n日志框架有：jdk自带的logging(jul)，log4j1、log4j2、logback\n日志门面有：apache commons-logging、slf4j\n\n日志框架很好理解，就是提供日志api，使我们可以很轻易的，有组织有规范的输出日志。日志门面的作用是在日志记录实现的基础上提供一个封装的 API 层次，\n对日志记录 API 的使用者提供一个统一的接口，使得可以自由切换不同的日志记录实现。日志门面就好比java中的jdbc规范接口，各个数据库厂家实现的jdbc驱动程序就是实际的日志框架，\n他们遵循了这个规范，使得我们在编写java程序时不用考虑底层驱动的不同，只需调用jdbc规范接口即可。这是典型的面向对象思想。\n\n##  slf4j的使用\n\n### 简介\n\n![slf4j使用](https://www.slf4j.org/images/concrete-bindings.png)\n\n上图来自slf4j官网\n\n<!-- more -->\n\nslf4j-api.jar包含了slf4j的抽象层API，我们在代码中调用这个jar包中的接口。API层\n\nslf4j-log412.jar、slf4j-jdk14.jar等是slf4j通向具体日志实现框架的桥梁。中间层\n\nlog4j.jar等则是具体的日志实现框架。实现层\n\n\n>SLF4J does not rely on any special class loader machinery. In fact, each SLF4J binding is hardwired at compile time to use one and only one specific logging framework. For example, the slf4j-log4j12-1.7.23.jar binding is bound at compile time to use log4j. In your code, in addition to slf4j-api-1.7.23.jar, you simply drop one and only one binding of your choice onto the appropriate class path location. Do not place more than one binding on your class path. Here is a graphical illustration of the general idea.\n\n上面这段话的意思大概是，我们不应该在classpath中绑定多于一个的中间层，否则会导致jar包冲突或者输出混乱。\n\n>To switch logging frameworks, just replace slf4j bindings on your class path. For example, to switch from java.util.logging to log4j, just replace slf4j-jdk14-1.7.23.jar with slf4j-log4j12-1.7.23.jar.\n\n当我们需要将日志实现由jul切换到log4j时，仅仅把中间层替换，同时切换实现层即可，并不需要修改代码。这就是日志门面的好处。不过实际应用中，需要切换日志实现的场景貌似不是很多。\n\n### slf4j结合log4j\n\n#### 依赖\n\n需要的jar包：slf4j-api.jar、slf4j-log4j12.jar、log4j.jar\n\n对应的maven依赖：\n\n```\n<dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>slf4j-api</artifactId>\n    <version>1.7.23</version>\n</dependency>\n<dependency> \n  <groupId>org.slf4j</groupId>\n  <artifactId>slf4j-log4j12</artifactId>\n  <version>1.7.23</version>\n</dependency>\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n</dependency>\n```\n#### 使用\n\n编写log4j.properties配置文件，放到类路径下\n\n```\nlog4j.rootLogger=INFO,stdout\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.out\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n\n\n```\njava代码\n\n```\npackage space.kyu.LogTest.log4j;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Test {\n\tpublic static Logger logger = LoggerFactory.getLogger(Test.class);\n\t\n\tpublic void test() {\n\t\tlogger.info(\"info\");\n\t\tlogger.debug(\"debug\");\n\t\tlogger.warn(\"warn\");\n\t\tlogger.error(\"error\");\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Test().test();\n\t}\n}\n```\n输出\n\n```\n[INFO ] 2017-02-21 14:52:28,083 method:space.kyu.LogTest.log4j.Test.test(Test.java:10)\ninfo\n[WARN ] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:12)\nwarn\n[ERROR] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)\nerror\n```\n\n#### 原理\n\nslf4j-api.jar: org.slf4j.LoggerFactory\n```\n public static Logger getLogger(String name) {\n    ILoggerFactory iLoggerFactory = getILoggerFactory();\n     return iLoggerFactory.getLogger(name);\n }\n```\n可以看到，主要分为两部分，获取ILoggerFactory，使用ILoggerFactory获取logger.\n\nslf4j-api.jar: org.slf4j.LoggerFactory\n```\npublic static ILoggerFactory getILoggerFactory() {\n        if (INITIALIZATION_STATE == UNINITIALIZED) {\n            synchronized (LoggerFactory.class) {\n                if (INITIALIZATION_STATE == UNINITIALIZED) {\n                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n                    performInitialization();\n                }\n            }\n        }\n        switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return StaticLoggerBinder.getSingleton().getLoggerFactory();\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_FACTORY;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);\n        case ONGOING_INITIALIZATION:\n            // support re-entrant behavior.\n            // See also http://jira.qos.ch/browse/SLF4J-97\n            return SUBST_FACTORY;\n        }\n        throw new IllegalStateException(\"Unreachable code\");\n}\n```\n注意`return StaticLoggerBinder.getSingleton().getLoggerFactory();`这行，StaticLoggerBinder是slf4j-log4j12.jar中的类\n\nslf4j-log4j12.jar: org.slf4j.impl.StaticLoggerBinder\n```\nprivate StaticLoggerBinder() {\n        loggerFactory = new Log4jLoggerFactory();\n        try {\n            @SuppressWarnings(\"unused\")\n            Level level = Level.TRACE;\n        } catch (NoSuchFieldError nsfe) {\n            Util.report(\"This version of SLF4J requires log4j version 1.2.12 or later. See also http://www.slf4j.org/codes.html#log4j_version\");\n        }\n}\n\n```\nslf4j-log4j12.jar: org.slf4j.impl.Log4jLoggerFactory\n```\npublic Log4jLoggerFactory() {\n        loggerMap = new ConcurrentHashMap<String, Logger>();\n        // force log4j to initialize\n        org.apache.log4j.LogManager.getRootLogger();\n}\n```\n注意`org.apache.log4j.LogManager.getRootLogger();`初始化了log4j为具体的日志实现\n\n追踪源代码还可以发现，我们在代码中调用的`LoggerFactory.getLogger(Test.class);`最终返回的是org.apache.log4j.Logger实例，也就是说，日志实现最终托付给了log4j\n\n## log4j的使用\n\n### 日志组件\n\nLoggers：Logger负责捕捉事件并将其发送给合适的Appender。\n\nAppenders：也被称为Handlers，负责将日志事件记录到目标位置。在将日志事件输出之前，Appenders使用Layouts来对事件进行格式化处理。\n\nLayouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的最终形式。\n\n当Logger记录一个事件时，它将事件转发给适当的Appender。然后Appender使用Layout来对日志记录进行格式化，并将其发送给控制台、文件或者其它目标位置。\n\n### 日志级别\n\n每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：\n\norg.apache.log4j.Level\n```\n  public final static int OFF_INT = Integer.MAX_VALUE;\n  public final static int FATAL_INT = 50000;\n  public final static int ERROR_INT = 40000;\n  public final static int WARN_INT  = 30000;\n  public final static int INFO_INT  = 20000;\n  public final static int DEBUG_INT = 10000;\n    //public final static int FINE_INT = DEBUG_INT;\n  public final static int ALL_INT = Integer.MIN_VALUE;\n```\nA：off 最高等级，用于关闭所有日志记录。\n\nB：fatal 指出每个严重的错误事件将会导致应用程序的退出。\n\nC：error 指出虽然发生错误事件，但仍然不影响系统的继续运行。\n\nD：warm 表明会出现潜在的错误情形。\n\nE：info 一般和在粗粒度级别上，强调应用程序的运行全程。\n\nF：debug 一般用于细粒度级别上，对调试应用程序非常有帮助。\n\nG：all 最低等级，用于打开所有日志记录。\n\n我们一般只是用error,warn,info和debug就够了。\n\n### 配置文件编写\n\n了解了组件和日志级别，我们可以编写自己的配置文件，log4j.properties放到类路径下，如果缺少了配置文件，log4j会报错。我们也可以使用`PropertyConfigurator.configure ( String configFilename)`来指定配置文件\n\n#### 配置logger\n\n配置根logger：`log4j.rootLogger = [ level ] , appenderName, appenderName, …`\n\n比如：`log4j.rootLogger=INFO,stdout`\n\nlevel为日志级别，表示这个logger只打印级别大于等于level的日志。\n\nappenderName定义了如何处理日志，即把日志输出到哪个地方，如何输出。\n\n可以看出，一个logger可以根据appender同时输出到多个地方，logger与appender是一对多的关系。\n\n我们也可以定义自己的logger：`log4j.logger.yukai=DEBUG,stdout`\n\n#### 配置appender\n\nappender定义了日志输出的目的地：`log4j.appender.appenderName = fully.qualified.name.of.appender.class `\n\n其中，Log4j提供的常用的appender：\n\norg.apache.log4j.ConsoleAppender（控制台），\n\norg.apache.log4j.FileAppender（文件），\n\norg.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），\n\norg.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），\n\norg.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）\n\n我们还可以设置appender的属性，比如针对ConsoleAppender\n\n```\n属性\t                  描述\nlayout\t    Appender 使用 Layout 对象和与之关联的模式来格式化日志信息。\ntarget\t    目的地可以是控制台、文件，或依赖于 appender 的对象。\nlevel\t    级别用来控制过滤日志信息。\nthreshold\tAppender 可脱离于日志级别定义一个阀值级别，Appender 对象会忽略所有级别低于阀值级别的日志。\nfilter\t    Filter 对象可在级别基础之上分析日志信息，来决定 Appender 对象是否处理或忽略一条日志记录。\n```\n\n#### 配置layout\n\n一个appender可以关联某一个layout，用来格式化日志的输出。可用的layout有以下几种：\n\norg.apache.log4j.HTMLLayout（以HTML表格形式布局）， \n\norg.apache.log4j.PatternLayout（可以灵活地指定布局模式）， \n\norg.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， \n\norg.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）\n\n可用的格式：\n\n%m 输出代码中指定的消息 \n\n%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL \n\n%r 输出自应用启动到输出该log信息耗费的毫秒数 \n\n%c 输出所属的类目，通常就是所在类的全名 \n\n%t 输出产生该日志事件的线程名 \n\n%n 输出一个回车换行符，Windows平台为\"rn\"，Unix平台为\"n\" \n\n%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 \n\n%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(Test Log4.java:10)\n\n比如：\n\n```\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n\n```\n\n打印的信息：\n\n```\n[ERROR] 2017-02-21 16:41:25,563 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)\ninfo\n```\n\n#### logger的继承关系\n\n我们可以定义自己的logger：`log4j.logger.yukai=DEBUG,stdout`\n\n其中，yukai指定了这个logger的名字，可以在代码中使用它：\n\n```\npublic static Logger logger = LoggerFactory.getLogger(\"yukai\");\n```\n\n假如我们同时定义这样一个logger：`log4j.logger.yukai.child=DEBUG,stdout`\n\n就表示yukai.child这个logger继承了yukai这个logger，更java中的包有些类似\n\n在代码中使用：\n\n```\npublic static Logger logger = LoggerFactory.getLogger(\"yukai.child\");\n```\n\n使用了该logger会默认实现自身的设定和父Logger的设定。比如使用该logger打印了一条debug信息，同样的打印动作会执行两次，因为父logger的打印动作也会实现。\n\n上面提到的rootlogger就是所有looger的根logger。\n\n我们经常在代码中使用 `public static Logger logger = LoggerFactory.getLogger(Test.calss);`这样的方式，因此我们可以通过指定包名的logger来控制某个包下面所有的logger输出。比如：\n\n我们指定：`log4j.logger.space.kyu=DEBUG,stdout`,就表示space.kyu包下面的所有logger(以LoggerFactory.getLogger(Test.calss);这种方式获取的)都继承该logger的设定。这在分层的应用或功能性应用中有可以用到。\n\n可以通过配置log4j.additivity.XXX=ture/false来打开或关闭继承功能；若为 false,表示Logger 的 appender 不继承它的父Logger； 若为true，则继承，这样就兼有自身的设定和父Logger的设定。\n\n### MDC的使用\n\n> 在一个高访问量的 Web 应用中，经常要在同一时刻处理大量的用户请求。Web 服务器会为每一个请求分配一个线程，每一个线程都会向日志系统输入一些信息，通常日志系统都是按照时间顺序而不是用户顺序排列这些信息的，这些线程的交替运行会让所有用户的处理信息交错在一起，让人很难分辨出那些记录是同一个用户产生的。另外，高可用性的网站经常会使用负载均衡系统平衡网络流量，这样一个用户的操作记录很可能会分布在多个 Web 服务器上，如果我们没有一种方法来标示一条记录是哪个用户产生的，从这众多的日志信息中筛选出对我们有用的东西将是一项艰巨的工作。\n\nNDC或MDC就是用来解决这个问题的。\n\nMDC 可以看成是一个与当前线程绑定的哈希表，可以往其中添加键值对。\nMDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。\n当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。\n对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。\n\n```\npublic class App {\n\tprivate static final Logger logger = LoggerFactory.getLogger(App.class);\n\n\tpublic static void main(String[] args) {\n\t\tnew App().log(\"main thread\");\n\t\tnew Thread(){\n\t\t\tpublic void run() {\n\t\t\t\tnew App().log(\"sub thread\");\n\t\t\t};\n\t\t}.start();\n\t}\n\n\tpublic void log(String arg) {\n\t\tMDC.put(\"username\", \"Yukai\");\n\t\tlogger.info(\"This message from : {}\", arg);\n\t}\n}\n```\n\n设置appender: `log4j.appender.stdout.layout.ConversionPattern=%X{username} %d{yyyy-MM-dd HH:mm:ss} [%p] %c - %m%n`\n\n输出\n\nYukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : main thread\nYukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : sub thread\n\n## 参考\n\n[SLF4J user manual](https://www.slf4j.org/manual.html)\n\n[JDK Logging深入分析](http://blog.csdn.net/qingkangxu/article/details/7514770)\n\n[jdk-logging、log4j、logback日志介绍及原理](http://my.oschina.net/pingpangkuangmo/blog/406618)\n\n[commons-logging与jdk-logging、log4j1、log4j2、logback的集成原理](http://my.oschina.net/pingpangkuangmo/blog/407895)\n\n[slf4j与jdk-logging、log4j1、log4j2、logback的集成原理](http://my.oschina.net/pingpangkuangmo/blog/408382)\n\n[slf4j、jcl、jul、log4j1、log4j2、logback大总结](http://my.oschina.net/pingpangkuangmo/blog/410224)\n\n[Java 日志管理最佳实践](https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/)","slug":"java日志使用","published":1,"updated":"2017-04-11T13:08:38.843Z","comments":1,"photos":[],"link":"","_id":"cj4vch4f0002fx3gct53d76kk","content":"<blockquote>\n<p>之前在web项目中用到了日志，日志在web应用中很重要，特别是对于程序员追查bug而言。但是由于对混乱的日志框架体系不是十分清楚，导致各种jar包冲突和日志不正常输出。今天来总结一下日志框架的使用<br>主要介绍日志门面slf4j结合日志实现log4j。关于其他的日志框架介绍和使用，参考链接里列出了前辈总结的很好的资料，相信读完之后一定会有收获。</p>\n</blockquote>\n<h2 id=\"日志门面和实际日志框架\"><a href=\"#日志门面和实际日志框架\" class=\"headerlink\" title=\"日志门面和实际日志框架\"></a>日志门面和实际日志框架</h2><p>日志框架有：jdk自带的logging(jul)，log4j1、log4j2、logback<br>日志门面有：apache commons-logging、slf4j</p>\n<p>日志框架很好理解，就是提供日志api，使我们可以很轻易的，有组织有规范的输出日志。日志门面的作用是在日志记录实现的基础上提供一个封装的 API 层次，<br>对日志记录 API 的使用者提供一个统一的接口，使得可以自由切换不同的日志记录实现。日志门面就好比java中的jdbc规范接口，各个数据库厂家实现的jdbc驱动程序就是实际的日志框架，<br>他们遵循了这个规范，使得我们在编写java程序时不用考虑底层驱动的不同，只需调用jdbc规范接口即可。这是典型的面向对象思想。</p>\n<h2 id=\"slf4j的使用\"><a href=\"#slf4j的使用\" class=\"headerlink\" title=\"slf4j的使用\"></a>slf4j的使用</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><img src=\"https://www.slf4j.org/images/concrete-bindings.png\" alt=\"slf4j使用\"></p>\n<p>上图来自slf4j官网</p>\n<a id=\"more\"></a>\n<p>slf4j-api.jar包含了slf4j的抽象层API，我们在代码中调用这个jar包中的接口。API层</p>\n<p>slf4j-log412.jar、slf4j-jdk14.jar等是slf4j通向具体日志实现框架的桥梁。中间层</p>\n<p>log4j.jar等则是具体的日志实现框架。实现层</p>\n<blockquote>\n<p>SLF4J does not rely on any special class loader machinery. In fact, each SLF4J binding is hardwired at compile time to use one and only one specific logging framework. For example, the slf4j-log4j12-1.7.23.jar binding is bound at compile time to use log4j. In your code, in addition to slf4j-api-1.7.23.jar, you simply drop one and only one binding of your choice onto the appropriate class path location. Do not place more than one binding on your class path. Here is a graphical illustration of the general idea.</p>\n</blockquote>\n<p>上面这段话的意思大概是，我们不应该在classpath中绑定多于一个的中间层，否则会导致jar包冲突或者输出混乱。</p>\n<blockquote>\n<p>To switch logging frameworks, just replace slf4j bindings on your class path. For example, to switch from java.util.logging to log4j, just replace slf4j-jdk14-1.7.23.jar with slf4j-log4j12-1.7.23.jar.</p>\n</blockquote>\n<p>当我们需要将日志实现由jul切换到log4j时，仅仅把中间层替换，同时切换实现层即可，并不需要修改代码。这就是日志门面的好处。不过实际应用中，需要切换日志实现的场景貌似不是很多。</p>\n<h3 id=\"slf4j结合log4j\"><a href=\"#slf4j结合log4j\" class=\"headerlink\" title=\"slf4j结合log4j\"></a>slf4j结合log4j</h3><h4 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h4><p>需要的jar包：slf4j-api.jar、slf4j-log4j12.jar、log4j.jar</p>\n<p>对应的maven依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;1.7.23&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div><div class=\"line\">&lt;dependency&gt; </div><div class=\"line\">  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class=\"line\">  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</div><div class=\"line\">  &lt;version&gt;1.7.23&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;log4j&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;1.2.17&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>编写log4j.properties配置文件，放到类路径下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">log4j.rootLogger=INFO,stdout</div><div class=\"line\"></div><div class=\"line\">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</div><div class=\"line\">log4j.appender.stdout.Target=System.out</div><div class=\"line\">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</div><div class=\"line\">log4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</div></pre></td></tr></table></figure>\n<p>java代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">package space.kyu.LogTest.log4j;</div><div class=\"line\"></div><div class=\"line\">import org.slf4j.Logger;</div><div class=\"line\">import org.slf4j.LoggerFactory;</div><div class=\"line\"></div><div class=\"line\">public class Test &#123;</div><div class=\"line\">\tpublic static Logger logger = LoggerFactory.getLogger(Test.class);</div><div class=\"line\">\t</div><div class=\"line\">\tpublic void test() &#123;</div><div class=\"line\">\t\tlogger.info(&quot;info&quot;);</div><div class=\"line\">\t\tlogger.debug(&quot;debug&quot;);</div><div class=\"line\">\t\tlogger.warn(&quot;warn&quot;);</div><div class=\"line\">\t\tlogger.error(&quot;error&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tnew Test().test();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[INFO ] 2017-02-21 14:52:28,083 method:space.kyu.LogTest.log4j.Test.test(Test.java:10)</div><div class=\"line\">info</div><div class=\"line\">[WARN ] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:12)</div><div class=\"line\">warn</div><div class=\"line\">[ERROR] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)</div><div class=\"line\">error</div></pre></td></tr></table></figure>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>slf4j-api.jar: org.slf4j.LoggerFactory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Logger getLogger(String name) &#123;</div><div class=\"line\">   ILoggerFactory iLoggerFactory = getILoggerFactory();</div><div class=\"line\">    return iLoggerFactory.getLogger(name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到，主要分为两部分，获取ILoggerFactory，使用ILoggerFactory获取logger.</p>\n<p>slf4j-api.jar: org.slf4j.LoggerFactory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static ILoggerFactory getILoggerFactory() &#123;</div><div class=\"line\">        if (INITIALIZATION_STATE == UNINITIALIZED) &#123;</div><div class=\"line\">            synchronized (LoggerFactory.class) &#123;</div><div class=\"line\">                if (INITIALIZATION_STATE == UNINITIALIZED) &#123;</div><div class=\"line\">                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;</div><div class=\"line\">                    performInitialization();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        switch (INITIALIZATION_STATE) &#123;</div><div class=\"line\">        case SUCCESSFUL_INITIALIZATION:</div><div class=\"line\">            return StaticLoggerBinder.getSingleton().getLoggerFactory();</div><div class=\"line\">        case NOP_FALLBACK_INITIALIZATION:</div><div class=\"line\">            return NOP_FALLBACK_FACTORY;</div><div class=\"line\">        case FAILED_INITIALIZATION:</div><div class=\"line\">            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);</div><div class=\"line\">        case ONGOING_INITIALIZATION:</div><div class=\"line\">            // support re-entrant behavior.</div><div class=\"line\">            // See also http://jira.qos.ch/browse/SLF4J-97</div><div class=\"line\">            return SUBST_FACTORY;</div><div class=\"line\">        &#125;</div><div class=\"line\">        throw new IllegalStateException(&quot;Unreachable code&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意<code>return StaticLoggerBinder.getSingleton().getLoggerFactory();</code>这行，StaticLoggerBinder是slf4j-log4j12.jar中的类</p>\n<p>slf4j-log4j12.jar: org.slf4j.impl.StaticLoggerBinder<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private StaticLoggerBinder() &#123;</div><div class=\"line\">        loggerFactory = new Log4jLoggerFactory();</div><div class=\"line\">        try &#123;</div><div class=\"line\">            @SuppressWarnings(&quot;unused&quot;)</div><div class=\"line\">            Level level = Level.TRACE;</div><div class=\"line\">        &#125; catch (NoSuchFieldError nsfe) &#123;</div><div class=\"line\">            Util.report(&quot;This version of SLF4J requires log4j version 1.2.12 or later. See also http://www.slf4j.org/codes.html#log4j_version&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>slf4j-log4j12.jar: org.slf4j.impl.Log4jLoggerFactory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Log4jLoggerFactory() &#123;</div><div class=\"line\">        loggerMap = new ConcurrentHashMap&lt;String, Logger&gt;();</div><div class=\"line\">        // force log4j to initialize</div><div class=\"line\">        org.apache.log4j.LogManager.getRootLogger();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意<code>org.apache.log4j.LogManager.getRootLogger();</code>初始化了log4j为具体的日志实现</p>\n<p>追踪源代码还可以发现，我们在代码中调用的<code>LoggerFactory.getLogger(Test.class);</code>最终返回的是org.apache.log4j.Logger实例，也就是说，日志实现最终托付给了log4j</p>\n<h2 id=\"log4j的使用\"><a href=\"#log4j的使用\" class=\"headerlink\" title=\"log4j的使用\"></a>log4j的使用</h2><h3 id=\"日志组件\"><a href=\"#日志组件\" class=\"headerlink\" title=\"日志组件\"></a>日志组件</h3><p>Loggers：Logger负责捕捉事件并将其发送给合适的Appender。</p>\n<p>Appenders：也被称为Handlers，负责将日志事件记录到目标位置。在将日志事件输出之前，Appenders使用Layouts来对事件进行格式化处理。</p>\n<p>Layouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的最终形式。</p>\n<p>当Logger记录一个事件时，它将事件转发给适当的Appender。然后Appender使用Layout来对日志记录进行格式化，并将其发送给控制台、文件或者其它目标位置。</p>\n<h3 id=\"日志级别\"><a href=\"#日志级别\" class=\"headerlink\" title=\"日志级别\"></a>日志级别</h3><p>每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：</p>\n<p>org.apache.log4j.Level<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final static int OFF_INT = Integer.MAX_VALUE;</div><div class=\"line\">public final static int FATAL_INT = 50000;</div><div class=\"line\">public final static int ERROR_INT = 40000;</div><div class=\"line\">public final static int WARN_INT  = 30000;</div><div class=\"line\">public final static int INFO_INT  = 20000;</div><div class=\"line\">public final static int DEBUG_INT = 10000;</div><div class=\"line\">  //public final static int FINE_INT = DEBUG_INT;</div><div class=\"line\">public final static int ALL_INT = Integer.MIN_VALUE;</div></pre></td></tr></table></figure></p>\n<p>A：off 最高等级，用于关闭所有日志记录。</p>\n<p>B：fatal 指出每个严重的错误事件将会导致应用程序的退出。</p>\n<p>C：error 指出虽然发生错误事件，但仍然不影响系统的继续运行。</p>\n<p>D：warm 表明会出现潜在的错误情形。</p>\n<p>E：info 一般和在粗粒度级别上，强调应用程序的运行全程。</p>\n<p>F：debug 一般用于细粒度级别上，对调试应用程序非常有帮助。</p>\n<p>G：all 最低等级，用于打开所有日志记录。</p>\n<p>我们一般只是用error,warn,info和debug就够了。</p>\n<h3 id=\"配置文件编写\"><a href=\"#配置文件编写\" class=\"headerlink\" title=\"配置文件编写\"></a>配置文件编写</h3><p>了解了组件和日志级别，我们可以编写自己的配置文件，log4j.properties放到类路径下，如果缺少了配置文件，log4j会报错。我们也可以使用<code>PropertyConfigurator.configure ( String configFilename)</code>来指定配置文件</p>\n<h4 id=\"配置logger\"><a href=\"#配置logger\" class=\"headerlink\" title=\"配置logger\"></a>配置logger</h4><p>配置根logger：<code>log4j.rootLogger = [ level ] , appenderName, appenderName, …</code></p>\n<p>比如：<code>log4j.rootLogger=INFO,stdout</code></p>\n<p>level为日志级别，表示这个logger只打印级别大于等于level的日志。</p>\n<p>appenderName定义了如何处理日志，即把日志输出到哪个地方，如何输出。</p>\n<p>可以看出，一个logger可以根据appender同时输出到多个地方，logger与appender是一对多的关系。</p>\n<p>我们也可以定义自己的logger：<code>log4j.logger.yukai=DEBUG,stdout</code></p>\n<h4 id=\"配置appender\"><a href=\"#配置appender\" class=\"headerlink\" title=\"配置appender\"></a>配置appender</h4><p>appender定义了日志输出的目的地：<code>log4j.appender.appenderName = fully.qualified.name.of.appender.class</code></p>\n<p>其中，Log4j提供的常用的appender：</p>\n<p>org.apache.log4j.ConsoleAppender（控制台），</p>\n<p>org.apache.log4j.FileAppender（文件），</p>\n<p>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</p>\n<p>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），</p>\n<p>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</p>\n<p>我们还可以设置appender的属性，比如针对ConsoleAppender</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">属性\t                  描述</div><div class=\"line\">layout\t    Appender 使用 Layout 对象和与之关联的模式来格式化日志信息。</div><div class=\"line\">target\t    目的地可以是控制台、文件，或依赖于 appender 的对象。</div><div class=\"line\">level\t    级别用来控制过滤日志信息。</div><div class=\"line\">threshold\tAppender 可脱离于日志级别定义一个阀值级别，Appender 对象会忽略所有级别低于阀值级别的日志。</div><div class=\"line\">filter\t    Filter 对象可在级别基础之上分析日志信息，来决定 Appender 对象是否处理或忽略一条日志记录。</div></pre></td></tr></table></figure>\n<h4 id=\"配置layout\"><a href=\"#配置layout\" class=\"headerlink\" title=\"配置layout\"></a>配置layout</h4><p>一个appender可以关联某一个layout，用来格式化日志的输出。可用的layout有以下几种：</p>\n<p>org.apache.log4j.HTMLLayout（以HTML表格形式布局）， </p>\n<p>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， </p>\n<p>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， </p>\n<p>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</p>\n<p>可用的格式：</p>\n<p>%m 输出代码中指定的消息 </p>\n<p>%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL </p>\n<p>%r 输出自应用启动到输出该log信息耗费的毫秒数 </p>\n<p>%c 输出所属的类目，通常就是所在类的全名 </p>\n<p>%t 输出产生该日志事件的线程名 </p>\n<p>%n 输出一个回车换行符，Windows平台为”rn”，Unix平台为”n” </p>\n<p>%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 </p>\n<p>%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(Test Log4.java:10)</p>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</div><div class=\"line\">log4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</div></pre></td></tr></table></figure>\n<p>打印的信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ERROR] 2017-02-21 16:41:25,563 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)</div><div class=\"line\">info</div></pre></td></tr></table></figure>\n<h4 id=\"logger的继承关系\"><a href=\"#logger的继承关系\" class=\"headerlink\" title=\"logger的继承关系\"></a>logger的继承关系</h4><p>我们可以定义自己的logger：<code>log4j.logger.yukai=DEBUG,stdout</code></p>\n<p>其中，yukai指定了这个logger的名字，可以在代码中使用它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Logger logger = LoggerFactory.getLogger(&quot;yukai&quot;);</div></pre></td></tr></table></figure>\n<p>假如我们同时定义这样一个logger：<code>log4j.logger.yukai.child=DEBUG,stdout</code></p>\n<p>就表示yukai.child这个logger继承了yukai这个logger，更java中的包有些类似</p>\n<p>在代码中使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Logger logger = LoggerFactory.getLogger(&quot;yukai.child&quot;);</div></pre></td></tr></table></figure>\n<p>使用了该logger会默认实现自身的设定和父Logger的设定。比如使用该logger打印了一条debug信息，同样的打印动作会执行两次，因为父logger的打印动作也会实现。</p>\n<p>上面提到的rootlogger就是所有looger的根logger。</p>\n<p>我们经常在代码中使用 <code>public static Logger logger = LoggerFactory.getLogger(Test.calss);</code>这样的方式，因此我们可以通过指定包名的logger来控制某个包下面所有的logger输出。比如：</p>\n<p>我们指定：<code>log4j.logger.space.kyu=DEBUG,stdout</code>,就表示space.kyu包下面的所有logger(以LoggerFactory.getLogger(Test.calss);这种方式获取的)都继承该logger的设定。这在分层的应用或功能性应用中有可以用到。</p>\n<p>可以通过配置log4j.additivity.XXX=ture/false来打开或关闭继承功能；若为 false,表示Logger 的 appender 不继承它的父Logger； 若为true，则继承，这样就兼有自身的设定和父Logger的设定。</p>\n<h3 id=\"MDC的使用\"><a href=\"#MDC的使用\" class=\"headerlink\" title=\"MDC的使用\"></a>MDC的使用</h3><blockquote>\n<p>在一个高访问量的 Web 应用中，经常要在同一时刻处理大量的用户请求。Web 服务器会为每一个请求分配一个线程，每一个线程都会向日志系统输入一些信息，通常日志系统都是按照时间顺序而不是用户顺序排列这些信息的，这些线程的交替运行会让所有用户的处理信息交错在一起，让人很难分辨出那些记录是同一个用户产生的。另外，高可用性的网站经常会使用负载均衡系统平衡网络流量，这样一个用户的操作记录很可能会分布在多个 Web 服务器上，如果我们没有一种方法来标示一条记录是哪个用户产生的，从这众多的日志信息中筛选出对我们有用的东西将是一项艰巨的工作。</p>\n</blockquote>\n<p>NDC或MDC就是用来解决这个问题的。</p>\n<p>MDC 可以看成是一个与当前线程绑定的哈希表，可以往其中添加键值对。<br>MDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。<br>当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。<br>对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class App &#123;</div><div class=\"line\">\tprivate static final Logger logger = LoggerFactory.getLogger(App.class);</div><div class=\"line\"></div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tnew App().log(&quot;main thread&quot;);</div><div class=\"line\">\t\tnew Thread()&#123;</div><div class=\"line\">\t\t\tpublic void run() &#123;</div><div class=\"line\">\t\t\t\tnew App().log(&quot;sub thread&quot;);</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t&#125;.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic void log(String arg) &#123;</div><div class=\"line\">\t\tMDC.put(&quot;username&quot;, &quot;Yukai&quot;);</div><div class=\"line\">\t\tlogger.info(&quot;This message from : &#123;&#125;&quot;, arg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>设置appender: <code>log4j.appender.stdout.layout.ConversionPattern=%X{username} %d{yyyy-MM-dd HH:mm:ss} [%p] %c - %m%n</code></p>\n<p>输出</p>\n<p>Yukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : main thread<br>Yukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : sub thread</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.slf4j.org/manual.html\" target=\"_blank\" rel=\"external\">SLF4J user manual</a></p>\n<p><a href=\"http://blog.csdn.net/qingkangxu/article/details/7514770\" target=\"_blank\" rel=\"external\">JDK Logging深入分析</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/406618\" target=\"_blank\" rel=\"external\">jdk-logging、log4j、logback日志介绍及原理</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/407895\" target=\"_blank\" rel=\"external\">commons-logging与jdk-logging、log4j1、log4j2、logback的集成原理</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/408382\" target=\"_blank\" rel=\"external\">slf4j与jdk-logging、log4j1、log4j2、logback的集成原理</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/410224\" target=\"_blank\" rel=\"external\">slf4j、jcl、jul、log4j1、log4j2、logback大总结</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/\" target=\"_blank\" rel=\"external\">Java 日志管理最佳实践</a></p>\n","excerpt":"<blockquote>\n<p>之前在web项目中用到了日志，日志在web应用中很重要，特别是对于程序员追查bug而言。但是由于对混乱的日志框架体系不是十分清楚，导致各种jar包冲突和日志不正常输出。今天来总结一下日志框架的使用<br>主要介绍日志门面slf4j结合日志实现log4j。关于其他的日志框架介绍和使用，参考链接里列出了前辈总结的很好的资料，相信读完之后一定会有收获。</p>\n</blockquote>\n<h2 id=\"日志门面和实际日志框架\"><a href=\"#日志门面和实际日志框架\" class=\"headerlink\" title=\"日志门面和实际日志框架\"></a>日志门面和实际日志框架</h2><p>日志框架有：jdk自带的logging(jul)，log4j1、log4j2、logback<br>日志门面有：apache commons-logging、slf4j</p>\n<p>日志框架很好理解，就是提供日志api，使我们可以很轻易的，有组织有规范的输出日志。日志门面的作用是在日志记录实现的基础上提供一个封装的 API 层次，<br>对日志记录 API 的使用者提供一个统一的接口，使得可以自由切换不同的日志记录实现。日志门面就好比java中的jdbc规范接口，各个数据库厂家实现的jdbc驱动程序就是实际的日志框架，<br>他们遵循了这个规范，使得我们在编写java程序时不用考虑底层驱动的不同，只需调用jdbc规范接口即可。这是典型的面向对象思想。</p>\n<h2 id=\"slf4j的使用\"><a href=\"#slf4j的使用\" class=\"headerlink\" title=\"slf4j的使用\"></a>slf4j的使用</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><img src=\"https://www.slf4j.org/images/concrete-bindings.png\" alt=\"slf4j使用\"></p>\n<p>上图来自slf4j官网</p>","more":"<p>slf4j-api.jar包含了slf4j的抽象层API，我们在代码中调用这个jar包中的接口。API层</p>\n<p>slf4j-log412.jar、slf4j-jdk14.jar等是slf4j通向具体日志实现框架的桥梁。中间层</p>\n<p>log4j.jar等则是具体的日志实现框架。实现层</p>\n<blockquote>\n<p>SLF4J does not rely on any special class loader machinery. In fact, each SLF4J binding is hardwired at compile time to use one and only one specific logging framework. For example, the slf4j-log4j12-1.7.23.jar binding is bound at compile time to use log4j. In your code, in addition to slf4j-api-1.7.23.jar, you simply drop one and only one binding of your choice onto the appropriate class path location. Do not place more than one binding on your class path. Here is a graphical illustration of the general idea.</p>\n</blockquote>\n<p>上面这段话的意思大概是，我们不应该在classpath中绑定多于一个的中间层，否则会导致jar包冲突或者输出混乱。</p>\n<blockquote>\n<p>To switch logging frameworks, just replace slf4j bindings on your class path. For example, to switch from java.util.logging to log4j, just replace slf4j-jdk14-1.7.23.jar with slf4j-log4j12-1.7.23.jar.</p>\n</blockquote>\n<p>当我们需要将日志实现由jul切换到log4j时，仅仅把中间层替换，同时切换实现层即可，并不需要修改代码。这就是日志门面的好处。不过实际应用中，需要切换日志实现的场景貌似不是很多。</p>\n<h3 id=\"slf4j结合log4j\"><a href=\"#slf4j结合log4j\" class=\"headerlink\" title=\"slf4j结合log4j\"></a>slf4j结合log4j</h3><h4 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h4><p>需要的jar包：slf4j-api.jar、slf4j-log4j12.jar、log4j.jar</p>\n<p>对应的maven依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;1.7.23&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div><div class=\"line\">&lt;dependency&gt; </div><div class=\"line\">  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class=\"line\">  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</div><div class=\"line\">  &lt;version&gt;1.7.23&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;log4j&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;1.2.17&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>编写log4j.properties配置文件，放到类路径下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">log4j.rootLogger=INFO,stdout</div><div class=\"line\"></div><div class=\"line\">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</div><div class=\"line\">log4j.appender.stdout.Target=System.out</div><div class=\"line\">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</div><div class=\"line\">log4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</div></pre></td></tr></table></figure>\n<p>java代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">package space.kyu.LogTest.log4j;</div><div class=\"line\"></div><div class=\"line\">import org.slf4j.Logger;</div><div class=\"line\">import org.slf4j.LoggerFactory;</div><div class=\"line\"></div><div class=\"line\">public class Test &#123;</div><div class=\"line\">\tpublic static Logger logger = LoggerFactory.getLogger(Test.class);</div><div class=\"line\">\t</div><div class=\"line\">\tpublic void test() &#123;</div><div class=\"line\">\t\tlogger.info(&quot;info&quot;);</div><div class=\"line\">\t\tlogger.debug(&quot;debug&quot;);</div><div class=\"line\">\t\tlogger.warn(&quot;warn&quot;);</div><div class=\"line\">\t\tlogger.error(&quot;error&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tnew Test().test();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[INFO ] 2017-02-21 14:52:28,083 method:space.kyu.LogTest.log4j.Test.test(Test.java:10)</div><div class=\"line\">info</div><div class=\"line\">[WARN ] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:12)</div><div class=\"line\">warn</div><div class=\"line\">[ERROR] 2017-02-21 14:52:28,085 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)</div><div class=\"line\">error</div></pre></td></tr></table></figure>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>slf4j-api.jar: org.slf4j.LoggerFactory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Logger getLogger(String name) &#123;</div><div class=\"line\">   ILoggerFactory iLoggerFactory = getILoggerFactory();</div><div class=\"line\">    return iLoggerFactory.getLogger(name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到，主要分为两部分，获取ILoggerFactory，使用ILoggerFactory获取logger.</p>\n<p>slf4j-api.jar: org.slf4j.LoggerFactory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static ILoggerFactory getILoggerFactory() &#123;</div><div class=\"line\">        if (INITIALIZATION_STATE == UNINITIALIZED) &#123;</div><div class=\"line\">            synchronized (LoggerFactory.class) &#123;</div><div class=\"line\">                if (INITIALIZATION_STATE == UNINITIALIZED) &#123;</div><div class=\"line\">                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;</div><div class=\"line\">                    performInitialization();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        switch (INITIALIZATION_STATE) &#123;</div><div class=\"line\">        case SUCCESSFUL_INITIALIZATION:</div><div class=\"line\">            return StaticLoggerBinder.getSingleton().getLoggerFactory();</div><div class=\"line\">        case NOP_FALLBACK_INITIALIZATION:</div><div class=\"line\">            return NOP_FALLBACK_FACTORY;</div><div class=\"line\">        case FAILED_INITIALIZATION:</div><div class=\"line\">            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);</div><div class=\"line\">        case ONGOING_INITIALIZATION:</div><div class=\"line\">            // support re-entrant behavior.</div><div class=\"line\">            // See also http://jira.qos.ch/browse/SLF4J-97</div><div class=\"line\">            return SUBST_FACTORY;</div><div class=\"line\">        &#125;</div><div class=\"line\">        throw new IllegalStateException(&quot;Unreachable code&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意<code>return StaticLoggerBinder.getSingleton().getLoggerFactory();</code>这行，StaticLoggerBinder是slf4j-log4j12.jar中的类</p>\n<p>slf4j-log4j12.jar: org.slf4j.impl.StaticLoggerBinder<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private StaticLoggerBinder() &#123;</div><div class=\"line\">        loggerFactory = new Log4jLoggerFactory();</div><div class=\"line\">        try &#123;</div><div class=\"line\">            @SuppressWarnings(&quot;unused&quot;)</div><div class=\"line\">            Level level = Level.TRACE;</div><div class=\"line\">        &#125; catch (NoSuchFieldError nsfe) &#123;</div><div class=\"line\">            Util.report(&quot;This version of SLF4J requires log4j version 1.2.12 or later. See also http://www.slf4j.org/codes.html#log4j_version&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>slf4j-log4j12.jar: org.slf4j.impl.Log4jLoggerFactory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Log4jLoggerFactory() &#123;</div><div class=\"line\">        loggerMap = new ConcurrentHashMap&lt;String, Logger&gt;();</div><div class=\"line\">        // force log4j to initialize</div><div class=\"line\">        org.apache.log4j.LogManager.getRootLogger();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意<code>org.apache.log4j.LogManager.getRootLogger();</code>初始化了log4j为具体的日志实现</p>\n<p>追踪源代码还可以发现，我们在代码中调用的<code>LoggerFactory.getLogger(Test.class);</code>最终返回的是org.apache.log4j.Logger实例，也就是说，日志实现最终托付给了log4j</p>\n<h2 id=\"log4j的使用\"><a href=\"#log4j的使用\" class=\"headerlink\" title=\"log4j的使用\"></a>log4j的使用</h2><h3 id=\"日志组件\"><a href=\"#日志组件\" class=\"headerlink\" title=\"日志组件\"></a>日志组件</h3><p>Loggers：Logger负责捕捉事件并将其发送给合适的Appender。</p>\n<p>Appenders：也被称为Handlers，负责将日志事件记录到目标位置。在将日志事件输出之前，Appenders使用Layouts来对事件进行格式化处理。</p>\n<p>Layouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的最终形式。</p>\n<p>当Logger记录一个事件时，它将事件转发给适当的Appender。然后Appender使用Layout来对日志记录进行格式化，并将其发送给控制台、文件或者其它目标位置。</p>\n<h3 id=\"日志级别\"><a href=\"#日志级别\" class=\"headerlink\" title=\"日志级别\"></a>日志级别</h3><p>每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：</p>\n<p>org.apache.log4j.Level<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final static int OFF_INT = Integer.MAX_VALUE;</div><div class=\"line\">public final static int FATAL_INT = 50000;</div><div class=\"line\">public final static int ERROR_INT = 40000;</div><div class=\"line\">public final static int WARN_INT  = 30000;</div><div class=\"line\">public final static int INFO_INT  = 20000;</div><div class=\"line\">public final static int DEBUG_INT = 10000;</div><div class=\"line\">  //public final static int FINE_INT = DEBUG_INT;</div><div class=\"line\">public final static int ALL_INT = Integer.MIN_VALUE;</div></pre></td></tr></table></figure></p>\n<p>A：off 最高等级，用于关闭所有日志记录。</p>\n<p>B：fatal 指出每个严重的错误事件将会导致应用程序的退出。</p>\n<p>C：error 指出虽然发生错误事件，但仍然不影响系统的继续运行。</p>\n<p>D：warm 表明会出现潜在的错误情形。</p>\n<p>E：info 一般和在粗粒度级别上，强调应用程序的运行全程。</p>\n<p>F：debug 一般用于细粒度级别上，对调试应用程序非常有帮助。</p>\n<p>G：all 最低等级，用于打开所有日志记录。</p>\n<p>我们一般只是用error,warn,info和debug就够了。</p>\n<h3 id=\"配置文件编写\"><a href=\"#配置文件编写\" class=\"headerlink\" title=\"配置文件编写\"></a>配置文件编写</h3><p>了解了组件和日志级别，我们可以编写自己的配置文件，log4j.properties放到类路径下，如果缺少了配置文件，log4j会报错。我们也可以使用<code>PropertyConfigurator.configure ( String configFilename)</code>来指定配置文件</p>\n<h4 id=\"配置logger\"><a href=\"#配置logger\" class=\"headerlink\" title=\"配置logger\"></a>配置logger</h4><p>配置根logger：<code>log4j.rootLogger = [ level ] , appenderName, appenderName, …</code></p>\n<p>比如：<code>log4j.rootLogger=INFO,stdout</code></p>\n<p>level为日志级别，表示这个logger只打印级别大于等于level的日志。</p>\n<p>appenderName定义了如何处理日志，即把日志输出到哪个地方，如何输出。</p>\n<p>可以看出，一个logger可以根据appender同时输出到多个地方，logger与appender是一对多的关系。</p>\n<p>我们也可以定义自己的logger：<code>log4j.logger.yukai=DEBUG,stdout</code></p>\n<h4 id=\"配置appender\"><a href=\"#配置appender\" class=\"headerlink\" title=\"配置appender\"></a>配置appender</h4><p>appender定义了日志输出的目的地：<code>log4j.appender.appenderName = fully.qualified.name.of.appender.class</code></p>\n<p>其中，Log4j提供的常用的appender：</p>\n<p>org.apache.log4j.ConsoleAppender（控制台），</p>\n<p>org.apache.log4j.FileAppender（文件），</p>\n<p>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</p>\n<p>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），</p>\n<p>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</p>\n<p>我们还可以设置appender的属性，比如针对ConsoleAppender</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">属性\t                  描述</div><div class=\"line\">layout\t    Appender 使用 Layout 对象和与之关联的模式来格式化日志信息。</div><div class=\"line\">target\t    目的地可以是控制台、文件，或依赖于 appender 的对象。</div><div class=\"line\">level\t    级别用来控制过滤日志信息。</div><div class=\"line\">threshold\tAppender 可脱离于日志级别定义一个阀值级别，Appender 对象会忽略所有级别低于阀值级别的日志。</div><div class=\"line\">filter\t    Filter 对象可在级别基础之上分析日志信息，来决定 Appender 对象是否处理或忽略一条日志记录。</div></pre></td></tr></table></figure>\n<h4 id=\"配置layout\"><a href=\"#配置layout\" class=\"headerlink\" title=\"配置layout\"></a>配置layout</h4><p>一个appender可以关联某一个layout，用来格式化日志的输出。可用的layout有以下几种：</p>\n<p>org.apache.log4j.HTMLLayout（以HTML表格形式布局）， </p>\n<p>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， </p>\n<p>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， </p>\n<p>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</p>\n<p>可用的格式：</p>\n<p>%m 输出代码中指定的消息 </p>\n<p>%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL </p>\n<p>%r 输出自应用启动到输出该log信息耗费的毫秒数 </p>\n<p>%c 输出所属的类目，通常就是所在类的全名 </p>\n<p>%t 输出产生该日志事件的线程名 </p>\n<p>%n 输出一个回车换行符，Windows平台为”rn”，Unix平台为”n” </p>\n<p>%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 </p>\n<p>%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(Test Log4.java:10)</p>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</div><div class=\"line\">log4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</div></pre></td></tr></table></figure>\n<p>打印的信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ERROR] 2017-02-21 16:41:25,563 method:space.kyu.LogTest.log4j.Test.test(Test.java:13)</div><div class=\"line\">info</div></pre></td></tr></table></figure>\n<h4 id=\"logger的继承关系\"><a href=\"#logger的继承关系\" class=\"headerlink\" title=\"logger的继承关系\"></a>logger的继承关系</h4><p>我们可以定义自己的logger：<code>log4j.logger.yukai=DEBUG,stdout</code></p>\n<p>其中，yukai指定了这个logger的名字，可以在代码中使用它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Logger logger = LoggerFactory.getLogger(&quot;yukai&quot;);</div></pre></td></tr></table></figure>\n<p>假如我们同时定义这样一个logger：<code>log4j.logger.yukai.child=DEBUG,stdout</code></p>\n<p>就表示yukai.child这个logger继承了yukai这个logger，更java中的包有些类似</p>\n<p>在代码中使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Logger logger = LoggerFactory.getLogger(&quot;yukai.child&quot;);</div></pre></td></tr></table></figure>\n<p>使用了该logger会默认实现自身的设定和父Logger的设定。比如使用该logger打印了一条debug信息，同样的打印动作会执行两次，因为父logger的打印动作也会实现。</p>\n<p>上面提到的rootlogger就是所有looger的根logger。</p>\n<p>我们经常在代码中使用 <code>public static Logger logger = LoggerFactory.getLogger(Test.calss);</code>这样的方式，因此我们可以通过指定包名的logger来控制某个包下面所有的logger输出。比如：</p>\n<p>我们指定：<code>log4j.logger.space.kyu=DEBUG,stdout</code>,就表示space.kyu包下面的所有logger(以LoggerFactory.getLogger(Test.calss);这种方式获取的)都继承该logger的设定。这在分层的应用或功能性应用中有可以用到。</p>\n<p>可以通过配置log4j.additivity.XXX=ture/false来打开或关闭继承功能；若为 false,表示Logger 的 appender 不继承它的父Logger； 若为true，则继承，这样就兼有自身的设定和父Logger的设定。</p>\n<h3 id=\"MDC的使用\"><a href=\"#MDC的使用\" class=\"headerlink\" title=\"MDC的使用\"></a>MDC的使用</h3><blockquote>\n<p>在一个高访问量的 Web 应用中，经常要在同一时刻处理大量的用户请求。Web 服务器会为每一个请求分配一个线程，每一个线程都会向日志系统输入一些信息，通常日志系统都是按照时间顺序而不是用户顺序排列这些信息的，这些线程的交替运行会让所有用户的处理信息交错在一起，让人很难分辨出那些记录是同一个用户产生的。另外，高可用性的网站经常会使用负载均衡系统平衡网络流量，这样一个用户的操作记录很可能会分布在多个 Web 服务器上，如果我们没有一种方法来标示一条记录是哪个用户产生的，从这众多的日志信息中筛选出对我们有用的东西将是一项艰巨的工作。</p>\n</blockquote>\n<p>NDC或MDC就是用来解决这个问题的。</p>\n<p>MDC 可以看成是一个与当前线程绑定的哈希表，可以往其中添加键值对。<br>MDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。<br>当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。<br>对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class App &#123;</div><div class=\"line\">\tprivate static final Logger logger = LoggerFactory.getLogger(App.class);</div><div class=\"line\"></div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tnew App().log(&quot;main thread&quot;);</div><div class=\"line\">\t\tnew Thread()&#123;</div><div class=\"line\">\t\t\tpublic void run() &#123;</div><div class=\"line\">\t\t\t\tnew App().log(&quot;sub thread&quot;);</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t&#125;.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic void log(String arg) &#123;</div><div class=\"line\">\t\tMDC.put(&quot;username&quot;, &quot;Yukai&quot;);</div><div class=\"line\">\t\tlogger.info(&quot;This message from : &#123;&#125;&quot;, arg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>设置appender: <code>log4j.appender.stdout.layout.ConversionPattern=%X{username} %d{yyyy-MM-dd HH:mm:ss} [%p] %c - %m%n</code></p>\n<p>输出</p>\n<p>Yukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : main thread<br>Yukai 2017-02-21 22:10:54 [INFO] space.kyu.log_test.App - This message from : sub thread</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.slf4j.org/manual.html\">SLF4J user manual</a></p>\n<p><a href=\"http://blog.csdn.net/qingkangxu/article/details/7514770\">JDK Logging深入分析</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/406618\">jdk-logging、log4j、logback日志介绍及原理</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/407895\">commons-logging与jdk-logging、log4j1、log4j2、logback的集成原理</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/408382\">slf4j与jdk-logging、log4j1、log4j2、logback的集成原理</a></p>\n<p><a href=\"http://my.oschina.net/pingpangkuangmo/blog/410224\">slf4j、jcl、jul、log4j1、log4j2、logback大总结</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/\">Java 日志管理最佳实践</a></p>"},{"layout":"post","title":"java I/O总结","date":"2017-03-19T09:09:19.000Z","_content":"> 在平时维护JDBC驱动的过程中，经常会接触到IO相关的代码。总结梳理一下java中的IO~\n\n## IO\n\nIO，即Input和Output。流可以理解为字节序列的流动，可以从其中读入字节序列的对象称为输入流，可以向其中写入字节序列的对象称为输出流。\n这些字节序列的来源和目的地可以是文件，网络，或者内存等。\n\njava中的IO基本可以分为两大类：\n\n1.基于字节操作的 I/O 接口：InputStream 和 OutputStream\n\n2.基于字符操作的 I/O 接口：Writer 和 Reader\n\n不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符。但是我们的程序通常操作的数据都是以字符的形式存在，比如处理网页中的内容或者磁盘文件中的文本。\n为了操作方便，提供了直接操作字符的接口。操作字符的接口底层还是基于字节的，只不过封装了一些例如编码和解码等操作。\n\n<!-- more -->\n\n下面是java.io包中的内容：[Package java.io](https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html)\n\n{% asset_img io.png java.io %}\n\njava.io 类图:\n\n{% asset_img javaio.png java.io %}\n\n## 字节接口\n\n{% asset_img stream.png 字节流 %}\n\n上图给出了InputStream和OutputStream的继承关系(不仅仅是java.io包)\n\n理解InputStream家族，首先要理解[装饰者模式](http://www.cnblogs.com/god_bless_you/archive/2010/06/10/1755212.html)：\n\n---\n{% asset_img decorator.jpg 装饰者模式 %}\n\n```\nComponent：\n\n定义一个对象接口，可以给这些对象动态地添加职责。\n\npublic interface Component\n{\n\tvoid operation();\n}\n \n\nConcrete Component：\n\n定义一个对象，可以给这个对象添加一些职责。动作的具体实施者。\n\npublic class ConcreteComponent implements Component\n{\n\tpublic void operation()\n\t{\n\t\t// Write your code here\n\t}\n}\n \n\nDecorator：\n\n维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。\n\npublic class Decorator implements Component\n{\n\tpublic Decorator(Component component)\n\t{\n\t\tthis.component = component;\n\t}\n\t\n\tpublic void operation()\n\t{\n\t\tcomponent.operation();\n\t}\n\t\n\tprivate Component component;\n}\n \n\nConcrete Decorator：\n\n在Concrete Component的行为之前或之后，加上自己的行为，以“贴上”附加的职责。\n\npublic class ConcreteDecorator extends Decorator\n{\n\tpublic void operation()\n\t{\n\t\t//addBehavior也可以在前面\n\t\t\n\t\tsuper.operation();\n\t\t\n\t\taddBehavior();\n\t}\n\t\n\tprivate void addBehavior()\n\t{\n\t\t//your code\n\t}\n}\n```\n使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。\n装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。\n\n---\n\nInputStream族与装饰者模式的对应关系：\n\nComponent: InputStream\n\nConcreteComponent: InputStream除FilterINputStream以外的直接子类，如FileInputStream，他们提供了最终的读取字节功能\n\nDecorator: FilterInputStream\n\nConcreteDecorator: FilterINputStream的直接子类，如BufferedInputStream，他们为读取字节附加了一些功能\n\n首先看一下InputStream为我们提供了哪些操作：\n\n```\nint\tavailable()\n返回不阻塞情况下可用的字节数\nvoid close()\n关闭这个输入流\nvoid mark(int readlimit)\n在流的当前位置打一个标记\nboolean\tmarkSupported()\n如果这个流支持打标记，则返回true\nabstract int read()\n从数据中读取一个字节，并返回该字节\nint\tread(byte[] b)\n读入一个字节数组，并返回读入的字节数\nint\tread(byte[] b, int off, int len)\n读入一个字节数组，并返回读入的字节数。b:数据读入的数组  off:第一个读入的字节在b中的偏移量  len:读入字节的最大数量\nvoid reset()\n返回最后的标记，随后对read的调用将重新读入这些字节\nlong skip(long n)\n在输入流中跳过n个字节，返回实际跳过数\n```\n\n其中：\nabstract int read()\nint\tread(byte[] b)\nint\tread(byte[] b, int off, int len)\n\n这三个方法提供了基本的读入功能。read方法在执行时将被阻塞，直到字节确实被读入。InputStream的子类实现或重写了这些方法的具体的操作，来完成对具体对象的读入功能。\n\n通过一个简单的例子来理解InputStream的组合过滤器功能。\n\n我们要从文件中读入数字，则首先必须有一个具体实现读取文件的FileInputStream实例： FileInputStream fin = new FileInputStream(\"test.dat\");\n\n流在默认情况下是不被缓冲区缓存的，也就是说，对于每一次的read的调用都会请求操作系统再分发一个字节。相比之下，一次请求一个数据块将其置于缓冲区显得更加高效。\n因此，我们为流添加缓冲功能，形成缓冲流： BufferedInputStream bin = new BufferedInputStream(fin);\n\ntest.dat文件中存储的是十进制数字的二进制序列。此时我们的流仅仅提供了读取字节序列的功能，为了实现将二进制序列转为十进制数字的功能，我们做进一步转换：\nDataInputStream din = new DataInputStream(bin);\n\n此时我们可以调用 din.readInt()方法依次读取文件中以二进制形式存储的十进制数字了。\n\n注意，我们将DataInputStream置于构造链的最后，这是因为我们最终希望使用DataInputStream的方法来读取十进制数字。\n\n观察一下上面提到的几个类的实现，就会对这种装饰者模式的工作机制有更加深刻的理解。理解了装饰者模式之后，再结合上面的类图，使用IO流就会更加得心应手。\n\n对于OutputStream，实现原理与InputStream是一样的，不再赘述。\n\n记录几个常用的stream：\n\nDataOutputStream: 将基本类型的数据以二进制流的形式写出\n\nDataInputStream: 将二进制流读入为基本类型数据\n\nObjectInputStream: 将Java对象以二进制流的形式写出 （序列化使用）\n\nObjectOutputStream: 将二进制流读入为java对象 （序列化时使用）\n\nPipedOutputStream和PipedInputStream分别是管道输出流和管道输入流，让多线程可以通过管道进行线程间的通讯\n\nZipOutputStream和ZipInputStream: 文件压缩与解压缩\n\nPushBackInputStream：回退流\n\n## 字符接口\n\n{% asset_img javaio2.bmp 字符流 %}\n\n在保存数据时，可以选择二进制格式保存或者文本格式保存。比如，整数12234可以存储成二进制，是由00 00 04 D2构成的字节序列。而存储成文本格式，则存储成为字符串“1234”。二进制格式的存储高效且节省空间，但是文本格式的存储方式更适宜人类阅读，应用也很广泛。\n\n与字节接口类似，字符接口族也是采用了装饰者模式的架构。\n\n在存储或读取文本字符串时，可以选择编码。比如：\n\nInputStreamReader reader = new InputStreamReader(new FileInputStream(\"test.dat\"),\"UTF-8\");\n\nreader将使用GBK编码读取文本test.dat的内容。如果构造器没有显示指定编码，将使用主机系统所使用的默认文字编码方式。\n\n与DataOutputStream对应，PrintWriter用来以文本的格式打印字符串和数字。\n\n与DataInputStream对应，可以使用Scanner类来读取文本格式的数据。\n\n## 字符集\n\n字符集规定了某个字符对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个字符（解码）的映射关系。\n\nJavaSE-1.4的java.nio包中引入了类Charset统一了对字符集的转换。\n\n{% asset_img decoder.jpg 字符集 %}\n\n{% asset_img encoder.jpg 字符集 %}\n\n通过观察InputStreamReader的源码（1.7），InputStreamReader 将字符的读取与解码委托给了类StreamDecoder实现。而在StreamDecoder中，又是通过传入的InputStream与指定的Charset配合完成了字节序列的读取和解码工作。\n\n可以通过调用静态的forName方法获取一个Charset：\n```\nCharset charset = Charset.forName(\"UTF-8\");\n```\n其中，传入的参数是某个字符集的官方名或者别名。\n\nSet<String> alias = charset.aliases(); //获取某个Charset的所有可用别名\nMap<String, Charset> charsets = Charset.availableCharsets(); //获取所用可用字符集的名字\n\n有了字符集Charset，就可以通过他将字节序列解码为字符序列或者将字符序列编码为字节序列：\n\n```\n//编码\nString str = \"hello\";\nByteBuffer bb = charset.encode(str);\nbyte[] bytes = bb.array();\n\n//解码\nbyte[] bytes = ....\nByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);\nCharBuffer cb = Charset.decode(bb);\nString str = cb.toString();\n```\n实际上，通过观察源码，得知InputStreamReader也是这么做的（还有String）。\n\n## 文件操作\n\nStream关心的是文件的内容，File类关心的是文件的存储。\n\n关于File的使用，网上有很多介绍，可以参考官网[Class File](https://docs.oracle.com/javase/7/docs/api/java/io/File.html)，不再赘述。\n\n要注意一个类RandomAccessFile，可以在文件的任何位置查找或者写入数据，RandomAccessFile同时实现了DataInput和DataOutput接口。\n\n我们可以使用RandomAccessFile随机读写的特性来完成大文件的上传或者下载。把文件分为n份，开启n个线程同时对这n个部分进行读写操作，提高了读写的效率。（让我想起了ConcurrentHashMap，分段锁的原理）同时，还具有了断点续传的功能。\n","source":"_posts/I-O总结.md","raw":"layout: post\ntitle: java I/O总结\ndate: 2017-03-19 17:09:19\ncategories: 编程\ntags: java io\n---\n> 在平时维护JDBC驱动的过程中，经常会接触到IO相关的代码。总结梳理一下java中的IO~\n\n## IO\n\nIO，即Input和Output。流可以理解为字节序列的流动，可以从其中读入字节序列的对象称为输入流，可以向其中写入字节序列的对象称为输出流。\n这些字节序列的来源和目的地可以是文件，网络，或者内存等。\n\njava中的IO基本可以分为两大类：\n\n1.基于字节操作的 I/O 接口：InputStream 和 OutputStream\n\n2.基于字符操作的 I/O 接口：Writer 和 Reader\n\n不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符。但是我们的程序通常操作的数据都是以字符的形式存在，比如处理网页中的内容或者磁盘文件中的文本。\n为了操作方便，提供了直接操作字符的接口。操作字符的接口底层还是基于字节的，只不过封装了一些例如编码和解码等操作。\n\n<!-- more -->\n\n下面是java.io包中的内容：[Package java.io](https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html)\n\n{% asset_img io.png java.io %}\n\njava.io 类图:\n\n{% asset_img javaio.png java.io %}\n\n## 字节接口\n\n{% asset_img stream.png 字节流 %}\n\n上图给出了InputStream和OutputStream的继承关系(不仅仅是java.io包)\n\n理解InputStream家族，首先要理解[装饰者模式](http://www.cnblogs.com/god_bless_you/archive/2010/06/10/1755212.html)：\n\n---\n{% asset_img decorator.jpg 装饰者模式 %}\n\n```\nComponent：\n\n定义一个对象接口，可以给这些对象动态地添加职责。\n\npublic interface Component\n{\n\tvoid operation();\n}\n \n\nConcrete Component：\n\n定义一个对象，可以给这个对象添加一些职责。动作的具体实施者。\n\npublic class ConcreteComponent implements Component\n{\n\tpublic void operation()\n\t{\n\t\t// Write your code here\n\t}\n}\n \n\nDecorator：\n\n维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。\n\npublic class Decorator implements Component\n{\n\tpublic Decorator(Component component)\n\t{\n\t\tthis.component = component;\n\t}\n\t\n\tpublic void operation()\n\t{\n\t\tcomponent.operation();\n\t}\n\t\n\tprivate Component component;\n}\n \n\nConcrete Decorator：\n\n在Concrete Component的行为之前或之后，加上自己的行为，以“贴上”附加的职责。\n\npublic class ConcreteDecorator extends Decorator\n{\n\tpublic void operation()\n\t{\n\t\t//addBehavior也可以在前面\n\t\t\n\t\tsuper.operation();\n\t\t\n\t\taddBehavior();\n\t}\n\t\n\tprivate void addBehavior()\n\t{\n\t\t//your code\n\t}\n}\n```\n使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。\n装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。\n\n---\n\nInputStream族与装饰者模式的对应关系：\n\nComponent: InputStream\n\nConcreteComponent: InputStream除FilterINputStream以外的直接子类，如FileInputStream，他们提供了最终的读取字节功能\n\nDecorator: FilterInputStream\n\nConcreteDecorator: FilterINputStream的直接子类，如BufferedInputStream，他们为读取字节附加了一些功能\n\n首先看一下InputStream为我们提供了哪些操作：\n\n```\nint\tavailable()\n返回不阻塞情况下可用的字节数\nvoid close()\n关闭这个输入流\nvoid mark(int readlimit)\n在流的当前位置打一个标记\nboolean\tmarkSupported()\n如果这个流支持打标记，则返回true\nabstract int read()\n从数据中读取一个字节，并返回该字节\nint\tread(byte[] b)\n读入一个字节数组，并返回读入的字节数\nint\tread(byte[] b, int off, int len)\n读入一个字节数组，并返回读入的字节数。b:数据读入的数组  off:第一个读入的字节在b中的偏移量  len:读入字节的最大数量\nvoid reset()\n返回最后的标记，随后对read的调用将重新读入这些字节\nlong skip(long n)\n在输入流中跳过n个字节，返回实际跳过数\n```\n\n其中：\nabstract int read()\nint\tread(byte[] b)\nint\tread(byte[] b, int off, int len)\n\n这三个方法提供了基本的读入功能。read方法在执行时将被阻塞，直到字节确实被读入。InputStream的子类实现或重写了这些方法的具体的操作，来完成对具体对象的读入功能。\n\n通过一个简单的例子来理解InputStream的组合过滤器功能。\n\n我们要从文件中读入数字，则首先必须有一个具体实现读取文件的FileInputStream实例： FileInputStream fin = new FileInputStream(\"test.dat\");\n\n流在默认情况下是不被缓冲区缓存的，也就是说，对于每一次的read的调用都会请求操作系统再分发一个字节。相比之下，一次请求一个数据块将其置于缓冲区显得更加高效。\n因此，我们为流添加缓冲功能，形成缓冲流： BufferedInputStream bin = new BufferedInputStream(fin);\n\ntest.dat文件中存储的是十进制数字的二进制序列。此时我们的流仅仅提供了读取字节序列的功能，为了实现将二进制序列转为十进制数字的功能，我们做进一步转换：\nDataInputStream din = new DataInputStream(bin);\n\n此时我们可以调用 din.readInt()方法依次读取文件中以二进制形式存储的十进制数字了。\n\n注意，我们将DataInputStream置于构造链的最后，这是因为我们最终希望使用DataInputStream的方法来读取十进制数字。\n\n观察一下上面提到的几个类的实现，就会对这种装饰者模式的工作机制有更加深刻的理解。理解了装饰者模式之后，再结合上面的类图，使用IO流就会更加得心应手。\n\n对于OutputStream，实现原理与InputStream是一样的，不再赘述。\n\n记录几个常用的stream：\n\nDataOutputStream: 将基本类型的数据以二进制流的形式写出\n\nDataInputStream: 将二进制流读入为基本类型数据\n\nObjectInputStream: 将Java对象以二进制流的形式写出 （序列化使用）\n\nObjectOutputStream: 将二进制流读入为java对象 （序列化时使用）\n\nPipedOutputStream和PipedInputStream分别是管道输出流和管道输入流，让多线程可以通过管道进行线程间的通讯\n\nZipOutputStream和ZipInputStream: 文件压缩与解压缩\n\nPushBackInputStream：回退流\n\n## 字符接口\n\n{% asset_img javaio2.bmp 字符流 %}\n\n在保存数据时，可以选择二进制格式保存或者文本格式保存。比如，整数12234可以存储成二进制，是由00 00 04 D2构成的字节序列。而存储成文本格式，则存储成为字符串“1234”。二进制格式的存储高效且节省空间，但是文本格式的存储方式更适宜人类阅读，应用也很广泛。\n\n与字节接口类似，字符接口族也是采用了装饰者模式的架构。\n\n在存储或读取文本字符串时，可以选择编码。比如：\n\nInputStreamReader reader = new InputStreamReader(new FileInputStream(\"test.dat\"),\"UTF-8\");\n\nreader将使用GBK编码读取文本test.dat的内容。如果构造器没有显示指定编码，将使用主机系统所使用的默认文字编码方式。\n\n与DataOutputStream对应，PrintWriter用来以文本的格式打印字符串和数字。\n\n与DataInputStream对应，可以使用Scanner类来读取文本格式的数据。\n\n## 字符集\n\n字符集规定了某个字符对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个字符（解码）的映射关系。\n\nJavaSE-1.4的java.nio包中引入了类Charset统一了对字符集的转换。\n\n{% asset_img decoder.jpg 字符集 %}\n\n{% asset_img encoder.jpg 字符集 %}\n\n通过观察InputStreamReader的源码（1.7），InputStreamReader 将字符的读取与解码委托给了类StreamDecoder实现。而在StreamDecoder中，又是通过传入的InputStream与指定的Charset配合完成了字节序列的读取和解码工作。\n\n可以通过调用静态的forName方法获取一个Charset：\n```\nCharset charset = Charset.forName(\"UTF-8\");\n```\n其中，传入的参数是某个字符集的官方名或者别名。\n\nSet<String> alias = charset.aliases(); //获取某个Charset的所有可用别名\nMap<String, Charset> charsets = Charset.availableCharsets(); //获取所用可用字符集的名字\n\n有了字符集Charset，就可以通过他将字节序列解码为字符序列或者将字符序列编码为字节序列：\n\n```\n//编码\nString str = \"hello\";\nByteBuffer bb = charset.encode(str);\nbyte[] bytes = bb.array();\n\n//解码\nbyte[] bytes = ....\nByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);\nCharBuffer cb = Charset.decode(bb);\nString str = cb.toString();\n```\n实际上，通过观察源码，得知InputStreamReader也是这么做的（还有String）。\n\n## 文件操作\n\nStream关心的是文件的内容，File类关心的是文件的存储。\n\n关于File的使用，网上有很多介绍，可以参考官网[Class File](https://docs.oracle.com/javase/7/docs/api/java/io/File.html)，不再赘述。\n\n要注意一个类RandomAccessFile，可以在文件的任何位置查找或者写入数据，RandomAccessFile同时实现了DataInput和DataOutput接口。\n\n我们可以使用RandomAccessFile随机读写的特性来完成大文件的上传或者下载。把文件分为n份，开启n个线程同时对这n个部分进行读写操作，提高了读写的效率。（让我想起了ConcurrentHashMap，分段锁的原理）同时，还具有了断点续传的功能。\n","slug":"I-O总结","published":1,"updated":"2017-04-11T13:08:38.820Z","comments":1,"photos":[],"link":"","_id":"cj4vch4f3002ix3gc4oguy8zc","content":"<blockquote>\n<p>在平时维护JDBC驱动的过程中，经常会接触到IO相关的代码。总结梳理一下java中的IO~</p>\n</blockquote>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><p>IO，即Input和Output。流可以理解为字节序列的流动，可以从其中读入字节序列的对象称为输入流，可以向其中写入字节序列的对象称为输出流。<br>这些字节序列的来源和目的地可以是文件，网络，或者内存等。</p>\n<p>java中的IO基本可以分为两大类：</p>\n<p>1.基于字节操作的 I/O 接口：InputStream 和 OutputStream</p>\n<p>2.基于字符操作的 I/O 接口：Writer 和 Reader</p>\n<p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符。但是我们的程序通常操作的数据都是以字符的形式存在，比如处理网页中的内容或者磁盘文件中的文本。<br>为了操作方便，提供了直接操作字符的接口。操作字符的接口底层还是基于字节的，只不过封装了一些例如编码和解码等操作。</p>\n<a id=\"more\"></a>\n<p>下面是java.io包中的内容：<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html\" target=\"_blank\" rel=\"external\">Package java.io</a></p>\n<img src=\"/2017/03/19/I-O总结/io.png\" alt=\"java.io\" title=\"java.io\">\n<p>java.io 类图:</p>\n<img src=\"/2017/03/19/I-O总结/javaio.png\" alt=\"java.io\" title=\"java.io\">\n<h2 id=\"字节接口\"><a href=\"#字节接口\" class=\"headerlink\" title=\"字节接口\"></a>字节接口</h2><img src=\"/2017/03/19/I-O总结/stream.png\" alt=\"字节流\" title=\"字节流\">\n<p>上图给出了InputStream和OutputStream的继承关系(不仅仅是java.io包)</p>\n<p>理解InputStream家族，首先要理解<a href=\"http://www.cnblogs.com/god_bless_you/archive/2010/06/10/1755212.html\" target=\"_blank\" rel=\"external\">装饰者模式</a>：</p>\n<hr>\n<img src=\"/2017/03/19/I-O总结/decorator.jpg\" alt=\"装饰者模式\" title=\"装饰者模式\">\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">Component：</div><div class=\"line\"></div><div class=\"line\">定义一个对象接口，可以给这些对象动态地添加职责。</div><div class=\"line\"></div><div class=\"line\">public interface Component</div><div class=\"line\">&#123;</div><div class=\"line\">\tvoid operation();</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">Concrete Component：</div><div class=\"line\"></div><div class=\"line\">定义一个对象，可以给这个对象添加一些职责。动作的具体实施者。</div><div class=\"line\"></div><div class=\"line\">public class ConcreteComponent implements Component</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic void operation()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t// Write your code here</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">Decorator：</div><div class=\"line\"></div><div class=\"line\">维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。</div><div class=\"line\"></div><div class=\"line\">public class Decorator implements Component</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic Decorator(Component component)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tthis.component = component;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic void operation()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tcomponent.operation();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tprivate Component component;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">Concrete Decorator：</div><div class=\"line\"></div><div class=\"line\">在Concrete Component的行为之前或之后，加上自己的行为，以“贴上”附加的职责。</div><div class=\"line\"></div><div class=\"line\">public class ConcreteDecorator extends Decorator</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic void operation()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t//addBehavior也可以在前面</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsuper.operation();</div><div class=\"line\">\t\t</div><div class=\"line\">\t\taddBehavior();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tprivate void addBehavior()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t//your code</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。<br>装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</p>\n<hr>\n<p>InputStream族与装饰者模式的对应关系：</p>\n<p>Component: InputStream</p>\n<p>ConcreteComponent: InputStream除FilterINputStream以外的直接子类，如FileInputStream，他们提供了最终的读取字节功能</p>\n<p>Decorator: FilterInputStream</p>\n<p>ConcreteDecorator: FilterINputStream的直接子类，如BufferedInputStream，他们为读取字节附加了一些功能</p>\n<p>首先看一下InputStream为我们提供了哪些操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">int\tavailable()</div><div class=\"line\">返回不阻塞情况下可用的字节数</div><div class=\"line\">void close()</div><div class=\"line\">关闭这个输入流</div><div class=\"line\">void mark(int readlimit)</div><div class=\"line\">在流的当前位置打一个标记</div><div class=\"line\">boolean\tmarkSupported()</div><div class=\"line\">如果这个流支持打标记，则返回true</div><div class=\"line\">abstract int read()</div><div class=\"line\">从数据中读取一个字节，并返回该字节</div><div class=\"line\">int\tread(byte[] b)</div><div class=\"line\">读入一个字节数组，并返回读入的字节数</div><div class=\"line\">int\tread(byte[] b, int off, int len)</div><div class=\"line\">读入一个字节数组，并返回读入的字节数。b:数据读入的数组  off:第一个读入的字节在b中的偏移量  len:读入字节的最大数量</div><div class=\"line\">void reset()</div><div class=\"line\">返回最后的标记，随后对read的调用将重新读入这些字节</div><div class=\"line\">long skip(long n)</div><div class=\"line\">在输入流中跳过n个字节，返回实际跳过数</div></pre></td></tr></table></figure>\n<p>其中：<br>abstract int read()<br>int    read(byte[] b)<br>int    read(byte[] b, int off, int len)</p>\n<p>这三个方法提供了基本的读入功能。read方法在执行时将被阻塞，直到字节确实被读入。InputStream的子类实现或重写了这些方法的具体的操作，来完成对具体对象的读入功能。</p>\n<p>通过一个简单的例子来理解InputStream的组合过滤器功能。</p>\n<p>我们要从文件中读入数字，则首先必须有一个具体实现读取文件的FileInputStream实例： FileInputStream fin = new FileInputStream(“test.dat”);</p>\n<p>流在默认情况下是不被缓冲区缓存的，也就是说，对于每一次的read的调用都会请求操作系统再分发一个字节。相比之下，一次请求一个数据块将其置于缓冲区显得更加高效。<br>因此，我们为流添加缓冲功能，形成缓冲流： BufferedInputStream bin = new BufferedInputStream(fin);</p>\n<p>test.dat文件中存储的是十进制数字的二进制序列。此时我们的流仅仅提供了读取字节序列的功能，为了实现将二进制序列转为十进制数字的功能，我们做进一步转换：<br>DataInputStream din = new DataInputStream(bin);</p>\n<p>此时我们可以调用 din.readInt()方法依次读取文件中以二进制形式存储的十进制数字了。</p>\n<p>注意，我们将DataInputStream置于构造链的最后，这是因为我们最终希望使用DataInputStream的方法来读取十进制数字。</p>\n<p>观察一下上面提到的几个类的实现，就会对这种装饰者模式的工作机制有更加深刻的理解。理解了装饰者模式之后，再结合上面的类图，使用IO流就会更加得心应手。</p>\n<p>对于OutputStream，实现原理与InputStream是一样的，不再赘述。</p>\n<p>记录几个常用的stream：</p>\n<p>DataOutputStream: 将基本类型的数据以二进制流的形式写出</p>\n<p>DataInputStream: 将二进制流读入为基本类型数据</p>\n<p>ObjectInputStream: 将Java对象以二进制流的形式写出 （序列化使用）</p>\n<p>ObjectOutputStream: 将二进制流读入为java对象 （序列化时使用）</p>\n<p>PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流，让多线程可以通过管道进行线程间的通讯</p>\n<p>ZipOutputStream和ZipInputStream: 文件压缩与解压缩</p>\n<p>PushBackInputStream：回退流</p>\n<h2 id=\"字符接口\"><a href=\"#字符接口\" class=\"headerlink\" title=\"字符接口\"></a>字符接口</h2><img src=\"/2017/03/19/I-O总结/javaio2.bmp\" alt=\"字符流\" title=\"字符流\">\n<p>在保存数据时，可以选择二进制格式保存或者文本格式保存。比如，整数12234可以存储成二进制，是由00 00 04 D2构成的字节序列。而存储成文本格式，则存储成为字符串“1234”。二进制格式的存储高效且节省空间，但是文本格式的存储方式更适宜人类阅读，应用也很广泛。</p>\n<p>与字节接口类似，字符接口族也是采用了装饰者模式的架构。</p>\n<p>在存储或读取文本字符串时，可以选择编码。比如：</p>\n<p>InputStreamReader reader = new InputStreamReader(new FileInputStream(“test.dat”),”UTF-8”);</p>\n<p>reader将使用GBK编码读取文本test.dat的内容。如果构造器没有显示指定编码，将使用主机系统所使用的默认文字编码方式。</p>\n<p>与DataOutputStream对应，PrintWriter用来以文本的格式打印字符串和数字。</p>\n<p>与DataInputStream对应，可以使用Scanner类来读取文本格式的数据。</p>\n<h2 id=\"字符集\"><a href=\"#字符集\" class=\"headerlink\" title=\"字符集\"></a>字符集</h2><p>字符集规定了某个字符对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个字符（解码）的映射关系。</p>\n<p>JavaSE-1.4的java.nio包中引入了类Charset统一了对字符集的转换。</p>\n<img src=\"/2017/03/19/I-O总结/decoder.jpg\" alt=\"字符集\" title=\"字符集\">\n<img src=\"/2017/03/19/I-O总结/encoder.jpg\" alt=\"字符集\" title=\"字符集\">\n<p>通过观察InputStreamReader的源码（1.7），InputStreamReader 将字符的读取与解码委托给了类StreamDecoder实现。而在StreamDecoder中，又是通过传入的InputStream与指定的Charset配合完成了字节序列的读取和解码工作。</p>\n<p>可以通过调用静态的forName方法获取一个Charset：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(&quot;UTF-8&quot;);</div></pre></td></tr></table></figure></p>\n<p>其中，传入的参数是某个字符集的官方名或者别名。</p>\n<p>Set<string> alias = charset.aliases(); //获取某个Charset的所有可用别名<br>Map<string, charset=\"\"> charsets = Charset.availableCharsets(); //获取所用可用字符集的名字</string,></string></p>\n<p>有了字符集Charset，就可以通过他将字节序列解码为字符序列或者将字符序列编码为字节序列：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//编码</div><div class=\"line\">String str = &quot;hello&quot;;</div><div class=\"line\">ByteBuffer bb = charset.encode(str);</div><div class=\"line\">byte[] bytes = bb.array();</div><div class=\"line\"></div><div class=\"line\">//解码</div><div class=\"line\">byte[] bytes = ....</div><div class=\"line\">ByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);</div><div class=\"line\">CharBuffer cb = Charset.decode(bb);</div><div class=\"line\">String str = cb.toString();</div></pre></td></tr></table></figure>\n<p>实际上，通过观察源码，得知InputStreamReader也是这么做的（还有String）。</p>\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><p>Stream关心的是文件的内容，File类关心的是文件的存储。</p>\n<p>关于File的使用，网上有很多介绍，可以参考官网<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/File.html\" target=\"_blank\" rel=\"external\">Class File</a>，不再赘述。</p>\n<p>要注意一个类RandomAccessFile，可以在文件的任何位置查找或者写入数据，RandomAccessFile同时实现了DataInput和DataOutput接口。</p>\n<p>我们可以使用RandomAccessFile随机读写的特性来完成大文件的上传或者下载。把文件分为n份，开启n个线程同时对这n个部分进行读写操作，提高了读写的效率。（让我想起了ConcurrentHashMap，分段锁的原理）同时，还具有了断点续传的功能。</p>\n","excerpt":"<blockquote>\n<p>在平时维护JDBC驱动的过程中，经常会接触到IO相关的代码。总结梳理一下java中的IO~</p>\n</blockquote>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><p>IO，即Input和Output。流可以理解为字节序列的流动，可以从其中读入字节序列的对象称为输入流，可以向其中写入字节序列的对象称为输出流。<br>这些字节序列的来源和目的地可以是文件，网络，或者内存等。</p>\n<p>java中的IO基本可以分为两大类：</p>\n<p>1.基于字节操作的 I/O 接口：InputStream 和 OutputStream</p>\n<p>2.基于字符操作的 I/O 接口：Writer 和 Reader</p>\n<p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符。但是我们的程序通常操作的数据都是以字符的形式存在，比如处理网页中的内容或者磁盘文件中的文本。<br>为了操作方便，提供了直接操作字符的接口。操作字符的接口底层还是基于字节的，只不过封装了一些例如编码和解码等操作。</p>","more":"<p>下面是java.io包中的内容：<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html\">Package java.io</a></p>\n<img src=\"/2017/03/19/I-O总结/io.png\" alt=\"java.io\" title=\"java.io\">\n<p>java.io 类图:</p>\n<img src=\"/2017/03/19/I-O总结/javaio.png\" alt=\"java.io\" title=\"java.io\">\n<h2 id=\"字节接口\"><a href=\"#字节接口\" class=\"headerlink\" title=\"字节接口\"></a>字节接口</h2><img src=\"/2017/03/19/I-O总结/stream.png\" alt=\"字节流\" title=\"字节流\">\n<p>上图给出了InputStream和OutputStream的继承关系(不仅仅是java.io包)</p>\n<p>理解InputStream家族，首先要理解<a href=\"http://www.cnblogs.com/god_bless_you/archive/2010/06/10/1755212.html\">装饰者模式</a>：</p>\n<hr>\n<img src=\"/2017/03/19/I-O总结/decorator.jpg\" alt=\"装饰者模式\" title=\"装饰者模式\">\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">Component：</div><div class=\"line\"></div><div class=\"line\">定义一个对象接口，可以给这些对象动态地添加职责。</div><div class=\"line\"></div><div class=\"line\">public interface Component</div><div class=\"line\">&#123;</div><div class=\"line\">\tvoid operation();</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">Concrete Component：</div><div class=\"line\"></div><div class=\"line\">定义一个对象，可以给这个对象添加一些职责。动作的具体实施者。</div><div class=\"line\"></div><div class=\"line\">public class ConcreteComponent implements Component</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic void operation()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t// Write your code here</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">Decorator：</div><div class=\"line\"></div><div class=\"line\">维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。</div><div class=\"line\"></div><div class=\"line\">public class Decorator implements Component</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic Decorator(Component component)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tthis.component = component;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic void operation()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tcomponent.operation();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tprivate Component component;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">Concrete Decorator：</div><div class=\"line\"></div><div class=\"line\">在Concrete Component的行为之前或之后，加上自己的行为，以“贴上”附加的职责。</div><div class=\"line\"></div><div class=\"line\">public class ConcreteDecorator extends Decorator</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic void operation()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t//addBehavior也可以在前面</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsuper.operation();</div><div class=\"line\">\t\t</div><div class=\"line\">\t\taddBehavior();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tprivate void addBehavior()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t//your code</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。<br>装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</p>\n<hr>\n<p>InputStream族与装饰者模式的对应关系：</p>\n<p>Component: InputStream</p>\n<p>ConcreteComponent: InputStream除FilterINputStream以外的直接子类，如FileInputStream，他们提供了最终的读取字节功能</p>\n<p>Decorator: FilterInputStream</p>\n<p>ConcreteDecorator: FilterINputStream的直接子类，如BufferedInputStream，他们为读取字节附加了一些功能</p>\n<p>首先看一下InputStream为我们提供了哪些操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">int\tavailable()</div><div class=\"line\">返回不阻塞情况下可用的字节数</div><div class=\"line\">void close()</div><div class=\"line\">关闭这个输入流</div><div class=\"line\">void mark(int readlimit)</div><div class=\"line\">在流的当前位置打一个标记</div><div class=\"line\">boolean\tmarkSupported()</div><div class=\"line\">如果这个流支持打标记，则返回true</div><div class=\"line\">abstract int read()</div><div class=\"line\">从数据中读取一个字节，并返回该字节</div><div class=\"line\">int\tread(byte[] b)</div><div class=\"line\">读入一个字节数组，并返回读入的字节数</div><div class=\"line\">int\tread(byte[] b, int off, int len)</div><div class=\"line\">读入一个字节数组，并返回读入的字节数。b:数据读入的数组  off:第一个读入的字节在b中的偏移量  len:读入字节的最大数量</div><div class=\"line\">void reset()</div><div class=\"line\">返回最后的标记，随后对read的调用将重新读入这些字节</div><div class=\"line\">long skip(long n)</div><div class=\"line\">在输入流中跳过n个字节，返回实际跳过数</div></pre></td></tr></table></figure>\n<p>其中：<br>abstract int read()<br>int    read(byte[] b)<br>int    read(byte[] b, int off, int len)</p>\n<p>这三个方法提供了基本的读入功能。read方法在执行时将被阻塞，直到字节确实被读入。InputStream的子类实现或重写了这些方法的具体的操作，来完成对具体对象的读入功能。</p>\n<p>通过一个简单的例子来理解InputStream的组合过滤器功能。</p>\n<p>我们要从文件中读入数字，则首先必须有一个具体实现读取文件的FileInputStream实例： FileInputStream fin = new FileInputStream(“test.dat”);</p>\n<p>流在默认情况下是不被缓冲区缓存的，也就是说，对于每一次的read的调用都会请求操作系统再分发一个字节。相比之下，一次请求一个数据块将其置于缓冲区显得更加高效。<br>因此，我们为流添加缓冲功能，形成缓冲流： BufferedInputStream bin = new BufferedInputStream(fin);</p>\n<p>test.dat文件中存储的是十进制数字的二进制序列。此时我们的流仅仅提供了读取字节序列的功能，为了实现将二进制序列转为十进制数字的功能，我们做进一步转换：<br>DataInputStream din = new DataInputStream(bin);</p>\n<p>此时我们可以调用 din.readInt()方法依次读取文件中以二进制形式存储的十进制数字了。</p>\n<p>注意，我们将DataInputStream置于构造链的最后，这是因为我们最终希望使用DataInputStream的方法来读取十进制数字。</p>\n<p>观察一下上面提到的几个类的实现，就会对这种装饰者模式的工作机制有更加深刻的理解。理解了装饰者模式之后，再结合上面的类图，使用IO流就会更加得心应手。</p>\n<p>对于OutputStream，实现原理与InputStream是一样的，不再赘述。</p>\n<p>记录几个常用的stream：</p>\n<p>DataOutputStream: 将基本类型的数据以二进制流的形式写出</p>\n<p>DataInputStream: 将二进制流读入为基本类型数据</p>\n<p>ObjectInputStream: 将Java对象以二进制流的形式写出 （序列化使用）</p>\n<p>ObjectOutputStream: 将二进制流读入为java对象 （序列化时使用）</p>\n<p>PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流，让多线程可以通过管道进行线程间的通讯</p>\n<p>ZipOutputStream和ZipInputStream: 文件压缩与解压缩</p>\n<p>PushBackInputStream：回退流</p>\n<h2 id=\"字符接口\"><a href=\"#字符接口\" class=\"headerlink\" title=\"字符接口\"></a>字符接口</h2><img src=\"/2017/03/19/I-O总结/javaio2.bmp\" alt=\"字符流\" title=\"字符流\">\n<p>在保存数据时，可以选择二进制格式保存或者文本格式保存。比如，整数12234可以存储成二进制，是由00 00 04 D2构成的字节序列。而存储成文本格式，则存储成为字符串“1234”。二进制格式的存储高效且节省空间，但是文本格式的存储方式更适宜人类阅读，应用也很广泛。</p>\n<p>与字节接口类似，字符接口族也是采用了装饰者模式的架构。</p>\n<p>在存储或读取文本字符串时，可以选择编码。比如：</p>\n<p>InputStreamReader reader = new InputStreamReader(new FileInputStream(“test.dat”),”UTF-8”);</p>\n<p>reader将使用GBK编码读取文本test.dat的内容。如果构造器没有显示指定编码，将使用主机系统所使用的默认文字编码方式。</p>\n<p>与DataOutputStream对应，PrintWriter用来以文本的格式打印字符串和数字。</p>\n<p>与DataInputStream对应，可以使用Scanner类来读取文本格式的数据。</p>\n<h2 id=\"字符集\"><a href=\"#字符集\" class=\"headerlink\" title=\"字符集\"></a>字符集</h2><p>字符集规定了某个字符对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个字符（解码）的映射关系。</p>\n<p>JavaSE-1.4的java.nio包中引入了类Charset统一了对字符集的转换。</p>\n<img src=\"/2017/03/19/I-O总结/decoder.jpg\" alt=\"字符集\" title=\"字符集\">\n<img src=\"/2017/03/19/I-O总结/encoder.jpg\" alt=\"字符集\" title=\"字符集\">\n<p>通过观察InputStreamReader的源码（1.7），InputStreamReader 将字符的读取与解码委托给了类StreamDecoder实现。而在StreamDecoder中，又是通过传入的InputStream与指定的Charset配合完成了字节序列的读取和解码工作。</p>\n<p>可以通过调用静态的forName方法获取一个Charset：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(&quot;UTF-8&quot;);</div></pre></td></tr></table></figure></p>\n<p>其中，传入的参数是某个字符集的官方名或者别名。</p>\n<p>Set<String> alias = charset.aliases(); //获取某个Charset的所有可用别名<br>Map<String, Charset> charsets = Charset.availableCharsets(); //获取所用可用字符集的名字</p>\n<p>有了字符集Charset，就可以通过他将字节序列解码为字符序列或者将字符序列编码为字节序列：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//编码</div><div class=\"line\">String str = &quot;hello&quot;;</div><div class=\"line\">ByteBuffer bb = charset.encode(str);</div><div class=\"line\">byte[] bytes = bb.array();</div><div class=\"line\"></div><div class=\"line\">//解码</div><div class=\"line\">byte[] bytes = ....</div><div class=\"line\">ByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);</div><div class=\"line\">CharBuffer cb = Charset.decode(bb);</div><div class=\"line\">String str = cb.toString();</div></pre></td></tr></table></figure>\n<p>实际上，通过观察源码，得知InputStreamReader也是这么做的（还有String）。</p>\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><p>Stream关心的是文件的内容，File类关心的是文件的存储。</p>\n<p>关于File的使用，网上有很多介绍，可以参考官网<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/File.html\">Class File</a>，不再赘述。</p>\n<p>要注意一个类RandomAccessFile，可以在文件的任何位置查找或者写入数据，RandomAccessFile同时实现了DataInput和DataOutput接口。</p>\n<p>我们可以使用RandomAccessFile随机读写的特性来完成大文件的上传或者下载。把文件分为n份，开启n个线程同时对这n个部分进行读写操作，提高了读写的效率。（让我想起了ConcurrentHashMap，分段锁的原理）同时，还具有了断点续传的功能。</p>"},{"layout":"post","title":"java类加载","date":"2017-04-06T11:56:22.000Z","_content":"> 本篇笔记的目标是理解类加载器的架构，学会实现类加载器并理解热替换的底层原理。\n\n## 什么是类加载\n\n>类从被加载到虚拟机内存中开始，到卸载出内存为止，包括了以下几个生命周期：\n\n{% asset_img jiazai.png jiazai %}\n\n>什么时候会触发类加载的第一个阶段(加载)？虚拟机规范没有强制规定，这一点依据不同的虚拟机实现来定。但对于初始化阶段，虚拟机规范规定了有且只有5种>情况必须立即对类进行初始化(加载阶段自然要在此之前开始)：\n\n>1.使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰的常量字段除外)、调用一个类的静态方法。\n\n>2.使用反射方法对类进行调用\n\n>3.初始化一个类的时候，发现其父类未初始化，则触发父类的初始化\n\n>4.虚拟机启动时，用户需指定一个要执行的主类(包含main的那个类)，虚拟机先初始化该类\n\n>5.当使用jdk1.7的动态语言支持时，如果一个java.lang.invoke。MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄所对应的类没有进行过初始化，则先触发其初始化(不懂...)\n\n--《深入理解jvm虚拟机》\n\n<!-- more -->\n\n这篇笔记所要学习的内容，仅仅是类加载的第一个阶段：加载。在加载阶段，虚拟机会完成下面三件事：\n\n1.通过一个类的全限定名获取定义此类的二进制字节流\n\n2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n\n3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口\n\n在上面的三个阶段中，`通过一个类的全限定名获取定义此类的二进制字节流` 是开发人员可以控制的部分，也是我们这篇笔记所要探讨的内容。\n\n虚拟机设计团队将`通过一个类的全限定名获取定义此类的二进制字节流`这个动作放到java虚拟机外部去实现，以便让应用程序自己决定去如何获取所需要的类。实现这个动作的代码模块被称为\"类加载器\"。`定义此类的二进制字节流`可以来自class文件、网络、zip包、或者运行时生成等。\n\n类加载器实现类的加载动作，比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使两个类源自于同一份class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那么这两个类必定不相等。\n\n```java\npublic class ClassLocaderTest {\n\tpublic static void main(String[] args) {\n        Object testClassLoader1 = getMyClassLoader1();\n        System.out.println(testClassLoader1.getClass());\n\t\tSystem.out.println(testClassLoader1 instanceof space.kyu.TestClass);\n    }\n    static Object getMyClassLoader1() {\n\t\tObject obj = null;\n\t\ttry {\n\t\t\tMyClassLoader1 loader = new MyClassLoader1();\n\t\t\tobj = loader.loadClass(\"space.kyu.TestClass\").newInstance();\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t\treturn obj;\n\t}\n}\nclass MyClassLoader1 extends ClassLoader{\n\t@Override\n\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\ttry {\n\t\t\tString fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\";\n\t\t\tInputStream stream = getClass().getResourceAsStream(fileName);\n\t\t\tif (stream == null) {\n//\t\t\t\tSystem.out.println(\"ClassLoader load class\" + name);\n\t\t\t\treturn super.loadClass(name);\n\t\t\t}\n\t\t\tbyte[] bs = new byte[stream.available()];\n\t\t\tstream.read(bs);\n//\t\t\tSystem.out.println(\"MyClassLoader1 load class: \" + name);\n\t\t\treturn defineClass(name, bs, 0, bs.length);\n\t\t} catch (IOException e) {\n\t\t\tthrow new ClassNotFoundException(name);\n\t\t}\n\t}\n\t\n}\n```\n\n输出：\n\n```\nclass space.kyu.TestClass\nfalse\n```\n\n在上面的例子中，虚拟机中存在两个space.kyu.TestClass类，一个是由系统应用程序类加载器加载的，一个是由我们自己实现的类加载器加载的。虽然来自同一个class文件，但依然是两个独立的类，故不相等。\n\n\n类加载器应用于类层次划分、OSGI、热部署、代码加密等方面。\n\n## 类加载器层次结构\n\n从java虚拟机的角度来看，类加载器分为两类：\n\n1.启动类加载器\n  \n  使用c++实现，是虚拟机自身的一部分\n\n2.其他类加载器\n  \n  由java语言实现，独立于虚拟机外部，全都继承自抽象类java.lang.ClassLoader\n\n从类加载器的实现来看，类加载器又可分为系统提供的类加载器与我们自己实现的类加载器。系统提供的类加载器主要有三个：\n\n- 引导类加载器，用来加载java核心类库。主要是放在JAVA_HOME\\lib目录中或被-Xbootclasspath所指定的目录。\n\n- 扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现。负责加载JAVA_HOME\\lib\\ext目录中，或java.ext.dirs所指定的路径中的类库。\n\n- 应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现。这个类也是ClassLoader中getSystemClassLoader()方法的返回值。负责加载classpath上指定的类库。\n\n除了系统提供的类加载器以外，我们可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。\n\n除了引导类加载器之外，所有的类加载器都有一个父类加载器。这种父子关系构成了类加载器的层次结构。\n\n对于系统提供的类加载器来说，应用程序类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器。\n\n因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。\n\n这种类加载器之间的层次关系，称为类加载器的双亲委派模型：\n\n{% asset_img classloader.png classloader %}\n\n注意，上图中的树状结构并不意味着继承关系，而是使用委托实现的。\n\n双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他会首先把这个请求委托给自己的父类加载器去完成，每一层次的加载器都是如此，最后所有的类加载请求最终都会传递到顶层的引导类加载器中去，只有当父类加载器无法完成这个加载请求(所请求加载的类不在 他加载的范围内)时，子类加载器会尝试自己加载。\n\n双亲委派机制保证了java核心类库的安全，如果尝试加载与rt.jar类库中已有的类重名的java类，该类永远无法被加载运行，因为请求被传递到引导类加载器之后，引导类加载器会返回加载到的rt.jar中的类。\n\n我们观察一下双亲委派机制的实现：\n\n首先看一下ClassLoader中的方法：\n\n```\nfindLoadedClass：每个类加载器都维护有自己的一份已加载类名字空间，其中不能出现两个同名的类。凡是通过该类加载器加载的类，无论是直接的还是间接的，都保存在自己的名字空间中，该方法就是在该名字空间中寻找指定的类是否已存在，如果存在就返回给类的引用，否则就返回 null。这里的直接是指，存在于该类加载器的加载路径上并由该加载器完成加载，间接是指，由该类加载器把类的加载工作委托给其他类加载器完成类的实际加载。\n\ngetSystemClassLoader：Java2 中新增的方法。该方法返回系统使用的 ClassLoader。可以在自己定制的类加载器中通过该方法把一部分工作转交给系统类加载器去处理。\n\ndefineClass：该方法是 ClassLoader 中非常重要的一个方法，它接收以字节数组表示的类字节码，并把它转换成 Class 实例，该方法转换一个类的同时，会先要求装载该类的父类以及实现的接口类。\n\nloadClass：加载类的入口方法，调用该方法完成类的显式加载。通过对该方法的重新实现，我们可以完全控制和管理类的加载过程。\n\nfindClass(String name):\t查找名称为 name的类，返回的结果是 java.lang.Class类的实例。\n\nresolveClass(Class<?> c): 链接指定的 Java 类。\n```\n\n实现双亲委派机制的代码集中在ClassLoader的loadClass方法中。\n\n```java\n protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    long t1 = System.nanoTime();\n                    c = findClass(name);\n\n                    // this is the defining class loader; record the stats\n                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    sun.misc.PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n```\n\n先检查是否已经加载过，若没有则调用父类加载器的loadClass方法，若父类加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常后，则调用自己的findClass方法进行加载。\n\n## 双亲委托机制的不足\n\n双亲委派机制很好的解决了各个类加载器的基础类统一的问题，基础类总是作为被用户代码调用的API（比如rt.jar中的类）。但是如果基础类要调用用户的代码时会发生什么？\n\n首先要搞明白一点：当我们使用 new 关键字或者 Class.forName 来加载类时，所要加载的类都是由调用 new 或者 Class.forName 的类的类加载器进行加载的。比如我们使用JDBC标准接口时，JDBC标准接口存在于rt.jar中，在这个接口中又需要调用各个数据库厂商提供的jdbc驱动程序来达到管理驱动的目的，这些驱动程序的jar包一般置于claspath路径下。问题出现了：JDBC标准接口是由引导类加载器加载的，故在这些接口中调用classpath路径下的jdbc驱动代码时，也会尝试使用引导类加载器进行加载。但是引导类加载器根本不可能认识这些代码(只负责rt.jar)。\n\n为了解决这个问题，引入了线程上下文类加载器。\n\n这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时没有设置，将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置，那么这个类加载器默认就是应用程序类加载器。\n\n使用java.lang.Thread.getContextClassLoader()可以获得线程上下文类加载器，故可以使用这个加载器加载classpath路径下的代码，也就是父类加载器请求子类加载器完成类加载动作，破坏了双亲委托模型。\n\n## 实现自己的类加载器\n\n上面提到的系统提供的类加载器在大多数情况下可以满足我们的需求，但是在某些情况下，我们需要开发自己的类加载器，比如，加载网络传输得到的类字节码、对字节码进行加密解码、加载运行时生成的字节码、实现类的热替换等。这些情况下类的字节码仅仅依靠上述的三种系统类加载器是无法加载的。\n\n我自己实现了一些测试代码，现在将他们贴到这里，顺便对前面的总结做一个印证。下面的几个类都位于包space.kyu下面：\n\n```java\nclass MyClassLoader1 extends ClassLoader{\n\t@Override\n\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\ttry {\n\t\t\tString fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\";\n\t\t\tInputStream stream = getClass().getResourceAsStream(fileName);\n\t\t\tif (stream == null) {\n//\t\t\t\tSystem.out.println(\"ClassLoader load class\" + name);\n\t\t\t\treturn super.loadClass(name);\n\t\t\t}\n\t\t\tbyte[] bs = new byte[stream.available()];\n\t\t\tstream.read(bs);\n//\t\t\tSystem.out.println(\"MyClassLoader1 load class: \" + name);\n\t\t\treturn defineClass(name, bs, 0, bs.length);\n\t\t} catch (IOException e) {\n\t\t\tthrow new ClassNotFoundException(name);\n\t\t}\n\t}\n}\n\npublic class MyClassLoader2 extends ClassLoader {\n\tpublic Class<?> loadDirectly(String name) throws ClassNotFoundException {\n\t\ttry {\n\t\t\tString fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\";\n\t\t\tInputStream stream = getClass().getResourceAsStream(fileName);\n\t\t\tif (stream == null) {\n//\t\t\t\tSystem.out.println(\"ClassLoader load class\" + name);\n\t\t\t\treturn super.loadClass(name);\n\t\t\t}\n\t\t\tbyte[] bs = new byte[stream.available()];\n\t\t\tstream.read(bs);\n//\t\t\tSystem.out.println(\"MyClassLoader2 load class: \" + name);\n\t\t\treturn defineClass(name, bs, 0, bs.length);\n\t\t} catch (IOException e) {\n\t\t\tthrow new ClassNotFoundException(name);\n\t\t}\n\t}\n}\n\npublic interface Operation {\n\tvoid doSomething();\n}\n\npublic class Test {\n\tpublic String str;\n\tpublic Test(String str) {\n\t\tthis.str = str;\n\t}\n\t\n\tpublic void test() {\n\t\tSystem.out.println(str);\n\t}\n}\n\npublic class TestClass implements Operation{\n\tpublic Test test;\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(\"hello\");\n\t}\n\t\n\tpublic Test test(){\n\t\ttest = new Test(\"haha\");\n\t\tSystem.out.println(test.str);\n\t\treturn test;\n\t}\n}\n\npublic class ClassLocaderTest {\n\tpublic static void main(String[] args) {\n\t\tObject testClassLoader1 = getMyClassLoader1();\n\t\tObject testClassLoader2 = getMyClassLoader2();\n\t\tSystem.out.println(\"*****************testClassLoader1*******************\");\n\t\tprintClassLoader(testClassLoader1);\n\t\treflectInvoke(testClassLoader1);\n\t\tinterfaceInvoke(testClassLoader1);\n\t\tSystem.out.println(\"*****************testClassLoader2*******************\");\n\t\tprintClassLoader(testClassLoader2);\n\t\treflectInvoke(testClassLoader2);\n\t\tinterfaceInvoke(testClassLoader2);\n        \n\t}\n\n\tstatic void printClassLoader(Object object) {\n\t\tSystem.out.println(\"*********printClassLoader:\");\n\t\tClassLoader classLoader = object.getClass().getClassLoader();\n\t\twhile (classLoader != null) {\n\t\t\tSystem.out.println(classLoader);\n\t\t\tclassLoader = classLoader.getParent();\n\t\t}\n\t}\n\n\tstatic void reflectInvoke(Object obj) {\n\t\tSystem.out.println(\"*********reflectInvoke:\");\n\t\ttry {\n\t\t\tMethod test = obj.getClass().getMethod(\"test\", new Class[] {});\n\t\t\ttest.invoke(obj, new Object[] {});\n\t\t\tMethod doSomething = obj.getClass().getMethod(\"doSomething\", new Class[] {});\n\t\t\tdoSomething.invoke(obj, new Object[] {});\n\t\t} catch (InvocationTargetException e) {\n\t\t\tThrowable t = e.getTargetException();// 获取目标异常\n\t\t\tSystem.out.println(t);\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\t\n\tstatic void interfaceInvoke(Object obj) {\n\t\tSystem.out.println(\"*********interfaceInvoke:\");\n\t\ttry {\n\t\t\tOperation operation = (Operation) obj;\n\t\t\toperation.doSomething();\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\n\tstatic Object getMyClassLoader1() {\n\t\tObject obj = null;\n\t\ttry {\n\t\t\tMyClassLoader1 loader = new MyClassLoader1();\n\t\t\tobj = loader.loadClass(\"space.kyu.TestClass\").newInstance();\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t\treturn obj;\n\t}\n\n\tstatic Object getMyClassLoader2() {\n\t\tObject obj = null;\n\t\ttry {\n\t\t\tMyClassLoader2 loader = new MyClassLoader2();\n\t\t\tobj = loader.loadDirectly(\"space.kyu.TestClass\").newInstance();\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t\treturn obj;\n\t}\n}\n\n```\n上述六个类位于space.kyu下不同的类文件当中。ClassLocaderTest运行结果：\n\n```\n*****************testClassLoader1*******************\n*********printClassLoader:\nspace.kyu.MyClassLoader1@76e2d0ab\nsun.misc.Launcher$AppClassLoader@52a53948\nsun.misc.Launcher$ExtClassLoader@5d53d05b\n*********reflectInvoke:\nhaha\nhello\n*********interfaceInvoke:\njava.lang.ClassCastException: space.kyu.TestClass cannot be cast to space.kyu.Operation\n*****************testClassLoader2*******************\n*********printClassLoader:\nspace.kyu.MyClassLoader2@6c618821\nsun.misc.Launcher$AppClassLoader@52a53948\nsun.misc.Launcher$ExtClassLoader@5d53d05b\n*********reflectInvoke:\nhaha\nhello\n*********interfaceInvoke:\nhello\n```\n一般来说，我们自己开发的类加载器只要继承ClassLoader并覆盖findClass方法即可。这样的话就会自动使用双亲委派机制，我们可以在findClass方法中填写我们自己的加载逻辑：从网络上或者是硬盘上加载一个类的字节码。\n\n上面的例子中并没有使用这个套路，MyClassLoader1直接复写loadClass方法，MyClassLoader2添加了方法loadDirectly，如果不这样做的话，我们在加载space.kyu.TestClass这个类的时候，因为这个类在classpath上，由于双亲委派机制，这个类会被应用程序类加载器先进行加载，达不到测试的效果。\n\n- 观察上面printClassLoader部分，通过getParent方法打印了类加载器的层次结构。可见虽然我们并未显示指定这两个自定义加载器的父类加载器，但是他们的父类加载器已经被默认设置为sun.misc.Launcher$AppClassLoader，也就是加载这两个个自定义类加载器所使用的加载器。印证上面的结论：`对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。`\n\n- reflectInvoke方法是使用反射机制调用了加载出来类的方法，如果去掉上面自定义类加载器中注掉的System.out方法，就会看到，在反射调用TestClass的test方法的时候，类加载器加载了space.kyu.Test这个类，并且加载他的类加载器正是我们自定义的类加载器，印证了我们上面的结论：`当我们使用 new 关键字或者 Class.forName 来加载类时，所要加载的类都是由调用 new 或者 Class.forName 的类的类加载器进行加载的`\n\n- 思考上面的反射用法，为什么不直接将getMyClassLoader1()方法返回的Object对象强转为space.kyu.TestClass呢？比如这样：\n\n  `space.kyu.TestClass testClass = (TestClass)getMyClassLoader1();`\n\n  编译并没有问题，但是在运行时就会报错：java.lang.ClassCastException\n\n  为什么会出现这样的结果呢？其实从这篇文章的一开始就已经演示过了。`space.kyu.TestClass testClass`这个类是通过应用程序类加载器加载的，而`getMyClassLoader1()`方法得到的是我们自定义类加载器加载的类，这两个类是不相等的(虽然名字相同)，所以强转失败。\n\n- 接下来看interfaceInvoke这部分。将自定义类加载器加载得到的对象强转为了接口类型。注意到，MyClassLoader1加载的类对象在强转时抛出异常，而MyClassLoader2可以正常强转并调用接口方法。\n\n  MyClassLoader1加载的类为什么强转失败？原因在于，MyClassLoader1在加载TestClass类时，触发其父类接口Operation的加载，此时默认使用MyClassLoader1加载Operation类。在MyClassLoader1中我们覆盖了loadClass方法，故加载Operation时也会调用我们自己实现的loadClass方法进行加载。\n\n  同样的，MyClassLoader2在加载TestClass类时，也触发其父类接口Operation的加载，此时默认使用MyClassLoader2加载Operation类。不同之处在于我们并未覆盖loadClass方法，加载Operation时调用了ClassLoader中的loadClass方法，在这个方法的实现中，由应用程序类加载器加载了Operation类。\n\n  所以，出现上面结果的原因也就一目了然了。\n\n## 类加载器与热替换\n\n普通的java应用中不能实现类的热替换的原因在于同名类的不同版本的实例不能共存，因为使用了默认的类加载机制后，一个类只会被加载一次，再次请求加载时直接返回之前加载的缓存(findLoadedClass)。故我们重新编译生成\n的class文件并不会被重新读取并加载。\n\n为了绕过这个加载机制，我们可以通过不同的类加载器来加载该类的不同版本。\n\n在space.kyu包下面新增一个类HotSwapTest：\n```java\npublic class HotSwapTest {\n\tpublic static void main(String[] args) {\n\t\tTimer timer = new Timer(false);\n\t\tTimerTask task = new TimerTask() {\n\t\t\tpublic void run() {\n\t\t\t\tupdate();\n\t\t\t}\n\t\t};\n\t\ttimer.schedule(task, 1000, 2000);\n\t}\n\n\tpublic static void update() {\n\t\ttry {\n\t\t\tMyClassLoader2 loader = new MyClassLoader2();\n\t\t\tObject obj = loader.loadDirectly(\"space.kyu.TestClass\").newInstance();\n\t\t\tMethod doSomething = obj.getClass().getMethod(\"doSomething\", new Class[] {});\n\t\t\tdoSomething.invoke(obj, new Object[] {});\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n在HotSwapTest类中，我们模拟了一个定时升级的任务：每隔两秒执行一次升级，实例化一个MyClassLoader2对象并使用该类加载器加载space.kyu.TestClass，反射调用其doSomething方法打印字符串。\n\n编译并运行HotSwapTest，运行过程中，每隔两秒doSomething便打印字符串\"hello\"，此时修改space.kyu.TestClass源码，将打印字符串替换为\"world\"，CTRL+S，我们的程序并未停止，但是下一次打印出的字符串已然不同了：\n\n```\nhello\nhello\nhello\nhello\nhello\nworld\nworld\nworld\n\n```\n\n上面就是一个简单的热替换的例子。实际的应用中当然不是通过一个定时任务进行升级的。把新版本类的字节码通过网络传输到服务器上去，然后发送一个升级指令，使用上面类似的方法便可对类进行升级。\n\n## 参考\n\n[Java 类的热替换 —— 概念、设计与实现](https://www.ibm.com/developerworks/cn/java/j-lo-hotswapcls/)\n\n[深入探讨 Java 类加载器](https://www.ibm.com/developerworks/cn/java/j-lo-classloader/)","source":"_posts/java类加载.md","raw":"---\nlayout: post\ntitle: java类加载\ndate: 2017-04-06 19:56:22\ncategories: 编程\ntags: java\n---\n> 本篇笔记的目标是理解类加载器的架构，学会实现类加载器并理解热替换的底层原理。\n\n## 什么是类加载\n\n>类从被加载到虚拟机内存中开始，到卸载出内存为止，包括了以下几个生命周期：\n\n{% asset_img jiazai.png jiazai %}\n\n>什么时候会触发类加载的第一个阶段(加载)？虚拟机规范没有强制规定，这一点依据不同的虚拟机实现来定。但对于初始化阶段，虚拟机规范规定了有且只有5种>情况必须立即对类进行初始化(加载阶段自然要在此之前开始)：\n\n>1.使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰的常量字段除外)、调用一个类的静态方法。\n\n>2.使用反射方法对类进行调用\n\n>3.初始化一个类的时候，发现其父类未初始化，则触发父类的初始化\n\n>4.虚拟机启动时，用户需指定一个要执行的主类(包含main的那个类)，虚拟机先初始化该类\n\n>5.当使用jdk1.7的动态语言支持时，如果一个java.lang.invoke。MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄所对应的类没有进行过初始化，则先触发其初始化(不懂...)\n\n--《深入理解jvm虚拟机》\n\n<!-- more -->\n\n这篇笔记所要学习的内容，仅仅是类加载的第一个阶段：加载。在加载阶段，虚拟机会完成下面三件事：\n\n1.通过一个类的全限定名获取定义此类的二进制字节流\n\n2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n\n3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口\n\n在上面的三个阶段中，`通过一个类的全限定名获取定义此类的二进制字节流` 是开发人员可以控制的部分，也是我们这篇笔记所要探讨的内容。\n\n虚拟机设计团队将`通过一个类的全限定名获取定义此类的二进制字节流`这个动作放到java虚拟机外部去实现，以便让应用程序自己决定去如何获取所需要的类。实现这个动作的代码模块被称为\"类加载器\"。`定义此类的二进制字节流`可以来自class文件、网络、zip包、或者运行时生成等。\n\n类加载器实现类的加载动作，比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使两个类源自于同一份class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那么这两个类必定不相等。\n\n```java\npublic class ClassLocaderTest {\n\tpublic static void main(String[] args) {\n        Object testClassLoader1 = getMyClassLoader1();\n        System.out.println(testClassLoader1.getClass());\n\t\tSystem.out.println(testClassLoader1 instanceof space.kyu.TestClass);\n    }\n    static Object getMyClassLoader1() {\n\t\tObject obj = null;\n\t\ttry {\n\t\t\tMyClassLoader1 loader = new MyClassLoader1();\n\t\t\tobj = loader.loadClass(\"space.kyu.TestClass\").newInstance();\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t\treturn obj;\n\t}\n}\nclass MyClassLoader1 extends ClassLoader{\n\t@Override\n\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\ttry {\n\t\t\tString fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\";\n\t\t\tInputStream stream = getClass().getResourceAsStream(fileName);\n\t\t\tif (stream == null) {\n//\t\t\t\tSystem.out.println(\"ClassLoader load class\" + name);\n\t\t\t\treturn super.loadClass(name);\n\t\t\t}\n\t\t\tbyte[] bs = new byte[stream.available()];\n\t\t\tstream.read(bs);\n//\t\t\tSystem.out.println(\"MyClassLoader1 load class: \" + name);\n\t\t\treturn defineClass(name, bs, 0, bs.length);\n\t\t} catch (IOException e) {\n\t\t\tthrow new ClassNotFoundException(name);\n\t\t}\n\t}\n\t\n}\n```\n\n输出：\n\n```\nclass space.kyu.TestClass\nfalse\n```\n\n在上面的例子中，虚拟机中存在两个space.kyu.TestClass类，一个是由系统应用程序类加载器加载的，一个是由我们自己实现的类加载器加载的。虽然来自同一个class文件，但依然是两个独立的类，故不相等。\n\n\n类加载器应用于类层次划分、OSGI、热部署、代码加密等方面。\n\n## 类加载器层次结构\n\n从java虚拟机的角度来看，类加载器分为两类：\n\n1.启动类加载器\n  \n  使用c++实现，是虚拟机自身的一部分\n\n2.其他类加载器\n  \n  由java语言实现，独立于虚拟机外部，全都继承自抽象类java.lang.ClassLoader\n\n从类加载器的实现来看，类加载器又可分为系统提供的类加载器与我们自己实现的类加载器。系统提供的类加载器主要有三个：\n\n- 引导类加载器，用来加载java核心类库。主要是放在JAVA_HOME\\lib目录中或被-Xbootclasspath所指定的目录。\n\n- 扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现。负责加载JAVA_HOME\\lib\\ext目录中，或java.ext.dirs所指定的路径中的类库。\n\n- 应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现。这个类也是ClassLoader中getSystemClassLoader()方法的返回值。负责加载classpath上指定的类库。\n\n除了系统提供的类加载器以外，我们可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。\n\n除了引导类加载器之外，所有的类加载器都有一个父类加载器。这种父子关系构成了类加载器的层次结构。\n\n对于系统提供的类加载器来说，应用程序类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器。\n\n因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。\n\n这种类加载器之间的层次关系，称为类加载器的双亲委派模型：\n\n{% asset_img classloader.png classloader %}\n\n注意，上图中的树状结构并不意味着继承关系，而是使用委托实现的。\n\n双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他会首先把这个请求委托给自己的父类加载器去完成，每一层次的加载器都是如此，最后所有的类加载请求最终都会传递到顶层的引导类加载器中去，只有当父类加载器无法完成这个加载请求(所请求加载的类不在 他加载的范围内)时，子类加载器会尝试自己加载。\n\n双亲委派机制保证了java核心类库的安全，如果尝试加载与rt.jar类库中已有的类重名的java类，该类永远无法被加载运行，因为请求被传递到引导类加载器之后，引导类加载器会返回加载到的rt.jar中的类。\n\n我们观察一下双亲委派机制的实现：\n\n首先看一下ClassLoader中的方法：\n\n```\nfindLoadedClass：每个类加载器都维护有自己的一份已加载类名字空间，其中不能出现两个同名的类。凡是通过该类加载器加载的类，无论是直接的还是间接的，都保存在自己的名字空间中，该方法就是在该名字空间中寻找指定的类是否已存在，如果存在就返回给类的引用，否则就返回 null。这里的直接是指，存在于该类加载器的加载路径上并由该加载器完成加载，间接是指，由该类加载器把类的加载工作委托给其他类加载器完成类的实际加载。\n\ngetSystemClassLoader：Java2 中新增的方法。该方法返回系统使用的 ClassLoader。可以在自己定制的类加载器中通过该方法把一部分工作转交给系统类加载器去处理。\n\ndefineClass：该方法是 ClassLoader 中非常重要的一个方法，它接收以字节数组表示的类字节码，并把它转换成 Class 实例，该方法转换一个类的同时，会先要求装载该类的父类以及实现的接口类。\n\nloadClass：加载类的入口方法，调用该方法完成类的显式加载。通过对该方法的重新实现，我们可以完全控制和管理类的加载过程。\n\nfindClass(String name):\t查找名称为 name的类，返回的结果是 java.lang.Class类的实例。\n\nresolveClass(Class<?> c): 链接指定的 Java 类。\n```\n\n实现双亲委派机制的代码集中在ClassLoader的loadClass方法中。\n\n```java\n protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    long t1 = System.nanoTime();\n                    c = findClass(name);\n\n                    // this is the defining class loader; record the stats\n                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    sun.misc.PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n```\n\n先检查是否已经加载过，若没有则调用父类加载器的loadClass方法，若父类加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常后，则调用自己的findClass方法进行加载。\n\n## 双亲委托机制的不足\n\n双亲委派机制很好的解决了各个类加载器的基础类统一的问题，基础类总是作为被用户代码调用的API（比如rt.jar中的类）。但是如果基础类要调用用户的代码时会发生什么？\n\n首先要搞明白一点：当我们使用 new 关键字或者 Class.forName 来加载类时，所要加载的类都是由调用 new 或者 Class.forName 的类的类加载器进行加载的。比如我们使用JDBC标准接口时，JDBC标准接口存在于rt.jar中，在这个接口中又需要调用各个数据库厂商提供的jdbc驱动程序来达到管理驱动的目的，这些驱动程序的jar包一般置于claspath路径下。问题出现了：JDBC标准接口是由引导类加载器加载的，故在这些接口中调用classpath路径下的jdbc驱动代码时，也会尝试使用引导类加载器进行加载。但是引导类加载器根本不可能认识这些代码(只负责rt.jar)。\n\n为了解决这个问题，引入了线程上下文类加载器。\n\n这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时没有设置，将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置，那么这个类加载器默认就是应用程序类加载器。\n\n使用java.lang.Thread.getContextClassLoader()可以获得线程上下文类加载器，故可以使用这个加载器加载classpath路径下的代码，也就是父类加载器请求子类加载器完成类加载动作，破坏了双亲委托模型。\n\n## 实现自己的类加载器\n\n上面提到的系统提供的类加载器在大多数情况下可以满足我们的需求，但是在某些情况下，我们需要开发自己的类加载器，比如，加载网络传输得到的类字节码、对字节码进行加密解码、加载运行时生成的字节码、实现类的热替换等。这些情况下类的字节码仅仅依靠上述的三种系统类加载器是无法加载的。\n\n我自己实现了一些测试代码，现在将他们贴到这里，顺便对前面的总结做一个印证。下面的几个类都位于包space.kyu下面：\n\n```java\nclass MyClassLoader1 extends ClassLoader{\n\t@Override\n\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\ttry {\n\t\t\tString fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\";\n\t\t\tInputStream stream = getClass().getResourceAsStream(fileName);\n\t\t\tif (stream == null) {\n//\t\t\t\tSystem.out.println(\"ClassLoader load class\" + name);\n\t\t\t\treturn super.loadClass(name);\n\t\t\t}\n\t\t\tbyte[] bs = new byte[stream.available()];\n\t\t\tstream.read(bs);\n//\t\t\tSystem.out.println(\"MyClassLoader1 load class: \" + name);\n\t\t\treturn defineClass(name, bs, 0, bs.length);\n\t\t} catch (IOException e) {\n\t\t\tthrow new ClassNotFoundException(name);\n\t\t}\n\t}\n}\n\npublic class MyClassLoader2 extends ClassLoader {\n\tpublic Class<?> loadDirectly(String name) throws ClassNotFoundException {\n\t\ttry {\n\t\t\tString fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\";\n\t\t\tInputStream stream = getClass().getResourceAsStream(fileName);\n\t\t\tif (stream == null) {\n//\t\t\t\tSystem.out.println(\"ClassLoader load class\" + name);\n\t\t\t\treturn super.loadClass(name);\n\t\t\t}\n\t\t\tbyte[] bs = new byte[stream.available()];\n\t\t\tstream.read(bs);\n//\t\t\tSystem.out.println(\"MyClassLoader2 load class: \" + name);\n\t\t\treturn defineClass(name, bs, 0, bs.length);\n\t\t} catch (IOException e) {\n\t\t\tthrow new ClassNotFoundException(name);\n\t\t}\n\t}\n}\n\npublic interface Operation {\n\tvoid doSomething();\n}\n\npublic class Test {\n\tpublic String str;\n\tpublic Test(String str) {\n\t\tthis.str = str;\n\t}\n\t\n\tpublic void test() {\n\t\tSystem.out.println(str);\n\t}\n}\n\npublic class TestClass implements Operation{\n\tpublic Test test;\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(\"hello\");\n\t}\n\t\n\tpublic Test test(){\n\t\ttest = new Test(\"haha\");\n\t\tSystem.out.println(test.str);\n\t\treturn test;\n\t}\n}\n\npublic class ClassLocaderTest {\n\tpublic static void main(String[] args) {\n\t\tObject testClassLoader1 = getMyClassLoader1();\n\t\tObject testClassLoader2 = getMyClassLoader2();\n\t\tSystem.out.println(\"*****************testClassLoader1*******************\");\n\t\tprintClassLoader(testClassLoader1);\n\t\treflectInvoke(testClassLoader1);\n\t\tinterfaceInvoke(testClassLoader1);\n\t\tSystem.out.println(\"*****************testClassLoader2*******************\");\n\t\tprintClassLoader(testClassLoader2);\n\t\treflectInvoke(testClassLoader2);\n\t\tinterfaceInvoke(testClassLoader2);\n        \n\t}\n\n\tstatic void printClassLoader(Object object) {\n\t\tSystem.out.println(\"*********printClassLoader:\");\n\t\tClassLoader classLoader = object.getClass().getClassLoader();\n\t\twhile (classLoader != null) {\n\t\t\tSystem.out.println(classLoader);\n\t\t\tclassLoader = classLoader.getParent();\n\t\t}\n\t}\n\n\tstatic void reflectInvoke(Object obj) {\n\t\tSystem.out.println(\"*********reflectInvoke:\");\n\t\ttry {\n\t\t\tMethod test = obj.getClass().getMethod(\"test\", new Class[] {});\n\t\t\ttest.invoke(obj, new Object[] {});\n\t\t\tMethod doSomething = obj.getClass().getMethod(\"doSomething\", new Class[] {});\n\t\t\tdoSomething.invoke(obj, new Object[] {});\n\t\t} catch (InvocationTargetException e) {\n\t\t\tThrowable t = e.getTargetException();// 获取目标异常\n\t\t\tSystem.out.println(t);\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\t\n\tstatic void interfaceInvoke(Object obj) {\n\t\tSystem.out.println(\"*********interfaceInvoke:\");\n\t\ttry {\n\t\t\tOperation operation = (Operation) obj;\n\t\t\toperation.doSomething();\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\n\tstatic Object getMyClassLoader1() {\n\t\tObject obj = null;\n\t\ttry {\n\t\t\tMyClassLoader1 loader = new MyClassLoader1();\n\t\t\tobj = loader.loadClass(\"space.kyu.TestClass\").newInstance();\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t\treturn obj;\n\t}\n\n\tstatic Object getMyClassLoader2() {\n\t\tObject obj = null;\n\t\ttry {\n\t\t\tMyClassLoader2 loader = new MyClassLoader2();\n\t\t\tobj = loader.loadDirectly(\"space.kyu.TestClass\").newInstance();\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t\treturn obj;\n\t}\n}\n\n```\n上述六个类位于space.kyu下不同的类文件当中。ClassLocaderTest运行结果：\n\n```\n*****************testClassLoader1*******************\n*********printClassLoader:\nspace.kyu.MyClassLoader1@76e2d0ab\nsun.misc.Launcher$AppClassLoader@52a53948\nsun.misc.Launcher$ExtClassLoader@5d53d05b\n*********reflectInvoke:\nhaha\nhello\n*********interfaceInvoke:\njava.lang.ClassCastException: space.kyu.TestClass cannot be cast to space.kyu.Operation\n*****************testClassLoader2*******************\n*********printClassLoader:\nspace.kyu.MyClassLoader2@6c618821\nsun.misc.Launcher$AppClassLoader@52a53948\nsun.misc.Launcher$ExtClassLoader@5d53d05b\n*********reflectInvoke:\nhaha\nhello\n*********interfaceInvoke:\nhello\n```\n一般来说，我们自己开发的类加载器只要继承ClassLoader并覆盖findClass方法即可。这样的话就会自动使用双亲委派机制，我们可以在findClass方法中填写我们自己的加载逻辑：从网络上或者是硬盘上加载一个类的字节码。\n\n上面的例子中并没有使用这个套路，MyClassLoader1直接复写loadClass方法，MyClassLoader2添加了方法loadDirectly，如果不这样做的话，我们在加载space.kyu.TestClass这个类的时候，因为这个类在classpath上，由于双亲委派机制，这个类会被应用程序类加载器先进行加载，达不到测试的效果。\n\n- 观察上面printClassLoader部分，通过getParent方法打印了类加载器的层次结构。可见虽然我们并未显示指定这两个自定义加载器的父类加载器，但是他们的父类加载器已经被默认设置为sun.misc.Launcher$AppClassLoader，也就是加载这两个个自定义类加载器所使用的加载器。印证上面的结论：`对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。`\n\n- reflectInvoke方法是使用反射机制调用了加载出来类的方法，如果去掉上面自定义类加载器中注掉的System.out方法，就会看到，在反射调用TestClass的test方法的时候，类加载器加载了space.kyu.Test这个类，并且加载他的类加载器正是我们自定义的类加载器，印证了我们上面的结论：`当我们使用 new 关键字或者 Class.forName 来加载类时，所要加载的类都是由调用 new 或者 Class.forName 的类的类加载器进行加载的`\n\n- 思考上面的反射用法，为什么不直接将getMyClassLoader1()方法返回的Object对象强转为space.kyu.TestClass呢？比如这样：\n\n  `space.kyu.TestClass testClass = (TestClass)getMyClassLoader1();`\n\n  编译并没有问题，但是在运行时就会报错：java.lang.ClassCastException\n\n  为什么会出现这样的结果呢？其实从这篇文章的一开始就已经演示过了。`space.kyu.TestClass testClass`这个类是通过应用程序类加载器加载的，而`getMyClassLoader1()`方法得到的是我们自定义类加载器加载的类，这两个类是不相等的(虽然名字相同)，所以强转失败。\n\n- 接下来看interfaceInvoke这部分。将自定义类加载器加载得到的对象强转为了接口类型。注意到，MyClassLoader1加载的类对象在强转时抛出异常，而MyClassLoader2可以正常强转并调用接口方法。\n\n  MyClassLoader1加载的类为什么强转失败？原因在于，MyClassLoader1在加载TestClass类时，触发其父类接口Operation的加载，此时默认使用MyClassLoader1加载Operation类。在MyClassLoader1中我们覆盖了loadClass方法，故加载Operation时也会调用我们自己实现的loadClass方法进行加载。\n\n  同样的，MyClassLoader2在加载TestClass类时，也触发其父类接口Operation的加载，此时默认使用MyClassLoader2加载Operation类。不同之处在于我们并未覆盖loadClass方法，加载Operation时调用了ClassLoader中的loadClass方法，在这个方法的实现中，由应用程序类加载器加载了Operation类。\n\n  所以，出现上面结果的原因也就一目了然了。\n\n## 类加载器与热替换\n\n普通的java应用中不能实现类的热替换的原因在于同名类的不同版本的实例不能共存，因为使用了默认的类加载机制后，一个类只会被加载一次，再次请求加载时直接返回之前加载的缓存(findLoadedClass)。故我们重新编译生成\n的class文件并不会被重新读取并加载。\n\n为了绕过这个加载机制，我们可以通过不同的类加载器来加载该类的不同版本。\n\n在space.kyu包下面新增一个类HotSwapTest：\n```java\npublic class HotSwapTest {\n\tpublic static void main(String[] args) {\n\t\tTimer timer = new Timer(false);\n\t\tTimerTask task = new TimerTask() {\n\t\t\tpublic void run() {\n\t\t\t\tupdate();\n\t\t\t}\n\t\t};\n\t\ttimer.schedule(task, 1000, 2000);\n\t}\n\n\tpublic static void update() {\n\t\ttry {\n\t\t\tMyClassLoader2 loader = new MyClassLoader2();\n\t\t\tObject obj = loader.loadDirectly(\"space.kyu.TestClass\").newInstance();\n\t\t\tMethod doSomething = obj.getClass().getMethod(\"doSomething\", new Class[] {});\n\t\t\tdoSomething.invoke(obj, new Object[] {});\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n在HotSwapTest类中，我们模拟了一个定时升级的任务：每隔两秒执行一次升级，实例化一个MyClassLoader2对象并使用该类加载器加载space.kyu.TestClass，反射调用其doSomething方法打印字符串。\n\n编译并运行HotSwapTest，运行过程中，每隔两秒doSomething便打印字符串\"hello\"，此时修改space.kyu.TestClass源码，将打印字符串替换为\"world\"，CTRL+S，我们的程序并未停止，但是下一次打印出的字符串已然不同了：\n\n```\nhello\nhello\nhello\nhello\nhello\nworld\nworld\nworld\n\n```\n\n上面就是一个简单的热替换的例子。实际的应用中当然不是通过一个定时任务进行升级的。把新版本类的字节码通过网络传输到服务器上去，然后发送一个升级指令，使用上面类似的方法便可对类进行升级。\n\n## 参考\n\n[Java 类的热替换 —— 概念、设计与实现](https://www.ibm.com/developerworks/cn/java/j-lo-hotswapcls/)\n\n[深入探讨 Java 类加载器](https://www.ibm.com/developerworks/cn/java/j-lo-classloader/)","slug":"java类加载","published":1,"updated":"2017-04-11T13:08:38.844Z","comments":1,"photos":[],"link":"","_id":"cj4vch4f7002mx3gcinkla7np","content":"<blockquote>\n<p>本篇笔记的目标是理解类加载器的架构，学会实现类加载器并理解热替换的底层原理。</p>\n</blockquote>\n<h2 id=\"什么是类加载\"><a href=\"#什么是类加载\" class=\"headerlink\" title=\"什么是类加载\"></a>什么是类加载</h2><blockquote>\n<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，包括了以下几个生命周期：</p>\n</blockquote>\n<img src=\"/2017/04/06/java类加载/jiazai.png\" alt=\"jiazai\" title=\"jiazai\">\n<blockquote>\n<p>什么时候会触发类加载的第一个阶段(加载)？虚拟机规范没有强制规定，这一点依据不同的虚拟机实现来定。但对于初始化阶段，虚拟机规范规定了有且只有5种&gt;情况必须立即对类进行初始化(加载阶段自然要在此之前开始)：</p>\n<p>1.使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰的常量字段除外)、调用一个类的静态方法。</p>\n<p>2.使用反射方法对类进行调用</p>\n<p>3.初始化一个类的时候，发现其父类未初始化，则触发父类的初始化</p>\n<p>4.虚拟机启动时，用户需指定一个要执行的主类(包含main的那个类)，虚拟机先初始化该类</p>\n<p>5.当使用jdk1.7的动态语言支持时，如果一个java.lang.invoke。MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄所对应的类没有进行过初始化，则先触发其初始化(不懂…)</p>\n</blockquote>\n<p>–《深入理解jvm虚拟机》</p>\n<a id=\"more\"></a>\n<p>这篇笔记所要学习的内容，仅仅是类加载的第一个阶段：加载。在加载阶段，虚拟机会完成下面三件事：</p>\n<p>1.通过一个类的全限定名获取定义此类的二进制字节流</p>\n<p>2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>\n<p>3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口</p>\n<p>在上面的三个阶段中，<code>通过一个类的全限定名获取定义此类的二进制字节流</code> 是开发人员可以控制的部分，也是我们这篇笔记所要探讨的内容。</p>\n<p>虚拟机设计团队将<code>通过一个类的全限定名获取定义此类的二进制字节流</code>这个动作放到java虚拟机外部去实现，以便让应用程序自己决定去如何获取所需要的类。实现这个动作的代码模块被称为”类加载器”。<code>定义此类的二进制字节流</code>可以来自class文件、网络、zip包、或者运行时生成等。</p>\n<p>类加载器实现类的加载动作，比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使两个类源自于同一份class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那么这两个类必定不相等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassLocaderTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        Object testClassLoader1 = getMyClassLoader1();</div><div class=\"line\">        System.out.println(testClassLoader1.getClass());</div><div class=\"line\">\t\tSystem.out.println(testClassLoader1 <span class=\"keyword\">instanceof</span> space.kyu.TestClass);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Object <span class=\"title\">getMyClassLoader1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tObject obj = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tMyClassLoader1 loader = <span class=\"keyword\">new</span> MyClassLoader1();</div><div class=\"line\">\t\t\tobj = loader.loadClass(<span class=\"string\">\"space.kyu.TestClass\"</span>).newInstance();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> obj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoader1</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span></span>&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> Class&lt;?&gt; loadClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tString fileName = name.substring(name.lastIndexOf(<span class=\"string\">\".\"</span>) + <span class=\"number\">1</span>) + <span class=\"string\">\".class\"</span>;</div><div class=\"line\">\t\t\tInputStream stream = getClass().getResourceAsStream(fileName);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (stream == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"comment\">//\t\t\t\tSystem.out.println(\"ClassLoader load class\" + name);</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.loadClass(name);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] bs = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[stream.available()];</div><div class=\"line\">\t\t\tstream.read(bs);</div><div class=\"line\"><span class=\"comment\">//\t\t\tSystem.out.println(\"MyClassLoader1 load class: \" + name);</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> defineClass(name, bs, <span class=\"number\">0</span>, bs.length);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(name);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">class space.kyu.TestClass</div><div class=\"line\">false</div></pre></td></tr></table></figure>\n<p>在上面的例子中，虚拟机中存在两个space.kyu.TestClass类，一个是由系统应用程序类加载器加载的，一个是由我们自己实现的类加载器加载的。虽然来自同一个class文件，但依然是两个独立的类，故不相等。</p>\n<p>类加载器应用于类层次划分、OSGI、热部署、代码加密等方面。</p>\n<h2 id=\"类加载器层次结构\"><a href=\"#类加载器层次结构\" class=\"headerlink\" title=\"类加载器层次结构\"></a>类加载器层次结构</h2><p>从java虚拟机的角度来看，类加载器分为两类：</p>\n<p>1.启动类加载器</p>\n<p>  使用c++实现，是虚拟机自身的一部分</p>\n<p>2.其他类加载器</p>\n<p>  由java语言实现，独立于虚拟机外部，全都继承自抽象类java.lang.ClassLoader</p>\n<p>从类加载器的实现来看，类加载器又可分为系统提供的类加载器与我们自己实现的类加载器。系统提供的类加载器主要有三个：</p>\n<ul>\n<li><p>引导类加载器，用来加载java核心类库。主要是放在JAVA_HOME\\lib目录中或被-Xbootclasspath所指定的目录。</p>\n</li>\n<li><p>扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现。负责加载JAVA_HOME\\lib\\ext目录中，或java.ext.dirs所指定的路径中的类库。</p>\n</li>\n<li><p>应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现。这个类也是ClassLoader中getSystemClassLoader()方法的返回值。负责加载classpath上指定的类库。</p>\n</li>\n</ul>\n<p>除了系统提供的类加载器以外，我们可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。</p>\n<p>除了引导类加载器之外，所有的类加载器都有一个父类加载器。这种父子关系构成了类加载器的层次结构。</p>\n<p>对于系统提供的类加载器来说，应用程序类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器。</p>\n<p>因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。</p>\n<p>这种类加载器之间的层次关系，称为类加载器的双亲委派模型：</p>\n<img src=\"/2017/04/06/java类加载/classloader.png\" alt=\"classloader\" title=\"classloader\">\n<p>注意，上图中的树状结构并不意味着继承关系，而是使用委托实现的。</p>\n<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他会首先把这个请求委托给自己的父类加载器去完成，每一层次的加载器都是如此，最后所有的类加载请求最终都会传递到顶层的引导类加载器中去，只有当父类加载器无法完成这个加载请求(所请求加载的类不在 他加载的范围内)时，子类加载器会尝试自己加载。</p>\n<p>双亲委派机制保证了java核心类库的安全，如果尝试加载与rt.jar类库中已有的类重名的java类，该类永远无法被加载运行，因为请求被传递到引导类加载器之后，引导类加载器会返回加载到的rt.jar中的类。</p>\n<p>我们观察一下双亲委派机制的实现：</p>\n<p>首先看一下ClassLoader中的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">findLoadedClass：每个类加载器都维护有自己的一份已加载类名字空间，其中不能出现两个同名的类。凡是通过该类加载器加载的类，无论是直接的还是间接的，都保存在自己的名字空间中，该方法就是在该名字空间中寻找指定的类是否已存在，如果存在就返回给类的引用，否则就返回 null。这里的直接是指，存在于该类加载器的加载路径上并由该加载器完成加载，间接是指，由该类加载器把类的加载工作委托给其他类加载器完成类的实际加载。</div><div class=\"line\"></div><div class=\"line\">getSystemClassLoader：Java2 中新增的方法。该方法返回系统使用的 ClassLoader。可以在自己定制的类加载器中通过该方法把一部分工作转交给系统类加载器去处理。</div><div class=\"line\"></div><div class=\"line\">defineClass：该方法是 ClassLoader 中非常重要的一个方法，它接收以字节数组表示的类字节码，并把它转换成 Class 实例，该方法转换一个类的同时，会先要求装载该类的父类以及实现的接口类。</div><div class=\"line\"></div><div class=\"line\">loadClass：加载类的入口方法，调用该方法完成类的显式加载。通过对该方法的重新实现，我们可以完全控制和管理类的加载过程。</div><div class=\"line\"></div><div class=\"line\">findClass(String name):\t查找名称为 name的类，返回的结果是 java.lang.Class类的实例。</div><div class=\"line\"></div><div class=\"line\">resolveClass(Class&lt;?&gt; c): 链接指定的 Java 类。</div></pre></td></tr></table></figure>\n<p>实现双亲委派机制的代码集中在ClassLoader的loadClass方法中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"keyword\">boolean</span> resolve)</div><div class=\"line\">       <span class=\"keyword\">throws</span> ClassNotFoundException</div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</div><div class=\"line\">           <span class=\"comment\">// First, check if the class has already been loaded</span></div><div class=\"line\">           Class c = findLoadedClass(name);</div><div class=\"line\">           <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">               <span class=\"keyword\">long</span> t0 = System.nanoTime();</div><div class=\"line\">               <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                   <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                       c = parent.loadClass(name, <span class=\"keyword\">false</span>);</div><div class=\"line\">                   &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                       c = findBootstrapClassOrNull(name);</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</div><div class=\"line\">                   <span class=\"comment\">// ClassNotFoundException thrown if class not found</span></div><div class=\"line\">                   <span class=\"comment\">// from the non-null parent class loader</span></div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   <span class=\"comment\">// If still not found, then invoke findClass in order</span></div><div class=\"line\">                   <span class=\"comment\">// to find the class.</span></div><div class=\"line\">                   <span class=\"keyword\">long</span> t1 = System.nanoTime();</div><div class=\"line\">                   c = findClass(name);</div><div class=\"line\"></div><div class=\"line\">                   <span class=\"comment\">// this is the defining class loader; record the stats</span></div><div class=\"line\">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class=\"line\">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class=\"line\">                   sun.misc.PerfCounter.getFindClasses().increment();</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">if</span> (resolve) &#123;</div><div class=\"line\">               resolveClass(c);</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">return</span> c;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>先检查是否已经加载过，若没有则调用父类加载器的loadClass方法，若父类加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常后，则调用自己的findClass方法进行加载。</p>\n<h2 id=\"双亲委托机制的不足\"><a href=\"#双亲委托机制的不足\" class=\"headerlink\" title=\"双亲委托机制的不足\"></a>双亲委托机制的不足</h2><p>双亲委派机制很好的解决了各个类加载器的基础类统一的问题，基础类总是作为被用户代码调用的API（比如rt.jar中的类）。但是如果基础类要调用用户的代码时会发生什么？</p>\n<p>首先要搞明白一点：当我们使用 new 关键字或者 Class.forName 来加载类时，所要加载的类都是由调用 new 或者 Class.forName 的类的类加载器进行加载的。比如我们使用JDBC标准接口时，JDBC标准接口存在于rt.jar中，在这个接口中又需要调用各个数据库厂商提供的jdbc驱动程序来达到管理驱动的目的，这些驱动程序的jar包一般置于claspath路径下。问题出现了：JDBC标准接口是由引导类加载器加载的，故在这些接口中调用classpath路径下的jdbc驱动代码时，也会尝试使用引导类加载器进行加载。但是引导类加载器根本不可能认识这些代码(只负责rt.jar)。</p>\n<p>为了解决这个问题，引入了线程上下文类加载器。</p>\n<p>这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时没有设置，将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置，那么这个类加载器默认就是应用程序类加载器。</p>\n<p>使用java.lang.Thread.getContextClassLoader()可以获得线程上下文类加载器，故可以使用这个加载器加载classpath路径下的代码，也就是父类加载器请求子类加载器完成类加载动作，破坏了双亲委托模型。</p>\n<h2 id=\"实现自己的类加载器\"><a href=\"#实现自己的类加载器\" class=\"headerlink\" title=\"实现自己的类加载器\"></a>实现自己的类加载器</h2><p>上面提到的系统提供的类加载器在大多数情况下可以满足我们的需求，但是在某些情况下，我们需要开发自己的类加载器，比如，加载网络传输得到的类字节码、对字节码进行加密解码、加载运行时生成的字节码、实现类的热替换等。这些情况下类的字节码仅仅依靠上述的三种系统类加载器是无法加载的。</p>\n<p>我自己实现了一些测试代码，现在将他们贴到这里，顺便对前面的总结做一个印证。下面的几个类都位于包space.kyu下面：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoader1</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span></span>&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> Class&lt;?&gt; loadClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tString fileName = name.substring(name.lastIndexOf(<span class=\"string\">\".\"</span>) + <span class=\"number\">1</span>) + <span class=\"string\">\".class\"</span>;</div><div class=\"line\">\t\t\tInputStream stream = getClass().getResourceAsStream(fileName);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (stream == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"comment\">//\t\t\t\tSystem.out.println(\"ClassLoader load class\" + name);</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.loadClass(name);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] bs = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[stream.available()];</div><div class=\"line\">\t\t\tstream.read(bs);</div><div class=\"line\"><span class=\"comment\">//\t\t\tSystem.out.println(\"MyClassLoader1 load class: \" + name);</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> defineClass(name, bs, <span class=\"number\">0</span>, bs.length);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(name);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoader2</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> Class&lt;?&gt; loadDirectly(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tString fileName = name.substring(name.lastIndexOf(<span class=\"string\">\".\"</span>) + <span class=\"number\">1</span>) + <span class=\"string\">\".class\"</span>;</div><div class=\"line\">\t\t\tInputStream stream = getClass().getResourceAsStream(fileName);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (stream == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"comment\">//\t\t\t\tSystem.out.println(\"ClassLoader load class\" + name);</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.loadClass(name);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] bs = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[stream.available()];</div><div class=\"line\">\t\t\tstream.read(bs);</div><div class=\"line\"><span class=\"comment\">//\t\t\tSystem.out.println(\"MyClassLoader2 load class: \" + name);</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> defineClass(name, bs, <span class=\"number\">0</span>, bs.length);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(name);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Operation</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> String str;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.str = str;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">Operation</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> Test test;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Test <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\ttest = <span class=\"keyword\">new</span> Test(<span class=\"string\">\"haha\"</span>);</div><div class=\"line\">\t\tSystem.out.println(test.str);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> test;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassLocaderTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tObject testClassLoader1 = getMyClassLoader1();</div><div class=\"line\">\t\tObject testClassLoader2 = getMyClassLoader2();</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"*****************testClassLoader1*******************\"</span>);</div><div class=\"line\">\t\tprintClassLoader(testClassLoader1);</div><div class=\"line\">\t\treflectInvoke(testClassLoader1);</div><div class=\"line\">\t\tinterfaceInvoke(testClassLoader1);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"*****************testClassLoader2*******************\"</span>);</div><div class=\"line\">\t\tprintClassLoader(testClassLoader2);</div><div class=\"line\">\t\treflectInvoke(testClassLoader2);</div><div class=\"line\">\t\tinterfaceInvoke(testClassLoader2);</div><div class=\"line\">        </div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printClassLoader</span><span class=\"params\">(Object object)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"*********printClassLoader:\"</span>);</div><div class=\"line\">\t\tClassLoader classLoader = object.getClass().getClassLoader();</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (classLoader != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(classLoader);</div><div class=\"line\">\t\t\tclassLoader = classLoader.getParent();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">reflectInvoke</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"*********reflectInvoke:\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tMethod test = obj.getClass().getMethod(<span class=\"string\">\"test\"</span>, <span class=\"keyword\">new</span> Class[] &#123;&#125;);</div><div class=\"line\">\t\t\ttest.invoke(obj, <span class=\"keyword\">new</span> Object[] &#123;&#125;);</div><div class=\"line\">\t\t\tMethod doSomething = obj.getClass().getMethod(<span class=\"string\">\"doSomething\"</span>, <span class=\"keyword\">new</span> Class[] &#123;&#125;);</div><div class=\"line\">\t\t\tdoSomething.invoke(obj, <span class=\"keyword\">new</span> Object[] &#123;&#125;);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</div><div class=\"line\">\t\t\tThrowable t = e.getTargetException();<span class=\"comment\">// 获取目标异常</span></div><div class=\"line\">\t\t\tSystem.out.println(t);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">interfaceInvoke</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"*********interfaceInvoke:\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tOperation operation = (Operation) obj;</div><div class=\"line\">\t\t\toperation.doSomething();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> Object <span class=\"title\">getMyClassLoader1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tObject obj = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tMyClassLoader1 loader = <span class=\"keyword\">new</span> MyClassLoader1();</div><div class=\"line\">\t\t\tobj = loader.loadClass(<span class=\"string\">\"space.kyu.TestClass\"</span>).newInstance();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> obj;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> Object <span class=\"title\">getMyClassLoader2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tObject obj = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tMyClassLoader2 loader = <span class=\"keyword\">new</span> MyClassLoader2();</div><div class=\"line\">\t\t\tobj = loader.loadDirectly(<span class=\"string\">\"space.kyu.TestClass\"</span>).newInstance();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> obj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述六个类位于space.kyu下不同的类文件当中。ClassLocaderTest运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">*****************testClassLoader1*******************</div><div class=\"line\">*********printClassLoader:</div><div class=\"line\">space.kyu.MyClassLoader1@76e2d0ab</div><div class=\"line\">sun.misc.Launcher$AppClassLoader@52a53948</div><div class=\"line\">sun.misc.Launcher$ExtClassLoader@5d53d05b</div><div class=\"line\">*********reflectInvoke:</div><div class=\"line\">haha</div><div class=\"line\">hello</div><div class=\"line\">*********interfaceInvoke:</div><div class=\"line\">java.lang.ClassCastException: space.kyu.TestClass cannot be cast to space.kyu.Operation</div><div class=\"line\">*****************testClassLoader2*******************</div><div class=\"line\">*********printClassLoader:</div><div class=\"line\">space.kyu.MyClassLoader2@6c618821</div><div class=\"line\">sun.misc.Launcher$AppClassLoader@52a53948</div><div class=\"line\">sun.misc.Launcher$ExtClassLoader@5d53d05b</div><div class=\"line\">*********reflectInvoke:</div><div class=\"line\">haha</div><div class=\"line\">hello</div><div class=\"line\">*********interfaceInvoke:</div><div class=\"line\">hello</div></pre></td></tr></table></figure>\n<p>一般来说，我们自己开发的类加载器只要继承ClassLoader并覆盖findClass方法即可。这样的话就会自动使用双亲委派机制，我们可以在findClass方法中填写我们自己的加载逻辑：从网络上或者是硬盘上加载一个类的字节码。</p>\n<p>上面的例子中并没有使用这个套路，MyClassLoader1直接复写loadClass方法，MyClassLoader2添加了方法loadDirectly，如果不这样做的话，我们在加载space.kyu.TestClass这个类的时候，因为这个类在classpath上，由于双亲委派机制，这个类会被应用程序类加载器先进行加载，达不到测试的效果。</p>\n<ul>\n<li><p>观察上面printClassLoader部分，通过getParent方法打印了类加载器的层次结构。可见虽然我们并未显示指定这两个自定义加载器的父类加载器，但是他们的父类加载器已经被默认设置为sun.misc.Launcher$AppClassLoader，也就是加载这两个个自定义类加载器所使用的加载器。印证上面的结论：<code>对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。</code></p>\n</li>\n<li><p>reflectInvoke方法是使用反射机制调用了加载出来类的方法，如果去掉上面自定义类加载器中注掉的System.out方法，就会看到，在反射调用TestClass的test方法的时候，类加载器加载了space.kyu.Test这个类，并且加载他的类加载器正是我们自定义的类加载器，印证了我们上面的结论：<code>当我们使用 new 关键字或者 Class.forName 来加载类时，所要加载的类都是由调用 new 或者 Class.forName 的类的类加载器进行加载的</code></p>\n</li>\n<li><p>思考上面的反射用法，为什么不直接将getMyClassLoader1()方法返回的Object对象强转为space.kyu.TestClass呢？比如这样：</p>\n<p><code>space.kyu.TestClass testClass = (TestClass)getMyClassLoader1();</code></p>\n<p>编译并没有问题，但是在运行时就会报错：java.lang.ClassCastException</p>\n<p>为什么会出现这样的结果呢？其实从这篇文章的一开始就已经演示过了。<code>space.kyu.TestClass testClass</code>这个类是通过应用程序类加载器加载的，而<code>getMyClassLoader1()</code>方法得到的是我们自定义类加载器加载的类，这两个类是不相等的(虽然名字相同)，所以强转失败。</p>\n</li>\n<li><p>接下来看interfaceInvoke这部分。将自定义类加载器加载得到的对象强转为了接口类型。注意到，MyClassLoader1加载的类对象在强转时抛出异常，而MyClassLoader2可以正常强转并调用接口方法。</p>\n<p>MyClassLoader1加载的类为什么强转失败？原因在于，MyClassLoader1在加载TestClass类时，触发其父类接口Operation的加载，此时默认使用MyClassLoader1加载Operation类。在MyClassLoader1中我们覆盖了loadClass方法，故加载Operation时也会调用我们自己实现的loadClass方法进行加载。</p>\n<p>同样的，MyClassLoader2在加载TestClass类时，也触发其父类接口Operation的加载，此时默认使用MyClassLoader2加载Operation类。不同之处在于我们并未覆盖loadClass方法，加载Operation时调用了ClassLoader中的loadClass方法，在这个方法的实现中，由应用程序类加载器加载了Operation类。</p>\n<p>所以，出现上面结果的原因也就一目了然了。</p>\n</li>\n</ul>\n<h2 id=\"类加载器与热替换\"><a href=\"#类加载器与热替换\" class=\"headerlink\" title=\"类加载器与热替换\"></a>类加载器与热替换</h2><p>普通的java应用中不能实现类的热替换的原因在于同名类的不同版本的实例不能共存，因为使用了默认的类加载机制后，一个类只会被加载一次，再次请求加载时直接返回之前加载的缓存(findLoadedClass)。故我们重新编译生成<br>的class文件并不会被重新读取并加载。</p>\n<p>为了绕过这个加载机制，我们可以通过不同的类加载器来加载该类的不同版本。</p>\n<p>在space.kyu包下面新增一个类HotSwapTest：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HotSwapTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tTimer timer = <span class=\"keyword\">new</span> Timer(<span class=\"keyword\">false</span>);</div><div class=\"line\">\t\tTimerTask task = <span class=\"keyword\">new</span> TimerTask() &#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\tupdate();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\ttimer.schedule(task, <span class=\"number\">1000</span>, <span class=\"number\">2000</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tMyClassLoader2 loader = <span class=\"keyword\">new</span> MyClassLoader2();</div><div class=\"line\">\t\t\tObject obj = loader.loadDirectly(<span class=\"string\">\"space.kyu.TestClass\"</span>).newInstance();</div><div class=\"line\">\t\t\tMethod doSomething = obj.getClass().getMethod(<span class=\"string\">\"doSomething\"</span>, <span class=\"keyword\">new</span> Class[] &#123;&#125;);</div><div class=\"line\">\t\t\tdoSomething.invoke(obj, <span class=\"keyword\">new</span> Object[] &#123;&#125;);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在HotSwapTest类中，我们模拟了一个定时升级的任务：每隔两秒执行一次升级，实例化一个MyClassLoader2对象并使用该类加载器加载space.kyu.TestClass，反射调用其doSomething方法打印字符串。</p>\n<p>编译并运行HotSwapTest，运行过程中，每隔两秒doSomething便打印字符串”hello”，此时修改space.kyu.TestClass源码，将打印字符串替换为”world”，CTRL+S，我们的程序并未停止，但是下一次打印出的字符串已然不同了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">hello</div><div class=\"line\">hello</div><div class=\"line\">hello</div><div class=\"line\">hello</div><div class=\"line\">hello</div><div class=\"line\">world</div><div class=\"line\">world</div><div class=\"line\">world</div></pre></td></tr></table></figure>\n<p>上面就是一个简单的热替换的例子。实际的应用中当然不是通过一个定时任务进行升级的。把新版本类的字节码通过网络传输到服务器上去，然后发送一个升级指令，使用上面类似的方法便可对类进行升级。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-hotswapcls/\" target=\"_blank\" rel=\"external\">Java 类的热替换 —— 概念、设计与实现</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-classloader/\" target=\"_blank\" rel=\"external\">深入探讨 Java 类加载器</a></p>\n","excerpt":"<blockquote>\n<p>本篇笔记的目标是理解类加载器的架构，学会实现类加载器并理解热替换的底层原理。</p>\n</blockquote>\n<h2 id=\"什么是类加载\"><a href=\"#什么是类加载\" class=\"headerlink\" title=\"什么是类加载\"></a>什么是类加载</h2><blockquote>\n<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，包括了以下几个生命周期：</p>\n</blockquote>\n<img src=\"/2017/04/06/java类加载/jiazai.png\" alt=\"jiazai\" title=\"jiazai\">\n<blockquote>\n<p>什么时候会触发类加载的第一个阶段(加载)？虚拟机规范没有强制规定，这一点依据不同的虚拟机实现来定。但对于初始化阶段，虚拟机规范规定了有且只有5种&gt;情况必须立即对类进行初始化(加载阶段自然要在此之前开始)：</p>\n<p>1.使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰的常量字段除外)、调用一个类的静态方法。</p>\n<p>2.使用反射方法对类进行调用</p>\n<p>3.初始化一个类的时候，发现其父类未初始化，则触发父类的初始化</p>\n<p>4.虚拟机启动时，用户需指定一个要执行的主类(包含main的那个类)，虚拟机先初始化该类</p>\n<p>5.当使用jdk1.7的动态语言支持时，如果一个java.lang.invoke。MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄所对应的类没有进行过初始化，则先触发其初始化(不懂…)</p>\n</blockquote>\n<p>–《深入理解jvm虚拟机》</p>","more":"<p>这篇笔记所要学习的内容，仅仅是类加载的第一个阶段：加载。在加载阶段，虚拟机会完成下面三件事：</p>\n<p>1.通过一个类的全限定名获取定义此类的二进制字节流</p>\n<p>2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>\n<p>3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口</p>\n<p>在上面的三个阶段中，<code>通过一个类的全限定名获取定义此类的二进制字节流</code> 是开发人员可以控制的部分，也是我们这篇笔记所要探讨的内容。</p>\n<p>虚拟机设计团队将<code>通过一个类的全限定名获取定义此类的二进制字节流</code>这个动作放到java虚拟机外部去实现，以便让应用程序自己决定去如何获取所需要的类。实现这个动作的代码模块被称为”类加载器”。<code>定义此类的二进制字节流</code>可以来自class文件、网络、zip包、或者运行时生成等。</p>\n<p>类加载器实现类的加载动作，比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使两个类源自于同一份class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那么这两个类必定不相等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassLocaderTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        Object testClassLoader1 = getMyClassLoader1();</div><div class=\"line\">        System.out.println(testClassLoader1.getClass());</div><div class=\"line\">\t\tSystem.out.println(testClassLoader1 <span class=\"keyword\">instanceof</span> space.kyu.TestClass);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Object <span class=\"title\">getMyClassLoader1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tObject obj = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tMyClassLoader1 loader = <span class=\"keyword\">new</span> MyClassLoader1();</div><div class=\"line\">\t\t\tobj = loader.loadClass(<span class=\"string\">\"space.kyu.TestClass\"</span>).newInstance();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> obj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoader1</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span></span>&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> Class&lt;?&gt; loadClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tString fileName = name.substring(name.lastIndexOf(<span class=\"string\">\".\"</span>) + <span class=\"number\">1</span>) + <span class=\"string\">\".class\"</span>;</div><div class=\"line\">\t\t\tInputStream stream = getClass().getResourceAsStream(fileName);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (stream == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"comment\">//\t\t\t\tSystem.out.println(\"ClassLoader load class\" + name);</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.loadClass(name);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] bs = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[stream.available()];</div><div class=\"line\">\t\t\tstream.read(bs);</div><div class=\"line\"><span class=\"comment\">//\t\t\tSystem.out.println(\"MyClassLoader1 load class: \" + name);</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> defineClass(name, bs, <span class=\"number\">0</span>, bs.length);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(name);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">class space.kyu.TestClass</div><div class=\"line\">false</div></pre></td></tr></table></figure>\n<p>在上面的例子中，虚拟机中存在两个space.kyu.TestClass类，一个是由系统应用程序类加载器加载的，一个是由我们自己实现的类加载器加载的。虽然来自同一个class文件，但依然是两个独立的类，故不相等。</p>\n<p>类加载器应用于类层次划分、OSGI、热部署、代码加密等方面。</p>\n<h2 id=\"类加载器层次结构\"><a href=\"#类加载器层次结构\" class=\"headerlink\" title=\"类加载器层次结构\"></a>类加载器层次结构</h2><p>从java虚拟机的角度来看，类加载器分为两类：</p>\n<p>1.启动类加载器</p>\n<p>  使用c++实现，是虚拟机自身的一部分</p>\n<p>2.其他类加载器</p>\n<p>  由java语言实现，独立于虚拟机外部，全都继承自抽象类java.lang.ClassLoader</p>\n<p>从类加载器的实现来看，类加载器又可分为系统提供的类加载器与我们自己实现的类加载器。系统提供的类加载器主要有三个：</p>\n<ul>\n<li><p>引导类加载器，用来加载java核心类库。主要是放在JAVA_HOME\\lib目录中或被-Xbootclasspath所指定的目录。</p>\n</li>\n<li><p>扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现。负责加载JAVA_HOME\\lib\\ext目录中，或java.ext.dirs所指定的路径中的类库。</p>\n</li>\n<li><p>应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现。这个类也是ClassLoader中getSystemClassLoader()方法的返回值。负责加载classpath上指定的类库。</p>\n</li>\n</ul>\n<p>除了系统提供的类加载器以外，我们可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。</p>\n<p>除了引导类加载器之外，所有的类加载器都有一个父类加载器。这种父子关系构成了类加载器的层次结构。</p>\n<p>对于系统提供的类加载器来说，应用程序类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器。</p>\n<p>因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。</p>\n<p>这种类加载器之间的层次关系，称为类加载器的双亲委派模型：</p>\n<img src=\"/2017/04/06/java类加载/classloader.png\" alt=\"classloader\" title=\"classloader\">\n<p>注意，上图中的树状结构并不意味着继承关系，而是使用委托实现的。</p>\n<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他会首先把这个请求委托给自己的父类加载器去完成，每一层次的加载器都是如此，最后所有的类加载请求最终都会传递到顶层的引导类加载器中去，只有当父类加载器无法完成这个加载请求(所请求加载的类不在 他加载的范围内)时，子类加载器会尝试自己加载。</p>\n<p>双亲委派机制保证了java核心类库的安全，如果尝试加载与rt.jar类库中已有的类重名的java类，该类永远无法被加载运行，因为请求被传递到引导类加载器之后，引导类加载器会返回加载到的rt.jar中的类。</p>\n<p>我们观察一下双亲委派机制的实现：</p>\n<p>首先看一下ClassLoader中的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">findLoadedClass：每个类加载器都维护有自己的一份已加载类名字空间，其中不能出现两个同名的类。凡是通过该类加载器加载的类，无论是直接的还是间接的，都保存在自己的名字空间中，该方法就是在该名字空间中寻找指定的类是否已存在，如果存在就返回给类的引用，否则就返回 null。这里的直接是指，存在于该类加载器的加载路径上并由该加载器完成加载，间接是指，由该类加载器把类的加载工作委托给其他类加载器完成类的实际加载。</div><div class=\"line\"></div><div class=\"line\">getSystemClassLoader：Java2 中新增的方法。该方法返回系统使用的 ClassLoader。可以在自己定制的类加载器中通过该方法把一部分工作转交给系统类加载器去处理。</div><div class=\"line\"></div><div class=\"line\">defineClass：该方法是 ClassLoader 中非常重要的一个方法，它接收以字节数组表示的类字节码，并把它转换成 Class 实例，该方法转换一个类的同时，会先要求装载该类的父类以及实现的接口类。</div><div class=\"line\"></div><div class=\"line\">loadClass：加载类的入口方法，调用该方法完成类的显式加载。通过对该方法的重新实现，我们可以完全控制和管理类的加载过程。</div><div class=\"line\"></div><div class=\"line\">findClass(String name):\t查找名称为 name的类，返回的结果是 java.lang.Class类的实例。</div><div class=\"line\"></div><div class=\"line\">resolveClass(Class&lt;?&gt; c): 链接指定的 Java 类。</div></pre></td></tr></table></figure>\n<p>实现双亲委派机制的代码集中在ClassLoader的loadClass方法中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"keyword\">boolean</span> resolve)</div><div class=\"line\">       <span class=\"keyword\">throws</span> ClassNotFoundException</div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</div><div class=\"line\">           <span class=\"comment\">// First, check if the class has already been loaded</span></div><div class=\"line\">           Class c = findLoadedClass(name);</div><div class=\"line\">           <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">               <span class=\"keyword\">long</span> t0 = System.nanoTime();</div><div class=\"line\">               <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                   <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                       c = parent.loadClass(name, <span class=\"keyword\">false</span>);</div><div class=\"line\">                   &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                       c = findBootstrapClassOrNull(name);</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</div><div class=\"line\">                   <span class=\"comment\">// ClassNotFoundException thrown if class not found</span></div><div class=\"line\">                   <span class=\"comment\">// from the non-null parent class loader</span></div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   <span class=\"comment\">// If still not found, then invoke findClass in order</span></div><div class=\"line\">                   <span class=\"comment\">// to find the class.</span></div><div class=\"line\">                   <span class=\"keyword\">long</span> t1 = System.nanoTime();</div><div class=\"line\">                   c = findClass(name);</div><div class=\"line\"></div><div class=\"line\">                   <span class=\"comment\">// this is the defining class loader; record the stats</span></div><div class=\"line\">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class=\"line\">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class=\"line\">                   sun.misc.PerfCounter.getFindClasses().increment();</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">if</span> (resolve) &#123;</div><div class=\"line\">               resolveClass(c);</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">return</span> c;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>先检查是否已经加载过，若没有则调用父类加载器的loadClass方法，若父类加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常后，则调用自己的findClass方法进行加载。</p>\n<h2 id=\"双亲委托机制的不足\"><a href=\"#双亲委托机制的不足\" class=\"headerlink\" title=\"双亲委托机制的不足\"></a>双亲委托机制的不足</h2><p>双亲委派机制很好的解决了各个类加载器的基础类统一的问题，基础类总是作为被用户代码调用的API（比如rt.jar中的类）。但是如果基础类要调用用户的代码时会发生什么？</p>\n<p>首先要搞明白一点：当我们使用 new 关键字或者 Class.forName 来加载类时，所要加载的类都是由调用 new 或者 Class.forName 的类的类加载器进行加载的。比如我们使用JDBC标准接口时，JDBC标准接口存在于rt.jar中，在这个接口中又需要调用各个数据库厂商提供的jdbc驱动程序来达到管理驱动的目的，这些驱动程序的jar包一般置于claspath路径下。问题出现了：JDBC标准接口是由引导类加载器加载的，故在这些接口中调用classpath路径下的jdbc驱动代码时，也会尝试使用引导类加载器进行加载。但是引导类加载器根本不可能认识这些代码(只负责rt.jar)。</p>\n<p>为了解决这个问题，引入了线程上下文类加载器。</p>\n<p>这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时没有设置，将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置，那么这个类加载器默认就是应用程序类加载器。</p>\n<p>使用java.lang.Thread.getContextClassLoader()可以获得线程上下文类加载器，故可以使用这个加载器加载classpath路径下的代码，也就是父类加载器请求子类加载器完成类加载动作，破坏了双亲委托模型。</p>\n<h2 id=\"实现自己的类加载器\"><a href=\"#实现自己的类加载器\" class=\"headerlink\" title=\"实现自己的类加载器\"></a>实现自己的类加载器</h2><p>上面提到的系统提供的类加载器在大多数情况下可以满足我们的需求，但是在某些情况下，我们需要开发自己的类加载器，比如，加载网络传输得到的类字节码、对字节码进行加密解码、加载运行时生成的字节码、实现类的热替换等。这些情况下类的字节码仅仅依靠上述的三种系统类加载器是无法加载的。</p>\n<p>我自己实现了一些测试代码，现在将他们贴到这里，顺便对前面的总结做一个印证。下面的几个类都位于包space.kyu下面：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoader1</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span></span>&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> Class&lt;?&gt; loadClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tString fileName = name.substring(name.lastIndexOf(<span class=\"string\">\".\"</span>) + <span class=\"number\">1</span>) + <span class=\"string\">\".class\"</span>;</div><div class=\"line\">\t\t\tInputStream stream = getClass().getResourceAsStream(fileName);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (stream == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"comment\">//\t\t\t\tSystem.out.println(\"ClassLoader load class\" + name);</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.loadClass(name);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] bs = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[stream.available()];</div><div class=\"line\">\t\t\tstream.read(bs);</div><div class=\"line\"><span class=\"comment\">//\t\t\tSystem.out.println(\"MyClassLoader1 load class: \" + name);</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> defineClass(name, bs, <span class=\"number\">0</span>, bs.length);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(name);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoader2</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> Class&lt;?&gt; loadDirectly(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tString fileName = name.substring(name.lastIndexOf(<span class=\"string\">\".\"</span>) + <span class=\"number\">1</span>) + <span class=\"string\">\".class\"</span>;</div><div class=\"line\">\t\t\tInputStream stream = getClass().getResourceAsStream(fileName);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (stream == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"comment\">//\t\t\t\tSystem.out.println(\"ClassLoader load class\" + name);</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.loadClass(name);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] bs = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[stream.available()];</div><div class=\"line\">\t\t\tstream.read(bs);</div><div class=\"line\"><span class=\"comment\">//\t\t\tSystem.out.println(\"MyClassLoader2 load class: \" + name);</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> defineClass(name, bs, <span class=\"number\">0</span>, bs.length);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(name);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Operation</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> String str;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.str = str;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(str);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">Operation</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> Test test;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Test <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\ttest = <span class=\"keyword\">new</span> Test(<span class=\"string\">\"haha\"</span>);</div><div class=\"line\">\t\tSystem.out.println(test.str);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> test;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassLocaderTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tObject testClassLoader1 = getMyClassLoader1();</div><div class=\"line\">\t\tObject testClassLoader2 = getMyClassLoader2();</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"*****************testClassLoader1*******************\"</span>);</div><div class=\"line\">\t\tprintClassLoader(testClassLoader1);</div><div class=\"line\">\t\treflectInvoke(testClassLoader1);</div><div class=\"line\">\t\tinterfaceInvoke(testClassLoader1);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"*****************testClassLoader2*******************\"</span>);</div><div class=\"line\">\t\tprintClassLoader(testClassLoader2);</div><div class=\"line\">\t\treflectInvoke(testClassLoader2);</div><div class=\"line\">\t\tinterfaceInvoke(testClassLoader2);</div><div class=\"line\">        </div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printClassLoader</span><span class=\"params\">(Object object)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"*********printClassLoader:\"</span>);</div><div class=\"line\">\t\tClassLoader classLoader = object.getClass().getClassLoader();</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (classLoader != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(classLoader);</div><div class=\"line\">\t\t\tclassLoader = classLoader.getParent();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">reflectInvoke</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"*********reflectInvoke:\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tMethod test = obj.getClass().getMethod(<span class=\"string\">\"test\"</span>, <span class=\"keyword\">new</span> Class[] &#123;&#125;);</div><div class=\"line\">\t\t\ttest.invoke(obj, <span class=\"keyword\">new</span> Object[] &#123;&#125;);</div><div class=\"line\">\t\t\tMethod doSomething = obj.getClass().getMethod(<span class=\"string\">\"doSomething\"</span>, <span class=\"keyword\">new</span> Class[] &#123;&#125;);</div><div class=\"line\">\t\t\tdoSomething.invoke(obj, <span class=\"keyword\">new</span> Object[] &#123;&#125;);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</div><div class=\"line\">\t\t\tThrowable t = e.getTargetException();<span class=\"comment\">// 获取目标异常</span></div><div class=\"line\">\t\t\tSystem.out.println(t);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">interfaceInvoke</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"*********interfaceInvoke:\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tOperation operation = (Operation) obj;</div><div class=\"line\">\t\t\toperation.doSomething();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> Object <span class=\"title\">getMyClassLoader1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tObject obj = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tMyClassLoader1 loader = <span class=\"keyword\">new</span> MyClassLoader1();</div><div class=\"line\">\t\t\tobj = loader.loadClass(<span class=\"string\">\"space.kyu.TestClass\"</span>).newInstance();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> obj;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> Object <span class=\"title\">getMyClassLoader2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tObject obj = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tMyClassLoader2 loader = <span class=\"keyword\">new</span> MyClassLoader2();</div><div class=\"line\">\t\t\tobj = loader.loadDirectly(<span class=\"string\">\"space.kyu.TestClass\"</span>).newInstance();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> obj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述六个类位于space.kyu下不同的类文件当中。ClassLocaderTest运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">*****************testClassLoader1*******************</div><div class=\"line\">*********printClassLoader:</div><div class=\"line\">space.kyu.MyClassLoader1@76e2d0ab</div><div class=\"line\">sun.misc.Launcher$AppClassLoader@52a53948</div><div class=\"line\">sun.misc.Launcher$ExtClassLoader@5d53d05b</div><div class=\"line\">*********reflectInvoke:</div><div class=\"line\">haha</div><div class=\"line\">hello</div><div class=\"line\">*********interfaceInvoke:</div><div class=\"line\">java.lang.ClassCastException: space.kyu.TestClass cannot be cast to space.kyu.Operation</div><div class=\"line\">*****************testClassLoader2*******************</div><div class=\"line\">*********printClassLoader:</div><div class=\"line\">space.kyu.MyClassLoader2@6c618821</div><div class=\"line\">sun.misc.Launcher$AppClassLoader@52a53948</div><div class=\"line\">sun.misc.Launcher$ExtClassLoader@5d53d05b</div><div class=\"line\">*********reflectInvoke:</div><div class=\"line\">haha</div><div class=\"line\">hello</div><div class=\"line\">*********interfaceInvoke:</div><div class=\"line\">hello</div></pre></td></tr></table></figure>\n<p>一般来说，我们自己开发的类加载器只要继承ClassLoader并覆盖findClass方法即可。这样的话就会自动使用双亲委派机制，我们可以在findClass方法中填写我们自己的加载逻辑：从网络上或者是硬盘上加载一个类的字节码。</p>\n<p>上面的例子中并没有使用这个套路，MyClassLoader1直接复写loadClass方法，MyClassLoader2添加了方法loadDirectly，如果不这样做的话，我们在加载space.kyu.TestClass这个类的时候，因为这个类在classpath上，由于双亲委派机制，这个类会被应用程序类加载器先进行加载，达不到测试的效果。</p>\n<ul>\n<li><p>观察上面printClassLoader部分，通过getParent方法打印了类加载器的层次结构。可见虽然我们并未显示指定这两个自定义加载器的父类加载器，但是他们的父类加载器已经被默认设置为sun.misc.Launcher$AppClassLoader，也就是加载这两个个自定义类加载器所使用的加载器。印证上面的结论：<code>对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。</code></p>\n</li>\n<li><p>reflectInvoke方法是使用反射机制调用了加载出来类的方法，如果去掉上面自定义类加载器中注掉的System.out方法，就会看到，在反射调用TestClass的test方法的时候，类加载器加载了space.kyu.Test这个类，并且加载他的类加载器正是我们自定义的类加载器，印证了我们上面的结论：<code>当我们使用 new 关键字或者 Class.forName 来加载类时，所要加载的类都是由调用 new 或者 Class.forName 的类的类加载器进行加载的</code></p>\n</li>\n<li><p>思考上面的反射用法，为什么不直接将getMyClassLoader1()方法返回的Object对象强转为space.kyu.TestClass呢？比如这样：</p>\n<p><code>space.kyu.TestClass testClass = (TestClass)getMyClassLoader1();</code></p>\n<p>编译并没有问题，但是在运行时就会报错：java.lang.ClassCastException</p>\n<p>为什么会出现这样的结果呢？其实从这篇文章的一开始就已经演示过了。<code>space.kyu.TestClass testClass</code>这个类是通过应用程序类加载器加载的，而<code>getMyClassLoader1()</code>方法得到的是我们自定义类加载器加载的类，这两个类是不相等的(虽然名字相同)，所以强转失败。</p>\n</li>\n<li><p>接下来看interfaceInvoke这部分。将自定义类加载器加载得到的对象强转为了接口类型。注意到，MyClassLoader1加载的类对象在强转时抛出异常，而MyClassLoader2可以正常强转并调用接口方法。</p>\n<p>MyClassLoader1加载的类为什么强转失败？原因在于，MyClassLoader1在加载TestClass类时，触发其父类接口Operation的加载，此时默认使用MyClassLoader1加载Operation类。在MyClassLoader1中我们覆盖了loadClass方法，故加载Operation时也会调用我们自己实现的loadClass方法进行加载。</p>\n<p>同样的，MyClassLoader2在加载TestClass类时，也触发其父类接口Operation的加载，此时默认使用MyClassLoader2加载Operation类。不同之处在于我们并未覆盖loadClass方法，加载Operation时调用了ClassLoader中的loadClass方法，在这个方法的实现中，由应用程序类加载器加载了Operation类。</p>\n<p>所以，出现上面结果的原因也就一目了然了。</p>\n</li>\n</ul>\n<h2 id=\"类加载器与热替换\"><a href=\"#类加载器与热替换\" class=\"headerlink\" title=\"类加载器与热替换\"></a>类加载器与热替换</h2><p>普通的java应用中不能实现类的热替换的原因在于同名类的不同版本的实例不能共存，因为使用了默认的类加载机制后，一个类只会被加载一次，再次请求加载时直接返回之前加载的缓存(findLoadedClass)。故我们重新编译生成<br>的class文件并不会被重新读取并加载。</p>\n<p>为了绕过这个加载机制，我们可以通过不同的类加载器来加载该类的不同版本。</p>\n<p>在space.kyu包下面新增一个类HotSwapTest：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HotSwapTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tTimer timer = <span class=\"keyword\">new</span> Timer(<span class=\"keyword\">false</span>);</div><div class=\"line\">\t\tTimerTask task = <span class=\"keyword\">new</span> TimerTask() &#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\tupdate();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\ttimer.schedule(task, <span class=\"number\">1000</span>, <span class=\"number\">2000</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tMyClassLoader2 loader = <span class=\"keyword\">new</span> MyClassLoader2();</div><div class=\"line\">\t\t\tObject obj = loader.loadDirectly(<span class=\"string\">\"space.kyu.TestClass\"</span>).newInstance();</div><div class=\"line\">\t\t\tMethod doSomething = obj.getClass().getMethod(<span class=\"string\">\"doSomething\"</span>, <span class=\"keyword\">new</span> Class[] &#123;&#125;);</div><div class=\"line\">\t\t\tdoSomething.invoke(obj, <span class=\"keyword\">new</span> Object[] &#123;&#125;);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在HotSwapTest类中，我们模拟了一个定时升级的任务：每隔两秒执行一次升级，实例化一个MyClassLoader2对象并使用该类加载器加载space.kyu.TestClass，反射调用其doSomething方法打印字符串。</p>\n<p>编译并运行HotSwapTest，运行过程中，每隔两秒doSomething便打印字符串”hello”，此时修改space.kyu.TestClass源码，将打印字符串替换为”world”，CTRL+S，我们的程序并未停止，但是下一次打印出的字符串已然不同了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">hello</div><div class=\"line\">hello</div><div class=\"line\">hello</div><div class=\"line\">hello</div><div class=\"line\">hello</div><div class=\"line\">world</div><div class=\"line\">world</div><div class=\"line\">world</div></pre></td></tr></table></figure>\n<p>上面就是一个简单的热替换的例子。实际的应用中当然不是通过一个定时任务进行升级的。把新版本类的字节码通过网络传输到服务器上去，然后发送一个升级指令，使用上面类似的方法便可对类进行升级。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-hotswapcls/\">Java 类的热替换 —— 概念、设计与实现</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-classloader/\">深入探讨 Java 类加载器</a></p>"},{"layout":"post","title":"java注解","date":"2017-03-31T13:07:33.000Z","_content":"> 在写java代码的过程中，经常会遇到注解，但是没有去理解注解背后的原理，也没有实现过注解。网上关于java注解的文章已经有很多了，参考了一些资料，整理一下注解这方面的知识~\n\n## 什么是注解\n注解其实很常见。比如@override、Deprecated等。在使用Junit或Spring boot等一些框架的时候，注解更是无处不在了。那么，到底什么是注解呢？\n\n```\nAnnotations, a form of metadata, provide data about a program that is not part of the program itself. \nAnnotations have no direct effect on the operation of the code they annotate.   \n>>[https://docs.oracle.com/javase/tutorial/java/annotations/]\n```\n注解是元数据的一种，提供了关于程序的一些描述信息，但这些信息并不属于这个程序本身的一部分。注解并不会直接影响到代码的执行。\n\n翻译起来有点拗口。实际上，注解是那些插入到源代码中用于某种工具进行处理的标签。注解不会改变对编写的程序的编译方式，对于包含和不包含注解的代码，java编译器都会生成相同的虚拟机指令。\n\n一句话来说，注解只是描述代码的标签。注解本身不会做什么事情，为了使注解起到作用来实现一些黑科技，我们还需要用于处理注解的工具(编写代码处理这些注解)。\n\n我们使用注解可以：\n\n- 生成文档\n\n- 在编译时进行检查。比如@override\n\n- 替代配置文件，实现自动配置。比如 Springboot\n\n注解Annotation是在jdk1.5之后引进的，jdk1.8之后又增加了一些新的特性。接下来的讨论基于jdk1.7。\n\n<!-- more -->\n\n## 注解的使用\n\n在java中，注解是当做一个修饰符(比如public或static之类的关键词)来使用的。注解可以存在于：\n\n包 | 类(包括enum) | 接口(包括注解接口) | 方法 | 构造器 | 成员变量 | 本地变量 | 方法参数\n\n注意：\n\n1.对于包的注解，需要在[package-info.java](http://strong-life-126-com.iteye.com/blog/806246)中声明。\n\n2.对于本地变量的注解，只能在源码级别上进行处理。所有的本地变量注解在类编译完之后会被遗弃掉。\n\n假如有这样一个注解：(注解的定义见下文)\n\n```\n@interface Result {\n\tString name() default \"\";\n\tint value() default -1;\n    String res() default \"\";\n}\n```\n\n我们可以这样使用它：\n\n`@Result(name=\"res1\",value=1)`\n\n括号中元素的顺序无关紧要\n\n`@Result(value=1,name=\"res1\")等价于@Result(name=\"res1\",value=1)`\n\n如果元素值没有指定，则使用默认值：(没有声明默认值时必须指定元素值)\n\n`@Result等价于@Result(name=\"\",value=-1,\"\")`\n\n如果元素的名字为特殊值value，那么可以忽略这个元素名和等号：\n\n`@Result(1)等价于@Result(name=\"\",value=1,\"\")`\n\n如果元素是数组，那么他的值要用括号括起来：\n\n`@Result(res={\"a\",\"b\"})`\n\n如果数组是单值，可以忽略这些括号：\n\n`@Result(res=\"a\")`\n\n## 注解分类\n\n根据注解的用途和使用方式，注解可以分为以下几类：\n\n元注解：注解注解的注解。也就是用来描述注解定义的注解\n\n预定义注解：jdk内置的一些注解\n\n自定义注解：我们自己定义的注解\n\n- 元注解\n\n元注解包含下面几个：\n\n**@Target: 指定这个注解可以应用于哪些项**\n\n```\npublic enum ElementType {\n    /** Class, interface (including annotation type), or enum declaration */\n    TYPE,\n\n    /** Field declaration (includes enum constants) */\n    FIELD,\n\n    /** Method declaration */\n    METHOD,\n\n    /** Parameter declaration */\n    PARAMETER,\n\n    /** Constructor declaration */\n    CONSTRUCTOR,\n\n    /** Local variable declaration */\n    LOCAL_VARIABLE,\n\n    /** Annotation type declaration */\n    ANNOTATION_TYPE,\n\n    /** Package declaration */\n    PACKAGE\n}\n```\n比如，我们定义了一个注解Bug，该注解只能应用于方法或成员变量：\n\n```\n@Target({ElementType.METHOD,ElementType.FIELD})\n@interface Bug{\n\tint value() default -1;\n}\n```\n注解Bug则只能用于类方法或成员变量，如果注解了其他项比如类或者包，编译则不会通过。\n\n对于一个没有声明@Target的注解，可以应用到任何项上。\n\n**@Retention: 指定这个注解可以保留多久**\n\n```\npublic enum RetentionPolicy {\n    /**\n     * Annotations are to be discarded by the compiler.\n     */\n    SOURCE,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler\n     * but need not be retained by the VM at run time.  This is the default\n     * behavior.\n     */\n    CLASS,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler and\n     * retained by the VM at run time, so they may be read reflectively.\n     *\n     * @see java.lang.reflect.AnnotatedElement\n     */\n    RUNTIME\n}\n```\nSOURCE：只存在于源代码，编译成.class之后就没了\n\nCLASS: 保留到类文件中，但是虚拟机不会载入\n\nRUNTIME：保留到类文件中，并且虚拟机会载入。这意味着通过反射可以获取到这些注解和注解元素值\n\n默认情况下(没有声明@Retention)，注解保留级别为CLASS\n\n**@Document：指定这个注解应该包含在文档中**\n\n文档化的注解意味着像javadoc这样的工具生成的文档中会包含这些注解。比如：\n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})\npublic @interface Deprecated {\n}\n```\n@Deprecated是文档化的注解，URLDecoder.decode(String s)方法应用了这个注解：\n\n{% asset_img decode.jpg decode %}\n\n{% asset_img doc.jpg doc %}\n\n可以在文档中看到Deprecated的出现。\n\n**@Inherited: 指定一个注解，当他应用于一个类的时候，能够自动被其子类继承**\n\n@Inherited只能应用于对类的注解。如果一个类具有继承注解，那么他的所有子类都自动具有同样的注解。\n\n比如，定义了一个继承注解@Secret表示一个类是隐私的不可被序列化传输的，那么该类的子类会被自动注解为不可序列化传输的。\n\n```\n@Inherited\n@interface Secret{\n}\n\n@Secret class A{}\n\nclass B extends A{} //同样是@Secret的\n```\n当注解工具去获取声明了@Secret的对象时，他能够获取到A的对象和B的对象。\n\n- 预定义注解\n\n常用的有三个：@override、@Deprecated、@SuppressWarnings，具体的作用可以查文档或者源码，不再赘述。\n\n## 注解的定义\n\n上面的讨论中已经涉及到了注解的定义。一个注解是由一个注解接口来定义的：\n\n```\n@interface Result {\n\tString name();\n\tint value() default -1;\n}\n```\n每个元素的声明有两种形式，有默认值和没有默认值的，就像上面那样。注解的元素可以是下面之一：\n\n基本类型|String|Class类型|enum|注解类型|由前面所述类型构成的数组\n\n```\n@interface BugReport{\n\tenum Status{FIXED,OPEN,NEW,CLOSE};\n\tboolean isIgnore() default false;\n\tString id();\n\tClass<?> testCase() default Void.class;\n\tStatus status() default Status.NEW;\n\tAuthor author() default @Author;\n\tString[] reportMsg() default \"\";\n}\n```\n注意，虽然注解元素可以是另一个注解，但是不能在注解中引入循环依赖，比如@BugReport依赖@Author，而@Author又依赖@BugReport。同时，注解元素也不可以为null，元素的值必须是编译期常量。\n\n我们可以通过在注解的定义前声明之前提到的元注解来定制我们的注解，比如：\n\n```\n@Target({ ElementType.METHOD, ElementType.FIELD })\n@Inherited\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@interface Result {\n\tString name() default \"\";\n\tint value() default -1;\n\tString[] reportMsg() default \"\";\n}\n```\n所有的注解接口隐式的继承自java.lang.annotation.Annotation接口。这是一个正常的接口，而不是注解接口。\n```\npublic interface Annotation {\n    boolean equals(Object obj);\n    int hashCode();\n    String toString();\n    Class<? extends Annotation> annotationType();\n}\n```\n也就是说，注解接口也是普通接口的一种。注解接口中的元素实际上也是方法的声明，这些方法类似于bean的get、set，我们使用@Result(name=\"A\")的形式实际上是调用了set方法给某个变量赋值。\n\n既然是接口，那么就应该有实现(不然怎么用呢？)。我们不需要主动提供实现了注解接口的类，虚拟机会在需要的时候产生一些代理类和对象。下文会提到。\n\n既然可以为注解元素赋值，那么必定有方法去获得这些值。也就是注解的解析。\n\n## 注解的解析\n\n我们定义了注解并且应用了注解，但是仅仅这样的话注解并不会起到什么作用。需要我们提供一种工具去解析声明的注解，然后实现一些自动配置或者生成报告的功能。这就是注解的解析。\n\n- 源代码中的注解\n\n注解的用处之一就是自动生成一些包含程序额外信息的文件。比如，根据注解生成代码进度报告，或者bug修复报告等。生成的文件可以是属性文件、xml文件、html文档或者shell脚本。也可以生成java源文件。\n\n注解处理器通常通过集成AbstractProcessor类实现了Processor接口，通过process方法实现处理源码中注解的逻辑。通过声明具体的注解类型来指定该处理器处理哪些注解。\n\n```\n@SupportedAnnotationTypes(\"space.yukai.annotations.BUG\")\nclass AnnotationProcessor extends AbstractProcessor {\n\n\t@Override\n\tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\t\n}\n```\nprocess的两个参数：annotations代表了要处理的注解集，roundEnv是包含有关当前处理循环信息的RoundEnv引用。\n\n[Java注解处理器](http://www.race604.com/annotation-processing/)这篇文章以通过注解自动生成工厂类文件为例，详细介绍了如何处理源码级别的注解。（英文原文在这：http://hannesdorfmann.com/annotation-processing/annotationprocessing101）\n\n注意，我们虽然可以通过源码级别的注解处理器生成新的文件，却很难编辑源文件，比如，通过处理注解自动生成get、set方法。字节码级别的处理器是可以的。\n\n- 字节码中的注解\n\n字节码级别的注解，即存在于class文件中的注解。我们还可以通过BCEL这样的字节码工程类库修改或插入字节码来改变类文件。比如在声明了@LogEntity的方法开始部分插入打印日志信息的字节码。\n\n涉及的不多，不再赘述。\n\n- 运行时的注解\n\n在运行时处理注解是比较常见的注解处理手段。一般是通过反射API获取到我们的注解信息，从而实现一些功能。\n\n下面是自己写的一个例子，通过解析BugReport注解得到一些测试信息，然后通过动态代理的方式生成代理测试类，最后运行测试自动生成测试报告。（不要在意代码有什么缺陷或者其他问题，仅仅是一个例子而已～）\n\n```\npackage space.kyu.proxy;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class AnnotationsTest {\n\tpublic static void main(String[] args) {\n\t\tTestBug testBug = new TestBug(true);\n\t\tTestBug testBug1 = new TestBug(false);\n\t\tTestExecutor executor = new TestExecutor();\n\t\texecutor.addTest(testBug);\n\t\texecutor.addTest(testBug1);\n\t\texecutor.executeTest();\n\t}\n}\n\nclass TestExecutor {\n\tprivate List<Test>  testCases;\n\tpublic TestExecutor() {\n\t\ttestCases = new ArrayList<Test>();\n\t}\n\t\n\tpublic <T extends Test> void  addTest(T testCase) {\n\t\tClass<? extends Object> cl = testCase.getClass();\n\t\tMethod[] declaredMethods = cl.getDeclaredMethods();\n\t\ttry {\n\t\t\tfor (Method method : declaredMethods) {\n\t\t\t\tif (method.isAnnotationPresent(BugReport.class)) {\n\t\t\t\t\tBugReport annotation = method.getAnnotation(BugReport.class);\n\t\t\t\t\tif (annotation != null) {\n\t\t\t\t\t\tSystem.out.println(annotation.toString());\n\t\t\t\t\t\tSystem.out.println(annotation.annotationType().getName());\n\t\t\t\t\t\tSystem.out.println(annotation.getClass().getName());\n\t\t\t\t\t\tString bugId = annotation.id();\n\t\t\t\t\t\tString bugMsg = annotation.msg();\n\t\t\t\t\t\tTest obj = (Test) createBugReportHandler(testCase,bugId,bugMsg);\n\t\t\t\t\t\ttestCases.add(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t}\n\tpublic void executeTest() {\n\t\tfor (Test test : testCases) {\n\t\t\ttest.test();\n\t\t}\n\t}\n\tprivate Object createBugReportHandler(Test testCase, final String bugId, final String bugMsg) {\n\t\treturn Proxy.newProxyInstance(testCase.getClass().getClassLoader(), testCase.getClass().getInterfaces(), new InvocationHandler() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t\tboolean res = (boolean) method.invoke(testCase, args);\n\t\t\t\t//也可以输出到文件中形成测试报告\n\t\t\t\tSystem.out.println(\"******************************\");\n\t\t\t\tSystem.out.println(\"bug: \" + bugId + \"测试结果：\");\n\t\t\t\tif (res) {//测试通过\n\t\t\t\t\tSystem.out.println(\"已通过\");\n\t\t\t\t} else {//测试不通过\n\t\t\t\t\tSystem.out.println(\"未通过\");\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"备注信息：\" + bugMsg);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t}\n}\n\ninterface Test {\n\t/**\n\t * 测试方法 2017年4月1日\n\t * @return \n\t * true 通过测试 \n\t * false 未通过测试\n\t */\n\tboolean test();\n}\n\nclass TestBug implements Test {\n\tboolean fixed;\n\tpublic TestBug(boolean fixed) {\n\t\t//控制测试成功或失败\n\t\tthis.fixed = fixed;\n\t}\n\t@BugReport(id = \"bug001\", msg = \"bug注释：这是一条测试bug\")\n\t@Override\n\tpublic boolean test() {\n\t\tSystem.out.println(\"执行测试...\");\n\t\t//假装测试成功或者失败了\n\t\treturn fixed;\n\t}\n\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface BugReport {\n\tString id();\n\n\tString msg();\n}\n\n```\n\n运行结果：\n\n```\n@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)\nspace.kyu.proxy.BugReport\nspace.kyu.proxy.$Proxy1\n@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)\nspace.kyu.proxy.BugReport\nspace.kyu.proxy.$Proxy1\n执行测试...\n******************************\nbug: bug001测试结果：\n已通过\n备注信息：bug注释：这是一条测试bug\n执行测试...\n******************************\nbug: bug001测试结果：\n未通过\n备注信息：bug注释：这是一条测试bug\n```\n上面的代码很简单，我们要注意的有几点：\n\n1.`method.isAnnotationPresent(BugReport.class)`和 `method.getAnnotation(BugReport.class)`\n\n这两个方法来自于接口AnnotatedElement，Method、Field、Package、Constructor、Class这些类都实现了这个接口，使得这些类拥有了提供所声明的注解的功能。\n\n通过method.getAnnotation(BugReport.class)得到了声明在方法上的BugReport注解，获得这个注解的实例之后，我们就可以调用以该注解声明的元素为名称的方法来获取对应的元素值了。\n\n2.`annotation.annotationType().getName()`和`annotation.getClass().getName()`\n\nannotation.annotationType()方法上面已经提到过了，是Annotation的一个方法，用于描述该注解对象的注解接口。这个方法返回的内容为：space.kyu.proxy.BugReport\n\nannotation.getClass()获得了实现了Annotation接口的代理类，通过调用getName()方法可以打印这个代理类的名称：space.kyu.proxy.$Proxy1。从而印证了我们上面所说，确实自动生成了代理类。\n\n上面的例子很简单，说白了，注解就是给代码加了一些额外的信息，这些信息对代码里面的逻辑是没有任何影响的。但是我们可以通过其他手段获得我们在代码中的注解，从而实现一些重复性的工作。这就是注解的作用。","source":"_posts/java注解.md","raw":"---\nlayout: post\ntitle: java注解\ndate: 2017-03-31 21:07:33\ncategories: 编程\ntags: java\n---\n> 在写java代码的过程中，经常会遇到注解，但是没有去理解注解背后的原理，也没有实现过注解。网上关于java注解的文章已经有很多了，参考了一些资料，整理一下注解这方面的知识~\n\n## 什么是注解\n注解其实很常见。比如@override、Deprecated等。在使用Junit或Spring boot等一些框架的时候，注解更是无处不在了。那么，到底什么是注解呢？\n\n```\nAnnotations, a form of metadata, provide data about a program that is not part of the program itself. \nAnnotations have no direct effect on the operation of the code they annotate.   \n>>[https://docs.oracle.com/javase/tutorial/java/annotations/]\n```\n注解是元数据的一种，提供了关于程序的一些描述信息，但这些信息并不属于这个程序本身的一部分。注解并不会直接影响到代码的执行。\n\n翻译起来有点拗口。实际上，注解是那些插入到源代码中用于某种工具进行处理的标签。注解不会改变对编写的程序的编译方式，对于包含和不包含注解的代码，java编译器都会生成相同的虚拟机指令。\n\n一句话来说，注解只是描述代码的标签。注解本身不会做什么事情，为了使注解起到作用来实现一些黑科技，我们还需要用于处理注解的工具(编写代码处理这些注解)。\n\n我们使用注解可以：\n\n- 生成文档\n\n- 在编译时进行检查。比如@override\n\n- 替代配置文件，实现自动配置。比如 Springboot\n\n注解Annotation是在jdk1.5之后引进的，jdk1.8之后又增加了一些新的特性。接下来的讨论基于jdk1.7。\n\n<!-- more -->\n\n## 注解的使用\n\n在java中，注解是当做一个修饰符(比如public或static之类的关键词)来使用的。注解可以存在于：\n\n包 | 类(包括enum) | 接口(包括注解接口) | 方法 | 构造器 | 成员变量 | 本地变量 | 方法参数\n\n注意：\n\n1.对于包的注解，需要在[package-info.java](http://strong-life-126-com.iteye.com/blog/806246)中声明。\n\n2.对于本地变量的注解，只能在源码级别上进行处理。所有的本地变量注解在类编译完之后会被遗弃掉。\n\n假如有这样一个注解：(注解的定义见下文)\n\n```\n@interface Result {\n\tString name() default \"\";\n\tint value() default -1;\n    String res() default \"\";\n}\n```\n\n我们可以这样使用它：\n\n`@Result(name=\"res1\",value=1)`\n\n括号中元素的顺序无关紧要\n\n`@Result(value=1,name=\"res1\")等价于@Result(name=\"res1\",value=1)`\n\n如果元素值没有指定，则使用默认值：(没有声明默认值时必须指定元素值)\n\n`@Result等价于@Result(name=\"\",value=-1,\"\")`\n\n如果元素的名字为特殊值value，那么可以忽略这个元素名和等号：\n\n`@Result(1)等价于@Result(name=\"\",value=1,\"\")`\n\n如果元素是数组，那么他的值要用括号括起来：\n\n`@Result(res={\"a\",\"b\"})`\n\n如果数组是单值，可以忽略这些括号：\n\n`@Result(res=\"a\")`\n\n## 注解分类\n\n根据注解的用途和使用方式，注解可以分为以下几类：\n\n元注解：注解注解的注解。也就是用来描述注解定义的注解\n\n预定义注解：jdk内置的一些注解\n\n自定义注解：我们自己定义的注解\n\n- 元注解\n\n元注解包含下面几个：\n\n**@Target: 指定这个注解可以应用于哪些项**\n\n```\npublic enum ElementType {\n    /** Class, interface (including annotation type), or enum declaration */\n    TYPE,\n\n    /** Field declaration (includes enum constants) */\n    FIELD,\n\n    /** Method declaration */\n    METHOD,\n\n    /** Parameter declaration */\n    PARAMETER,\n\n    /** Constructor declaration */\n    CONSTRUCTOR,\n\n    /** Local variable declaration */\n    LOCAL_VARIABLE,\n\n    /** Annotation type declaration */\n    ANNOTATION_TYPE,\n\n    /** Package declaration */\n    PACKAGE\n}\n```\n比如，我们定义了一个注解Bug，该注解只能应用于方法或成员变量：\n\n```\n@Target({ElementType.METHOD,ElementType.FIELD})\n@interface Bug{\n\tint value() default -1;\n}\n```\n注解Bug则只能用于类方法或成员变量，如果注解了其他项比如类或者包，编译则不会通过。\n\n对于一个没有声明@Target的注解，可以应用到任何项上。\n\n**@Retention: 指定这个注解可以保留多久**\n\n```\npublic enum RetentionPolicy {\n    /**\n     * Annotations are to be discarded by the compiler.\n     */\n    SOURCE,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler\n     * but need not be retained by the VM at run time.  This is the default\n     * behavior.\n     */\n    CLASS,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler and\n     * retained by the VM at run time, so they may be read reflectively.\n     *\n     * @see java.lang.reflect.AnnotatedElement\n     */\n    RUNTIME\n}\n```\nSOURCE：只存在于源代码，编译成.class之后就没了\n\nCLASS: 保留到类文件中，但是虚拟机不会载入\n\nRUNTIME：保留到类文件中，并且虚拟机会载入。这意味着通过反射可以获取到这些注解和注解元素值\n\n默认情况下(没有声明@Retention)，注解保留级别为CLASS\n\n**@Document：指定这个注解应该包含在文档中**\n\n文档化的注解意味着像javadoc这样的工具生成的文档中会包含这些注解。比如：\n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})\npublic @interface Deprecated {\n}\n```\n@Deprecated是文档化的注解，URLDecoder.decode(String s)方法应用了这个注解：\n\n{% asset_img decode.jpg decode %}\n\n{% asset_img doc.jpg doc %}\n\n可以在文档中看到Deprecated的出现。\n\n**@Inherited: 指定一个注解，当他应用于一个类的时候，能够自动被其子类继承**\n\n@Inherited只能应用于对类的注解。如果一个类具有继承注解，那么他的所有子类都自动具有同样的注解。\n\n比如，定义了一个继承注解@Secret表示一个类是隐私的不可被序列化传输的，那么该类的子类会被自动注解为不可序列化传输的。\n\n```\n@Inherited\n@interface Secret{\n}\n\n@Secret class A{}\n\nclass B extends A{} //同样是@Secret的\n```\n当注解工具去获取声明了@Secret的对象时，他能够获取到A的对象和B的对象。\n\n- 预定义注解\n\n常用的有三个：@override、@Deprecated、@SuppressWarnings，具体的作用可以查文档或者源码，不再赘述。\n\n## 注解的定义\n\n上面的讨论中已经涉及到了注解的定义。一个注解是由一个注解接口来定义的：\n\n```\n@interface Result {\n\tString name();\n\tint value() default -1;\n}\n```\n每个元素的声明有两种形式，有默认值和没有默认值的，就像上面那样。注解的元素可以是下面之一：\n\n基本类型|String|Class类型|enum|注解类型|由前面所述类型构成的数组\n\n```\n@interface BugReport{\n\tenum Status{FIXED,OPEN,NEW,CLOSE};\n\tboolean isIgnore() default false;\n\tString id();\n\tClass<?> testCase() default Void.class;\n\tStatus status() default Status.NEW;\n\tAuthor author() default @Author;\n\tString[] reportMsg() default \"\";\n}\n```\n注意，虽然注解元素可以是另一个注解，但是不能在注解中引入循环依赖，比如@BugReport依赖@Author，而@Author又依赖@BugReport。同时，注解元素也不可以为null，元素的值必须是编译期常量。\n\n我们可以通过在注解的定义前声明之前提到的元注解来定制我们的注解，比如：\n\n```\n@Target({ ElementType.METHOD, ElementType.FIELD })\n@Inherited\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@interface Result {\n\tString name() default \"\";\n\tint value() default -1;\n\tString[] reportMsg() default \"\";\n}\n```\n所有的注解接口隐式的继承自java.lang.annotation.Annotation接口。这是一个正常的接口，而不是注解接口。\n```\npublic interface Annotation {\n    boolean equals(Object obj);\n    int hashCode();\n    String toString();\n    Class<? extends Annotation> annotationType();\n}\n```\n也就是说，注解接口也是普通接口的一种。注解接口中的元素实际上也是方法的声明，这些方法类似于bean的get、set，我们使用@Result(name=\"A\")的形式实际上是调用了set方法给某个变量赋值。\n\n既然是接口，那么就应该有实现(不然怎么用呢？)。我们不需要主动提供实现了注解接口的类，虚拟机会在需要的时候产生一些代理类和对象。下文会提到。\n\n既然可以为注解元素赋值，那么必定有方法去获得这些值。也就是注解的解析。\n\n## 注解的解析\n\n我们定义了注解并且应用了注解，但是仅仅这样的话注解并不会起到什么作用。需要我们提供一种工具去解析声明的注解，然后实现一些自动配置或者生成报告的功能。这就是注解的解析。\n\n- 源代码中的注解\n\n注解的用处之一就是自动生成一些包含程序额外信息的文件。比如，根据注解生成代码进度报告，或者bug修复报告等。生成的文件可以是属性文件、xml文件、html文档或者shell脚本。也可以生成java源文件。\n\n注解处理器通常通过集成AbstractProcessor类实现了Processor接口，通过process方法实现处理源码中注解的逻辑。通过声明具体的注解类型来指定该处理器处理哪些注解。\n\n```\n@SupportedAnnotationTypes(\"space.yukai.annotations.BUG\")\nclass AnnotationProcessor extends AbstractProcessor {\n\n\t@Override\n\tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\t\n}\n```\nprocess的两个参数：annotations代表了要处理的注解集，roundEnv是包含有关当前处理循环信息的RoundEnv引用。\n\n[Java注解处理器](http://www.race604.com/annotation-processing/)这篇文章以通过注解自动生成工厂类文件为例，详细介绍了如何处理源码级别的注解。（英文原文在这：http://hannesdorfmann.com/annotation-processing/annotationprocessing101）\n\n注意，我们虽然可以通过源码级别的注解处理器生成新的文件，却很难编辑源文件，比如，通过处理注解自动生成get、set方法。字节码级别的处理器是可以的。\n\n- 字节码中的注解\n\n字节码级别的注解，即存在于class文件中的注解。我们还可以通过BCEL这样的字节码工程类库修改或插入字节码来改变类文件。比如在声明了@LogEntity的方法开始部分插入打印日志信息的字节码。\n\n涉及的不多，不再赘述。\n\n- 运行时的注解\n\n在运行时处理注解是比较常见的注解处理手段。一般是通过反射API获取到我们的注解信息，从而实现一些功能。\n\n下面是自己写的一个例子，通过解析BugReport注解得到一些测试信息，然后通过动态代理的方式生成代理测试类，最后运行测试自动生成测试报告。（不要在意代码有什么缺陷或者其他问题，仅仅是一个例子而已～）\n\n```\npackage space.kyu.proxy;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class AnnotationsTest {\n\tpublic static void main(String[] args) {\n\t\tTestBug testBug = new TestBug(true);\n\t\tTestBug testBug1 = new TestBug(false);\n\t\tTestExecutor executor = new TestExecutor();\n\t\texecutor.addTest(testBug);\n\t\texecutor.addTest(testBug1);\n\t\texecutor.executeTest();\n\t}\n}\n\nclass TestExecutor {\n\tprivate List<Test>  testCases;\n\tpublic TestExecutor() {\n\t\ttestCases = new ArrayList<Test>();\n\t}\n\t\n\tpublic <T extends Test> void  addTest(T testCase) {\n\t\tClass<? extends Object> cl = testCase.getClass();\n\t\tMethod[] declaredMethods = cl.getDeclaredMethods();\n\t\ttry {\n\t\t\tfor (Method method : declaredMethods) {\n\t\t\t\tif (method.isAnnotationPresent(BugReport.class)) {\n\t\t\t\t\tBugReport annotation = method.getAnnotation(BugReport.class);\n\t\t\t\t\tif (annotation != null) {\n\t\t\t\t\t\tSystem.out.println(annotation.toString());\n\t\t\t\t\t\tSystem.out.println(annotation.annotationType().getName());\n\t\t\t\t\t\tSystem.out.println(annotation.getClass().getName());\n\t\t\t\t\t\tString bugId = annotation.id();\n\t\t\t\t\t\tString bugMsg = annotation.msg();\n\t\t\t\t\t\tTest obj = (Test) createBugReportHandler(testCase,bugId,bugMsg);\n\t\t\t\t\t\ttestCases.add(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t}\n\tpublic void executeTest() {\n\t\tfor (Test test : testCases) {\n\t\t\ttest.test();\n\t\t}\n\t}\n\tprivate Object createBugReportHandler(Test testCase, final String bugId, final String bugMsg) {\n\t\treturn Proxy.newProxyInstance(testCase.getClass().getClassLoader(), testCase.getClass().getInterfaces(), new InvocationHandler() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t\tboolean res = (boolean) method.invoke(testCase, args);\n\t\t\t\t//也可以输出到文件中形成测试报告\n\t\t\t\tSystem.out.println(\"******************************\");\n\t\t\t\tSystem.out.println(\"bug: \" + bugId + \"测试结果：\");\n\t\t\t\tif (res) {//测试通过\n\t\t\t\t\tSystem.out.println(\"已通过\");\n\t\t\t\t} else {//测试不通过\n\t\t\t\t\tSystem.out.println(\"未通过\");\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"备注信息：\" + bugMsg);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t}\n}\n\ninterface Test {\n\t/**\n\t * 测试方法 2017年4月1日\n\t * @return \n\t * true 通过测试 \n\t * false 未通过测试\n\t */\n\tboolean test();\n}\n\nclass TestBug implements Test {\n\tboolean fixed;\n\tpublic TestBug(boolean fixed) {\n\t\t//控制测试成功或失败\n\t\tthis.fixed = fixed;\n\t}\n\t@BugReport(id = \"bug001\", msg = \"bug注释：这是一条测试bug\")\n\t@Override\n\tpublic boolean test() {\n\t\tSystem.out.println(\"执行测试...\");\n\t\t//假装测试成功或者失败了\n\t\treturn fixed;\n\t}\n\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface BugReport {\n\tString id();\n\n\tString msg();\n}\n\n```\n\n运行结果：\n\n```\n@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)\nspace.kyu.proxy.BugReport\nspace.kyu.proxy.$Proxy1\n@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)\nspace.kyu.proxy.BugReport\nspace.kyu.proxy.$Proxy1\n执行测试...\n******************************\nbug: bug001测试结果：\n已通过\n备注信息：bug注释：这是一条测试bug\n执行测试...\n******************************\nbug: bug001测试结果：\n未通过\n备注信息：bug注释：这是一条测试bug\n```\n上面的代码很简单，我们要注意的有几点：\n\n1.`method.isAnnotationPresent(BugReport.class)`和 `method.getAnnotation(BugReport.class)`\n\n这两个方法来自于接口AnnotatedElement，Method、Field、Package、Constructor、Class这些类都实现了这个接口，使得这些类拥有了提供所声明的注解的功能。\n\n通过method.getAnnotation(BugReport.class)得到了声明在方法上的BugReport注解，获得这个注解的实例之后，我们就可以调用以该注解声明的元素为名称的方法来获取对应的元素值了。\n\n2.`annotation.annotationType().getName()`和`annotation.getClass().getName()`\n\nannotation.annotationType()方法上面已经提到过了，是Annotation的一个方法，用于描述该注解对象的注解接口。这个方法返回的内容为：space.kyu.proxy.BugReport\n\nannotation.getClass()获得了实现了Annotation接口的代理类，通过调用getName()方法可以打印这个代理类的名称：space.kyu.proxy.$Proxy1。从而印证了我们上面所说，确实自动生成了代理类。\n\n上面的例子很简单，说白了，注解就是给代码加了一些额外的信息，这些信息对代码里面的逻辑是没有任何影响的。但是我们可以通过其他手段获得我们在代码中的注解，从而实现一些重复性的工作。这就是注解的作用。","slug":"java注解","published":1,"updated":"2017-04-11T13:08:38.844Z","comments":1,"photos":[],"link":"","_id":"cj4vch4f9002px3gc883v03la","content":"<blockquote>\n<p>在写java代码的过程中，经常会遇到注解，但是没有去理解注解背后的原理，也没有实现过注解。网上关于java注解的文章已经有很多了，参考了一些资料，整理一下注解这方面的知识~</p>\n</blockquote>\n<h2 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h2><p>注解其实很常见。比如@override、Deprecated等。在使用Junit或Spring boot等一些框架的时候，注解更是无处不在了。那么，到底什么是注解呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Annotations, a form of metadata, provide data about a program that is not part of the program itself. </div><div class=\"line\">Annotations have no direct effect on the operation of the code they annotate.   </div><div class=\"line\">&gt;&gt;[https://docs.oracle.com/javase/tutorial/java/annotations/]</div></pre></td></tr></table></figure>\n<p>注解是元数据的一种，提供了关于程序的一些描述信息，但这些信息并不属于这个程序本身的一部分。注解并不会直接影响到代码的执行。</p>\n<p>翻译起来有点拗口。实际上，注解是那些插入到源代码中用于某种工具进行处理的标签。注解不会改变对编写的程序的编译方式，对于包含和不包含注解的代码，java编译器都会生成相同的虚拟机指令。</p>\n<p>一句话来说，注解只是描述代码的标签。注解本身不会做什么事情，为了使注解起到作用来实现一些黑科技，我们还需要用于处理注解的工具(编写代码处理这些注解)。</p>\n<p>我们使用注解可以：</p>\n<ul>\n<li><p>生成文档</p>\n</li>\n<li><p>在编译时进行检查。比如@override</p>\n</li>\n<li><p>替代配置文件，实现自动配置。比如 Springboot</p>\n</li>\n</ul>\n<p>注解Annotation是在jdk1.5之后引进的，jdk1.8之后又增加了一些新的特性。接下来的讨论基于jdk1.7。</p>\n<a id=\"more\"></a>\n<h2 id=\"注解的使用\"><a href=\"#注解的使用\" class=\"headerlink\" title=\"注解的使用\"></a>注解的使用</h2><p>在java中，注解是当做一个修饰符(比如public或static之类的关键词)来使用的。注解可以存在于：</p>\n<p>包 | 类(包括enum) | 接口(包括注解接口) | 方法 | 构造器 | 成员变量 | 本地变量 | 方法参数</p>\n<p>注意：</p>\n<p>1.对于包的注解，需要在<a href=\"http://strong-life-126-com.iteye.com/blog/806246\" target=\"_blank\" rel=\"external\">package-info.java</a>中声明。</p>\n<p>2.对于本地变量的注解，只能在源码级别上进行处理。所有的本地变量注解在类编译完之后会被遗弃掉。</p>\n<p>假如有这样一个注解：(注解的定义见下文)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Result &#123;</div><div class=\"line\">\tString name() default &quot;&quot;;</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">    String res() default &quot;&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以这样使用它：</p>\n<p><code>@Result(name=&quot;res1&quot;,value=1)</code></p>\n<p>括号中元素的顺序无关紧要</p>\n<p><code>@Result(value=1,name=&quot;res1&quot;)等价于@Result(name=&quot;res1&quot;,value=1)</code></p>\n<p>如果元素值没有指定，则使用默认值：(没有声明默认值时必须指定元素值)</p>\n<p><code>@Result等价于@Result(name=&quot;&quot;,value=-1,&quot;&quot;)</code></p>\n<p>如果元素的名字为特殊值value，那么可以忽略这个元素名和等号：</p>\n<p><code>@Result(1)等价于@Result(name=&quot;&quot;,value=1,&quot;&quot;)</code></p>\n<p>如果元素是数组，那么他的值要用括号括起来：</p>\n<p><code>@Result(res={&quot;a&quot;,&quot;b&quot;})</code></p>\n<p>如果数组是单值，可以忽略这些括号：</p>\n<p><code>@Result(res=&quot;a&quot;)</code></p>\n<h2 id=\"注解分类\"><a href=\"#注解分类\" class=\"headerlink\" title=\"注解分类\"></a>注解分类</h2><p>根据注解的用途和使用方式，注解可以分为以下几类：</p>\n<p>元注解：注解注解的注解。也就是用来描述注解定义的注解</p>\n<p>预定义注解：jdk内置的一些注解</p>\n<p>自定义注解：我们自己定义的注解</p>\n<ul>\n<li>元注解</li>\n</ul>\n<p>元注解包含下面几个：</p>\n<p><strong>@Target: 指定这个注解可以应用于哪些项</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public enum ElementType &#123;</div><div class=\"line\">    /** Class, interface (including annotation type), or enum declaration */</div><div class=\"line\">    TYPE,</div><div class=\"line\"></div><div class=\"line\">    /** Field declaration (includes enum constants) */</div><div class=\"line\">    FIELD,</div><div class=\"line\"></div><div class=\"line\">    /** Method declaration */</div><div class=\"line\">    METHOD,</div><div class=\"line\"></div><div class=\"line\">    /** Parameter declaration */</div><div class=\"line\">    PARAMETER,</div><div class=\"line\"></div><div class=\"line\">    /** Constructor declaration */</div><div class=\"line\">    CONSTRUCTOR,</div><div class=\"line\"></div><div class=\"line\">    /** Local variable declaration */</div><div class=\"line\">    LOCAL_VARIABLE,</div><div class=\"line\"></div><div class=\"line\">    /** Annotation type declaration */</div><div class=\"line\">    ANNOTATION_TYPE,</div><div class=\"line\"></div><div class=\"line\">    /** Package declaration */</div><div class=\"line\">    PACKAGE</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>比如，我们定义了一个注解Bug，该注解只能应用于方法或成员变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</div><div class=\"line\">@interface Bug&#123;</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注解Bug则只能用于类方法或成员变量，如果注解了其他项比如类或者包，编译则不会通过。</p>\n<p>对于一个没有声明@Target的注解，可以应用到任何项上。</p>\n<p><strong>@Retention: 指定这个注解可以保留多久</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public enum RetentionPolicy &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Annotations are to be discarded by the compiler.</div><div class=\"line\">     */</div><div class=\"line\">    SOURCE,</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Annotations are to be recorded in the class file by the compiler</div><div class=\"line\">     * but need not be retained by the VM at run time.  This is the default</div><div class=\"line\">     * behavior.</div><div class=\"line\">     */</div><div class=\"line\">    CLASS,</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Annotations are to be recorded in the class file by the compiler and</div><div class=\"line\">     * retained by the VM at run time, so they may be read reflectively.</div><div class=\"line\">     *</div><div class=\"line\">     * @see java.lang.reflect.AnnotatedElement</div><div class=\"line\">     */</div><div class=\"line\">    RUNTIME</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>SOURCE：只存在于源代码，编译成.class之后就没了</p>\n<p>CLASS: 保留到类文件中，但是虚拟机不会载入</p>\n<p>RUNTIME：保留到类文件中，并且虚拟机会载入。这意味着通过反射可以获取到这些注解和注解元素值</p>\n<p>默认情况下(没有声明@Retention)，注解保留级别为CLASS</p>\n<p><strong>@Document：指定这个注解应该包含在文档中</strong></p>\n<p>文档化的注解意味着像javadoc这样的工具生成的文档中会包含这些注解。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Documented</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</div><div class=\"line\">public @interface Deprecated &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>@Deprecated是文档化的注解，URLDecoder.decode(String s)方法应用了这个注解：</p>\n<img src=\"/2017/03/31/java注解/decode.jpg\" alt=\"decode\" title=\"decode\">\n<img src=\"/2017/03/31/java注解/doc.jpg\" alt=\"doc\" title=\"doc\">\n<p>可以在文档中看到Deprecated的出现。</p>\n<p><strong>@Inherited: 指定一个注解，当他应用于一个类的时候，能够自动被其子类继承</strong></p>\n<p>@Inherited只能应用于对类的注解。如果一个类具有继承注解，那么他的所有子类都自动具有同样的注解。</p>\n<p>比如，定义了一个继承注解@Secret表示一个类是隐私的不可被序列化传输的，那么该类的子类会被自动注解为不可序列化传输的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Inherited</div><div class=\"line\">@interface Secret&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Secret class A&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">class B extends A&#123;&#125; //同样是@Secret的</div></pre></td></tr></table></figure>\n<p>当注解工具去获取声明了@Secret的对象时，他能够获取到A的对象和B的对象。</p>\n<ul>\n<li>预定义注解</li>\n</ul>\n<p>常用的有三个：@override、@Deprecated、@SuppressWarnings，具体的作用可以查文档或者源码，不再赘述。</p>\n<h2 id=\"注解的定义\"><a href=\"#注解的定义\" class=\"headerlink\" title=\"注解的定义\"></a>注解的定义</h2><p>上面的讨论中已经涉及到了注解的定义。一个注解是由一个注解接口来定义的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Result &#123;</div><div class=\"line\">\tString name();</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每个元素的声明有两种形式，有默认值和没有默认值的，就像上面那样。注解的元素可以是下面之一：</p>\n<p>基本类型|String|Class类型|enum|注解类型|由前面所述类型构成的数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface BugReport&#123;</div><div class=\"line\">\tenum Status&#123;FIXED,OPEN,NEW,CLOSE&#125;;</div><div class=\"line\">\tboolean isIgnore() default false;</div><div class=\"line\">\tString id();</div><div class=\"line\">\tClass&lt;?&gt; testCase() default Void.class;</div><div class=\"line\">\tStatus status() default Status.NEW;</div><div class=\"line\">\tAuthor author() default @Author;</div><div class=\"line\">\tString[] reportMsg() default &quot;&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，虽然注解元素可以是另一个注解，但是不能在注解中引入循环依赖，比如@BugReport依赖@Author，而@Author又依赖@BugReport。同时，注解元素也不可以为null，元素的值必须是编译期常量。</p>\n<p>我们可以通过在注解的定义前声明之前提到的元注解来定制我们的注解，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(&#123; ElementType.METHOD, ElementType.FIELD &#125;)</div><div class=\"line\">@Inherited</div><div class=\"line\">@Documented</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@interface Result &#123;</div><div class=\"line\">\tString name() default &quot;&quot;;</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">\tString[] reportMsg() default &quot;&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所有的注解接口隐式的继承自java.lang.annotation.Annotation接口。这是一个正常的接口，而不是注解接口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Annotation &#123;</div><div class=\"line\">    boolean equals(Object obj);</div><div class=\"line\">    int hashCode();</div><div class=\"line\">    String toString();</div><div class=\"line\">    Class&lt;? extends Annotation&gt; annotationType();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>也就是说，注解接口也是普通接口的一种。注解接口中的元素实际上也是方法的声明，这些方法类似于bean的get、set，我们使用@Result(name=”A”)的形式实际上是调用了set方法给某个变量赋值。</p>\n<p>既然是接口，那么就应该有实现(不然怎么用呢？)。我们不需要主动提供实现了注解接口的类，虚拟机会在需要的时候产生一些代理类和对象。下文会提到。</p>\n<p>既然可以为注解元素赋值，那么必定有方法去获得这些值。也就是注解的解析。</p>\n<h2 id=\"注解的解析\"><a href=\"#注解的解析\" class=\"headerlink\" title=\"注解的解析\"></a>注解的解析</h2><p>我们定义了注解并且应用了注解，但是仅仅这样的话注解并不会起到什么作用。需要我们提供一种工具去解析声明的注解，然后实现一些自动配置或者生成报告的功能。这就是注解的解析。</p>\n<ul>\n<li>源代码中的注解</li>\n</ul>\n<p>注解的用处之一就是自动生成一些包含程序额外信息的文件。比如，根据注解生成代码进度报告，或者bug修复报告等。生成的文件可以是属性文件、xml文件、html文档或者shell脚本。也可以生成java源文件。</p>\n<p>注解处理器通常通过集成AbstractProcessor类实现了Processor接口，通过process方法实现处理源码中注解的逻辑。通过声明具体的注解类型来指定该处理器处理哪些注解。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SupportedAnnotationTypes(&quot;space.yukai.annotations.BUG&quot;)</div><div class=\"line\">class AnnotationProcessor extends AbstractProcessor &#123;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\treturn false;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>process的两个参数：annotations代表了要处理的注解集，roundEnv是包含有关当前处理循环信息的RoundEnv引用。</p>\n<p><a href=\"http://www.race604.com/annotation-processing/\" target=\"_blank\" rel=\"external\">Java注解处理器</a>这篇文章以通过注解自动生成工厂类文件为例，详细介绍了如何处理源码级别的注解。（英文原文在这：<a href=\"http://hannesdorfmann.com/annotation-processing/annotationprocessing101）\" target=\"_blank\" rel=\"external\">http://hannesdorfmann.com/annotation-processing/annotationprocessing101）</a></p>\n<p>注意，我们虽然可以通过源码级别的注解处理器生成新的文件，却很难编辑源文件，比如，通过处理注解自动生成get、set方法。字节码级别的处理器是可以的。</p>\n<ul>\n<li>字节码中的注解</li>\n</ul>\n<p>字节码级别的注解，即存在于class文件中的注解。我们还可以通过BCEL这样的字节码工程类库修改或插入字节码来改变类文件。比如在声明了@LogEntity的方法开始部分插入打印日志信息的字节码。</p>\n<p>涉及的不多，不再赘述。</p>\n<ul>\n<li>运行时的注解</li>\n</ul>\n<p>在运行时处理注解是比较常见的注解处理手段。一般是通过反射API获取到我们的注解信息，从而实现一些功能。</p>\n<p>下面是自己写的一个例子，通过解析BugReport注解得到一些测试信息，然后通过动态代理的方式生成代理测试类，最后运行测试自动生成测试报告。（不要在意代码有什么缺陷或者其他问题，仅仅是一个例子而已～）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\">package space.kyu.proxy;</div><div class=\"line\"></div><div class=\"line\">import java.lang.annotation.ElementType;</div><div class=\"line\">import java.lang.annotation.Retention;</div><div class=\"line\">import java.lang.annotation.RetentionPolicy;</div><div class=\"line\">import java.lang.annotation.Target;</div><div class=\"line\">import java.lang.reflect.InvocationHandler;</div><div class=\"line\">import java.lang.reflect.Method;</div><div class=\"line\">import java.lang.reflect.Proxy;</div><div class=\"line\">import java.util.ArrayList;</div><div class=\"line\">import java.util.List;</div><div class=\"line\"></div><div class=\"line\">public class AnnotationsTest &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tTestBug testBug = new TestBug(true);</div><div class=\"line\">\t\tTestBug testBug1 = new TestBug(false);</div><div class=\"line\">\t\tTestExecutor executor = new TestExecutor();</div><div class=\"line\">\t\texecutor.addTest(testBug);</div><div class=\"line\">\t\texecutor.addTest(testBug1);</div><div class=\"line\">\t\texecutor.executeTest();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class TestExecutor &#123;</div><div class=\"line\">\tprivate List&lt;Test&gt;  testCases;</div><div class=\"line\">\tpublic TestExecutor() &#123;</div><div class=\"line\">\t\ttestCases = new ArrayList&lt;Test&gt;();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic &lt;T extends Test&gt; void  addTest(T testCase) &#123;</div><div class=\"line\">\t\tClass&lt;? extends Object&gt; cl = testCase.getClass();</div><div class=\"line\">\t\tMethod[] declaredMethods = cl.getDeclaredMethods();</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tfor (Method method : declaredMethods) &#123;</div><div class=\"line\">\t\t\t\tif (method.isAnnotationPresent(BugReport.class)) &#123;</div><div class=\"line\">\t\t\t\t\tBugReport annotation = method.getAnnotation(BugReport.class);</div><div class=\"line\">\t\t\t\t\tif (annotation != null) &#123;</div><div class=\"line\">\t\t\t\t\t\tSystem.out.println(annotation.toString());</div><div class=\"line\">\t\t\t\t\t\tSystem.out.println(annotation.annotationType().getName());</div><div class=\"line\">\t\t\t\t\t\tSystem.out.println(annotation.getClass().getName());</div><div class=\"line\">\t\t\t\t\t\tString bugId = annotation.id();</div><div class=\"line\">\t\t\t\t\t\tString bugMsg = annotation.msg();</div><div class=\"line\">\t\t\t\t\t\tTest obj = (Test) createBugReportHandler(testCase,bugId,bugMsg);</div><div class=\"line\">\t\t\t\t\t\ttestCases.add(obj);</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; catch (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\tthrow new IllegalStateException(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void executeTest() &#123;</div><div class=\"line\">\t\tfor (Test test : testCases) &#123;</div><div class=\"line\">\t\t\ttest.test();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tprivate Object createBugReportHandler(Test testCase, final String bugId, final String bugMsg) &#123;</div><div class=\"line\">\t\treturn Proxy.newProxyInstance(testCase.getClass().getClassLoader(), testCase.getClass().getInterfaces(), new InvocationHandler() &#123;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\t@Override</div><div class=\"line\">\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class=\"line\">\t\t\t\tboolean res = (boolean) method.invoke(testCase, args);</div><div class=\"line\">\t\t\t\t//也可以输出到文件中形成测试报告</div><div class=\"line\">\t\t\t\tSystem.out.println(&quot;******************************&quot;);</div><div class=\"line\">\t\t\t\tSystem.out.println(&quot;bug: &quot; + bugId + &quot;测试结果：&quot;);</div><div class=\"line\">\t\t\t\tif (res) &#123;//测试通过</div><div class=\"line\">\t\t\t\t\tSystem.out.println(&quot;已通过&quot;);</div><div class=\"line\">\t\t\t\t&#125; else &#123;//测试不通过</div><div class=\"line\">\t\t\t\t\tSystem.out.println(&quot;未通过&quot;);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tSystem.out.println(&quot;备注信息：&quot; + bugMsg);</div><div class=\"line\">\t\t\t\treturn res;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">interface Test &#123;</div><div class=\"line\">\t/**</div><div class=\"line\">\t * 测试方法 2017年4月1日</div><div class=\"line\">\t * @return </div><div class=\"line\">\t * true 通过测试 </div><div class=\"line\">\t * false 未通过测试</div><div class=\"line\">\t */</div><div class=\"line\">\tboolean test();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class TestBug implements Test &#123;</div><div class=\"line\">\tboolean fixed;</div><div class=\"line\">\tpublic TestBug(boolean fixed) &#123;</div><div class=\"line\">\t\t//控制测试成功或失败</div><div class=\"line\">\t\tthis.fixed = fixed;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@BugReport(id = &quot;bug001&quot;, msg = &quot;bug注释：这是一条测试bug&quot;)</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean test() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;执行测试...&quot;);</div><div class=\"line\">\t\t//假装测试成功或者失败了</div><div class=\"line\">\t\treturn fixed;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Target(ElementType.METHOD)</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@interface BugReport &#123;</div><div class=\"line\">\tString id();</div><div class=\"line\"></div><div class=\"line\">\tString msg();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)</div><div class=\"line\">space.kyu.proxy.BugReport</div><div class=\"line\">space.kyu.proxy.$Proxy1</div><div class=\"line\">@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)</div><div class=\"line\">space.kyu.proxy.BugReport</div><div class=\"line\">space.kyu.proxy.$Proxy1</div><div class=\"line\">执行测试...</div><div class=\"line\">******************************</div><div class=\"line\">bug: bug001测试结果：</div><div class=\"line\">已通过</div><div class=\"line\">备注信息：bug注释：这是一条测试bug</div><div class=\"line\">执行测试...</div><div class=\"line\">******************************</div><div class=\"line\">bug: bug001测试结果：</div><div class=\"line\">未通过</div><div class=\"line\">备注信息：bug注释：这是一条测试bug</div></pre></td></tr></table></figure>\n<p>上面的代码很简单，我们要注意的有几点：</p>\n<p>1.<code>method.isAnnotationPresent(BugReport.class)</code>和 <code>method.getAnnotation(BugReport.class)</code></p>\n<p>这两个方法来自于接口AnnotatedElement，Method、Field、Package、Constructor、Class这些类都实现了这个接口，使得这些类拥有了提供所声明的注解的功能。</p>\n<p>通过method.getAnnotation(BugReport.class)得到了声明在方法上的BugReport注解，获得这个注解的实例之后，我们就可以调用以该注解声明的元素为名称的方法来获取对应的元素值了。</p>\n<p>2.<code>annotation.annotationType().getName()</code>和<code>annotation.getClass().getName()</code></p>\n<p>annotation.annotationType()方法上面已经提到过了，是Annotation的一个方法，用于描述该注解对象的注解接口。这个方法返回的内容为：space.kyu.proxy.BugReport</p>\n<p>annotation.getClass()获得了实现了Annotation接口的代理类，通过调用getName()方法可以打印这个代理类的名称：space.kyu.proxy.$Proxy1。从而印证了我们上面所说，确实自动生成了代理类。</p>\n<p>上面的例子很简单，说白了，注解就是给代码加了一些额外的信息，这些信息对代码里面的逻辑是没有任何影响的。但是我们可以通过其他手段获得我们在代码中的注解，从而实现一些重复性的工作。这就是注解的作用。</p>\n","excerpt":"<blockquote>\n<p>在写java代码的过程中，经常会遇到注解，但是没有去理解注解背后的原理，也没有实现过注解。网上关于java注解的文章已经有很多了，参考了一些资料，整理一下注解这方面的知识~</p>\n</blockquote>\n<h2 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h2><p>注解其实很常见。比如@override、Deprecated等。在使用Junit或Spring boot等一些框架的时候，注解更是无处不在了。那么，到底什么是注解呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Annotations, a form of metadata, provide data about a program that is not part of the program itself. </div><div class=\"line\">Annotations have no direct effect on the operation of the code they annotate.   </div><div class=\"line\">&gt;&gt;[https://docs.oracle.com/javase/tutorial/java/annotations/]</div></pre></td></tr></table></figure>\n<p>注解是元数据的一种，提供了关于程序的一些描述信息，但这些信息并不属于这个程序本身的一部分。注解并不会直接影响到代码的执行。</p>\n<p>翻译起来有点拗口。实际上，注解是那些插入到源代码中用于某种工具进行处理的标签。注解不会改变对编写的程序的编译方式，对于包含和不包含注解的代码，java编译器都会生成相同的虚拟机指令。</p>\n<p>一句话来说，注解只是描述代码的标签。注解本身不会做什么事情，为了使注解起到作用来实现一些黑科技，我们还需要用于处理注解的工具(编写代码处理这些注解)。</p>\n<p>我们使用注解可以：</p>\n<ul>\n<li><p>生成文档</p>\n</li>\n<li><p>在编译时进行检查。比如@override</p>\n</li>\n<li><p>替代配置文件，实现自动配置。比如 Springboot</p>\n</li>\n</ul>\n<p>注解Annotation是在jdk1.5之后引进的，jdk1.8之后又增加了一些新的特性。接下来的讨论基于jdk1.7。</p>","more":"<h2 id=\"注解的使用\"><a href=\"#注解的使用\" class=\"headerlink\" title=\"注解的使用\"></a>注解的使用</h2><p>在java中，注解是当做一个修饰符(比如public或static之类的关键词)来使用的。注解可以存在于：</p>\n<p>包 | 类(包括enum) | 接口(包括注解接口) | 方法 | 构造器 | 成员变量 | 本地变量 | 方法参数</p>\n<p>注意：</p>\n<p>1.对于包的注解，需要在<a href=\"http://strong-life-126-com.iteye.com/blog/806246\">package-info.java</a>中声明。</p>\n<p>2.对于本地变量的注解，只能在源码级别上进行处理。所有的本地变量注解在类编译完之后会被遗弃掉。</p>\n<p>假如有这样一个注解：(注解的定义见下文)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Result &#123;</div><div class=\"line\">\tString name() default &quot;&quot;;</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">    String res() default &quot;&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以这样使用它：</p>\n<p><code>@Result(name=&quot;res1&quot;,value=1)</code></p>\n<p>括号中元素的顺序无关紧要</p>\n<p><code>@Result(value=1,name=&quot;res1&quot;)等价于@Result(name=&quot;res1&quot;,value=1)</code></p>\n<p>如果元素值没有指定，则使用默认值：(没有声明默认值时必须指定元素值)</p>\n<p><code>@Result等价于@Result(name=&quot;&quot;,value=-1,&quot;&quot;)</code></p>\n<p>如果元素的名字为特殊值value，那么可以忽略这个元素名和等号：</p>\n<p><code>@Result(1)等价于@Result(name=&quot;&quot;,value=1,&quot;&quot;)</code></p>\n<p>如果元素是数组，那么他的值要用括号括起来：</p>\n<p><code>@Result(res={&quot;a&quot;,&quot;b&quot;})</code></p>\n<p>如果数组是单值，可以忽略这些括号：</p>\n<p><code>@Result(res=&quot;a&quot;)</code></p>\n<h2 id=\"注解分类\"><a href=\"#注解分类\" class=\"headerlink\" title=\"注解分类\"></a>注解分类</h2><p>根据注解的用途和使用方式，注解可以分为以下几类：</p>\n<p>元注解：注解注解的注解。也就是用来描述注解定义的注解</p>\n<p>预定义注解：jdk内置的一些注解</p>\n<p>自定义注解：我们自己定义的注解</p>\n<ul>\n<li>元注解</li>\n</ul>\n<p>元注解包含下面几个：</p>\n<p><strong>@Target: 指定这个注解可以应用于哪些项</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public enum ElementType &#123;</div><div class=\"line\">    /** Class, interface (including annotation type), or enum declaration */</div><div class=\"line\">    TYPE,</div><div class=\"line\"></div><div class=\"line\">    /** Field declaration (includes enum constants) */</div><div class=\"line\">    FIELD,</div><div class=\"line\"></div><div class=\"line\">    /** Method declaration */</div><div class=\"line\">    METHOD,</div><div class=\"line\"></div><div class=\"line\">    /** Parameter declaration */</div><div class=\"line\">    PARAMETER,</div><div class=\"line\"></div><div class=\"line\">    /** Constructor declaration */</div><div class=\"line\">    CONSTRUCTOR,</div><div class=\"line\"></div><div class=\"line\">    /** Local variable declaration */</div><div class=\"line\">    LOCAL_VARIABLE,</div><div class=\"line\"></div><div class=\"line\">    /** Annotation type declaration */</div><div class=\"line\">    ANNOTATION_TYPE,</div><div class=\"line\"></div><div class=\"line\">    /** Package declaration */</div><div class=\"line\">    PACKAGE</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>比如，我们定义了一个注解Bug，该注解只能应用于方法或成员变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</div><div class=\"line\">@interface Bug&#123;</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注解Bug则只能用于类方法或成员变量，如果注解了其他项比如类或者包，编译则不会通过。</p>\n<p>对于一个没有声明@Target的注解，可以应用到任何项上。</p>\n<p><strong>@Retention: 指定这个注解可以保留多久</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public enum RetentionPolicy &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Annotations are to be discarded by the compiler.</div><div class=\"line\">     */</div><div class=\"line\">    SOURCE,</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Annotations are to be recorded in the class file by the compiler</div><div class=\"line\">     * but need not be retained by the VM at run time.  This is the default</div><div class=\"line\">     * behavior.</div><div class=\"line\">     */</div><div class=\"line\">    CLASS,</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Annotations are to be recorded in the class file by the compiler and</div><div class=\"line\">     * retained by the VM at run time, so they may be read reflectively.</div><div class=\"line\">     *</div><div class=\"line\">     * @see java.lang.reflect.AnnotatedElement</div><div class=\"line\">     */</div><div class=\"line\">    RUNTIME</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>SOURCE：只存在于源代码，编译成.class之后就没了</p>\n<p>CLASS: 保留到类文件中，但是虚拟机不会载入</p>\n<p>RUNTIME：保留到类文件中，并且虚拟机会载入。这意味着通过反射可以获取到这些注解和注解元素值</p>\n<p>默认情况下(没有声明@Retention)，注解保留级别为CLASS</p>\n<p><strong>@Document：指定这个注解应该包含在文档中</strong></p>\n<p>文档化的注解意味着像javadoc这样的工具生成的文档中会包含这些注解。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Documented</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</div><div class=\"line\">public @interface Deprecated &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>@Deprecated是文档化的注解，URLDecoder.decode(String s)方法应用了这个注解：</p>\n<img src=\"/2017/03/31/java注解/decode.jpg\" alt=\"decode\" title=\"decode\">\n<img src=\"/2017/03/31/java注解/doc.jpg\" alt=\"doc\" title=\"doc\">\n<p>可以在文档中看到Deprecated的出现。</p>\n<p><strong>@Inherited: 指定一个注解，当他应用于一个类的时候，能够自动被其子类继承</strong></p>\n<p>@Inherited只能应用于对类的注解。如果一个类具有继承注解，那么他的所有子类都自动具有同样的注解。</p>\n<p>比如，定义了一个继承注解@Secret表示一个类是隐私的不可被序列化传输的，那么该类的子类会被自动注解为不可序列化传输的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Inherited</div><div class=\"line\">@interface Secret&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Secret class A&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">class B extends A&#123;&#125; //同样是@Secret的</div></pre></td></tr></table></figure>\n<p>当注解工具去获取声明了@Secret的对象时，他能够获取到A的对象和B的对象。</p>\n<ul>\n<li>预定义注解</li>\n</ul>\n<p>常用的有三个：@override、@Deprecated、@SuppressWarnings，具体的作用可以查文档或者源码，不再赘述。</p>\n<h2 id=\"注解的定义\"><a href=\"#注解的定义\" class=\"headerlink\" title=\"注解的定义\"></a>注解的定义</h2><p>上面的讨论中已经涉及到了注解的定义。一个注解是由一个注解接口来定义的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Result &#123;</div><div class=\"line\">\tString name();</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每个元素的声明有两种形式，有默认值和没有默认值的，就像上面那样。注解的元素可以是下面之一：</p>\n<p>基本类型|String|Class类型|enum|注解类型|由前面所述类型构成的数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface BugReport&#123;</div><div class=\"line\">\tenum Status&#123;FIXED,OPEN,NEW,CLOSE&#125;;</div><div class=\"line\">\tboolean isIgnore() default false;</div><div class=\"line\">\tString id();</div><div class=\"line\">\tClass&lt;?&gt; testCase() default Void.class;</div><div class=\"line\">\tStatus status() default Status.NEW;</div><div class=\"line\">\tAuthor author() default @Author;</div><div class=\"line\">\tString[] reportMsg() default &quot;&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，虽然注解元素可以是另一个注解，但是不能在注解中引入循环依赖，比如@BugReport依赖@Author，而@Author又依赖@BugReport。同时，注解元素也不可以为null，元素的值必须是编译期常量。</p>\n<p>我们可以通过在注解的定义前声明之前提到的元注解来定制我们的注解，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(&#123; ElementType.METHOD, ElementType.FIELD &#125;)</div><div class=\"line\">@Inherited</div><div class=\"line\">@Documented</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@interface Result &#123;</div><div class=\"line\">\tString name() default &quot;&quot;;</div><div class=\"line\">\tint value() default -1;</div><div class=\"line\">\tString[] reportMsg() default &quot;&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所有的注解接口隐式的继承自java.lang.annotation.Annotation接口。这是一个正常的接口，而不是注解接口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Annotation &#123;</div><div class=\"line\">    boolean equals(Object obj);</div><div class=\"line\">    int hashCode();</div><div class=\"line\">    String toString();</div><div class=\"line\">    Class&lt;? extends Annotation&gt; annotationType();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>也就是说，注解接口也是普通接口的一种。注解接口中的元素实际上也是方法的声明，这些方法类似于bean的get、set，我们使用@Result(name=”A”)的形式实际上是调用了set方法给某个变量赋值。</p>\n<p>既然是接口，那么就应该有实现(不然怎么用呢？)。我们不需要主动提供实现了注解接口的类，虚拟机会在需要的时候产生一些代理类和对象。下文会提到。</p>\n<p>既然可以为注解元素赋值，那么必定有方法去获得这些值。也就是注解的解析。</p>\n<h2 id=\"注解的解析\"><a href=\"#注解的解析\" class=\"headerlink\" title=\"注解的解析\"></a>注解的解析</h2><p>我们定义了注解并且应用了注解，但是仅仅这样的话注解并不会起到什么作用。需要我们提供一种工具去解析声明的注解，然后实现一些自动配置或者生成报告的功能。这就是注解的解析。</p>\n<ul>\n<li>源代码中的注解</li>\n</ul>\n<p>注解的用处之一就是自动生成一些包含程序额外信息的文件。比如，根据注解生成代码进度报告，或者bug修复报告等。生成的文件可以是属性文件、xml文件、html文档或者shell脚本。也可以生成java源文件。</p>\n<p>注解处理器通常通过集成AbstractProcessor类实现了Processor接口，通过process方法实现处理源码中注解的逻辑。通过声明具体的注解类型来指定该处理器处理哪些注解。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SupportedAnnotationTypes(&quot;space.yukai.annotations.BUG&quot;)</div><div class=\"line\">class AnnotationProcessor extends AbstractProcessor &#123;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\treturn false;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>process的两个参数：annotations代表了要处理的注解集，roundEnv是包含有关当前处理循环信息的RoundEnv引用。</p>\n<p><a href=\"http://www.race604.com/annotation-processing/\">Java注解处理器</a>这篇文章以通过注解自动生成工厂类文件为例，详细介绍了如何处理源码级别的注解。（英文原文在这：<a href=\"http://hannesdorfmann.com/annotation-processing/annotationprocessing101）\">http://hannesdorfmann.com/annotation-processing/annotationprocessing101）</a></p>\n<p>注意，我们虽然可以通过源码级别的注解处理器生成新的文件，却很难编辑源文件，比如，通过处理注解自动生成get、set方法。字节码级别的处理器是可以的。</p>\n<ul>\n<li>字节码中的注解</li>\n</ul>\n<p>字节码级别的注解，即存在于class文件中的注解。我们还可以通过BCEL这样的字节码工程类库修改或插入字节码来改变类文件。比如在声明了@LogEntity的方法开始部分插入打印日志信息的字节码。</p>\n<p>涉及的不多，不再赘述。</p>\n<ul>\n<li>运行时的注解</li>\n</ul>\n<p>在运行时处理注解是比较常见的注解处理手段。一般是通过反射API获取到我们的注解信息，从而实现一些功能。</p>\n<p>下面是自己写的一个例子，通过解析BugReport注解得到一些测试信息，然后通过动态代理的方式生成代理测试类，最后运行测试自动生成测试报告。（不要在意代码有什么缺陷或者其他问题，仅仅是一个例子而已～）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\">package space.kyu.proxy;</div><div class=\"line\"></div><div class=\"line\">import java.lang.annotation.ElementType;</div><div class=\"line\">import java.lang.annotation.Retention;</div><div class=\"line\">import java.lang.annotation.RetentionPolicy;</div><div class=\"line\">import java.lang.annotation.Target;</div><div class=\"line\">import java.lang.reflect.InvocationHandler;</div><div class=\"line\">import java.lang.reflect.Method;</div><div class=\"line\">import java.lang.reflect.Proxy;</div><div class=\"line\">import java.util.ArrayList;</div><div class=\"line\">import java.util.List;</div><div class=\"line\"></div><div class=\"line\">public class AnnotationsTest &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tTestBug testBug = new TestBug(true);</div><div class=\"line\">\t\tTestBug testBug1 = new TestBug(false);</div><div class=\"line\">\t\tTestExecutor executor = new TestExecutor();</div><div class=\"line\">\t\texecutor.addTest(testBug);</div><div class=\"line\">\t\texecutor.addTest(testBug1);</div><div class=\"line\">\t\texecutor.executeTest();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class TestExecutor &#123;</div><div class=\"line\">\tprivate List&lt;Test&gt;  testCases;</div><div class=\"line\">\tpublic TestExecutor() &#123;</div><div class=\"line\">\t\ttestCases = new ArrayList&lt;Test&gt;();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic &lt;T extends Test&gt; void  addTest(T testCase) &#123;</div><div class=\"line\">\t\tClass&lt;? extends Object&gt; cl = testCase.getClass();</div><div class=\"line\">\t\tMethod[] declaredMethods = cl.getDeclaredMethods();</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tfor (Method method : declaredMethods) &#123;</div><div class=\"line\">\t\t\t\tif (method.isAnnotationPresent(BugReport.class)) &#123;</div><div class=\"line\">\t\t\t\t\tBugReport annotation = method.getAnnotation(BugReport.class);</div><div class=\"line\">\t\t\t\t\tif (annotation != null) &#123;</div><div class=\"line\">\t\t\t\t\t\tSystem.out.println(annotation.toString());</div><div class=\"line\">\t\t\t\t\t\tSystem.out.println(annotation.annotationType().getName());</div><div class=\"line\">\t\t\t\t\t\tSystem.out.println(annotation.getClass().getName());</div><div class=\"line\">\t\t\t\t\t\tString bugId = annotation.id();</div><div class=\"line\">\t\t\t\t\t\tString bugMsg = annotation.msg();</div><div class=\"line\">\t\t\t\t\t\tTest obj = (Test) createBugReportHandler(testCase,bugId,bugMsg);</div><div class=\"line\">\t\t\t\t\t\ttestCases.add(obj);</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; catch (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\tthrow new IllegalStateException(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void executeTest() &#123;</div><div class=\"line\">\t\tfor (Test test : testCases) &#123;</div><div class=\"line\">\t\t\ttest.test();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tprivate Object createBugReportHandler(Test testCase, final String bugId, final String bugMsg) &#123;</div><div class=\"line\">\t\treturn Proxy.newProxyInstance(testCase.getClass().getClassLoader(), testCase.getClass().getInterfaces(), new InvocationHandler() &#123;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\t@Override</div><div class=\"line\">\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class=\"line\">\t\t\t\tboolean res = (boolean) method.invoke(testCase, args);</div><div class=\"line\">\t\t\t\t//也可以输出到文件中形成测试报告</div><div class=\"line\">\t\t\t\tSystem.out.println(&quot;******************************&quot;);</div><div class=\"line\">\t\t\t\tSystem.out.println(&quot;bug: &quot; + bugId + &quot;测试结果：&quot;);</div><div class=\"line\">\t\t\t\tif (res) &#123;//测试通过</div><div class=\"line\">\t\t\t\t\tSystem.out.println(&quot;已通过&quot;);</div><div class=\"line\">\t\t\t\t&#125; else &#123;//测试不通过</div><div class=\"line\">\t\t\t\t\tSystem.out.println(&quot;未通过&quot;);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tSystem.out.println(&quot;备注信息：&quot; + bugMsg);</div><div class=\"line\">\t\t\t\treturn res;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">interface Test &#123;</div><div class=\"line\">\t/**</div><div class=\"line\">\t * 测试方法 2017年4月1日</div><div class=\"line\">\t * @return </div><div class=\"line\">\t * true 通过测试 </div><div class=\"line\">\t * false 未通过测试</div><div class=\"line\">\t */</div><div class=\"line\">\tboolean test();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class TestBug implements Test &#123;</div><div class=\"line\">\tboolean fixed;</div><div class=\"line\">\tpublic TestBug(boolean fixed) &#123;</div><div class=\"line\">\t\t//控制测试成功或失败</div><div class=\"line\">\t\tthis.fixed = fixed;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@BugReport(id = &quot;bug001&quot;, msg = &quot;bug注释：这是一条测试bug&quot;)</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean test() &#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;执行测试...&quot;);</div><div class=\"line\">\t\t//假装测试成功或者失败了</div><div class=\"line\">\t\treturn fixed;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Target(ElementType.METHOD)</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@interface BugReport &#123;</div><div class=\"line\">\tString id();</div><div class=\"line\"></div><div class=\"line\">\tString msg();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)</div><div class=\"line\">space.kyu.proxy.BugReport</div><div class=\"line\">space.kyu.proxy.$Proxy1</div><div class=\"line\">@space.kyu.proxy.BugReport(id=bug001, msg=bug注释：这是一条测试bug)</div><div class=\"line\">space.kyu.proxy.BugReport</div><div class=\"line\">space.kyu.proxy.$Proxy1</div><div class=\"line\">执行测试...</div><div class=\"line\">******************************</div><div class=\"line\">bug: bug001测试结果：</div><div class=\"line\">已通过</div><div class=\"line\">备注信息：bug注释：这是一条测试bug</div><div class=\"line\">执行测试...</div><div class=\"line\">******************************</div><div class=\"line\">bug: bug001测试结果：</div><div class=\"line\">未通过</div><div class=\"line\">备注信息：bug注释：这是一条测试bug</div></pre></td></tr></table></figure>\n<p>上面的代码很简单，我们要注意的有几点：</p>\n<p>1.<code>method.isAnnotationPresent(BugReport.class)</code>和 <code>method.getAnnotation(BugReport.class)</code></p>\n<p>这两个方法来自于接口AnnotatedElement，Method、Field、Package、Constructor、Class这些类都实现了这个接口，使得这些类拥有了提供所声明的注解的功能。</p>\n<p>通过method.getAnnotation(BugReport.class)得到了声明在方法上的BugReport注解，获得这个注解的实例之后，我们就可以调用以该注解声明的元素为名称的方法来获取对应的元素值了。</p>\n<p>2.<code>annotation.annotationType().getName()</code>和<code>annotation.getClass().getName()</code></p>\n<p>annotation.annotationType()方法上面已经提到过了，是Annotation的一个方法，用于描述该注解对象的注解接口。这个方法返回的内容为：space.kyu.proxy.BugReport</p>\n<p>annotation.getClass()获得了实现了Annotation接口的代理类，通过调用getName()方法可以打印这个代理类的名称：space.kyu.proxy.$Proxy1。从而印证了我们上面所说，确实自动生成了代理类。</p>\n<p>上面的例子很简单，说白了，注解就是给代码加了一些额外的信息，这些信息对代码里面的逻辑是没有任何影响的。但是我们可以通过其他手段获得我们在代码中的注解，从而实现一些重复性的工作。这就是注解的作用。</p>"},{"layout":"post","date":"2016-04-12T04:48:55.000Z","title":"Junit的使用","_content":"\n>[Junit](http://junit.org/junit4/)是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。\n\n\n\n<!-- more -->\n\n\n\n**资料**\n\n[Unit Testing with JUnit - Tutorial](http://www.vogella.com/tutorials/JUnit/article.html)\n\n[JUnit Tutorial](http://www.tutorialspoint.com/junit/)\n\n[走进java测试利器-junit](http://developer.51cto.com/art/201103/252490.htm)\n\n","source":"_posts/junit使用.md","raw":"---\nlayout: post\ndate:   2016-04-12 12:48:55\ntitle: \"Junit的使用\"\ncategories: 工具\ntags: \n- junit\n- 测试\n---\n\n>[Junit](http://junit.org/junit4/)是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。\n\n\n\n<!-- more -->\n\n\n\n**资料**\n\n[Unit Testing with JUnit - Tutorial](http://www.vogella.com/tutorials/JUnit/article.html)\n\n[JUnit Tutorial](http://www.tutorialspoint.com/junit/)\n\n[走进java测试利器-junit](http://developer.51cto.com/art/201103/252490.htm)\n\n","slug":"junit使用","published":1,"updated":"2017-04-11T13:08:38.846Z","comments":1,"photos":[],"link":"","_id":"cj4vch4fb002sx3gcp30cgktp","content":"<blockquote>\n<p><a href=\"http://junit.org/junit4/\" target=\"_blank\" rel=\"external\">Junit</a>是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><strong>资料</strong></p>\n<p><a href=\"http://www.vogella.com/tutorials/JUnit/article.html\" target=\"_blank\" rel=\"external\">Unit Testing with JUnit - Tutorial</a></p>\n<p><a href=\"http://www.tutorialspoint.com/junit/\" target=\"_blank\" rel=\"external\">JUnit Tutorial</a></p>\n<p><a href=\"http://developer.51cto.com/art/201103/252490.htm\" target=\"_blank\" rel=\"external\">走进java测试利器-junit</a></p>\n","excerpt":"<blockquote>\n<p><a href=\"http://junit.org/junit4/\">Junit</a>是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。</p>\n</blockquote>","more":"<p><strong>资料</strong></p>\n<p><a href=\"http://www.vogella.com/tutorials/JUnit/article.html\">Unit Testing with JUnit - Tutorial</a></p>\n<p><a href=\"http://www.tutorialspoint.com/junit/\">JUnit Tutorial</a></p>\n<p><a href=\"http://developer.51cto.com/art/201103/252490.htm\">走进java测试利器-junit</a></p>"},{"layout":"post","title":"java线程池的使用","date":"2017-05-08T12:37:58.000Z","_content":"> 在并发应用程序中，线程池是很重要的一块。读完《java并发编程实战》以及研究了一遍jdk源代码之后，总结一下线程池方面的知识~\n\n{% asset_img pool.jpg 线程池 %}\n\n## 使用线程池的原因\n<!-- more -->\n\n1. 无线创建线程的不足\n\n   在生产环境中，为每一个任务都分配一个线程这种方法存在一些缺陷：\n\n   - 线程生命周期的开销：线程的创建与销毁都会消耗大量资源，频繁创建与销毁线程会带来很大的资源开销\n\n   - 资源消耗：活跃的线程会消耗系统资源。如果可运行的线程数量大于可用的处理器数量，闲置的线程会占用许多内存，并且频繁的线程上下文切换也会带来很大的性能开销\n\n   - 稳定性：操作系统在可创建的线程数量上有一个限制。在高负载情况下，应用程序很有可能突破这个限制，资源耗尽后很可能抛出OutOfMemoryError异常\n\n2. 提高响应速度\n\n   任务到达时，不再需要创建线程就可以立即执行\n\n3. 线程池提供了管理线程的功能\n\n   比如，可以统计任务的完成情况，统计活跃线程与闲置线程的数量等\n\n## 使用场景\n\n   - 不适用场合\n\n   1. 依赖性任务\n\n      在线程池中，如果任务依赖于其他任务，那么可能产生死锁。比如，在单线程的Executor中，如果一个任务将另一个任务提交到同一个Executor，并且等待这个被提交任务的结果，那么通常会引发死锁\n\n   2. 使用ThreadLocal的任务\n        \n      ThreadLocal可以存储线程级变量，将变量封闭到特定的线程当中。然而使用线程池时，这些线程都会被自由的重用，在线程池的线程中不应该使用ThreadLocal在任务之间传递值。\n\n      当线程本地值的生命周期受限于任务的生命周期时，可以在线程池的线程中使用ThreadLocal，任务结束后调用ThreadLocal.remove方法将已存储的值清除。\n    \n   3. 使用线程封闭机制的任务\n        \n      在单线程应用程序中，不用考虑对象的并发安全问题，他们都被很好的封闭在单个线程当中。如果将单线程的环境换成线程池，那么这些对象有可能造成并发安全问题，失去线程安全性\n\n   4. 不同类型或运行时长差异较大的任务\n\n      不同类型任务之间很可能存在依赖，并且他们执行的时长也不相同，在线程池中运行时很有可能造成拥塞，甚至死锁\n\n   - 适用场合\n\n     当任务是同类型且相互独立时，线程池的性能可以达到最佳\n\n     网页服务器、文件服务器、邮件服务器，他们的请求往往是同类型且相互独立的\n\n## 架构\n\n在[线程池异常处理方案](http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/)这篇博客中已经提到了线程池的架构，如图：\n\n{% asset_img pool_uml.png 线程池uml %}\n\n**Executor**：异步任务执行框架的基础\n\n```java\npublic interface Executor {\n    void execute(Runnable command);\n}\n```\n通过使用Executor，将请求处理任务的提交与任务的实际执行解耦，只需要采用另一种不同的Executor实现，就可以改变服务器的行为。比如：\n\n```java\n// 为每个任务分配一个线程\npublic class ThreadPerTaskExecutor implements Executor {\n    @Override\n    public void execute(Runnable r) {\n        new Thread(r).start();\n    }\n}\n// 以同步的方式执行每个任务\npublic class WithinThreadExecutor implements Executor{\n\t@Override\n\tpublic void execute(Runnable r) {\n\t\tr.run();\n\t}\n}\n```\n\n**ExecutorService**：ExecutorService扩展了Executor接口，添加了一些用于管理生命周期和任务提交的方法\n\n```java\npublic interface ExecutorService extends Executor {\n    // 生命周期管理\n    void shutdown();\n\n    List<Runnable> shutdownNow();\n\n    boolean isShutdown();\n\n    boolean isTerminated();\n\n    boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    // 任务提交\n    <T> Future<T> submit(Callable<T> task);\n\n    <T> Future<T> submit(Runnable task, T result);\n\n    Future<?> submit(Runnable task);\n\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException;\n\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,\n                                  long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException, ExecutionException;\n\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks,\n                    long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n```\n\nExecutorService的生命周期有3中状态：运行、关闭、终止。ExecutorService在初始创建时处于运行状态。shutdown方法执行平缓的关闭过程：不再接受新任务，同时等待已提交的任务执行完成，包括在任务队列中尚未开始的任务。shutdownNow方法将尝试取消所有运行中的任务，并不再启动队列中尚未执行的任务。\n\n所有任务完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过轮询isTerminated来判断ExecutorService是否终止。\n\n**AbstractExecutorService ThreadPoolExecutor ScheduledThreadPoolExecutor**: 线程池的实现\n\nThreadPoolExecutor扩展了ExecutorService接口，是线程池的具体实现。ScheduledThreadPoolExecutor支持定时以及周期性任务的执行。\n\nThreadPoolExecutor支持两种方式的任务提交：`exec.execute(Runnable r)`以及`exec.submit(Runnable r)`。关于任务的这两种提交方式在[线程池异常处理方案](http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/)已经提到过了，不再赘述。\n\n## 定制线程池\n\n先来了解一下线程池的创建：\n\n```java\nThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n```\n以上是ThreadPoolExecutor的构造函数，看一下每个参数的含义：\n\n1. corePoolSize\n\ncorePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。\n\n2. runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。\n\n    - ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。\n\n    - LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。\n\n    - SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。\n\n    - PriorityBlockingQueue：一个具有优先级的无限阻塞队列。\n\n3. maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。\n\n4. ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。\n\n5. RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。下面会有介绍几种饱和策略。\n\n6. keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。\n\n7. TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。\n\n{% asset_img pool_execute.jpg 执行任务 %}\n\n### 设置线程池的大小\n\n线程池过大，会导致大量的线程在很少的cpu和内存资源上发生竞争，频繁的线程上下文切换也会带来额外的性能开销。线程池过小，导致许多空闲的处理器无法执行工作，降低吞吐率。\n\n1. cpu密集型\n\n对于计算密集型的任务，当系统拥有n个处理器时，将线程池大小设置为n+1通常可以实现最优利用率。\n\n2. io密集型\n\n对于包含io操作或其他阻塞操作的任务，由于线程不会一直执行，因此线程池的规模应该更大。有这么一个简单的公式：\n\n`N[threads] = N[cpu] * U[cpu] * (1 + W/C)`\n\n其中，N[threads]是线程池的大小，U[cpu]是cpu的利用率，W/C是任务等待时间与任务执行时间的比值。\n\n可以通过一些监控工具获得cpu利用率等，`Runtime.getRuntime().availableProcessors()`返回cpu的数目\n\n3. 资源依赖\n\n如果任务还依赖一些其他的有限资源，比如数据库连接，文件句柄等，那么这些资源也会影响线程池的大小：计算每个任务对该资源的需求量，用该资源的可用总量除以每个任务的需求量，所得的结果就是线程池大小的上限。\n\n### Executors\n\nExecutors提供了许多静态工厂方法来创建一个线程池：\n\n```\nnewCachedThreadPool\n创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\nnewFixedThreadPool\n创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\nnewSingleThreadExecutor\n创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\nnewScheduledThreadPool\n创建一个定长线程池，支持定时及周期性任务执行。\n```\n具体情况可以结合Executors源码和ThreadPoolExecutor的构造函数查看。我们也可以模仿Executors的这几个工厂方法来定制自己的线程池执行策略。\n\n### 扩展ThreadPoolExecutor\n\n1. 在[线程池异常处理方案](http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/)这篇总结曾经提到重写ThreadPoolExecutor的afterExecute方法来处理未检测异常，这就是扩展ThreadPoolExecutor的一个例子。除此之外，还可以在这些方法中添加日志、计时、监视等功能。\n\n线程池完成关闭操作后会调用方法terminated。terminated可以用来释放Executor在其生命周期中分配的各种资源，以及执行发送通知、记录日志等操作。\n\n下面编写一个利用beforeExecute、afterExecute和terminated添加日志记录和统计信息收集的扩展ThreadPoolExecutor。\n\n```java\npublic class TimingThreadPool extends ThreadPoolExecutor{\n\t// 使用ThreadLocal存储任务起始时间，在beforeExecute设置起始时间，在afterExecute中可以看到这个值\n\tprivate final ThreadLocal<Long> startTime = new ThreadLocal<>();\n\tprivate final Logger logger = Logger.getLogger(TimingThreadPool.class.getName());\n\tprivate final AtomicLong numTasks = new AtomicLong();\n    private final AtomicLong totalTime = new AtomicLong();\n    \n\tpublic TimingThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,\n\t\t\tBlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n\t\tsuper(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);\n\t}\n\t\n\t@Override\n\tprotected void beforeExecute(Thread t, Runnable r) {\n\t\tsuper.beforeExecute(t, r);\n\t\tlogger.fine(String.format(\"Thread %s: start %s\", t, r));\n\t\tstartTime.set(System.nanoTime());\n\t}\n\t\n\t@Override\n\tprotected void afterExecute(Runnable r, Throwable t) {\n\t\ttry {\n\t\t\tlong endTime = System.nanoTime();\n\t\t\tlong taskTime = endTime - startTime.get();\n\t\t\tnumTasks.incrementAndGet();\n\t\t\ttotalTime.addAndGet(taskTime);\n\t\t\tlogger.fine(String.format(\"Thread %s: end %s, time=%dns\", t, r, taskTime));\n\t\t} finally {\n\t\t\tsuper.afterExecute(r, t);\n\t\t}\n\t}\n\t\n\t@Override\n\tprotected void terminated() {\n\t\ttry {\n\t\t\tlogger.fine(String.format(\"Terminated: avg time=%dns\", totalTime.get()/numTasks.get()));\n\t\t} finally {\n\t\t\tsuper.terminated();\n\t\t}\n\t}\n\n}\n```\n\n2. 扩展ThreadPoolExecutor的newTaskFor方法可以修改通过submit方法返回的默认Future实现FutureTask为自己的实现。在我们自己实现Future的类中可以针对任务做一些操作，比如定制任务的取消行为：\n\n```java\npublic class CacellingExecutor extends ThreadPoolExecutor {\n\n\tpublic CacellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,\n\t\t\tBlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n\t\tsuper(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);\n\t}\n\t\n\t@Override\n\tprotected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n\t\tif (callable instanceof CancellableTask) {\n\t\t\treturn ((CancellableTask<T>)callable).newTask();\n\t\t}\n\t\treturn super.newTaskFor(callable);\n\t}\n\n}\ninterface CancellableTask<T> extends Callable<T> {\n\tvoid cancel();\n\tRunnableFuture<T> newTask();\n}\n\nabstract class SocketUsingTask<T> implements CancellableTask<T> {\n\tprivate Socket socket;\n\tpublic SocketUsingTask(Socket socket) {\n\t\tthis.socket = socket;\n\t}\n\t@Override\n\tpublic void cancel() {在并发应用程序中，线程池是很重要的一块。读完《java并发编程实战》以及研究了一遍jdk源代码之后，总结一下线程池方面的知识~\n\t\ttry {\n\t\t\tthis.socket.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t@Override\n\tpublic RunnableFuture<T> newTask() {\n\t\treturn new FutureTask<T>(this){\n\t\t\t@Override\n\t\t\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n\t\t\t\ttry {\n\t\t\t\t\tSocketUsingTask.this.cancel();\n\t\t\t\t} finally {\n\t\t\t\t\treturn super.cancel(mayInterruptIfRunning);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n}\n```\n\n## 异常处理\n\n异常处理这部分，在前面的博客中已经总结过了：[线程池异常处理方案](http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/)\n\n## 饱和策略\n\n当线程池达到饱和以后(maximumPoolSzie)，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略可以通过setRejectedExecutionHandler来修改。当某个任务被提交到一个已经关闭的Executor时，也会用到饱和策略。jdk提供了几种不同的RejectedExecutionHandler实现：\n\n1. AbortPolicy\n\n```java\npublic static class AbortPolicy implements RejectedExecutionHandler {\n        public AbortPolicy() { }\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }\n    }\n```\nAbortPolicy是默认的饱和策略，该饱和策略将抛出未检查的RejectedExecutionException。调用者可以处理这个异常。\n\n2. CallerRunsPolicy\n\n```java\npublic static class CallerRunsPolicy implements RejectedExecutionHandler {\n        public CallerRunsPolicy() { }\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            if (!e.isShutdown()) {\n                r.run();\n            }\n        }\n    }\n```\nCallerRunsPolicy将任务回退到调用者，他不会在线程池的某个线程中提交任务，而是在调用execute的线程中运行，从而降低新任务的流量。\n\n3. DiscardPolicy\n\n```java\npublic static class DiscardPolicy implements RejectedExecutionHandler {\n        public DiscardPolicy() { }\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n        }\n    }\n```\nDiscardPolicy会悄悄抛弃任务，什么也不做。\n\n4. DiscardOldestPolicy\n\n```java\npublic static class DiscardOldestPolicy implements RejectedExecutionHandler {\n        public DiscardOldestPolicy() { }\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            if (!e.isShutdown()) {\n                e.getQueue().poll();\n                e.execute(r);\n            }\n        }\n    }\n```\nDiscardOldestPolicy会抛弃下一个将被执行的任务，然后重新尝试提交任务。\n\n## 其他\n\n1. CompletionService\n\n如果向Executor提交了一组计算任务，并希望在计算完成后获取结果，那么可以保留与每个任务关联的Future，然后轮询这些future的get方法，判断任务是否完成。这种方法虽然可行，但是有些繁琐。\n\nCompletionService将Executor和BlockingQueue的功能融合在一起，可以将任务提交给他执行，然后使用类似于队列的take或poll方法获取已完成结果。\n\nExecutorCompletionService 实现了CompletionService，他的实现很简单，在构造函数中创建一个BlockingQueue来保存计算完成的结果。当提交某个任务时，该任务首先包装成为一个QueueingFuture,这是FutureTask的一个子类，他改写了done方法，将结果放入BlockingQueue中。ExecutorCompletionService的take和poll方法委托给了BlockingQueue。\n\n2. ScheduledThreadPoolExecutor\n\nScheduledThreadPoolExecutor以延迟或定时的方式执行任务，类似于Timer。由于Timer的一些缺陷，可以使用ScheduledThreadPoolExecutor来代替Timer。\n\nTimer在执行所有的定时任务时只会创建一个线程，如果某个任务执行时间过长，就会破坏其他TimerTask的定时准确性。TimerTask抛出异常后，Timer线程也不会捕获这个异常，从而终止定时线程。尚未执行的TimerTask不会再执行，新的任务也不会被调度。\n\n## 参考\n\n[java并发编程实战](https://book.douban.com/subject/10484692/)\n\n[聊聊并发（三）——JAVA线程池的分析和使用](http://www.infoq.com/cn/articles/java-threadPool)\n","source":"_posts/java线程池的使用.md","raw":"---\nlayout: post\ntitle: java线程池的使用\ndate: 2017-05-08 20:37:58\ncategories: 编程\ntags: \n- java\n- 多线程\n---\n> 在并发应用程序中，线程池是很重要的一块。读完《java并发编程实战》以及研究了一遍jdk源代码之后，总结一下线程池方面的知识~\n\n{% asset_img pool.jpg 线程池 %}\n\n## 使用线程池的原因\n<!-- more -->\n\n1. 无线创建线程的不足\n\n   在生产环境中，为每一个任务都分配一个线程这种方法存在一些缺陷：\n\n   - 线程生命周期的开销：线程的创建与销毁都会消耗大量资源，频繁创建与销毁线程会带来很大的资源开销\n\n   - 资源消耗：活跃的线程会消耗系统资源。如果可运行的线程数量大于可用的处理器数量，闲置的线程会占用许多内存，并且频繁的线程上下文切换也会带来很大的性能开销\n\n   - 稳定性：操作系统在可创建的线程数量上有一个限制。在高负载情况下，应用程序很有可能突破这个限制，资源耗尽后很可能抛出OutOfMemoryError异常\n\n2. 提高响应速度\n\n   任务到达时，不再需要创建线程就可以立即执行\n\n3. 线程池提供了管理线程的功能\n\n   比如，可以统计任务的完成情况，统计活跃线程与闲置线程的数量等\n\n## 使用场景\n\n   - 不适用场合\n\n   1. 依赖性任务\n\n      在线程池中，如果任务依赖于其他任务，那么可能产生死锁。比如，在单线程的Executor中，如果一个任务将另一个任务提交到同一个Executor，并且等待这个被提交任务的结果，那么通常会引发死锁\n\n   2. 使用ThreadLocal的任务\n        \n      ThreadLocal可以存储线程级变量，将变量封闭到特定的线程当中。然而使用线程池时，这些线程都会被自由的重用，在线程池的线程中不应该使用ThreadLocal在任务之间传递值。\n\n      当线程本地值的生命周期受限于任务的生命周期时，可以在线程池的线程中使用ThreadLocal，任务结束后调用ThreadLocal.remove方法将已存储的值清除。\n    \n   3. 使用线程封闭机制的任务\n        \n      在单线程应用程序中，不用考虑对象的并发安全问题，他们都被很好的封闭在单个线程当中。如果将单线程的环境换成线程池，那么这些对象有可能造成并发安全问题，失去线程安全性\n\n   4. 不同类型或运行时长差异较大的任务\n\n      不同类型任务之间很可能存在依赖，并且他们执行的时长也不相同，在线程池中运行时很有可能造成拥塞，甚至死锁\n\n   - 适用场合\n\n     当任务是同类型且相互独立时，线程池的性能可以达到最佳\n\n     网页服务器、文件服务器、邮件服务器，他们的请求往往是同类型且相互独立的\n\n## 架构\n\n在[线程池异常处理方案](http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/)这篇博客中已经提到了线程池的架构，如图：\n\n{% asset_img pool_uml.png 线程池uml %}\n\n**Executor**：异步任务执行框架的基础\n\n```java\npublic interface Executor {\n    void execute(Runnable command);\n}\n```\n通过使用Executor，将请求处理任务的提交与任务的实际执行解耦，只需要采用另一种不同的Executor实现，就可以改变服务器的行为。比如：\n\n```java\n// 为每个任务分配一个线程\npublic class ThreadPerTaskExecutor implements Executor {\n    @Override\n    public void execute(Runnable r) {\n        new Thread(r).start();\n    }\n}\n// 以同步的方式执行每个任务\npublic class WithinThreadExecutor implements Executor{\n\t@Override\n\tpublic void execute(Runnable r) {\n\t\tr.run();\n\t}\n}\n```\n\n**ExecutorService**：ExecutorService扩展了Executor接口，添加了一些用于管理生命周期和任务提交的方法\n\n```java\npublic interface ExecutorService extends Executor {\n    // 生命周期管理\n    void shutdown();\n\n    List<Runnable> shutdownNow();\n\n    boolean isShutdown();\n\n    boolean isTerminated();\n\n    boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    // 任务提交\n    <T> Future<T> submit(Callable<T> task);\n\n    <T> Future<T> submit(Runnable task, T result);\n\n    Future<?> submit(Runnable task);\n\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException;\n\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,\n                                  long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException, ExecutionException;\n\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks,\n                    long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n```\n\nExecutorService的生命周期有3中状态：运行、关闭、终止。ExecutorService在初始创建时处于运行状态。shutdown方法执行平缓的关闭过程：不再接受新任务，同时等待已提交的任务执行完成，包括在任务队列中尚未开始的任务。shutdownNow方法将尝试取消所有运行中的任务，并不再启动队列中尚未执行的任务。\n\n所有任务完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过轮询isTerminated来判断ExecutorService是否终止。\n\n**AbstractExecutorService ThreadPoolExecutor ScheduledThreadPoolExecutor**: 线程池的实现\n\nThreadPoolExecutor扩展了ExecutorService接口，是线程池的具体实现。ScheduledThreadPoolExecutor支持定时以及周期性任务的执行。\n\nThreadPoolExecutor支持两种方式的任务提交：`exec.execute(Runnable r)`以及`exec.submit(Runnable r)`。关于任务的这两种提交方式在[线程池异常处理方案](http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/)已经提到过了，不再赘述。\n\n## 定制线程池\n\n先来了解一下线程池的创建：\n\n```java\nThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n```\n以上是ThreadPoolExecutor的构造函数，看一下每个参数的含义：\n\n1. corePoolSize\n\ncorePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。\n\n2. runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。\n\n    - ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。\n\n    - LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。\n\n    - SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。\n\n    - PriorityBlockingQueue：一个具有优先级的无限阻塞队列。\n\n3. maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。\n\n4. ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。\n\n5. RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。下面会有介绍几种饱和策略。\n\n6. keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。\n\n7. TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。\n\n{% asset_img pool_execute.jpg 执行任务 %}\n\n### 设置线程池的大小\n\n线程池过大，会导致大量的线程在很少的cpu和内存资源上发生竞争，频繁的线程上下文切换也会带来额外的性能开销。线程池过小，导致许多空闲的处理器无法执行工作，降低吞吐率。\n\n1. cpu密集型\n\n对于计算密集型的任务，当系统拥有n个处理器时，将线程池大小设置为n+1通常可以实现最优利用率。\n\n2. io密集型\n\n对于包含io操作或其他阻塞操作的任务，由于线程不会一直执行，因此线程池的规模应该更大。有这么一个简单的公式：\n\n`N[threads] = N[cpu] * U[cpu] * (1 + W/C)`\n\n其中，N[threads]是线程池的大小，U[cpu]是cpu的利用率，W/C是任务等待时间与任务执行时间的比值。\n\n可以通过一些监控工具获得cpu利用率等，`Runtime.getRuntime().availableProcessors()`返回cpu的数目\n\n3. 资源依赖\n\n如果任务还依赖一些其他的有限资源，比如数据库连接，文件句柄等，那么这些资源也会影响线程池的大小：计算每个任务对该资源的需求量，用该资源的可用总量除以每个任务的需求量，所得的结果就是线程池大小的上限。\n\n### Executors\n\nExecutors提供了许多静态工厂方法来创建一个线程池：\n\n```\nnewCachedThreadPool\n创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\nnewFixedThreadPool\n创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\nnewSingleThreadExecutor\n创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\nnewScheduledThreadPool\n创建一个定长线程池，支持定时及周期性任务执行。\n```\n具体情况可以结合Executors源码和ThreadPoolExecutor的构造函数查看。我们也可以模仿Executors的这几个工厂方法来定制自己的线程池执行策略。\n\n### 扩展ThreadPoolExecutor\n\n1. 在[线程池异常处理方案](http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/)这篇总结曾经提到重写ThreadPoolExecutor的afterExecute方法来处理未检测异常，这就是扩展ThreadPoolExecutor的一个例子。除此之外，还可以在这些方法中添加日志、计时、监视等功能。\n\n线程池完成关闭操作后会调用方法terminated。terminated可以用来释放Executor在其生命周期中分配的各种资源，以及执行发送通知、记录日志等操作。\n\n下面编写一个利用beforeExecute、afterExecute和terminated添加日志记录和统计信息收集的扩展ThreadPoolExecutor。\n\n```java\npublic class TimingThreadPool extends ThreadPoolExecutor{\n\t// 使用ThreadLocal存储任务起始时间，在beforeExecute设置起始时间，在afterExecute中可以看到这个值\n\tprivate final ThreadLocal<Long> startTime = new ThreadLocal<>();\n\tprivate final Logger logger = Logger.getLogger(TimingThreadPool.class.getName());\n\tprivate final AtomicLong numTasks = new AtomicLong();\n    private final AtomicLong totalTime = new AtomicLong();\n    \n\tpublic TimingThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,\n\t\t\tBlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n\t\tsuper(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);\n\t}\n\t\n\t@Override\n\tprotected void beforeExecute(Thread t, Runnable r) {\n\t\tsuper.beforeExecute(t, r);\n\t\tlogger.fine(String.format(\"Thread %s: start %s\", t, r));\n\t\tstartTime.set(System.nanoTime());\n\t}\n\t\n\t@Override\n\tprotected void afterExecute(Runnable r, Throwable t) {\n\t\ttry {\n\t\t\tlong endTime = System.nanoTime();\n\t\t\tlong taskTime = endTime - startTime.get();\n\t\t\tnumTasks.incrementAndGet();\n\t\t\ttotalTime.addAndGet(taskTime);\n\t\t\tlogger.fine(String.format(\"Thread %s: end %s, time=%dns\", t, r, taskTime));\n\t\t} finally {\n\t\t\tsuper.afterExecute(r, t);\n\t\t}\n\t}\n\t\n\t@Override\n\tprotected void terminated() {\n\t\ttry {\n\t\t\tlogger.fine(String.format(\"Terminated: avg time=%dns\", totalTime.get()/numTasks.get()));\n\t\t} finally {\n\t\t\tsuper.terminated();\n\t\t}\n\t}\n\n}\n```\n\n2. 扩展ThreadPoolExecutor的newTaskFor方法可以修改通过submit方法返回的默认Future实现FutureTask为自己的实现。在我们自己实现Future的类中可以针对任务做一些操作，比如定制任务的取消行为：\n\n```java\npublic class CacellingExecutor extends ThreadPoolExecutor {\n\n\tpublic CacellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,\n\t\t\tBlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n\t\tsuper(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);\n\t}\n\t\n\t@Override\n\tprotected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n\t\tif (callable instanceof CancellableTask) {\n\t\t\treturn ((CancellableTask<T>)callable).newTask();\n\t\t}\n\t\treturn super.newTaskFor(callable);\n\t}\n\n}\ninterface CancellableTask<T> extends Callable<T> {\n\tvoid cancel();\n\tRunnableFuture<T> newTask();\n}\n\nabstract class SocketUsingTask<T> implements CancellableTask<T> {\n\tprivate Socket socket;\n\tpublic SocketUsingTask(Socket socket) {\n\t\tthis.socket = socket;\n\t}\n\t@Override\n\tpublic void cancel() {在并发应用程序中，线程池是很重要的一块。读完《java并发编程实战》以及研究了一遍jdk源代码之后，总结一下线程池方面的知识~\n\t\ttry {\n\t\t\tthis.socket.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t@Override\n\tpublic RunnableFuture<T> newTask() {\n\t\treturn new FutureTask<T>(this){\n\t\t\t@Override\n\t\t\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n\t\t\t\ttry {\n\t\t\t\t\tSocketUsingTask.this.cancel();\n\t\t\t\t} finally {\n\t\t\t\t\treturn super.cancel(mayInterruptIfRunning);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n}\n```\n\n## 异常处理\n\n异常处理这部分，在前面的博客中已经总结过了：[线程池异常处理方案](http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/)\n\n## 饱和策略\n\n当线程池达到饱和以后(maximumPoolSzie)，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略可以通过setRejectedExecutionHandler来修改。当某个任务被提交到一个已经关闭的Executor时，也会用到饱和策略。jdk提供了几种不同的RejectedExecutionHandler实现：\n\n1. AbortPolicy\n\n```java\npublic static class AbortPolicy implements RejectedExecutionHandler {\n        public AbortPolicy() { }\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }\n    }\n```\nAbortPolicy是默认的饱和策略，该饱和策略将抛出未检查的RejectedExecutionException。调用者可以处理这个异常。\n\n2. CallerRunsPolicy\n\n```java\npublic static class CallerRunsPolicy implements RejectedExecutionHandler {\n        public CallerRunsPolicy() { }\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            if (!e.isShutdown()) {\n                r.run();\n            }\n        }\n    }\n```\nCallerRunsPolicy将任务回退到调用者，他不会在线程池的某个线程中提交任务，而是在调用execute的线程中运行，从而降低新任务的流量。\n\n3. DiscardPolicy\n\n```java\npublic static class DiscardPolicy implements RejectedExecutionHandler {\n        public DiscardPolicy() { }\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n        }\n    }\n```\nDiscardPolicy会悄悄抛弃任务，什么也不做。\n\n4. DiscardOldestPolicy\n\n```java\npublic static class DiscardOldestPolicy implements RejectedExecutionHandler {\n        public DiscardOldestPolicy() { }\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            if (!e.isShutdown()) {\n                e.getQueue().poll();\n                e.execute(r);\n            }\n        }\n    }\n```\nDiscardOldestPolicy会抛弃下一个将被执行的任务，然后重新尝试提交任务。\n\n## 其他\n\n1. CompletionService\n\n如果向Executor提交了一组计算任务，并希望在计算完成后获取结果，那么可以保留与每个任务关联的Future，然后轮询这些future的get方法，判断任务是否完成。这种方法虽然可行，但是有些繁琐。\n\nCompletionService将Executor和BlockingQueue的功能融合在一起，可以将任务提交给他执行，然后使用类似于队列的take或poll方法获取已完成结果。\n\nExecutorCompletionService 实现了CompletionService，他的实现很简单，在构造函数中创建一个BlockingQueue来保存计算完成的结果。当提交某个任务时，该任务首先包装成为一个QueueingFuture,这是FutureTask的一个子类，他改写了done方法，将结果放入BlockingQueue中。ExecutorCompletionService的take和poll方法委托给了BlockingQueue。\n\n2. ScheduledThreadPoolExecutor\n\nScheduledThreadPoolExecutor以延迟或定时的方式执行任务，类似于Timer。由于Timer的一些缺陷，可以使用ScheduledThreadPoolExecutor来代替Timer。\n\nTimer在执行所有的定时任务时只会创建一个线程，如果某个任务执行时间过长，就会破坏其他TimerTask的定时准确性。TimerTask抛出异常后，Timer线程也不会捕获这个异常，从而终止定时线程。尚未执行的TimerTask不会再执行，新的任务也不会被调度。\n\n## 参考\n\n[java并发编程实战](https://book.douban.com/subject/10484692/)\n\n[聊聊并发（三）——JAVA线程池的分析和使用](http://www.infoq.com/cn/articles/java-threadPool)\n","slug":"java线程池的使用","published":1,"updated":"2017-05-08T13:19:06.000Z","comments":1,"photos":[],"link":"","_id":"cj4vch4fd002wx3gchw2fa5yb","content":"<blockquote>\n<p>在并发应用程序中，线程池是很重要的一块。读完《java并发编程实战》以及研究了一遍jdk源代码之后，总结一下线程池方面的知识~</p>\n</blockquote>\n<img src=\"/2017/05/08/java线程池的使用/pool.jpg\" alt=\"线程池\" title=\"线程池\">\n<h2 id=\"使用线程池的原因\"><a href=\"#使用线程池的原因\" class=\"headerlink\" title=\"使用线程池的原因\"></a>使用线程池的原因</h2><a id=\"more\"></a>\n<ol>\n<li><p>无线创建线程的不足</p>\n<p>在生产环境中，为每一个任务都分配一个线程这种方法存在一些缺陷：</p>\n<ul>\n<li><p>线程生命周期的开销：线程的创建与销毁都会消耗大量资源，频繁创建与销毁线程会带来很大的资源开销</p>\n</li>\n<li><p>资源消耗：活跃的线程会消耗系统资源。如果可运行的线程数量大于可用的处理器数量，闲置的线程会占用许多内存，并且频繁的线程上下文切换也会带来很大的性能开销</p>\n</li>\n<li><p>稳定性：操作系统在可创建的线程数量上有一个限制。在高负载情况下，应用程序很有可能突破这个限制，资源耗尽后很可能抛出OutOfMemoryError异常</p>\n</li>\n</ul>\n</li>\n<li><p>提高响应速度</p>\n<p>任务到达时，不再需要创建线程就可以立即执行</p>\n</li>\n<li><p>线程池提供了管理线程的功能</p>\n<p>比如，可以统计任务的完成情况，统计活跃线程与闲置线程的数量等</p>\n</li>\n</ol>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><ul>\n<li>不适用场合</li>\n</ul>\n<ol>\n<li><p>依赖性任务</p>\n<p>在线程池中，如果任务依赖于其他任务，那么可能产生死锁。比如，在单线程的Executor中，如果一个任务将另一个任务提交到同一个Executor，并且等待这个被提交任务的结果，那么通常会引发死锁</p>\n</li>\n<li><p>使用ThreadLocal的任务</p>\n<p>ThreadLocal可以存储线程级变量，将变量封闭到特定的线程当中。然而使用线程池时，这些线程都会被自由的重用，在线程池的线程中不应该使用ThreadLocal在任务之间传递值。</p>\n<p>当线程本地值的生命周期受限于任务的生命周期时，可以在线程池的线程中使用ThreadLocal，任务结束后调用ThreadLocal.remove方法将已存储的值清除。</p>\n</li>\n<li><p>使用线程封闭机制的任务</p>\n<p>在单线程应用程序中，不用考虑对象的并发安全问题，他们都被很好的封闭在单个线程当中。如果将单线程的环境换成线程池，那么这些对象有可能造成并发安全问题，失去线程安全性</p>\n</li>\n<li><p>不同类型或运行时长差异较大的任务</p>\n<p>不同类型任务之间很可能存在依赖，并且他们执行的时长也不相同，在线程池中运行时很有可能造成拥塞，甚至死锁</p>\n</li>\n</ol>\n<ul>\n<li><p>适用场合</p>\n<p>当任务是同类型且相互独立时，线程池的性能可以达到最佳</p>\n<p>网页服务器、文件服务器、邮件服务器，他们的请求往往是同类型且相互独立的</p>\n</li>\n</ul>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><p>在<a href=\"http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/\">线程池异常处理方案</a>这篇博客中已经提到了线程池的架构，如图：</p>\n<img src=\"/2017/05/08/java线程池的使用/pool_uml.png\" alt=\"线程池uml\" title=\"线程池uml\">\n<p><strong>Executor</strong>：异步任务执行框架的基础</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过使用Executor，将请求处理任务的提交与任务的实际执行解耦，只需要采用另一种不同的Executor实现，就可以改变服务器的行为。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 为每个任务分配一个线程</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPerTaskExecutor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Executor</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable r)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">new</span> Thread(r).start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 以同步的方式执行每个任务</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WithinThreadExecutor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Executor</span></span>&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable r)</span> </span>&#123;</div><div class=\"line\">\t\tr.run();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>ExecutorService</strong>：ExecutorService扩展了Executor接口，添加了一些用于管理生命周期和任务提交的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ExecutorService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Executor</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 生命周期管理</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isShutdown</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTerminated</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">awaitTermination</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></div><div class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 任务提交</span></div><div class=\"line\">    &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Runnable task, T result)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    Future&lt;?&gt; submit(Runnable task);</div><div class=\"line\"></div><div class=\"line\">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</div><div class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException;</div><div class=\"line\"></div><div class=\"line\">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</div><div class=\"line\">                                  <span class=\"keyword\">long</span> timeout, TimeUnit unit)</div><div class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException;</div><div class=\"line\"></div><div class=\"line\">    &lt;T&gt; <span class=\"function\">T <span class=\"title\">invokeAny</span><span class=\"params\">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></div><div class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException;</div><div class=\"line\"></div><div class=\"line\">    &lt;T&gt; <span class=\"function\">T <span class=\"title\">invokeAny</span><span class=\"params\">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></div><div class=\"line\">                    <span class=\"keyword\">long</span> timeout, TimeUnit unit)</div><div class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ExecutorService的生命周期有3中状态：运行、关闭、终止。ExecutorService在初始创建时处于运行状态。shutdown方法执行平缓的关闭过程：不再接受新任务，同时等待已提交的任务执行完成，包括在任务队列中尚未开始的任务。shutdownNow方法将尝试取消所有运行中的任务，并不再启动队列中尚未执行的任务。</p>\n<p>所有任务完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过轮询isTerminated来判断ExecutorService是否终止。</p>\n<p><strong>AbstractExecutorService ThreadPoolExecutor ScheduledThreadPoolExecutor</strong>: 线程池的实现</p>\n<p>ThreadPoolExecutor扩展了ExecutorService接口，是线程池的具体实现。ScheduledThreadPoolExecutor支持定时以及周期性任务的执行。</p>\n<p>ThreadPoolExecutor支持两种方式的任务提交：<code>exec.execute(Runnable r)</code>以及<code>exec.submit(Runnable r)</code>。关于任务的这两种提交方式在<a href=\"http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/\">线程池异常处理方案</a>已经提到过了，不再赘述。</p>\n<h2 id=\"定制线程池\"><a href=\"#定制线程池\" class=\"headerlink\" title=\"定制线程池\"></a>定制线程池</h2><p>先来了解一下线程池的创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ThreadPoolExecutor(<span class=\"keyword\">int</span> corePoolSize,</div><div class=\"line\">                              <span class=\"keyword\">int</span> maximumPoolSize,</div><div class=\"line\">                              <span class=\"keyword\">long</span> keepAliveTime,</div><div class=\"line\">                              TimeUnit unit,</div><div class=\"line\">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class=\"line\">                              ThreadFactory threadFactory,</div><div class=\"line\">                              RejectedExecutionHandler handler)</div></pre></td></tr></table></figure>\n<p>以上是ThreadPoolExecutor的构造函数，看一下每个参数的含义：</p>\n<ol>\n<li>corePoolSize</li>\n</ol>\n<p>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。</p>\n<ol>\n<li><p>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。</p>\n<ul>\n<li><p>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p>\n</li>\n<li><p>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</p>\n</li>\n<li><p>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p>\n</li>\n<li><p>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p>\n</li>\n</ul>\n</li>\n<li><p>maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</p>\n</li>\n<li><p>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</p>\n</li>\n<li><p>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。下面会有介绍几种饱和策略。</p>\n</li>\n<li><p>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p>\n</li>\n<li><p>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</p>\n</li>\n</ol>\n<img src=\"/2017/05/08/java线程池的使用/pool_execute.jpg\" alt=\"执行任务\" title=\"执行任务\">\n<h3 id=\"设置线程池的大小\"><a href=\"#设置线程池的大小\" class=\"headerlink\" title=\"设置线程池的大小\"></a>设置线程池的大小</h3><p>线程池过大，会导致大量的线程在很少的cpu和内存资源上发生竞争，频繁的线程上下文切换也会带来额外的性能开销。线程池过小，导致许多空闲的处理器无法执行工作，降低吞吐率。</p>\n<ol>\n<li>cpu密集型</li>\n</ol>\n<p>对于计算密集型的任务，当系统拥有n个处理器时，将线程池大小设置为n+1通常可以实现最优利用率。</p>\n<ol>\n<li>io密集型</li>\n</ol>\n<p>对于包含io操作或其他阻塞操作的任务，由于线程不会一直执行，因此线程池的规模应该更大。有这么一个简单的公式：</p>\n<p><code>N[threads] = N[cpu] * U[cpu] * (1 + W/C)</code></p>\n<p>其中，N[threads]是线程池的大小，U[cpu]是cpu的利用率，W/C是任务等待时间与任务执行时间的比值。</p>\n<p>可以通过一些监控工具获得cpu利用率等，<code>Runtime.getRuntime().availableProcessors()</code>返回cpu的数目</p>\n<ol>\n<li>资源依赖</li>\n</ol>\n<p>如果任务还依赖一些其他的有限资源，比如数据库连接，文件句柄等，那么这些资源也会影响线程池的大小：计算每个任务对该资源的需求量，用该资源的可用总量除以每个任务的需求量，所得的结果就是线程池大小的上限。</p>\n<h3 id=\"Executors\"><a href=\"#Executors\" class=\"headerlink\" title=\"Executors\"></a>Executors</h3><p>Executors提供了许多静态工厂方法来创建一个线程池：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">newCachedThreadPool</div><div class=\"line\">创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</div><div class=\"line\">newFixedThreadPool</div><div class=\"line\">创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</div><div class=\"line\">newSingleThreadExecutor</div><div class=\"line\">创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</div><div class=\"line\">newScheduledThreadPool</div><div class=\"line\">创建一个定长线程池，支持定时及周期性任务执行。</div></pre></td></tr></table></figure>\n<p>具体情况可以结合Executors源码和ThreadPoolExecutor的构造函数查看。我们也可以模仿Executors的这几个工厂方法来定制自己的线程池执行策略。</p>\n<h3 id=\"扩展ThreadPoolExecutor\"><a href=\"#扩展ThreadPoolExecutor\" class=\"headerlink\" title=\"扩展ThreadPoolExecutor\"></a>扩展ThreadPoolExecutor</h3><ol>\n<li>在<a href=\"http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/\">线程池异常处理方案</a>这篇总结曾经提到重写ThreadPoolExecutor的afterExecute方法来处理未检测异常，这就是扩展ThreadPoolExecutor的一个例子。除此之外，还可以在这些方法中添加日志、计时、监视等功能。</li>\n</ol>\n<p>线程池完成关闭操作后会调用方法terminated。terminated可以用来释放Executor在其生命周期中分配的各种资源，以及执行发送通知、记录日志等操作。</p>\n<p>下面编写一个利用beforeExecute、afterExecute和terminated添加日志记录和统计信息收集的扩展ThreadPoolExecutor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimingThreadPool</span> <span class=\"keyword\">extends</span> <span class=\"title\">ThreadPoolExecutor</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 使用ThreadLocal存储任务起始时间，在beforeExecute设置起始时间，在afterExecute中可以看到这个值</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Long&gt; startTime = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger logger = Logger.getLogger(TimingThreadPool.class.getName());</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicLong numTasks = <span class=\"keyword\">new</span> AtomicLong();</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicLong totalTime = <span class=\"keyword\">new</span> AtomicLong();</div><div class=\"line\">    </div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TimingThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize, <span class=\"keyword\">int</span> maximumPoolSize, <span class=\"keyword\">long</span> keepAliveTime, TimeUnit unit,</span></span></div><div class=\"line\">\t\t\tBlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">beforeExecute</span><span class=\"params\">(Thread t, Runnable r)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">super</span>.beforeExecute(t, r);</div><div class=\"line\">\t\tlogger.fine(String.format(<span class=\"string\">\"Thread %s: start %s\"</span>, t, r));</div><div class=\"line\">\t\tstartTime.set(System.nanoTime());</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">afterExecute</span><span class=\"params\">(Runnable r, Throwable t)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">long</span> endTime = System.nanoTime();</div><div class=\"line\">\t\t\t<span class=\"keyword\">long</span> taskTime = endTime - startTime.get();</div><div class=\"line\">\t\t\tnumTasks.incrementAndGet();</div><div class=\"line\">\t\t\ttotalTime.addAndGet(taskTime);</div><div class=\"line\">\t\t\tlogger.fine(String.format(<span class=\"string\">\"Thread %s: end %s, time=%dns\"</span>, t, r, taskTime));</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">super</span>.afterExecute(r, t);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">terminated</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tlogger.fine(String.format(<span class=\"string\">\"Terminated: avg time=%dns\"</span>, totalTime.get()/numTasks.get()));</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">super</span>.terminated();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>扩展ThreadPoolExecutor的newTaskFor方法可以修改通过submit方法返回的默认Future实现FutureTask为自己的实现。在我们自己实现Future的类中可以针对任务做一些操作，比如定制任务的取消行为：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacellingExecutor</span> <span class=\"keyword\">extends</span> <span class=\"title\">ThreadPoolExecutor</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CacellingExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize, <span class=\"keyword\">int</span> maximumPoolSize, <span class=\"keyword\">long</span> keepAliveTime, TimeUnit unit,</span></span></div><div class=\"line\">\t\t\tBlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">RunnableFuture&lt;T&gt; <span class=\"title\">newTaskFor</span><span class=\"params\">(Callable&lt;T&gt; callable)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (callable <span class=\"keyword\">instanceof</span> CancellableTask) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> ((CancellableTask&lt;T&gt;)callable).newTask();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.newTaskFor(callable);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CancellableTask</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t<span class=\"function\">RunnableFuture&lt;T&gt; <span class=\"title\">newTask</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocketUsingTask</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CancellableTask</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Socket socket;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SocketUsingTask</span><span class=\"params\">(Socket socket)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.socket = socket;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;在并发应用程序中，线程池是很重要的一块。读完《java并发编程实战》以及研究了一遍jdk源代码之后，总结一下线程池方面的知识~</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.socket.close();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> RunnableFuture&lt;T&gt; <span class=\"title\">newTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FutureTask&lt;T&gt;(<span class=\"keyword\">this</span>)&#123;</div><div class=\"line\">\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t\tSocketUsingTask.<span class=\"keyword\">this</span>.cancel();</div><div class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.cancel(mayInterruptIfRunning);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p>异常处理这部分，在前面的博客中已经总结过了：<a href=\"http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/\">线程池异常处理方案</a></p>\n<h2 id=\"饱和策略\"><a href=\"#饱和策略\" class=\"headerlink\" title=\"饱和策略\"></a>饱和策略</h2><p>当线程池达到饱和以后(maximumPoolSzie)，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略可以通过setRejectedExecutionHandler来修改。当某个任务被提交到一个已经关闭的Executor时，也会用到饱和策略。jdk提供了几种不同的RejectedExecutionHandler实现：</p>\n<ol>\n<li>AbortPolicy</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbortPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AbortPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RejectedExecutionException(<span class=\"string\">\"Task \"</span> + r.toString() +</div><div class=\"line\">                                                 <span class=\"string\">\" rejected from \"</span> +</div><div class=\"line\">                                                 e.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>AbortPolicy是默认的饱和策略，该饱和策略将抛出未检查的RejectedExecutionException。调用者可以处理这个异常。</p>\n<ol>\n<li>CallerRunsPolicy</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallerRunsPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CallerRunsPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!e.isShutdown()) &#123;</div><div class=\"line\">                r.run();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>CallerRunsPolicy将任务回退到调用者，他不会在线程池的某个线程中提交任务，而是在调用execute的线程中运行，从而降低新任务的流量。</p>\n<ol>\n<li>DiscardPolicy</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscardPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiscardPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>DiscardPolicy会悄悄抛弃任务，什么也不做。</p>\n<ol>\n<li>DiscardOldestPolicy</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscardOldestPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiscardOldestPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!e.isShutdown()) &#123;</div><div class=\"line\">                e.getQueue().poll();</div><div class=\"line\">                e.execute(r);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>DiscardOldestPolicy会抛弃下一个将被执行的任务，然后重新尝试提交任务。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ol>\n<li>CompletionService</li>\n</ol>\n<p>如果向Executor提交了一组计算任务，并希望在计算完成后获取结果，那么可以保留与每个任务关联的Future，然后轮询这些future的get方法，判断任务是否完成。这种方法虽然可行，但是有些繁琐。</p>\n<p>CompletionService将Executor和BlockingQueue的功能融合在一起，可以将任务提交给他执行，然后使用类似于队列的take或poll方法获取已完成结果。</p>\n<p>ExecutorCompletionService 实现了CompletionService，他的实现很简单，在构造函数中创建一个BlockingQueue来保存计算完成的结果。当提交某个任务时，该任务首先包装成为一个QueueingFuture,这是FutureTask的一个子类，他改写了done方法，将结果放入BlockingQueue中。ExecutorCompletionService的take和poll方法委托给了BlockingQueue。</p>\n<ol>\n<li>ScheduledThreadPoolExecutor</li>\n</ol>\n<p>ScheduledThreadPoolExecutor以延迟或定时的方式执行任务，类似于Timer。由于Timer的一些缺陷，可以使用ScheduledThreadPoolExecutor来代替Timer。</p>\n<p>Timer在执行所有的定时任务时只会创建一个线程，如果某个任务执行时间过长，就会破坏其他TimerTask的定时准确性。TimerTask抛出异常后，Timer线程也不会捕获这个异常，从而终止定时线程。尚未执行的TimerTask不会再执行，新的任务也不会被调度。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://book.douban.com/subject/10484692/\" target=\"_blank\" rel=\"external\">java并发编程实战</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/java-threadPool\" target=\"_blank\" rel=\"external\">聊聊并发（三）——JAVA线程池的分析和使用</a></p>\n","excerpt":"<blockquote>\n<p>在并发应用程序中，线程池是很重要的一块。读完《java并发编程实战》以及研究了一遍jdk源代码之后，总结一下线程池方面的知识~</p>\n</blockquote>\n<img src=\"/2017/05/08/java线程池的使用/pool.jpg\" alt=\"线程池\" title=\"线程池\">\n<h2 id=\"使用线程池的原因\"><a href=\"#使用线程池的原因\" class=\"headerlink\" title=\"使用线程池的原因\"></a>使用线程池的原因</h2>","more":"<ol>\n<li><p>无线创建线程的不足</p>\n<p>在生产环境中，为每一个任务都分配一个线程这种方法存在一些缺陷：</p>\n<ul>\n<li><p>线程生命周期的开销：线程的创建与销毁都会消耗大量资源，频繁创建与销毁线程会带来很大的资源开销</p>\n</li>\n<li><p>资源消耗：活跃的线程会消耗系统资源。如果可运行的线程数量大于可用的处理器数量，闲置的线程会占用许多内存，并且频繁的线程上下文切换也会带来很大的性能开销</p>\n</li>\n<li><p>稳定性：操作系统在可创建的线程数量上有一个限制。在高负载情况下，应用程序很有可能突破这个限制，资源耗尽后很可能抛出OutOfMemoryError异常</p>\n</li>\n</ul>\n</li>\n<li><p>提高响应速度</p>\n<p>任务到达时，不再需要创建线程就可以立即执行</p>\n</li>\n<li><p>线程池提供了管理线程的功能</p>\n<p>比如，可以统计任务的完成情况，统计活跃线程与闲置线程的数量等</p>\n</li>\n</ol>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><ul>\n<li>不适用场合</li>\n</ul>\n<ol>\n<li><p>依赖性任务</p>\n<p>在线程池中，如果任务依赖于其他任务，那么可能产生死锁。比如，在单线程的Executor中，如果一个任务将另一个任务提交到同一个Executor，并且等待这个被提交任务的结果，那么通常会引发死锁</p>\n</li>\n<li><p>使用ThreadLocal的任务</p>\n<p>ThreadLocal可以存储线程级变量，将变量封闭到特定的线程当中。然而使用线程池时，这些线程都会被自由的重用，在线程池的线程中不应该使用ThreadLocal在任务之间传递值。</p>\n<p>当线程本地值的生命周期受限于任务的生命周期时，可以在线程池的线程中使用ThreadLocal，任务结束后调用ThreadLocal.remove方法将已存储的值清除。</p>\n</li>\n<li><p>使用线程封闭机制的任务</p>\n<p>在单线程应用程序中，不用考虑对象的并发安全问题，他们都被很好的封闭在单个线程当中。如果将单线程的环境换成线程池，那么这些对象有可能造成并发安全问题，失去线程安全性</p>\n</li>\n<li><p>不同类型或运行时长差异较大的任务</p>\n<p>不同类型任务之间很可能存在依赖，并且他们执行的时长也不相同，在线程池中运行时很有可能造成拥塞，甚至死锁</p>\n</li>\n</ol>\n<ul>\n<li><p>适用场合</p>\n<p>当任务是同类型且相互独立时，线程池的性能可以达到最佳</p>\n<p>网页服务器、文件服务器、邮件服务器，他们的请求往往是同类型且相互独立的</p>\n</li>\n</ul>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><p>在<a href=\"http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/\">线程池异常处理方案</a>这篇博客中已经提到了线程池的架构，如图：</p>\n<img src=\"/2017/05/08/java线程池的使用/pool_uml.png\" alt=\"线程池uml\" title=\"线程池uml\">\n<p><strong>Executor</strong>：异步任务执行框架的基础</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过使用Executor，将请求处理任务的提交与任务的实际执行解耦，只需要采用另一种不同的Executor实现，就可以改变服务器的行为。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 为每个任务分配一个线程</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPerTaskExecutor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Executor</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable r)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">new</span> Thread(r).start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 以同步的方式执行每个任务</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WithinThreadExecutor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Executor</span></span>&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable r)</span> </span>&#123;</div><div class=\"line\">\t\tr.run();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>ExecutorService</strong>：ExecutorService扩展了Executor接口，添加了一些用于管理生命周期和任务提交的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ExecutorService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Executor</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 生命周期管理</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isShutdown</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTerminated</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">awaitTermination</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></div><div class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 任务提交</span></div><div class=\"line\">    &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Runnable task, T result)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    Future&lt;?&gt; submit(Runnable task);</div><div class=\"line\"></div><div class=\"line\">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</div><div class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException;</div><div class=\"line\"></div><div class=\"line\">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</div><div class=\"line\">                                  <span class=\"keyword\">long</span> timeout, TimeUnit unit)</div><div class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException;</div><div class=\"line\"></div><div class=\"line\">    &lt;T&gt; <span class=\"function\">T <span class=\"title\">invokeAny</span><span class=\"params\">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></div><div class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException</span>;</div><div class=\"line\"></div><div class=\"line\">    &lt;T&gt; <span class=\"function\">T <span class=\"title\">invokeAny</span><span class=\"params\">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</div><div class=\"line\">                    <span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></div><div class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ExecutorService的生命周期有3中状态：运行、关闭、终止。ExecutorService在初始创建时处于运行状态。shutdown方法执行平缓的关闭过程：不再接受新任务，同时等待已提交的任务执行完成，包括在任务队列中尚未开始的任务。shutdownNow方法将尝试取消所有运行中的任务，并不再启动队列中尚未执行的任务。</p>\n<p>所有任务完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过轮询isTerminated来判断ExecutorService是否终止。</p>\n<p><strong>AbstractExecutorService ThreadPoolExecutor ScheduledThreadPoolExecutor</strong>: 线程池的实现</p>\n<p>ThreadPoolExecutor扩展了ExecutorService接口，是线程池的具体实现。ScheduledThreadPoolExecutor支持定时以及周期性任务的执行。</p>\n<p>ThreadPoolExecutor支持两种方式的任务提交：<code>exec.execute(Runnable r)</code>以及<code>exec.submit(Runnable r)</code>。关于任务的这两种提交方式在<a href=\"http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/\">线程池异常处理方案</a>已经提到过了，不再赘述。</p>\n<h2 id=\"定制线程池\"><a href=\"#定制线程池\" class=\"headerlink\" title=\"定制线程池\"></a>定制线程池</h2><p>先来了解一下线程池的创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ThreadPoolExecutor(<span class=\"keyword\">int</span> corePoolSize,</div><div class=\"line\">                              <span class=\"keyword\">int</span> maximumPoolSize,</div><div class=\"line\">                              <span class=\"keyword\">long</span> keepAliveTime,</div><div class=\"line\">                              TimeUnit unit,</div><div class=\"line\">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class=\"line\">                              ThreadFactory threadFactory,</div><div class=\"line\">                              RejectedExecutionHandler handler)</div></pre></td></tr></table></figure>\n<p>以上是ThreadPoolExecutor的构造函数，看一下每个参数的含义：</p>\n<ol>\n<li>corePoolSize</li>\n</ol>\n<p>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。</p>\n<ol>\n<li><p>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。</p>\n<ul>\n<li><p>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p>\n</li>\n<li><p>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</p>\n</li>\n<li><p>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p>\n</li>\n<li><p>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p>\n</li>\n</ul>\n</li>\n<li><p>maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</p>\n</li>\n<li><p>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</p>\n</li>\n<li><p>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。下面会有介绍几种饱和策略。</p>\n</li>\n<li><p>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p>\n</li>\n<li><p>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</p>\n</li>\n</ol>\n<img src=\"/2017/05/08/java线程池的使用/pool_execute.jpg\" alt=\"执行任务\" title=\"执行任务\">\n<h3 id=\"设置线程池的大小\"><a href=\"#设置线程池的大小\" class=\"headerlink\" title=\"设置线程池的大小\"></a>设置线程池的大小</h3><p>线程池过大，会导致大量的线程在很少的cpu和内存资源上发生竞争，频繁的线程上下文切换也会带来额外的性能开销。线程池过小，导致许多空闲的处理器无法执行工作，降低吞吐率。</p>\n<ol>\n<li>cpu密集型</li>\n</ol>\n<p>对于计算密集型的任务，当系统拥有n个处理器时，将线程池大小设置为n+1通常可以实现最优利用率。</p>\n<ol>\n<li>io密集型</li>\n</ol>\n<p>对于包含io操作或其他阻塞操作的任务，由于线程不会一直执行，因此线程池的规模应该更大。有这么一个简单的公式：</p>\n<p><code>N[threads] = N[cpu] * U[cpu] * (1 + W/C)</code></p>\n<p>其中，N[threads]是线程池的大小，U[cpu]是cpu的利用率，W/C是任务等待时间与任务执行时间的比值。</p>\n<p>可以通过一些监控工具获得cpu利用率等，<code>Runtime.getRuntime().availableProcessors()</code>返回cpu的数目</p>\n<ol>\n<li>资源依赖</li>\n</ol>\n<p>如果任务还依赖一些其他的有限资源，比如数据库连接，文件句柄等，那么这些资源也会影响线程池的大小：计算每个任务对该资源的需求量，用该资源的可用总量除以每个任务的需求量，所得的结果就是线程池大小的上限。</p>\n<h3 id=\"Executors\"><a href=\"#Executors\" class=\"headerlink\" title=\"Executors\"></a>Executors</h3><p>Executors提供了许多静态工厂方法来创建一个线程池：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">newCachedThreadPool</div><div class=\"line\">创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</div><div class=\"line\">newFixedThreadPool</div><div class=\"line\">创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</div><div class=\"line\">newSingleThreadExecutor</div><div class=\"line\">创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</div><div class=\"line\">newScheduledThreadPool</div><div class=\"line\">创建一个定长线程池，支持定时及周期性任务执行。</div></pre></td></tr></table></figure>\n<p>具体情况可以结合Executors源码和ThreadPoolExecutor的构造函数查看。我们也可以模仿Executors的这几个工厂方法来定制自己的线程池执行策略。</p>\n<h3 id=\"扩展ThreadPoolExecutor\"><a href=\"#扩展ThreadPoolExecutor\" class=\"headerlink\" title=\"扩展ThreadPoolExecutor\"></a>扩展ThreadPoolExecutor</h3><ol>\n<li>在<a href=\"http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/\">线程池异常处理方案</a>这篇总结曾经提到重写ThreadPoolExecutor的afterExecute方法来处理未检测异常，这就是扩展ThreadPoolExecutor的一个例子。除此之外，还可以在这些方法中添加日志、计时、监视等功能。</li>\n</ol>\n<p>线程池完成关闭操作后会调用方法terminated。terminated可以用来释放Executor在其生命周期中分配的各种资源，以及执行发送通知、记录日志等操作。</p>\n<p>下面编写一个利用beforeExecute、afterExecute和terminated添加日志记录和统计信息收集的扩展ThreadPoolExecutor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimingThreadPool</span> <span class=\"keyword\">extends</span> <span class=\"title\">ThreadPoolExecutor</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 使用ThreadLocal存储任务起始时间，在beforeExecute设置起始时间，在afterExecute中可以看到这个值</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Long&gt; startTime = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger logger = Logger.getLogger(TimingThreadPool.class.getName());</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicLong numTasks = <span class=\"keyword\">new</span> AtomicLong();</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicLong totalTime = <span class=\"keyword\">new</span> AtomicLong();</div><div class=\"line\">    </div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TimingThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize, <span class=\"keyword\">int</span> maximumPoolSize, <span class=\"keyword\">long</span> keepAliveTime, TimeUnit unit,</div><div class=\"line\">\t\t\tBlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">beforeExecute</span><span class=\"params\">(Thread t, Runnable r)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">super</span>.beforeExecute(t, r);</div><div class=\"line\">\t\tlogger.fine(String.format(<span class=\"string\">\"Thread %s: start %s\"</span>, t, r));</div><div class=\"line\">\t\tstartTime.set(System.nanoTime());</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">afterExecute</span><span class=\"params\">(Runnable r, Throwable t)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">long</span> endTime = System.nanoTime();</div><div class=\"line\">\t\t\t<span class=\"keyword\">long</span> taskTime = endTime - startTime.get();</div><div class=\"line\">\t\t\tnumTasks.incrementAndGet();</div><div class=\"line\">\t\t\ttotalTime.addAndGet(taskTime);</div><div class=\"line\">\t\t\tlogger.fine(String.format(<span class=\"string\">\"Thread %s: end %s, time=%dns\"</span>, t, r, taskTime));</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">super</span>.afterExecute(r, t);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">terminated</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tlogger.fine(String.format(<span class=\"string\">\"Terminated: avg time=%dns\"</span>, totalTime.get()/numTasks.get()));</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">super</span>.terminated();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>扩展ThreadPoolExecutor的newTaskFor方法可以修改通过submit方法返回的默认Future实现FutureTask为自己的实现。在我们自己实现Future的类中可以针对任务做一些操作，比如定制任务的取消行为：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacellingExecutor</span> <span class=\"keyword\">extends</span> <span class=\"title\">ThreadPoolExecutor</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CacellingExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize, <span class=\"keyword\">int</span> maximumPoolSize, <span class=\"keyword\">long</span> keepAliveTime, TimeUnit unit,</div><div class=\"line\">\t\t\tBlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">RunnableFuture&lt;T&gt; <span class=\"title\">newTaskFor</span><span class=\"params\">(Callable&lt;T&gt; callable)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (callable <span class=\"keyword\">instanceof</span> CancellableTask) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> ((CancellableTask&lt;T&gt;)callable).newTask();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.newTaskFor(callable);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CancellableTask</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t<span class=\"function\">RunnableFuture&lt;T&gt; <span class=\"title\">newTask</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocketUsingTask</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CancellableTask</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Socket socket;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SocketUsingTask</span><span class=\"params\">(Socket socket)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.socket = socket;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;在并发应用程序中，线程池是很重要的一块。读完《java并发编程实战》以及研究了一遍jdk源代码之后，总结一下线程池方面的知识~</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.socket.close();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> RunnableFuture&lt;T&gt; <span class=\"title\">newTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FutureTask&lt;T&gt;(<span class=\"keyword\">this</span>)&#123;</div><div class=\"line\">\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t\tSocketUsingTask.<span class=\"keyword\">this</span>.cancel();</div><div class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.cancel(mayInterruptIfRunning);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p>异常处理这部分，在前面的博客中已经总结过了：<a href=\"http://yukai.space/2017/04/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/\">线程池异常处理方案</a></p>\n<h2 id=\"饱和策略\"><a href=\"#饱和策略\" class=\"headerlink\" title=\"饱和策略\"></a>饱和策略</h2><p>当线程池达到饱和以后(maximumPoolSzie)，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略可以通过setRejectedExecutionHandler来修改。当某个任务被提交到一个已经关闭的Executor时，也会用到饱和策略。jdk提供了几种不同的RejectedExecutionHandler实现：</p>\n<ol>\n<li>AbortPolicy</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbortPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AbortPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RejectedExecutionException(<span class=\"string\">\"Task \"</span> + r.toString() +</div><div class=\"line\">                                                 <span class=\"string\">\" rejected from \"</span> +</div><div class=\"line\">                                                 e.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>AbortPolicy是默认的饱和策略，该饱和策略将抛出未检查的RejectedExecutionException。调用者可以处理这个异常。</p>\n<ol>\n<li>CallerRunsPolicy</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallerRunsPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CallerRunsPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!e.isShutdown()) &#123;</div><div class=\"line\">                r.run();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>CallerRunsPolicy将任务回退到调用者，他不会在线程池的某个线程中提交任务，而是在调用execute的线程中运行，从而降低新任务的流量。</p>\n<ol>\n<li>DiscardPolicy</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscardPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiscardPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>DiscardPolicy会悄悄抛弃任务，什么也不做。</p>\n<ol>\n<li>DiscardOldestPolicy</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscardOldestPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiscardOldestPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!e.isShutdown()) &#123;</div><div class=\"line\">                e.getQueue().poll();</div><div class=\"line\">                e.execute(r);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>DiscardOldestPolicy会抛弃下一个将被执行的任务，然后重新尝试提交任务。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ol>\n<li>CompletionService</li>\n</ol>\n<p>如果向Executor提交了一组计算任务，并希望在计算完成后获取结果，那么可以保留与每个任务关联的Future，然后轮询这些future的get方法，判断任务是否完成。这种方法虽然可行，但是有些繁琐。</p>\n<p>CompletionService将Executor和BlockingQueue的功能融合在一起，可以将任务提交给他执行，然后使用类似于队列的take或poll方法获取已完成结果。</p>\n<p>ExecutorCompletionService 实现了CompletionService，他的实现很简单，在构造函数中创建一个BlockingQueue来保存计算完成的结果。当提交某个任务时，该任务首先包装成为一个QueueingFuture,这是FutureTask的一个子类，他改写了done方法，将结果放入BlockingQueue中。ExecutorCompletionService的take和poll方法委托给了BlockingQueue。</p>\n<ol>\n<li>ScheduledThreadPoolExecutor</li>\n</ol>\n<p>ScheduledThreadPoolExecutor以延迟或定时的方式执行任务，类似于Timer。由于Timer的一些缺陷，可以使用ScheduledThreadPoolExecutor来代替Timer。</p>\n<p>Timer在执行所有的定时任务时只会创建一个线程，如果某个任务执行时间过长，就会破坏其他TimerTask的定时准确性。TimerTask抛出异常后，Timer线程也不会捕获这个异常，从而终止定时线程。尚未执行的TimerTask不会再执行，新的任务也不会被调度。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://book.douban.com/subject/10484692/\">java并发编程实战</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/java-threadPool\">聊聊并发（三）——JAVA线程池的分析和使用</a></p>"},{"layout":"post","title":"linux分区","date":"2017-03-04T03:45:43.000Z","_content":"> 每次安装linux的时候，都会选择分区和挂载点。但是基本上没怎么研究过linux分区的细节，今天回顾了一下《鸟哥的linux私房菜》，总结一下分区的相关知识。\n\n## 磁盘的组成\n\n{% asset_img cipan.png 磁盘 %}\n\n磁道（Track）：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。\n\n柱面（Cylinder）：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。\n\n扇区（Sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。\n\n磁头（Heads）\n\n盘片（Platters）\n\n每个碟片都有两面，因此也会相对应每碟片有2个磁头。\n\n硬盘的物理结构一般由磁头与碟片、电动机、主控芯片与排线等部件组成；当主电动机带动碟片旋转时，副电动机带动一组（磁头）到相对应的碟片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与碟片同心的圆形轨道（磁轨或称柱面），这时由磁头的磁感线圈感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位扇区，从而得到该扇区的数据内容；\n\n磁盘的第一个扇区记录了整块磁盘的重要信息，主要有两个：\n\n1.主引导分区：可以安装引导加载程序的地方，有446bytes\n\n2.分区表：记录整块音盘的分区状况，有64bytes\n\n<!-- more -->\n\n ## 开机流程\n\n简单梳理一下开机流程：\n\n计算机开机后，会主动执行BIOS程序，BIOS是写入到主板上面的一个软件程序。接下来BIOS会去分析计算机中有哪些存储设备，然后依据用户的设置获取可以开机的硬盘（比如我们设置从usb启动），\n然后到读取该硬盘中的第一个扇区MBR位置。MBR中放置着基本的引导加载程序，接下来就是MBR内的引导加载程序加载内核文件。这个引导加载程序是操作系统在安装时提供的。\n\n## 磁盘分区表\n\n分区不难理解，在windows中，就意味着C，D，E等不同的盘，其实这些c盘，d盘往往都是属于同一块磁盘，将同一块磁盘划分开来，这就是分区。那为什么要分区呢？\n\n1.数据安全\n\n很好理解。比如我们在重装win操作系统的时候，往往只需要重装c盘即可，d盘等其他分区里的数据并不受重装系统的影响。\n\n2.性能\n\n将磁盘分区后，提高了数据读取的速度。我们在寻找某个分区的数据时，只需要扫描该分区对应磁盘的位置即可，并不需要全盘扫描。\n\n那么，到底是如何分区呢？\n\n{% asset_img zhumian.jpg 柱面 %}\n\n上图中，不同颜色的柱面范围就代表了不同的分区。分区利用了柱面号码的方式来处理。在分区表所在的64bytes中，总共分为四组记录，每组记录该分区的起始与结束柱面号码。\n\n我们将上图中从圆心到周长中间切出一条长方形来看：\n\n{% asset_img fen.png 分区 %}\n\n上图假设硬盘有400个柱面，分成四个分区。所谓的分区其实就是针对分区表进行设置而已。分区表最多可以容纳四个分区(只能记录四条数据)，这四个分区被称为主分区或者扩展分区。\n系统要写磁盘时，首先会参考磁盘分区表，然后才对某个分区的数据进行处理。\n\n假设这个磁盘在linux中的设备文件名为/dev/hda，那么这四个分区的文件名分别为：\n\np1:/dev/hda1  p2:/dev/hda2  p3:/dev/hda3  p4:/dev/hda4\n\n那么如何可以分得更多的分区呢？装过操作系统的人都知道分区不仅仅可以分四个，我们可以有c,d,e,f,g等等多个磁盘的划分。这都是通过扩展分区来做到的。\n\n扩展分区的原理就是利用额外的扇区来记录更多的分区信息，从而继续分出更多的分区来。由扩展分区分出来的分区叫做逻辑分区。\n\n{% asset_img kuozhan.png 分区 %}\n\n上图中，我们将磁盘/dev/sdb 分为了六个分区，分别是\n\n三个主分区：/dev/sdb1，/dev/sdb2/，/dev/sdb3\n\n三个逻辑分区：/dev/sdb5，/dev/sdb6/，/dev/sdb7\n\n为什么没有sdb4呢？那是因为1-4是保留给主分区或者扩展分区使用的。\n\n注意以下几点：\n\n主分区和扩展分区最多只能有四个；\n\n扩展分区只能有一个；\n\n逻辑分区是有扩展分区再切割而来的；\n\n扩展分区不能够格式化，所以无法直接使用，必须分为逻辑分区后才可以访问；\n\n所以说，如果我们想要分出四个以上的分区时，务必要设置一个扩展分区，而不能将四个分区全部划为主分区。\n\n## 多重引导\n\n前面的开机流程中提到，计算机通过读取MBR中的引导加载程序，使用该程序读取内核文件，启动操作系统。如果我们安装了双系统的话，又是如何指定启动哪一个操作系统呢？\n\n引导加载程序主要有下面几个功能：\n\n提供不同的开机选项；\n\n载入内核文件；\n\n将引导加载功能转交给其他引导加载程序；\n\n其中第三点，转交给其他引导加载程序，表明我们可以安装不同的引导加载程序到硬盘上面，但是MBR只有一个，也只能安装一个引导加载程序。\n其他的引导加载程序，可以安装在不同分区的引导扇区上面。\n\n{% asset_img yindao.jpg 分区 %}\n\n上图中，我们假设分别在两块分区上安装了windows和linux。当MBR中的引导加载程序开始工作时，会提供两个开机选项供我们选择：\n\n如果我们选择windows，引导加载程序直接加载windows的内核文件开机；\n\n如果我们选择linux，引导加载程序会把工作交给第二个分区的启动扇区中的引导加载程序。第二个引导加载程序启动后，加载该分区内的内核文件开机。\n\n那么，为什么安装双系统时，常常要求先安装windows，后安装linux呢？\n\n那是因为windows在安装的时候，会主动覆盖掉MBR及自己所在分区的启动扇区，并且也没有提供不同的开机选项菜单；而安装linux，可以选择将引导程序安装在MBR或者其他分区的启动扇区，并且也提供了手动设置开机菜单的功能。\n\n如果我们先安装了linux，再安装windows的时候就会把linux在MBR内的引导加载程序覆盖掉，并且也不会提供linux选项，而是直接进入windows系统。\n\n## 挂载点\n\n安装linux的时候，都会让我们选择挂载点。这个挂载点又与分区有什么关系呢？\n\n我们知道linux中所有的数据都以文件的形式存在，而文件数据是放在磁盘的分区当中的。所有的文件都是又根目录/衍生而来，我们想要取得/home/yukai/data.txt这个文件时，系统又根目录开始找，\n找到home，然后找到yukai，最后找到data.txt这个文件。如何由目录树找到磁盘分区中的数据，就是挂载点的意义。\n\n所谓的挂载就是利用一个目录当作进入点，去访问挂载在这个目录上的分区内的文件，即进入该目录就可以读取该分区，该目录是该分区的入口。我们想要访问一个分区时，必须将该分区挂载到某个目录上面，这个目录就是挂载点。\n\n所以说在安装linux的时候，要选择分区和挂载点，意思就是把不同的数据放置到不同的分区上的意思，比如我们把 /dev/sda1的挂载点设置为/home，就意味着/home下所有的数据都存放在/dev/sda1这个分区上面。\n\n","source":"_posts/linux分区.md","raw":"---\nlayout: post\ntitle: linux分区\ndate: 2017-03-04 11:45:43\ncategories: 技术\ntags: linux\n---\n> 每次安装linux的时候，都会选择分区和挂载点。但是基本上没怎么研究过linux分区的细节，今天回顾了一下《鸟哥的linux私房菜》，总结一下分区的相关知识。\n\n## 磁盘的组成\n\n{% asset_img cipan.png 磁盘 %}\n\n磁道（Track）：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。\n\n柱面（Cylinder）：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。\n\n扇区（Sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。\n\n磁头（Heads）\n\n盘片（Platters）\n\n每个碟片都有两面，因此也会相对应每碟片有2个磁头。\n\n硬盘的物理结构一般由磁头与碟片、电动机、主控芯片与排线等部件组成；当主电动机带动碟片旋转时，副电动机带动一组（磁头）到相对应的碟片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与碟片同心的圆形轨道（磁轨或称柱面），这时由磁头的磁感线圈感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位扇区，从而得到该扇区的数据内容；\n\n磁盘的第一个扇区记录了整块磁盘的重要信息，主要有两个：\n\n1.主引导分区：可以安装引导加载程序的地方，有446bytes\n\n2.分区表：记录整块音盘的分区状况，有64bytes\n\n<!-- more -->\n\n ## 开机流程\n\n简单梳理一下开机流程：\n\n计算机开机后，会主动执行BIOS程序，BIOS是写入到主板上面的一个软件程序。接下来BIOS会去分析计算机中有哪些存储设备，然后依据用户的设置获取可以开机的硬盘（比如我们设置从usb启动），\n然后到读取该硬盘中的第一个扇区MBR位置。MBR中放置着基本的引导加载程序，接下来就是MBR内的引导加载程序加载内核文件。这个引导加载程序是操作系统在安装时提供的。\n\n## 磁盘分区表\n\n分区不难理解，在windows中，就意味着C，D，E等不同的盘，其实这些c盘，d盘往往都是属于同一块磁盘，将同一块磁盘划分开来，这就是分区。那为什么要分区呢？\n\n1.数据安全\n\n很好理解。比如我们在重装win操作系统的时候，往往只需要重装c盘即可，d盘等其他分区里的数据并不受重装系统的影响。\n\n2.性能\n\n将磁盘分区后，提高了数据读取的速度。我们在寻找某个分区的数据时，只需要扫描该分区对应磁盘的位置即可，并不需要全盘扫描。\n\n那么，到底是如何分区呢？\n\n{% asset_img zhumian.jpg 柱面 %}\n\n上图中，不同颜色的柱面范围就代表了不同的分区。分区利用了柱面号码的方式来处理。在分区表所在的64bytes中，总共分为四组记录，每组记录该分区的起始与结束柱面号码。\n\n我们将上图中从圆心到周长中间切出一条长方形来看：\n\n{% asset_img fen.png 分区 %}\n\n上图假设硬盘有400个柱面，分成四个分区。所谓的分区其实就是针对分区表进行设置而已。分区表最多可以容纳四个分区(只能记录四条数据)，这四个分区被称为主分区或者扩展分区。\n系统要写磁盘时，首先会参考磁盘分区表，然后才对某个分区的数据进行处理。\n\n假设这个磁盘在linux中的设备文件名为/dev/hda，那么这四个分区的文件名分别为：\n\np1:/dev/hda1  p2:/dev/hda2  p3:/dev/hda3  p4:/dev/hda4\n\n那么如何可以分得更多的分区呢？装过操作系统的人都知道分区不仅仅可以分四个，我们可以有c,d,e,f,g等等多个磁盘的划分。这都是通过扩展分区来做到的。\n\n扩展分区的原理就是利用额外的扇区来记录更多的分区信息，从而继续分出更多的分区来。由扩展分区分出来的分区叫做逻辑分区。\n\n{% asset_img kuozhan.png 分区 %}\n\n上图中，我们将磁盘/dev/sdb 分为了六个分区，分别是\n\n三个主分区：/dev/sdb1，/dev/sdb2/，/dev/sdb3\n\n三个逻辑分区：/dev/sdb5，/dev/sdb6/，/dev/sdb7\n\n为什么没有sdb4呢？那是因为1-4是保留给主分区或者扩展分区使用的。\n\n注意以下几点：\n\n主分区和扩展分区最多只能有四个；\n\n扩展分区只能有一个；\n\n逻辑分区是有扩展分区再切割而来的；\n\n扩展分区不能够格式化，所以无法直接使用，必须分为逻辑分区后才可以访问；\n\n所以说，如果我们想要分出四个以上的分区时，务必要设置一个扩展分区，而不能将四个分区全部划为主分区。\n\n## 多重引导\n\n前面的开机流程中提到，计算机通过读取MBR中的引导加载程序，使用该程序读取内核文件，启动操作系统。如果我们安装了双系统的话，又是如何指定启动哪一个操作系统呢？\n\n引导加载程序主要有下面几个功能：\n\n提供不同的开机选项；\n\n载入内核文件；\n\n将引导加载功能转交给其他引导加载程序；\n\n其中第三点，转交给其他引导加载程序，表明我们可以安装不同的引导加载程序到硬盘上面，但是MBR只有一个，也只能安装一个引导加载程序。\n其他的引导加载程序，可以安装在不同分区的引导扇区上面。\n\n{% asset_img yindao.jpg 分区 %}\n\n上图中，我们假设分别在两块分区上安装了windows和linux。当MBR中的引导加载程序开始工作时，会提供两个开机选项供我们选择：\n\n如果我们选择windows，引导加载程序直接加载windows的内核文件开机；\n\n如果我们选择linux，引导加载程序会把工作交给第二个分区的启动扇区中的引导加载程序。第二个引导加载程序启动后，加载该分区内的内核文件开机。\n\n那么，为什么安装双系统时，常常要求先安装windows，后安装linux呢？\n\n那是因为windows在安装的时候，会主动覆盖掉MBR及自己所在分区的启动扇区，并且也没有提供不同的开机选项菜单；而安装linux，可以选择将引导程序安装在MBR或者其他分区的启动扇区，并且也提供了手动设置开机菜单的功能。\n\n如果我们先安装了linux，再安装windows的时候就会把linux在MBR内的引导加载程序覆盖掉，并且也不会提供linux选项，而是直接进入windows系统。\n\n## 挂载点\n\n安装linux的时候，都会让我们选择挂载点。这个挂载点又与分区有什么关系呢？\n\n我们知道linux中所有的数据都以文件的形式存在，而文件数据是放在磁盘的分区当中的。所有的文件都是又根目录/衍生而来，我们想要取得/home/yukai/data.txt这个文件时，系统又根目录开始找，\n找到home，然后找到yukai，最后找到data.txt这个文件。如何由目录树找到磁盘分区中的数据，就是挂载点的意义。\n\n所谓的挂载就是利用一个目录当作进入点，去访问挂载在这个目录上的分区内的文件，即进入该目录就可以读取该分区，该目录是该分区的入口。我们想要访问一个分区时，必须将该分区挂载到某个目录上面，这个目录就是挂载点。\n\n所以说在安装linux的时候，要选择分区和挂载点，意思就是把不同的数据放置到不同的分区上的意思，比如我们把 /dev/sda1的挂载点设置为/home，就意味着/home下所有的数据都存放在/dev/sda1这个分区上面。\n\n","slug":"linux分区","published":1,"updated":"2017-04-11T13:08:38.846Z","comments":1,"photos":[],"link":"","_id":"cj4vch4ff002zx3gc34a2ztrd","content":"<blockquote>\n<p>每次安装linux的时候，都会选择分区和挂载点。但是基本上没怎么研究过linux分区的细节，今天回顾了一下《鸟哥的linux私房菜》，总结一下分区的相关知识。</p>\n</blockquote>\n<h2 id=\"磁盘的组成\"><a href=\"#磁盘的组成\" class=\"headerlink\" title=\"磁盘的组成\"></a>磁盘的组成</h2><img src=\"/2017/03/04/linux分区/cipan.png\" alt=\"磁盘\" title=\"磁盘\">\n<p>磁道（Track）：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。</p>\n<p>柱面（Cylinder）：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。</p>\n<p>扇区（Sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。</p>\n<p>磁头（Heads）</p>\n<p>盘片（Platters）</p>\n<p>每个碟片都有两面，因此也会相对应每碟片有2个磁头。</p>\n<p>硬盘的物理结构一般由磁头与碟片、电动机、主控芯片与排线等部件组成；当主电动机带动碟片旋转时，副电动机带动一组（磁头）到相对应的碟片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与碟片同心的圆形轨道（磁轨或称柱面），这时由磁头的磁感线圈感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位扇区，从而得到该扇区的数据内容；</p>\n<p>磁盘的第一个扇区记录了整块磁盘的重要信息，主要有两个：</p>\n<p>1.主引导分区：可以安装引导加载程序的地方，有446bytes</p>\n<p>2.分区表：记录整块音盘的分区状况，有64bytes</p>\n<a id=\"more\"></a>\n<h2 id=\"开机流程\"><a href=\"#开机流程\" class=\"headerlink\" title=\"开机流程\"></a>开机流程</h2><p>简单梳理一下开机流程：</p>\n<p>计算机开机后，会主动执行BIOS程序，BIOS是写入到主板上面的一个软件程序。接下来BIOS会去分析计算机中有哪些存储设备，然后依据用户的设置获取可以开机的硬盘（比如我们设置从usb启动），<br>然后到读取该硬盘中的第一个扇区MBR位置。MBR中放置着基本的引导加载程序，接下来就是MBR内的引导加载程序加载内核文件。这个引导加载程序是操作系统在安装时提供的。</p>\n<h2 id=\"磁盘分区表\"><a href=\"#磁盘分区表\" class=\"headerlink\" title=\"磁盘分区表\"></a>磁盘分区表</h2><p>分区不难理解，在windows中，就意味着C，D，E等不同的盘，其实这些c盘，d盘往往都是属于同一块磁盘，将同一块磁盘划分开来，这就是分区。那为什么要分区呢？</p>\n<p>1.数据安全</p>\n<p>很好理解。比如我们在重装win操作系统的时候，往往只需要重装c盘即可，d盘等其他分区里的数据并不受重装系统的影响。</p>\n<p>2.性能</p>\n<p>将磁盘分区后，提高了数据读取的速度。我们在寻找某个分区的数据时，只需要扫描该分区对应磁盘的位置即可，并不需要全盘扫描。</p>\n<p>那么，到底是如何分区呢？</p>\n<img src=\"/2017/03/04/linux分区/zhumian.jpg\" alt=\"柱面\" title=\"柱面\">\n<p>上图中，不同颜色的柱面范围就代表了不同的分区。分区利用了柱面号码的方式来处理。在分区表所在的64bytes中，总共分为四组记录，每组记录该分区的起始与结束柱面号码。</p>\n<p>我们将上图中从圆心到周长中间切出一条长方形来看：</p>\n<img src=\"/2017/03/04/linux分区/fen.png\" alt=\"分区\" title=\"分区\">\n<p>上图假设硬盘有400个柱面，分成四个分区。所谓的分区其实就是针对分区表进行设置而已。分区表最多可以容纳四个分区(只能记录四条数据)，这四个分区被称为主分区或者扩展分区。<br>系统要写磁盘时，首先会参考磁盘分区表，然后才对某个分区的数据进行处理。</p>\n<p>假设这个磁盘在linux中的设备文件名为/dev/hda，那么这四个分区的文件名分别为：</p>\n<p>p1:/dev/hda1  p2:/dev/hda2  p3:/dev/hda3  p4:/dev/hda4</p>\n<p>那么如何可以分得更多的分区呢？装过操作系统的人都知道分区不仅仅可以分四个，我们可以有c,d,e,f,g等等多个磁盘的划分。这都是通过扩展分区来做到的。</p>\n<p>扩展分区的原理就是利用额外的扇区来记录更多的分区信息，从而继续分出更多的分区来。由扩展分区分出来的分区叫做逻辑分区。</p>\n<img src=\"/2017/03/04/linux分区/kuozhan.png\" alt=\"分区\" title=\"分区\">\n<p>上图中，我们将磁盘/dev/sdb 分为了六个分区，分别是</p>\n<p>三个主分区：/dev/sdb1，/dev/sdb2/，/dev/sdb3</p>\n<p>三个逻辑分区：/dev/sdb5，/dev/sdb6/，/dev/sdb7</p>\n<p>为什么没有sdb4呢？那是因为1-4是保留给主分区或者扩展分区使用的。</p>\n<p>注意以下几点：</p>\n<p>主分区和扩展分区最多只能有四个；</p>\n<p>扩展分区只能有一个；</p>\n<p>逻辑分区是有扩展分区再切割而来的；</p>\n<p>扩展分区不能够格式化，所以无法直接使用，必须分为逻辑分区后才可以访问；</p>\n<p>所以说，如果我们想要分出四个以上的分区时，务必要设置一个扩展分区，而不能将四个分区全部划为主分区。</p>\n<h2 id=\"多重引导\"><a href=\"#多重引导\" class=\"headerlink\" title=\"多重引导\"></a>多重引导</h2><p>前面的开机流程中提到，计算机通过读取MBR中的引导加载程序，使用该程序读取内核文件，启动操作系统。如果我们安装了双系统的话，又是如何指定启动哪一个操作系统呢？</p>\n<p>引导加载程序主要有下面几个功能：</p>\n<p>提供不同的开机选项；</p>\n<p>载入内核文件；</p>\n<p>将引导加载功能转交给其他引导加载程序；</p>\n<p>其中第三点，转交给其他引导加载程序，表明我们可以安装不同的引导加载程序到硬盘上面，但是MBR只有一个，也只能安装一个引导加载程序。<br>其他的引导加载程序，可以安装在不同分区的引导扇区上面。</p>\n<img src=\"/2017/03/04/linux分区/yindao.jpg\" alt=\"分区\" title=\"分区\">\n<p>上图中，我们假设分别在两块分区上安装了windows和linux。当MBR中的引导加载程序开始工作时，会提供两个开机选项供我们选择：</p>\n<p>如果我们选择windows，引导加载程序直接加载windows的内核文件开机；</p>\n<p>如果我们选择linux，引导加载程序会把工作交给第二个分区的启动扇区中的引导加载程序。第二个引导加载程序启动后，加载该分区内的内核文件开机。</p>\n<p>那么，为什么安装双系统时，常常要求先安装windows，后安装linux呢？</p>\n<p>那是因为windows在安装的时候，会主动覆盖掉MBR及自己所在分区的启动扇区，并且也没有提供不同的开机选项菜单；而安装linux，可以选择将引导程序安装在MBR或者其他分区的启动扇区，并且也提供了手动设置开机菜单的功能。</p>\n<p>如果我们先安装了linux，再安装windows的时候就会把linux在MBR内的引导加载程序覆盖掉，并且也不会提供linux选项，而是直接进入windows系统。</p>\n<h2 id=\"挂载点\"><a href=\"#挂载点\" class=\"headerlink\" title=\"挂载点\"></a>挂载点</h2><p>安装linux的时候，都会让我们选择挂载点。这个挂载点又与分区有什么关系呢？</p>\n<p>我们知道linux中所有的数据都以文件的形式存在，而文件数据是放在磁盘的分区当中的。所有的文件都是又根目录/衍生而来，我们想要取得/home/yukai/data.txt这个文件时，系统又根目录开始找，<br>找到home，然后找到yukai，最后找到data.txt这个文件。如何由目录树找到磁盘分区中的数据，就是挂载点的意义。</p>\n<p>所谓的挂载就是利用一个目录当作进入点，去访问挂载在这个目录上的分区内的文件，即进入该目录就可以读取该分区，该目录是该分区的入口。我们想要访问一个分区时，必须将该分区挂载到某个目录上面，这个目录就是挂载点。</p>\n<p>所以说在安装linux的时候，要选择分区和挂载点，意思就是把不同的数据放置到不同的分区上的意思，比如我们把 /dev/sda1的挂载点设置为/home，就意味着/home下所有的数据都存放在/dev/sda1这个分区上面。</p>\n","excerpt":"<blockquote>\n<p>每次安装linux的时候，都会选择分区和挂载点。但是基本上没怎么研究过linux分区的细节，今天回顾了一下《鸟哥的linux私房菜》，总结一下分区的相关知识。</p>\n</blockquote>\n<h2 id=\"磁盘的组成\"><a href=\"#磁盘的组成\" class=\"headerlink\" title=\"磁盘的组成\"></a>磁盘的组成</h2><img src=\"/2017/03/04/linux分区/cipan.png\" alt=\"磁盘\" title=\"磁盘\">\n<p>磁道（Track）：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。</p>\n<p>柱面（Cylinder）：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。</p>\n<p>扇区（Sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。</p>\n<p>磁头（Heads）</p>\n<p>盘片（Platters）</p>\n<p>每个碟片都有两面，因此也会相对应每碟片有2个磁头。</p>\n<p>硬盘的物理结构一般由磁头与碟片、电动机、主控芯片与排线等部件组成；当主电动机带动碟片旋转时，副电动机带动一组（磁头）到相对应的碟片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与碟片同心的圆形轨道（磁轨或称柱面），这时由磁头的磁感线圈感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位扇区，从而得到该扇区的数据内容；</p>\n<p>磁盘的第一个扇区记录了整块磁盘的重要信息，主要有两个：</p>\n<p>1.主引导分区：可以安装引导加载程序的地方，有446bytes</p>\n<p>2.分区表：记录整块音盘的分区状况，有64bytes</p>","more":"<h2 id=\"开机流程\"><a href=\"#开机流程\" class=\"headerlink\" title=\"开机流程\"></a>开机流程</h2><p>简单梳理一下开机流程：</p>\n<p>计算机开机后，会主动执行BIOS程序，BIOS是写入到主板上面的一个软件程序。接下来BIOS会去分析计算机中有哪些存储设备，然后依据用户的设置获取可以开机的硬盘（比如我们设置从usb启动），<br>然后到读取该硬盘中的第一个扇区MBR位置。MBR中放置着基本的引导加载程序，接下来就是MBR内的引导加载程序加载内核文件。这个引导加载程序是操作系统在安装时提供的。</p>\n<h2 id=\"磁盘分区表\"><a href=\"#磁盘分区表\" class=\"headerlink\" title=\"磁盘分区表\"></a>磁盘分区表</h2><p>分区不难理解，在windows中，就意味着C，D，E等不同的盘，其实这些c盘，d盘往往都是属于同一块磁盘，将同一块磁盘划分开来，这就是分区。那为什么要分区呢？</p>\n<p>1.数据安全</p>\n<p>很好理解。比如我们在重装win操作系统的时候，往往只需要重装c盘即可，d盘等其他分区里的数据并不受重装系统的影响。</p>\n<p>2.性能</p>\n<p>将磁盘分区后，提高了数据读取的速度。我们在寻找某个分区的数据时，只需要扫描该分区对应磁盘的位置即可，并不需要全盘扫描。</p>\n<p>那么，到底是如何分区呢？</p>\n<img src=\"/2017/03/04/linux分区/zhumian.jpg\" alt=\"柱面\" title=\"柱面\">\n<p>上图中，不同颜色的柱面范围就代表了不同的分区。分区利用了柱面号码的方式来处理。在分区表所在的64bytes中，总共分为四组记录，每组记录该分区的起始与结束柱面号码。</p>\n<p>我们将上图中从圆心到周长中间切出一条长方形来看：</p>\n<img src=\"/2017/03/04/linux分区/fen.png\" alt=\"分区\" title=\"分区\">\n<p>上图假设硬盘有400个柱面，分成四个分区。所谓的分区其实就是针对分区表进行设置而已。分区表最多可以容纳四个分区(只能记录四条数据)，这四个分区被称为主分区或者扩展分区。<br>系统要写磁盘时，首先会参考磁盘分区表，然后才对某个分区的数据进行处理。</p>\n<p>假设这个磁盘在linux中的设备文件名为/dev/hda，那么这四个分区的文件名分别为：</p>\n<p>p1:/dev/hda1  p2:/dev/hda2  p3:/dev/hda3  p4:/dev/hda4</p>\n<p>那么如何可以分得更多的分区呢？装过操作系统的人都知道分区不仅仅可以分四个，我们可以有c,d,e,f,g等等多个磁盘的划分。这都是通过扩展分区来做到的。</p>\n<p>扩展分区的原理就是利用额外的扇区来记录更多的分区信息，从而继续分出更多的分区来。由扩展分区分出来的分区叫做逻辑分区。</p>\n<img src=\"/2017/03/04/linux分区/kuozhan.png\" alt=\"分区\" title=\"分区\">\n<p>上图中，我们将磁盘/dev/sdb 分为了六个分区，分别是</p>\n<p>三个主分区：/dev/sdb1，/dev/sdb2/，/dev/sdb3</p>\n<p>三个逻辑分区：/dev/sdb5，/dev/sdb6/，/dev/sdb7</p>\n<p>为什么没有sdb4呢？那是因为1-4是保留给主分区或者扩展分区使用的。</p>\n<p>注意以下几点：</p>\n<p>主分区和扩展分区最多只能有四个；</p>\n<p>扩展分区只能有一个；</p>\n<p>逻辑分区是有扩展分区再切割而来的；</p>\n<p>扩展分区不能够格式化，所以无法直接使用，必须分为逻辑分区后才可以访问；</p>\n<p>所以说，如果我们想要分出四个以上的分区时，务必要设置一个扩展分区，而不能将四个分区全部划为主分区。</p>\n<h2 id=\"多重引导\"><a href=\"#多重引导\" class=\"headerlink\" title=\"多重引导\"></a>多重引导</h2><p>前面的开机流程中提到，计算机通过读取MBR中的引导加载程序，使用该程序读取内核文件，启动操作系统。如果我们安装了双系统的话，又是如何指定启动哪一个操作系统呢？</p>\n<p>引导加载程序主要有下面几个功能：</p>\n<p>提供不同的开机选项；</p>\n<p>载入内核文件；</p>\n<p>将引导加载功能转交给其他引导加载程序；</p>\n<p>其中第三点，转交给其他引导加载程序，表明我们可以安装不同的引导加载程序到硬盘上面，但是MBR只有一个，也只能安装一个引导加载程序。<br>其他的引导加载程序，可以安装在不同分区的引导扇区上面。</p>\n<img src=\"/2017/03/04/linux分区/yindao.jpg\" alt=\"分区\" title=\"分区\">\n<p>上图中，我们假设分别在两块分区上安装了windows和linux。当MBR中的引导加载程序开始工作时，会提供两个开机选项供我们选择：</p>\n<p>如果我们选择windows，引导加载程序直接加载windows的内核文件开机；</p>\n<p>如果我们选择linux，引导加载程序会把工作交给第二个分区的启动扇区中的引导加载程序。第二个引导加载程序启动后，加载该分区内的内核文件开机。</p>\n<p>那么，为什么安装双系统时，常常要求先安装windows，后安装linux呢？</p>\n<p>那是因为windows在安装的时候，会主动覆盖掉MBR及自己所在分区的启动扇区，并且也没有提供不同的开机选项菜单；而安装linux，可以选择将引导程序安装在MBR或者其他分区的启动扇区，并且也提供了手动设置开机菜单的功能。</p>\n<p>如果我们先安装了linux，再安装windows的时候就会把linux在MBR内的引导加载程序覆盖掉，并且也不会提供linux选项，而是直接进入windows系统。</p>\n<h2 id=\"挂载点\"><a href=\"#挂载点\" class=\"headerlink\" title=\"挂载点\"></a>挂载点</h2><p>安装linux的时候，都会让我们选择挂载点。这个挂载点又与分区有什么关系呢？</p>\n<p>我们知道linux中所有的数据都以文件的形式存在，而文件数据是放在磁盘的分区当中的。所有的文件都是又根目录/衍生而来，我们想要取得/home/yukai/data.txt这个文件时，系统又根目录开始找，<br>找到home，然后找到yukai，最后找到data.txt这个文件。如何由目录树找到磁盘分区中的数据，就是挂载点的意义。</p>\n<p>所谓的挂载就是利用一个目录当作进入点，去访问挂载在这个目录上的分区内的文件，即进入该目录就可以读取该分区，该目录是该分区的入口。我们想要访问一个分区时，必须将该分区挂载到某个目录上面，这个目录就是挂载点。</p>\n<p>所以说在安装linux的时候，要选择分区和挂载点，意思就是把不同的数据放置到不同的分区上的意思，比如我们把 /dev/sda1的挂载点设置为/home，就意味着/home下所有的数据都存放在/dev/sda1这个分区上面。</p>"},{"layout":"post","title":"java远程调试学习","date":"2016-12-07T13:55:48.000Z","_content":"\n> 集群前后台协议需要做一些修改，我负责jdbc这边的修改。按照协议内容修改完代码之后却面临一个测试的问题：修改后的后台又部署在北京，但北京并不是所有的机器都对天津这边开放，只给提供一台机器A，就是集群的服务器。\n> 这样的话,就无法创建节点的连接，测试没有办法进行。\n\n> 一开始用了最简单的办法，把打好的jar包通过远程ssh放到A上面，再通过ssh去跑用例，打印结果看看正确与否。但是这样的效率真的太低了，每做一次修改都要打包、部署、运行、分析log。于是借这个机会学习一下java程序的远程调试。以下为总结。\n\n\n## 一些概念\n\nJDPA: java平台调试架构\n\nJVMTI: JVM端调试接口\n\nJDI: java端调试接口\n\nJDWP: java调试网络协议\n\n{% asset_img jdpa.png jdpa %}\n\nJPDA 定义了一套如何开发调试工具的接口和规范。\n\nJPDA 由三个独立的模块 JVMTI、JDWP、JDI 组成。\n\n调试者通过 JDI 发送接受调试命令。\n\nJDWP 定义调试者和被调试者交流数据的格式。\n\nJVMTI 可以控制当前虚拟机运行状态。\n\n上图中的前端工具就是我们要用到的调试工具。如JDB、Eclipse等等。这些工具实现了JDI接口，通过这些工具我们可以达到在命令行或者图形界面下调试的目的。\n\n关于这部分，只是简单的了解一下概念，更多的关于JDPA的介绍：[JDPA体系](http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?search_by=%E6%B7%B1%E5%85%A5+Java+%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB)\n\n<!-- more -->\n\n## 使用JDB进行本地调试\n\nJDB 是jdk自带的一个调试工具，用于命令行下调试java程序\n\njdb.exe就位于jdk安装目录的bin目录下，安装好jdk并设置好环境变量之后就可以愉快的使用jdb了。\n\n```\nC:\\Users\\kyu>jdb -help\n用法: jdb <options> <class> <arguments>\n\n其中, 选项包括:\n    -help             输出此消息并退出\n    -sourcepath <由 \";\" 分隔的目录>\n                      要在其中查找源文件的目录\n    -attach <address>\n                      使用标准连接器附加到指定地址处正在运行的 VM\n    -listen <address>\n                      等待正在运行的 VM 使用标准连接器在指定地址处连接\n    -listenany\n                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接\n    -launch\n                      立即启动 VM 而不是等待 'run' 命令\n    -listconnectors   列出此 VM 中的可用连接器\n    -connect <connector-name>:<name1>=<value1>,...\n                      使用所列参数值通过指定的连接器连接到目标 VM\n    -dbgtrace [flags] 输出信息供调试jdb\n    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序\n    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序\n\n转发到被调试进程的选项:\n    -v -verbose[:class|gc|jni]\n                      启用详细模式\n    -D<name>=<value>  设置系统属性\n    -classpath <由 \";\" 分隔的目录>\n                      列出要在其中查找类的目录\n    -X<option>        非标准目标 VM 选项\n\n<class> 是要开始调试的类的名称\n<arguments> 是传递到 <class> 的 main() 方法的参数\n\n要获得命令的帮助, 请在jdb提示下键入 'help'\n```\n\n上面是启动JDB的语法说明。\n\n现假设运行程序的工程目录如下：\n\n```\nJDBTest\n  |----bin(编译生成的class文件)\n  |     |----*.class\n  |----src(源文件)\n  |     |----*.java\n  |----lib(依赖的第三方jar)\n  |     |----*.jar\n```\n\n开始启动JDB调试：\n\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n\n`注意，如果有多个文件，windows下使用 \";\" 分隔每个文件或目录，Linux下使用 \":\" 分隔每个文件或目录`\n\n`-classpath` 指定了类路径，`-sourcepath` 指定了源文件的路径\n\n回车，出现如下信息：\n\n```\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n正在初始化jdb...\n> \n```\n此时，JDB调试器等待用户的输入，输入`help`，出现如下信息：\n\n```\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n正在初始化jdb...\n> help\n** 命令列表 **\nconnectors                -- 列出此 VM 中可用的连接器和传输\n\nrun [class [args]]        -- 开始执行应用程序的主类\n\nthreads [threadgroup]     -- 列出线程\nthread <thread id>        -- 设置默认线程\nsuspend [thread id(s)]    -- 挂起线程 (默认值: all)\nresume [thread id(s)]     -- 恢复线程 (默认值: all)\nwhere [<thread id> | all] -- 转储线程的堆栈\nwherei [<thread id> | all]-- 转储线程的堆栈, 以及 pc 信息\nup [n frames]             -- 上移线程的堆栈\ndown [n frames]           -- 下移线程的堆栈\nkill <thread id> <expr>   -- 终止具有给定的异常错误对象的线程\ninterrupt <thread id>     -- 中断线程\n\nprint <expr>              -- 输出表达式的值\ndump <expr>               -- 输出所有对象信息\neval <expr>               -- 对表达式求值 (与 print 相同)\nset <lvalue> = <expr>     -- 向字段/变量/数组元素分配新值\nlocals                    -- 输出当前堆栈帧中的所有本地变量\n\nclasses                   -- 列出当前已知的类\nclass <class id>          -- 显示已命名类的详细资料\nmethods <class id>        -- 列出类的方法\nfields <class id>         -- 列出类的字段\n\nthreadgroups              -- 列出线程组\nthreadgroup <name>        -- 设置当前线程组\n\nstop in <class id>.<method>[(argument_type,...)]\n                          -- 在方法中设置断点\nstop at <class id>:<line> -- 在行中设置断点\nclear <class id>.<method>[(argument_type,...)]\n                          -- 清除方法中的断点\nclear <class id>:<line>   -- 清除行中的断点\nclear                     -- 列出断点\ncatch [uncaught|caught|all] <class id>|<class pattern>\n                          -- 出现指定的异常错误时中断\nignore [uncaught|caught|all] <class id>|<class pattern>\n                          -- 对于指定的异常错误, 取消 'catch'\nwatch [access|all] <class id>.<field name>\n                          -- 监视对字段的访问/修改\nunwatch [access|all] <class id>.<field name>\n                          -- 停止监视对字段的访问/修改\ntrace [go] methods [thread]\n                          -- 跟踪方法进入和退出。\n                          -- 除非指定 'go', 否则挂起所有线程\ntrace [go] method exit | exits [thread]\n                          -- 跟踪当前方法的退出, 或者所有方法的退出\n                          -- 除非指定 'go', 否则挂起所有线程\nuntrace [methods]         -- 停止跟踪方法进入和/或退出\nstep                      -- 执行当前行\nstep up                   -- 一直执行, 直到当前方法返回到其调用方\nstepi                     -- 执行当前指令\nnext                      -- 步进一行 (步过调用)\ncont                      -- 从断点处继续执行\n\nlist [line number|method] -- 输出源代码\nuse (或 sourcepath) [source file path]\n                          -- 显示或更改源路径\nexclude [<class pattern>, ... | \"none\"]\n                          -- 对于指定的类, 不报告步骤或方法事件\nclasspath                 -- 从目标 VM 输出类路径信息\n\nmonitor <command>         -- 每次程序停止时执行命令\nmonitor                   -- 列出监视器\nunmonitor <monitor#>      -- 删除监视器\nread <filename>           -- 读取并执行命令文件\n\nlock <expr>               -- 输出对象的锁信息\nthreadlocks [thread id]   -- 输出线程的锁信息\n\npop                       -- 通过当前帧出栈, 且包含当前帧\nreenter                   -- 与 pop 相同, 但重新进入当前帧\nredefine <class id> <class file name>\n                          -- 重新定义类的代码\n\ndisablegc <expr>          -- 禁止对象的垃圾收集\nenablegc <expr>           -- 允许对象的垃圾收集\n\n!!                        -- 重复执行最后一个命令\n<n> <command>             -- 将命令重复执行 n 次\n# <command>               -- 放弃 (无操作)\nhelp (或 ?)               -- 列出命令\nversion                   -- 输出版本信息\nexit (或 quit)            -- 退出调试器\n\n<class id>: 带有程序包限定符的完整类名\n<class pattern>: 带有前导或尾随通配符 ('*') 的类名\n<thread id>: 'threads' 命令中报告的线程编号\n<expr>: Java(TM) 编程语言表达式。\n支持大多数常见语法。\n\n可以将启动命令置于 \"jdb.ini\" 或 \".jdbrc\" 中\n位于 user.home 或 user.dir 中\n>\n```\n上面的帮助信息说明了如何进行JDB调试，解释一下其中的几个：\n\nstep: -- 执行当前行 相当于Eclipse中的F5\n\nstep up: -- 一直执行, 直到当前方法返回到其调用方 相当于Eclipse中的F7\n\nnext: -- 步进一行 (步过调用) 相当于Eclipse中的F6\n\ncont: -- 从断点处继续执行 相当于Eclipse中的F8\n\n此时，继续输入：\n\n```\n> stop at test.JDBTest:7\n正在延迟断点test.JDBTest:7。\n将在加载类后设置。\n> run\n运行test.JDBTest\n设置未捕获的java.lang.Throwable\n设置延迟的未捕获的java.lang.Throwable\n>\nVM 已启动: 设置延迟的断点test.JDBTest:7\n\n断点命中: \"线程=main\", test.JDBTest.main(), 行=7 bci=0\n7               JDBTest jdbTest = new JDBTest();\n\nmain[1]\n```\nstop at test.JDBTest:7 表示在这个类文件的第7行处打一个断点\n\n接着，输入run，就开始进入调试步骤了。现在可以输入上面帮助中的语法来了解当前程序的执行情况了。一试便知\n\n`注意, 若想要在调试时能够正常输出调试信息如变量值等等，需要在编译java文件时指定 -g 参数，否则无法获得其运行时的调试信息`\n\n另外，使用list可以打印当前断点处的源代码，如果没有在启动JDB时指定源代码路径 -sourcepath ./src/ ，那么会提示没有源代码信息，无法输出。此时可以使用命令 use ./src/ 来指定源代码路径，再使用list命令时可以正常打印了。\n\n以上就是使用JDB调试本地程序的方法，具体的使用可根据实际情况参照语法说明去执行。\n\n## 使用JDB进行远程调试\n\n如果程序不是运行在本机，而是在其他机器或者现场的时候，可以使用java提供的远程调试功能。\n\n假设程序现运行在主机 192.168.101.72 这台机器上，该机器为linux环境，且只可以通过ssh作为一个普通用户连接。我们想要在自己的机器上调试运行在192.168.101.72这台机器上的程序。\n\n### 启动要调试的程序\n\n在192.168.101.72这台主机上以下面的方式启动java程序：还是以JDBTest为例\n\n`java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest`\n\n此时，命令行输出\n\n`Listening for transport dt_socket at address: 8899`\n\n并处于等待状态\n\n下面是几个参数的解释：\n\n-Xdebug 启用调试特性。 \n\n-Xrunjdwp:<sub-options> 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。下面介绍一些特定的子选项。\n从 Java V5 开始，您可以使用 -agentlib:jdwp 选项，而不是 -Xdebug 和 -Xrunjdwp。但如果连接到 V5 以前的 VM，只能选择 -Xdebug 和 -Xrunjdwp。下面简单描述 -Xrunjdwp 子选项。\n\ntransport 这里通常使用套接字传输。但是在 Windows 平台上也可以使用共享内存传输。\n\nserver 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。\n\naddress 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。\n\nsuspend 如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。\n\n### 本机连接远程程序并启动调试\n\n在本机上命令行下输入：\n\n`jdb -connect com.sun.jdi.SocketAttach:hostname=192.168.101.72,port=8899`\n\n然后就进入了调试界面，你可以像调试本机程序那样使用JDB的一些命令来调试了。当退出调试程序时，远程主机上的程序也就退出了。\n\n\n## 使用Eclipse进行远程调试\n\n可以使用Eclipse进行远程调试，就上上面使用JDB一样。\n\n### 启动要调试的程序\n\n与JDB远程调试一样，启动远程主机上的程序：\n\n`java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest`\n\n### 本机启动Eclipse进行调试\n\n首先要右键工程->java compiler\n\n{% asset_img setting.png jdpa %}\n\n上图中的几个选项最好全部打勾，否则调试时会出现无法打断点或者获取不到行号等问题(关于这几个选项的含义在之前的总结中有提到)\n\n接着，右键工程->Debug As->Run Configurations, 在出现的对话框中选择Remote Java Application, 右键->New, 出现如下界面：\n\n{% asset_img remote.png jdpa %}\n\n在Connect页中，选择对应的java 工程，Connection Type选择 Socket Attach，然后填写远程主机的ip和端口，这里应该填写192.168.101.72和8899。\n在Source页中可以添加源代码，如用到的第三方jar的源代码或者引用的工程，调试时就可以进入到这部分代码查看。在Common页可以设置编码的配置。\n\n接下来点击Debug按钮，就可以愉快的在本机调试远程程序了，就像调试本地程序那样。只不过可能有一点一点慢，不过比打Log的方式要好很多了。\n\n## 参考\n\n[使用 Eclipse 远程调试 Java 应用程序](https://www.ibm.com/developerworks/cn/opensource/os-eclipse-javadebug/)\n\n[JDB的简单使用](http://www.ibm.com/developerworks/cn/java/joy-jdb/)\n\n[深入 Java 调试体系: 第 1 部分，JPDA 体系概览 ](https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/)\n","source":"_posts/java远程调试学习.md","raw":"---\nlayout: post\ntitle: java远程调试学习\ndate: 2016-12-07 21:55:48\ncategories: 编程\ntags: \n- java \n- 调试\n---\n\n> 集群前后台协议需要做一些修改，我负责jdbc这边的修改。按照协议内容修改完代码之后却面临一个测试的问题：修改后的后台又部署在北京，但北京并不是所有的机器都对天津这边开放，只给提供一台机器A，就是集群的服务器。\n> 这样的话,就无法创建节点的连接，测试没有办法进行。\n\n> 一开始用了最简单的办法，把打好的jar包通过远程ssh放到A上面，再通过ssh去跑用例，打印结果看看正确与否。但是这样的效率真的太低了，每做一次修改都要打包、部署、运行、分析log。于是借这个机会学习一下java程序的远程调试。以下为总结。\n\n\n## 一些概念\n\nJDPA: java平台调试架构\n\nJVMTI: JVM端调试接口\n\nJDI: java端调试接口\n\nJDWP: java调试网络协议\n\n{% asset_img jdpa.png jdpa %}\n\nJPDA 定义了一套如何开发调试工具的接口和规范。\n\nJPDA 由三个独立的模块 JVMTI、JDWP、JDI 组成。\n\n调试者通过 JDI 发送接受调试命令。\n\nJDWP 定义调试者和被调试者交流数据的格式。\n\nJVMTI 可以控制当前虚拟机运行状态。\n\n上图中的前端工具就是我们要用到的调试工具。如JDB、Eclipse等等。这些工具实现了JDI接口，通过这些工具我们可以达到在命令行或者图形界面下调试的目的。\n\n关于这部分，只是简单的了解一下概念，更多的关于JDPA的介绍：[JDPA体系](http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?search_by=%E6%B7%B1%E5%85%A5+Java+%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB)\n\n<!-- more -->\n\n## 使用JDB进行本地调试\n\nJDB 是jdk自带的一个调试工具，用于命令行下调试java程序\n\njdb.exe就位于jdk安装目录的bin目录下，安装好jdk并设置好环境变量之后就可以愉快的使用jdb了。\n\n```\nC:\\Users\\kyu>jdb -help\n用法: jdb <options> <class> <arguments>\n\n其中, 选项包括:\n    -help             输出此消息并退出\n    -sourcepath <由 \";\" 分隔的目录>\n                      要在其中查找源文件的目录\n    -attach <address>\n                      使用标准连接器附加到指定地址处正在运行的 VM\n    -listen <address>\n                      等待正在运行的 VM 使用标准连接器在指定地址处连接\n    -listenany\n                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接\n    -launch\n                      立即启动 VM 而不是等待 'run' 命令\n    -listconnectors   列出此 VM 中的可用连接器\n    -connect <connector-name>:<name1>=<value1>,...\n                      使用所列参数值通过指定的连接器连接到目标 VM\n    -dbgtrace [flags] 输出信息供调试jdb\n    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序\n    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序\n\n转发到被调试进程的选项:\n    -v -verbose[:class|gc|jni]\n                      启用详细模式\n    -D<name>=<value>  设置系统属性\n    -classpath <由 \";\" 分隔的目录>\n                      列出要在其中查找类的目录\n    -X<option>        非标准目标 VM 选项\n\n<class> 是要开始调试的类的名称\n<arguments> 是传递到 <class> 的 main() 方法的参数\n\n要获得命令的帮助, 请在jdb提示下键入 'help'\n```\n\n上面是启动JDB的语法说明。\n\n现假设运行程序的工程目录如下：\n\n```\nJDBTest\n  |----bin(编译生成的class文件)\n  |     |----*.class\n  |----src(源文件)\n  |     |----*.java\n  |----lib(依赖的第三方jar)\n  |     |----*.jar\n```\n\n开始启动JDB调试：\n\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n\n`注意，如果有多个文件，windows下使用 \";\" 分隔每个文件或目录，Linux下使用 \":\" 分隔每个文件或目录`\n\n`-classpath` 指定了类路径，`-sourcepath` 指定了源文件的路径\n\n回车，出现如下信息：\n\n```\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n正在初始化jdb...\n> \n```\n此时，JDB调试器等待用户的输入，输入`help`，出现如下信息：\n\n```\nY:\\project\\JavaProject\\JDBTest>jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest\n正在初始化jdb...\n> help\n** 命令列表 **\nconnectors                -- 列出此 VM 中可用的连接器和传输\n\nrun [class [args]]        -- 开始执行应用程序的主类\n\nthreads [threadgroup]     -- 列出线程\nthread <thread id>        -- 设置默认线程\nsuspend [thread id(s)]    -- 挂起线程 (默认值: all)\nresume [thread id(s)]     -- 恢复线程 (默认值: all)\nwhere [<thread id> | all] -- 转储线程的堆栈\nwherei [<thread id> | all]-- 转储线程的堆栈, 以及 pc 信息\nup [n frames]             -- 上移线程的堆栈\ndown [n frames]           -- 下移线程的堆栈\nkill <thread id> <expr>   -- 终止具有给定的异常错误对象的线程\ninterrupt <thread id>     -- 中断线程\n\nprint <expr>              -- 输出表达式的值\ndump <expr>               -- 输出所有对象信息\neval <expr>               -- 对表达式求值 (与 print 相同)\nset <lvalue> = <expr>     -- 向字段/变量/数组元素分配新值\nlocals                    -- 输出当前堆栈帧中的所有本地变量\n\nclasses                   -- 列出当前已知的类\nclass <class id>          -- 显示已命名类的详细资料\nmethods <class id>        -- 列出类的方法\nfields <class id>         -- 列出类的字段\n\nthreadgroups              -- 列出线程组\nthreadgroup <name>        -- 设置当前线程组\n\nstop in <class id>.<method>[(argument_type,...)]\n                          -- 在方法中设置断点\nstop at <class id>:<line> -- 在行中设置断点\nclear <class id>.<method>[(argument_type,...)]\n                          -- 清除方法中的断点\nclear <class id>:<line>   -- 清除行中的断点\nclear                     -- 列出断点\ncatch [uncaught|caught|all] <class id>|<class pattern>\n                          -- 出现指定的异常错误时中断\nignore [uncaught|caught|all] <class id>|<class pattern>\n                          -- 对于指定的异常错误, 取消 'catch'\nwatch [access|all] <class id>.<field name>\n                          -- 监视对字段的访问/修改\nunwatch [access|all] <class id>.<field name>\n                          -- 停止监视对字段的访问/修改\ntrace [go] methods [thread]\n                          -- 跟踪方法进入和退出。\n                          -- 除非指定 'go', 否则挂起所有线程\ntrace [go] method exit | exits [thread]\n                          -- 跟踪当前方法的退出, 或者所有方法的退出\n                          -- 除非指定 'go', 否则挂起所有线程\nuntrace [methods]         -- 停止跟踪方法进入和/或退出\nstep                      -- 执行当前行\nstep up                   -- 一直执行, 直到当前方法返回到其调用方\nstepi                     -- 执行当前指令\nnext                      -- 步进一行 (步过调用)\ncont                      -- 从断点处继续执行\n\nlist [line number|method] -- 输出源代码\nuse (或 sourcepath) [source file path]\n                          -- 显示或更改源路径\nexclude [<class pattern>, ... | \"none\"]\n                          -- 对于指定的类, 不报告步骤或方法事件\nclasspath                 -- 从目标 VM 输出类路径信息\n\nmonitor <command>         -- 每次程序停止时执行命令\nmonitor                   -- 列出监视器\nunmonitor <monitor#>      -- 删除监视器\nread <filename>           -- 读取并执行命令文件\n\nlock <expr>               -- 输出对象的锁信息\nthreadlocks [thread id]   -- 输出线程的锁信息\n\npop                       -- 通过当前帧出栈, 且包含当前帧\nreenter                   -- 与 pop 相同, 但重新进入当前帧\nredefine <class id> <class file name>\n                          -- 重新定义类的代码\n\ndisablegc <expr>          -- 禁止对象的垃圾收集\nenablegc <expr>           -- 允许对象的垃圾收集\n\n!!                        -- 重复执行最后一个命令\n<n> <command>             -- 将命令重复执行 n 次\n# <command>               -- 放弃 (无操作)\nhelp (或 ?)               -- 列出命令\nversion                   -- 输出版本信息\nexit (或 quit)            -- 退出调试器\n\n<class id>: 带有程序包限定符的完整类名\n<class pattern>: 带有前导或尾随通配符 ('*') 的类名\n<thread id>: 'threads' 命令中报告的线程编号\n<expr>: Java(TM) 编程语言表达式。\n支持大多数常见语法。\n\n可以将启动命令置于 \"jdb.ini\" 或 \".jdbrc\" 中\n位于 user.home 或 user.dir 中\n>\n```\n上面的帮助信息说明了如何进行JDB调试，解释一下其中的几个：\n\nstep: -- 执行当前行 相当于Eclipse中的F5\n\nstep up: -- 一直执行, 直到当前方法返回到其调用方 相当于Eclipse中的F7\n\nnext: -- 步进一行 (步过调用) 相当于Eclipse中的F6\n\ncont: -- 从断点处继续执行 相当于Eclipse中的F8\n\n此时，继续输入：\n\n```\n> stop at test.JDBTest:7\n正在延迟断点test.JDBTest:7。\n将在加载类后设置。\n> run\n运行test.JDBTest\n设置未捕获的java.lang.Throwable\n设置延迟的未捕获的java.lang.Throwable\n>\nVM 已启动: 设置延迟的断点test.JDBTest:7\n\n断点命中: \"线程=main\", test.JDBTest.main(), 行=7 bci=0\n7               JDBTest jdbTest = new JDBTest();\n\nmain[1]\n```\nstop at test.JDBTest:7 表示在这个类文件的第7行处打一个断点\n\n接着，输入run，就开始进入调试步骤了。现在可以输入上面帮助中的语法来了解当前程序的执行情况了。一试便知\n\n`注意, 若想要在调试时能够正常输出调试信息如变量值等等，需要在编译java文件时指定 -g 参数，否则无法获得其运行时的调试信息`\n\n另外，使用list可以打印当前断点处的源代码，如果没有在启动JDB时指定源代码路径 -sourcepath ./src/ ，那么会提示没有源代码信息，无法输出。此时可以使用命令 use ./src/ 来指定源代码路径，再使用list命令时可以正常打印了。\n\n以上就是使用JDB调试本地程序的方法，具体的使用可根据实际情况参照语法说明去执行。\n\n## 使用JDB进行远程调试\n\n如果程序不是运行在本机，而是在其他机器或者现场的时候，可以使用java提供的远程调试功能。\n\n假设程序现运行在主机 192.168.101.72 这台机器上，该机器为linux环境，且只可以通过ssh作为一个普通用户连接。我们想要在自己的机器上调试运行在192.168.101.72这台机器上的程序。\n\n### 启动要调试的程序\n\n在192.168.101.72这台主机上以下面的方式启动java程序：还是以JDBTest为例\n\n`java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest`\n\n此时，命令行输出\n\n`Listening for transport dt_socket at address: 8899`\n\n并处于等待状态\n\n下面是几个参数的解释：\n\n-Xdebug 启用调试特性。 \n\n-Xrunjdwp:<sub-options> 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。下面介绍一些特定的子选项。\n从 Java V5 开始，您可以使用 -agentlib:jdwp 选项，而不是 -Xdebug 和 -Xrunjdwp。但如果连接到 V5 以前的 VM，只能选择 -Xdebug 和 -Xrunjdwp。下面简单描述 -Xrunjdwp 子选项。\n\ntransport 这里通常使用套接字传输。但是在 Windows 平台上也可以使用共享内存传输。\n\nserver 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。\n\naddress 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。\n\nsuspend 如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。\n\n### 本机连接远程程序并启动调试\n\n在本机上命令行下输入：\n\n`jdb -connect com.sun.jdi.SocketAttach:hostname=192.168.101.72,port=8899`\n\n然后就进入了调试界面，你可以像调试本机程序那样使用JDB的一些命令来调试了。当退出调试程序时，远程主机上的程序也就退出了。\n\n\n## 使用Eclipse进行远程调试\n\n可以使用Eclipse进行远程调试，就上上面使用JDB一样。\n\n### 启动要调试的程序\n\n与JDB远程调试一样，启动远程主机上的程序：\n\n`java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest`\n\n### 本机启动Eclipse进行调试\n\n首先要右键工程->java compiler\n\n{% asset_img setting.png jdpa %}\n\n上图中的几个选项最好全部打勾，否则调试时会出现无法打断点或者获取不到行号等问题(关于这几个选项的含义在之前的总结中有提到)\n\n接着，右键工程->Debug As->Run Configurations, 在出现的对话框中选择Remote Java Application, 右键->New, 出现如下界面：\n\n{% asset_img remote.png jdpa %}\n\n在Connect页中，选择对应的java 工程，Connection Type选择 Socket Attach，然后填写远程主机的ip和端口，这里应该填写192.168.101.72和8899。\n在Source页中可以添加源代码，如用到的第三方jar的源代码或者引用的工程，调试时就可以进入到这部分代码查看。在Common页可以设置编码的配置。\n\n接下来点击Debug按钮，就可以愉快的在本机调试远程程序了，就像调试本地程序那样。只不过可能有一点一点慢，不过比打Log的方式要好很多了。\n\n## 参考\n\n[使用 Eclipse 远程调试 Java 应用程序](https://www.ibm.com/developerworks/cn/opensource/os-eclipse-javadebug/)\n\n[JDB的简单使用](http://www.ibm.com/developerworks/cn/java/joy-jdb/)\n\n[深入 Java 调试体系: 第 1 部分，JPDA 体系概览 ](https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/)\n","slug":"java远程调试学习","published":1,"updated":"2017-04-11T13:08:38.845Z","comments":1,"photos":[],"link":"","_id":"cj4vch4fh0033x3gcaxcr2fsn","content":"<blockquote>\n<p>集群前后台协议需要做一些修改，我负责jdbc这边的修改。按照协议内容修改完代码之后却面临一个测试的问题：修改后的后台又部署在北京，但北京并不是所有的机器都对天津这边开放，只给提供一台机器A，就是集群的服务器。<br>这样的话,就无法创建节点的连接，测试没有办法进行。</p>\n<p>一开始用了最简单的办法，把打好的jar包通过远程ssh放到A上面，再通过ssh去跑用例，打印结果看看正确与否。但是这样的效率真的太低了，每做一次修改都要打包、部署、运行、分析log。于是借这个机会学习一下java程序的远程调试。以下为总结。</p>\n</blockquote>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><p>JDPA: java平台调试架构</p>\n<p>JVMTI: JVM端调试接口</p>\n<p>JDI: java端调试接口</p>\n<p>JDWP: java调试网络协议</p>\n<img src=\"/2016/12/07/java远程调试学习/jdpa.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>JPDA 定义了一套如何开发调试工具的接口和规范。</p>\n<p>JPDA 由三个独立的模块 JVMTI、JDWP、JDI 组成。</p>\n<p>调试者通过 JDI 发送接受调试命令。</p>\n<p>JDWP 定义调试者和被调试者交流数据的格式。</p>\n<p>JVMTI 可以控制当前虚拟机运行状态。</p>\n<p>上图中的前端工具就是我们要用到的调试工具。如JDB、Eclipse等等。这些工具实现了JDI接口，通过这些工具我们可以达到在命令行或者图形界面下调试的目的。</p>\n<p>关于这部分，只是简单的了解一下概念，更多的关于JDPA的介绍：<a href=\"http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?search_by=%E6%B7%B1%E5%85%A5+Java+%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB\" target=\"_blank\" rel=\"external\">JDPA体系</a></p>\n<a id=\"more\"></a>\n<h2 id=\"使用JDB进行本地调试\"><a href=\"#使用JDB进行本地调试\" class=\"headerlink\" title=\"使用JDB进行本地调试\"></a>使用JDB进行本地调试</h2><p>JDB 是jdk自带的一个调试工具，用于命令行下调试java程序</p>\n<p>jdb.exe就位于jdk安装目录的bin目录下，安装好jdk并设置好环境变量之后就可以愉快的使用jdb了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:\\Users\\kyu&gt;jdb -help</div><div class=\"line\">用法: jdb &lt;options&gt; &lt;class&gt; &lt;arguments&gt;</div><div class=\"line\"></div><div class=\"line\">其中, 选项包括:</div><div class=\"line\">    -help             输出此消息并退出</div><div class=\"line\">    -sourcepath &lt;由 &quot;;&quot; 分隔的目录&gt;</div><div class=\"line\">                      要在其中查找源文件的目录</div><div class=\"line\">    -attach &lt;address&gt;</div><div class=\"line\">                      使用标准连接器附加到指定地址处正在运行的 VM</div><div class=\"line\">    -listen &lt;address&gt;</div><div class=\"line\">                      等待正在运行的 VM 使用标准连接器在指定地址处连接</div><div class=\"line\">    -listenany</div><div class=\"line\">                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接</div><div class=\"line\">    -launch</div><div class=\"line\">                      立即启动 VM 而不是等待 &apos;run&apos; 命令</div><div class=\"line\">    -listconnectors   列出此 VM 中的可用连接器</div><div class=\"line\">    -connect &lt;connector-name&gt;:&lt;name1&gt;=&lt;value1&gt;,...</div><div class=\"line\">                      使用所列参数值通过指定的连接器连接到目标 VM</div><div class=\"line\">    -dbgtrace [flags] 输出信息供调试jdb</div><div class=\"line\">    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序</div><div class=\"line\">    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序</div><div class=\"line\"></div><div class=\"line\">转发到被调试进程的选项:</div><div class=\"line\">    -v -verbose[:class|gc|jni]</div><div class=\"line\">                      启用详细模式</div><div class=\"line\">    -D&lt;name&gt;=&lt;value&gt;  设置系统属性</div><div class=\"line\">    -classpath &lt;由 &quot;;&quot; 分隔的目录&gt;</div><div class=\"line\">                      列出要在其中查找类的目录</div><div class=\"line\">    -X&lt;option&gt;        非标准目标 VM 选项</div><div class=\"line\"></div><div class=\"line\">&lt;class&gt; 是要开始调试的类的名称</div><div class=\"line\">&lt;arguments&gt; 是传递到 &lt;class&gt; 的 main() 方法的参数</div><div class=\"line\"></div><div class=\"line\">要获得命令的帮助, 请在jdb提示下键入 &apos;help&apos;</div></pre></td></tr></table></figure>\n<p>上面是启动JDB的语法说明。</p>\n<p>现假设运行程序的工程目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">JDBTest</div><div class=\"line\">  |----bin(编译生成的class文件)</div><div class=\"line\">  |     |----*.class</div><div class=\"line\">  |----src(源文件)</div><div class=\"line\">  |     |----*.java</div><div class=\"line\">  |----lib(依赖的第三方jar)</div><div class=\"line\">  |     |----*.jar</div></pre></td></tr></table></figure>\n<p>开始启动JDB调试：</p>\n<p>Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</p>\n<p><code>注意，如果有多个文件，windows下使用 &quot;;&quot; 分隔每个文件或目录，Linux下使用 &quot;:&quot; 分隔每个文件或目录</code></p>\n<p><code>-classpath</code> 指定了类路径，<code>-sourcepath</code> 指定了源文件的路径</p>\n<p>回车，出现如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</div><div class=\"line\">正在初始化jdb...</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<p>此时，JDB调试器等待用户的输入，输入<code>help</code>，出现如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div></pre></td><td class=\"code\"><pre><div class=\"line\">Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</div><div class=\"line\">正在初始化jdb...</div><div class=\"line\">&gt; help</div><div class=\"line\">** 命令列表 **</div><div class=\"line\">connectors                -- 列出此 VM 中可用的连接器和传输</div><div class=\"line\"></div><div class=\"line\">run [class [args]]        -- 开始执行应用程序的主类</div><div class=\"line\"></div><div class=\"line\">threads [threadgroup]     -- 列出线程</div><div class=\"line\">thread &lt;thread id&gt;        -- 设置默认线程</div><div class=\"line\">suspend [thread id(s)]    -- 挂起线程 (默认值: all)</div><div class=\"line\">resume [thread id(s)]     -- 恢复线程 (默认值: all)</div><div class=\"line\">where [&lt;thread id&gt; | all] -- 转储线程的堆栈</div><div class=\"line\">wherei [&lt;thread id&gt; | all]-- 转储线程的堆栈, 以及 pc 信息</div><div class=\"line\">up [n frames]             -- 上移线程的堆栈</div><div class=\"line\">down [n frames]           -- 下移线程的堆栈</div><div class=\"line\">kill &lt;thread id&gt; &lt;expr&gt;   -- 终止具有给定的异常错误对象的线程</div><div class=\"line\">interrupt &lt;thread id&gt;     -- 中断线程</div><div class=\"line\"></div><div class=\"line\">print &lt;expr&gt;              -- 输出表达式的值</div><div class=\"line\">dump &lt;expr&gt;               -- 输出所有对象信息</div><div class=\"line\">eval &lt;expr&gt;               -- 对表达式求值 (与 print 相同)</div><div class=\"line\">set &lt;lvalue&gt; = &lt;expr&gt;     -- 向字段/变量/数组元素分配新值</div><div class=\"line\">locals                    -- 输出当前堆栈帧中的所有本地变量</div><div class=\"line\"></div><div class=\"line\">classes                   -- 列出当前已知的类</div><div class=\"line\">class &lt;class id&gt;          -- 显示已命名类的详细资料</div><div class=\"line\">methods &lt;class id&gt;        -- 列出类的方法</div><div class=\"line\">fields &lt;class id&gt;         -- 列出类的字段</div><div class=\"line\"></div><div class=\"line\">threadgroups              -- 列出线程组</div><div class=\"line\">threadgroup &lt;name&gt;        -- 设置当前线程组</div><div class=\"line\"></div><div class=\"line\">stop in &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]</div><div class=\"line\">                          -- 在方法中设置断点</div><div class=\"line\">stop at &lt;class id&gt;:&lt;line&gt; -- 在行中设置断点</div><div class=\"line\">clear &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]</div><div class=\"line\">                          -- 清除方法中的断点</div><div class=\"line\">clear &lt;class id&gt;:&lt;line&gt;   -- 清除行中的断点</div><div class=\"line\">clear                     -- 列出断点</div><div class=\"line\">catch [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;</div><div class=\"line\">                          -- 出现指定的异常错误时中断</div><div class=\"line\">ignore [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;</div><div class=\"line\">                          -- 对于指定的异常错误, 取消 &apos;catch&apos;</div><div class=\"line\">watch [access|all] &lt;class id&gt;.&lt;field name&gt;</div><div class=\"line\">                          -- 监视对字段的访问/修改</div><div class=\"line\">unwatch [access|all] &lt;class id&gt;.&lt;field name&gt;</div><div class=\"line\">                          -- 停止监视对字段的访问/修改</div><div class=\"line\">trace [go] methods [thread]</div><div class=\"line\">                          -- 跟踪方法进入和退出。</div><div class=\"line\">                          -- 除非指定 &apos;go&apos;, 否则挂起所有线程</div><div class=\"line\">trace [go] method exit | exits [thread]</div><div class=\"line\">                          -- 跟踪当前方法的退出, 或者所有方法的退出</div><div class=\"line\">                          -- 除非指定 &apos;go&apos;, 否则挂起所有线程</div><div class=\"line\">untrace [methods]         -- 停止跟踪方法进入和/或退出</div><div class=\"line\">step                      -- 执行当前行</div><div class=\"line\">step up                   -- 一直执行, 直到当前方法返回到其调用方</div><div class=\"line\">stepi                     -- 执行当前指令</div><div class=\"line\">next                      -- 步进一行 (步过调用)</div><div class=\"line\">cont                      -- 从断点处继续执行</div><div class=\"line\"></div><div class=\"line\">list [line number|method] -- 输出源代码</div><div class=\"line\">use (或 sourcepath) [source file path]</div><div class=\"line\">                          -- 显示或更改源路径</div><div class=\"line\">exclude [&lt;class pattern&gt;, ... | &quot;none&quot;]</div><div class=\"line\">                          -- 对于指定的类, 不报告步骤或方法事件</div><div class=\"line\">classpath                 -- 从目标 VM 输出类路径信息</div><div class=\"line\"></div><div class=\"line\">monitor &lt;command&gt;         -- 每次程序停止时执行命令</div><div class=\"line\">monitor                   -- 列出监视器</div><div class=\"line\">unmonitor &lt;monitor#&gt;      -- 删除监视器</div><div class=\"line\">read &lt;filename&gt;           -- 读取并执行命令文件</div><div class=\"line\"></div><div class=\"line\">lock &lt;expr&gt;               -- 输出对象的锁信息</div><div class=\"line\">threadlocks [thread id]   -- 输出线程的锁信息</div><div class=\"line\"></div><div class=\"line\">pop                       -- 通过当前帧出栈, 且包含当前帧</div><div class=\"line\">reenter                   -- 与 pop 相同, 但重新进入当前帧</div><div class=\"line\">redefine &lt;class id&gt; &lt;class file name&gt;</div><div class=\"line\">                          -- 重新定义类的代码</div><div class=\"line\"></div><div class=\"line\">disablegc &lt;expr&gt;          -- 禁止对象的垃圾收集</div><div class=\"line\">enablegc &lt;expr&gt;           -- 允许对象的垃圾收集</div><div class=\"line\"></div><div class=\"line\">!!                        -- 重复执行最后一个命令</div><div class=\"line\">&lt;n&gt; &lt;command&gt;             -- 将命令重复执行 n 次</div><div class=\"line\"># &lt;command&gt;               -- 放弃 (无操作)</div><div class=\"line\">help (或 ?)               -- 列出命令</div><div class=\"line\">version                   -- 输出版本信息</div><div class=\"line\">exit (或 quit)            -- 退出调试器</div><div class=\"line\"></div><div class=\"line\">&lt;class id&gt;: 带有程序包限定符的完整类名</div><div class=\"line\">&lt;class pattern&gt;: 带有前导或尾随通配符 (&apos;*&apos;) 的类名</div><div class=\"line\">&lt;thread id&gt;: &apos;threads&apos; 命令中报告的线程编号</div><div class=\"line\">&lt;expr&gt;: Java(TM) 编程语言表达式。</div><div class=\"line\">支持大多数常见语法。</div><div class=\"line\"></div><div class=\"line\">可以将启动命令置于 &quot;jdb.ini&quot; 或 &quot;.jdbrc&quot; 中</div><div class=\"line\">位于 user.home 或 user.dir 中</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<p>上面的帮助信息说明了如何进行JDB调试，解释一下其中的几个：</p>\n<p>step: – 执行当前行 相当于Eclipse中的F5</p>\n<p>step up: – 一直执行, 直到当前方法返回到其调用方 相当于Eclipse中的F7</p>\n<p>next: – 步进一行 (步过调用) 相当于Eclipse中的F6</p>\n<p>cont: – 从断点处继续执行 相当于Eclipse中的F8</p>\n<p>此时，继续输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; stop at test.JDBTest:7</div><div class=\"line\">正在延迟断点test.JDBTest:7。</div><div class=\"line\">将在加载类后设置。</div><div class=\"line\">&gt; run</div><div class=\"line\">运行test.JDBTest</div><div class=\"line\">设置未捕获的java.lang.Throwable</div><div class=\"line\">设置延迟的未捕获的java.lang.Throwable</div><div class=\"line\">&gt;</div><div class=\"line\">VM 已启动: 设置延迟的断点test.JDBTest:7</div><div class=\"line\"></div><div class=\"line\">断点命中: &quot;线程=main&quot;, test.JDBTest.main(), 行=7 bci=0</div><div class=\"line\">7               JDBTest jdbTest = new JDBTest();</div><div class=\"line\"></div><div class=\"line\">main[1]</div></pre></td></tr></table></figure>\n<p>stop at test.JDBTest:7 表示在这个类文件的第7行处打一个断点</p>\n<p>接着，输入run，就开始进入调试步骤了。现在可以输入上面帮助中的语法来了解当前程序的执行情况了。一试便知</p>\n<p><code>注意, 若想要在调试时能够正常输出调试信息如变量值等等，需要在编译java文件时指定 -g 参数，否则无法获得其运行时的调试信息</code></p>\n<p>另外，使用list可以打印当前断点处的源代码，如果没有在启动JDB时指定源代码路径 -sourcepath ./src/ ，那么会提示没有源代码信息，无法输出。此时可以使用命令 use ./src/ 来指定源代码路径，再使用list命令时可以正常打印了。</p>\n<p>以上就是使用JDB调试本地程序的方法，具体的使用可根据实际情况参照语法说明去执行。</p>\n<h2 id=\"使用JDB进行远程调试\"><a href=\"#使用JDB进行远程调试\" class=\"headerlink\" title=\"使用JDB进行远程调试\"></a>使用JDB进行远程调试</h2><p>如果程序不是运行在本机，而是在其他机器或者现场的时候，可以使用java提供的远程调试功能。</p>\n<p>假设程序现运行在主机 192.168.101.72 这台机器上，该机器为linux环境，且只可以通过ssh作为一个普通用户连接。我们想要在自己的机器上调试运行在192.168.101.72这台机器上的程序。</p>\n<h3 id=\"启动要调试的程序\"><a href=\"#启动要调试的程序\" class=\"headerlink\" title=\"启动要调试的程序\"></a>启动要调试的程序</h3><p>在192.168.101.72这台主机上以下面的方式启动java程序：还是以JDBTest为例</p>\n<p><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest</code></p>\n<p>此时，命令行输出</p>\n<p><code>Listening for transport dt_socket at address: 8899</code></p>\n<p>并处于等待状态</p>\n<p>下面是几个参数的解释：</p>\n<p>-Xdebug 启用调试特性。 </p>\n<p>-Xrunjdwp:<sub-options> 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。下面介绍一些特定的子选项。<br>从 Java V5 开始，您可以使用 -agentlib:jdwp 选项，而不是 -Xdebug 和 -Xrunjdwp。但如果连接到 V5 以前的 VM，只能选择 -Xdebug 和 -Xrunjdwp。下面简单描述 -Xrunjdwp 子选项。</sub-options></p>\n<p>transport 这里通常使用套接字传输。但是在 Windows 平台上也可以使用共享内存传输。</p>\n<p>server 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。</p>\n<p>address 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。</p>\n<p>suspend 如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。</p>\n<h3 id=\"本机连接远程程序并启动调试\"><a href=\"#本机连接远程程序并启动调试\" class=\"headerlink\" title=\"本机连接远程程序并启动调试\"></a>本机连接远程程序并启动调试</h3><p>在本机上命令行下输入：</p>\n<p><code>jdb -connect com.sun.jdi.SocketAttach:hostname=192.168.101.72,port=8899</code></p>\n<p>然后就进入了调试界面，你可以像调试本机程序那样使用JDB的一些命令来调试了。当退出调试程序时，远程主机上的程序也就退出了。</p>\n<h2 id=\"使用Eclipse进行远程调试\"><a href=\"#使用Eclipse进行远程调试\" class=\"headerlink\" title=\"使用Eclipse进行远程调试\"></a>使用Eclipse进行远程调试</h2><p>可以使用Eclipse进行远程调试，就上上面使用JDB一样。</p>\n<h3 id=\"启动要调试的程序-1\"><a href=\"#启动要调试的程序-1\" class=\"headerlink\" title=\"启动要调试的程序\"></a>启动要调试的程序</h3><p>与JDB远程调试一样，启动远程主机上的程序：</p>\n<p><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest</code></p>\n<h3 id=\"本机启动Eclipse进行调试\"><a href=\"#本机启动Eclipse进行调试\" class=\"headerlink\" title=\"本机启动Eclipse进行调试\"></a>本机启动Eclipse进行调试</h3><p>首先要右键工程-&gt;java compiler</p>\n<img src=\"/2016/12/07/java远程调试学习/setting.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>上图中的几个选项最好全部打勾，否则调试时会出现无法打断点或者获取不到行号等问题(关于这几个选项的含义在之前的总结中有提到)</p>\n<p>接着，右键工程-&gt;Debug As-&gt;Run Configurations, 在出现的对话框中选择Remote Java Application, 右键-&gt;New, 出现如下界面：</p>\n<img src=\"/2016/12/07/java远程调试学习/remote.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>在Connect页中，选择对应的java 工程，Connection Type选择 Socket Attach，然后填写远程主机的ip和端口，这里应该填写192.168.101.72和8899。<br>在Source页中可以添加源代码，如用到的第三方jar的源代码或者引用的工程，调试时就可以进入到这部分代码查看。在Common页可以设置编码的配置。</p>\n<p>接下来点击Debug按钮，就可以愉快的在本机调试远程程序了，就像调试本地程序那样。只不过可能有一点一点慢，不过比打Log的方式要好很多了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-eclipse-javadebug/\" target=\"_blank\" rel=\"external\">使用 Eclipse 远程调试 Java 应用程序</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/java/joy-jdb/\" target=\"_blank\" rel=\"external\">JDB的简单使用</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/\" target=\"_blank\" rel=\"external\">深入 Java 调试体系: 第 1 部分，JPDA 体系概览 </a></p>\n","excerpt":"<blockquote>\n<p>集群前后台协议需要做一些修改，我负责jdbc这边的修改。按照协议内容修改完代码之后却面临一个测试的问题：修改后的后台又部署在北京，但北京并不是所有的机器都对天津这边开放，只给提供一台机器A，就是集群的服务器。<br>这样的话,就无法创建节点的连接，测试没有办法进行。</p>\n<p>一开始用了最简单的办法，把打好的jar包通过远程ssh放到A上面，再通过ssh去跑用例，打印结果看看正确与否。但是这样的效率真的太低了，每做一次修改都要打包、部署、运行、分析log。于是借这个机会学习一下java程序的远程调试。以下为总结。</p>\n</blockquote>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><p>JDPA: java平台调试架构</p>\n<p>JVMTI: JVM端调试接口</p>\n<p>JDI: java端调试接口</p>\n<p>JDWP: java调试网络协议</p>\n<img src=\"/2016/12/07/java远程调试学习/jdpa.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>JPDA 定义了一套如何开发调试工具的接口和规范。</p>\n<p>JPDA 由三个独立的模块 JVMTI、JDWP、JDI 组成。</p>\n<p>调试者通过 JDI 发送接受调试命令。</p>\n<p>JDWP 定义调试者和被调试者交流数据的格式。</p>\n<p>JVMTI 可以控制当前虚拟机运行状态。</p>\n<p>上图中的前端工具就是我们要用到的调试工具。如JDB、Eclipse等等。这些工具实现了JDI接口，通过这些工具我们可以达到在命令行或者图形界面下调试的目的。</p>\n<p>关于这部分，只是简单的了解一下概念，更多的关于JDPA的介绍：<a href=\"http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?search_by=%E6%B7%B1%E5%85%A5+Java+%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB\">JDPA体系</a></p>","more":"<h2 id=\"使用JDB进行本地调试\"><a href=\"#使用JDB进行本地调试\" class=\"headerlink\" title=\"使用JDB进行本地调试\"></a>使用JDB进行本地调试</h2><p>JDB 是jdk自带的一个调试工具，用于命令行下调试java程序</p>\n<p>jdb.exe就位于jdk安装目录的bin目录下，安装好jdk并设置好环境变量之后就可以愉快的使用jdb了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:\\Users\\kyu&gt;jdb -help</div><div class=\"line\">用法: jdb &lt;options&gt; &lt;class&gt; &lt;arguments&gt;</div><div class=\"line\"></div><div class=\"line\">其中, 选项包括:</div><div class=\"line\">    -help             输出此消息并退出</div><div class=\"line\">    -sourcepath &lt;由 &quot;;&quot; 分隔的目录&gt;</div><div class=\"line\">                      要在其中查找源文件的目录</div><div class=\"line\">    -attach &lt;address&gt;</div><div class=\"line\">                      使用标准连接器附加到指定地址处正在运行的 VM</div><div class=\"line\">    -listen &lt;address&gt;</div><div class=\"line\">                      等待正在运行的 VM 使用标准连接器在指定地址处连接</div><div class=\"line\">    -listenany</div><div class=\"line\">                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接</div><div class=\"line\">    -launch</div><div class=\"line\">                      立即启动 VM 而不是等待 &apos;run&apos; 命令</div><div class=\"line\">    -listconnectors   列出此 VM 中的可用连接器</div><div class=\"line\">    -connect &lt;connector-name&gt;:&lt;name1&gt;=&lt;value1&gt;,...</div><div class=\"line\">                      使用所列参数值通过指定的连接器连接到目标 VM</div><div class=\"line\">    -dbgtrace [flags] 输出信息供调试jdb</div><div class=\"line\">    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序</div><div class=\"line\">    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序</div><div class=\"line\"></div><div class=\"line\">转发到被调试进程的选项:</div><div class=\"line\">    -v -verbose[:class|gc|jni]</div><div class=\"line\">                      启用详细模式</div><div class=\"line\">    -D&lt;name&gt;=&lt;value&gt;  设置系统属性</div><div class=\"line\">    -classpath &lt;由 &quot;;&quot; 分隔的目录&gt;</div><div class=\"line\">                      列出要在其中查找类的目录</div><div class=\"line\">    -X&lt;option&gt;        非标准目标 VM 选项</div><div class=\"line\"></div><div class=\"line\">&lt;class&gt; 是要开始调试的类的名称</div><div class=\"line\">&lt;arguments&gt; 是传递到 &lt;class&gt; 的 main() 方法的参数</div><div class=\"line\"></div><div class=\"line\">要获得命令的帮助, 请在jdb提示下键入 &apos;help&apos;</div></pre></td></tr></table></figure>\n<p>上面是启动JDB的语法说明。</p>\n<p>现假设运行程序的工程目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">JDBTest</div><div class=\"line\">  |----bin(编译生成的class文件)</div><div class=\"line\">  |     |----*.class</div><div class=\"line\">  |----src(源文件)</div><div class=\"line\">  |     |----*.java</div><div class=\"line\">  |----lib(依赖的第三方jar)</div><div class=\"line\">  |     |----*.jar</div></pre></td></tr></table></figure>\n<p>开始启动JDB调试：</p>\n<p>Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</p>\n<p><code>注意，如果有多个文件，windows下使用 &quot;;&quot; 分隔每个文件或目录，Linux下使用 &quot;:&quot; 分隔每个文件或目录</code></p>\n<p><code>-classpath</code> 指定了类路径，<code>-sourcepath</code> 指定了源文件的路径</p>\n<p>回车，出现如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</div><div class=\"line\">正在初始化jdb...</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<p>此时，JDB调试器等待用户的输入，输入<code>help</code>，出现如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div></pre></td><td class=\"code\"><pre><div class=\"line\">Y:\\project\\JavaProject\\JDBTest&gt;jdb -classpath ./bin/;./lib/* -sourcepath ./src/ test.JDBTest</div><div class=\"line\">正在初始化jdb...</div><div class=\"line\">&gt; help</div><div class=\"line\">** 命令列表 **</div><div class=\"line\">connectors                -- 列出此 VM 中可用的连接器和传输</div><div class=\"line\"></div><div class=\"line\">run [class [args]]        -- 开始执行应用程序的主类</div><div class=\"line\"></div><div class=\"line\">threads [threadgroup]     -- 列出线程</div><div class=\"line\">thread &lt;thread id&gt;        -- 设置默认线程</div><div class=\"line\">suspend [thread id(s)]    -- 挂起线程 (默认值: all)</div><div class=\"line\">resume [thread id(s)]     -- 恢复线程 (默认值: all)</div><div class=\"line\">where [&lt;thread id&gt; | all] -- 转储线程的堆栈</div><div class=\"line\">wherei [&lt;thread id&gt; | all]-- 转储线程的堆栈, 以及 pc 信息</div><div class=\"line\">up [n frames]             -- 上移线程的堆栈</div><div class=\"line\">down [n frames]           -- 下移线程的堆栈</div><div class=\"line\">kill &lt;thread id&gt; &lt;expr&gt;   -- 终止具有给定的异常错误对象的线程</div><div class=\"line\">interrupt &lt;thread id&gt;     -- 中断线程</div><div class=\"line\"></div><div class=\"line\">print &lt;expr&gt;              -- 输出表达式的值</div><div class=\"line\">dump &lt;expr&gt;               -- 输出所有对象信息</div><div class=\"line\">eval &lt;expr&gt;               -- 对表达式求值 (与 print 相同)</div><div class=\"line\">set &lt;lvalue&gt; = &lt;expr&gt;     -- 向字段/变量/数组元素分配新值</div><div class=\"line\">locals                    -- 输出当前堆栈帧中的所有本地变量</div><div class=\"line\"></div><div class=\"line\">classes                   -- 列出当前已知的类</div><div class=\"line\">class &lt;class id&gt;          -- 显示已命名类的详细资料</div><div class=\"line\">methods &lt;class id&gt;        -- 列出类的方法</div><div class=\"line\">fields &lt;class id&gt;         -- 列出类的字段</div><div class=\"line\"></div><div class=\"line\">threadgroups              -- 列出线程组</div><div class=\"line\">threadgroup &lt;name&gt;        -- 设置当前线程组</div><div class=\"line\"></div><div class=\"line\">stop in &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]</div><div class=\"line\">                          -- 在方法中设置断点</div><div class=\"line\">stop at &lt;class id&gt;:&lt;line&gt; -- 在行中设置断点</div><div class=\"line\">clear &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]</div><div class=\"line\">                          -- 清除方法中的断点</div><div class=\"line\">clear &lt;class id&gt;:&lt;line&gt;   -- 清除行中的断点</div><div class=\"line\">clear                     -- 列出断点</div><div class=\"line\">catch [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;</div><div class=\"line\">                          -- 出现指定的异常错误时中断</div><div class=\"line\">ignore [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;</div><div class=\"line\">                          -- 对于指定的异常错误, 取消 &apos;catch&apos;</div><div class=\"line\">watch [access|all] &lt;class id&gt;.&lt;field name&gt;</div><div class=\"line\">                          -- 监视对字段的访问/修改</div><div class=\"line\">unwatch [access|all] &lt;class id&gt;.&lt;field name&gt;</div><div class=\"line\">                          -- 停止监视对字段的访问/修改</div><div class=\"line\">trace [go] methods [thread]</div><div class=\"line\">                          -- 跟踪方法进入和退出。</div><div class=\"line\">                          -- 除非指定 &apos;go&apos;, 否则挂起所有线程</div><div class=\"line\">trace [go] method exit | exits [thread]</div><div class=\"line\">                          -- 跟踪当前方法的退出, 或者所有方法的退出</div><div class=\"line\">                          -- 除非指定 &apos;go&apos;, 否则挂起所有线程</div><div class=\"line\">untrace [methods]         -- 停止跟踪方法进入和/或退出</div><div class=\"line\">step                      -- 执行当前行</div><div class=\"line\">step up                   -- 一直执行, 直到当前方法返回到其调用方</div><div class=\"line\">stepi                     -- 执行当前指令</div><div class=\"line\">next                      -- 步进一行 (步过调用)</div><div class=\"line\">cont                      -- 从断点处继续执行</div><div class=\"line\"></div><div class=\"line\">list [line number|method] -- 输出源代码</div><div class=\"line\">use (或 sourcepath) [source file path]</div><div class=\"line\">                          -- 显示或更改源路径</div><div class=\"line\">exclude [&lt;class pattern&gt;, ... | &quot;none&quot;]</div><div class=\"line\">                          -- 对于指定的类, 不报告步骤或方法事件</div><div class=\"line\">classpath                 -- 从目标 VM 输出类路径信息</div><div class=\"line\"></div><div class=\"line\">monitor &lt;command&gt;         -- 每次程序停止时执行命令</div><div class=\"line\">monitor                   -- 列出监视器</div><div class=\"line\">unmonitor &lt;monitor#&gt;      -- 删除监视器</div><div class=\"line\">read &lt;filename&gt;           -- 读取并执行命令文件</div><div class=\"line\"></div><div class=\"line\">lock &lt;expr&gt;               -- 输出对象的锁信息</div><div class=\"line\">threadlocks [thread id]   -- 输出线程的锁信息</div><div class=\"line\"></div><div class=\"line\">pop                       -- 通过当前帧出栈, 且包含当前帧</div><div class=\"line\">reenter                   -- 与 pop 相同, 但重新进入当前帧</div><div class=\"line\">redefine &lt;class id&gt; &lt;class file name&gt;</div><div class=\"line\">                          -- 重新定义类的代码</div><div class=\"line\"></div><div class=\"line\">disablegc &lt;expr&gt;          -- 禁止对象的垃圾收集</div><div class=\"line\">enablegc &lt;expr&gt;           -- 允许对象的垃圾收集</div><div class=\"line\"></div><div class=\"line\">!!                        -- 重复执行最后一个命令</div><div class=\"line\">&lt;n&gt; &lt;command&gt;             -- 将命令重复执行 n 次</div><div class=\"line\"># &lt;command&gt;               -- 放弃 (无操作)</div><div class=\"line\">help (或 ?)               -- 列出命令</div><div class=\"line\">version                   -- 输出版本信息</div><div class=\"line\">exit (或 quit)            -- 退出调试器</div><div class=\"line\"></div><div class=\"line\">&lt;class id&gt;: 带有程序包限定符的完整类名</div><div class=\"line\">&lt;class pattern&gt;: 带有前导或尾随通配符 (&apos;*&apos;) 的类名</div><div class=\"line\">&lt;thread id&gt;: &apos;threads&apos; 命令中报告的线程编号</div><div class=\"line\">&lt;expr&gt;: Java(TM) 编程语言表达式。</div><div class=\"line\">支持大多数常见语法。</div><div class=\"line\"></div><div class=\"line\">可以将启动命令置于 &quot;jdb.ini&quot; 或 &quot;.jdbrc&quot; 中</div><div class=\"line\">位于 user.home 或 user.dir 中</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<p>上面的帮助信息说明了如何进行JDB调试，解释一下其中的几个：</p>\n<p>step: – 执行当前行 相当于Eclipse中的F5</p>\n<p>step up: – 一直执行, 直到当前方法返回到其调用方 相当于Eclipse中的F7</p>\n<p>next: – 步进一行 (步过调用) 相当于Eclipse中的F6</p>\n<p>cont: – 从断点处继续执行 相当于Eclipse中的F8</p>\n<p>此时，继续输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; stop at test.JDBTest:7</div><div class=\"line\">正在延迟断点test.JDBTest:7。</div><div class=\"line\">将在加载类后设置。</div><div class=\"line\">&gt; run</div><div class=\"line\">运行test.JDBTest</div><div class=\"line\">设置未捕获的java.lang.Throwable</div><div class=\"line\">设置延迟的未捕获的java.lang.Throwable</div><div class=\"line\">&gt;</div><div class=\"line\">VM 已启动: 设置延迟的断点test.JDBTest:7</div><div class=\"line\"></div><div class=\"line\">断点命中: &quot;线程=main&quot;, test.JDBTest.main(), 行=7 bci=0</div><div class=\"line\">7               JDBTest jdbTest = new JDBTest();</div><div class=\"line\"></div><div class=\"line\">main[1]</div></pre></td></tr></table></figure>\n<p>stop at test.JDBTest:7 表示在这个类文件的第7行处打一个断点</p>\n<p>接着，输入run，就开始进入调试步骤了。现在可以输入上面帮助中的语法来了解当前程序的执行情况了。一试便知</p>\n<p><code>注意, 若想要在调试时能够正常输出调试信息如变量值等等，需要在编译java文件时指定 -g 参数，否则无法获得其运行时的调试信息</code></p>\n<p>另外，使用list可以打印当前断点处的源代码，如果没有在启动JDB时指定源代码路径 -sourcepath ./src/ ，那么会提示没有源代码信息，无法输出。此时可以使用命令 use ./src/ 来指定源代码路径，再使用list命令时可以正常打印了。</p>\n<p>以上就是使用JDB调试本地程序的方法，具体的使用可根据实际情况参照语法说明去执行。</p>\n<h2 id=\"使用JDB进行远程调试\"><a href=\"#使用JDB进行远程调试\" class=\"headerlink\" title=\"使用JDB进行远程调试\"></a>使用JDB进行远程调试</h2><p>如果程序不是运行在本机，而是在其他机器或者现场的时候，可以使用java提供的远程调试功能。</p>\n<p>假设程序现运行在主机 192.168.101.72 这台机器上，该机器为linux环境，且只可以通过ssh作为一个普通用户连接。我们想要在自己的机器上调试运行在192.168.101.72这台机器上的程序。</p>\n<h3 id=\"启动要调试的程序\"><a href=\"#启动要调试的程序\" class=\"headerlink\" title=\"启动要调试的程序\"></a>启动要调试的程序</h3><p>在192.168.101.72这台主机上以下面的方式启动java程序：还是以JDBTest为例</p>\n<p><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest</code></p>\n<p>此时，命令行输出</p>\n<p><code>Listening for transport dt_socket at address: 8899</code></p>\n<p>并处于等待状态</p>\n<p>下面是几个参数的解释：</p>\n<p>-Xdebug 启用调试特性。 </p>\n<p>-Xrunjdwp:<sub-options> 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。下面介绍一些特定的子选项。<br>从 Java V5 开始，您可以使用 -agentlib:jdwp 选项，而不是 -Xdebug 和 -Xrunjdwp。但如果连接到 V5 以前的 VM，只能选择 -Xdebug 和 -Xrunjdwp。下面简单描述 -Xrunjdwp 子选项。</p>\n<p>transport 这里通常使用套接字传输。但是在 Windows 平台上也可以使用共享内存传输。</p>\n<p>server 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。</p>\n<p>address 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。</p>\n<p>suspend 如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。</p>\n<h3 id=\"本机连接远程程序并启动调试\"><a href=\"#本机连接远程程序并启动调试\" class=\"headerlink\" title=\"本机连接远程程序并启动调试\"></a>本机连接远程程序并启动调试</h3><p>在本机上命令行下输入：</p>\n<p><code>jdb -connect com.sun.jdi.SocketAttach:hostname=192.168.101.72,port=8899</code></p>\n<p>然后就进入了调试界面，你可以像调试本机程序那样使用JDB的一些命令来调试了。当退出调试程序时，远程主机上的程序也就退出了。</p>\n<h2 id=\"使用Eclipse进行远程调试\"><a href=\"#使用Eclipse进行远程调试\" class=\"headerlink\" title=\"使用Eclipse进行远程调试\"></a>使用Eclipse进行远程调试</h2><p>可以使用Eclipse进行远程调试，就上上面使用JDB一样。</p>\n<h3 id=\"启动要调试的程序-1\"><a href=\"#启动要调试的程序-1\" class=\"headerlink\" title=\"启动要调试的程序\"></a>启动要调试的程序</h3><p>与JDB远程调试一样，启动远程主机上的程序：</p>\n<p><code>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8899 -classpath ./bin/:./lib/*  test.JDBTest</code></p>\n<h3 id=\"本机启动Eclipse进行调试\"><a href=\"#本机启动Eclipse进行调试\" class=\"headerlink\" title=\"本机启动Eclipse进行调试\"></a>本机启动Eclipse进行调试</h3><p>首先要右键工程-&gt;java compiler</p>\n<img src=\"/2016/12/07/java远程调试学习/setting.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>上图中的几个选项最好全部打勾，否则调试时会出现无法打断点或者获取不到行号等问题(关于这几个选项的含义在之前的总结中有提到)</p>\n<p>接着，右键工程-&gt;Debug As-&gt;Run Configurations, 在出现的对话框中选择Remote Java Application, 右键-&gt;New, 出现如下界面：</p>\n<img src=\"/2016/12/07/java远程调试学习/remote.png\" alt=\"jdpa\" title=\"jdpa\">\n<p>在Connect页中，选择对应的java 工程，Connection Type选择 Socket Attach，然后填写远程主机的ip和端口，这里应该填写192.168.101.72和8899。<br>在Source页中可以添加源代码，如用到的第三方jar的源代码或者引用的工程，调试时就可以进入到这部分代码查看。在Common页可以设置编码的配置。</p>\n<p>接下来点击Debug按钮，就可以愉快的在本机调试远程程序了，就像调试本地程序那样。只不过可能有一点一点慢，不过比打Log的方式要好很多了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-eclipse-javadebug/\">使用 Eclipse 远程调试 Java 应用程序</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/java/joy-jdb/\">JDB的简单使用</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/\">深入 Java 调试体系: 第 1 部分，JPDA 体系概览 </a></p>"},{"layout":"post","title":"Markdown","date":"2016-03-03T14:10:55.000Z","_content":"\n>[Markdown][markdown-com] 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。\n\n# 常用语法\n \n makedown 语法  \n\n---\n\n## 代码\n\n\\`\\`\\`\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\\`\\`\\`\n\nUse the \\`printf()` function.\n\n---\n\n<!-- more -->\n## 标题\n\n\\# 标题1\n\n\\## 标题2\n\n\\### 标题3\n\n\\#### 标题4\n\n\\##### 标题5\n\n\\###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n\n2. 有序列表2\n\n\n\\- 无序列表1\n\n\\- 无序列表2\n\n\\* 无序列表3\n\n\\+ 无序列表4\n\n---\n\n## 链接\n\n\\[谷歌](http://www.google.com)\n\n这是一个 \\[例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 \\[例子] \\[id] 参考链接.\n\n\\[id]: http://google.com/ \"google\"\n\n\n自动链接\n\n```\n<http://example.com/>\n```\n\n---\n\n## 图片\n\n行内链接：\n\\!\\[](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n\\!\\[img]\n\n\\[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n```\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n```\n---\n\n## 引用\n\n\\> 引用\n\n\\>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n\\*这里是斜体\\*\n\n\\*\\*这里是粗体\\*\\*\n\n\\*\\*\\*这里是粗斜体\\*\\*\\*\n\n---\n\n## 表格\n\ndog \\| bird \\| cat\n\n----\\|------\\|----\n\nfoo \\| foo  \\| foo\n\nbar \\| bar  \\| bar\n\nbaz \\| baz  \\| baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\\\   反斜线\n  \n   \\\\`   反引号\n   \n   \\\\*   星号\n   \n   \\\\_   底线\n   \n   \\\\{}  花括号\n   \n   \\\\[]  方括号\n   \n   \\\\()  括弧\n   \n   \\\\#   井字号\n   \n   \\\\+   加号\n   \n   \\\\-   减号\n   \n   \\\\.   英文句点\n   \n   \\\\!   惊叹号\n\n---\n\n## 删除线\n\n\\~~删除这里的内容~~\n\n---\n\n\n\n\n# 效果\n\nmakedown 语法  \n---\n\n## 代码\n\n```\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\n```\n\nUse the `printf()` function.\n\n---\n\n\n## 标题\n\n# 标题1\n\n## 标题2\n\n### 标题3\n\n#### 标题4\n\n##### 标题5\n\n###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n2. 有序列表2\n\n\n- 无序列表1\n- 无序列表2\n* 无序列表3\n+ 无序列表4\n\n---\n\n## 链接\n\n[谷歌](http://www.google.com)\n\n这是一个 [例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 [例子] [id] 参考链接.\n[id]: http://google.com/  \"google\"\n\n\n自动链接\n<http://example.com/>\n\n---\n\n## 图片\n\n行内链接：\n![](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n![img]\n\n[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n\n---\n\n## 引用\n\n> 引用\n\n>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n*这里是斜体*\n\n**这里是粗体**\n\n***这里是粗斜体***\n\n---\n\n## 表格\n\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\   反斜线\n  \n   \\`   反引号\n   \n   \\*   星号\n   \n   \\_   底线\n   \n   \\{}  花括号\n   \n   \\[]  方括号\n   \n   \\()  括弧\n   \n   \\#   井字号\n   \n   \\+   加号\n   \n   \\-   减号\n   \n   \\.   英文句点\n   \n   \\!   惊叹号\n\n---\n\n## 删除线\n\n~~删除这里的内容~~\n\n---\n\n## 一些参考\n\n[Markdown 语法说明 (简体中文版)](http://www.markdown.cn/)\n\n[Markdown 维基百科 ](https://zh.wikipedia.org/wiki/Markdown)\n\n---\n\n[markdown-com]:      http://wowubuntu.com/markdown/\n","source":"_posts/markdown.md","raw":"---\nlayout: post\ntitle:  \"Markdown\"\ndate:   2016-03-03 22:10:55\ncategories: 工具\ntags: \n- markdown\n---\n\n>[Markdown][markdown-com] 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。\n\n# 常用语法\n \n makedown 语法  \n\n---\n\n## 代码\n\n\\`\\`\\`\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\\`\\`\\`\n\nUse the \\`printf()` function.\n\n---\n\n<!-- more -->\n## 标题\n\n\\# 标题1\n\n\\## 标题2\n\n\\### 标题3\n\n\\#### 标题4\n\n\\##### 标题5\n\n\\###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n\n2. 有序列表2\n\n\n\\- 无序列表1\n\n\\- 无序列表2\n\n\\* 无序列表3\n\n\\+ 无序列表4\n\n---\n\n## 链接\n\n\\[谷歌](http://www.google.com)\n\n这是一个 \\[例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 \\[例子] \\[id] 参考链接.\n\n\\[id]: http://google.com/ \"google\"\n\n\n自动链接\n\n```\n<http://example.com/>\n```\n\n---\n\n## 图片\n\n行内链接：\n\\!\\[](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n\\!\\[img]\n\n\\[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n```\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n```\n---\n\n## 引用\n\n\\> 引用\n\n\\>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n\\*这里是斜体\\*\n\n\\*\\*这里是粗体\\*\\*\n\n\\*\\*\\*这里是粗斜体\\*\\*\\*\n\n---\n\n## 表格\n\ndog \\| bird \\| cat\n\n----\\|------\\|----\n\nfoo \\| foo  \\| foo\n\nbar \\| bar  \\| bar\n\nbaz \\| baz  \\| baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\\\   反斜线\n  \n   \\\\`   反引号\n   \n   \\\\*   星号\n   \n   \\\\_   底线\n   \n   \\\\{}  花括号\n   \n   \\\\[]  方括号\n   \n   \\\\()  括弧\n   \n   \\\\#   井字号\n   \n   \\\\+   加号\n   \n   \\\\-   减号\n   \n   \\\\.   英文句点\n   \n   \\\\!   惊叹号\n\n---\n\n## 删除线\n\n\\~~删除这里的内容~~\n\n---\n\n\n\n\n# 效果\n\nmakedown 语法  \n---\n\n## 代码\n\n```\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\n```\n\nUse the `printf()` function.\n\n---\n\n\n## 标题\n\n# 标题1\n\n## 标题2\n\n### 标题3\n\n#### 标题4\n\n##### 标题5\n\n###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n2. 有序列表2\n\n\n- 无序列表1\n- 无序列表2\n* 无序列表3\n+ 无序列表4\n\n---\n\n## 链接\n\n[谷歌](http://www.google.com)\n\n这是一个 [例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 [例子] [id] 参考链接.\n[id]: http://google.com/  \"google\"\n\n\n自动链接\n<http://example.com/>\n\n---\n\n## 图片\n\n行内链接：\n![](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n![img]\n\n[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n\n---\n\n## 引用\n\n> 引用\n\n>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n*这里是斜体*\n\n**这里是粗体**\n\n***这里是粗斜体***\n\n---\n\n## 表格\n\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\   反斜线\n  \n   \\`   反引号\n   \n   \\*   星号\n   \n   \\_   底线\n   \n   \\{}  花括号\n   \n   \\[]  方括号\n   \n   \\()  括弧\n   \n   \\#   井字号\n   \n   \\+   加号\n   \n   \\-   减号\n   \n   \\.   英文句点\n   \n   \\!   惊叹号\n\n---\n\n## 删除线\n\n~~删除这里的内容~~\n\n---\n\n## 一些参考\n\n[Markdown 语法说明 (简体中文版)](http://www.markdown.cn/)\n\n[Markdown 维基百科 ](https://zh.wikipedia.org/wiki/Markdown)\n\n---\n\n[markdown-com]:      http://wowubuntu.com/markdown/\n","slug":"markdown","published":1,"updated":"2017-04-11T13:08:38.847Z","comments":1,"photos":[],"link":"","_id":"cj4vch4fj0036x3gcgmhx1dj7","content":"<blockquote>\n<p><a href=\"http://wowubuntu.com/markdown/\" target=\"_blank\" rel=\"external\">Markdown</a> 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>\n</blockquote>\n<p> 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。</p>\n<h1 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h1><p> makedown 语法  </p>\n<hr>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>```<br>public void main(String args[]){<br>    System.out.print(“Hello World”);<br>}<br>```</p>\n<p>Use the `printf()` function.</p>\n<hr>\n<a id=\"more\"></a>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p># 标题1</p>\n<p>## 标题2</p>\n<p>### 标题3</p>\n<p>#### 标题4</p>\n<p>##### 标题5</p>\n<p>###### 标题6</p>\n<hr>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li><p>有序列表1</p>\n</li>\n<li><p>有序列表2</p>\n</li>\n</ol>\n<p>- 无序列表1</p>\n<p>- 无序列表2</p>\n<p>* 无序列表3</p>\n<p>+ 无序列表4</p>\n<hr>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>[谷歌](<a href=\"http://www.google.com\" target=\"_blank\" rel=\"external\">http://www.google.com</a>)</p>\n<p>这是一个 [例子](<a href=\"http://google.com/\" target=\"_blank\" rel=\"external\">http://google.com/</a> “google”) 行内链接.</p>\n<p>这是一个 [例子] [id] 参考链接.</p>\n<p>[id]: <a href=\"http://google.com/\" target=\"_blank\" rel=\"external\">http://google.com/</a> “google”</p>\n<p>自动链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;http://example.com/&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br>![](<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" target=\"_blank\" rel=\"external\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a>)</p>\n<p>参考链接：<br>![img]</p>\n<p>[img]:<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" target=\"_blank\" rel=\"external\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a></p>\n<p>指定宽高：需用html标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;img src=&quot;http://img3.3lian.com/2013/s1/65/d/104.jpg&quot; width=&quot;200&quot; height=&quot;128&quot;  /&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>> 引用</p>\n<p>>&gt; 嵌套引用</p>\n<hr>\n<h2 id=\"粗体-斜体\"><a href=\"#粗体-斜体\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p>*这里是斜体*</p>\n<p>**这里是粗体**</p>\n<p>***这里是粗斜体***</p>\n<hr>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>dog | bird | cat</p>\n<p>—-|——|—-</p>\n<p>foo | foo  | foo</p>\n<p>bar | bar  | bar</p>\n<p>baz | baz  | baz</p>\n<hr>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\\\   反斜线</p>\n<p>   \\`   反引号</p>\n<p>   \\*   星号</p>\n<p>   \\_   底线</p>\n<p>   \\{}  花括号</p>\n<p>   \\[]  方括号</p>\n<p>   \\()  括弧</p>\n<p>   \\#   井字号</p>\n<p>   \\+   加号</p>\n<p>   \\-   减号</p>\n<p>   \\.   英文句点</p>\n<p>   \\!   惊叹号</p>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>~~删除这里的内容~~</p>\n<hr>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><h2 id=\"makedown-语法\"><a href=\"#makedown-语法\" class=\"headerlink\" title=\"makedown 语法  \"></a>makedown 语法  </h2><h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void main(String args[])&#123;</div><div class=\"line\">    System.out.print(&quot;Hello World&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Use the <code>printf()</code> function.</p>\n<hr>\n<h2 id=\"标题-1\"><a href=\"#标题-1\" class=\"headerlink\" title=\"标题\"></a>标题</h2><h1 id=\"标题1\"><a href=\"#标题1\" class=\"headerlink\" title=\"标题1\"></a>标题1</h1><h2 id=\"标题2\"><a href=\"#标题2\" class=\"headerlink\" title=\"标题2\"></a>标题2</h2><h3 id=\"标题3\"><a href=\"#标题3\" class=\"headerlink\" title=\"标题3\"></a>标题3</h3><h4 id=\"标题4\"><a href=\"#标题4\" class=\"headerlink\" title=\"标题4\"></a>标题4</h4><h5 id=\"标题5\"><a href=\"#标题5\" class=\"headerlink\" title=\"标题5\"></a>标题5</h5><h6 id=\"标题6\"><a href=\"#标题6\" class=\"headerlink\" title=\"标题6\"></a>标题6</h6><hr>\n<h2 id=\"列表-1\"><a href=\"#列表-1\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n</ul>\n<ul>\n<li>无序列表3</li>\n</ul>\n<ul>\n<li>无序列表4</li>\n</ul>\n<hr>\n<h2 id=\"链接-1\"><a href=\"#链接-1\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://www.google.com\" target=\"_blank\" rel=\"external\">谷歌</a></p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\" target=\"_blank\" rel=\"external\">例子</a> 行内链接.</p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\" target=\"_blank\" rel=\"external\">例子</a> 参考链接.</p>\n<p>自动链接<br><a href=\"http://example.com/\" target=\"_blank\" rel=\"external\">http://example.com/</a></p>\n<hr>\n<h2 id=\"图片-1\"><a href=\"#图片-1\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"\"></p>\n<p>参考链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"img\"></p>\n<p>指定宽高：需用html标记</p>\n<p><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\">  </p>\n<hr>\n<h2 id=\"引用-1\"><a href=\"#引用-1\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>引用</p>\n<blockquote>\n<p>嵌套引用</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"粗体-斜体-1\"><a href=\"#粗体-斜体-1\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p><em>这里是斜体</em></p>\n<p><strong>这里是粗体</strong></p>\n<p><strong><em>这里是粗斜体</em></strong></p>\n<hr>\n<h2 id=\"表格-1\"><a href=\"#表格-1\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th>dog</th>\n<th>bird</th>\n<th>cat</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>foo</td>\n<td>foo</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>bar</td>\n<td>bar</td>\n</tr>\n<tr>\n<td>baz</td>\n<td>baz</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"转义-1\"><a href=\"#转义-1\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\   反斜线</p>\n<p>   `   反引号</p>\n<p>   *   星号</p>\n<p>   _   底线</p>\n<p>   {}  花括号</p>\n<p>   []  方括号</p>\n<p>   ()  括弧</p>\n<p>   #   井字号</p>\n<p>   +   加号</p>\n<p>   -   减号</p>\n<p>   .   英文句点</p>\n<p>   !   惊叹号</p>\n<hr>\n<h2 id=\"删除线-1\"><a href=\"#删除线-1\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p><del>删除这里的内容</del></p>\n<hr>\n<h2 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h2><p><a href=\"http://www.markdown.cn/\" target=\"_blank\" rel=\"external\">Markdown 语法说明 (简体中文版)</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"external\">Markdown 维基百科 </a></p>\n<hr>\n","excerpt":"<blockquote>\n<p><a href=\"http://wowubuntu.com/markdown/\">Markdown</a> 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>\n</blockquote>\n<p> 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。</p>\n<h1 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h1><p> makedown 语法  </p>\n<hr>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>```<br>public void main(String args[]){<br>    System.out.print(“Hello World”);<br>}<br>```</p>\n<p>Use the `printf()` function.</p>\n<hr>","more":"<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p># 标题1</p>\n<p>## 标题2</p>\n<p>### 标题3</p>\n<p>#### 标题4</p>\n<p>##### 标题5</p>\n<p>###### 标题6</p>\n<hr>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li><p>有序列表1</p>\n</li>\n<li><p>有序列表2</p>\n</li>\n</ol>\n<p>- 无序列表1</p>\n<p>- 无序列表2</p>\n<p>* 无序列表3</p>\n<p>+ 无序列表4</p>\n<hr>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>[谷歌](<a href=\"http://www.google.com\">http://www.google.com</a>)</p>\n<p>这是一个 [例子](<a href=\"http://google.com/\">http://google.com/</a> “google”) 行内链接.</p>\n<p>这是一个 [例子] [id] 参考链接.</p>\n<p>[id]: <a href=\"http://google.com/\">http://google.com/</a> “google”</p>\n<p>自动链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;http://example.com/&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br>![](<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a>)</p>\n<p>参考链接：<br>![img]</p>\n<p>[img]:<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a></p>\n<p>指定宽高：需用html标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;img src=&quot;http://img3.3lian.com/2013/s1/65/d/104.jpg&quot; width=&quot;200&quot; height=&quot;128&quot;  /&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>> 引用</p>\n<p>>&gt; 嵌套引用</p>\n<hr>\n<h2 id=\"粗体-斜体\"><a href=\"#粗体-斜体\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p>*这里是斜体*</p>\n<p>**这里是粗体**</p>\n<p>***这里是粗斜体***</p>\n<hr>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>dog | bird | cat</p>\n<p>—-|——|—-</p>\n<p>foo | foo  | foo</p>\n<p>bar | bar  | bar</p>\n<p>baz | baz  | baz</p>\n<hr>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\\\   反斜线</p>\n<p>   \\`   反引号</p>\n<p>   \\*   星号</p>\n<p>   \\_   底线</p>\n<p>   \\{}  花括号</p>\n<p>   \\[]  方括号</p>\n<p>   \\()  括弧</p>\n<p>   \\#   井字号</p>\n<p>   \\+   加号</p>\n<p>   \\-   减号</p>\n<p>   \\.   英文句点</p>\n<p>   \\!   惊叹号</p>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>~~删除这里的内容~~</p>\n<hr>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><h2 id=\"makedown-语法\"><a href=\"#makedown-语法\" class=\"headerlink\" title=\"makedown 语法  \"></a>makedown 语法  </h2><h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void main(String args[])&#123;</div><div class=\"line\">    System.out.print(&quot;Hello World&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Use the <code>printf()</code> function.</p>\n<hr>\n<h2 id=\"标题-1\"><a href=\"#标题-1\" class=\"headerlink\" title=\"标题\"></a>标题</h2><h1 id=\"标题1\"><a href=\"#标题1\" class=\"headerlink\" title=\"标题1\"></a>标题1</h1><h2 id=\"标题2\"><a href=\"#标题2\" class=\"headerlink\" title=\"标题2\"></a>标题2</h2><h3 id=\"标题3\"><a href=\"#标题3\" class=\"headerlink\" title=\"标题3\"></a>标题3</h3><h4 id=\"标题4\"><a href=\"#标题4\" class=\"headerlink\" title=\"标题4\"></a>标题4</h4><h5 id=\"标题5\"><a href=\"#标题5\" class=\"headerlink\" title=\"标题5\"></a>标题5</h5><h6 id=\"标题6\"><a href=\"#标题6\" class=\"headerlink\" title=\"标题6\"></a>标题6</h6><hr>\n<h2 id=\"列表-1\"><a href=\"#列表-1\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n</ul>\n<ul>\n<li>无序列表3</li>\n</ul>\n<ul>\n<li>无序列表4</li>\n</ul>\n<hr>\n<h2 id=\"链接-1\"><a href=\"#链接-1\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://www.google.com\">谷歌</a></p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\">例子</a> 行内链接.</p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\">例子</a> 参考链接.</p>\n<p>自动链接<br><a href=\"http://example.com/\">http://example.com/</a></p>\n<hr>\n<h2 id=\"图片-1\"><a href=\"#图片-1\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"\"></p>\n<p>参考链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"img\"></p>\n<p>指定宽高：需用html标记</p>\n<p><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  </p>\n<hr>\n<h2 id=\"引用-1\"><a href=\"#引用-1\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>引用</p>\n<blockquote>\n<p>嵌套引用</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"粗体-斜体-1\"><a href=\"#粗体-斜体-1\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p><em>这里是斜体</em></p>\n<p><strong>这里是粗体</strong></p>\n<p><strong><em>这里是粗斜体</em></strong></p>\n<hr>\n<h2 id=\"表格-1\"><a href=\"#表格-1\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th>dog</th>\n<th>bird</th>\n<th>cat</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>foo</td>\n<td>foo</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>bar</td>\n<td>bar</td>\n</tr>\n<tr>\n<td>baz</td>\n<td>baz</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"转义-1\"><a href=\"#转义-1\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\   反斜线</p>\n<p>   `   反引号</p>\n<p>   *   星号</p>\n<p>   _   底线</p>\n<p>   {}  花括号</p>\n<p>   []  方括号</p>\n<p>   ()  括弧</p>\n<p>   #   井字号</p>\n<p>   +   加号</p>\n<p>   -   减号</p>\n<p>   .   英文句点</p>\n<p>   !   惊叹号</p>\n<hr>\n<h2 id=\"删除线-1\"><a href=\"#删除线-1\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p><del>删除这里的内容</del></p>\n<hr>\n<h2 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h2><p><a href=\"http://www.markdown.cn/\">Markdown 语法说明 (简体中文版)</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\">Markdown 维基百科 </a></p>\n<hr>"},{"layout":"post","title":"notify 问题","date":"2015-12-21T04:48:55.000Z","_content":"\n今天遇到了这么个情况：\n有线程若干，我需要他们按顺序执行。\n代码大概长这样：\n\n```\nclass SyncTag {\n\tpublic int threadNO;\n\tpublic SyncTag() {\n\t    threadNO = 0;\n\t}\n}\nclass ThreadA extend Thread{\n\tSyncTag syncTag;\n\tint scriptNO;\n\tThreadA(SyncTag syncTag,int scriptNO){\n\t\t\tthis.syncTag=syncTag;\n\t\t\tthis.scriptNO=scriptNO;\n\t}\n\tpublic void Run(){\n\t\t\tsynchronized (syncTag) {\n                if (syncTag.threadNO != scriptNO) {\n                        try {\n                                syncTag.wait();\n                        } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                        }\n                }\n                dosomething();\n                syncTag.threadNO++;\n                syncTag.notifyAll();\n\t\t\t}\n\t}\n}\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t    SyncTag syncTag=new SyncTag();\n\t\t\tfor(int i=0;i<10;++i){\n\t\t\t\tThreadA t=new ThreadA(syncTag,i);\n\t\t\t\tt.start();\n\t\t\t}\n\t}\n}\n```\n<!-- more -->\n结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。\n研究一番，发现是 notify 与notifyAll 在捣鬼。\n当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。\n其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。\n\t\t \n当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，\n剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，\n没抢到的老实等着。\n\t\t \n这就是notify 与 notifyAll两者的区别.\n\t\t \n那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。\n原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合\nsyncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，\n如果不符合，就继续wait.符合则执行。\n很简单，将 \n\n```java\nif (syncTag.threadNO != scriptNO) {\n        try {\n                syncTag.wait();\n            } catch (InterruptedException e) {\n                                    e.printStackTrace();\n            }\n}\n```\n\n这部分代码 改为： \n\n```java\nwhile (syncTag.threadNO != scriptNO) {\n\t\ttry {\n\t\t\t\tsyncTag.wait();\n\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n这个问题就解决了。\n\n所以，应该记住这样一个原则：**永远在循环（loop）里调用 wait 和 notify，不是在 If 语句**。\n\t \n## **延伸**：\n假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：\n设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO\n这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们\n中的一个。于是陷入死锁，无尽的等待。\n\t\t \n所以，具体使用notify还是notifyAll 就得具体情况具体分析了。","source":"_posts/notify问题.md","raw":"---\nlayout: post\ntitle:  \"notify 问题\"\ndate:   2015-12-21 12:48:55\ncategories: 编程\ntags:\n- java\n- 多线程 \n---\n\n今天遇到了这么个情况：\n有线程若干，我需要他们按顺序执行。\n代码大概长这样：\n\n```\nclass SyncTag {\n\tpublic int threadNO;\n\tpublic SyncTag() {\n\t    threadNO = 0;\n\t}\n}\nclass ThreadA extend Thread{\n\tSyncTag syncTag;\n\tint scriptNO;\n\tThreadA(SyncTag syncTag,int scriptNO){\n\t\t\tthis.syncTag=syncTag;\n\t\t\tthis.scriptNO=scriptNO;\n\t}\n\tpublic void Run(){\n\t\t\tsynchronized (syncTag) {\n                if (syncTag.threadNO != scriptNO) {\n                        try {\n                                syncTag.wait();\n                        } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                        }\n                }\n                dosomething();\n                syncTag.threadNO++;\n                syncTag.notifyAll();\n\t\t\t}\n\t}\n}\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t    SyncTag syncTag=new SyncTag();\n\t\t\tfor(int i=0;i<10;++i){\n\t\t\t\tThreadA t=new ThreadA(syncTag,i);\n\t\t\t\tt.start();\n\t\t\t}\n\t}\n}\n```\n<!-- more -->\n结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。\n研究一番，发现是 notify 与notifyAll 在捣鬼。\n当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。\n其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。\n\t\t \n当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，\n剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，\n没抢到的老实等着。\n\t\t \n这就是notify 与 notifyAll两者的区别.\n\t\t \n那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。\n原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合\nsyncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，\n如果不符合，就继续wait.符合则执行。\n很简单，将 \n\n```java\nif (syncTag.threadNO != scriptNO) {\n        try {\n                syncTag.wait();\n            } catch (InterruptedException e) {\n                                    e.printStackTrace();\n            }\n}\n```\n\n这部分代码 改为： \n\n```java\nwhile (syncTag.threadNO != scriptNO) {\n\t\ttry {\n\t\t\t\tsyncTag.wait();\n\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n这个问题就解决了。\n\n所以，应该记住这样一个原则：**永远在循环（loop）里调用 wait 和 notify，不是在 If 语句**。\n\t \n## **延伸**：\n假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：\n设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO\n这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们\n中的一个。于是陷入死锁，无尽的等待。\n\t\t \n所以，具体使用notify还是notifyAll 就得具体情况具体分析了。","slug":"notify问题","published":1,"updated":"2017-04-11T13:08:38.847Z","comments":1,"photos":[],"link":"","_id":"cj4vch4fq003ax3gch59ndxyn","content":"<p>今天遇到了这么个情况：<br>有线程若干，我需要他们按顺序执行。<br>代码大概长这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SyncTag &#123;</div><div class=\"line\">\tpublic int threadNO;</div><div class=\"line\">\tpublic SyncTag() &#123;</div><div class=\"line\">\t    threadNO = 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class ThreadA extend Thread&#123;</div><div class=\"line\">\tSyncTag syncTag;</div><div class=\"line\">\tint scriptNO;</div><div class=\"line\">\tThreadA(SyncTag syncTag,int scriptNO)&#123;</div><div class=\"line\">\t\t\tthis.syncTag=syncTag;</div><div class=\"line\">\t\t\tthis.scriptNO=scriptNO;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void Run()&#123;</div><div class=\"line\">\t\t\tsynchronized (syncTag) &#123;</div><div class=\"line\">                if (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">                        try &#123;</div><div class=\"line\">                                syncTag.wait();</div><div class=\"line\">                        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                dosomething();</div><div class=\"line\">                syncTag.threadNO++;</div><div class=\"line\">                syncTag.notifyAll();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">public class Test&#123;</div><div class=\"line\">\tpublic static void main(String args[])&#123;</div><div class=\"line\">\t\t    SyncTag syncTag=new SyncTag();</div><div class=\"line\">\t\t\tfor(int i=0;i&lt;10;++i)&#123;</div><div class=\"line\">\t\t\t\tThreadA t=new ThreadA(syncTag,i);</div><div class=\"line\">\t\t\t\tt.start();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。<br>研究一番，发现是 notify 与notifyAll 在捣鬼。<br>当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。<br>其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。</p>\n<p>当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，<br>剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，<br>没抢到的老实等着。</p>\n<p>这就是notify 与 notifyAll两者的区别.</p>\n<p>那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。<br>原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合<br>syncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，<br>如果不符合，就继续wait.符合则执行。<br>很简单，将 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                syncTag.wait();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这部分代码 改为： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tsyncTag.wait();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个问题就解决了。</p>\n<p>所以，应该记住这样一个原则：<strong>永远在循环（loop）里调用 wait 和 notify，不是在 If 语句</strong>。</p>\n<h2 id=\"延伸：\"><a href=\"#延伸：\" class=\"headerlink\" title=\"延伸：\"></a><strong>延伸</strong>：</h2><p>假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：<br>设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO<br>这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们<br>中的一个。于是陷入死锁，无尽的等待。</p>\n<p>所以，具体使用notify还是notifyAll 就得具体情况具体分析了。</p>\n","excerpt":"<p>今天遇到了这么个情况：<br>有线程若干，我需要他们按顺序执行。<br>代码大概长这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SyncTag &#123;</div><div class=\"line\">\tpublic int threadNO;</div><div class=\"line\">\tpublic SyncTag() &#123;</div><div class=\"line\">\t    threadNO = 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class ThreadA extend Thread&#123;</div><div class=\"line\">\tSyncTag syncTag;</div><div class=\"line\">\tint scriptNO;</div><div class=\"line\">\tThreadA(SyncTag syncTag,int scriptNO)&#123;</div><div class=\"line\">\t\t\tthis.syncTag=syncTag;</div><div class=\"line\">\t\t\tthis.scriptNO=scriptNO;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void Run()&#123;</div><div class=\"line\">\t\t\tsynchronized (syncTag) &#123;</div><div class=\"line\">                if (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">                        try &#123;</div><div class=\"line\">                                syncTag.wait();</div><div class=\"line\">                        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                dosomething();</div><div class=\"line\">                syncTag.threadNO++;</div><div class=\"line\">                syncTag.notifyAll();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">public class Test&#123;</div><div class=\"line\">\tpublic static void main(String args[])&#123;</div><div class=\"line\">\t\t    SyncTag syncTag=new SyncTag();</div><div class=\"line\">\t\t\tfor(int i=0;i&lt;10;++i)&#123;</div><div class=\"line\">\t\t\t\tThreadA t=new ThreadA(syncTag,i);</div><div class=\"line\">\t\t\t\tt.start();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。<br>研究一番，发现是 notify 与notifyAll 在捣鬼。<br>当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。<br>其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。</p>\n<p>当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，<br>剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，<br>没抢到的老实等着。</p>\n<p>这就是notify 与 notifyAll两者的区别.</p>\n<p>那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。<br>原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合<br>syncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，<br>如果不符合，就继续wait.符合则执行。<br>很简单，将 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                syncTag.wait();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这部分代码 改为： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tsyncTag.wait();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个问题就解决了。</p>\n<p>所以，应该记住这样一个原则：<strong>永远在循环（loop）里调用 wait 和 notify，不是在 If 语句</strong>。</p>\n<h2 id=\"延伸：\"><a href=\"#延伸：\" class=\"headerlink\" title=\"延伸：\"></a><strong>延伸</strong>：</h2><p>假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：<br>设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO<br>这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们<br>中的一个。于是陷入死锁，无尽的等待。</p>\n<p>所以，具体使用notify还是notifyAll 就得具体情况具体分析了。</p>"},{"layout":"post","date":"2016-03-30T04:48:55.000Z","title":"sphinx安装问题","_content":"\n>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python\n 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。\n\n>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是\n Python2，Python3与Python2是不兼容的，在编码问题上报错。\n\n>遂改之，卸载Python3，安装Python2.问题来了。\n\n安装完Python2之后，使用 easy_install sphinx \n指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：\n\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 4-5: ordi al not in range(128)\n\n意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内\n，就会抛出异常（ordinal not in range(128)）。\n\n看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆\n.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。\n\n后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。\n\n首先所有修改的动作都是要创建一个叫 **sitecustomize.py**的文件，为什么要创建这个文件呢，是因为python在启动的时候会\n去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。\n\n修改默认字符编码的代码很简单就2行：\n\n```\n\n# sitecustomize.py                   # this file can be anywhere in your Python path,\n# but it usually goes in ${pythondir}/lib/site-packages/\nimport sys\nsys.setdefaultencoding('utf-8') \n\n```\n\n<!-- more -->\n\n写完这个文件放哪里呢？\n\nwindows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 \n\nok,现在再次运行 easy_install sphinx ，可以通过安装了！\n\nps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。\n\n**参考**\n\n[解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误](http://wangye.org/blog/archives/629/)\n\n[永久修改python默认的字符编码为utf-8](http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html)       \n","source":"_posts/sphinx安装问题.md","raw":"---\nlayout: post\ndate:   2016-03-30 12:48:55\ntitle: \"sphinx安装问题\"\ncategories: 工具\ntags: \n- python\n- 编码\n---\n\n>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python\n 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。\n\n>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是\n Python2，Python3与Python2是不兼容的，在编码问题上报错。\n\n>遂改之，卸载Python3，安装Python2.问题来了。\n\n安装完Python2之后，使用 easy_install sphinx \n指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：\n\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 4-5: ordi al not in range(128)\n\n意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内\n，就会抛出异常（ordinal not in range(128)）。\n\n看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆\n.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。\n\n后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。\n\n首先所有修改的动作都是要创建一个叫 **sitecustomize.py**的文件，为什么要创建这个文件呢，是因为python在启动的时候会\n去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。\n\n修改默认字符编码的代码很简单就2行：\n\n```\n\n# sitecustomize.py                   # this file can be anywhere in your Python path,\n# but it usually goes in ${pythondir}/lib/site-packages/\nimport sys\nsys.setdefaultencoding('utf-8') \n\n```\n\n<!-- more -->\n\n写完这个文件放哪里呢？\n\nwindows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 \n\nok,现在再次运行 easy_install sphinx ，可以通过安装了！\n\nps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。\n\n**参考**\n\n[解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误](http://wangye.org/blog/archives/629/)\n\n[永久修改python默认的字符编码为utf-8](http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html)       \n","slug":"sphinx安装问题","published":1,"updated":"2017-04-11T13:08:38.847Z","comments":1,"photos":[],"link":"","_id":"cj4vch4fr003dx3gceyflusit","content":"<blockquote>\n<p>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python<br> 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。</p>\n<p>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是<br> Python2，Python3与Python2是不兼容的，在编码问题上报错。</p>\n<p>遂改之，卸载Python3，安装Python2.问题来了。</p>\n</blockquote>\n<p>安装完Python2之后，使用 easy_install sphinx<br>指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：</p>\n<p>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 4-5: ordi al not in range(128)</p>\n<p>意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内<br>，就会抛出异常（ordinal not in range(128)）。</p>\n<p>看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆<br>.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。</p>\n<p>后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。</p>\n<p>首先所有修改的动作都是要创建一个叫 <strong>sitecustomize.py</strong>的文件，为什么要创建这个文件呢，是因为python在启动的时候会<br>去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。</p>\n<p>修改默认字符编码的代码很简单就2行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># sitecustomize.py                   # this file can be anywhere in your Python path,</div><div class=\"line\"># but it usually goes in $&#123;pythondir&#125;/lib/site-packages/</div><div class=\"line\">import sys</div><div class=\"line\">sys.setdefaultencoding(&apos;utf-8&apos;)</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>写完这个文件放哪里呢？</p>\n<p>windows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 </p>\n<p>ok,现在再次运行 easy_install sphinx ，可以通过安装了！</p>\n<p>ps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"http://wangye.org/blog/archives/629/\" target=\"_blank\" rel=\"external\">解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html\" target=\"_blank\" rel=\"external\">永久修改python默认的字符编码为utf-8</a>       </p>\n","excerpt":"<blockquote>\n<p>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python<br> 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。</p>\n<p>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是<br> Python2，Python3与Python2是不兼容的，在编码问题上报错。</p>\n<p>遂改之，卸载Python3，安装Python2.问题来了。</p>\n</blockquote>\n<p>安装完Python2之后，使用 easy_install sphinx<br>指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：</p>\n<p>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 4-5: ordi al not in range(128)</p>\n<p>意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内<br>，就会抛出异常（ordinal not in range(128)）。</p>\n<p>看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆<br>.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。</p>\n<p>后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。</p>\n<p>首先所有修改的动作都是要创建一个叫 <strong>sitecustomize.py</strong>的文件，为什么要创建这个文件呢，是因为python在启动的时候会<br>去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。</p>\n<p>修改默认字符编码的代码很简单就2行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># sitecustomize.py                   # this file can be anywhere in your Python path,</div><div class=\"line\"># but it usually goes in $&#123;pythondir&#125;/lib/site-packages/</div><div class=\"line\">import sys</div><div class=\"line\">sys.setdefaultencoding(&apos;utf-8&apos;)</div></pre></td></tr></table></figure>","more":"<p>写完这个文件放哪里呢？</p>\n<p>windows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 </p>\n<p>ok,现在再次运行 easy_install sphinx ，可以通过安装了！</p>\n<p>ps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"http://wangye.org/blog/archives/629/\">解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html\">永久修改python默认的字符编码为utf-8</a>       </p>"},{"layout":"post","title":"maven学习笔记(二)","date":"2017-04-19T03:58:03.000Z","_content":"\n## 依赖\n\ndependency标签可以声明以下一些元素：\n\n```xml\n<dependency>\n\t<groupId>...</groupId>\n\t<artifactId>...</artifactId>\n\t<version>...</version>\n\t<scope>...</scope>\n    <type>...</type>\n\t<optional>...</optional>\n\t<exclusions>\n\t\t <exclusion>...</exclusion>\n\t</exclusions>\n</dependency>\n```\n<!-- more -->\ngroupId、artifactId、version：声明了依赖的基本坐标\n\ntype: 依赖的类型，对应于项目坐标定义中的packaging，比如说jar\n\nscope：依赖的范围\n\noptional：是否是可选依赖\n\nexclusions: 排除传递性依赖\n\n- 依赖范围(scope)\n\n  Maven有三套classpath，编译项目主代码、编译测试代码、实际运行。依赖范围就是用来控制依赖与这三种classpath的关系.有以下几个选项：\n\n  依赖范围 | 对主代码classpath有效 | 对测试classpath有效 | 对运行时classpath有效\n  --------|----------------------|--------------------|----------------------\n  compile |         Y            |         Y          |           Y  \n  test    |         N            |         Y          |           N\n  provided|         Y            |         Y          |           N\n  runtime |         N            |         Y          |           Y\n  system  |         Y            |         Y          |           N\n\n- 传递性依赖\n  \n  我们在项目的pom.xml文件中声明了直接依赖，如果声明的这些依赖还依赖于其他第三方组件，在maven中，我们不用考虑这些间接依赖，也不用担心引入多余的依赖。Maven会解析各个直接依赖的pom，将那些必要的间接依赖以传递性依赖的方式引入到当前项目的classpath中。\n\n  依赖范围不仅能够控制依赖与三种classpath的关系，还会对传递性依赖产生影响。比如设A依赖于B，B依赖于C，A对于B是第一直接依赖，B对于C是第二直接依赖，A对与C是传递性依赖。第一直接依赖与第二直接依赖的依赖范围决定了传递性依赖的依赖范围。如下图，最左边第一列表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间交叉单元格表示传递性依赖范围\n\n          | compile | test | provided | runtime\n  --------|---------|------|----------|-----------\n  compile | compile |      |          | runtime \n  test    | test    |      |          | test \n  provided| provided|      | provided | provided \n  runtime | runtime |      |          | runtime \n\n  比如，account-email 项目有一个com.icegree:greemail:1.3.1b的直接依赖，这是第一直接依赖，其依赖范围是test；而greemail又有一个javax.mail:mail:1.4的直接依赖，这是第二直接依赖，其依赖的范围是compile。根据上面的表格可以推断，javax.mail:mail:1.4是account-email的一个范围是test的传递依赖。\n\n- 依赖调解\n\n  对于一个构件，存在于不同依赖路径上。选择哪个路径上的构件就是依赖调解要解决的问题，有两种策略：\n\n  1. 路径近者优先。 比如，项目A有这样的依赖关系：A->B->C->x(1.0)、A->D->X(2.0)，对于两个版本的X，如果都引入就会造成依赖重复。根据路径近者优先的策略，X(2.0)会被引入；\n\n  2. 第一声明者优先。 路径近者优先的策略不能解决所有问题，如果出现路径长度相同的情况，那么maven就会选择依赖声明在前的那个路径上的版本。\n\n- 可选依赖(optional)\n  \n  假设有这样的依赖关系：项目A依赖于项目B，项目B依赖于项目X，Y，B对于X和Y都是可选依赖：A-B、B->X(可选)、B->Y(可选)。那么此时，由于X、Y都是可选依赖，依赖性将不会传递，也就是说，A中不会引入X和Y。\n\n  有这样一种情况符合可选依赖的场景：项目B是一个持久层的工具包，支持多种数据库，X、Y就是其依赖的数据库驱动程序，但是我们的项目A在使用这个工具包B的时候，只依赖一种数据库，故我们不需要将X和Y全部引入。这种情况下需要我们在项目A中声明实际使用的数据库驱动依赖。\n\n- 排除依赖(exclusions)\n \n  传递性依赖为我们的项目隐式的引入了很多依赖，如果我们不想引入某个传递性依赖(自己选择依赖版本)，就可以使用排除依赖。\n\n  ```xml\n  <dependency>\n\t\t<groupId>org.slf4j</groupId>\n\t\t<artifactId>slf4j-api</artifactId>\n\t\t<version>1.7.7</version>\n  </dependency>\n  <dependency>\n\t\t<groupId>org.slf4j</groupId>\n\t\t<artifactId>slf4j-log4j12</artifactId>\n\t\t<version>1.7.7</version>\n\t\t<exclusions>\n\t\t\t<exclusion>\n\t\t\t    <groupId>org.slf4j</groupId>\n\t\t\t    <artifactId>slf4j-api</artifactId>\n\t\t\t</exclusion>\n\t\t</exclusions>\n  </dependency>\n  ```\n  上面的代码声明了一个排除依赖。我们的项目所依赖的slf4j-log4j12会引入slf4j-api这个传递性依赖。出于版本或者其他考虑，现在不想引入这个依赖，而是由我们显示的声明，那么就可以像上面的代码那样做。\n\n- 查看依赖\n\n  通过执行`mvn dependency:list`可以查看项目已经解析的依赖；\n  通过执行`mvn dependency:tree`可以查看项目的依赖树；\n  通过执行`mvn dependency:analyze`可以查看项目中没有使用，却显示声明的依赖和项目中显示使用了却没有显示声明的依赖。\n\n  在Eclispe中，可以双击pom.xml，在Dependencies和Dependency Hierarchy选项卡查看项目的依赖情况。\n\n## 仓库\n\n- 仓库分类\n\n  对于maven来说，仓库分为两类：本地仓库和远程仓库。本地仓库即存在于我们本地机器上的构件仓库，远程仓库就是远程机器上的构件仓库。我们的依赖(jar)都是从仓库当中下载得到的。\n\n  当maven对我们的项目执行编译或者测试时，如果需要使用依赖文件，他总是基于坐标使用本地仓库的依赖文件。如果本地仓库存在此构件，则直接使用；如果本地仓库不存在此构件，或者需要更新的版本，maven会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。如果本地仓库和远程仓库都没有需要的构件，则报错。\n\n  中央仓库是Maven核心自带的远程仓库，包含了绝大部分开源构件。默认情况下，当本地仓库没有maven需要的构件时，他就会从中央仓库下载。\n\n- 仓库配置\n\n  在linux上本地仓库的默认路径为：`~/.m2/repository/`  如果想要自定义本地仓库地址，可以编辑 `~/.m2/setting.xml`, 设置localRepository元素值为想要的地址：\n\n  ```\n  <localRepository>/path/to/local/repo</localRepository>\n  ```\n\n  某些情况下，中央仓库无法满足项目需求，项目需要的构件可能存在于另一个远程仓库上，这是，可以在pom中配置该仓库：\n\n  ```xml\n  <repositories>\n\t\t<repository>\n\t\t\t<id>JBOSS</id>\n\t\t\t<name>Jboss</name>\n\t\t\t<url>http://repository.jnoss.com/maven2</url>\n\t\t\t<releases>\n\t\t\t\t<enabled>true</enabled>\n\t\t\t</releases>\n\t\t\t<snapshots>\n\t\t\t\t<enabled>false</enabled>\n\t\t\t</snapshots>\n\t\t</repository>\n\t</repositories>\n  ```\n  上面的例子中声明了一个id为JBOSS的远程仓库，任何一个仓库声明的id都必须是唯一的。release的enable值为true，表示开启Jboss仓库发布版本的下载支持；snapshots的enable值为false，表示关闭Jboss仓库快照版本的下载支持。\n\n  可以声明多个远程仓库，maven会遍历这些仓库去查找所需的构件。\n  \n## 聚合与继承\n\n- 聚合\n\n  一个项目中往往不止一个模块，比如有core、util等等模块的划分。每个模块是一个独立的工程，提供了对外的接口供调用，各个模块之间有相互依赖的关系。那么，如果我们想要一次性构建项目中的两个两个模块，而不是到两个模块各自的目录下面执行mvn命令，这时候就需要maven的聚合。\n\n  为了能够使用一条命令就构建core和util两个模块，我们需要额外创建一个名为aggregator的模块，然后通过该模块构建整个项目的所有模块。aggregator本身作为一个maven项目，必须有自己的pom：\n\n  ```xml\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<groupId>com.test.app</groupId>\n\t<artifactId>app-aggregator</artifactId>\n\t<version>1.0-SNAPSHOT</version>\n\t<packaging>pom</packaging>\n\t<modules>\n\t\t<module>app-core</module>\n\t\t<module>app-util</module>\n\t</modules>\n  </project>\n  ```\n  对于聚合模块来说，packaging的值必须为pom，否则无法构建。用户可以通过在一个打包为pom的Maven项目中声明任意数量的module元素来实现模块的聚合。\n\n  这里每一个module的值都是一个当前pom的相对目录。比如app-aggregator的pom路径为`~/app/app-aggregator/pom.xml`，那么app-core就对应目录`~/app/app-aggregator/app-core/`,app-util就对应目录`~/app/app-aggregator/app-util/`，这两个目录各自包含pom.xml、src/main/java等内容，可以独立构建。\n\n  从聚合模块运行mvn命令，maven就会解析聚合模块的pom，分析要构建的模块，并计算出一个构建顺序，然后根据这个顺序依次构建各个模块。\n\n- 继承\n  \n  在面向对象的设计中，可以在父类中声明一些字段，由子类继承使用。类似的，pom也可以声明这样一种父子结构。\n\n  我们继续在`~/app/app-aggregator/`目录下创建一个名为app-parent的子目录，在该子目录中声明一个pom:\n\n  ```xml\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<groupId>com.test.app</groupId>\n\t<artifactId>app-parent</artifactId>\n\t<version>1.0-SNAPSHOT</version>\n\t<packaging>pom</packaging>\n\t<name>App parent</name>\n  </project>\n  ```\n  修改app-core继承app-parent\n  ```xml\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>com.test.app</groupId>\n\t\t<artifactId>app-parent</artifactId>\n\t\t<version>1.0-SNAPSHOT</version>\n\t\t<relativePath>../app-parent/pom.xml</relativePath>\n\t</parent>\n\t<artifactId>app-core</artifactId>\n\t<packaging>pom</packaging>\n\t<name>App core</name>\n  </project>\n  ```\n  上述pom中parent元素声明父模块，groupId、artifactId、version指定了父模块的坐标。relativePath指定了父模块pom的相对路径。\n\n  app-core中没有声明version和groupId，他隐式的从父模块继承了这两个元素。\n\n  下面是可继承的pom元素：\n\n  ```\n  groupId ：项目组 ID ，项目坐标的核心元素；  \n  version ：项目版本，项目坐标的核心元素；  \n  description ：项目的描述信息；  \n  organization ：项目的组织信息；  \n  inceptionYear ：项目的创始年份；  \n  url ：项目的 url 地址  \n  develoers ：项目的开发者信息；  \n  contributors ：项目的贡献者信息；  \n  distributionManagerment ：项目的部署信息；  \n  issueManagement ：缺陷跟踪系统信息；  \n  ciManagement ：项目的持续继承信息；  \n  scm ：项目的版本控制信息；  \n  mailingListserv ：项目的邮件列表信息；  \n  properties ：自定义的 Maven 属性；  \n  dependencies ：项目的依赖配置；  \n  dependencyManagement ：醒目的依赖管理配置；  \n  repositories ：项目的仓库配置；  \n  build ：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等；  \n  reporting ：包括项目的报告输出目录配置、报告插件配置等。  \n  ```\n\n- 依赖管理与插件管理\n\n  上面的列表中包含了dependencies元素，表示依赖会被继承。因此，我们可以将模块的公有依赖配置到父模块pom中，子模块就可以移除这些依赖，但这样带来一个问题，如果我们新增了模块也继承父模块的话，新增的子模块也就有可能引入了他不需要的依赖。\n\n  为了解决这个问题，maven提供了dependencyManagement元素。在dependencyManagement元素下声明的依赖不会被实际引入：app-parent/pom.xml\n\n  ```xml\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<groupId>com.test.app</groupId>\n\t<artifactId>app-parent</artifactId>\n\t<version>1.0-SNAPSHOT</version>\n\t<packaging>pom</packaging>\n\t<name>App parent</name>\n\n\t<dependencyManagement>\n\t\t<dependencies>\n\t\t\t<dependency>\n\t\t\t\t<groupId>com.googlecode.java-diff-utils</groupId>\n\t\t\t\t<artifactId>diffutils</artifactId>\n\t\t\t\t<version>1.2.1</version>\n\t\t\t</dependency>\n\t\t</dependencies>\n\t</dependencyManagement>\n  </project>\n  ```\n  使用dependencyManagement声明的依赖既不会给app-parent引入依赖，也不会给他的子模块引入依赖，不过这段配置会被继承：app-core/pom.xml\n  ```xml\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>com.test.app</groupId>\n\t\t<artifactId>app-parent</artifactId>\n\t\t<version>1.0-SNAPSHOT</version>\n\t\t<relativePath>../app-parent/pom.xml</relativePath>\n\t</parent>\n\t<artifactId>app-core</artifactId>\n\t<packaging>pom</packaging>\n\t<name>App core</name>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>com.googlecode.java-diff-utils</groupId>\n\t\t\t<artifactId>diffutils</artifactId>\n\t\t</dependency>\n\t</dependencies>\n  </project>\n  ```\n  可以看到子模块只需要声明dependency的groupId、artifactId，不用声明version，虽然只省去了一行配置，但是统一了项目依赖的版本，降低依赖冲突的机会。\n\n  如果子模块没有声明diffutils，diffutils就不会被引入。\n\n  maven还提供了pluginManagement元素帮助管理插件。与dependencyManagement的原理相同。\n\n- 超级pom\n\n  实际上，我们声明的pom都隐式的继承自超级pom，位于`MAVEN_HOME/lib/maven-model-builder-x.jar`中的`org/apache/maven/model/pom-4.0.0.xml`。\n\n  在超级pom中定义了仓库和插件仓库，都是中央仓库的地址，定义了项目的主代码目录，测试目录等等项目的结构。\n\n  我们可以模仿超级pom在我们自己的pom中声明这些元素，从而自定义项目结构。\n \n## 属性与Profile\n\n### 属性\n\n属性有点类似于java中的变量。我们可以在pom中使用${属性名}的方式引用属性的值，从而消除重复，也能降低错误发生的概率。\n\nmaven属性有6类：\n\n- 内置属性\n\n  主要有${basedir}表示项目根目录，即包含pom.xml的目录；${version}表示项目的版本\n\n- pom属性\n\n  ${project.build.directory}表示主源码路径;\n\n  ${project.build.sourceEncoding}表示主源码的编码格式;\n\n  ${project.build.sourceDirectory}表示主源码路径;\n\n  ${project.build.finalName}表示输出文件名称;\n\n  ${project.version}表示项目版本,与${version}相同;\n\n- 自定义属性\n\n```xml\n  <properties>\n\t\t<project.my>hello</project.build.sourceEncoding>\n  </properties>\n```\n在pom中的其他地方使用${project.my}就会被替换成hello\n\n- settings属性\n\n  与pom属性同理，用户以settings开头的属性引用settings.xml文件中的xml元素值，如${settings.localRepository}指向本地仓库地址\n\n- java系统属性\n\n  所有java系统属性都可以使用maven属性引用。如${user.home}指向用户目录\n\n- 环境变量属性\n\n  所有环境变量都可以用以env开头的属性引用。如${env.JAVA_HOME}\n\n### 资源过滤\n\n一般情况下，我们习惯于在src/main/resources/目录下放置配置文件，在配置文件中，我们可能配置数据库的url，用户名密码等信息。但是在不同的环境中，这些数据库的配置常常会变动，比如在测试环境或者运行环境中。比较原始的做法手动更改这些配置，但是这样的方法比较低下也容易出错。maven可以在构建过程中针对不同的环境激活不同的配置。\n\n首先需要使用maven属性将会发生变化的部分提取出来：在数据库配置文件中\n\n```\ndb.jdbc.driver=${db.driver}\ndb.jdbc.url=${db.url}\n```\n\n这里定义了两个属性：db.driver、db.url\n\n既然定义了maven属性，我们需要在某个地方为其赋值。与自定义属性不同的是，这里需要做的是使用profile将其包裹：\n\n```xml\n<profiles>\n\t\t<profile>\n\t\t\t<id>pro_A</id>\n\t\t\t<properties>\n\t\t\t\t<db.driver>com.mysql.jdbc.Driver</db.driver>\n\t\t\t\t<db.url>jdbc:mysql://localhost:3306</db.url>\n\t\t\t</properties>\n\t\t</profile>\n</profiles>\n```\n\n那么这个profile是在哪里声明的呢？有三个地方：\n\n- pom.xml: pom中的profile只对当前项目有效\n\n- 用户settings.xml: 用户目录下`.m2/settings.xml`中的profile对该用户的所有maven项目有效\n\n- 全局settings.xml: maven安装目录下`conf/settings.xml`中的profile对本机上所有maven项目有效\n\n在配置文件中定义了maven属性，也在profile中为其赋值了，此时要做的是打开资源过滤：\n\n资源文件的处理实际上是maven-resources-plugin插件所做的事情，他的默认行为只是将项目主资源文件复制到主代码编译输出目录中，将测试资源文件复制到测试代码编译输出目录中。我们需要一些配置，使得该插件能够解析资源文件中的maven属性，开启资源过滤。\n\nmaven默认的资源目录是在超级pom中定义的，要开启资源目录过滤，需要如下配置：\n\n```xml\n<build>\n  <resources>\n        <resource>\n          <directory>${project.basedir}/src/main/resources</directory>\n          <filtering>true</filtering>\n        </resource>\n  </resources>\n</build>\n```\n上述代码为主资源目录开启了资源过滤，类似的我们可以为多个资源目录提供过滤配置：\n```xml\n<build>\n  <resources>\n        <resource>\n          <directory>${project.basedir}/src/main/resources</directory>\n          <filtering>true</filtering>\n        </resource>\n        <resource>\n          <directory>${project.basedir}/src/main/sql</directory>\n          <filtering>true</filtering>\n        </resource>\n  </resources>\n</build>\n```\n在配置文件中定义了maven属性，在profile中为属性赋值，并且为资源目录开启了资源过滤，接下来只需要在命令行激活profile：`mvn clean test -Ppro_A`.\n\nmvn命令中的-P参数激活了一个名为pro_A的profile。maven在构建项目的时候就会使用profile中的属性值替换在配置文件中的属性定义，然后将其复制到编译输出目录当中。\n\n### profile\n\n我们可以想到，针对不同的环境定义不同的profile，然后在不同的环境中通过命令行激活对应的profile，就能达到灵活切换配置的目的。除了命令行手动激活profile以外，还有下面几种方式能够激活profile：\n\n- 默认激活\n\n  ```xml\n  <profiles>\n\t\t<profile>\n\t\t\t<id>pro_A</id>\n\t\t\t<activation>\n\t\t\t<activeByDefault>true</activeByDefault>\n\t\t\t</activation>\n\t\t\t<properties>\n\t\t\t\t<db.driver>com.mysql.jdbc.Driver</db.driver>\n\t\t\t\t<db.url>jdbc:mysql://localhost:3306</db.url>\n\t\t\t</properties>\n\t\t</profile>\n\t</profiles>\n  ```\n  activeByDefault指定profile自动激活。但是如果pom中的任意一个profile通过其他方式被激活了，那么默认的激活配置失效。\n\n- 属性激活\n\n  ```xml\n  <profiles>\n\t\t<profile>\n\t\t\t<id>pro_A</id>\n\t\t\t<activation>\n\t\t\t\t<property>\n\t\t\t\t\t<name>test</name>\n\t\t\t\t\t<value>x</value>\n\t\t\t\t</property>\n\t\t\t</activation>\n\t\t\t<properties>\n\t\t\t\t<db.driver>com.mysql.jdbc.Driver</db.driver>\n\t\t\t\t<db.url>jdbc:mysql://localhost:3306</db.url>\n\t\t\t</properties>\n\t\t</profile>\n\t</profiles>\n  ```\n  属性test存在且值为x时激活该profile。利用这个特性可以在命令行同时激活多个profile：`mvn clean test -Dtest=x`\n\n- settings文件激活\n\n  ```xml\n  <settings>\n     <activeProfiles>\n       <activeProfile>pro_x</activeProfile>\n     </activeProfiles>\n  </settings>\n  ```\n  在settings.xml文件中配置，表示其配置的profile对所有项目处于激活状态。\n\n在profile中不仅可以添加或者修改maven属性，还可以对其他maven元素进行设置。\n\n- pom中的profile可以使用的元素：\n  \n  ```xml\n  <repositories></repositories>\n\t<pluginRepositories></pluginRepositories>\n\t<distributionManagement></distributionManagement>\n\t<dependencies></dependencies>\n\t<dependencyManagement></dependencyManagement>\n\t<modules></modules>\n\t<properties></properties>\n\t<reporting></reporting>\n\t<build>\n\t\t<plugins></plugins>\n\t\t<defaultGoal></defaultGoal>\n\t\t<resources></resources>\n\t\t<testResources></testResources>\n\t\t<finalName></finalName>\n\t</build>\n  ```\n\n- 其他profile可以使用的元素\n\n  ```xml\n  <repositories></repositories>\n  <pluginRepositories></pluginRepositories>\n  <properties></properties>\n  ```\n","source":"_posts/maven学习笔记2.md","raw":"---\nlayout: post\ntitle: maven学习笔记(二)\ndate: 2017-04-19 11:58:03\ncategories: 工具\ntags: \n- java\n- maven\n---\n\n## 依赖\n\ndependency标签可以声明以下一些元素：\n\n```xml\n<dependency>\n\t<groupId>...</groupId>\n\t<artifactId>...</artifactId>\n\t<version>...</version>\n\t<scope>...</scope>\n    <type>...</type>\n\t<optional>...</optional>\n\t<exclusions>\n\t\t <exclusion>...</exclusion>\n\t</exclusions>\n</dependency>\n```\n<!-- more -->\ngroupId、artifactId、version：声明了依赖的基本坐标\n\ntype: 依赖的类型，对应于项目坐标定义中的packaging，比如说jar\n\nscope：依赖的范围\n\noptional：是否是可选依赖\n\nexclusions: 排除传递性依赖\n\n- 依赖范围(scope)\n\n  Maven有三套classpath，编译项目主代码、编译测试代码、实际运行。依赖范围就是用来控制依赖与这三种classpath的关系.有以下几个选项：\n\n  依赖范围 | 对主代码classpath有效 | 对测试classpath有效 | 对运行时classpath有效\n  --------|----------------------|--------------------|----------------------\n  compile |         Y            |         Y          |           Y  \n  test    |         N            |         Y          |           N\n  provided|         Y            |         Y          |           N\n  runtime |         N            |         Y          |           Y\n  system  |         Y            |         Y          |           N\n\n- 传递性依赖\n  \n  我们在项目的pom.xml文件中声明了直接依赖，如果声明的这些依赖还依赖于其他第三方组件，在maven中，我们不用考虑这些间接依赖，也不用担心引入多余的依赖。Maven会解析各个直接依赖的pom，将那些必要的间接依赖以传递性依赖的方式引入到当前项目的classpath中。\n\n  依赖范围不仅能够控制依赖与三种classpath的关系，还会对传递性依赖产生影响。比如设A依赖于B，B依赖于C，A对于B是第一直接依赖，B对于C是第二直接依赖，A对与C是传递性依赖。第一直接依赖与第二直接依赖的依赖范围决定了传递性依赖的依赖范围。如下图，最左边第一列表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间交叉单元格表示传递性依赖范围\n\n          | compile | test | provided | runtime\n  --------|---------|------|----------|-----------\n  compile | compile |      |          | runtime \n  test    | test    |      |          | test \n  provided| provided|      | provided | provided \n  runtime | runtime |      |          | runtime \n\n  比如，account-email 项目有一个com.icegree:greemail:1.3.1b的直接依赖，这是第一直接依赖，其依赖范围是test；而greemail又有一个javax.mail:mail:1.4的直接依赖，这是第二直接依赖，其依赖的范围是compile。根据上面的表格可以推断，javax.mail:mail:1.4是account-email的一个范围是test的传递依赖。\n\n- 依赖调解\n\n  对于一个构件，存在于不同依赖路径上。选择哪个路径上的构件就是依赖调解要解决的问题，有两种策略：\n\n  1. 路径近者优先。 比如，项目A有这样的依赖关系：A->B->C->x(1.0)、A->D->X(2.0)，对于两个版本的X，如果都引入就会造成依赖重复。根据路径近者优先的策略，X(2.0)会被引入；\n\n  2. 第一声明者优先。 路径近者优先的策略不能解决所有问题，如果出现路径长度相同的情况，那么maven就会选择依赖声明在前的那个路径上的版本。\n\n- 可选依赖(optional)\n  \n  假设有这样的依赖关系：项目A依赖于项目B，项目B依赖于项目X，Y，B对于X和Y都是可选依赖：A-B、B->X(可选)、B->Y(可选)。那么此时，由于X、Y都是可选依赖，依赖性将不会传递，也就是说，A中不会引入X和Y。\n\n  有这样一种情况符合可选依赖的场景：项目B是一个持久层的工具包，支持多种数据库，X、Y就是其依赖的数据库驱动程序，但是我们的项目A在使用这个工具包B的时候，只依赖一种数据库，故我们不需要将X和Y全部引入。这种情况下需要我们在项目A中声明实际使用的数据库驱动依赖。\n\n- 排除依赖(exclusions)\n \n  传递性依赖为我们的项目隐式的引入了很多依赖，如果我们不想引入某个传递性依赖(自己选择依赖版本)，就可以使用排除依赖。\n\n  ```xml\n  <dependency>\n\t\t<groupId>org.slf4j</groupId>\n\t\t<artifactId>slf4j-api</artifactId>\n\t\t<version>1.7.7</version>\n  </dependency>\n  <dependency>\n\t\t<groupId>org.slf4j</groupId>\n\t\t<artifactId>slf4j-log4j12</artifactId>\n\t\t<version>1.7.7</version>\n\t\t<exclusions>\n\t\t\t<exclusion>\n\t\t\t    <groupId>org.slf4j</groupId>\n\t\t\t    <artifactId>slf4j-api</artifactId>\n\t\t\t</exclusion>\n\t\t</exclusions>\n  </dependency>\n  ```\n  上面的代码声明了一个排除依赖。我们的项目所依赖的slf4j-log4j12会引入slf4j-api这个传递性依赖。出于版本或者其他考虑，现在不想引入这个依赖，而是由我们显示的声明，那么就可以像上面的代码那样做。\n\n- 查看依赖\n\n  通过执行`mvn dependency:list`可以查看项目已经解析的依赖；\n  通过执行`mvn dependency:tree`可以查看项目的依赖树；\n  通过执行`mvn dependency:analyze`可以查看项目中没有使用，却显示声明的依赖和项目中显示使用了却没有显示声明的依赖。\n\n  在Eclispe中，可以双击pom.xml，在Dependencies和Dependency Hierarchy选项卡查看项目的依赖情况。\n\n## 仓库\n\n- 仓库分类\n\n  对于maven来说，仓库分为两类：本地仓库和远程仓库。本地仓库即存在于我们本地机器上的构件仓库，远程仓库就是远程机器上的构件仓库。我们的依赖(jar)都是从仓库当中下载得到的。\n\n  当maven对我们的项目执行编译或者测试时，如果需要使用依赖文件，他总是基于坐标使用本地仓库的依赖文件。如果本地仓库存在此构件，则直接使用；如果本地仓库不存在此构件，或者需要更新的版本，maven会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。如果本地仓库和远程仓库都没有需要的构件，则报错。\n\n  中央仓库是Maven核心自带的远程仓库，包含了绝大部分开源构件。默认情况下，当本地仓库没有maven需要的构件时，他就会从中央仓库下载。\n\n- 仓库配置\n\n  在linux上本地仓库的默认路径为：`~/.m2/repository/`  如果想要自定义本地仓库地址，可以编辑 `~/.m2/setting.xml`, 设置localRepository元素值为想要的地址：\n\n  ```\n  <localRepository>/path/to/local/repo</localRepository>\n  ```\n\n  某些情况下，中央仓库无法满足项目需求，项目需要的构件可能存在于另一个远程仓库上，这是，可以在pom中配置该仓库：\n\n  ```xml\n  <repositories>\n\t\t<repository>\n\t\t\t<id>JBOSS</id>\n\t\t\t<name>Jboss</name>\n\t\t\t<url>http://repository.jnoss.com/maven2</url>\n\t\t\t<releases>\n\t\t\t\t<enabled>true</enabled>\n\t\t\t</releases>\n\t\t\t<snapshots>\n\t\t\t\t<enabled>false</enabled>\n\t\t\t</snapshots>\n\t\t</repository>\n\t</repositories>\n  ```\n  上面的例子中声明了一个id为JBOSS的远程仓库，任何一个仓库声明的id都必须是唯一的。release的enable值为true，表示开启Jboss仓库发布版本的下载支持；snapshots的enable值为false，表示关闭Jboss仓库快照版本的下载支持。\n\n  可以声明多个远程仓库，maven会遍历这些仓库去查找所需的构件。\n  \n## 聚合与继承\n\n- 聚合\n\n  一个项目中往往不止一个模块，比如有core、util等等模块的划分。每个模块是一个独立的工程，提供了对外的接口供调用，各个模块之间有相互依赖的关系。那么，如果我们想要一次性构建项目中的两个两个模块，而不是到两个模块各自的目录下面执行mvn命令，这时候就需要maven的聚合。\n\n  为了能够使用一条命令就构建core和util两个模块，我们需要额外创建一个名为aggregator的模块，然后通过该模块构建整个项目的所有模块。aggregator本身作为一个maven项目，必须有自己的pom：\n\n  ```xml\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<groupId>com.test.app</groupId>\n\t<artifactId>app-aggregator</artifactId>\n\t<version>1.0-SNAPSHOT</version>\n\t<packaging>pom</packaging>\n\t<modules>\n\t\t<module>app-core</module>\n\t\t<module>app-util</module>\n\t</modules>\n  </project>\n  ```\n  对于聚合模块来说，packaging的值必须为pom，否则无法构建。用户可以通过在一个打包为pom的Maven项目中声明任意数量的module元素来实现模块的聚合。\n\n  这里每一个module的值都是一个当前pom的相对目录。比如app-aggregator的pom路径为`~/app/app-aggregator/pom.xml`，那么app-core就对应目录`~/app/app-aggregator/app-core/`,app-util就对应目录`~/app/app-aggregator/app-util/`，这两个目录各自包含pom.xml、src/main/java等内容，可以独立构建。\n\n  从聚合模块运行mvn命令，maven就会解析聚合模块的pom，分析要构建的模块，并计算出一个构建顺序，然后根据这个顺序依次构建各个模块。\n\n- 继承\n  \n  在面向对象的设计中，可以在父类中声明一些字段，由子类继承使用。类似的，pom也可以声明这样一种父子结构。\n\n  我们继续在`~/app/app-aggregator/`目录下创建一个名为app-parent的子目录，在该子目录中声明一个pom:\n\n  ```xml\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<groupId>com.test.app</groupId>\n\t<artifactId>app-parent</artifactId>\n\t<version>1.0-SNAPSHOT</version>\n\t<packaging>pom</packaging>\n\t<name>App parent</name>\n  </project>\n  ```\n  修改app-core继承app-parent\n  ```xml\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>com.test.app</groupId>\n\t\t<artifactId>app-parent</artifactId>\n\t\t<version>1.0-SNAPSHOT</version>\n\t\t<relativePath>../app-parent/pom.xml</relativePath>\n\t</parent>\n\t<artifactId>app-core</artifactId>\n\t<packaging>pom</packaging>\n\t<name>App core</name>\n  </project>\n  ```\n  上述pom中parent元素声明父模块，groupId、artifactId、version指定了父模块的坐标。relativePath指定了父模块pom的相对路径。\n\n  app-core中没有声明version和groupId，他隐式的从父模块继承了这两个元素。\n\n  下面是可继承的pom元素：\n\n  ```\n  groupId ：项目组 ID ，项目坐标的核心元素；  \n  version ：项目版本，项目坐标的核心元素；  \n  description ：项目的描述信息；  \n  organization ：项目的组织信息；  \n  inceptionYear ：项目的创始年份；  \n  url ：项目的 url 地址  \n  develoers ：项目的开发者信息；  \n  contributors ：项目的贡献者信息；  \n  distributionManagerment ：项目的部署信息；  \n  issueManagement ：缺陷跟踪系统信息；  \n  ciManagement ：项目的持续继承信息；  \n  scm ：项目的版本控制信息；  \n  mailingListserv ：项目的邮件列表信息；  \n  properties ：自定义的 Maven 属性；  \n  dependencies ：项目的依赖配置；  \n  dependencyManagement ：醒目的依赖管理配置；  \n  repositories ：项目的仓库配置；  \n  build ：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等；  \n  reporting ：包括项目的报告输出目录配置、报告插件配置等。  \n  ```\n\n- 依赖管理与插件管理\n\n  上面的列表中包含了dependencies元素，表示依赖会被继承。因此，我们可以将模块的公有依赖配置到父模块pom中，子模块就可以移除这些依赖，但这样带来一个问题，如果我们新增了模块也继承父模块的话，新增的子模块也就有可能引入了他不需要的依赖。\n\n  为了解决这个问题，maven提供了dependencyManagement元素。在dependencyManagement元素下声明的依赖不会被实际引入：app-parent/pom.xml\n\n  ```xml\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<groupId>com.test.app</groupId>\n\t<artifactId>app-parent</artifactId>\n\t<version>1.0-SNAPSHOT</version>\n\t<packaging>pom</packaging>\n\t<name>App parent</name>\n\n\t<dependencyManagement>\n\t\t<dependencies>\n\t\t\t<dependency>\n\t\t\t\t<groupId>com.googlecode.java-diff-utils</groupId>\n\t\t\t\t<artifactId>diffutils</artifactId>\n\t\t\t\t<version>1.2.1</version>\n\t\t\t</dependency>\n\t\t</dependencies>\n\t</dependencyManagement>\n  </project>\n  ```\n  使用dependencyManagement声明的依赖既不会给app-parent引入依赖，也不会给他的子模块引入依赖，不过这段配置会被继承：app-core/pom.xml\n  ```xml\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>com.test.app</groupId>\n\t\t<artifactId>app-parent</artifactId>\n\t\t<version>1.0-SNAPSHOT</version>\n\t\t<relativePath>../app-parent/pom.xml</relativePath>\n\t</parent>\n\t<artifactId>app-core</artifactId>\n\t<packaging>pom</packaging>\n\t<name>App core</name>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>com.googlecode.java-diff-utils</groupId>\n\t\t\t<artifactId>diffutils</artifactId>\n\t\t</dependency>\n\t</dependencies>\n  </project>\n  ```\n  可以看到子模块只需要声明dependency的groupId、artifactId，不用声明version，虽然只省去了一行配置，但是统一了项目依赖的版本，降低依赖冲突的机会。\n\n  如果子模块没有声明diffutils，diffutils就不会被引入。\n\n  maven还提供了pluginManagement元素帮助管理插件。与dependencyManagement的原理相同。\n\n- 超级pom\n\n  实际上，我们声明的pom都隐式的继承自超级pom，位于`MAVEN_HOME/lib/maven-model-builder-x.jar`中的`org/apache/maven/model/pom-4.0.0.xml`。\n\n  在超级pom中定义了仓库和插件仓库，都是中央仓库的地址，定义了项目的主代码目录，测试目录等等项目的结构。\n\n  我们可以模仿超级pom在我们自己的pom中声明这些元素，从而自定义项目结构。\n \n## 属性与Profile\n\n### 属性\n\n属性有点类似于java中的变量。我们可以在pom中使用${属性名}的方式引用属性的值，从而消除重复，也能降低错误发生的概率。\n\nmaven属性有6类：\n\n- 内置属性\n\n  主要有${basedir}表示项目根目录，即包含pom.xml的目录；${version}表示项目的版本\n\n- pom属性\n\n  ${project.build.directory}表示主源码路径;\n\n  ${project.build.sourceEncoding}表示主源码的编码格式;\n\n  ${project.build.sourceDirectory}表示主源码路径;\n\n  ${project.build.finalName}表示输出文件名称;\n\n  ${project.version}表示项目版本,与${version}相同;\n\n- 自定义属性\n\n```xml\n  <properties>\n\t\t<project.my>hello</project.build.sourceEncoding>\n  </properties>\n```\n在pom中的其他地方使用${project.my}就会被替换成hello\n\n- settings属性\n\n  与pom属性同理，用户以settings开头的属性引用settings.xml文件中的xml元素值，如${settings.localRepository}指向本地仓库地址\n\n- java系统属性\n\n  所有java系统属性都可以使用maven属性引用。如${user.home}指向用户目录\n\n- 环境变量属性\n\n  所有环境变量都可以用以env开头的属性引用。如${env.JAVA_HOME}\n\n### 资源过滤\n\n一般情况下，我们习惯于在src/main/resources/目录下放置配置文件，在配置文件中，我们可能配置数据库的url，用户名密码等信息。但是在不同的环境中，这些数据库的配置常常会变动，比如在测试环境或者运行环境中。比较原始的做法手动更改这些配置，但是这样的方法比较低下也容易出错。maven可以在构建过程中针对不同的环境激活不同的配置。\n\n首先需要使用maven属性将会发生变化的部分提取出来：在数据库配置文件中\n\n```\ndb.jdbc.driver=${db.driver}\ndb.jdbc.url=${db.url}\n```\n\n这里定义了两个属性：db.driver、db.url\n\n既然定义了maven属性，我们需要在某个地方为其赋值。与自定义属性不同的是，这里需要做的是使用profile将其包裹：\n\n```xml\n<profiles>\n\t\t<profile>\n\t\t\t<id>pro_A</id>\n\t\t\t<properties>\n\t\t\t\t<db.driver>com.mysql.jdbc.Driver</db.driver>\n\t\t\t\t<db.url>jdbc:mysql://localhost:3306</db.url>\n\t\t\t</properties>\n\t\t</profile>\n</profiles>\n```\n\n那么这个profile是在哪里声明的呢？有三个地方：\n\n- pom.xml: pom中的profile只对当前项目有效\n\n- 用户settings.xml: 用户目录下`.m2/settings.xml`中的profile对该用户的所有maven项目有效\n\n- 全局settings.xml: maven安装目录下`conf/settings.xml`中的profile对本机上所有maven项目有效\n\n在配置文件中定义了maven属性，也在profile中为其赋值了，此时要做的是打开资源过滤：\n\n资源文件的处理实际上是maven-resources-plugin插件所做的事情，他的默认行为只是将项目主资源文件复制到主代码编译输出目录中，将测试资源文件复制到测试代码编译输出目录中。我们需要一些配置，使得该插件能够解析资源文件中的maven属性，开启资源过滤。\n\nmaven默认的资源目录是在超级pom中定义的，要开启资源目录过滤，需要如下配置：\n\n```xml\n<build>\n  <resources>\n        <resource>\n          <directory>${project.basedir}/src/main/resources</directory>\n          <filtering>true</filtering>\n        </resource>\n  </resources>\n</build>\n```\n上述代码为主资源目录开启了资源过滤，类似的我们可以为多个资源目录提供过滤配置：\n```xml\n<build>\n  <resources>\n        <resource>\n          <directory>${project.basedir}/src/main/resources</directory>\n          <filtering>true</filtering>\n        </resource>\n        <resource>\n          <directory>${project.basedir}/src/main/sql</directory>\n          <filtering>true</filtering>\n        </resource>\n  </resources>\n</build>\n```\n在配置文件中定义了maven属性，在profile中为属性赋值，并且为资源目录开启了资源过滤，接下来只需要在命令行激活profile：`mvn clean test -Ppro_A`.\n\nmvn命令中的-P参数激活了一个名为pro_A的profile。maven在构建项目的时候就会使用profile中的属性值替换在配置文件中的属性定义，然后将其复制到编译输出目录当中。\n\n### profile\n\n我们可以想到，针对不同的环境定义不同的profile，然后在不同的环境中通过命令行激活对应的profile，就能达到灵活切换配置的目的。除了命令行手动激活profile以外，还有下面几种方式能够激活profile：\n\n- 默认激活\n\n  ```xml\n  <profiles>\n\t\t<profile>\n\t\t\t<id>pro_A</id>\n\t\t\t<activation>\n\t\t\t<activeByDefault>true</activeByDefault>\n\t\t\t</activation>\n\t\t\t<properties>\n\t\t\t\t<db.driver>com.mysql.jdbc.Driver</db.driver>\n\t\t\t\t<db.url>jdbc:mysql://localhost:3306</db.url>\n\t\t\t</properties>\n\t\t</profile>\n\t</profiles>\n  ```\n  activeByDefault指定profile自动激活。但是如果pom中的任意一个profile通过其他方式被激活了，那么默认的激活配置失效。\n\n- 属性激活\n\n  ```xml\n  <profiles>\n\t\t<profile>\n\t\t\t<id>pro_A</id>\n\t\t\t<activation>\n\t\t\t\t<property>\n\t\t\t\t\t<name>test</name>\n\t\t\t\t\t<value>x</value>\n\t\t\t\t</property>\n\t\t\t</activation>\n\t\t\t<properties>\n\t\t\t\t<db.driver>com.mysql.jdbc.Driver</db.driver>\n\t\t\t\t<db.url>jdbc:mysql://localhost:3306</db.url>\n\t\t\t</properties>\n\t\t</profile>\n\t</profiles>\n  ```\n  属性test存在且值为x时激活该profile。利用这个特性可以在命令行同时激活多个profile：`mvn clean test -Dtest=x`\n\n- settings文件激活\n\n  ```xml\n  <settings>\n     <activeProfiles>\n       <activeProfile>pro_x</activeProfile>\n     </activeProfiles>\n  </settings>\n  ```\n  在settings.xml文件中配置，表示其配置的profile对所有项目处于激活状态。\n\n在profile中不仅可以添加或者修改maven属性，还可以对其他maven元素进行设置。\n\n- pom中的profile可以使用的元素：\n  \n  ```xml\n  <repositories></repositories>\n\t<pluginRepositories></pluginRepositories>\n\t<distributionManagement></distributionManagement>\n\t<dependencies></dependencies>\n\t<dependencyManagement></dependencyManagement>\n\t<modules></modules>\n\t<properties></properties>\n\t<reporting></reporting>\n\t<build>\n\t\t<plugins></plugins>\n\t\t<defaultGoal></defaultGoal>\n\t\t<resources></resources>\n\t\t<testResources></testResources>\n\t\t<finalName></finalName>\n\t</build>\n  ```\n\n- 其他profile可以使用的元素\n\n  ```xml\n  <repositories></repositories>\n  <pluginRepositories></pluginRepositories>\n  <properties></properties>\n  ```\n","slug":"maven学习笔记2","published":1,"updated":"2017-04-19T04:00:34.672Z","comments":1,"photos":[],"link":"","_id":"cj4vch4ft003hx3gcray0xdtj","content":"<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><p>dependency标签可以声明以下一些元素：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">optional</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">optional</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">exclusions</span>&gt;</span></div><div class=\"line\">\t\t <span class=\"tag\">&lt;<span class=\"name\">exclusion</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">exclusion</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">exclusions</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>groupId、artifactId、version：声明了依赖的基本坐标</p>\n<p>type: 依赖的类型，对应于项目坐标定义中的packaging，比如说jar</p>\n<p>scope：依赖的范围</p>\n<p>optional：是否是可选依赖</p>\n<p>exclusions: 排除传递性依赖</p>\n<ul>\n<li><p>依赖范围(scope)</p>\n<p>Maven有三套classpath，编译项目主代码、编译测试代码、实际运行。依赖范围就是用来控制依赖与这三种classpath的关系.有以下几个选项：</p>\n<p>依赖范围 | 对主代码classpath有效 | 对测试classpath有效 | 对运行时classpath有效<br>——–|———————-|——————–|———————-<br>compile |         Y            |         Y          |           Y<br>test    |         N            |         Y          |           N<br>provided|         Y            |         Y          |           N<br>runtime |         N            |         Y          |           Y<br>system  |         Y            |         Y          |           N</p>\n</li>\n<li><p>传递性依赖</p>\n<p>我们在项目的pom.xml文件中声明了直接依赖，如果声明的这些依赖还依赖于其他第三方组件，在maven中，我们不用考虑这些间接依赖，也不用担心引入多余的依赖。Maven会解析各个直接依赖的pom，将那些必要的间接依赖以传递性依赖的方式引入到当前项目的classpath中。</p>\n<p>依赖范围不仅能够控制依赖与三种classpath的关系，还会对传递性依赖产生影响。比如设A依赖于B，B依赖于C，A对于B是第一直接依赖，B对于C是第二直接依赖，A对与C是传递性依赖。第一直接依赖与第二直接依赖的依赖范围决定了传递性依赖的依赖范围。如下图，最左边第一列表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间交叉单元格表示传递性依赖范围</p>\n<pre><code>| compile | test | provided | runtime\n</code></pre><p>——–|———|——|———-|———–<br>compile | compile |      |          | runtime<br>test    | test    |      |          | test<br>provided| provided|      | provided | provided<br>runtime | runtime |      |          | runtime </p>\n<p>比如，account-email 项目有一个com.icegree:greemail:1.3.1b的直接依赖，这是第一直接依赖，其依赖范围是test；而greemail又有一个javax.mail:mail:1.4的直接依赖，这是第二直接依赖，其依赖的范围是compile。根据上面的表格可以推断，javax.mail:mail:1.4是account-email的一个范围是test的传递依赖。</p>\n</li>\n<li><p>依赖调解</p>\n<p>对于一个构件，存在于不同依赖路径上。选择哪个路径上的构件就是依赖调解要解决的问题，有两种策略：</p>\n<ol>\n<li><p>路径近者优先。 比如，项目A有这样的依赖关系：A-&gt;B-&gt;C-&gt;x(1.0)、A-&gt;D-&gt;X(2.0)，对于两个版本的X，如果都引入就会造成依赖重复。根据路径近者优先的策略，X(2.0)会被引入；</p>\n</li>\n<li><p>第一声明者优先。 路径近者优先的策略不能解决所有问题，如果出现路径长度相同的情况，那么maven就会选择依赖声明在前的那个路径上的版本。</p>\n</li>\n</ol>\n</li>\n<li><p>可选依赖(optional)</p>\n<p>假设有这样的依赖关系：项目A依赖于项目B，项目B依赖于项目X，Y，B对于X和Y都是可选依赖：A-B、B-&gt;X(可选)、B-&gt;Y(可选)。那么此时，由于X、Y都是可选依赖，依赖性将不会传递，也就是说，A中不会引入X和Y。</p>\n<p>有这样一种情况符合可选依赖的场景：项目B是一个持久层的工具包，支持多种数据库，X、Y就是其依赖的数据库驱动程序，但是我们的项目A在使用这个工具包B的时候，只依赖一种数据库，故我们不需要将X和Y全部引入。这种情况下需要我们在项目A中声明实际使用的数据库驱动依赖。</p>\n</li>\n<li><p>排除依赖(exclusions)</p>\n<p>传递性依赖为我们的项目隐式的引入了很多依赖，如果我们不想引入某个传递性依赖(自己选择依赖版本)，就可以使用排除依赖。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">exclusions</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">exclusion</span>&gt;</span></div><div class=\"line\">\t    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">exclusion</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">exclusions</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>上面的代码声明了一个排除依赖。我们的项目所依赖的slf4j-log4j12会引入slf4j-api这个传递性依赖。出于版本或者其他考虑，现在不想引入这个依赖，而是由我们显示的声明，那么就可以像上面的代码那样做。</p>\n</li>\n<li><p>查看依赖</p>\n<p>通过执行<code>mvn dependency:list</code>可以查看项目已经解析的依赖；<br>通过执行<code>mvn dependency:tree</code>可以查看项目的依赖树；<br>通过执行<code>mvn dependency:analyze</code>可以查看项目中没有使用，却显示声明的依赖和项目中显示使用了却没有显示声明的依赖。</p>\n<p>在Eclispe中，可以双击pom.xml，在Dependencies和Dependency Hierarchy选项卡查看项目的依赖情况。</p>\n</li>\n</ul>\n<h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><ul>\n<li><p>仓库分类</p>\n<p>对于maven来说，仓库分为两类：本地仓库和远程仓库。本地仓库即存在于我们本地机器上的构件仓库，远程仓库就是远程机器上的构件仓库。我们的依赖(jar)都是从仓库当中下载得到的。</p>\n<p>当maven对我们的项目执行编译或者测试时，如果需要使用依赖文件，他总是基于坐标使用本地仓库的依赖文件。如果本地仓库存在此构件，则直接使用；如果本地仓库不存在此构件，或者需要更新的版本，maven会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。如果本地仓库和远程仓库都没有需要的构件，则报错。</p>\n<p>中央仓库是Maven核心自带的远程仓库，包含了绝大部分开源构件。默认情况下，当本地仓库没有maven需要的构件时，他就会从中央仓库下载。</p>\n</li>\n<li><p>仓库配置</p>\n<p>在linux上本地仓库的默认路径为：<code>~/.m2/repository/</code>  如果想要自定义本地仓库地址，可以编辑 <code>~/.m2/setting.xml</code>, 设置localRepository元素值为想要的地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</div></pre></td></tr></table></figure>\n<p>某些情况下，中央仓库无法满足项目需求，项目需要的构件可能存在于另一个远程仓库上，这是，可以在pom中配置该仓库：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>JBOSS<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Jboss<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://repository.jnoss.com/maven2<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>上面的例子中声明了一个id为JBOSS的远程仓库，任何一个仓库声明的id都必须是唯一的。release的enable值为true，表示开启Jboss仓库发布版本的下载支持；snapshots的enable值为false，表示关闭Jboss仓库快照版本的下载支持。</p>\n<p>可以声明多个远程仓库，maven会遍历这些仓库去查找所需的构件。</p>\n</li>\n</ul>\n<h2 id=\"聚合与继承\"><a href=\"#聚合与继承\" class=\"headerlink\" title=\"聚合与继承\"></a>聚合与继承</h2><ul>\n<li><p>聚合</p>\n<p>一个项目中往往不止一个模块，比如有core、util等等模块的划分。每个模块是一个独立的工程，提供了对外的接口供调用，各个模块之间有相互依赖的关系。那么，如果我们想要一次性构建项目中的两个两个模块，而不是到两个模块各自的目录下面执行mvn命令，这时候就需要maven的聚合。</p>\n<p>为了能够使用一条命令就构建core和util两个模块，我们需要额外创建一个名为aggregator的模块，然后通过该模块构建整个项目的所有模块。aggregator本身作为一个maven项目，必须有自己的pom：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.test.app<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-aggregator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modules</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>app-core<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>app-util<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">modules</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>对于聚合模块来说，packaging的值必须为pom，否则无法构建。用户可以通过在一个打包为pom的Maven项目中声明任意数量的module元素来实现模块的聚合。</p>\n<p>这里每一个module的值都是一个当前pom的相对目录。比如app-aggregator的pom路径为<code>~/app/app-aggregator/pom.xml</code>，那么app-core就对应目录<code>~/app/app-aggregator/app-core/</code>,app-util就对应目录<code>~/app/app-aggregator/app-util/</code>，这两个目录各自包含pom.xml、src/main/java等内容，可以独立构建。</p>\n<p>从聚合模块运行mvn命令，maven就会解析聚合模块的pom，分析要构建的模块，并计算出一个构建顺序，然后根据这个顺序依次构建各个模块。</p>\n</li>\n<li><p>继承</p>\n<p>在面向对象的设计中，可以在父类中声明一些字段，由子类继承使用。类似的，pom也可以声明这样一种父子结构。</p>\n<p>我们继续在<code>~/app/app-aggregator/</code>目录下创建一个名为app-parent的子目录，在该子目录中声明一个pom:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.test.app<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>App parent<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>修改app-core继承app-parent</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.test.app<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">relativePath</span>&gt;</span>../app-parent/pom.xml<span class=\"tag\">&lt;/<span class=\"name\">relativePath</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>App core<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>上述pom中parent元素声明父模块，groupId、artifactId、version指定了父模块的坐标。relativePath指定了父模块pom的相对路径。</p>\n<p>app-core中没有声明version和groupId，他隐式的从父模块继承了这两个元素。</p>\n<p>下面是可继承的pom元素：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">groupId ：项目组 ID ，项目坐标的核心元素；  </div><div class=\"line\">version ：项目版本，项目坐标的核心元素；  </div><div class=\"line\">description ：项目的描述信息；  </div><div class=\"line\">organization ：项目的组织信息；  </div><div class=\"line\">inceptionYear ：项目的创始年份；  </div><div class=\"line\">url ：项目的 url 地址  </div><div class=\"line\">develoers ：项目的开发者信息；  </div><div class=\"line\">contributors ：项目的贡献者信息；  </div><div class=\"line\">distributionManagerment ：项目的部署信息；  </div><div class=\"line\">issueManagement ：缺陷跟踪系统信息；  </div><div class=\"line\">ciManagement ：项目的持续继承信息；  </div><div class=\"line\">scm ：项目的版本控制信息；  </div><div class=\"line\">mailingListserv ：项目的邮件列表信息；  </div><div class=\"line\">properties ：自定义的 Maven 属性；  </div><div class=\"line\">dependencies ：项目的依赖配置；  </div><div class=\"line\">dependencyManagement ：醒目的依赖管理配置；  </div><div class=\"line\">repositories ：项目的仓库配置；  </div><div class=\"line\">build ：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等；  </div><div class=\"line\">reporting ：包括项目的报告输出目录配置、报告插件配置等。</div></pre></td></tr></table></figure>\n</li>\n<li><p>依赖管理与插件管理</p>\n<p>上面的列表中包含了dependencies元素，表示依赖会被继承。因此，我们可以将模块的公有依赖配置到父模块pom中，子模块就可以移除这些依赖，但这样带来一个问题，如果我们新增了模块也继承父模块的话，新增的子模块也就有可能引入了他不需要的依赖。</p>\n<p>为了解决这个问题，maven提供了dependencyManagement元素。在dependencyManagement元素下声明的依赖不会被实际引入：app-parent/pom.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.test.app<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>App parent<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.googlecode.java-diff-utils<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>diffutils<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>使用dependencyManagement声明的依赖既不会给app-parent引入依赖，也不会给他的子模块引入依赖，不过这段配置会被继承：app-core/pom.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.test.app<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">relativePath</span>&gt;</span>../app-parent/pom.xml<span class=\"tag\">&lt;/<span class=\"name\">relativePath</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>App core<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.googlecode.java-diff-utils<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>diffutils<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>可以看到子模块只需要声明dependency的groupId、artifactId，不用声明version，虽然只省去了一行配置，但是统一了项目依赖的版本，降低依赖冲突的机会。</p>\n<p>如果子模块没有声明diffutils，diffutils就不会被引入。</p>\n<p>maven还提供了pluginManagement元素帮助管理插件。与dependencyManagement的原理相同。</p>\n</li>\n<li><p>超级pom</p>\n<p>实际上，我们声明的pom都隐式的继承自超级pom，位于<code>MAVEN_HOME/lib/maven-model-builder-x.jar</code>中的<code>org/apache/maven/model/pom-4.0.0.xml</code>。</p>\n<p>在超级pom中定义了仓库和插件仓库，都是中央仓库的地址，定义了项目的主代码目录，测试目录等等项目的结构。</p>\n<p>我们可以模仿超级pom在我们自己的pom中声明这些元素，从而自定义项目结构。</p>\n</li>\n</ul>\n<h2 id=\"属性与Profile\"><a href=\"#属性与Profile\" class=\"headerlink\" title=\"属性与Profile\"></a>属性与Profile</h2><h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>属性有点类似于java中的变量。我们可以在pom中使用${属性名}的方式引用属性的值，从而消除重复，也能降低错误发生的概率。</p>\n<p>maven属性有6类：</p>\n<ul>\n<li><p>内置属性</p>\n<p>主要有${basedir}表示项目根目录，即包含pom.xml的目录；${version}表示项目的版本</p>\n</li>\n<li><p>pom属性</p>\n<p>${project.build.directory}表示主源码路径;</p>\n<p>${project.build.sourceEncoding}表示主源码的编码格式;</p>\n<p>${project.build.sourceDirectory}表示主源码路径;</p>\n<p>${project.build.finalName}表示输出文件名称;</p>\n<p>${project.version}表示项目版本,与${version}相同;</p>\n</li>\n<li><p>自定义属性</p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project.my</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在pom中的其他地方使用${project.my}就会被替换成hello</p>\n<ul>\n<li><p>settings属性</p>\n<p>与pom属性同理，用户以settings开头的属性引用settings.xml文件中的xml元素值，如${settings.localRepository}指向本地仓库地址</p>\n</li>\n<li><p>java系统属性</p>\n<p>所有java系统属性都可以使用maven属性引用。如${user.home}指向用户目录</p>\n</li>\n<li><p>环境变量属性</p>\n<p>所有环境变量都可以用以env开头的属性引用。如${env.JAVA_HOME}</p>\n</li>\n</ul>\n<h3 id=\"资源过滤\"><a href=\"#资源过滤\" class=\"headerlink\" title=\"资源过滤\"></a>资源过滤</h3><p>一般情况下，我们习惯于在src/main/resources/目录下放置配置文件，在配置文件中，我们可能配置数据库的url，用户名密码等信息。但是在不同的环境中，这些数据库的配置常常会变动，比如在测试环境或者运行环境中。比较原始的做法手动更改这些配置，但是这样的方法比较低下也容易出错。maven可以在构建过程中针对不同的环境激活不同的配置。</p>\n<p>首先需要使用maven属性将会发生变化的部分提取出来：在数据库配置文件中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.jdbc.driver=$&#123;db.driver&#125;</div><div class=\"line\">db.jdbc.url=$&#123;db.url&#125;</div></pre></td></tr></table></figure>\n<p>这里定义了两个属性：db.driver、db.url</p>\n<p>既然定义了maven属性，我们需要在某个地方为其赋值。与自定义属性不同的是，这里需要做的是使用profile将其包裹：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>pro_A<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">db.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">db.driver</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">db.url</span>&gt;</span>jdbc:mysql://localhost:3306<span class=\"tag\">&lt;/<span class=\"name\">db.url</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>那么这个profile是在哪里声明的呢？有三个地方：</p>\n<ul>\n<li><p>pom.xml: pom中的profile只对当前项目有效</p>\n</li>\n<li><p>用户settings.xml: 用户目录下<code>.m2/settings.xml</code>中的profile对该用户的所有maven项目有效</p>\n</li>\n<li><p>全局settings.xml: maven安装目录下<code>conf/settings.xml</code>中的profile对本机上所有maven项目有效</p>\n</li>\n</ul>\n<p>在配置文件中定义了maven属性，也在profile中为其赋值了，此时要做的是打开资源过滤：</p>\n<p>资源文件的处理实际上是maven-resources-plugin插件所做的事情，他的默认行为只是将项目主资源文件复制到主代码编译输出目录中，将测试资源文件复制到测试代码编译输出目录中。我们需要一些配置，使得该插件能够解析资源文件中的maven属性，开启资源过滤。</p>\n<p>maven默认的资源目录是在超级pom中定义的，要开启资源目录过滤，需要如下配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">filtering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtering</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>上述代码为主资源目录开启了资源过滤，类似的我们可以为多个资源目录提供过滤配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">filtering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtering</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/sql<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">filtering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtering</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>在配置文件中定义了maven属性，在profile中为属性赋值，并且为资源目录开启了资源过滤，接下来只需要在命令行激活profile：<code>mvn clean test -Ppro_A</code>.</p>\n<p>mvn命令中的-P参数激活了一个名为pro_A的profile。maven在构建项目的时候就会使用profile中的属性值替换在配置文件中的属性定义，然后将其复制到编译输出目录当中。</p>\n<h3 id=\"profile\"><a href=\"#profile\" class=\"headerlink\" title=\"profile\"></a>profile</h3><p>我们可以想到，针对不同的环境定义不同的profile，然后在不同的环境中通过命令行激活对应的profile，就能达到灵活切换配置的目的。除了命令行手动激活profile以外，还有下面几种方式能够激活profile：</p>\n<ul>\n<li><p>默认激活</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>pro_A<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">activeByDefault</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">activeByDefault</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">db.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">db.driver</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">db.url</span>&gt;</span>jdbc:mysql://localhost:3306<span class=\"tag\">&lt;/<span class=\"name\">db.url</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>activeByDefault指定profile自动激活。但是如果pom中的任意一个profile通过其他方式被激活了，那么默认的激活配置失效。</p>\n</li>\n<li><p>属性激活</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>pro_A<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>x<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">db.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">db.driver</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">db.url</span>&gt;</span>jdbc:mysql://localhost:3306<span class=\"tag\">&lt;/<span class=\"name\">db.url</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>属性test存在且值为x时激活该profile。利用这个特性可以在命令行同时激活多个profile：<code>mvn clean test -Dtest=x</code></p>\n</li>\n<li><p>settings文件激活</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></div><div class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">activeProfiles</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">activeProfile</span>&gt;</span>pro_x<span class=\"tag\">&lt;/<span class=\"name\">activeProfile</span>&gt;</span></div><div class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">activeProfiles</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在settings.xml文件中配置，表示其配置的profile对所有项目处于激活状态。</p>\n</li>\n</ul>\n<p>在profile中不仅可以添加或者修改maven属性，还可以对其他maven元素进行设置。</p>\n<ul>\n<li><p>pom中的profile可以使用的元素：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">pluginRepositories</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">pluginRepositories</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">distributionManagement</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">distributionManagement</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modules</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">modules</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">reporting</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">reporting</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">defaultGoal</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">defaultGoal</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">testResources</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">testResources</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">finalName</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">finalName</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>其他profile可以使用的元素</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">pluginRepositories</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">pluginRepositories</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n","excerpt":"<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><p>dependency标签可以声明以下一些元素：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">optional</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">optional</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">exclusions</span>&gt;</span></div><div class=\"line\">\t\t <span class=\"tag\">&lt;<span class=\"name\">exclusion</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">exclusion</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">exclusions</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>","more":"<p>groupId、artifactId、version：声明了依赖的基本坐标</p>\n<p>type: 依赖的类型，对应于项目坐标定义中的packaging，比如说jar</p>\n<p>scope：依赖的范围</p>\n<p>optional：是否是可选依赖</p>\n<p>exclusions: 排除传递性依赖</p>\n<ul>\n<li><p>依赖范围(scope)</p>\n<p>Maven有三套classpath，编译项目主代码、编译测试代码、实际运行。依赖范围就是用来控制依赖与这三种classpath的关系.有以下几个选项：</p>\n<p>依赖范围 | 对主代码classpath有效 | 对测试classpath有效 | 对运行时classpath有效<br>——–|———————-|——————–|———————-<br>compile |         Y            |         Y          |           Y<br>test    |         N            |         Y          |           N<br>provided|         Y            |         Y          |           N<br>runtime |         N            |         Y          |           Y<br>system  |         Y            |         Y          |           N</p>\n</li>\n<li><p>传递性依赖</p>\n<p>我们在项目的pom.xml文件中声明了直接依赖，如果声明的这些依赖还依赖于其他第三方组件，在maven中，我们不用考虑这些间接依赖，也不用担心引入多余的依赖。Maven会解析各个直接依赖的pom，将那些必要的间接依赖以传递性依赖的方式引入到当前项目的classpath中。</p>\n<p>依赖范围不仅能够控制依赖与三种classpath的关系，还会对传递性依赖产生影响。比如设A依赖于B，B依赖于C，A对于B是第一直接依赖，B对于C是第二直接依赖，A对与C是传递性依赖。第一直接依赖与第二直接依赖的依赖范围决定了传递性依赖的依赖范围。如下图，最左边第一列表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间交叉单元格表示传递性依赖范围</p>\n<pre><code>| compile | test | provided | runtime\n</code></pre><p>——–|———|——|———-|———–<br>compile | compile |      |          | runtime<br>test    | test    |      |          | test<br>provided| provided|      | provided | provided<br>runtime | runtime |      |          | runtime </p>\n<p>比如，account-email 项目有一个com.icegree:greemail:1.3.1b的直接依赖，这是第一直接依赖，其依赖范围是test；而greemail又有一个javax.mail:mail:1.4的直接依赖，这是第二直接依赖，其依赖的范围是compile。根据上面的表格可以推断，javax.mail:mail:1.4是account-email的一个范围是test的传递依赖。</p>\n</li>\n<li><p>依赖调解</p>\n<p>对于一个构件，存在于不同依赖路径上。选择哪个路径上的构件就是依赖调解要解决的问题，有两种策略：</p>\n<ol>\n<li><p>路径近者优先。 比如，项目A有这样的依赖关系：A-&gt;B-&gt;C-&gt;x(1.0)、A-&gt;D-&gt;X(2.0)，对于两个版本的X，如果都引入就会造成依赖重复。根据路径近者优先的策略，X(2.0)会被引入；</p>\n</li>\n<li><p>第一声明者优先。 路径近者优先的策略不能解决所有问题，如果出现路径长度相同的情况，那么maven就会选择依赖声明在前的那个路径上的版本。</p>\n</li>\n</ol>\n</li>\n<li><p>可选依赖(optional)</p>\n<p>假设有这样的依赖关系：项目A依赖于项目B，项目B依赖于项目X，Y，B对于X和Y都是可选依赖：A-B、B-&gt;X(可选)、B-&gt;Y(可选)。那么此时，由于X、Y都是可选依赖，依赖性将不会传递，也就是说，A中不会引入X和Y。</p>\n<p>有这样一种情况符合可选依赖的场景：项目B是一个持久层的工具包，支持多种数据库，X、Y就是其依赖的数据库驱动程序，但是我们的项目A在使用这个工具包B的时候，只依赖一种数据库，故我们不需要将X和Y全部引入。这种情况下需要我们在项目A中声明实际使用的数据库驱动依赖。</p>\n</li>\n<li><p>排除依赖(exclusions)</p>\n<p>传递性依赖为我们的项目隐式的引入了很多依赖，如果我们不想引入某个传递性依赖(自己选择依赖版本)，就可以使用排除依赖。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">exclusions</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">exclusion</span>&gt;</span></div><div class=\"line\">\t    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">exclusion</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">exclusions</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>上面的代码声明了一个排除依赖。我们的项目所依赖的slf4j-log4j12会引入slf4j-api这个传递性依赖。出于版本或者其他考虑，现在不想引入这个依赖，而是由我们显示的声明，那么就可以像上面的代码那样做。</p>\n</li>\n<li><p>查看依赖</p>\n<p>通过执行<code>mvn dependency:list</code>可以查看项目已经解析的依赖；<br>通过执行<code>mvn dependency:tree</code>可以查看项目的依赖树；<br>通过执行<code>mvn dependency:analyze</code>可以查看项目中没有使用，却显示声明的依赖和项目中显示使用了却没有显示声明的依赖。</p>\n<p>在Eclispe中，可以双击pom.xml，在Dependencies和Dependency Hierarchy选项卡查看项目的依赖情况。</p>\n</li>\n</ul>\n<h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><ul>\n<li><p>仓库分类</p>\n<p>对于maven来说，仓库分为两类：本地仓库和远程仓库。本地仓库即存在于我们本地机器上的构件仓库，远程仓库就是远程机器上的构件仓库。我们的依赖(jar)都是从仓库当中下载得到的。</p>\n<p>当maven对我们的项目执行编译或者测试时，如果需要使用依赖文件，他总是基于坐标使用本地仓库的依赖文件。如果本地仓库存在此构件，则直接使用；如果本地仓库不存在此构件，或者需要更新的版本，maven会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。如果本地仓库和远程仓库都没有需要的构件，则报错。</p>\n<p>中央仓库是Maven核心自带的远程仓库，包含了绝大部分开源构件。默认情况下，当本地仓库没有maven需要的构件时，他就会从中央仓库下载。</p>\n</li>\n<li><p>仓库配置</p>\n<p>在linux上本地仓库的默认路径为：<code>~/.m2/repository/</code>  如果想要自定义本地仓库地址，可以编辑 <code>~/.m2/setting.xml</code>, 设置localRepository元素值为想要的地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</div></pre></td></tr></table></figure>\n<p>某些情况下，中央仓库无法满足项目需求，项目需要的构件可能存在于另一个远程仓库上，这是，可以在pom中配置该仓库：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>JBOSS<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Jboss<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://repository.jnoss.com/maven2<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>上面的例子中声明了一个id为JBOSS的远程仓库，任何一个仓库声明的id都必须是唯一的。release的enable值为true，表示开启Jboss仓库发布版本的下载支持；snapshots的enable值为false，表示关闭Jboss仓库快照版本的下载支持。</p>\n<p>可以声明多个远程仓库，maven会遍历这些仓库去查找所需的构件。</p>\n</li>\n</ul>\n<h2 id=\"聚合与继承\"><a href=\"#聚合与继承\" class=\"headerlink\" title=\"聚合与继承\"></a>聚合与继承</h2><ul>\n<li><p>聚合</p>\n<p>一个项目中往往不止一个模块，比如有core、util等等模块的划分。每个模块是一个独立的工程，提供了对外的接口供调用，各个模块之间有相互依赖的关系。那么，如果我们想要一次性构建项目中的两个两个模块，而不是到两个模块各自的目录下面执行mvn命令，这时候就需要maven的聚合。</p>\n<p>为了能够使用一条命令就构建core和util两个模块，我们需要额外创建一个名为aggregator的模块，然后通过该模块构建整个项目的所有模块。aggregator本身作为一个maven项目，必须有自己的pom：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.test.app<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-aggregator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modules</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>app-core<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>app-util<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">modules</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>对于聚合模块来说，packaging的值必须为pom，否则无法构建。用户可以通过在一个打包为pom的Maven项目中声明任意数量的module元素来实现模块的聚合。</p>\n<p>这里每一个module的值都是一个当前pom的相对目录。比如app-aggregator的pom路径为<code>~/app/app-aggregator/pom.xml</code>，那么app-core就对应目录<code>~/app/app-aggregator/app-core/</code>,app-util就对应目录<code>~/app/app-aggregator/app-util/</code>，这两个目录各自包含pom.xml、src/main/java等内容，可以独立构建。</p>\n<p>从聚合模块运行mvn命令，maven就会解析聚合模块的pom，分析要构建的模块，并计算出一个构建顺序，然后根据这个顺序依次构建各个模块。</p>\n</li>\n<li><p>继承</p>\n<p>在面向对象的设计中，可以在父类中声明一些字段，由子类继承使用。类似的，pom也可以声明这样一种父子结构。</p>\n<p>我们继续在<code>~/app/app-aggregator/</code>目录下创建一个名为app-parent的子目录，在该子目录中声明一个pom:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.test.app<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>App parent<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>修改app-core继承app-parent</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.test.app<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">relativePath</span>&gt;</span>../app-parent/pom.xml<span class=\"tag\">&lt;/<span class=\"name\">relativePath</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>App core<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>上述pom中parent元素声明父模块，groupId、artifactId、version指定了父模块的坐标。relativePath指定了父模块pom的相对路径。</p>\n<p>app-core中没有声明version和groupId，他隐式的从父模块继承了这两个元素。</p>\n<p>下面是可继承的pom元素：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">groupId ：项目组 ID ，项目坐标的核心元素；  </div><div class=\"line\">version ：项目版本，项目坐标的核心元素；  </div><div class=\"line\">description ：项目的描述信息；  </div><div class=\"line\">organization ：项目的组织信息；  </div><div class=\"line\">inceptionYear ：项目的创始年份；  </div><div class=\"line\">url ：项目的 url 地址  </div><div class=\"line\">develoers ：项目的开发者信息；  </div><div class=\"line\">contributors ：项目的贡献者信息；  </div><div class=\"line\">distributionManagerment ：项目的部署信息；  </div><div class=\"line\">issueManagement ：缺陷跟踪系统信息；  </div><div class=\"line\">ciManagement ：项目的持续继承信息；  </div><div class=\"line\">scm ：项目的版本控制信息；  </div><div class=\"line\">mailingListserv ：项目的邮件列表信息；  </div><div class=\"line\">properties ：自定义的 Maven 属性；  </div><div class=\"line\">dependencies ：项目的依赖配置；  </div><div class=\"line\">dependencyManagement ：醒目的依赖管理配置；  </div><div class=\"line\">repositories ：项目的仓库配置；  </div><div class=\"line\">build ：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等；  </div><div class=\"line\">reporting ：包括项目的报告输出目录配置、报告插件配置等。</div></pre></td></tr></table></figure>\n</li>\n<li><p>依赖管理与插件管理</p>\n<p>上面的列表中包含了dependencies元素，表示依赖会被继承。因此，我们可以将模块的公有依赖配置到父模块pom中，子模块就可以移除这些依赖，但这样带来一个问题，如果我们新增了模块也继承父模块的话，新增的子模块也就有可能引入了他不需要的依赖。</p>\n<p>为了解决这个问题，maven提供了dependencyManagement元素。在dependencyManagement元素下声明的依赖不会被实际引入：app-parent/pom.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.test.app<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>App parent<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.googlecode.java-diff-utils<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>diffutils<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>使用dependencyManagement声明的依赖既不会给app-parent引入依赖，也不会给他的子模块引入依赖，不过这段配置会被继承：app-core/pom.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.test.app<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">relativePath</span>&gt;</span>../app-parent/pom.xml<span class=\"tag\">&lt;/<span class=\"name\">relativePath</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>app-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>App core<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.googlecode.java-diff-utils<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>diffutils<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>可以看到子模块只需要声明dependency的groupId、artifactId，不用声明version，虽然只省去了一行配置，但是统一了项目依赖的版本，降低依赖冲突的机会。</p>\n<p>如果子模块没有声明diffutils，diffutils就不会被引入。</p>\n<p>maven还提供了pluginManagement元素帮助管理插件。与dependencyManagement的原理相同。</p>\n</li>\n<li><p>超级pom</p>\n<p>实际上，我们声明的pom都隐式的继承自超级pom，位于<code>MAVEN_HOME/lib/maven-model-builder-x.jar</code>中的<code>org/apache/maven/model/pom-4.0.0.xml</code>。</p>\n<p>在超级pom中定义了仓库和插件仓库，都是中央仓库的地址，定义了项目的主代码目录，测试目录等等项目的结构。</p>\n<p>我们可以模仿超级pom在我们自己的pom中声明这些元素，从而自定义项目结构。</p>\n</li>\n</ul>\n<h2 id=\"属性与Profile\"><a href=\"#属性与Profile\" class=\"headerlink\" title=\"属性与Profile\"></a>属性与Profile</h2><h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>属性有点类似于java中的变量。我们可以在pom中使用${属性名}的方式引用属性的值，从而消除重复，也能降低错误发生的概率。</p>\n<p>maven属性有6类：</p>\n<ul>\n<li><p>内置属性</p>\n<p>主要有${basedir}表示项目根目录，即包含pom.xml的目录；${version}表示项目的版本</p>\n</li>\n<li><p>pom属性</p>\n<p>${project.build.directory}表示主源码路径;</p>\n<p>${project.build.sourceEncoding}表示主源码的编码格式;</p>\n<p>${project.build.sourceDirectory}表示主源码路径;</p>\n<p>${project.build.finalName}表示输出文件名称;</p>\n<p>${project.version}表示项目版本,与${version}相同;</p>\n</li>\n<li><p>自定义属性</p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project.my</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在pom中的其他地方使用${project.my}就会被替换成hello</p>\n<ul>\n<li><p>settings属性</p>\n<p>与pom属性同理，用户以settings开头的属性引用settings.xml文件中的xml元素值，如${settings.localRepository}指向本地仓库地址</p>\n</li>\n<li><p>java系统属性</p>\n<p>所有java系统属性都可以使用maven属性引用。如${user.home}指向用户目录</p>\n</li>\n<li><p>环境变量属性</p>\n<p>所有环境变量都可以用以env开头的属性引用。如${env.JAVA_HOME}</p>\n</li>\n</ul>\n<h3 id=\"资源过滤\"><a href=\"#资源过滤\" class=\"headerlink\" title=\"资源过滤\"></a>资源过滤</h3><p>一般情况下，我们习惯于在src/main/resources/目录下放置配置文件，在配置文件中，我们可能配置数据库的url，用户名密码等信息。但是在不同的环境中，这些数据库的配置常常会变动，比如在测试环境或者运行环境中。比较原始的做法手动更改这些配置，但是这样的方法比较低下也容易出错。maven可以在构建过程中针对不同的环境激活不同的配置。</p>\n<p>首先需要使用maven属性将会发生变化的部分提取出来：在数据库配置文件中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.jdbc.driver=$&#123;db.driver&#125;</div><div class=\"line\">db.jdbc.url=$&#123;db.url&#125;</div></pre></td></tr></table></figure>\n<p>这里定义了两个属性：db.driver、db.url</p>\n<p>既然定义了maven属性，我们需要在某个地方为其赋值。与自定义属性不同的是，这里需要做的是使用profile将其包裹：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>pro_A<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">db.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">db.driver</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">db.url</span>&gt;</span>jdbc:mysql://localhost:3306<span class=\"tag\">&lt;/<span class=\"name\">db.url</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>那么这个profile是在哪里声明的呢？有三个地方：</p>\n<ul>\n<li><p>pom.xml: pom中的profile只对当前项目有效</p>\n</li>\n<li><p>用户settings.xml: 用户目录下<code>.m2/settings.xml</code>中的profile对该用户的所有maven项目有效</p>\n</li>\n<li><p>全局settings.xml: maven安装目录下<code>conf/settings.xml</code>中的profile对本机上所有maven项目有效</p>\n</li>\n</ul>\n<p>在配置文件中定义了maven属性，也在profile中为其赋值了，此时要做的是打开资源过滤：</p>\n<p>资源文件的处理实际上是maven-resources-plugin插件所做的事情，他的默认行为只是将项目主资源文件复制到主代码编译输出目录中，将测试资源文件复制到测试代码编译输出目录中。我们需要一些配置，使得该插件能够解析资源文件中的maven属性，开启资源过滤。</p>\n<p>maven默认的资源目录是在超级pom中定义的，要开启资源目录过滤，需要如下配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">filtering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtering</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>上述代码为主资源目录开启了资源过滤，类似的我们可以为多个资源目录提供过滤配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">filtering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtering</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/sql<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">filtering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtering</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>在配置文件中定义了maven属性，在profile中为属性赋值，并且为资源目录开启了资源过滤，接下来只需要在命令行激活profile：<code>mvn clean test -Ppro_A</code>.</p>\n<p>mvn命令中的-P参数激活了一个名为pro_A的profile。maven在构建项目的时候就会使用profile中的属性值替换在配置文件中的属性定义，然后将其复制到编译输出目录当中。</p>\n<h3 id=\"profile\"><a href=\"#profile\" class=\"headerlink\" title=\"profile\"></a>profile</h3><p>我们可以想到，针对不同的环境定义不同的profile，然后在不同的环境中通过命令行激活对应的profile，就能达到灵活切换配置的目的。除了命令行手动激活profile以外，还有下面几种方式能够激活profile：</p>\n<ul>\n<li><p>默认激活</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>pro_A<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">activeByDefault</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">activeByDefault</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">db.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">db.driver</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">db.url</span>&gt;</span>jdbc:mysql://localhost:3306<span class=\"tag\">&lt;/<span class=\"name\">db.url</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>activeByDefault指定profile自动激活。但是如果pom中的任意一个profile通过其他方式被激活了，那么默认的激活配置失效。</p>\n</li>\n<li><p>属性激活</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>pro_A<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>x<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">db.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">db.driver</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">db.url</span>&gt;</span>jdbc:mysql://localhost:3306<span class=\"tag\">&lt;/<span class=\"name\">db.url</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>属性test存在且值为x时激活该profile。利用这个特性可以在命令行同时激活多个profile：<code>mvn clean test -Dtest=x</code></p>\n</li>\n<li><p>settings文件激活</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></div><div class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">activeProfiles</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">activeProfile</span>&gt;</span>pro_x<span class=\"tag\">&lt;/<span class=\"name\">activeProfile</span>&gt;</span></div><div class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">activeProfiles</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在settings.xml文件中配置，表示其配置的profile对所有项目处于激活状态。</p>\n</li>\n</ul>\n<p>在profile中不仅可以添加或者修改maven属性，还可以对其他maven元素进行设置。</p>\n<ul>\n<li><p>pom中的profile可以使用的元素：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">pluginRepositories</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">pluginRepositories</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">distributionManagement</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">distributionManagement</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modules</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">modules</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">reporting</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">reporting</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">defaultGoal</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">defaultGoal</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">testResources</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">testResources</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">finalName</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">finalName</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>其他profile可以使用的元素</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">pluginRepositories</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">pluginRepositories</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>"},{"layout":"post","title":"maven学习笔记(一)","date":"2017-04-17T12:51:25.000Z","_content":"\n> 上周末两天时间基本上将《Maven实战》这本书看完了。《Maven实战》是很棒的一本介绍maven相关知识的书籍。读完之后，对学到的maven相关的内容做一个梳理总结。\n\n## Maven基础\n\n有关[Maven](http://maven.apache.org/)如何安装和设置，不在这里啰嗦了，可以到[官网](http://maven.apache.org/)下载最新版本然后安装。\n\nMaven是一个异常强大的构建工具，能够帮助我们自动化构建过程，从清理、编译、测试到生成报告，打包和部署。我们要做的只是使用Maven配置好项目，然后输入简单的命令，Maven会帮我们处理这些任务。\n\nMaven项目的核心是pom.xml。Pom定义了项目的基本信息，用于描述项目如何构建，声明项目依赖等。下面是一个例子：\n<!-- more -->\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\n\t<groupId>space.yukai.mergetool</groupId>\n\t<artifactId>mergetool-core</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<packaging>jar</packaging>\n    <name>MergeTool</name>\n\n\t<name>space.yukai</name>\n\t<url>http://maven.apache.org</url>\n\n\t<properties>\n\t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n\t</properties>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n\t\t\t\t<configuration>\n\t\t\t\t\t<source>1.8</source>\n\t\t\t\t\t<target>1.8</target>\n\t\t\t\t</configuration>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>junit</groupId>\n\t\t\t<artifactId>junit</artifactId>\n\t\t\t<version>4.4</version>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\n\t\t<!-- https://mvnrepository.com/artifact/commons-io/commons-io -->\n\t\t<dependency>\n\t\t\t<groupId>commons-io</groupId>\n\t\t\t<artifactId>commons-io</artifactId>\n\t\t\t<version>2.5</version>\n\t\t</dependency>\n\t</dependencies>\n</project>\n\n```\n\nMaven不仅是一个构建工具，还是一个依赖管理工具和项目信息管理工具。我们的java项目或多或少都会依赖一些第三方的类库，而maven提供了中央仓库，能够帮助我们自动下载构件。\n\nMaven通过一个坐标系统准确的定位每一个构件(artifact)，也就是通过一组坐标Maven能够找到任何一个java类库(如jar包)。\n\n在Maven的世界中，任何的jar、pom、或war都是通过这些坐标进行区分的。上面代码中开头的groupId、artifactId、version定义了这个项目的基本坐标。\n\n- groupId定义了项目属于哪个组，这个组往往和项目所在的组织有关联。比如Googlecode上面建立了一个项目app，那么groupId就应该为com.googlecode.app\n\n- artifactId定义了当前项目在组中的唯一Id。比如为app中不同的子项目分配artifactId，如app-core、app-util、app-web\n\n- version指定了项目当前的版本。SNAPSHOT表示项目还处于开发中，是不稳定的版本\n\n- packaging指定了项目的打包方式，默认为jar\n\n- name定义了项目名称\n\n上面dependency标签中的内容就是本项目声明的依赖。可以看到dependency标签中声明了groupId、artifactId、version这三个属性，比如commons-io，Maven解析到这个依赖时，就会根据这个坐标去本地仓库查找这个坐标下的依赖是否已经被下载，如果没有下载，那么到中央仓库去下载依赖的jar包到本地仓库，然后把下载好的jar包路径添加到classpath当中。这些工作都是自动进行的，我们要做的，只是在pom.xml中声明这个依赖即可。\n\nMaven在项目构建过程和过程的各个阶段的工作都是由插件实现的，并且大部分的插件都是现成的。我们只需要声明项目的基本元素，Maven就会执行内置的构建过程。上面代码中plugin标签中的内容，是对maven-compiler-plugin这个插件进行的配置。\n\n## Archetype\n\nMaven提倡 \"约定优于配置\"。遵循Maven的一些约定，我们可以快速的创建项目并完成构建。对于遵循约定的Maven项目，我们可以快速的了解其结构，减轻了我们的学习成本。\n\n比如：在项目的根目录放置pom.xml，在src/main/java目录放置项目主代码，在src/test/java放置项目测试代码。我们称这些基本的目录结构为项目骨架。通过Archetype插件可以帮助我们快速的创建出项目骨架。\n\n运行`mvn archetype:generate`命令，选择我们的项目骨架。\n\n```\nC:\\Users\\kyu\\Desktop\\test>mvn archetype:generate\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building Maven Stub Project (No POM) 1\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] >>> maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom >>>\n[INFO]\n[INFO] <<< maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom <<<\n[INFO]\n[INFO] --- maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom ---\n[INFO] Generating project in Interactive mode\n[INFO] No archetype defined. Using maven-archetype-quickstart (org.apache.maven.archetypes:maven-archetype-quickstart:1.0)\nChoose archetype:\n1: remote -> am.ik.archetype:maven-reactjs-blank-archetype (Blank Project for React.js)\n2: remote -> am.ik.archetype:msgpack-rpc-jersey-blank-archetype (Blank Project for Spring Boot + Jersey)\n3: remote -> am.ik.archetype:mvc-1.0-blank-archetype (MVC 1.0 Blank Project)\n4: remote -> am.ik.archetype:spring-boot-blank-archetype (Blank Project for Spring Boot)\n5: remote -> am.ik.archetype:spring-boot-docker-blank-archetype (Docker Blank Project for Spring Boot)\n6: remote -> am.ik.archetype:spring-boot-gae-blank-archetype (GAE Blank Project for Spring Boot)\n7: remote -> am.ik.archetype:spring-boot-jersey-blank-archetype (Blank Project for Spring Boot + Jersey)\n8: remote -> at.chrl.archetypes:chrl-spring-sample (Archetype for Spring Vaadin Webapps)\n9: remote -> br.com.address.archetypes:struts2-archetype (an archetype web 3.0 + struts2 (bootstrap + jquery) + JPA 2.1 with struts2 login system)\n10: remote -> br.com.address.archetypes:struts2-base-archetype (An Archetype with JPA 2.1; Struts2 core 2.3.28.1; Jquery struts plugin; Struts BootStrap plugin; json Struts plugin;\n.\n.\n.\n1813: remote -> us.fatehi:schemacrawler-archetype-plugin-command (-)\n1814: remote -> us.fatehi:schemacrawler-archetype-plugin-dbconnector (-)\n1815: remote -> us.fatehi:schemacrawler-archetype-plugin-lint (-)\nChoose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 955:\n```\n\n默认为maven-archetype-quickstart(955)。选择该Archetype，Maven会提示输入创建项目的groupId、artifactId、version及包名package。\n\n在当前目录下，Archetype插件会创建以artifactId命名的子目录：\n\n{% asset_img mvn.png artifact %}\n\n可以看出，使用约定俗成的Archetype，不仅使用Maven插件代替了原本需要手工处理的劳动，同时节省了时间，降低了错误发生的概率。\n\n也可以定义自己的项目骨架，在创建项目的时候，就可以直接使用该Archetype。\n\n## 生命周期\n\nMaven的生命周期对所有的构建过程进行了抽象和统一。这个生命周期包括项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等所有的构建步骤。所有的项目构建，都可以映射到这样一个生命周期上。\n\nMaven只是抽象出了生命周期，生命周期中实际的任务都是交给插件完成的，类似于设计模式中的模板方法模式。\n\nMaven拥有三套独立的生命周期：clean、default、site。每个生命周期包含一些阶段：\n\n- clean\n\n  pre-clean  执行一些清理前需要完成的工作\n\n  clean  清理上一次构建生成的文件\n\n  post-clean   执行一些清理后需要完成的工作\n\n- default\n  \n  validate\t检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。\n\n  initialize\t初始化构建状态，例如设置属性。\n\n  generate-sources\t生成编译阶段需要包含的任何源码文件。\n\n  process-sources\t处理源代码，例如，过滤任何值（filter any value）。\n\n  generate-resources\t生成工程包中需要包含的资源文件。\n\n  process-resources\t拷贝和处理资源文件到目的目录中，为打包阶段做准备。\n\n  compile\t编译工程源码。\n\n  process-classes\t处理编译生成的文件，例如 Java Class 字节码的加强和优化。\n\n  generate-test-sources\t生成编译阶段需要包含的任何测试源代码。\n\n  process-test-sources\t处理测试源代码，例如，过滤任何值（filter any values)。\n\n  test-compile\t编译测试源代码到测试目的目录。\n\n  process-test-classes\t处理测试代码文件编译后生成的文件。\n\n  test\t使用适当的单元测试框架（例如JUnit）运行测试。\n\n  prepare-package\t在真正打包之前，为准备打包执行任何必要的操作。\n\n  package\t获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR 或者 EAR 文件。\n\n  pre-integration-test\t在集成测试执行之前，执行所需的操作。例如，设置所需的环境变量。\n\n  integration-test\t处理和部署必须的工程包到集成测试能够运行的环境中。\n\n  post-integration-test\t在集成测试被执行后执行必要的操作。例如，清理环境。\n\n  verify\t运行检查操作来验证工程包是有效的，并满足质量要求。\n\n  install\t安装工程包到本地仓库中，该仓库可以作为本地其他工程的依赖。\n\n  deploy\t拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。\n\n- site\n\n  pre-site  执行一些生成项目站点前需要完成的工作\n\n  site  生成项目站点文档\n\n  post-site  执行一些生成项目站点前需要完成的工作\n\n  site-deploy  将生成的站点发布到服务器\n\n每个生命周期的阶段是有顺序的，后面的阶段依赖前面的阶段。使用maven最直接的交互方式就是调用这些生命周期的阶段。比如，当用户调用pre-clean时，只有pre-clean阶段得以执行，当调用clean时，pre-clean和clean依次执行，当调用post-clean时，pre-clean、clean和post-clean依次执行。\n\n虽然每个生命周期内的阶段是有顺序和前后依赖的，但是三套生命周期之间是互相独立的。比如，当用户调用clean生命周期的clean阶段时，不会触发default生命周期的任何阶段，反之，当用户调用default生命周期的compile阶段时，也不会触发clean生命周期的任何阶段。\n\n`mvn clean install`，该命令调用了clean生命周期clean阶段与default生命周期install 阶段。实际执行的阶段为clean生命周期的pre-clean、clean阶段，以及default生命周期从validate到install所有阶段。\n\n## 插件目标\n\nMaven的核心仅仅定义了抽象的生命周期，具体的任务是由插件来完成的。\n\n每个插件可以完成多个功能，每个功能就是插件的一个目标。比如maven-dependency-plugin可以列出项目依赖树，列出所有已解析的依赖等等。这两个目标对应的命令为：\n\n`mvn dependency:tree`，`mvn dependency:list`。冒号前面是插件前缀，冒号后面是插件目标。\n\n所以，我们知道了mvn命令有两种调用方式，一种调用其生命周期，一种直接调用插件目标。\n\n插件的生命周期与插件相互绑定，完成实际的构建任务。调用生命周期实际上也是执行了多个插件目标。\n\n- 内置绑定\n\n  Maven核心已经对一些主要的生命周期阶段绑定了很多插件目标，当用户通过命令行调用生命周期的时候，对应的插件目标就会执行相应的任务。\n\n  比如，clean生命周期有pre-clean、clean、post-clean三个阶段，clean生命周期阶段与插件目标的绑定关系如下：\n\n  生命周期阶段 | 插件目标\n  ------------|-----------\n  pre-clean   |\n  clean       |maven-clean-plugin:clean\n  post-clean  |\n\n  执行命令`mvn post-clean`，输出如下：\n\n  ```\n  [INFO] ------------------------------------------------------------------------\n  [INFO] Building space.yukai 0.0.1-SNAPSHOT\n  [INFO] ------------------------------------------------------------------------\n  [INFO] \n  [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ space.yukai ---\n  [INFO] ------------------------------------------------------------------------\n  [INFO] BUILD SUCCESS\n  [INFO] ------------------------------------------------------------------------\n  [INFO] Total time: 0.409 s\n  [INFO] Finished at: 2017-04-17T16:37:08+08:00\n  [INFO] Final Memory: 7M/106M\n  [INFO] ------------------------------------------------------------------------\n  ```\n  从输出中可以看到，执行的插件目标仅为`maven-clean-plugin:clean`\n\n- 自定义绑定\n\n  除了内置绑定之外，用户可以自己选择将某个插件目标绑定到生命周期的某个阶段。\n\n  比如，我们可以自行配置创建项目的源码jar包。maven-source-plugin的jar-no-fork目标可以将项目的主代码打包成jar文件。我们将其绑定到clean生命周期的post-clean阶段测试一下：\n\n  ```xml\n  <plugin>\n\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t<artifactId>maven-source-plugin</artifactId>\n\t\t<executions>\n\t\t\t    <execution>\n\t\t\t\t    <id>attach-source</id>\n\t\t\t\t    <phase>post-clean</phase>\n\t\t\t\t        goals>\n\t\t\t\t        <goal>jar-no-fork</goal>\n\t\t\t\t    </goals>\n\t\t\t </execution>\n\t\t</executions>\n  </plugin>\n  ```\n\n  运行`mvn post-clean`，输出：\n\n  ```\n  [INFO] ------------------------------------------------------------------------\n  [INFO] Building space.yukai 0.0.1-SNAPSHOT\n  [INFO] ------------------------------------------------------------------------\n  [INFO] \n  [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ space.yukai ---\n  [INFO] Deleting Y:\\code\\versionmergetool\\VersionMergeTool\\target\n  [INFO] \n  [INFO] --- maven-source-plugin:3.0.1:jar-no-fork (attach-source) @ space.yukai ---\n  [INFO] Building jar: Y:\\code\\versionmergetool\\VersionMergeTool\\target\\space.yukai-0.0.1-SNAPSHOT-sources.jar\n  [INFO] ------------------------------------------------------------------------\n  [INFO] BUILD SUCCESS\n  [INFO] ------------------------------------------------------------------------\n  [INFO] Total time: 1.082 s\n  [INFO] Finished at: 2017-04-17T16:55:32+08:00\n  [INFO] Final Memory: 7M/111M\n  [INFO] ------------------------------------------------------------------------\n  ```\n\n  可以看到，当执行post-clean阶段的时候，maven-source-plugin:jar-no-fork 创建了一个以-sources.jar结尾的源码包。\n\n为了了解插件有哪些配置，我们可以使用maven-help-plugin来获取插件信息。\n\n运行命令`mvn help:describe -Dplugin=compiler`\n\n```\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building mvntest-test 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-help-plugin:2.2:describe (default-cli) @ mvntest-test ---\n[INFO] org.apache.maven.plugins:maven-compiler-plugin:3.6.1\n\nName: Apache Maven Compiler Plugin\nDescription: The Compiler Plugin is used to compile the sources of your\n  project.\nGroup Id: org.apache.maven.plugins\nArtifact Id: maven-compiler-plugin\nVersion: 3.6.1\nGoal Prefix: compiler\n\nThis plugin has 3 goals:\n\ncompiler:compile\n  Description: Compiles application sources\n\ncompiler:help\n  Description: Display help information on maven-compiler-plugin.\n    Call mvn compiler:help -Ddetail=true -Dgoal=<goal-name> to display\n    parameter details.\n\ncompiler:testCompile\n  Description: Compiles application test sources.\n\nFor more information, run 'mvn help:describe [...] -Ddetail'\n\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 5.944s\n[INFO] Finished at: Mon Apr 17 17:02:52 CST 2017\n[INFO] Final Memory: 11M/110M\n[INFO] ------------------------------------------------------------------------\n```\n可以得到插件maven-compiler-plugin的信息及相关目标。还可以加上detail参数输出更详细的信息`mvn help:describe -Dplugin=compiler -Ddetail`\n\n- 前缀\n\n  笔记开头说了，在maven的世界中，所有的构件都是由坐标来确定的，构件包括依赖的jar或者插件。那么我们上面的`mvn help:describe -Dplugin=compiler`中并没有指定插件的坐标，为什么能够正常的运行呢？\n\n  其实`mvn help:describe -Dplugin=compiler`就等效于`mvn org.apache.maven.plugins:maven-help-plugin:2.2:describe -Dplugin=compiler`。help就是maven-help-plugin的前缀，maven能够根据这个前缀找到对应的artifactId，从而解析得到groupId和version，所有能够精确的定位某个插件。compiler也是前缀。\n\n","source":"_posts/maven学习笔记.md","raw":"---\nlayout: post\ntitle: maven学习笔记(一)\ndate: 2017-04-17 20:51:25\ncategories: 工具\ntags: \n- java\n- maven \n---\n\n> 上周末两天时间基本上将《Maven实战》这本书看完了。《Maven实战》是很棒的一本介绍maven相关知识的书籍。读完之后，对学到的maven相关的内容做一个梳理总结。\n\n## Maven基础\n\n有关[Maven](http://maven.apache.org/)如何安装和设置，不在这里啰嗦了，可以到[官网](http://maven.apache.org/)下载最新版本然后安装。\n\nMaven是一个异常强大的构建工具，能够帮助我们自动化构建过程，从清理、编译、测试到生成报告，打包和部署。我们要做的只是使用Maven配置好项目，然后输入简单的命令，Maven会帮我们处理这些任务。\n\nMaven项目的核心是pom.xml。Pom定义了项目的基本信息，用于描述项目如何构建，声明项目依赖等。下面是一个例子：\n<!-- more -->\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\n\t<groupId>space.yukai.mergetool</groupId>\n\t<artifactId>mergetool-core</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<packaging>jar</packaging>\n    <name>MergeTool</name>\n\n\t<name>space.yukai</name>\n\t<url>http://maven.apache.org</url>\n\n\t<properties>\n\t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n\t</properties>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n\t\t\t\t<configuration>\n\t\t\t\t\t<source>1.8</source>\n\t\t\t\t\t<target>1.8</target>\n\t\t\t\t</configuration>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>junit</groupId>\n\t\t\t<artifactId>junit</artifactId>\n\t\t\t<version>4.4</version>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\n\t\t<!-- https://mvnrepository.com/artifact/commons-io/commons-io -->\n\t\t<dependency>\n\t\t\t<groupId>commons-io</groupId>\n\t\t\t<artifactId>commons-io</artifactId>\n\t\t\t<version>2.5</version>\n\t\t</dependency>\n\t</dependencies>\n</project>\n\n```\n\nMaven不仅是一个构建工具，还是一个依赖管理工具和项目信息管理工具。我们的java项目或多或少都会依赖一些第三方的类库，而maven提供了中央仓库，能够帮助我们自动下载构件。\n\nMaven通过一个坐标系统准确的定位每一个构件(artifact)，也就是通过一组坐标Maven能够找到任何一个java类库(如jar包)。\n\n在Maven的世界中，任何的jar、pom、或war都是通过这些坐标进行区分的。上面代码中开头的groupId、artifactId、version定义了这个项目的基本坐标。\n\n- groupId定义了项目属于哪个组，这个组往往和项目所在的组织有关联。比如Googlecode上面建立了一个项目app，那么groupId就应该为com.googlecode.app\n\n- artifactId定义了当前项目在组中的唯一Id。比如为app中不同的子项目分配artifactId，如app-core、app-util、app-web\n\n- version指定了项目当前的版本。SNAPSHOT表示项目还处于开发中，是不稳定的版本\n\n- packaging指定了项目的打包方式，默认为jar\n\n- name定义了项目名称\n\n上面dependency标签中的内容就是本项目声明的依赖。可以看到dependency标签中声明了groupId、artifactId、version这三个属性，比如commons-io，Maven解析到这个依赖时，就会根据这个坐标去本地仓库查找这个坐标下的依赖是否已经被下载，如果没有下载，那么到中央仓库去下载依赖的jar包到本地仓库，然后把下载好的jar包路径添加到classpath当中。这些工作都是自动进行的，我们要做的，只是在pom.xml中声明这个依赖即可。\n\nMaven在项目构建过程和过程的各个阶段的工作都是由插件实现的，并且大部分的插件都是现成的。我们只需要声明项目的基本元素，Maven就会执行内置的构建过程。上面代码中plugin标签中的内容，是对maven-compiler-plugin这个插件进行的配置。\n\n## Archetype\n\nMaven提倡 \"约定优于配置\"。遵循Maven的一些约定，我们可以快速的创建项目并完成构建。对于遵循约定的Maven项目，我们可以快速的了解其结构，减轻了我们的学习成本。\n\n比如：在项目的根目录放置pom.xml，在src/main/java目录放置项目主代码，在src/test/java放置项目测试代码。我们称这些基本的目录结构为项目骨架。通过Archetype插件可以帮助我们快速的创建出项目骨架。\n\n运行`mvn archetype:generate`命令，选择我们的项目骨架。\n\n```\nC:\\Users\\kyu\\Desktop\\test>mvn archetype:generate\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building Maven Stub Project (No POM) 1\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] >>> maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom >>>\n[INFO]\n[INFO] <<< maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom <<<\n[INFO]\n[INFO] --- maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom ---\n[INFO] Generating project in Interactive mode\n[INFO] No archetype defined. Using maven-archetype-quickstart (org.apache.maven.archetypes:maven-archetype-quickstart:1.0)\nChoose archetype:\n1: remote -> am.ik.archetype:maven-reactjs-blank-archetype (Blank Project for React.js)\n2: remote -> am.ik.archetype:msgpack-rpc-jersey-blank-archetype (Blank Project for Spring Boot + Jersey)\n3: remote -> am.ik.archetype:mvc-1.0-blank-archetype (MVC 1.0 Blank Project)\n4: remote -> am.ik.archetype:spring-boot-blank-archetype (Blank Project for Spring Boot)\n5: remote -> am.ik.archetype:spring-boot-docker-blank-archetype (Docker Blank Project for Spring Boot)\n6: remote -> am.ik.archetype:spring-boot-gae-blank-archetype (GAE Blank Project for Spring Boot)\n7: remote -> am.ik.archetype:spring-boot-jersey-blank-archetype (Blank Project for Spring Boot + Jersey)\n8: remote -> at.chrl.archetypes:chrl-spring-sample (Archetype for Spring Vaadin Webapps)\n9: remote -> br.com.address.archetypes:struts2-archetype (an archetype web 3.0 + struts2 (bootstrap + jquery) + JPA 2.1 with struts2 login system)\n10: remote -> br.com.address.archetypes:struts2-base-archetype (An Archetype with JPA 2.1; Struts2 core 2.3.28.1; Jquery struts plugin; Struts BootStrap plugin; json Struts plugin;\n.\n.\n.\n1813: remote -> us.fatehi:schemacrawler-archetype-plugin-command (-)\n1814: remote -> us.fatehi:schemacrawler-archetype-plugin-dbconnector (-)\n1815: remote -> us.fatehi:schemacrawler-archetype-plugin-lint (-)\nChoose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 955:\n```\n\n默认为maven-archetype-quickstart(955)。选择该Archetype，Maven会提示输入创建项目的groupId、artifactId、version及包名package。\n\n在当前目录下，Archetype插件会创建以artifactId命名的子目录：\n\n{% asset_img mvn.png artifact %}\n\n可以看出，使用约定俗成的Archetype，不仅使用Maven插件代替了原本需要手工处理的劳动，同时节省了时间，降低了错误发生的概率。\n\n也可以定义自己的项目骨架，在创建项目的时候，就可以直接使用该Archetype。\n\n## 生命周期\n\nMaven的生命周期对所有的构建过程进行了抽象和统一。这个生命周期包括项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等所有的构建步骤。所有的项目构建，都可以映射到这样一个生命周期上。\n\nMaven只是抽象出了生命周期，生命周期中实际的任务都是交给插件完成的，类似于设计模式中的模板方法模式。\n\nMaven拥有三套独立的生命周期：clean、default、site。每个生命周期包含一些阶段：\n\n- clean\n\n  pre-clean  执行一些清理前需要完成的工作\n\n  clean  清理上一次构建生成的文件\n\n  post-clean   执行一些清理后需要完成的工作\n\n- default\n  \n  validate\t检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。\n\n  initialize\t初始化构建状态，例如设置属性。\n\n  generate-sources\t生成编译阶段需要包含的任何源码文件。\n\n  process-sources\t处理源代码，例如，过滤任何值（filter any value）。\n\n  generate-resources\t生成工程包中需要包含的资源文件。\n\n  process-resources\t拷贝和处理资源文件到目的目录中，为打包阶段做准备。\n\n  compile\t编译工程源码。\n\n  process-classes\t处理编译生成的文件，例如 Java Class 字节码的加强和优化。\n\n  generate-test-sources\t生成编译阶段需要包含的任何测试源代码。\n\n  process-test-sources\t处理测试源代码，例如，过滤任何值（filter any values)。\n\n  test-compile\t编译测试源代码到测试目的目录。\n\n  process-test-classes\t处理测试代码文件编译后生成的文件。\n\n  test\t使用适当的单元测试框架（例如JUnit）运行测试。\n\n  prepare-package\t在真正打包之前，为准备打包执行任何必要的操作。\n\n  package\t获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR 或者 EAR 文件。\n\n  pre-integration-test\t在集成测试执行之前，执行所需的操作。例如，设置所需的环境变量。\n\n  integration-test\t处理和部署必须的工程包到集成测试能够运行的环境中。\n\n  post-integration-test\t在集成测试被执行后执行必要的操作。例如，清理环境。\n\n  verify\t运行检查操作来验证工程包是有效的，并满足质量要求。\n\n  install\t安装工程包到本地仓库中，该仓库可以作为本地其他工程的依赖。\n\n  deploy\t拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。\n\n- site\n\n  pre-site  执行一些生成项目站点前需要完成的工作\n\n  site  生成项目站点文档\n\n  post-site  执行一些生成项目站点前需要完成的工作\n\n  site-deploy  将生成的站点发布到服务器\n\n每个生命周期的阶段是有顺序的，后面的阶段依赖前面的阶段。使用maven最直接的交互方式就是调用这些生命周期的阶段。比如，当用户调用pre-clean时，只有pre-clean阶段得以执行，当调用clean时，pre-clean和clean依次执行，当调用post-clean时，pre-clean、clean和post-clean依次执行。\n\n虽然每个生命周期内的阶段是有顺序和前后依赖的，但是三套生命周期之间是互相独立的。比如，当用户调用clean生命周期的clean阶段时，不会触发default生命周期的任何阶段，反之，当用户调用default生命周期的compile阶段时，也不会触发clean生命周期的任何阶段。\n\n`mvn clean install`，该命令调用了clean生命周期clean阶段与default生命周期install 阶段。实际执行的阶段为clean生命周期的pre-clean、clean阶段，以及default生命周期从validate到install所有阶段。\n\n## 插件目标\n\nMaven的核心仅仅定义了抽象的生命周期，具体的任务是由插件来完成的。\n\n每个插件可以完成多个功能，每个功能就是插件的一个目标。比如maven-dependency-plugin可以列出项目依赖树，列出所有已解析的依赖等等。这两个目标对应的命令为：\n\n`mvn dependency:tree`，`mvn dependency:list`。冒号前面是插件前缀，冒号后面是插件目标。\n\n所以，我们知道了mvn命令有两种调用方式，一种调用其生命周期，一种直接调用插件目标。\n\n插件的生命周期与插件相互绑定，完成实际的构建任务。调用生命周期实际上也是执行了多个插件目标。\n\n- 内置绑定\n\n  Maven核心已经对一些主要的生命周期阶段绑定了很多插件目标，当用户通过命令行调用生命周期的时候，对应的插件目标就会执行相应的任务。\n\n  比如，clean生命周期有pre-clean、clean、post-clean三个阶段，clean生命周期阶段与插件目标的绑定关系如下：\n\n  生命周期阶段 | 插件目标\n  ------------|-----------\n  pre-clean   |\n  clean       |maven-clean-plugin:clean\n  post-clean  |\n\n  执行命令`mvn post-clean`，输出如下：\n\n  ```\n  [INFO] ------------------------------------------------------------------------\n  [INFO] Building space.yukai 0.0.1-SNAPSHOT\n  [INFO] ------------------------------------------------------------------------\n  [INFO] \n  [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ space.yukai ---\n  [INFO] ------------------------------------------------------------------------\n  [INFO] BUILD SUCCESS\n  [INFO] ------------------------------------------------------------------------\n  [INFO] Total time: 0.409 s\n  [INFO] Finished at: 2017-04-17T16:37:08+08:00\n  [INFO] Final Memory: 7M/106M\n  [INFO] ------------------------------------------------------------------------\n  ```\n  从输出中可以看到，执行的插件目标仅为`maven-clean-plugin:clean`\n\n- 自定义绑定\n\n  除了内置绑定之外，用户可以自己选择将某个插件目标绑定到生命周期的某个阶段。\n\n  比如，我们可以自行配置创建项目的源码jar包。maven-source-plugin的jar-no-fork目标可以将项目的主代码打包成jar文件。我们将其绑定到clean生命周期的post-clean阶段测试一下：\n\n  ```xml\n  <plugin>\n\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t<artifactId>maven-source-plugin</artifactId>\n\t\t<executions>\n\t\t\t    <execution>\n\t\t\t\t    <id>attach-source</id>\n\t\t\t\t    <phase>post-clean</phase>\n\t\t\t\t        goals>\n\t\t\t\t        <goal>jar-no-fork</goal>\n\t\t\t\t    </goals>\n\t\t\t </execution>\n\t\t</executions>\n  </plugin>\n  ```\n\n  运行`mvn post-clean`，输出：\n\n  ```\n  [INFO] ------------------------------------------------------------------------\n  [INFO] Building space.yukai 0.0.1-SNAPSHOT\n  [INFO] ------------------------------------------------------------------------\n  [INFO] \n  [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ space.yukai ---\n  [INFO] Deleting Y:\\code\\versionmergetool\\VersionMergeTool\\target\n  [INFO] \n  [INFO] --- maven-source-plugin:3.0.1:jar-no-fork (attach-source) @ space.yukai ---\n  [INFO] Building jar: Y:\\code\\versionmergetool\\VersionMergeTool\\target\\space.yukai-0.0.1-SNAPSHOT-sources.jar\n  [INFO] ------------------------------------------------------------------------\n  [INFO] BUILD SUCCESS\n  [INFO] ------------------------------------------------------------------------\n  [INFO] Total time: 1.082 s\n  [INFO] Finished at: 2017-04-17T16:55:32+08:00\n  [INFO] Final Memory: 7M/111M\n  [INFO] ------------------------------------------------------------------------\n  ```\n\n  可以看到，当执行post-clean阶段的时候，maven-source-plugin:jar-no-fork 创建了一个以-sources.jar结尾的源码包。\n\n为了了解插件有哪些配置，我们可以使用maven-help-plugin来获取插件信息。\n\n运行命令`mvn help:describe -Dplugin=compiler`\n\n```\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building mvntest-test 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-help-plugin:2.2:describe (default-cli) @ mvntest-test ---\n[INFO] org.apache.maven.plugins:maven-compiler-plugin:3.6.1\n\nName: Apache Maven Compiler Plugin\nDescription: The Compiler Plugin is used to compile the sources of your\n  project.\nGroup Id: org.apache.maven.plugins\nArtifact Id: maven-compiler-plugin\nVersion: 3.6.1\nGoal Prefix: compiler\n\nThis plugin has 3 goals:\n\ncompiler:compile\n  Description: Compiles application sources\n\ncompiler:help\n  Description: Display help information on maven-compiler-plugin.\n    Call mvn compiler:help -Ddetail=true -Dgoal=<goal-name> to display\n    parameter details.\n\ncompiler:testCompile\n  Description: Compiles application test sources.\n\nFor more information, run 'mvn help:describe [...] -Ddetail'\n\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 5.944s\n[INFO] Finished at: Mon Apr 17 17:02:52 CST 2017\n[INFO] Final Memory: 11M/110M\n[INFO] ------------------------------------------------------------------------\n```\n可以得到插件maven-compiler-plugin的信息及相关目标。还可以加上detail参数输出更详细的信息`mvn help:describe -Dplugin=compiler -Ddetail`\n\n- 前缀\n\n  笔记开头说了，在maven的世界中，所有的构件都是由坐标来确定的，构件包括依赖的jar或者插件。那么我们上面的`mvn help:describe -Dplugin=compiler`中并没有指定插件的坐标，为什么能够正常的运行呢？\n\n  其实`mvn help:describe -Dplugin=compiler`就等效于`mvn org.apache.maven.plugins:maven-help-plugin:2.2:describe -Dplugin=compiler`。help就是maven-help-plugin的前缀，maven能够根据这个前缀找到对应的artifactId，从而解析得到groupId和version，所有能够精确的定位某个插件。compiler也是前缀。\n\n","slug":"maven学习笔记","published":1,"updated":"2017-04-19T04:00:12.882Z","comments":1,"photos":[],"link":"","_id":"cj4vch4fv003kx3gcma546ka1","content":"<blockquote>\n<p>上周末两天时间基本上将《Maven实战》这本书看完了。《Maven实战》是很棒的一本介绍maven相关知识的书籍。读完之后，对学到的maven相关的内容做一个梳理总结。</p>\n</blockquote>\n<h2 id=\"Maven基础\"><a href=\"#Maven基础\" class=\"headerlink\" title=\"Maven基础\"></a>Maven基础</h2><p>有关<a href=\"http://maven.apache.org/\" target=\"_blank\" rel=\"external\">Maven</a>如何安装和设置，不在这里啰嗦了，可以到<a href=\"http://maven.apache.org/\" target=\"_blank\" rel=\"external\">官网</a>下载最新版本然后安装。</p>\n<p>Maven是一个异常强大的构建工具，能够帮助我们自动化构建过程，从清理、编译、测试到生成报告，打包和部署。我们要做的只是使用Maven配置好项目，然后输入简单的命令，Maven会帮我们处理这些任务。</p>\n<p>Maven项目的核心是pom.xml。Pom定义了项目的基本信息，用于描述项目如何构建，声明项目依赖等。下面是一个例子：<br><a id=\"more\"></a><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></div><div class=\"line\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>space.yukai.mergetool<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mergetool-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>MergeTool<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>space.yukai<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.apache.org<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></div><div class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>commons-io<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-io<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.5<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>Maven不仅是一个构建工具，还是一个依赖管理工具和项目信息管理工具。我们的java项目或多或少都会依赖一些第三方的类库，而maven提供了中央仓库，能够帮助我们自动下载构件。</p>\n<p>Maven通过一个坐标系统准确的定位每一个构件(artifact)，也就是通过一组坐标Maven能够找到任何一个java类库(如jar包)。</p>\n<p>在Maven的世界中，任何的jar、pom、或war都是通过这些坐标进行区分的。上面代码中开头的groupId、artifactId、version定义了这个项目的基本坐标。</p>\n<ul>\n<li><p>groupId定义了项目属于哪个组，这个组往往和项目所在的组织有关联。比如Googlecode上面建立了一个项目app，那么groupId就应该为com.googlecode.app</p>\n</li>\n<li><p>artifactId定义了当前项目在组中的唯一Id。比如为app中不同的子项目分配artifactId，如app-core、app-util、app-web</p>\n</li>\n<li><p>version指定了项目当前的版本。SNAPSHOT表示项目还处于开发中，是不稳定的版本</p>\n</li>\n<li><p>packaging指定了项目的打包方式，默认为jar</p>\n</li>\n<li><p>name定义了项目名称</p>\n</li>\n</ul>\n<p>上面dependency标签中的内容就是本项目声明的依赖。可以看到dependency标签中声明了groupId、artifactId、version这三个属性，比如commons-io，Maven解析到这个依赖时，就会根据这个坐标去本地仓库查找这个坐标下的依赖是否已经被下载，如果没有下载，那么到中央仓库去下载依赖的jar包到本地仓库，然后把下载好的jar包路径添加到classpath当中。这些工作都是自动进行的，我们要做的，只是在pom.xml中声明这个依赖即可。</p>\n<p>Maven在项目构建过程和过程的各个阶段的工作都是由插件实现的，并且大部分的插件都是现成的。我们只需要声明项目的基本元素，Maven就会执行内置的构建过程。上面代码中plugin标签中的内容，是对maven-compiler-plugin这个插件进行的配置。</p>\n<h2 id=\"Archetype\"><a href=\"#Archetype\" class=\"headerlink\" title=\"Archetype\"></a>Archetype</h2><p>Maven提倡 “约定优于配置”。遵循Maven的一些约定，我们可以快速的创建项目并完成构建。对于遵循约定的Maven项目，我们可以快速的了解其结构，减轻了我们的学习成本。</p>\n<p>比如：在项目的根目录放置pom.xml，在src/main/java目录放置项目主代码，在src/test/java放置项目测试代码。我们称这些基本的目录结构为项目骨架。通过Archetype插件可以帮助我们快速的创建出项目骨架。</p>\n<p>运行<code>mvn archetype:generate</code>命令，选择我们的项目骨架。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:\\Users\\kyu\\Desktop\\test&gt;mvn archetype:generate</div><div class=\"line\">[INFO] Scanning for projects...</div><div class=\"line\">[INFO]</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Building Maven Stub Project (No POM) 1</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO]</div><div class=\"line\">[INFO] &gt;&gt;&gt; maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom &gt;&gt;&gt;</div><div class=\"line\">[INFO]</div><div class=\"line\">[INFO] &lt;&lt;&lt; maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom &lt;&lt;&lt;</div><div class=\"line\">[INFO]</div><div class=\"line\">[INFO] --- maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom ---</div><div class=\"line\">[INFO] Generating project in Interactive mode</div><div class=\"line\">[INFO] No archetype defined. Using maven-archetype-quickstart (org.apache.maven.archetypes:maven-archetype-quickstart:1.0)</div><div class=\"line\">Choose archetype:</div><div class=\"line\">1: remote -&gt; am.ik.archetype:maven-reactjs-blank-archetype (Blank Project for React.js)</div><div class=\"line\">2: remote -&gt; am.ik.archetype:msgpack-rpc-jersey-blank-archetype (Blank Project for Spring Boot + Jersey)</div><div class=\"line\">3: remote -&gt; am.ik.archetype:mvc-1.0-blank-archetype (MVC 1.0 Blank Project)</div><div class=\"line\">4: remote -&gt; am.ik.archetype:spring-boot-blank-archetype (Blank Project for Spring Boot)</div><div class=\"line\">5: remote -&gt; am.ik.archetype:spring-boot-docker-blank-archetype (Docker Blank Project for Spring Boot)</div><div class=\"line\">6: remote -&gt; am.ik.archetype:spring-boot-gae-blank-archetype (GAE Blank Project for Spring Boot)</div><div class=\"line\">7: remote -&gt; am.ik.archetype:spring-boot-jersey-blank-archetype (Blank Project for Spring Boot + Jersey)</div><div class=\"line\">8: remote -&gt; at.chrl.archetypes:chrl-spring-sample (Archetype for Spring Vaadin Webapps)</div><div class=\"line\">9: remote -&gt; br.com.address.archetypes:struts2-archetype (an archetype web 3.0 + struts2 (bootstrap + jquery) + JPA 2.1 with struts2 login system)</div><div class=\"line\">10: remote -&gt; br.com.address.archetypes:struts2-base-archetype (An Archetype with JPA 2.1; Struts2 core 2.3.28.1; Jquery struts plugin; Struts BootStrap plugin; json Struts plugin;</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">1813: remote -&gt; us.fatehi:schemacrawler-archetype-plugin-command (-)</div><div class=\"line\">1814: remote -&gt; us.fatehi:schemacrawler-archetype-plugin-dbconnector (-)</div><div class=\"line\">1815: remote -&gt; us.fatehi:schemacrawler-archetype-plugin-lint (-)</div><div class=\"line\">Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 955:</div></pre></td></tr></table></figure>\n<p>默认为maven-archetype-quickstart(955)。选择该Archetype，Maven会提示输入创建项目的groupId、artifactId、version及包名package。</p>\n<p>在当前目录下，Archetype插件会创建以artifactId命名的子目录：</p>\n<img src=\"/2017/04/17/maven学习笔记/mvn.png\" alt=\"artifact\" title=\"artifact\">\n<p>可以看出，使用约定俗成的Archetype，不仅使用Maven插件代替了原本需要手工处理的劳动，同时节省了时间，降低了错误发生的概率。</p>\n<p>也可以定义自己的项目骨架，在创建项目的时候，就可以直接使用该Archetype。</p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>Maven的生命周期对所有的构建过程进行了抽象和统一。这个生命周期包括项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等所有的构建步骤。所有的项目构建，都可以映射到这样一个生命周期上。</p>\n<p>Maven只是抽象出了生命周期，生命周期中实际的任务都是交给插件完成的，类似于设计模式中的模板方法模式。</p>\n<p>Maven拥有三套独立的生命周期：clean、default、site。每个生命周期包含一些阶段：</p>\n<ul>\n<li><p>clean</p>\n<p>pre-clean  执行一些清理前需要完成的工作</p>\n<p>clean  清理上一次构建生成的文件</p>\n<p>post-clean   执行一些清理后需要完成的工作</p>\n</li>\n<li><p>default</p>\n<p>validate    检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。</p>\n<p>initialize    初始化构建状态，例如设置属性。</p>\n<p>generate-sources    生成编译阶段需要包含的任何源码文件。</p>\n<p>process-sources    处理源代码，例如，过滤任何值（filter any value）。</p>\n<p>generate-resources    生成工程包中需要包含的资源文件。</p>\n<p>process-resources    拷贝和处理资源文件到目的目录中，为打包阶段做准备。</p>\n<p>compile    编译工程源码。</p>\n<p>process-classes    处理编译生成的文件，例如 Java Class 字节码的加强和优化。</p>\n<p>generate-test-sources    生成编译阶段需要包含的任何测试源代码。</p>\n<p>process-test-sources    处理测试源代码，例如，过滤任何值（filter any values)。</p>\n<p>test-compile    编译测试源代码到测试目的目录。</p>\n<p>process-test-classes    处理测试代码文件编译后生成的文件。</p>\n<p>test    使用适当的单元测试框架（例如JUnit）运行测试。</p>\n<p>prepare-package    在真正打包之前，为准备打包执行任何必要的操作。</p>\n<p>package    获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR 或者 EAR 文件。</p>\n<p>pre-integration-test    在集成测试执行之前，执行所需的操作。例如，设置所需的环境变量。</p>\n<p>integration-test    处理和部署必须的工程包到集成测试能够运行的环境中。</p>\n<p>post-integration-test    在集成测试被执行后执行必要的操作。例如，清理环境。</p>\n<p>verify    运行检查操作来验证工程包是有效的，并满足质量要求。</p>\n<p>install    安装工程包到本地仓库中，该仓库可以作为本地其他工程的依赖。</p>\n<p>deploy    拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。</p>\n</li>\n<li><p>site</p>\n<p>pre-site  执行一些生成项目站点前需要完成的工作</p>\n<p>site  生成项目站点文档</p>\n<p>post-site  执行一些生成项目站点前需要完成的工作</p>\n<p>site-deploy  将生成的站点发布到服务器</p>\n</li>\n</ul>\n<p>每个生命周期的阶段是有顺序的，后面的阶段依赖前面的阶段。使用maven最直接的交互方式就是调用这些生命周期的阶段。比如，当用户调用pre-clean时，只有pre-clean阶段得以执行，当调用clean时，pre-clean和clean依次执行，当调用post-clean时，pre-clean、clean和post-clean依次执行。</p>\n<p>虽然每个生命周期内的阶段是有顺序和前后依赖的，但是三套生命周期之间是互相独立的。比如，当用户调用clean生命周期的clean阶段时，不会触发default生命周期的任何阶段，反之，当用户调用default生命周期的compile阶段时，也不会触发clean生命周期的任何阶段。</p>\n<p><code>mvn clean install</code>，该命令调用了clean生命周期clean阶段与default生命周期install 阶段。实际执行的阶段为clean生命周期的pre-clean、clean阶段，以及default生命周期从validate到install所有阶段。</p>\n<h2 id=\"插件目标\"><a href=\"#插件目标\" class=\"headerlink\" title=\"插件目标\"></a>插件目标</h2><p>Maven的核心仅仅定义了抽象的生命周期，具体的任务是由插件来完成的。</p>\n<p>每个插件可以完成多个功能，每个功能就是插件的一个目标。比如maven-dependency-plugin可以列出项目依赖树，列出所有已解析的依赖等等。这两个目标对应的命令为：</p>\n<p><code>mvn dependency:tree</code>，<code>mvn dependency:list</code>。冒号前面是插件前缀，冒号后面是插件目标。</p>\n<p>所以，我们知道了mvn命令有两种调用方式，一种调用其生命周期，一种直接调用插件目标。</p>\n<p>插件的生命周期与插件相互绑定，完成实际的构建任务。调用生命周期实际上也是执行了多个插件目标。</p>\n<ul>\n<li><p>内置绑定</p>\n<p>Maven核心已经对一些主要的生命周期阶段绑定了很多插件目标，当用户通过命令行调用生命周期的时候，对应的插件目标就会执行相应的任务。</p>\n<p>比如，clean生命周期有pre-clean、clean、post-clean三个阶段，clean生命周期阶段与插件目标的绑定关系如下：</p>\n<p>生命周期阶段 | 插件目标<br>————|———–<br>pre-clean   |<br>clean       |maven-clean-plugin:clean<br>post-clean  |</p>\n<p>执行命令<code>mvn post-clean</code>，输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Building space.yukai 0.0.1-SNAPSHOT</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] </div><div class=\"line\">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ space.yukai ---</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] BUILD SUCCESS</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Total time: 0.409 s</div><div class=\"line\">[INFO] Finished at: 2017-04-17T16:37:08+08:00</div><div class=\"line\">[INFO] Final Memory: 7M/106M</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<p>从输出中可以看到，执行的插件目标仅为<code>maven-clean-plugin:clean</code></p>\n</li>\n<li><p>自定义绑定</p>\n<p>除了内置绑定之外，用户可以自己选择将某个插件目标绑定到生命周期的某个阶段。</p>\n<p>比如，我们可以自行配置创建项目的源码jar包。maven-source-plugin的jar-no-fork目标可以将项目的主代码打包成jar文件。我们将其绑定到clean生命周期的post-clean阶段测试一下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-source-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\">\t    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\">\t\t    <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>attach-source<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">\t\t    <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>post-clean<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></div><div class=\"line\">\t\t        goals&gt;</div><div class=\"line\">\t\t        <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>jar-no-fork<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></div><div class=\"line\">\t\t    <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></div><div class=\"line\">\t <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>运行<code>mvn post-clean</code>，输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Building space.yukai 0.0.1-SNAPSHOT</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] </div><div class=\"line\">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ space.yukai ---</div><div class=\"line\">[INFO] Deleting Y:\\code\\versionmergetool\\VersionMergeTool\\target</div><div class=\"line\">[INFO] </div><div class=\"line\">[INFO] --- maven-source-plugin:3.0.1:jar-no-fork (attach-source) @ space.yukai ---</div><div class=\"line\">[INFO] Building jar: Y:\\code\\versionmergetool\\VersionMergeTool\\target\\space.yukai-0.0.1-SNAPSHOT-sources.jar</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] BUILD SUCCESS</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Total time: 1.082 s</div><div class=\"line\">[INFO] Finished at: 2017-04-17T16:55:32+08:00</div><div class=\"line\">[INFO] Final Memory: 7M/111M</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<p>可以看到，当执行post-clean阶段的时候，maven-source-plugin:jar-no-fork 创建了一个以-sources.jar结尾的源码包。</p>\n</li>\n</ul>\n<p>为了了解插件有哪些配置，我们可以使用maven-help-plugin来获取插件信息。</p>\n<p>运行命令<code>mvn help:describe -Dplugin=compiler</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">[INFO] Scanning for projects...</div><div class=\"line\">[INFO]</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Building mvntest-test 1.0-SNAPSHOT</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO]</div><div class=\"line\">[INFO] --- maven-help-plugin:2.2:describe (default-cli) @ mvntest-test ---</div><div class=\"line\">[INFO] org.apache.maven.plugins:maven-compiler-plugin:3.6.1</div><div class=\"line\"></div><div class=\"line\">Name: Apache Maven Compiler Plugin</div><div class=\"line\">Description: The Compiler Plugin is used to compile the sources of your</div><div class=\"line\">  project.</div><div class=\"line\">Group Id: org.apache.maven.plugins</div><div class=\"line\">Artifact Id: maven-compiler-plugin</div><div class=\"line\">Version: 3.6.1</div><div class=\"line\">Goal Prefix: compiler</div><div class=\"line\"></div><div class=\"line\">This plugin has 3 goals:</div><div class=\"line\"></div><div class=\"line\">compiler:compile</div><div class=\"line\">  Description: Compiles application sources</div><div class=\"line\"></div><div class=\"line\">compiler:help</div><div class=\"line\">  Description: Display help information on maven-compiler-plugin.</div><div class=\"line\">    Call mvn compiler:help -Ddetail=true -Dgoal=&lt;goal-name&gt; to display</div><div class=\"line\">    parameter details.</div><div class=\"line\"></div><div class=\"line\">compiler:testCompile</div><div class=\"line\">  Description: Compiles application test sources.</div><div class=\"line\"></div><div class=\"line\">For more information, run &apos;mvn help:describe [...] -Ddetail&apos;</div><div class=\"line\"></div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] BUILD SUCCESS</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Total time: 5.944s</div><div class=\"line\">[INFO] Finished at: Mon Apr 17 17:02:52 CST 2017</div><div class=\"line\">[INFO] Final Memory: 11M/110M</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<p>可以得到插件maven-compiler-plugin的信息及相关目标。还可以加上detail参数输出更详细的信息<code>mvn help:describe -Dplugin=compiler -Ddetail</code></p>\n<ul>\n<li><p>前缀</p>\n<p>笔记开头说了，在maven的世界中，所有的构件都是由坐标来确定的，构件包括依赖的jar或者插件。那么我们上面的<code>mvn help:describe -Dplugin=compiler</code>中并没有指定插件的坐标，为什么能够正常的运行呢？</p>\n<p>其实<code>mvn help:describe -Dplugin=compiler</code>就等效于<code>mvn org.apache.maven.plugins:maven-help-plugin:2.2:describe -Dplugin=compiler</code>。help就是maven-help-plugin的前缀，maven能够根据这个前缀找到对应的artifactId，从而解析得到groupId和version，所有能够精确的定位某个插件。compiler也是前缀。</p>\n</li>\n</ul>\n","excerpt":"<blockquote>\n<p>上周末两天时间基本上将《Maven实战》这本书看完了。《Maven实战》是很棒的一本介绍maven相关知识的书籍。读完之后，对学到的maven相关的内容做一个梳理总结。</p>\n</blockquote>\n<h2 id=\"Maven基础\"><a href=\"#Maven基础\" class=\"headerlink\" title=\"Maven基础\"></a>Maven基础</h2><p>有关<a href=\"http://maven.apache.org/\">Maven</a>如何安装和设置，不在这里啰嗦了，可以到<a href=\"http://maven.apache.org/\">官网</a>下载最新版本然后安装。</p>\n<p>Maven是一个异常强大的构建工具，能够帮助我们自动化构建过程，从清理、编译、测试到生成报告，打包和部署。我们要做的只是使用Maven配置好项目，然后输入简单的命令，Maven会帮我们处理这些任务。</p>\n<p>Maven项目的核心是pom.xml。Pom定义了项目的基本信息，用于描述项目如何构建，声明项目依赖等。下面是一个例子：<br>","more":"<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>space.yukai.mergetool<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mergetool-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>MergeTool<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>space.yukai<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.apache.org<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></div><div class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>commons-io<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-io<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.5<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>Maven不仅是一个构建工具，还是一个依赖管理工具和项目信息管理工具。我们的java项目或多或少都会依赖一些第三方的类库，而maven提供了中央仓库，能够帮助我们自动下载构件。</p>\n<p>Maven通过一个坐标系统准确的定位每一个构件(artifact)，也就是通过一组坐标Maven能够找到任何一个java类库(如jar包)。</p>\n<p>在Maven的世界中，任何的jar、pom、或war都是通过这些坐标进行区分的。上面代码中开头的groupId、artifactId、version定义了这个项目的基本坐标。</p>\n<ul>\n<li><p>groupId定义了项目属于哪个组，这个组往往和项目所在的组织有关联。比如Googlecode上面建立了一个项目app，那么groupId就应该为com.googlecode.app</p>\n</li>\n<li><p>artifactId定义了当前项目在组中的唯一Id。比如为app中不同的子项目分配artifactId，如app-core、app-util、app-web</p>\n</li>\n<li><p>version指定了项目当前的版本。SNAPSHOT表示项目还处于开发中，是不稳定的版本</p>\n</li>\n<li><p>packaging指定了项目的打包方式，默认为jar</p>\n</li>\n<li><p>name定义了项目名称</p>\n</li>\n</ul>\n<p>上面dependency标签中的内容就是本项目声明的依赖。可以看到dependency标签中声明了groupId、artifactId、version这三个属性，比如commons-io，Maven解析到这个依赖时，就会根据这个坐标去本地仓库查找这个坐标下的依赖是否已经被下载，如果没有下载，那么到中央仓库去下载依赖的jar包到本地仓库，然后把下载好的jar包路径添加到classpath当中。这些工作都是自动进行的，我们要做的，只是在pom.xml中声明这个依赖即可。</p>\n<p>Maven在项目构建过程和过程的各个阶段的工作都是由插件实现的，并且大部分的插件都是现成的。我们只需要声明项目的基本元素，Maven就会执行内置的构建过程。上面代码中plugin标签中的内容，是对maven-compiler-plugin这个插件进行的配置。</p>\n<h2 id=\"Archetype\"><a href=\"#Archetype\" class=\"headerlink\" title=\"Archetype\"></a>Archetype</h2><p>Maven提倡 “约定优于配置”。遵循Maven的一些约定，我们可以快速的创建项目并完成构建。对于遵循约定的Maven项目，我们可以快速的了解其结构，减轻了我们的学习成本。</p>\n<p>比如：在项目的根目录放置pom.xml，在src/main/java目录放置项目主代码，在src/test/java放置项目测试代码。我们称这些基本的目录结构为项目骨架。通过Archetype插件可以帮助我们快速的创建出项目骨架。</p>\n<p>运行<code>mvn archetype:generate</code>命令，选择我们的项目骨架。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:\\Users\\kyu\\Desktop\\test&gt;mvn archetype:generate</div><div class=\"line\">[INFO] Scanning for projects...</div><div class=\"line\">[INFO]</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Building Maven Stub Project (No POM) 1</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO]</div><div class=\"line\">[INFO] &gt;&gt;&gt; maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom &gt;&gt;&gt;</div><div class=\"line\">[INFO]</div><div class=\"line\">[INFO] &lt;&lt;&lt; maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom &lt;&lt;&lt;</div><div class=\"line\">[INFO]</div><div class=\"line\">[INFO] --- maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom ---</div><div class=\"line\">[INFO] Generating project in Interactive mode</div><div class=\"line\">[INFO] No archetype defined. Using maven-archetype-quickstart (org.apache.maven.archetypes:maven-archetype-quickstart:1.0)</div><div class=\"line\">Choose archetype:</div><div class=\"line\">1: remote -&gt; am.ik.archetype:maven-reactjs-blank-archetype (Blank Project for React.js)</div><div class=\"line\">2: remote -&gt; am.ik.archetype:msgpack-rpc-jersey-blank-archetype (Blank Project for Spring Boot + Jersey)</div><div class=\"line\">3: remote -&gt; am.ik.archetype:mvc-1.0-blank-archetype (MVC 1.0 Blank Project)</div><div class=\"line\">4: remote -&gt; am.ik.archetype:spring-boot-blank-archetype (Blank Project for Spring Boot)</div><div class=\"line\">5: remote -&gt; am.ik.archetype:spring-boot-docker-blank-archetype (Docker Blank Project for Spring Boot)</div><div class=\"line\">6: remote -&gt; am.ik.archetype:spring-boot-gae-blank-archetype (GAE Blank Project for Spring Boot)</div><div class=\"line\">7: remote -&gt; am.ik.archetype:spring-boot-jersey-blank-archetype (Blank Project for Spring Boot + Jersey)</div><div class=\"line\">8: remote -&gt; at.chrl.archetypes:chrl-spring-sample (Archetype for Spring Vaadin Webapps)</div><div class=\"line\">9: remote -&gt; br.com.address.archetypes:struts2-archetype (an archetype web 3.0 + struts2 (bootstrap + jquery) + JPA 2.1 with struts2 login system)</div><div class=\"line\">10: remote -&gt; br.com.address.archetypes:struts2-base-archetype (An Archetype with JPA 2.1; Struts2 core 2.3.28.1; Jquery struts plugin; Struts BootStrap plugin; json Struts plugin;</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">1813: remote -&gt; us.fatehi:schemacrawler-archetype-plugin-command (-)</div><div class=\"line\">1814: remote -&gt; us.fatehi:schemacrawler-archetype-plugin-dbconnector (-)</div><div class=\"line\">1815: remote -&gt; us.fatehi:schemacrawler-archetype-plugin-lint (-)</div><div class=\"line\">Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 955:</div></pre></td></tr></table></figure>\n<p>默认为maven-archetype-quickstart(955)。选择该Archetype，Maven会提示输入创建项目的groupId、artifactId、version及包名package。</p>\n<p>在当前目录下，Archetype插件会创建以artifactId命名的子目录：</p>\n<img src=\"/2017/04/17/maven学习笔记/mvn.png\" alt=\"artifact\" title=\"artifact\">\n<p>可以看出，使用约定俗成的Archetype，不仅使用Maven插件代替了原本需要手工处理的劳动，同时节省了时间，降低了错误发生的概率。</p>\n<p>也可以定义自己的项目骨架，在创建项目的时候，就可以直接使用该Archetype。</p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>Maven的生命周期对所有的构建过程进行了抽象和统一。这个生命周期包括项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等所有的构建步骤。所有的项目构建，都可以映射到这样一个生命周期上。</p>\n<p>Maven只是抽象出了生命周期，生命周期中实际的任务都是交给插件完成的，类似于设计模式中的模板方法模式。</p>\n<p>Maven拥有三套独立的生命周期：clean、default、site。每个生命周期包含一些阶段：</p>\n<ul>\n<li><p>clean</p>\n<p>pre-clean  执行一些清理前需要完成的工作</p>\n<p>clean  清理上一次构建生成的文件</p>\n<p>post-clean   执行一些清理后需要完成的工作</p>\n</li>\n<li><p>default</p>\n<p>validate    检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。</p>\n<p>initialize    初始化构建状态，例如设置属性。</p>\n<p>generate-sources    生成编译阶段需要包含的任何源码文件。</p>\n<p>process-sources    处理源代码，例如，过滤任何值（filter any value）。</p>\n<p>generate-resources    生成工程包中需要包含的资源文件。</p>\n<p>process-resources    拷贝和处理资源文件到目的目录中，为打包阶段做准备。</p>\n<p>compile    编译工程源码。</p>\n<p>process-classes    处理编译生成的文件，例如 Java Class 字节码的加强和优化。</p>\n<p>generate-test-sources    生成编译阶段需要包含的任何测试源代码。</p>\n<p>process-test-sources    处理测试源代码，例如，过滤任何值（filter any values)。</p>\n<p>test-compile    编译测试源代码到测试目的目录。</p>\n<p>process-test-classes    处理测试代码文件编译后生成的文件。</p>\n<p>test    使用适当的单元测试框架（例如JUnit）运行测试。</p>\n<p>prepare-package    在真正打包之前，为准备打包执行任何必要的操作。</p>\n<p>package    获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR 或者 EAR 文件。</p>\n<p>pre-integration-test    在集成测试执行之前，执行所需的操作。例如，设置所需的环境变量。</p>\n<p>integration-test    处理和部署必须的工程包到集成测试能够运行的环境中。</p>\n<p>post-integration-test    在集成测试被执行后执行必要的操作。例如，清理环境。</p>\n<p>verify    运行检查操作来验证工程包是有效的，并满足质量要求。</p>\n<p>install    安装工程包到本地仓库中，该仓库可以作为本地其他工程的依赖。</p>\n<p>deploy    拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。</p>\n</li>\n<li><p>site</p>\n<p>pre-site  执行一些生成项目站点前需要完成的工作</p>\n<p>site  生成项目站点文档</p>\n<p>post-site  执行一些生成项目站点前需要完成的工作</p>\n<p>site-deploy  将生成的站点发布到服务器</p>\n</li>\n</ul>\n<p>每个生命周期的阶段是有顺序的，后面的阶段依赖前面的阶段。使用maven最直接的交互方式就是调用这些生命周期的阶段。比如，当用户调用pre-clean时，只有pre-clean阶段得以执行，当调用clean时，pre-clean和clean依次执行，当调用post-clean时，pre-clean、clean和post-clean依次执行。</p>\n<p>虽然每个生命周期内的阶段是有顺序和前后依赖的，但是三套生命周期之间是互相独立的。比如，当用户调用clean生命周期的clean阶段时，不会触发default生命周期的任何阶段，反之，当用户调用default生命周期的compile阶段时，也不会触发clean生命周期的任何阶段。</p>\n<p><code>mvn clean install</code>，该命令调用了clean生命周期clean阶段与default生命周期install 阶段。实际执行的阶段为clean生命周期的pre-clean、clean阶段，以及default生命周期从validate到install所有阶段。</p>\n<h2 id=\"插件目标\"><a href=\"#插件目标\" class=\"headerlink\" title=\"插件目标\"></a>插件目标</h2><p>Maven的核心仅仅定义了抽象的生命周期，具体的任务是由插件来完成的。</p>\n<p>每个插件可以完成多个功能，每个功能就是插件的一个目标。比如maven-dependency-plugin可以列出项目依赖树，列出所有已解析的依赖等等。这两个目标对应的命令为：</p>\n<p><code>mvn dependency:tree</code>，<code>mvn dependency:list</code>。冒号前面是插件前缀，冒号后面是插件目标。</p>\n<p>所以，我们知道了mvn命令有两种调用方式，一种调用其生命周期，一种直接调用插件目标。</p>\n<p>插件的生命周期与插件相互绑定，完成实际的构建任务。调用生命周期实际上也是执行了多个插件目标。</p>\n<ul>\n<li><p>内置绑定</p>\n<p>Maven核心已经对一些主要的生命周期阶段绑定了很多插件目标，当用户通过命令行调用生命周期的时候，对应的插件目标就会执行相应的任务。</p>\n<p>比如，clean生命周期有pre-clean、clean、post-clean三个阶段，clean生命周期阶段与插件目标的绑定关系如下：</p>\n<p>生命周期阶段 | 插件目标<br>————|———–<br>pre-clean   |<br>clean       |maven-clean-plugin:clean<br>post-clean  |</p>\n<p>执行命令<code>mvn post-clean</code>，输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Building space.yukai 0.0.1-SNAPSHOT</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] </div><div class=\"line\">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ space.yukai ---</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] BUILD SUCCESS</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Total time: 0.409 s</div><div class=\"line\">[INFO] Finished at: 2017-04-17T16:37:08+08:00</div><div class=\"line\">[INFO] Final Memory: 7M/106M</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<p>从输出中可以看到，执行的插件目标仅为<code>maven-clean-plugin:clean</code></p>\n</li>\n<li><p>自定义绑定</p>\n<p>除了内置绑定之外，用户可以自己选择将某个插件目标绑定到生命周期的某个阶段。</p>\n<p>比如，我们可以自行配置创建项目的源码jar包。maven-source-plugin的jar-no-fork目标可以将项目的主代码打包成jar文件。我们将其绑定到clean生命周期的post-clean阶段测试一下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-source-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\">\t    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\">\t\t    <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>attach-source<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">\t\t    <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>post-clean<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></div><div class=\"line\">\t\t        goals&gt;</div><div class=\"line\">\t\t        <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>jar-no-fork<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></div><div class=\"line\">\t\t    <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></div><div class=\"line\">\t <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>运行<code>mvn post-clean</code>，输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Building space.yukai 0.0.1-SNAPSHOT</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] </div><div class=\"line\">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ space.yukai ---</div><div class=\"line\">[INFO] Deleting Y:\\code\\versionmergetool\\VersionMergeTool\\target</div><div class=\"line\">[INFO] </div><div class=\"line\">[INFO] --- maven-source-plugin:3.0.1:jar-no-fork (attach-source) @ space.yukai ---</div><div class=\"line\">[INFO] Building jar: Y:\\code\\versionmergetool\\VersionMergeTool\\target\\space.yukai-0.0.1-SNAPSHOT-sources.jar</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] BUILD SUCCESS</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Total time: 1.082 s</div><div class=\"line\">[INFO] Finished at: 2017-04-17T16:55:32+08:00</div><div class=\"line\">[INFO] Final Memory: 7M/111M</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<p>可以看到，当执行post-clean阶段的时候，maven-source-plugin:jar-no-fork 创建了一个以-sources.jar结尾的源码包。</p>\n</li>\n</ul>\n<p>为了了解插件有哪些配置，我们可以使用maven-help-plugin来获取插件信息。</p>\n<p>运行命令<code>mvn help:describe -Dplugin=compiler</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">[INFO] Scanning for projects...</div><div class=\"line\">[INFO]</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Building mvntest-test 1.0-SNAPSHOT</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO]</div><div class=\"line\">[INFO] --- maven-help-plugin:2.2:describe (default-cli) @ mvntest-test ---</div><div class=\"line\">[INFO] org.apache.maven.plugins:maven-compiler-plugin:3.6.1</div><div class=\"line\"></div><div class=\"line\">Name: Apache Maven Compiler Plugin</div><div class=\"line\">Description: The Compiler Plugin is used to compile the sources of your</div><div class=\"line\">  project.</div><div class=\"line\">Group Id: org.apache.maven.plugins</div><div class=\"line\">Artifact Id: maven-compiler-plugin</div><div class=\"line\">Version: 3.6.1</div><div class=\"line\">Goal Prefix: compiler</div><div class=\"line\"></div><div class=\"line\">This plugin has 3 goals:</div><div class=\"line\"></div><div class=\"line\">compiler:compile</div><div class=\"line\">  Description: Compiles application sources</div><div class=\"line\"></div><div class=\"line\">compiler:help</div><div class=\"line\">  Description: Display help information on maven-compiler-plugin.</div><div class=\"line\">    Call mvn compiler:help -Ddetail=true -Dgoal=&lt;goal-name&gt; to display</div><div class=\"line\">    parameter details.</div><div class=\"line\"></div><div class=\"line\">compiler:testCompile</div><div class=\"line\">  Description: Compiles application test sources.</div><div class=\"line\"></div><div class=\"line\">For more information, run &apos;mvn help:describe [...] -Ddetail&apos;</div><div class=\"line\"></div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] BUILD SUCCESS</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div><div class=\"line\">[INFO] Total time: 5.944s</div><div class=\"line\">[INFO] Finished at: Mon Apr 17 17:02:52 CST 2017</div><div class=\"line\">[INFO] Final Memory: 11M/110M</div><div class=\"line\">[INFO] ------------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<p>可以得到插件maven-compiler-plugin的信息及相关目标。还可以加上detail参数输出更详细的信息<code>mvn help:describe -Dplugin=compiler -Ddetail</code></p>\n<ul>\n<li><p>前缀</p>\n<p>笔记开头说了，在maven的世界中，所有的构件都是由坐标来确定的，构件包括依赖的jar或者插件。那么我们上面的<code>mvn help:describe -Dplugin=compiler</code>中并没有指定插件的坐标，为什么能够正常的运行呢？</p>\n<p>其实<code>mvn help:describe -Dplugin=compiler</code>就等效于<code>mvn org.apache.maven.plugins:maven-help-plugin:2.2:describe -Dplugin=compiler</code>。help就是maven-help-plugin的前缀，maven能够根据这个前缀找到对应的artifactId，从而解析得到groupId和version，所有能够精确的定位某个插件。compiler也是前缀。</p>\n</li>\n</ul>"},{"layout":"post","title":"ssh的两种用法","date":"2017-02-23T12:05:03.000Z","_content":"> 工作中在远程主机上进行一些操作时，经常使用ssh进行远程登录。后来使用github时，也会用到ssh。其中涉及到了ssh的两种用法，记录一下~\n\n> 本文主要参考自阮一峰老师的博客：[SSH原理与运用（一）：远程登录](http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)\n\nssh是每台linux机器的标准配置。ssh是一种协议，SSH在计算机之间构建网络连接，确保连接双方身份的真实性，同时，它还保证在此连接上传送的数据到达时不会被人更改，不会被他人窃听。\n\nssh有多种实现，我们一般使用的是openssh，这是一款免费开源的ssh工具。一般在我们使用的linux发行版中，已经预设了这个软件了，所以可以直接使用它。如果是在windows中使用ssh客户端连接远程linux ssh服务，\n我使用一款名为MobaXterm的工具。\n\n<!-- more -->\n## 密码登录\n\n这是我们使用远程linux机器时最一般的登录方式。使用user这个用户登录到主机host:\n\nssh user@host\n\nssh默认端口是22，如果远程主机ssh服务端口不是22的话，可以通过-p参数修改连接端口：\n\nssh -p 8899 user@host\n\n整个的登录过程：\n\n1.远程主机收到客户端的登录请求，把自己的公钥发给用户。\n\n2.客户端使用这个公钥，将登录密码加密后，发送回来。\n\n3.远程主机用自己的私钥，解密登录密码，如果密码正确，就同意客户端登录。\n\n这样的登录方式有一个问题，那就是如果有人截获了客户端的登录请求（比如使用公共WiFi），然后将自己的公钥发给了客户端，就可以冒充远程主机获取客户端的密码了。\nHttps协议是有CA证书中心作公证的，ssh协议并不存在这样的机构，所以就有中间人攻击的风险。\n\n为了应对这种风险，当客户端第一次登陆远程主机时，会有类似的提示：\n\n```\nThe authenticity of host 'test.linux.org (192.168.1.100)' can't be established. \nRSA key fingerprint is 46:cf:06:6a:ad:ba:e2:85:cc:d9:c4:8d:15:bb:f3:ec. \nAre you sure you want to continue connecting (yes/no)?\n```\n意思就是要你核对远程主机的公钥指纹，从而证明他的身份。那么我们如何判断这个公钥指纹是不是远程主机的公钥产生的指纹呢？答案是没有好办法，只能由用户自己想办法核对，比如远程主机在网站上贴出了自己的公钥指纹。\n\n当我们输入yes之后，会出现：\n\n```\nWarning: Permanently added 'test.linux.org,192.168.1.100' (RSA) to the list of known \n```\n表示我们已经认可了该主机。\n\n此时要求我们输入登录用户的密码，密码正确则登录。\n\n当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。\n\n每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。\n\n## 公钥登录\n\n### 步骤\n\nssh还提供了另一种登录方式，就是公钥登录，避免了输入密码的麻烦。\n\n所谓\"公钥登录\"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。\n\n这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：\n\nssh-keygen\n\n运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。\n\n这时再输入下面的命令，将公钥传送到远程主机host上面：\n\nssh-copy-id user@host\n\n然后，打开远程主机/etc/ssh/sshd_config这个文件，检查以下几项：\n\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n\n然后重启ssh服务就可以了：\n\nservice sshd restart\n\n### authorized_keys\n\n远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。\n\n这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：\n\nssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub\n\n这条命令由多个语句组成，依次分解开来看：\n\n1. \"ssh user@host\"，表示登录远程主机；\n\n2. 单引号中的mkdir .ssh && cat >> .ssh/authorized_keys，表示登录后在远程shell上执行的命令：\n\n3. \"mkdir -p .ssh\"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；\n\n4. 'cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。\n\n写入authorized_keys文件后，公钥登录的设置就完成了。\n\n## 参考\n\n[簡易 Telnet 與 SSH 主機設定](http://linux.vbird.org/linux_server/0310telnetssh/0310telnetssh.php)\n\n[SSH原理与运用（一）：远程登录](http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)","source":"_posts/ssh的两种用法.md","raw":"---\nlayout: post\ntitle: ssh的两种用法\ndate: 2017-02-23 20:05:03\ncategories: 编程 \ntags:\n- linux\n---\n> 工作中在远程主机上进行一些操作时，经常使用ssh进行远程登录。后来使用github时，也会用到ssh。其中涉及到了ssh的两种用法，记录一下~\n\n> 本文主要参考自阮一峰老师的博客：[SSH原理与运用（一）：远程登录](http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)\n\nssh是每台linux机器的标准配置。ssh是一种协议，SSH在计算机之间构建网络连接，确保连接双方身份的真实性，同时，它还保证在此连接上传送的数据到达时不会被人更改，不会被他人窃听。\n\nssh有多种实现，我们一般使用的是openssh，这是一款免费开源的ssh工具。一般在我们使用的linux发行版中，已经预设了这个软件了，所以可以直接使用它。如果是在windows中使用ssh客户端连接远程linux ssh服务，\n我使用一款名为MobaXterm的工具。\n\n<!-- more -->\n## 密码登录\n\n这是我们使用远程linux机器时最一般的登录方式。使用user这个用户登录到主机host:\n\nssh user@host\n\nssh默认端口是22，如果远程主机ssh服务端口不是22的话，可以通过-p参数修改连接端口：\n\nssh -p 8899 user@host\n\n整个的登录过程：\n\n1.远程主机收到客户端的登录请求，把自己的公钥发给用户。\n\n2.客户端使用这个公钥，将登录密码加密后，发送回来。\n\n3.远程主机用自己的私钥，解密登录密码，如果密码正确，就同意客户端登录。\n\n这样的登录方式有一个问题，那就是如果有人截获了客户端的登录请求（比如使用公共WiFi），然后将自己的公钥发给了客户端，就可以冒充远程主机获取客户端的密码了。\nHttps协议是有CA证书中心作公证的，ssh协议并不存在这样的机构，所以就有中间人攻击的风险。\n\n为了应对这种风险，当客户端第一次登陆远程主机时，会有类似的提示：\n\n```\nThe authenticity of host 'test.linux.org (192.168.1.100)' can't be established. \nRSA key fingerprint is 46:cf:06:6a:ad:ba:e2:85:cc:d9:c4:8d:15:bb:f3:ec. \nAre you sure you want to continue connecting (yes/no)?\n```\n意思就是要你核对远程主机的公钥指纹，从而证明他的身份。那么我们如何判断这个公钥指纹是不是远程主机的公钥产生的指纹呢？答案是没有好办法，只能由用户自己想办法核对，比如远程主机在网站上贴出了自己的公钥指纹。\n\n当我们输入yes之后，会出现：\n\n```\nWarning: Permanently added 'test.linux.org,192.168.1.100' (RSA) to the list of known \n```\n表示我们已经认可了该主机。\n\n此时要求我们输入登录用户的密码，密码正确则登录。\n\n当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。\n\n每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。\n\n## 公钥登录\n\n### 步骤\n\nssh还提供了另一种登录方式，就是公钥登录，避免了输入密码的麻烦。\n\n所谓\"公钥登录\"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。\n\n这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：\n\nssh-keygen\n\n运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。\n\n这时再输入下面的命令，将公钥传送到远程主机host上面：\n\nssh-copy-id user@host\n\n然后，打开远程主机/etc/ssh/sshd_config这个文件，检查以下几项：\n\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n\n然后重启ssh服务就可以了：\n\nservice sshd restart\n\n### authorized_keys\n\n远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。\n\n这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：\n\nssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub\n\n这条命令由多个语句组成，依次分解开来看：\n\n1. \"ssh user@host\"，表示登录远程主机；\n\n2. 单引号中的mkdir .ssh && cat >> .ssh/authorized_keys，表示登录后在远程shell上执行的命令：\n\n3. \"mkdir -p .ssh\"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；\n\n4. 'cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。\n\n写入authorized_keys文件后，公钥登录的设置就完成了。\n\n## 参考\n\n[簡易 Telnet 與 SSH 主機設定](http://linux.vbird.org/linux_server/0310telnetssh/0310telnetssh.php)\n\n[SSH原理与运用（一）：远程登录](http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)","slug":"ssh的两种用法","published":1,"updated":"2017-04-11T13:08:38.847Z","comments":1,"photos":[],"link":"","_id":"cj4vch4fy003nx3gckasvqopm","content":"<blockquote>\n<p>工作中在远程主机上进行一些操作时，经常使用ssh进行远程登录。后来使用github时，也会用到ssh。其中涉及到了ssh的两种用法，记录一下~</p>\n<p>本文主要参考自阮一峰老师的博客：<a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\" target=\"_blank\" rel=\"external\">SSH原理与运用（一）：远程登录</a></p>\n</blockquote>\n<p>ssh是每台linux机器的标准配置。ssh是一种协议，SSH在计算机之间构建网络连接，确保连接双方身份的真实性，同时，它还保证在此连接上传送的数据到达时不会被人更改，不会被他人窃听。</p>\n<p>ssh有多种实现，我们一般使用的是openssh，这是一款免费开源的ssh工具。一般在我们使用的linux发行版中，已经预设了这个软件了，所以可以直接使用它。如果是在windows中使用ssh客户端连接远程linux ssh服务，<br>我使用一款名为MobaXterm的工具。</p>\n<a id=\"more\"></a>\n<h2 id=\"密码登录\"><a href=\"#密码登录\" class=\"headerlink\" title=\"密码登录\"></a>密码登录</h2><p>这是我们使用远程linux机器时最一般的登录方式。使用user这个用户登录到主机host:</p>\n<p>ssh user@host</p>\n<p>ssh默认端口是22，如果远程主机ssh服务端口不是22的话，可以通过-p参数修改连接端口：</p>\n<p>ssh -p 8899 user@host</p>\n<p>整个的登录过程：</p>\n<p>1.远程主机收到客户端的登录请求，把自己的公钥发给用户。</p>\n<p>2.客户端使用这个公钥，将登录密码加密后，发送回来。</p>\n<p>3.远程主机用自己的私钥，解密登录密码，如果密码正确，就同意客户端登录。</p>\n<p>这样的登录方式有一个问题，那就是如果有人截获了客户端的登录请求（比如使用公共WiFi），然后将自己的公钥发给了客户端，就可以冒充远程主机获取客户端的密码了。<br>Https协议是有CA证书中心作公证的，ssh协议并不存在这样的机构，所以就有中间人攻击的风险。</p>\n<p>为了应对这种风险，当客户端第一次登陆远程主机时，会有类似的提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">The authenticity of host &apos;test.linux.org (192.168.1.100)&apos; can&apos;t be established. </div><div class=\"line\">RSA key fingerprint is 46:cf:06:6a:ad:ba:e2:85:cc:d9:c4:8d:15:bb:f3:ec. </div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>\n<p>意思就是要你核对远程主机的公钥指纹，从而证明他的身份。那么我们如何判断这个公钥指纹是不是远程主机的公钥产生的指纹呢？答案是没有好办法，只能由用户自己想办法核对，比如远程主机在网站上贴出了自己的公钥指纹。</p>\n<p>当我们输入yes之后，会出现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Warning: Permanently added &apos;test.linux.org,192.168.1.100&apos; (RSA) to the list of known</div></pre></td></tr></table></figure>\n<p>表示我们已经认可了该主机。</p>\n<p>此时要求我们输入登录用户的密码，密码正确则登录。</p>\n<p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>\n<p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>\n<h2 id=\"公钥登录\"><a href=\"#公钥登录\" class=\"headerlink\" title=\"公钥登录\"></a>公钥登录</h2><h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>ssh还提供了另一种登录方式，就是公钥登录，避免了输入密码的麻烦。</p>\n<p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>\n<p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p>\n<p>ssh-keygen</p>\n<p>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。</p>\n<p>这时再输入下面的命令，将公钥传送到远程主机host上面：</p>\n<p>ssh-copy-id user@host</p>\n<p>然后，打开远程主机/etc/ssh/sshd_config这个文件，检查以下几项：</p>\n<p>RSAAuthentication yes<br>PubkeyAuthentication yes<br>AuthorizedKeysFile .ssh/authorized_keys</p>\n<p>然后重启ssh服务就可以了：</p>\n<p>service sshd restart</p>\n<h3 id=\"authorized-keys\"><a href=\"#authorized-keys\" class=\"headerlink\" title=\"authorized_keys\"></a>authorized_keys</h3><p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。</p>\n<p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p>\n<p>ssh user@host ‘mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub</p>\n<p>这条命令由多个语句组成，依次分解开来看：</p>\n<ol>\n<li><p>“ssh user@host”，表示登录远程主机；</p>\n</li>\n<li><p>单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：</p>\n</li>\n<li><p>“mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；</p>\n</li>\n<li><p>‘cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。</p>\n</li>\n</ol>\n<p>写入authorized_keys文件后，公钥登录的设置就完成了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://linux.vbird.org/linux_server/0310telnetssh/0310telnetssh.php\" target=\"_blank\" rel=\"external\">簡易 Telnet 與 SSH 主機設定</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\" target=\"_blank\" rel=\"external\">SSH原理与运用（一）：远程登录</a></p>\n","excerpt":"<blockquote>\n<p>工作中在远程主机上进行一些操作时，经常使用ssh进行远程登录。后来使用github时，也会用到ssh。其中涉及到了ssh的两种用法，记录一下~</p>\n<p>本文主要参考自阮一峰老师的博客：<a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\">SSH原理与运用（一）：远程登录</a></p>\n</blockquote>\n<p>ssh是每台linux机器的标准配置。ssh是一种协议，SSH在计算机之间构建网络连接，确保连接双方身份的真实性，同时，它还保证在此连接上传送的数据到达时不会被人更改，不会被他人窃听。</p>\n<p>ssh有多种实现，我们一般使用的是openssh，这是一款免费开源的ssh工具。一般在我们使用的linux发行版中，已经预设了这个软件了，所以可以直接使用它。如果是在windows中使用ssh客户端连接远程linux ssh服务，<br>我使用一款名为MobaXterm的工具。</p>","more":"<h2 id=\"密码登录\"><a href=\"#密码登录\" class=\"headerlink\" title=\"密码登录\"></a>密码登录</h2><p>这是我们使用远程linux机器时最一般的登录方式。使用user这个用户登录到主机host:</p>\n<p>ssh user@host</p>\n<p>ssh默认端口是22，如果远程主机ssh服务端口不是22的话，可以通过-p参数修改连接端口：</p>\n<p>ssh -p 8899 user@host</p>\n<p>整个的登录过程：</p>\n<p>1.远程主机收到客户端的登录请求，把自己的公钥发给用户。</p>\n<p>2.客户端使用这个公钥，将登录密码加密后，发送回来。</p>\n<p>3.远程主机用自己的私钥，解密登录密码，如果密码正确，就同意客户端登录。</p>\n<p>这样的登录方式有一个问题，那就是如果有人截获了客户端的登录请求（比如使用公共WiFi），然后将自己的公钥发给了客户端，就可以冒充远程主机获取客户端的密码了。<br>Https协议是有CA证书中心作公证的，ssh协议并不存在这样的机构，所以就有中间人攻击的风险。</p>\n<p>为了应对这种风险，当客户端第一次登陆远程主机时，会有类似的提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">The authenticity of host &apos;test.linux.org (192.168.1.100)&apos; can&apos;t be established. </div><div class=\"line\">RSA key fingerprint is 46:cf:06:6a:ad:ba:e2:85:cc:d9:c4:8d:15:bb:f3:ec. </div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>\n<p>意思就是要你核对远程主机的公钥指纹，从而证明他的身份。那么我们如何判断这个公钥指纹是不是远程主机的公钥产生的指纹呢？答案是没有好办法，只能由用户自己想办法核对，比如远程主机在网站上贴出了自己的公钥指纹。</p>\n<p>当我们输入yes之后，会出现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Warning: Permanently added &apos;test.linux.org,192.168.1.100&apos; (RSA) to the list of known</div></pre></td></tr></table></figure>\n<p>表示我们已经认可了该主机。</p>\n<p>此时要求我们输入登录用户的密码，密码正确则登录。</p>\n<p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>\n<p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>\n<h2 id=\"公钥登录\"><a href=\"#公钥登录\" class=\"headerlink\" title=\"公钥登录\"></a>公钥登录</h2><h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>ssh还提供了另一种登录方式，就是公钥登录，避免了输入密码的麻烦。</p>\n<p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>\n<p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p>\n<p>ssh-keygen</p>\n<p>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。</p>\n<p>这时再输入下面的命令，将公钥传送到远程主机host上面：</p>\n<p>ssh-copy-id user@host</p>\n<p>然后，打开远程主机/etc/ssh/sshd_config这个文件，检查以下几项：</p>\n<p>RSAAuthentication yes<br>PubkeyAuthentication yes<br>AuthorizedKeysFile .ssh/authorized_keys</p>\n<p>然后重启ssh服务就可以了：</p>\n<p>service sshd restart</p>\n<h3 id=\"authorized-keys\"><a href=\"#authorized-keys\" class=\"headerlink\" title=\"authorized_keys\"></a>authorized_keys</h3><p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。</p>\n<p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p>\n<p>ssh user@host ‘mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub</p>\n<p>这条命令由多个语句组成，依次分解开来看：</p>\n<ol>\n<li><p>“ssh user@host”，表示登录远程主机；</p>\n</li>\n<li><p>单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：</p>\n</li>\n<li><p>“mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；</p>\n</li>\n<li><p>‘cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。</p>\n</li>\n</ol>\n<p>写入authorized_keys文件后，公钥登录的设置就完成了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://linux.vbird.org/linux_server/0310telnetssh/0310telnetssh.php\">簡易 Telnet 與 SSH 主機設定</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\">SSH原理与运用（一）：远程登录</a></p>"},{"layout":"post","date":"2016-08-16T07:31:44.000Z","title":"synchronized的用法","comments":1,"_content":"\n>以前的工作过程中，偶尔会遇到synchronized的使用，比如[这篇总结](http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/)。今天来总结一下自己对synchronized的关键字的一些认识。\n\n## 同步锁\n\nsynchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。\n\n每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：\n\n```java\nsynchronized (object) {\n\t//doSomething...\t\t\n}\n```\n\n上面的 '{' '}' 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。\n\n## synchronized修饰代码块\n\n### synchronized同步锁为普通对象\n\n```java\npublic void function(){\n\tsynchronized (object) {\n\t\t//doSomething...\t\t\n\t}\n}\n```\n<!-- more -->\n当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。\n\n下面的例子：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(new Object());\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n运行结果：\n\n```\nThread-0运行中...\nThread-1运行中...\nThread-2运行中...\nThread-3运行中...\nThread-4运行中...\nThread-1结束...\nThread-0结束...\nThread-3结束...\nThread-4结束...\nThread-2结束...\n```\n\n跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tObject object = new Object();\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(object);\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```java\nThread-0运行中...\nThread-0结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。\n\n重点要理解：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**\n\n### synchronized同步锁为类\n\n类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。\n\n将上面的例子修改一下：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-0结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\n```\n这些线程同样实现了同步，因为他们的同步锁是同一个对象--SyncTest类对象。\n\n需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\tSync1 sync1 = new Sync1(new SyncTest());\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t\t\n\t\tsync1.start();\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n\nclass Sync1 extends Thread{\n\tSyncTest syncTest;\n\tpublic Sync1(SyncTest syncTest){\n\t\tthis.syncTest = syncTest;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncTest) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-5运行中...\nThread-0结束...\nThread-5结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。\n\n## synchronized修饰方法\n\nsynchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。\n\n### synchronized修饰普通方法\n\n```java\npublic synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\nsynchronized修饰普通方法中的同步锁就是这个对象本身，即\"this\"。\n\n下面的代码：\n\n```java\nclass Sync extends Thread{\n\tpublic synchronized void syncFunction(){\n\t\tdoSomething();\n\t}\n\t\n\tpublic void syncFunction2(){\n\t\tsynchronized (this) {\n\t\t\tdoSomething();\n\t\t}\n\t}\n\t\n\tprivate void doSomething(){\n\t\t//doSomething...\n\t}\n}\n```\n\n上面syncFunction()与syncFunction2()实现的同步效果是一样的。\n\n当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的\"this\"。\n\n### synchronized修饰静态方法\n\n```java\npublic static synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\n同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。\n\n不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。\n\n## 总结\n\n理解synchronized的关键就在于：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**这个同步锁，可以理解为一个对象。","source":"_posts/synchronized的一些用法.md","raw":"---\nlayout: post\ndate: 2016-08-16 15:31:44\ncategories: 编程\ntitle: synchronized的用法\ntags: \n- 多线程\n- java\ncomments: true\n---\n\n>以前的工作过程中，偶尔会遇到synchronized的使用，比如[这篇总结](http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/)。今天来总结一下自己对synchronized的关键字的一些认识。\n\n## 同步锁\n\nsynchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。\n\n每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：\n\n```java\nsynchronized (object) {\n\t//doSomething...\t\t\n}\n```\n\n上面的 '{' '}' 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。\n\n## synchronized修饰代码块\n\n### synchronized同步锁为普通对象\n\n```java\npublic void function(){\n\tsynchronized (object) {\n\t\t//doSomething...\t\t\n\t}\n}\n```\n<!-- more -->\n当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。\n\n下面的例子：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(new Object());\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n运行结果：\n\n```\nThread-0运行中...\nThread-1运行中...\nThread-2运行中...\nThread-3运行中...\nThread-4运行中...\nThread-1结束...\nThread-0结束...\nThread-3结束...\nThread-4结束...\nThread-2结束...\n```\n\n跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tObject object = new Object();\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync(object);\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tObject syncObj;\n\tpublic Sync(Object syncObj) {\n\t\tthis.syncObj = syncObj;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncObj) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```java\nThread-0运行中...\nThread-0结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。\n\n重点要理解：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**\n\n### synchronized同步锁为类\n\n类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。\n\n将上面的例子修改一下：\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-0结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\n```\n这些线程同样实现了同步，因为他们的同步锁是同一个对象--SyncTest类对象。\n\n需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。\n\n```java\npublic class SyncTest {\n\tpublic static void main(String args[]){\n\t\tSync[] syncs = new Sync[5];\n\t\tfor (int i = 0; i < syncs.length; i++) {\n\t\t\tsyncs[i] = new Sync();\n\t\t}\n\t\tSync1 sync1 = new Sync1(new SyncTest());\n\t\t\n\t\tfor(Sync sync : syncs){\n\t\t\tsync.start();\n\t\t}\n\t\t\n\t\tsync1.start();\n\t}\n}\nclass Sync extends Thread{\n\tpublic void run(){\n\t\tsynchronized (SyncTest.class) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n\nclass Sync1 extends Thread{\n\tSyncTest syncTest;\n\tpublic Sync1(SyncTest syncTest){\n\t\tthis.syncTest = syncTest;\n\t}\n\tpublic void run(){\n\t\tsynchronized (syncTest) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"运行中...\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"结束...\");\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n```\nThread-0运行中...\nThread-5运行中...\nThread-0结束...\nThread-5结束...\nThread-4运行中...\nThread-4结束...\nThread-2运行中...\nThread-2结束...\nThread-3运行中...\nThread-3结束...\nThread-1运行中...\nThread-1结束...\n```\n\n可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。\n\n## synchronized修饰方法\n\nsynchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。\n\n### synchronized修饰普通方法\n\n```java\npublic synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\nsynchronized修饰普通方法中的同步锁就是这个对象本身，即\"this\"。\n\n下面的代码：\n\n```java\nclass Sync extends Thread{\n\tpublic synchronized void syncFunction(){\n\t\tdoSomething();\n\t}\n\t\n\tpublic void syncFunction2(){\n\t\tsynchronized (this) {\n\t\t\tdoSomething();\n\t\t}\n\t}\n\t\n\tprivate void doSomething(){\n\t\t//doSomething...\n\t}\n}\n```\n\n上面syncFunction()与syncFunction2()实现的同步效果是一样的。\n\n当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的\"this\"。\n\n### synchronized修饰静态方法\n\n```java\npublic static synchronized void syncFunction(){\n\t\t//doSomething...\n}\n```\n同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。\n\n不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。\n\n## 总结\n\n理解synchronized的关键就在于：**若想要多个线程同步，则这些线程必须竞争同一个同步锁。**这个同步锁，可以理解为一个对象。","slug":"synchronized的一些用法","published":1,"updated":"2017-04-11T13:08:38.849Z","photos":[],"link":"","_id":"cj4vch4g2003rx3gcruq31d3n","content":"<blockquote>\n<p>以前的工作过程中，偶尔会遇到synchronized的使用，比如<a href=\"http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/\">这篇总结</a>。今天来总结一下自己对synchronized的关键字的一些认识。</p>\n</blockquote>\n<h2 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h2><p>synchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。</p>\n<p>每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的 ‘{‘ ‘}’ 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p>\n<h2 id=\"synchronized修饰代码块\"><a href=\"#synchronized修饰代码块\" class=\"headerlink\" title=\"synchronized修饰代码块\"></a>synchronized修饰代码块</h2><h3 id=\"synchronized同步锁为普通对象\"><a href=\"#synchronized同步锁为普通对象\" class=\"headerlink\" title=\"synchronized同步锁为普通对象\"></a>synchronized同步锁为普通对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。</p>\n<p>下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(<span class=\"keyword\">new</span> Object());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\tObject object = <span class=\"keyword\">new</span> Object();</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(object);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-<span class=\"number\">0</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">0</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">4</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">4</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">2</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">2</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">3</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">3</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">1</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">1</span>结束...</div></pre></td></tr></table></figure>\n<p>5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。</p>\n<p>重点要理解：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong></p>\n<h3 id=\"synchronized同步锁为类\"><a href=\"#synchronized同步锁为类\" class=\"headerlink\" title=\"synchronized同步锁为类\"></a>synchronized同步锁为类</h3><p>类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。</p>\n<p>将上面的例子修改一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>这些线程同样实现了同步，因为他们的同步锁是同一个对象–SyncTest类对象。</p>\n<p>需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSync1 sync1 = <span class=\"keyword\">new</span> Sync1(<span class=\"keyword\">new</span> SyncTest());</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsync1.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tSyncTest syncTest;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync1</span><span class=\"params\">(SyncTest syncTest)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncTest = syncTest;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncTest) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-5运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-5结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div></pre></td></tr></table></figure>\n<p>可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。</p>\n<h2 id=\"synchronized修饰方法\"><a href=\"#synchronized修饰方法\" class=\"headerlink\" title=\"synchronized修饰方法\"></a>synchronized修饰方法</h2><p>synchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。</p>\n<h3 id=\"synchronized修饰普通方法\"><a href=\"#synchronized修饰普通方法\" class=\"headerlink\" title=\"synchronized修饰普通方法\"></a>synchronized修饰普通方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>synchronized修饰普通方法中的同步锁就是这个对象本身，即”this”。</p>\n<p>下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tdoSomething();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\tdoSomething();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面syncFunction()与syncFunction2()实现的同步效果是一样的。</p>\n<p>当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的”this”。</p>\n<h3 id=\"synchronized修饰静态方法\"><a href=\"#synchronized修饰静态方法\" class=\"headerlink\" title=\"synchronized修饰静态方法\"></a>synchronized修饰静态方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。</p>\n<p>不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>理解synchronized的关键就在于：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong>这个同步锁，可以理解为一个对象。</p>\n","excerpt":"<blockquote>\n<p>以前的工作过程中，偶尔会遇到synchronized的使用，比如<a href=\"http://yukai.space/2015/12/21/notify%E9%97%AE%E9%A2%98/\">这篇总结</a>。今天来总结一下自己对synchronized的关键字的一些认识。</p>\n</blockquote>\n<h2 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h2><p>synchronized顾名思义，就是用来进行一些同步工作的，我们常常在多线程的环境中使用到它，实现互斥的效果。</p>\n<p>每一个java对象都可以当做一个同步锁，线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得锁的唯一途径就是进入这个锁的保护的同步代码块或方法。这里的同步代码块和同步方法，就是使用synchronized关键字标记的代码块和方法。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的 ‘{‘ ‘}’ 中间的内容，就是同步代码块，object可以认为是同步锁。同步锁实现了互斥的效果，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p>\n<h2 id=\"synchronized修饰代码块\"><a href=\"#synchronized修饰代码块\" class=\"headerlink\" title=\"synchronized修饰代码块\"></a>synchronized修饰代码块</h2><h3 id=\"synchronized同步锁为普通对象\"><a href=\"#synchronized同步锁为普通对象\" class=\"headerlink\" title=\"synchronized同步锁为普通对象\"></a>synchronized同步锁为普通对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (object) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...\t\t</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>当某个线程要访问上面同步代码块中的内容时，若此时没有其他线程获得object对象的锁，则此线程获得object对象的锁，获得了这段代码的执行权，否则，此线程被阻塞，直到其他线程释放了object对象的锁。</p>\n<p>下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(<span class=\"keyword\">new</span> Object());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>跟我们的预期不一样，这5个线程并没有按顺序执行，他们之间不是同步的。这是因为：5个线程中的syncObj并不是指向同一个对象，他们之间不存在同步锁的竞争，所以是非同步的。将程序改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\tObject object = <span class=\"keyword\">new</span> Object();</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync(object);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tObject syncObj;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync</span><span class=\"params\">(Object syncObj)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncObj = syncObj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncObj) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-<span class=\"number\">0</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">0</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">4</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">4</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">2</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">2</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">3</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">3</span>结束...</div><div class=\"line\">Thread-<span class=\"number\">1</span>运行中...</div><div class=\"line\">Thread-<span class=\"number\">1</span>结束...</div></pre></td></tr></table></figure>\n<p>5个线程达到了同步的效果。但是5个线程的执行顺序并不是固定的，这是编译时重排序造成的。</p>\n<p>重点要理解：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong></p>\n<h3 id=\"synchronized同步锁为类\"><a href=\"#synchronized同步锁为类\" class=\"headerlink\" title=\"synchronized同步锁为类\"></a>synchronized同步锁为类</h3><p>类也是一个对象，可以按照普通对象的方式去理解。他们的不同之处在于，普通对象作用于某个实例，而类对象作用于整个类。</p>\n<p>将上面的例子修改一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div></pre></td></tr></table></figure>\n<p>这些线程同样实现了同步，因为他们的同步锁是同一个对象–SyncTest类对象。</p>\n<p>需要注意的是，类对象锁和普通对象锁是两个不同的锁（即使这个对象是这个类的实例），他们之间互不干扰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tSync[] syncs = <span class=\"keyword\">new</span> Sync[<span class=\"number\">5</span>];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; syncs.length; i++) &#123;</div><div class=\"line\">\t\t\tsyncs[i] = <span class=\"keyword\">new</span> Sync();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSync1 sync1 = <span class=\"keyword\">new</span> Sync1(<span class=\"keyword\">new</span> SyncTest());</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(Sync sync : syncs)&#123;</div><div class=\"line\">\t\t\tsync.start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsync1.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SyncTest.class) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\tSyncTest syncTest;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sync1</span><span class=\"params\">(SyncTest syncTest)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.syncTest = syncTest;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (syncTest) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"运行中...\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\"结束...\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread-0运行中...</div><div class=\"line\">Thread-5运行中...</div><div class=\"line\">Thread-0结束...</div><div class=\"line\">Thread-5结束...</div><div class=\"line\">Thread-4运行中...</div><div class=\"line\">Thread-4结束...</div><div class=\"line\">Thread-2运行中...</div><div class=\"line\">Thread-2结束...</div><div class=\"line\">Thread-3运行中...</div><div class=\"line\">Thread-3结束...</div><div class=\"line\">Thread-1运行中...</div><div class=\"line\">Thread-1结束...</div></pre></td></tr></table></figure>\n<p>可以看到，虽然Sync1中的对象锁是SyncTest的实例，但是Sync1与Sync的run方法中的synchronized代码块并没有实现同步，他们可以同时访问这段代码。</p>\n<h2 id=\"synchronized修饰方法\"><a href=\"#synchronized修饰方法\" class=\"headerlink\" title=\"synchronized修饰方法\"></a>synchronized修饰方法</h2><p>synchronized修饰方法在本质上和修饰代码块是一样的，他们都是通过同步锁来实现同步的。</p>\n<h3 id=\"synchronized修饰普通方法\"><a href=\"#synchronized修饰普通方法\" class=\"headerlink\" title=\"synchronized修饰普通方法\"></a>synchronized修饰普通方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>synchronized修饰普通方法中的同步锁就是这个对象本身，即”this”。</p>\n<p>下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tdoSomething();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t\tdoSomething();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面syncFunction()与syncFunction2()实现的同步效果是一样的。</p>\n<p>当类中某个方法test()被synchronized关键字所修饰时，所有不同的线程访问这个类的同一个实例的test()方法都会实现同步的效果。不同的实例之间不存在同步锁的竞争，也就是说，不同的线程访问这个类不同实例的test()方法并不会实现同步。这很容易理解，因为不同的实例同步锁不同，每个实例都有自己的”this”。</p>\n<h3 id=\"synchronized修饰静态方法\"><a href=\"#synchronized修饰静态方法\" class=\"headerlink\" title=\"synchronized修饰静态方法\"></a>synchronized修饰静态方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">syncFunction</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的，此时的类对象就是静态方法所属的类。</p>\n<p>不同的线程访问某个类不同实例的syncFunction()方法(被synchronized修饰的静态方法，如上)时，他们之间实现了同步效果。结合上面的解释，这种情况也很好理解：此时不同线程竞争同一把同步锁，这就是这个类的类对象锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>理解synchronized的关键就在于：<strong>若想要多个线程同步，则这些线程必须竞争同一个同步锁。</strong>这个同步锁，可以理解为一个对象。</p>"},{"layout":"post","title":"ssl使用总结","date":"2016-09-25T02:09:10.000Z","_content":"\n>这次维护的web服务器要求使用Https双向认证，了解了一下如何在客户端和服务器之间进行ssl的配置，在此记录。另外，这篇日志主要记录如何使用，并不深入底层原理。\n\n## 简单认识ssl和证书\n\n在理解这部分内容之前，建议先看看前面对的一篇总结：[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)\n\nSSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。\n\nSSL协议提供的服务主要有：\n\n1、认证用户和服务器，确保数据发送到正确的客户机和服务器；\n\n2、加密数据以防止数据中途被窃取；\n\n3、维护数据的完整性，确保数据在传输过程中不被改变。\n\n其实，ssl就是一种协议。我们知道Http协议是明文传输的，安全性不高。Https就是在Http基础之上加一层ssl协议，来达到加密通信的目的。具体的ssl握手过程，可以参考[百度百科](http://baike.baidu.com/view/14121.htm#6)\n\n附上一张图方便理解：\n\n{% asset_img sslprocess.jpg sslprocess %}\n\n图片来自网络\n\n<!-- more -->\n\n可以看到ssl握手过程中服务器向客户端发送了自己的证书。这个证书是加密过程的重要内容。在前面的[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)这篇博客中，在关于数字证书的一节，我们知道了数字证书可以证明服务器的身份，服务器证书中包含了服务器的公钥，用于之后的通信。\n\n那么，简单了解下证书的工作原理。\n\n首先看一下证书中有哪些内容：\n\n{% asset_img zhifubao.png 支付宝证书 %}\n\n{% asset_img zhufubao1.png 支付宝证书 %}\n\n{% asset_img zhufubao2.png 支付宝证书 %}\n\n上面是我从谷chorme浏览器中截取的支付宝所使用证书的信息截图。\n\n可以看到，里面有颁发者和使用者。颁发者就是颁发此证书的CA(证书颁发机构),使用者就是与我们通信的服务器，也就是该证书的持有者。证书中还包含了我们上面提到的公钥。\n\n我们知道，证书能够证明服务器的身份，那么他是如何证明的呢？我们以浏览器为例：\n\n首先，浏览器(客户端)接收到服务器发来的证书A之后，会去验证这个证书A是否被篡改或者是伪造的。浏览器首先会去操作系统中内置根证书库中搜索A的颁发者的证书。关于这一点要解释一下，数字证书的颁发机构也有自己的证书，这个证书就是根证书，这个根证书在我的系统刚安装好时，就被微软等公司默认安装在操作系统当中了。\n\n如果在操作系统中找到了服务器证书中的颁发者的证书Root，那么继续下一步，否则，就知道这个服务器证书的颁发者是个不受信任的CA发布的，此时，浏览器会给出警告。若我们选择相信这个CA并继续，则继续下一步。\n\n接下来，浏览器从Root中得到Root的公钥，然后用该公钥对A中的指纹算法和指纹进行解密。注意，为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。\n\n那么什么是指纹算法和指纹呢？这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。\n\n此时就可以判断该证书是否是仿冒或者经过伪造篡改的。如没有，则证明这个服务器是可信任的。接下来就可以使用该服务器提供的公钥来进行通信了。\n\n通过上面的分析我们知道了，ssl协议中，首先通过证书来证明服务器的身份，然后取出证书中的公钥，接下来就可以按照[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)这篇博客中说到的通信方式通信了。这大概上就是ssl的原理，当然实际中ssl的细节还是要复杂很多。\n\n了解了ssl的基本原理，对我们实现服务器的https通信有很大的帮助。\n\n## Https 单向认证\n\n单向认证就是服务器必须向客户端发送自己的证书来证明自己的身份，然后进行加密通信。现在服务器的基础框架是springboot，演示如何配置服务器和客户端：\n\n服务器：\n\n打开springboot的配置文件application.properties:\n\nserver.ssl.key-store=server.keystore\n\nserver.ssl.key-store-password=123456\n\nserver.ssl.keyStoreType=JKS\n\nserver.ssl.keyAlias:server\n\n先解释一下上面几个配置：\n\n.keystore: keystore文件中存储了密钥和证书。密钥包括私钥和公钥，而证书中只包含公钥。这个证书就是我们上面所说的证书。注意：密钥和证书是一一对应的。\n\npassword: 生成keystore文件时所填的密码。\n\nkeyStoreType: keystore类型。\n\nkeyAlias: 生成密钥的别名。\n\nkeysotre文件是怎么生成的呢？使用jdk自带的工具：keytool。生成keystore文件的命令如下：\n\n`keytool -genkey -alias server -keyalg RSA -validity 365 -keystore server.keystore`\n\n其中：-alias 指定生成密钥的别名，-keystore 指定生成的keystore文件的位置和名称。其他的参数的含义可以通过keytool -help来查找。\n\n一个keystore文件中可以存储多个证书和证书对应的密钥，这些证书和其对应的密钥通过唯一的别名alias来指定，也就是说，通过alias可以导出证书。但是要注意，无法通过keytool导出私钥。\n\n看一下如何从keystore文件中导出证书：\n\n`keytool -export -alias server -keystore server.keystore -file serverCA.crt`\n\n-alias指定了要导出的证书文件，-file 指定了要导出的证书文件的位置和名称。\n\n了解了上面的几个配置，再结合之前对ssl原理的总结，不难知道：\n\n我们指定的别名(server.ssl.keyAlias:server)之后,服务器通过该别名从keystore文件中获得对应的证书，并将其发送给客户端，同时使用keystore中alias对应的私钥(keytool虽然导不出私钥，但可以通过代码等方式获得)可以对与客户端通信的内容进行加密和解密。这便是keystore文件的作用：存储证书和私钥。\n\n服务器端的配置完成了。现在有一个问题，虽然服务器可以发送证书到客户端了，但是客户端并不会信任我们这个证书。如果这个时候通过浏览器以https的方式访问服务器，浏览器会提醒你，此连接不受信任。那是因为虽然服务器将证书发送到了浏览器(客户端)，但是浏览器并不认为这个证书能够证明服务器的身份。那为什么https访问支付宝等网站没有报这个警告呢？想想上面的内容，浏览器或操作系统内置了颁发给支付宝证书的机构的根证书，通过这个根证书的公钥对支付宝发来的证书进行解密可以证明这个证书确实是由支付宝发过来的，从而证明了服务器的身份。\n\n虽然浏览器并不能验证我们的证书，我们可以手动的把证书添加到浏览器的信任列表中。这个证书就是我们上面通过keytool导出的证书，将这个证书手动添加到浏览器信任列表里面，再次访问服务器就不会有警告啦。(具体的添加方式不再赘述)(从这点上也可以看出自签名证书的不安全性，有可能被假冒和伪造)\n\nso,通过上面的方式我们已经将ssl单向验证配置好了。那么，如果客户端是自己用java写的呢？下面举一个例子，使用HttpsURLConnection实现：\n\n首先生成客户端的信任证书库，用来存放客户端所信任的证书：\n\n`keytool -keystore truststore.jks -alias client -import -trustcacerts -file serverCA.crt`\n\n-file 指定要信任的证书，此例中应该是我们上面导出的证书serverCA.crt\n\n-keystore 指定要生成的信任库路径和名称。\n\n然后生成我们自己的信任证书管理器：\n\n参考了网上的代码：\n\n```java\npublic class MyX509TrustManager implements X509TrustManager {\n\t/*\n\t * The default X509TrustManager returned by SunX509. We'll delegate\n\t * decisions to it, and fall back to the logic in this class if the default\n\t * X509TrustManager doesn't trust it.\n\t */\n\tX509TrustManager sunJSSEX509TrustManager;\n\n\tpublic MyX509TrustManager() throws Exception {\n\t\t// create a \"default\" JSSE X509TrustManager.\n\t\tKeyStore ks = KeyStore.getInstance(\"JKS\");\n\t\t//注意 src/clientTrustCA.jks就是上面生成的信任证书库\n\t\tks.load(new FileInputStream(\"src/clientTrustCA.jks\"), \"123456\".toCharArray());\n\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\", \"SunJSSE\");\n\t\ttmf.init(ks);\n\t\tTrustManager tms[] = tmf.getTrustManagers();\n\t\t/*\n\t\t * Iterate over the returned trustmanagers, look for an instance of\n\t\t * X509TrustManager. If found, use that as our \"default\" trust manager.\n\t\t */\n\t\tfor (int i = 0; i < tms.length; i++) {\n\t\t\tif (tms[i] instanceof X509TrustManager) {\n\t\t\t\tsunJSSEX509TrustManager = (X509TrustManager) tms[i];\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Find some other way to initialize, or else we have to fail the\n\t\t * constructor.\n\t\t */\n\t\tthrow new Exception(\"Couldn't initialize\");\n\t}\n\n\t/*\n\t * Delegate to the default trust manager.\n\t */\n\tpublic void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\ttry {\n\t\t\tsunJSSEX509TrustManager.checkClientTrusted(chain, authType);\n\t\t} catch (CertificateException excep) {\n\t\t\t// do any special handling here, or rethrow exception.\n\t\t}\n\t}\n\n\t/*\n\t * Delegate to the default trust manager.\n\t */\n\tpublic void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\ttry {\n\t\t\tsunJSSEX509TrustManager.checkServerTrusted(chain, authType);\n\t\t} catch (CertificateException excep) {\n\t\t\t/*\n\t\t\t * Possibly pop up a dialog box asking whether to trust the cert\n\t\t\t * chain.\n\t\t\t */\n\t\t}\n\t}\n\n\t/*\n\t * Merely pass this through.\n\t */\n\tpublic X509Certificate[] getAcceptedIssuers() {\n\t\treturn sunJSSEX509TrustManager.getAcceptedIssuers();\n\t}\n}\n```\n接着使用这个管理器：\n\n```java\n TrustManager[] tm = { new MyX509TrustManager() };\n SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n sslContext.init(null, tm, new java.security.SecureRandom());\n // 从上述SSLContext对象中得到SSLSocketFactory对象\n SSLSocketFactory ssf = sslContext.getSocketFactory();\n\n // 创建URL对象\n URL myURL = new URL(url);\n // 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象\n HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();\n httpsConn.setSSLSocketFactory(ssf);\n\n```\n\n接下来就可以使用这个HttpsURLConnection来访问服务器啦。\n\n## Https双向认证\n\n所谓的Https双向认证就是不仅仅客户端要验证浏览器的身份，浏览器也要向服务器证明自己的身份，也就是第一幅图片中的5。\n\n理解了单向认证，双向认证实现起来也就不难了。\n\n首先像我们之前一样使用keytool生成keystore文件client.keystore，这个文件是为客户端使用准备的。\n\n然后通过client.keystore导出证书client.crt。\n\n接着生成信任库文件serverTrust.jks,将client.crt导入其中。\n\n在单向认证中我们给出了客户端单向认证时的java代码，用来下面给出双向认证的代码：\n\n生成读取keystore的类：\n\n```java\npublic class MyKeyManager{\n\t// 相关的 jks 文件及其密码定义\n\t private final static String CERT_STORE=\"src/client.keystore\";\n\t private final static String CERT_STORE_PASSWORD=\"123456\";\n\t \n\t public static KeyManager[] getKeyManagers() throws Exception{\n\t\t // 载入 jks 文件\n\t\t FileInputStream f_certStore=new FileInputStream(CERT_STORE); \n\t\t KeyStore ks=KeyStore.getInstance(\"jks\"); \n\t\t ks.load(f_certStore, CERT_STORE_PASSWORD.toCharArray()); \n\t\t f_certStore.close(); \n\n\t\t // 创建并初始化证书库工厂\n\t\t String alg=KeyManagerFactory.getDefaultAlgorithm(); \n\t\t KeyManagerFactory kmFact=KeyManagerFactory.getInstance(alg); \n\t\t kmFact.init(ks, CERT_STORE_PASSWORD.toCharArray()); \n\n\t\t KeyManager[] kms=kmFact.getKeyManagers(); \n\t\t return kms;\n\t }\n}\n```\n\n像上面单向认证中那样使用它：\n\n```java \n TrustManager[] tm = { new MyX509TrustManager() };\n KeyManager[] km = MyKeyManager.getKeyManagers();\n SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n sslContext.init(km, tm, new java.security.SecureRandom());\n // 从上述SSLContext对象中得到SSLSocketFactory对象\n SSLSocketFactory ssf = sslContext.getSocketFactory();\n\n // 创建URL对象\n URL myURL = new URL(url);\n // 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象\n HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();\n httpsConn.setSSLSocketFactory(ssf);\n```\n\n然后使用HttpsURLConnection就可以使用了。但是此时服务器端还需要配置，因为客户端仅仅是将自己的证书发过去了，服务器应该如何信任它呢？\n\n打开springboot的配置文件application.properties添加以下配置:\n\n#Whether client authentication is wanted (\"want\") or needed (\"need\"). Requires a trust store.\n\nserver.ssl.client-auth=need\n\nserver.ssl.trust-store=serverTrust.jks \n\nserver.ssl.trust-store-password=123456\n\n其中，serverTrust.jks就是刚刚生成的服务器端信任库。\n\n以上步骤全部做完，服务器和客户端就可以愉快的使用Https进行双向认证通信了。\n\n## 关于证书的一些格式\n\n在使用keytool和openssl的时候，会发现有好多种格式让人头晕眼花。不妨参考这篇文章：[那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)](http://www.cnblogs.com/guogangj/p/4118605.html)\n\n我现在也不是理解的十分清楚，故不再赘述。\n\n## 总结\n\n感觉这篇博客没有把自己想要总结的内容全部记录下来，但是现在也不想再写了。服务器实际测试的时候是使用curl这样一个命令行浏览器进行的，使用curl作为客户端进行双向认证的时候也遇到了不少问题，总结了一份配置的[readme](https://github.com/Hikyu/SSL-Configuration/blob/master/ssl%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE.md)，放在github上面，以作记录。readme中的配置方法可能还有一些瑕疵，有些格式转换可能会有冗余，但是整个配置是没有问题的，经过了自己的验证。证书这一块内容感觉还不是理解的特别透彻，尤其是ssl协议的交互和证书格式的一些问题，留作以后学习吧！真的不想看了...\n\n## 参考\n\n[数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html):这篇一定要看，总结的很好！\n\n[浏览器和SSL证书通讯过程](http://www.live-in.org/archives/1302.html)\n\n[Java安全通信：HTTPS与SSL](http://www.cnblogs.com/devinzhang/archive/2012/02/28/2371631.html)\n\n[Java 安全套接字编程以及 keytool 使用最佳实践](http://www.ibm.com/developerworks/cn/java/j-lo-socketkeytool/)\n\n[openssl生成SSL证书的流程](http://blog.csdn.net/liuchunming033/article/details/48470575)\n\n[如何添加自签名SSL证书 自签名SSL证书存风险](https://freessl.wosign.com/911.html)\n\n[keystore提取私钥和证书(重要×××)](http://www.360doc.com/content/11/1226/02/3700464_174996042.shtml)\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/ssl总结.md","raw":"---\nlayout: post\ntitle: ssl使用总结\ndate: 2016-09-25 10:09:10\ncategories: 技术 \ntags: \n- java\n- 加密\n---\n\n>这次维护的web服务器要求使用Https双向认证，了解了一下如何在客户端和服务器之间进行ssl的配置，在此记录。另外，这篇日志主要记录如何使用，并不深入底层原理。\n\n## 简单认识ssl和证书\n\n在理解这部分内容之前，建议先看看前面对的一篇总结：[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)\n\nSSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。\n\nSSL协议提供的服务主要有：\n\n1、认证用户和服务器，确保数据发送到正确的客户机和服务器；\n\n2、加密数据以防止数据中途被窃取；\n\n3、维护数据的完整性，确保数据在传输过程中不被改变。\n\n其实，ssl就是一种协议。我们知道Http协议是明文传输的，安全性不高。Https就是在Http基础之上加一层ssl协议，来达到加密通信的目的。具体的ssl握手过程，可以参考[百度百科](http://baike.baidu.com/view/14121.htm#6)\n\n附上一张图方便理解：\n\n{% asset_img sslprocess.jpg sslprocess %}\n\n图片来自网络\n\n<!-- more -->\n\n可以看到ssl握手过程中服务器向客户端发送了自己的证书。这个证书是加密过程的重要内容。在前面的[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)这篇博客中，在关于数字证书的一节，我们知道了数字证书可以证明服务器的身份，服务器证书中包含了服务器的公钥，用于之后的通信。\n\n那么，简单了解下证书的工作原理。\n\n首先看一下证书中有哪些内容：\n\n{% asset_img zhifubao.png 支付宝证书 %}\n\n{% asset_img zhufubao1.png 支付宝证书 %}\n\n{% asset_img zhufubao2.png 支付宝证书 %}\n\n上面是我从谷chorme浏览器中截取的支付宝所使用证书的信息截图。\n\n可以看到，里面有颁发者和使用者。颁发者就是颁发此证书的CA(证书颁发机构),使用者就是与我们通信的服务器，也就是该证书的持有者。证书中还包含了我们上面提到的公钥。\n\n我们知道，证书能够证明服务器的身份，那么他是如何证明的呢？我们以浏览器为例：\n\n首先，浏览器(客户端)接收到服务器发来的证书A之后，会去验证这个证书A是否被篡改或者是伪造的。浏览器首先会去操作系统中内置根证书库中搜索A的颁发者的证书。关于这一点要解释一下，数字证书的颁发机构也有自己的证书，这个证书就是根证书，这个根证书在我的系统刚安装好时，就被微软等公司默认安装在操作系统当中了。\n\n如果在操作系统中找到了服务器证书中的颁发者的证书Root，那么继续下一步，否则，就知道这个服务器证书的颁发者是个不受信任的CA发布的，此时，浏览器会给出警告。若我们选择相信这个CA并继续，则继续下一步。\n\n接下来，浏览器从Root中得到Root的公钥，然后用该公钥对A中的指纹算法和指纹进行解密。注意，为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。\n\n那么什么是指纹算法和指纹呢？这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。\n\n此时就可以判断该证书是否是仿冒或者经过伪造篡改的。如没有，则证明这个服务器是可信任的。接下来就可以使用该服务器提供的公钥来进行通信了。\n\n通过上面的分析我们知道了，ssl协议中，首先通过证书来证明服务器的身份，然后取出证书中的公钥，接下来就可以按照[关于加密的一点总结](http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/)这篇博客中说到的通信方式通信了。这大概上就是ssl的原理，当然实际中ssl的细节还是要复杂很多。\n\n了解了ssl的基本原理，对我们实现服务器的https通信有很大的帮助。\n\n## Https 单向认证\n\n单向认证就是服务器必须向客户端发送自己的证书来证明自己的身份，然后进行加密通信。现在服务器的基础框架是springboot，演示如何配置服务器和客户端：\n\n服务器：\n\n打开springboot的配置文件application.properties:\n\nserver.ssl.key-store=server.keystore\n\nserver.ssl.key-store-password=123456\n\nserver.ssl.keyStoreType=JKS\n\nserver.ssl.keyAlias:server\n\n先解释一下上面几个配置：\n\n.keystore: keystore文件中存储了密钥和证书。密钥包括私钥和公钥，而证书中只包含公钥。这个证书就是我们上面所说的证书。注意：密钥和证书是一一对应的。\n\npassword: 生成keystore文件时所填的密码。\n\nkeyStoreType: keystore类型。\n\nkeyAlias: 生成密钥的别名。\n\nkeysotre文件是怎么生成的呢？使用jdk自带的工具：keytool。生成keystore文件的命令如下：\n\n`keytool -genkey -alias server -keyalg RSA -validity 365 -keystore server.keystore`\n\n其中：-alias 指定生成密钥的别名，-keystore 指定生成的keystore文件的位置和名称。其他的参数的含义可以通过keytool -help来查找。\n\n一个keystore文件中可以存储多个证书和证书对应的密钥，这些证书和其对应的密钥通过唯一的别名alias来指定，也就是说，通过alias可以导出证书。但是要注意，无法通过keytool导出私钥。\n\n看一下如何从keystore文件中导出证书：\n\n`keytool -export -alias server -keystore server.keystore -file serverCA.crt`\n\n-alias指定了要导出的证书文件，-file 指定了要导出的证书文件的位置和名称。\n\n了解了上面的几个配置，再结合之前对ssl原理的总结，不难知道：\n\n我们指定的别名(server.ssl.keyAlias:server)之后,服务器通过该别名从keystore文件中获得对应的证书，并将其发送给客户端，同时使用keystore中alias对应的私钥(keytool虽然导不出私钥，但可以通过代码等方式获得)可以对与客户端通信的内容进行加密和解密。这便是keystore文件的作用：存储证书和私钥。\n\n服务器端的配置完成了。现在有一个问题，虽然服务器可以发送证书到客户端了，但是客户端并不会信任我们这个证书。如果这个时候通过浏览器以https的方式访问服务器，浏览器会提醒你，此连接不受信任。那是因为虽然服务器将证书发送到了浏览器(客户端)，但是浏览器并不认为这个证书能够证明服务器的身份。那为什么https访问支付宝等网站没有报这个警告呢？想想上面的内容，浏览器或操作系统内置了颁发给支付宝证书的机构的根证书，通过这个根证书的公钥对支付宝发来的证书进行解密可以证明这个证书确实是由支付宝发过来的，从而证明了服务器的身份。\n\n虽然浏览器并不能验证我们的证书，我们可以手动的把证书添加到浏览器的信任列表中。这个证书就是我们上面通过keytool导出的证书，将这个证书手动添加到浏览器信任列表里面，再次访问服务器就不会有警告啦。(具体的添加方式不再赘述)(从这点上也可以看出自签名证书的不安全性，有可能被假冒和伪造)\n\nso,通过上面的方式我们已经将ssl单向验证配置好了。那么，如果客户端是自己用java写的呢？下面举一个例子，使用HttpsURLConnection实现：\n\n首先生成客户端的信任证书库，用来存放客户端所信任的证书：\n\n`keytool -keystore truststore.jks -alias client -import -trustcacerts -file serverCA.crt`\n\n-file 指定要信任的证书，此例中应该是我们上面导出的证书serverCA.crt\n\n-keystore 指定要生成的信任库路径和名称。\n\n然后生成我们自己的信任证书管理器：\n\n参考了网上的代码：\n\n```java\npublic class MyX509TrustManager implements X509TrustManager {\n\t/*\n\t * The default X509TrustManager returned by SunX509. We'll delegate\n\t * decisions to it, and fall back to the logic in this class if the default\n\t * X509TrustManager doesn't trust it.\n\t */\n\tX509TrustManager sunJSSEX509TrustManager;\n\n\tpublic MyX509TrustManager() throws Exception {\n\t\t// create a \"default\" JSSE X509TrustManager.\n\t\tKeyStore ks = KeyStore.getInstance(\"JKS\");\n\t\t//注意 src/clientTrustCA.jks就是上面生成的信任证书库\n\t\tks.load(new FileInputStream(\"src/clientTrustCA.jks\"), \"123456\".toCharArray());\n\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\", \"SunJSSE\");\n\t\ttmf.init(ks);\n\t\tTrustManager tms[] = tmf.getTrustManagers();\n\t\t/*\n\t\t * Iterate over the returned trustmanagers, look for an instance of\n\t\t * X509TrustManager. If found, use that as our \"default\" trust manager.\n\t\t */\n\t\tfor (int i = 0; i < tms.length; i++) {\n\t\t\tif (tms[i] instanceof X509TrustManager) {\n\t\t\t\tsunJSSEX509TrustManager = (X509TrustManager) tms[i];\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Find some other way to initialize, or else we have to fail the\n\t\t * constructor.\n\t\t */\n\t\tthrow new Exception(\"Couldn't initialize\");\n\t}\n\n\t/*\n\t * Delegate to the default trust manager.\n\t */\n\tpublic void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\ttry {\n\t\t\tsunJSSEX509TrustManager.checkClientTrusted(chain, authType);\n\t\t} catch (CertificateException excep) {\n\t\t\t// do any special handling here, or rethrow exception.\n\t\t}\n\t}\n\n\t/*\n\t * Delegate to the default trust manager.\n\t */\n\tpublic void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\ttry {\n\t\t\tsunJSSEX509TrustManager.checkServerTrusted(chain, authType);\n\t\t} catch (CertificateException excep) {\n\t\t\t/*\n\t\t\t * Possibly pop up a dialog box asking whether to trust the cert\n\t\t\t * chain.\n\t\t\t */\n\t\t}\n\t}\n\n\t/*\n\t * Merely pass this through.\n\t */\n\tpublic X509Certificate[] getAcceptedIssuers() {\n\t\treturn sunJSSEX509TrustManager.getAcceptedIssuers();\n\t}\n}\n```\n接着使用这个管理器：\n\n```java\n TrustManager[] tm = { new MyX509TrustManager() };\n SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n sslContext.init(null, tm, new java.security.SecureRandom());\n // 从上述SSLContext对象中得到SSLSocketFactory对象\n SSLSocketFactory ssf = sslContext.getSocketFactory();\n\n // 创建URL对象\n URL myURL = new URL(url);\n // 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象\n HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();\n httpsConn.setSSLSocketFactory(ssf);\n\n```\n\n接下来就可以使用这个HttpsURLConnection来访问服务器啦。\n\n## Https双向认证\n\n所谓的Https双向认证就是不仅仅客户端要验证浏览器的身份，浏览器也要向服务器证明自己的身份，也就是第一幅图片中的5。\n\n理解了单向认证，双向认证实现起来也就不难了。\n\n首先像我们之前一样使用keytool生成keystore文件client.keystore，这个文件是为客户端使用准备的。\n\n然后通过client.keystore导出证书client.crt。\n\n接着生成信任库文件serverTrust.jks,将client.crt导入其中。\n\n在单向认证中我们给出了客户端单向认证时的java代码，用来下面给出双向认证的代码：\n\n生成读取keystore的类：\n\n```java\npublic class MyKeyManager{\n\t// 相关的 jks 文件及其密码定义\n\t private final static String CERT_STORE=\"src/client.keystore\";\n\t private final static String CERT_STORE_PASSWORD=\"123456\";\n\t \n\t public static KeyManager[] getKeyManagers() throws Exception{\n\t\t // 载入 jks 文件\n\t\t FileInputStream f_certStore=new FileInputStream(CERT_STORE); \n\t\t KeyStore ks=KeyStore.getInstance(\"jks\"); \n\t\t ks.load(f_certStore, CERT_STORE_PASSWORD.toCharArray()); \n\t\t f_certStore.close(); \n\n\t\t // 创建并初始化证书库工厂\n\t\t String alg=KeyManagerFactory.getDefaultAlgorithm(); \n\t\t KeyManagerFactory kmFact=KeyManagerFactory.getInstance(alg); \n\t\t kmFact.init(ks, CERT_STORE_PASSWORD.toCharArray()); \n\n\t\t KeyManager[] kms=kmFact.getKeyManagers(); \n\t\t return kms;\n\t }\n}\n```\n\n像上面单向认证中那样使用它：\n\n```java \n TrustManager[] tm = { new MyX509TrustManager() };\n KeyManager[] km = MyKeyManager.getKeyManagers();\n SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n sslContext.init(km, tm, new java.security.SecureRandom());\n // 从上述SSLContext对象中得到SSLSocketFactory对象\n SSLSocketFactory ssf = sslContext.getSocketFactory();\n\n // 创建URL对象\n URL myURL = new URL(url);\n // 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象\n HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();\n httpsConn.setSSLSocketFactory(ssf);\n```\n\n然后使用HttpsURLConnection就可以使用了。但是此时服务器端还需要配置，因为客户端仅仅是将自己的证书发过去了，服务器应该如何信任它呢？\n\n打开springboot的配置文件application.properties添加以下配置:\n\n#Whether client authentication is wanted (\"want\") or needed (\"need\"). Requires a trust store.\n\nserver.ssl.client-auth=need\n\nserver.ssl.trust-store=serverTrust.jks \n\nserver.ssl.trust-store-password=123456\n\n其中，serverTrust.jks就是刚刚生成的服务器端信任库。\n\n以上步骤全部做完，服务器和客户端就可以愉快的使用Https进行双向认证通信了。\n\n## 关于证书的一些格式\n\n在使用keytool和openssl的时候，会发现有好多种格式让人头晕眼花。不妨参考这篇文章：[那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)](http://www.cnblogs.com/guogangj/p/4118605.html)\n\n我现在也不是理解的十分清楚，故不再赘述。\n\n## 总结\n\n感觉这篇博客没有把自己想要总结的内容全部记录下来，但是现在也不想再写了。服务器实际测试的时候是使用curl这样一个命令行浏览器进行的，使用curl作为客户端进行双向认证的时候也遇到了不少问题，总结了一份配置的[readme](https://github.com/Hikyu/SSL-Configuration/blob/master/ssl%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE.md)，放在github上面，以作记录。readme中的配置方法可能还有一些瑕疵，有些格式转换可能会有冗余，但是整个配置是没有问题的，经过了自己的验证。证书这一块内容感觉还不是理解的特别透彻，尤其是ssl协议的交互和证书格式的一些问题，留作以后学习吧！真的不想看了...\n\n## 参考\n\n[数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html):这篇一定要看，总结的很好！\n\n[浏览器和SSL证书通讯过程](http://www.live-in.org/archives/1302.html)\n\n[Java安全通信：HTTPS与SSL](http://www.cnblogs.com/devinzhang/archive/2012/02/28/2371631.html)\n\n[Java 安全套接字编程以及 keytool 使用最佳实践](http://www.ibm.com/developerworks/cn/java/j-lo-socketkeytool/)\n\n[openssl生成SSL证书的流程](http://blog.csdn.net/liuchunming033/article/details/48470575)\n\n[如何添加自签名SSL证书 自签名SSL证书存风险](https://freessl.wosign.com/911.html)\n\n[keystore提取私钥和证书(重要×××)](http://www.360doc.com/content/11/1226/02/3700464_174996042.shtml)\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"ssl总结","published":1,"updated":"2017-04-11T13:08:38.847Z","comments":1,"photos":[],"link":"","_id":"cj4vch4g4003ux3gc4uxol5mv","content":"<blockquote>\n<p>这次维护的web服务器要求使用Https双向认证，了解了一下如何在客户端和服务器之间进行ssl的配置，在此记录。另外，这篇日志主要记录如何使用，并不深入底层原理。</p>\n</blockquote>\n<h2 id=\"简单认识ssl和证书\"><a href=\"#简单认识ssl和证书\" class=\"headerlink\" title=\"简单认识ssl和证书\"></a>简单认识ssl和证书</h2><p>在理解这部分内容之前，建议先看看前面对的一篇总结：<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a></p>\n<p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</p>\n<p>SSL协议提供的服务主要有：</p>\n<p>1、认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>\n<p>2、加密数据以防止数据中途被窃取；</p>\n<p>3、维护数据的完整性，确保数据在传输过程中不被改变。</p>\n<p>其实，ssl就是一种协议。我们知道Http协议是明文传输的，安全性不高。Https就是在Http基础之上加一层ssl协议，来达到加密通信的目的。具体的ssl握手过程，可以参考<a href=\"http://baike.baidu.com/view/14121.htm#6\" target=\"_blank\" rel=\"external\">百度百科</a></p>\n<p>附上一张图方便理解：</p>\n<img src=\"/2016/09/25/ssl总结/sslprocess.jpg\" alt=\"sslprocess\" title=\"sslprocess\">\n<p>图片来自网络</p>\n<a id=\"more\"></a>\n<p>可以看到ssl握手过程中服务器向客户端发送了自己的证书。这个证书是加密过程的重要内容。在前面的<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a>这篇博客中，在关于数字证书的一节，我们知道了数字证书可以证明服务器的身份，服务器证书中包含了服务器的公钥，用于之后的通信。</p>\n<p>那么，简单了解下证书的工作原理。</p>\n<p>首先看一下证书中有哪些内容：</p>\n<img src=\"/2016/09/25/ssl总结/zhifubao.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<img src=\"/2016/09/25/ssl总结/zhufubao1.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<img src=\"/2016/09/25/ssl总结/zhufubao2.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<p>上面是我从谷chorme浏览器中截取的支付宝所使用证书的信息截图。</p>\n<p>可以看到，里面有颁发者和使用者。颁发者就是颁发此证书的CA(证书颁发机构),使用者就是与我们通信的服务器，也就是该证书的持有者。证书中还包含了我们上面提到的公钥。</p>\n<p>我们知道，证书能够证明服务器的身份，那么他是如何证明的呢？我们以浏览器为例：</p>\n<p>首先，浏览器(客户端)接收到服务器发来的证书A之后，会去验证这个证书A是否被篡改或者是伪造的。浏览器首先会去操作系统中内置根证书库中搜索A的颁发者的证书。关于这一点要解释一下，数字证书的颁发机构也有自己的证书，这个证书就是根证书，这个根证书在我的系统刚安装好时，就被微软等公司默认安装在操作系统当中了。</p>\n<p>如果在操作系统中找到了服务器证书中的颁发者的证书Root，那么继续下一步，否则，就知道这个服务器证书的颁发者是个不受信任的CA发布的，此时，浏览器会给出警告。若我们选择相信这个CA并继续，则继续下一步。</p>\n<p>接下来，浏览器从Root中得到Root的公钥，然后用该公钥对A中的指纹算法和指纹进行解密。注意，为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。</p>\n<p>那么什么是指纹算法和指纹呢？这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。</p>\n<p>此时就可以判断该证书是否是仿冒或者经过伪造篡改的。如没有，则证明这个服务器是可信任的。接下来就可以使用该服务器提供的公钥来进行通信了。</p>\n<p>通过上面的分析我们知道了，ssl协议中，首先通过证书来证明服务器的身份，然后取出证书中的公钥，接下来就可以按照<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a>这篇博客中说到的通信方式通信了。这大概上就是ssl的原理，当然实际中ssl的细节还是要复杂很多。</p>\n<p>了解了ssl的基本原理，对我们实现服务器的https通信有很大的帮助。</p>\n<h2 id=\"Https-单向认证\"><a href=\"#Https-单向认证\" class=\"headerlink\" title=\"Https 单向认证\"></a>Https 单向认证</h2><p>单向认证就是服务器必须向客户端发送自己的证书来证明自己的身份，然后进行加密通信。现在服务器的基础框架是springboot，演示如何配置服务器和客户端：</p>\n<p>服务器：</p>\n<p>打开springboot的配置文件application.properties:</p>\n<p>server.ssl.key-store=server.keystore</p>\n<p>server.ssl.key-store-password=123456</p>\n<p>server.ssl.keyStoreType=JKS</p>\n<p>server.ssl.keyAlias:server</p>\n<p>先解释一下上面几个配置：</p>\n<p>.keystore: keystore文件中存储了密钥和证书。密钥包括私钥和公钥，而证书中只包含公钥。这个证书就是我们上面所说的证书。注意：密钥和证书是一一对应的。</p>\n<p>password: 生成keystore文件时所填的密码。</p>\n<p>keyStoreType: keystore类型。</p>\n<p>keyAlias: 生成密钥的别名。</p>\n<p>keysotre文件是怎么生成的呢？使用jdk自带的工具：keytool。生成keystore文件的命令如下：</p>\n<p><code>keytool -genkey -alias server -keyalg RSA -validity 365 -keystore server.keystore</code></p>\n<p>其中：-alias 指定生成密钥的别名，-keystore 指定生成的keystore文件的位置和名称。其他的参数的含义可以通过keytool -help来查找。</p>\n<p>一个keystore文件中可以存储多个证书和证书对应的密钥，这些证书和其对应的密钥通过唯一的别名alias来指定，也就是说，通过alias可以导出证书。但是要注意，无法通过keytool导出私钥。</p>\n<p>看一下如何从keystore文件中导出证书：</p>\n<p><code>keytool -export -alias server -keystore server.keystore -file serverCA.crt</code></p>\n<p>-alias指定了要导出的证书文件，-file 指定了要导出的证书文件的位置和名称。</p>\n<p>了解了上面的几个配置，再结合之前对ssl原理的总结，不难知道：</p>\n<p>我们指定的别名(server.ssl.keyAlias:server)之后,服务器通过该别名从keystore文件中获得对应的证书，并将其发送给客户端，同时使用keystore中alias对应的私钥(keytool虽然导不出私钥，但可以通过代码等方式获得)可以对与客户端通信的内容进行加密和解密。这便是keystore文件的作用：存储证书和私钥。</p>\n<p>服务器端的配置完成了。现在有一个问题，虽然服务器可以发送证书到客户端了，但是客户端并不会信任我们这个证书。如果这个时候通过浏览器以https的方式访问服务器，浏览器会提醒你，此连接不受信任。那是因为虽然服务器将证书发送到了浏览器(客户端)，但是浏览器并不认为这个证书能够证明服务器的身份。那为什么https访问支付宝等网站没有报这个警告呢？想想上面的内容，浏览器或操作系统内置了颁发给支付宝证书的机构的根证书，通过这个根证书的公钥对支付宝发来的证书进行解密可以证明这个证书确实是由支付宝发过来的，从而证明了服务器的身份。</p>\n<p>虽然浏览器并不能验证我们的证书，我们可以手动的把证书添加到浏览器的信任列表中。这个证书就是我们上面通过keytool导出的证书，将这个证书手动添加到浏览器信任列表里面，再次访问服务器就不会有警告啦。(具体的添加方式不再赘述)(从这点上也可以看出自签名证书的不安全性，有可能被假冒和伪造)</p>\n<p>so,通过上面的方式我们已经将ssl单向验证配置好了。那么，如果客户端是自己用java写的呢？下面举一个例子，使用HttpsURLConnection实现：</p>\n<p>首先生成客户端的信任证书库，用来存放客户端所信任的证书：</p>\n<p><code>keytool -keystore truststore.jks -alias client -import -trustcacerts -file serverCA.crt</code></p>\n<p>-file 指定要信任的证书，此例中应该是我们上面导出的证书serverCA.crt</p>\n<p>-keystore 指定要生成的信任库路径和名称。</p>\n<p>然后生成我们自己的信任证书管理器：</p>\n<p>参考了网上的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyX509TrustManager</span> <span class=\"keyword\">implements</span> <span class=\"title\">X509TrustManager</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t * The default X509TrustManager returned by SunX509. We'll delegate</div><div class=\"line\">\t * decisions to it, and fall back to the logic in this class if the default</div><div class=\"line\">\t * X509TrustManager doesn't trust it.</div><div class=\"line\">\t */</div><div class=\"line\">\tX509TrustManager sunJSSEX509TrustManager;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyX509TrustManager</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// create a \"default\" JSSE X509TrustManager.</span></div><div class=\"line\">\t\tKeyStore ks = KeyStore.getInstance(<span class=\"string\">\"JKS\"</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//注意 src/clientTrustCA.jks就是上面生成的信任证书库</span></div><div class=\"line\">\t\tks.load(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"src/clientTrustCA.jks\"</span>), <span class=\"string\">\"123456\"</span>.toCharArray());</div><div class=\"line\">\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(<span class=\"string\">\"SunX509\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">\t\ttmf.init(ks);</div><div class=\"line\">\t\tTrustManager tms[] = tmf.getTrustManagers();</div><div class=\"line\">\t\t<span class=\"comment\">/*</span></div><div class=\"line\">\t\t * Iterate over the returned trustmanagers, look for an instance of</div><div class=\"line\">\t\t * X509TrustManager. If found, use that as our \"default\" trust manager.</div><div class=\"line\">\t\t */</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tms.length; i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tms[i] <span class=\"keyword\">instanceof</span> X509TrustManager) &#123;</div><div class=\"line\">\t\t\t\tsunJSSEX509TrustManager = (X509TrustManager) tms[i];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">/*</span></div><div class=\"line\">\t\t * Find some other way to initialize, or else we have to fail the</div><div class=\"line\">\t\t * constructor.</div><div class=\"line\">\t\t */</div><div class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Couldn't initialize\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t * Delegate to the default trust manager.</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkClientTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsunJSSEX509TrustManager.checkClientTrusted(chain, authType);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CertificateException excep) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// do any special handling here, or rethrow exception.</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t * Delegate to the default trust manager.</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkServerTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsunJSSEX509TrustManager.checkServerTrusted(chain, authType);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CertificateException excep) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">/*</span></div><div class=\"line\">\t\t\t * Possibly pop up a dialog box asking whether to trust the cert</div><div class=\"line\">\t\t\t * chain.</div><div class=\"line\">\t\t\t */</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t * Merely pass this through.</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"keyword\">public</span> X509Certificate[] getAcceptedIssuers() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> sunJSSEX509TrustManager.getAcceptedIssuers();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接着使用这个管理器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManager[] tm = &#123; <span class=\"keyword\">new</span> MyX509TrustManager() &#125;;</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(<span class=\"string\">\"SSL\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">sslContext.init(<span class=\"keyword\">null</span>, tm, <span class=\"keyword\">new</span> java.security.SecureRandom());</div><div class=\"line\"><span class=\"comment\">// 从上述SSLContext对象中得到SSLSocketFactory对象</span></div><div class=\"line\">SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建URL对象</span></div><div class=\"line\">URL myURL = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\"><span class=\"comment\">// 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></div><div class=\"line\">HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();</div><div class=\"line\">httpsConn.setSSLSocketFactory(ssf);</div></pre></td></tr></table></figure>\n<p>接下来就可以使用这个HttpsURLConnection来访问服务器啦。</p>\n<h2 id=\"Https双向认证\"><a href=\"#Https双向认证\" class=\"headerlink\" title=\"Https双向认证\"></a>Https双向认证</h2><p>所谓的Https双向认证就是不仅仅客户端要验证浏览器的身份，浏览器也要向服务器证明自己的身份，也就是第一幅图片中的5。</p>\n<p>理解了单向认证，双向认证实现起来也就不难了。</p>\n<p>首先像我们之前一样使用keytool生成keystore文件client.keystore，这个文件是为客户端使用准备的。</p>\n<p>然后通过client.keystore导出证书client.crt。</p>\n<p>接着生成信任库文件serverTrust.jks,将client.crt导入其中。</p>\n<p>在单向认证中我们给出了客户端单向认证时的java代码，用来下面给出双向认证的代码：</p>\n<p>生成读取keystore的类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyKeyManager</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 相关的 jks 文件及其密码定义</span></div><div class=\"line\">\t <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CERT_STORE=<span class=\"string\">\"src/client.keystore\"</span>;</div><div class=\"line\">\t <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CERT_STORE_PASSWORD=<span class=\"string\">\"123456\"</span>;</div><div class=\"line\">\t </div><div class=\"line\">\t <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> KeyManager[] getKeyManagers() <span class=\"keyword\">throws</span> Exception&#123;</div><div class=\"line\">\t\t <span class=\"comment\">// 载入 jks 文件</span></div><div class=\"line\">\t\t FileInputStream f_certStore=<span class=\"keyword\">new</span> FileInputStream(CERT_STORE); </div><div class=\"line\">\t\t KeyStore ks=KeyStore.getInstance(<span class=\"string\">\"jks\"</span>); </div><div class=\"line\">\t\t ks.load(f_certStore, CERT_STORE_PASSWORD.toCharArray()); </div><div class=\"line\">\t\t f_certStore.close(); </div><div class=\"line\"></div><div class=\"line\">\t\t <span class=\"comment\">// 创建并初始化证书库工厂</span></div><div class=\"line\">\t\t String alg=KeyManagerFactory.getDefaultAlgorithm(); </div><div class=\"line\">\t\t KeyManagerFactory kmFact=KeyManagerFactory.getInstance(alg); </div><div class=\"line\">\t\t kmFact.init(ks, CERT_STORE_PASSWORD.toCharArray()); </div><div class=\"line\"></div><div class=\"line\">\t\t KeyManager[] kms=kmFact.getKeyManagers(); </div><div class=\"line\">\t\t <span class=\"keyword\">return</span> kms;</div><div class=\"line\">\t &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面单向认证中那样使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManager[] tm = &#123; <span class=\"keyword\">new</span> MyX509TrustManager() &#125;;</div><div class=\"line\">KeyManager[] km = MyKeyManager.getKeyManagers();</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(<span class=\"string\">\"SSL\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">sslContext.init(km, tm, <span class=\"keyword\">new</span> java.security.SecureRandom());</div><div class=\"line\"><span class=\"comment\">// 从上述SSLContext对象中得到SSLSocketFactory对象</span></div><div class=\"line\">SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建URL对象</span></div><div class=\"line\">URL myURL = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\"><span class=\"comment\">// 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></div><div class=\"line\">HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();</div><div class=\"line\">httpsConn.setSSLSocketFactory(ssf);</div></pre></td></tr></table></figure>\n<p>然后使用HttpsURLConnection就可以使用了。但是此时服务器端还需要配置，因为客户端仅仅是将自己的证书发过去了，服务器应该如何信任它呢？</p>\n<p>打开springboot的配置文件application.properties添加以下配置:</p>\n<p>#Whether client authentication is wanted (“want”) or needed (“need”). Requires a trust store.</p>\n<p>server.ssl.client-auth=need</p>\n<p>server.ssl.trust-store=serverTrust.jks </p>\n<p>server.ssl.trust-store-password=123456</p>\n<p>其中，serverTrust.jks就是刚刚生成的服务器端信任库。</p>\n<p>以上步骤全部做完，服务器和客户端就可以愉快的使用Https进行双向认证通信了。</p>\n<h2 id=\"关于证书的一些格式\"><a href=\"#关于证书的一些格式\" class=\"headerlink\" title=\"关于证书的一些格式\"></a>关于证书的一些格式</h2><p>在使用keytool和openssl的时候，会发现有好多种格式让人头晕眼花。不妨参考这篇文章：<a href=\"http://www.cnblogs.com/guogangj/p/4118605.html\" target=\"_blank\" rel=\"external\">那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)</a></p>\n<p>我现在也不是理解的十分清楚，故不再赘述。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>感觉这篇博客没有把自己想要总结的内容全部记录下来，但是现在也不想再写了。服务器实际测试的时候是使用curl这样一个命令行浏览器进行的，使用curl作为客户端进行双向认证的时候也遇到了不少问题，总结了一份配置的<a href=\"https://github.com/Hikyu/SSL-Configuration/blob/master/ssl%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE.md\" target=\"_blank\" rel=\"external\">readme</a>，放在github上面，以作记录。readme中的配置方法可能还有一些瑕疵，有些格式转换可能会有冗余，但是整个配置是没有问题的，经过了自己的验证。证书这一块内容感觉还不是理解的特别透彻，尤其是ssl协议的交互和证书格式的一些问题，留作以后学习吧！真的不想看了…</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\" target=\"_blank\" rel=\"external\">数字证书原理</a>:这篇一定要看，总结的很好！</p>\n<p><a href=\"http://www.live-in.org/archives/1302.html\" target=\"_blank\" rel=\"external\">浏览器和SSL证书通讯过程</a></p>\n<p><a href=\"http://www.cnblogs.com/devinzhang/archive/2012/02/28/2371631.html\" target=\"_blank\" rel=\"external\">Java安全通信：HTTPS与SSL</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-socketkeytool/\" target=\"_blank\" rel=\"external\">Java 安全套接字编程以及 keytool 使用最佳实践</a></p>\n<p><a href=\"http://blog.csdn.net/liuchunming033/article/details/48470575\" target=\"_blank\" rel=\"external\">openssl生成SSL证书的流程</a></p>\n<p><a href=\"https://freessl.wosign.com/911.html\" target=\"_blank\" rel=\"external\">如何添加自签名SSL证书 自签名SSL证书存风险</a></p>\n<p><a href=\"http://www.360doc.com/content/11/1226/02/3700464_174996042.shtml\" target=\"_blank\" rel=\"external\">keystore提取私钥和证书(重要×××)</a></p>\n","excerpt":"<blockquote>\n<p>这次维护的web服务器要求使用Https双向认证，了解了一下如何在客户端和服务器之间进行ssl的配置，在此记录。另外，这篇日志主要记录如何使用，并不深入底层原理。</p>\n</blockquote>\n<h2 id=\"简单认识ssl和证书\"><a href=\"#简单认识ssl和证书\" class=\"headerlink\" title=\"简单认识ssl和证书\"></a>简单认识ssl和证书</h2><p>在理解这部分内容之前，建议先看看前面对的一篇总结：<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a></p>\n<p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</p>\n<p>SSL协议提供的服务主要有：</p>\n<p>1、认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>\n<p>2、加密数据以防止数据中途被窃取；</p>\n<p>3、维护数据的完整性，确保数据在传输过程中不被改变。</p>\n<p>其实，ssl就是一种协议。我们知道Http协议是明文传输的，安全性不高。Https就是在Http基础之上加一层ssl协议，来达到加密通信的目的。具体的ssl握手过程，可以参考<a href=\"http://baike.baidu.com/view/14121.htm#6\">百度百科</a></p>\n<p>附上一张图方便理解：</p>\n<img src=\"/2016/09/25/ssl总结/sslprocess.jpg\" alt=\"sslprocess\" title=\"sslprocess\">\n<p>图片来自网络</p>","more":"<p>可以看到ssl握手过程中服务器向客户端发送了自己的证书。这个证书是加密过程的重要内容。在前面的<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a>这篇博客中，在关于数字证书的一节，我们知道了数字证书可以证明服务器的身份，服务器证书中包含了服务器的公钥，用于之后的通信。</p>\n<p>那么，简单了解下证书的工作原理。</p>\n<p>首先看一下证书中有哪些内容：</p>\n<img src=\"/2016/09/25/ssl总结/zhifubao.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<img src=\"/2016/09/25/ssl总结/zhufubao1.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<img src=\"/2016/09/25/ssl总结/zhufubao2.png\" alt=\"支付宝证书\" title=\"支付宝证书\">\n<p>上面是我从谷chorme浏览器中截取的支付宝所使用证书的信息截图。</p>\n<p>可以看到，里面有颁发者和使用者。颁发者就是颁发此证书的CA(证书颁发机构),使用者就是与我们通信的服务器，也就是该证书的持有者。证书中还包含了我们上面提到的公钥。</p>\n<p>我们知道，证书能够证明服务器的身份，那么他是如何证明的呢？我们以浏览器为例：</p>\n<p>首先，浏览器(客户端)接收到服务器发来的证书A之后，会去验证这个证书A是否被篡改或者是伪造的。浏览器首先会去操作系统中内置根证书库中搜索A的颁发者的证书。关于这一点要解释一下，数字证书的颁发机构也有自己的证书，这个证书就是根证书，这个根证书在我的系统刚安装好时，就被微软等公司默认安装在操作系统当中了。</p>\n<p>如果在操作系统中找到了服务器证书中的颁发者的证书Root，那么继续下一步，否则，就知道这个服务器证书的颁发者是个不受信任的CA发布的，此时，浏览器会给出警告。若我们选择相信这个CA并继续，则继续下一步。</p>\n<p>接下来，浏览器从Root中得到Root的公钥，然后用该公钥对A中的指纹算法和指纹进行解密。注意，为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。</p>\n<p>那么什么是指纹算法和指纹呢？这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。</p>\n<p>此时就可以判断该证书是否是仿冒或者经过伪造篡改的。如没有，则证明这个服务器是可信任的。接下来就可以使用该服务器提供的公钥来进行通信了。</p>\n<p>通过上面的分析我们知道了，ssl协议中，首先通过证书来证明服务器的身份，然后取出证书中的公钥，接下来就可以按照<a href=\"http://yukai.space/2016/08/22/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/\">关于加密的一点总结</a>这篇博客中说到的通信方式通信了。这大概上就是ssl的原理，当然实际中ssl的细节还是要复杂很多。</p>\n<p>了解了ssl的基本原理，对我们实现服务器的https通信有很大的帮助。</p>\n<h2 id=\"Https-单向认证\"><a href=\"#Https-单向认证\" class=\"headerlink\" title=\"Https 单向认证\"></a>Https 单向认证</h2><p>单向认证就是服务器必须向客户端发送自己的证书来证明自己的身份，然后进行加密通信。现在服务器的基础框架是springboot，演示如何配置服务器和客户端：</p>\n<p>服务器：</p>\n<p>打开springboot的配置文件application.properties:</p>\n<p>server.ssl.key-store=server.keystore</p>\n<p>server.ssl.key-store-password=123456</p>\n<p>server.ssl.keyStoreType=JKS</p>\n<p>server.ssl.keyAlias:server</p>\n<p>先解释一下上面几个配置：</p>\n<p>.keystore: keystore文件中存储了密钥和证书。密钥包括私钥和公钥，而证书中只包含公钥。这个证书就是我们上面所说的证书。注意：密钥和证书是一一对应的。</p>\n<p>password: 生成keystore文件时所填的密码。</p>\n<p>keyStoreType: keystore类型。</p>\n<p>keyAlias: 生成密钥的别名。</p>\n<p>keysotre文件是怎么生成的呢？使用jdk自带的工具：keytool。生成keystore文件的命令如下：</p>\n<p><code>keytool -genkey -alias server -keyalg RSA -validity 365 -keystore server.keystore</code></p>\n<p>其中：-alias 指定生成密钥的别名，-keystore 指定生成的keystore文件的位置和名称。其他的参数的含义可以通过keytool -help来查找。</p>\n<p>一个keystore文件中可以存储多个证书和证书对应的密钥，这些证书和其对应的密钥通过唯一的别名alias来指定，也就是说，通过alias可以导出证书。但是要注意，无法通过keytool导出私钥。</p>\n<p>看一下如何从keystore文件中导出证书：</p>\n<p><code>keytool -export -alias server -keystore server.keystore -file serverCA.crt</code></p>\n<p>-alias指定了要导出的证书文件，-file 指定了要导出的证书文件的位置和名称。</p>\n<p>了解了上面的几个配置，再结合之前对ssl原理的总结，不难知道：</p>\n<p>我们指定的别名(server.ssl.keyAlias:server)之后,服务器通过该别名从keystore文件中获得对应的证书，并将其发送给客户端，同时使用keystore中alias对应的私钥(keytool虽然导不出私钥，但可以通过代码等方式获得)可以对与客户端通信的内容进行加密和解密。这便是keystore文件的作用：存储证书和私钥。</p>\n<p>服务器端的配置完成了。现在有一个问题，虽然服务器可以发送证书到客户端了，但是客户端并不会信任我们这个证书。如果这个时候通过浏览器以https的方式访问服务器，浏览器会提醒你，此连接不受信任。那是因为虽然服务器将证书发送到了浏览器(客户端)，但是浏览器并不认为这个证书能够证明服务器的身份。那为什么https访问支付宝等网站没有报这个警告呢？想想上面的内容，浏览器或操作系统内置了颁发给支付宝证书的机构的根证书，通过这个根证书的公钥对支付宝发来的证书进行解密可以证明这个证书确实是由支付宝发过来的，从而证明了服务器的身份。</p>\n<p>虽然浏览器并不能验证我们的证书，我们可以手动的把证书添加到浏览器的信任列表中。这个证书就是我们上面通过keytool导出的证书，将这个证书手动添加到浏览器信任列表里面，再次访问服务器就不会有警告啦。(具体的添加方式不再赘述)(从这点上也可以看出自签名证书的不安全性，有可能被假冒和伪造)</p>\n<p>so,通过上面的方式我们已经将ssl单向验证配置好了。那么，如果客户端是自己用java写的呢？下面举一个例子，使用HttpsURLConnection实现：</p>\n<p>首先生成客户端的信任证书库，用来存放客户端所信任的证书：</p>\n<p><code>keytool -keystore truststore.jks -alias client -import -trustcacerts -file serverCA.crt</code></p>\n<p>-file 指定要信任的证书，此例中应该是我们上面导出的证书serverCA.crt</p>\n<p>-keystore 指定要生成的信任库路径和名称。</p>\n<p>然后生成我们自己的信任证书管理器：</p>\n<p>参考了网上的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyX509TrustManager</span> <span class=\"keyword\">implements</span> <span class=\"title\">X509TrustManager</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">/*</div><div class=\"line\">\t * The default X509TrustManager returned by SunX509. We'll delegate</div><div class=\"line\">\t * decisions to it, and fall back to the logic in this class if the default</div><div class=\"line\">\t * X509TrustManager doesn't trust it.</div><div class=\"line\">\t */</span></div><div class=\"line\">\tX509TrustManager sunJSSEX509TrustManager;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyX509TrustManager</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// create a \"default\" JSSE X509TrustManager.</span></div><div class=\"line\">\t\tKeyStore ks = KeyStore.getInstance(<span class=\"string\">\"JKS\"</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//注意 src/clientTrustCA.jks就是上面生成的信任证书库</span></div><div class=\"line\">\t\tks.load(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"src/clientTrustCA.jks\"</span>), <span class=\"string\">\"123456\"</span>.toCharArray());</div><div class=\"line\">\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(<span class=\"string\">\"SunX509\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">\t\ttmf.init(ks);</div><div class=\"line\">\t\tTrustManager tms[] = tmf.getTrustManagers();</div><div class=\"line\">\t\t<span class=\"comment\">/*</div><div class=\"line\">\t\t * Iterate over the returned trustmanagers, look for an instance of</div><div class=\"line\">\t\t * X509TrustManager. If found, use that as our \"default\" trust manager.</div><div class=\"line\">\t\t */</span></div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tms.length; i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tms[i] <span class=\"keyword\">instanceof</span> X509TrustManager) &#123;</div><div class=\"line\">\t\t\t\tsunJSSEX509TrustManager = (X509TrustManager) tms[i];</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">/*</div><div class=\"line\">\t\t * Find some other way to initialize, or else we have to fail the</div><div class=\"line\">\t\t * constructor.</div><div class=\"line\">\t\t */</span></div><div class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Couldn't initialize\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</div><div class=\"line\">\t * Delegate to the default trust manager.</div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkClientTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsunJSSEX509TrustManager.checkClientTrusted(chain, authType);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CertificateException excep) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// do any special handling here, or rethrow exception.</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</div><div class=\"line\">\t * Delegate to the default trust manager.</div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkServerTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsunJSSEX509TrustManager.checkServerTrusted(chain, authType);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CertificateException excep) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">/*</div><div class=\"line\">\t\t\t * Possibly pop up a dialog box asking whether to trust the cert</div><div class=\"line\">\t\t\t * chain.</div><div class=\"line\">\t\t\t */</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</div><div class=\"line\">\t * Merely pass this through.</div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> X509Certificate[] getAcceptedIssuers() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> sunJSSEX509TrustManager.getAcceptedIssuers();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接着使用这个管理器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManager[] tm = &#123; <span class=\"keyword\">new</span> MyX509TrustManager() &#125;;</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(<span class=\"string\">\"SSL\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">sslContext.init(<span class=\"keyword\">null</span>, tm, <span class=\"keyword\">new</span> java.security.SecureRandom());</div><div class=\"line\"><span class=\"comment\">// 从上述SSLContext对象中得到SSLSocketFactory对象</span></div><div class=\"line\">SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建URL对象</span></div><div class=\"line\">URL myURL = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\"><span class=\"comment\">// 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></div><div class=\"line\">HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();</div><div class=\"line\">httpsConn.setSSLSocketFactory(ssf);</div></pre></td></tr></table></figure>\n<p>接下来就可以使用这个HttpsURLConnection来访问服务器啦。</p>\n<h2 id=\"Https双向认证\"><a href=\"#Https双向认证\" class=\"headerlink\" title=\"Https双向认证\"></a>Https双向认证</h2><p>所谓的Https双向认证就是不仅仅客户端要验证浏览器的身份，浏览器也要向服务器证明自己的身份，也就是第一幅图片中的5。</p>\n<p>理解了单向认证，双向认证实现起来也就不难了。</p>\n<p>首先像我们之前一样使用keytool生成keystore文件client.keystore，这个文件是为客户端使用准备的。</p>\n<p>然后通过client.keystore导出证书client.crt。</p>\n<p>接着生成信任库文件serverTrust.jks,将client.crt导入其中。</p>\n<p>在单向认证中我们给出了客户端单向认证时的java代码，用来下面给出双向认证的代码：</p>\n<p>生成读取keystore的类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyKeyManager</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 相关的 jks 文件及其密码定义</span></div><div class=\"line\">\t <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CERT_STORE=<span class=\"string\">\"src/client.keystore\"</span>;</div><div class=\"line\">\t <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CERT_STORE_PASSWORD=<span class=\"string\">\"123456\"</span>;</div><div class=\"line\">\t </div><div class=\"line\">\t <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> KeyManager[] getKeyManagers() <span class=\"keyword\">throws</span> Exception&#123;</div><div class=\"line\">\t\t <span class=\"comment\">// 载入 jks 文件</span></div><div class=\"line\">\t\t FileInputStream f_certStore=<span class=\"keyword\">new</span> FileInputStream(CERT_STORE); </div><div class=\"line\">\t\t KeyStore ks=KeyStore.getInstance(<span class=\"string\">\"jks\"</span>); </div><div class=\"line\">\t\t ks.load(f_certStore, CERT_STORE_PASSWORD.toCharArray()); </div><div class=\"line\">\t\t f_certStore.close(); </div><div class=\"line\"></div><div class=\"line\">\t\t <span class=\"comment\">// 创建并初始化证书库工厂</span></div><div class=\"line\">\t\t String alg=KeyManagerFactory.getDefaultAlgorithm(); </div><div class=\"line\">\t\t KeyManagerFactory kmFact=KeyManagerFactory.getInstance(alg); </div><div class=\"line\">\t\t kmFact.init(ks, CERT_STORE_PASSWORD.toCharArray()); </div><div class=\"line\"></div><div class=\"line\">\t\t KeyManager[] kms=kmFact.getKeyManagers(); </div><div class=\"line\">\t\t <span class=\"keyword\">return</span> kms;</div><div class=\"line\">\t &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面单向认证中那样使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManager[] tm = &#123; <span class=\"keyword\">new</span> MyX509TrustManager() &#125;;</div><div class=\"line\">KeyManager[] km = MyKeyManager.getKeyManagers();</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(<span class=\"string\">\"SSL\"</span>, <span class=\"string\">\"SunJSSE\"</span>);</div><div class=\"line\">sslContext.init(km, tm, <span class=\"keyword\">new</span> java.security.SecureRandom());</div><div class=\"line\"><span class=\"comment\">// 从上述SSLContext对象中得到SSLSocketFactory对象</span></div><div class=\"line\">SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建URL对象</span></div><div class=\"line\">URL myURL = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\"><span class=\"comment\">// 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></div><div class=\"line\">HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();</div><div class=\"line\">httpsConn.setSSLSocketFactory(ssf);</div></pre></td></tr></table></figure>\n<p>然后使用HttpsURLConnection就可以使用了。但是此时服务器端还需要配置，因为客户端仅仅是将自己的证书发过去了，服务器应该如何信任它呢？</p>\n<p>打开springboot的配置文件application.properties添加以下配置:</p>\n<p>#Whether client authentication is wanted (“want”) or needed (“need”). Requires a trust store.</p>\n<p>server.ssl.client-auth=need</p>\n<p>server.ssl.trust-store=serverTrust.jks </p>\n<p>server.ssl.trust-store-password=123456</p>\n<p>其中，serverTrust.jks就是刚刚生成的服务器端信任库。</p>\n<p>以上步骤全部做完，服务器和客户端就可以愉快的使用Https进行双向认证通信了。</p>\n<h2 id=\"关于证书的一些格式\"><a href=\"#关于证书的一些格式\" class=\"headerlink\" title=\"关于证书的一些格式\"></a>关于证书的一些格式</h2><p>在使用keytool和openssl的时候，会发现有好多种格式让人头晕眼花。不妨参考这篇文章：<a href=\"http://www.cnblogs.com/guogangj/p/4118605.html\">那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)</a></p>\n<p>我现在也不是理解的十分清楚，故不再赘述。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>感觉这篇博客没有把自己想要总结的内容全部记录下来，但是现在也不想再写了。服务器实际测试的时候是使用curl这样一个命令行浏览器进行的，使用curl作为客户端进行双向认证的时候也遇到了不少问题，总结了一份配置的<a href=\"https://github.com/Hikyu/SSL-Configuration/blob/master/ssl%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE.md\">readme</a>，放在github上面，以作记录。readme中的配置方法可能还有一些瑕疵，有些格式转换可能会有冗余，但是整个配置是没有问题的，经过了自己的验证。证书这一块内容感觉还不是理解的特别透彻，尤其是ssl协议的交互和证书格式的一些问题，留作以后学习吧！真的不想看了…</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\">数字证书原理</a>:这篇一定要看，总结的很好！</p>\n<p><a href=\"http://www.live-in.org/archives/1302.html\">浏览器和SSL证书通讯过程</a></p>\n<p><a href=\"http://www.cnblogs.com/devinzhang/archive/2012/02/28/2371631.html\">Java安全通信：HTTPS与SSL</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-socketkeytool/\">Java 安全套接字编程以及 keytool 使用最佳实践</a></p>\n<p><a href=\"http://blog.csdn.net/liuchunming033/article/details/48470575\">openssl生成SSL证书的流程</a></p>\n<p><a href=\"https://freessl.wosign.com/911.html\">如何添加自签名SSL证书 自签名SSL证书存风险</a></p>\n<p><a href=\"http://www.360doc.com/content/11/1226/02/3700464_174996042.shtml\">keystore提取私钥和证书(重要×××)</a></p>"},{"layout":"post","title":"win7与centos7双系统安装","date":"2017-02-18T13:10:00.000Z","_content":"> 之前会有同学让帮忙重装操作系统，正好计划重新装一下自己电脑的系统，折腾了win7与linux双系统，在此记录。以后就可以给他们看这篇笔记自己去装啦~\n\n> ps: 由于是双系统的安装操作，而不是虚拟机，所以并未截图，是纯文字说明。如果不清楚，可以参考最下面的参考链接\n\n## 安装win7\n\n### 下载win7镜像文件：\n\n[系统之家win7下载](http://www.xitongzhijia.net/win7/)\n\n选择一款进行下载，我选择了`雨林木风 GHOST WIN7 SP1 X64 装机旗舰版 V2017.02（64位）`\n\n### 制作U盘启动工具\n\n下载启动盘制作工具：\n\n[老毛桃u盘启动盘制作工具](http://www.laomaotao.org/lmtxz/933.html)\n\n下载装机版，进行安装\n\n启动盘制作工具安装完成，且镜像下载完毕之后，启动老毛桃，选择U盘启动->默认模式\n\n插入一个可用的U盘，在选择设备这项中，选择插入的U盘设备，注意不要选错\n\n其他选项默认，点击 开始制作 进行启动盘的制作。\n\n启动盘制作完毕之后，将下载好的iso文件拷入U盘\n<!-- more -->\n### 安装win7\n\n插入制作好的启动盘，重启电脑\n\n开机画面出现时，按下F12，boot options(我的电脑是DELL的，其他品牌电脑自行查找)\n\n选择USB启动\n\n老毛桃启动盘正常启动，此时选择第二项，win8pe,点击进入win8pe\n\n1. 首先进行分区，选择分区工具，可以自由设置分区数目和分区大小(我分了3个区，一个用来装win7(C)，一个用来做Windows的资料盘(D)，另外一个用来安装Linux(E))\n\n双击win8pe桌面上的“diskgenius分区工具”图标，在弹出的窗口中点击“快速分区”，即可启动分区工具，具体的分区方法参考官网介绍：[老毛桃分区工具的使用](http://www.laomaotao.org/lmtjc/245.html)\n\n2. 设置好分区后，鼠标左键双击打开桌面上的“老毛桃PE装机工具”，选择“还原分区”，映像文件路径选择上一步拷入U盘的镜像，然后选择要装入的分区(C盘)，点击确认开始自动装机。\n\n3. 系统自动重启几次之后，就安装好了，可以卸载一些不必要的系统自带软件，此时的操作系统已经是激活的版本了（我下载的镜像是），各种需要的驱动也都安装完毕，简单省事。\n\n## 安装centos7\n\n### 查看磁盘分区情况\n\n右键计算机->管理，打开计算机管理程序。选择磁盘管理，查看分区情况。\n\n选择之前分好的E盘，右键“删除卷”，使之状态变为“可用空间”，以便centos安装程序识别。\n\n### 制作U盘启动工具\n\n下载centos7镜像文件（DVD版本即可）\n\n[CentOS-7-x86_64-DVD-1611.iso](http://101.96.8.151/mirror.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1611.iso)\n\n下载烧录U盘工具\n\n[ImageUsb](http://www.osforensics.com/tools/write-usb-images.html)\n\n插入一个可用的U盘\n\n启动 imageusb.exe，\n\nstep1 选择要写入的U盘;\n\nstep2 选择 write image to USB driver;\n\nstep3 选择下载好的centos7镜像文件\n\nstep4 点击 write ，开始烧录启动盘\n\n启动盘烧录完毕后，可以开始安装centos\n\n### 安装centos7\n\n插入制作好的启动盘，重启电脑\n\n开机画面出现时，按下F12 (我的电脑是DELL的，其他品牌电脑自行查找)\n\n选择USB启动\n\n选择第一项，Install CentOs 7 ，回车，开始安装CentOS 7\n\n之后就进入了简单的可视化安装界面，有几点需要注意：\n\n1.分区选择\n\n如果是像上面一样分了3个区，两个被Windows使用，还剩一个分区未被使用，\n那么可以选择自动选择分区，centos安装程序会自动选择好这块未被使用的分区（将“/”目录挂载到这个分区上面）\n\n也可以自定义分区，建议分四个区：/   /boot  /home swap（如果有这么些分区的话）\n\n2.在之后的安装信息摘要中，注意“软件”-“软件选择”，默认是最小安装，即不安装桌面环境，若选择此项，则只有命令行界面，应该选择带有UI界面的选项。\n\n之后就是很简单的安装了\n\n### 配置引导程序\n\n再次启动电脑之后，会发现自动进入Linux，没有win7系统的选项，此时需要配置引导程序\n\n首先添加ntfs支持\n\n```\nwget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo\n\nyum update;yum install ntfs-3g\n```\n\n安装完毕后打开终端，运行`grub2-mkconfig -o /boot/grub2/grub.cfg`\n\n就会重新生成引导项，重启电脑即可\n\n## 参考\n\n[老毛桃u盘安装原版win7系统详细教程](http://www.laomaotao.org/jiaocheng/upzybwin7.html)\n\n[老毛桃分区工具的使用](http://www.laomaotao.org/lmtjc/245.html)\n\n[CentOS 7.0系统安装配置图解教程](http://www.osyunwei.com/archives/7829.html)\n","source":"_posts/win7与centos7双系统安装.md","raw":"layout: post\ntitle: win7与centos7双系统安装\ndate: 2017-02-18 21:10:00\ncategories: 技术\ntags: linux\n---\n> 之前会有同学让帮忙重装操作系统，正好计划重新装一下自己电脑的系统，折腾了win7与linux双系统，在此记录。以后就可以给他们看这篇笔记自己去装啦~\n\n> ps: 由于是双系统的安装操作，而不是虚拟机，所以并未截图，是纯文字说明。如果不清楚，可以参考最下面的参考链接\n\n## 安装win7\n\n### 下载win7镜像文件：\n\n[系统之家win7下载](http://www.xitongzhijia.net/win7/)\n\n选择一款进行下载，我选择了`雨林木风 GHOST WIN7 SP1 X64 装机旗舰版 V2017.02（64位）`\n\n### 制作U盘启动工具\n\n下载启动盘制作工具：\n\n[老毛桃u盘启动盘制作工具](http://www.laomaotao.org/lmtxz/933.html)\n\n下载装机版，进行安装\n\n启动盘制作工具安装完成，且镜像下载完毕之后，启动老毛桃，选择U盘启动->默认模式\n\n插入一个可用的U盘，在选择设备这项中，选择插入的U盘设备，注意不要选错\n\n其他选项默认，点击 开始制作 进行启动盘的制作。\n\n启动盘制作完毕之后，将下载好的iso文件拷入U盘\n<!-- more -->\n### 安装win7\n\n插入制作好的启动盘，重启电脑\n\n开机画面出现时，按下F12，boot options(我的电脑是DELL的，其他品牌电脑自行查找)\n\n选择USB启动\n\n老毛桃启动盘正常启动，此时选择第二项，win8pe,点击进入win8pe\n\n1. 首先进行分区，选择分区工具，可以自由设置分区数目和分区大小(我分了3个区，一个用来装win7(C)，一个用来做Windows的资料盘(D)，另外一个用来安装Linux(E))\n\n双击win8pe桌面上的“diskgenius分区工具”图标，在弹出的窗口中点击“快速分区”，即可启动分区工具，具体的分区方法参考官网介绍：[老毛桃分区工具的使用](http://www.laomaotao.org/lmtjc/245.html)\n\n2. 设置好分区后，鼠标左键双击打开桌面上的“老毛桃PE装机工具”，选择“还原分区”，映像文件路径选择上一步拷入U盘的镜像，然后选择要装入的分区(C盘)，点击确认开始自动装机。\n\n3. 系统自动重启几次之后，就安装好了，可以卸载一些不必要的系统自带软件，此时的操作系统已经是激活的版本了（我下载的镜像是），各种需要的驱动也都安装完毕，简单省事。\n\n## 安装centos7\n\n### 查看磁盘分区情况\n\n右键计算机->管理，打开计算机管理程序。选择磁盘管理，查看分区情况。\n\n选择之前分好的E盘，右键“删除卷”，使之状态变为“可用空间”，以便centos安装程序识别。\n\n### 制作U盘启动工具\n\n下载centos7镜像文件（DVD版本即可）\n\n[CentOS-7-x86_64-DVD-1611.iso](http://101.96.8.151/mirror.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1611.iso)\n\n下载烧录U盘工具\n\n[ImageUsb](http://www.osforensics.com/tools/write-usb-images.html)\n\n插入一个可用的U盘\n\n启动 imageusb.exe，\n\nstep1 选择要写入的U盘;\n\nstep2 选择 write image to USB driver;\n\nstep3 选择下载好的centos7镜像文件\n\nstep4 点击 write ，开始烧录启动盘\n\n启动盘烧录完毕后，可以开始安装centos\n\n### 安装centos7\n\n插入制作好的启动盘，重启电脑\n\n开机画面出现时，按下F12 (我的电脑是DELL的，其他品牌电脑自行查找)\n\n选择USB启动\n\n选择第一项，Install CentOs 7 ，回车，开始安装CentOS 7\n\n之后就进入了简单的可视化安装界面，有几点需要注意：\n\n1.分区选择\n\n如果是像上面一样分了3个区，两个被Windows使用，还剩一个分区未被使用，\n那么可以选择自动选择分区，centos安装程序会自动选择好这块未被使用的分区（将“/”目录挂载到这个分区上面）\n\n也可以自定义分区，建议分四个区：/   /boot  /home swap（如果有这么些分区的话）\n\n2.在之后的安装信息摘要中，注意“软件”-“软件选择”，默认是最小安装，即不安装桌面环境，若选择此项，则只有命令行界面，应该选择带有UI界面的选项。\n\n之后就是很简单的安装了\n\n### 配置引导程序\n\n再次启动电脑之后，会发现自动进入Linux，没有win7系统的选项，此时需要配置引导程序\n\n首先添加ntfs支持\n\n```\nwget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo\n\nyum update;yum install ntfs-3g\n```\n\n安装完毕后打开终端，运行`grub2-mkconfig -o /boot/grub2/grub.cfg`\n\n就会重新生成引导项，重启电脑即可\n\n## 参考\n\n[老毛桃u盘安装原版win7系统详细教程](http://www.laomaotao.org/jiaocheng/upzybwin7.html)\n\n[老毛桃分区工具的使用](http://www.laomaotao.org/lmtjc/245.html)\n\n[CentOS 7.0系统安装配置图解教程](http://www.osyunwei.com/archives/7829.html)\n","slug":"win7与centos7双系统安装","published":1,"updated":"2017-04-11T13:08:38.850Z","comments":1,"photos":[],"link":"","_id":"cj4vch4g7003yx3gc457asqlt","content":"<blockquote>\n<p>之前会有同学让帮忙重装操作系统，正好计划重新装一下自己电脑的系统，折腾了win7与linux双系统，在此记录。以后就可以给他们看这篇笔记自己去装啦~</p>\n<p>ps: 由于是双系统的安装操作，而不是虚拟机，所以并未截图，是纯文字说明。如果不清楚，可以参考最下面的参考链接</p>\n</blockquote>\n<h2 id=\"安装win7\"><a href=\"#安装win7\" class=\"headerlink\" title=\"安装win7\"></a>安装win7</h2><h3 id=\"下载win7镜像文件：\"><a href=\"#下载win7镜像文件：\" class=\"headerlink\" title=\"下载win7镜像文件：\"></a>下载win7镜像文件：</h3><p><a href=\"http://www.xitongzhijia.net/win7/\" target=\"_blank\" rel=\"external\">系统之家win7下载</a></p>\n<p>选择一款进行下载，我选择了<code>雨林木风 GHOST WIN7 SP1 X64 装机旗舰版 V2017.02（64位）</code></p>\n<h3 id=\"制作U盘启动工具\"><a href=\"#制作U盘启动工具\" class=\"headerlink\" title=\"制作U盘启动工具\"></a>制作U盘启动工具</h3><p>下载启动盘制作工具：</p>\n<p><a href=\"http://www.laomaotao.org/lmtxz/933.html\" target=\"_blank\" rel=\"external\">老毛桃u盘启动盘制作工具</a></p>\n<p>下载装机版，进行安装</p>\n<p>启动盘制作工具安装完成，且镜像下载完毕之后，启动老毛桃，选择U盘启动-&gt;默认模式</p>\n<p>插入一个可用的U盘，在选择设备这项中，选择插入的U盘设备，注意不要选错</p>\n<p>其他选项默认，点击 开始制作 进行启动盘的制作。</p>\n<p>启动盘制作完毕之后，将下载好的iso文件拷入U盘<br><a id=\"more\"></a></p>\n<h3 id=\"安装win7-1\"><a href=\"#安装win7-1\" class=\"headerlink\" title=\"安装win7\"></a>安装win7</h3><p>插入制作好的启动盘，重启电脑</p>\n<p>开机画面出现时，按下F12，boot options(我的电脑是DELL的，其他品牌电脑自行查找)</p>\n<p>选择USB启动</p>\n<p>老毛桃启动盘正常启动，此时选择第二项，win8pe,点击进入win8pe</p>\n<ol>\n<li>首先进行分区，选择分区工具，可以自由设置分区数目和分区大小(我分了3个区，一个用来装win7(C)，一个用来做Windows的资料盘(D)，另外一个用来安装Linux(E))</li>\n</ol>\n<p>双击win8pe桌面上的“diskgenius分区工具”图标，在弹出的窗口中点击“快速分区”，即可启动分区工具，具体的分区方法参考官网介绍：<a href=\"http://www.laomaotao.org/lmtjc/245.html\" target=\"_blank\" rel=\"external\">老毛桃分区工具的使用</a></p>\n<ol>\n<li><p>设置好分区后，鼠标左键双击打开桌面上的“老毛桃PE装机工具”，选择“还原分区”，映像文件路径选择上一步拷入U盘的镜像，然后选择要装入的分区(C盘)，点击确认开始自动装机。</p>\n</li>\n<li><p>系统自动重启几次之后，就安装好了，可以卸载一些不必要的系统自带软件，此时的操作系统已经是激活的版本了（我下载的镜像是），各种需要的驱动也都安装完毕，简单省事。</p>\n</li>\n</ol>\n<h2 id=\"安装centos7\"><a href=\"#安装centos7\" class=\"headerlink\" title=\"安装centos7\"></a>安装centos7</h2><h3 id=\"查看磁盘分区情况\"><a href=\"#查看磁盘分区情况\" class=\"headerlink\" title=\"查看磁盘分区情况\"></a>查看磁盘分区情况</h3><p>右键计算机-&gt;管理，打开计算机管理程序。选择磁盘管理，查看分区情况。</p>\n<p>选择之前分好的E盘，右键“删除卷”，使之状态变为“可用空间”，以便centos安装程序识别。</p>\n<h3 id=\"制作U盘启动工具-1\"><a href=\"#制作U盘启动工具-1\" class=\"headerlink\" title=\"制作U盘启动工具\"></a>制作U盘启动工具</h3><p>下载centos7镜像文件（DVD版本即可）</p>\n<p><a href=\"http://101.96.8.151/mirror.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1611.iso\" target=\"_blank\" rel=\"external\">CentOS-7-x86_64-DVD-1611.iso</a></p>\n<p>下载烧录U盘工具</p>\n<p><a href=\"http://www.osforensics.com/tools/write-usb-images.html\" target=\"_blank\" rel=\"external\">ImageUsb</a></p>\n<p>插入一个可用的U盘</p>\n<p>启动 imageusb.exe，</p>\n<p>step1 选择要写入的U盘;</p>\n<p>step2 选择 write image to USB driver;</p>\n<p>step3 选择下载好的centos7镜像文件</p>\n<p>step4 点击 write ，开始烧录启动盘</p>\n<p>启动盘烧录完毕后，可以开始安装centos</p>\n<h3 id=\"安装centos7-1\"><a href=\"#安装centos7-1\" class=\"headerlink\" title=\"安装centos7\"></a>安装centos7</h3><p>插入制作好的启动盘，重启电脑</p>\n<p>开机画面出现时，按下F12 (我的电脑是DELL的，其他品牌电脑自行查找)</p>\n<p>选择USB启动</p>\n<p>选择第一项，Install CentOs 7 ，回车，开始安装CentOS 7</p>\n<p>之后就进入了简单的可视化安装界面，有几点需要注意：</p>\n<p>1.分区选择</p>\n<p>如果是像上面一样分了3个区，两个被Windows使用，还剩一个分区未被使用，<br>那么可以选择自动选择分区，centos安装程序会自动选择好这块未被使用的分区（将“/”目录挂载到这个分区上面）</p>\n<p>也可以自定义分区，建议分四个区：/   /boot  /home swap（如果有这么些分区的话）</p>\n<p>2.在之后的安装信息摘要中，注意“软件”-“软件选择”，默认是最小安装，即不安装桌面环境，若选择此项，则只有命令行界面，应该选择带有UI界面的选项。</p>\n<p>之后就是很简单的安装了</p>\n<h3 id=\"配置引导程序\"><a href=\"#配置引导程序\" class=\"headerlink\" title=\"配置引导程序\"></a>配置引导程序</h3><p>再次启动电脑之后，会发现自动进入Linux，没有win7系统的选项，此时需要配置引导程序</p>\n<p>首先添加ntfs支持</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</div><div class=\"line\"></div><div class=\"line\">yum update;yum install ntfs-3g</div></pre></td></tr></table></figure>\n<p>安装完毕后打开终端，运行<code>grub2-mkconfig -o /boot/grub2/grub.cfg</code></p>\n<p>就会重新生成引导项，重启电脑即可</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.laomaotao.org/jiaocheng/upzybwin7.html\" target=\"_blank\" rel=\"external\">老毛桃u盘安装原版win7系统详细教程</a></p>\n<p><a href=\"http://www.laomaotao.org/lmtjc/245.html\" target=\"_blank\" rel=\"external\">老毛桃分区工具的使用</a></p>\n<p><a href=\"http://www.osyunwei.com/archives/7829.html\" target=\"_blank\" rel=\"external\">CentOS 7.0系统安装配置图解教程</a></p>\n","excerpt":"<blockquote>\n<p>之前会有同学让帮忙重装操作系统，正好计划重新装一下自己电脑的系统，折腾了win7与linux双系统，在此记录。以后就可以给他们看这篇笔记自己去装啦~</p>\n<p>ps: 由于是双系统的安装操作，而不是虚拟机，所以并未截图，是纯文字说明。如果不清楚，可以参考最下面的参考链接</p>\n</blockquote>\n<h2 id=\"安装win7\"><a href=\"#安装win7\" class=\"headerlink\" title=\"安装win7\"></a>安装win7</h2><h3 id=\"下载win7镜像文件：\"><a href=\"#下载win7镜像文件：\" class=\"headerlink\" title=\"下载win7镜像文件：\"></a>下载win7镜像文件：</h3><p><a href=\"http://www.xitongzhijia.net/win7/\">系统之家win7下载</a></p>\n<p>选择一款进行下载，我选择了<code>雨林木风 GHOST WIN7 SP1 X64 装机旗舰版 V2017.02（64位）</code></p>\n<h3 id=\"制作U盘启动工具\"><a href=\"#制作U盘启动工具\" class=\"headerlink\" title=\"制作U盘启动工具\"></a>制作U盘启动工具</h3><p>下载启动盘制作工具：</p>\n<p><a href=\"http://www.laomaotao.org/lmtxz/933.html\">老毛桃u盘启动盘制作工具</a></p>\n<p>下载装机版，进行安装</p>\n<p>启动盘制作工具安装完成，且镜像下载完毕之后，启动老毛桃，选择U盘启动-&gt;默认模式</p>\n<p>插入一个可用的U盘，在选择设备这项中，选择插入的U盘设备，注意不要选错</p>\n<p>其他选项默认，点击 开始制作 进行启动盘的制作。</p>\n<p>启动盘制作完毕之后，将下载好的iso文件拷入U盘<br>","more":"</p>\n<h3 id=\"安装win7-1\"><a href=\"#安装win7-1\" class=\"headerlink\" title=\"安装win7\"></a>安装win7</h3><p>插入制作好的启动盘，重启电脑</p>\n<p>开机画面出现时，按下F12，boot options(我的电脑是DELL的，其他品牌电脑自行查找)</p>\n<p>选择USB启动</p>\n<p>老毛桃启动盘正常启动，此时选择第二项，win8pe,点击进入win8pe</p>\n<ol>\n<li>首先进行分区，选择分区工具，可以自由设置分区数目和分区大小(我分了3个区，一个用来装win7(C)，一个用来做Windows的资料盘(D)，另外一个用来安装Linux(E))</li>\n</ol>\n<p>双击win8pe桌面上的“diskgenius分区工具”图标，在弹出的窗口中点击“快速分区”，即可启动分区工具，具体的分区方法参考官网介绍：<a href=\"http://www.laomaotao.org/lmtjc/245.html\">老毛桃分区工具的使用</a></p>\n<ol>\n<li><p>设置好分区后，鼠标左键双击打开桌面上的“老毛桃PE装机工具”，选择“还原分区”，映像文件路径选择上一步拷入U盘的镜像，然后选择要装入的分区(C盘)，点击确认开始自动装机。</p>\n</li>\n<li><p>系统自动重启几次之后，就安装好了，可以卸载一些不必要的系统自带软件，此时的操作系统已经是激活的版本了（我下载的镜像是），各种需要的驱动也都安装完毕，简单省事。</p>\n</li>\n</ol>\n<h2 id=\"安装centos7\"><a href=\"#安装centos7\" class=\"headerlink\" title=\"安装centos7\"></a>安装centos7</h2><h3 id=\"查看磁盘分区情况\"><a href=\"#查看磁盘分区情况\" class=\"headerlink\" title=\"查看磁盘分区情况\"></a>查看磁盘分区情况</h3><p>右键计算机-&gt;管理，打开计算机管理程序。选择磁盘管理，查看分区情况。</p>\n<p>选择之前分好的E盘，右键“删除卷”，使之状态变为“可用空间”，以便centos安装程序识别。</p>\n<h3 id=\"制作U盘启动工具-1\"><a href=\"#制作U盘启动工具-1\" class=\"headerlink\" title=\"制作U盘启动工具\"></a>制作U盘启动工具</h3><p>下载centos7镜像文件（DVD版本即可）</p>\n<p><a href=\"http://101.96.8.151/mirror.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1611.iso\">CentOS-7-x86_64-DVD-1611.iso</a></p>\n<p>下载烧录U盘工具</p>\n<p><a href=\"http://www.osforensics.com/tools/write-usb-images.html\">ImageUsb</a></p>\n<p>插入一个可用的U盘</p>\n<p>启动 imageusb.exe，</p>\n<p>step1 选择要写入的U盘;</p>\n<p>step2 选择 write image to USB driver;</p>\n<p>step3 选择下载好的centos7镜像文件</p>\n<p>step4 点击 write ，开始烧录启动盘</p>\n<p>启动盘烧录完毕后，可以开始安装centos</p>\n<h3 id=\"安装centos7-1\"><a href=\"#安装centos7-1\" class=\"headerlink\" title=\"安装centos7\"></a>安装centos7</h3><p>插入制作好的启动盘，重启电脑</p>\n<p>开机画面出现时，按下F12 (我的电脑是DELL的，其他品牌电脑自行查找)</p>\n<p>选择USB启动</p>\n<p>选择第一项，Install CentOs 7 ，回车，开始安装CentOS 7</p>\n<p>之后就进入了简单的可视化安装界面，有几点需要注意：</p>\n<p>1.分区选择</p>\n<p>如果是像上面一样分了3个区，两个被Windows使用，还剩一个分区未被使用，<br>那么可以选择自动选择分区，centos安装程序会自动选择好这块未被使用的分区（将“/”目录挂载到这个分区上面）</p>\n<p>也可以自定义分区，建议分四个区：/   /boot  /home swap（如果有这么些分区的话）</p>\n<p>2.在之后的安装信息摘要中，注意“软件”-“软件选择”，默认是最小安装，即不安装桌面环境，若选择此项，则只有命令行界面，应该选择带有UI界面的选项。</p>\n<p>之后就是很简单的安装了</p>\n<h3 id=\"配置引导程序\"><a href=\"#配置引导程序\" class=\"headerlink\" title=\"配置引导程序\"></a>配置引导程序</h3><p>再次启动电脑之后，会发现自动进入Linux，没有win7系统的选项，此时需要配置引导程序</p>\n<p>首先添加ntfs支持</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</div><div class=\"line\"></div><div class=\"line\">yum update;yum install ntfs-3g</div></pre></td></tr></table></figure>\n<p>安装完毕后打开终端，运行<code>grub2-mkconfig -o /boot/grub2/grub.cfg</code></p>\n<p>就会重新生成引导项，重启电脑即可</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.laomaotao.org/jiaocheng/upzybwin7.html\">老毛桃u盘安装原版win7系统详细教程</a></p>\n<p><a href=\"http://www.laomaotao.org/lmtjc/245.html\">老毛桃分区工具的使用</a></p>\n<p><a href=\"http://www.osyunwei.com/archives/7829.html\">CentOS 7.0系统安装配置图解教程</a></p>"},{"layout":"post","title":"java同步锁锁什么","date":"2015-12-17T06:10:55.000Z","_content":"\n在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：\n情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;\nThreadTest中的成员变量 j 被赋值为 i \n在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;\n在synchronized块中，我改变了这个 j 的值。代码大概是这样的：\n\n```\t\t\t\t\t   \nInteger j;\nThreadTest(Integer i){\n\t\tj=i;\n}\npublic void run() {\n\t\tsynchronized(j){\n\t\t  j++;\n\t\t}\n}\n\n```\n\n<!-- more -->\n\n1. 一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。\n\n2. 另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。\n\n苦逼了。结果不对\n后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，\n即 void test(Object  i){\n\t\ti.dosomething()......\n   }\n函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。\n这样就解释了出错的 原因：\nInteger 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。\n所以 \n\n对于 1. \n\n当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望\n\n对于 2. \n\n使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步\n\t\t\t\t\t\t\t\n上面的情况也证明了，**synchronized 锁的是内存 ，而不是指向内存的引用**。\n\t\t\t\t\t\t\t\n这样的情况也说明了另外一种情况的问题，那就是**在函数中给实参分配内存,实际在函数体外是得不到这个对象的**。\n\t\t\t\t\t\t\t\n解决的办法：\n放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，\n各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。","source":"_posts/java同步锁锁什么.md","raw":"---\nlayout: post\ntitle:  \"java同步锁锁什么\"\ndate:   2015-12-17 14:10:55\ncategories: 编程\ntags: \n- java\n- 多线程\n---\n\n在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：\n情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;\nThreadTest中的成员变量 j 被赋值为 i \n在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;\n在synchronized块中，我改变了这个 j 的值。代码大概是这样的：\n\n```\t\t\t\t\t   \nInteger j;\nThreadTest(Integer i){\n\t\tj=i;\n}\npublic void run() {\n\t\tsynchronized(j){\n\t\t  j++;\n\t\t}\n}\n\n```\n\n<!-- more -->\n\n1. 一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。\n\n2. 另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。\n\n苦逼了。结果不对\n后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，\n即 void test(Object  i){\n\t\ti.dosomething()......\n   }\n函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。\n这样就解释了出错的 原因：\nInteger 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。\n所以 \n\n对于 1. \n\n当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望\n\n对于 2. \n\n使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步\n\t\t\t\t\t\t\t\n上面的情况也证明了，**synchronized 锁的是内存 ，而不是指向内存的引用**。\n\t\t\t\t\t\t\t\n这样的情况也说明了另外一种情况的问题，那就是**在函数中给实参分配内存,实际在函数体外是得不到这个对象的**。\n\t\t\t\t\t\t\t\n解决的办法：\n放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，\n各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。","slug":"java同步锁锁什么","published":1,"updated":"2017-04-11T13:08:38.842Z","comments":1,"photos":[],"link":"","_id":"cj4vch4gl0041x3gcbq7crzvb","content":"<p>在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：<br>情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;<br>ThreadTest中的成员变量 j 被赋值为 i<br>在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;<br>在synchronized块中，我改变了这个 j 的值。代码大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer j;</div><div class=\"line\">ThreadTest(Integer i)&#123;</div><div class=\"line\">\t\tj=i;</div><div class=\"line\">&#125;</div><div class=\"line\">public void run() &#123;</div><div class=\"line\">\t\tsynchronized(j)&#123;</div><div class=\"line\">\t\t  j++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ol>\n<li><p>一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。</p>\n</li>\n<li><p>另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。</p>\n</li>\n</ol>\n<p>苦逼了。结果不对<br>后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，<br>即 void test(Object  i){<br>        i.dosomething()……<br>   }<br>函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。<br>这样就解释了出错的 原因：<br>Integer 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。<br>所以 </p>\n<p>对于 1. </p>\n<p>当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望</p>\n<p>对于 2. </p>\n<p>使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步</p>\n<p>上面的情况也证明了，<strong>synchronized 锁的是内存 ，而不是指向内存的引用</strong>。</p>\n<p>这样的情况也说明了另外一种情况的问题，那就是<strong>在函数中给实参分配内存,实际在函数体外是得不到这个对象的</strong>。</p>\n<p>解决的办法：<br>放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，<br>各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。</p>\n","excerpt":"<p>在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：<br>情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;<br>ThreadTest中的成员变量 j 被赋值为 i<br>在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;<br>在synchronized块中，我改变了这个 j 的值。代码大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer j;</div><div class=\"line\">ThreadTest(Integer i)&#123;</div><div class=\"line\">\t\tj=i;</div><div class=\"line\">&#125;</div><div class=\"line\">public void run() &#123;</div><div class=\"line\">\t\tsynchronized(j)&#123;</div><div class=\"line\">\t\t  j++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<ol>\n<li><p>一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。</p>\n</li>\n<li><p>另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。</p>\n</li>\n</ol>\n<p>苦逼了。结果不对<br>后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，<br>即 void test(Object  i){<br>        i.dosomething()……<br>   }<br>函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。<br>这样就解释了出错的 原因：<br>Integer 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。<br>所以 </p>\n<p>对于 1. </p>\n<p>当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望</p>\n<p>对于 2. </p>\n<p>使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步</p>\n<p>上面的情况也证明了，<strong>synchronized 锁的是内存 ，而不是指向内存的引用</strong>。</p>\n<p>这样的情况也说明了另外一种情况的问题，那就是<strong>在函数中给实参分配内存,实际在函数体外是得不到这个对象的</strong>。</p>\n<p>解决的办法：<br>放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，<br>各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。</p>"},{"layout":"post","title":"java泛型学习","date":"2016-10-10T12:05:03.000Z","_content":"\n有一段时间没有更新博客了，过了国庆之后，好像变得更懒了~~前两天开发了一个用于记账的公众号，功能很简单，就是普通的增删查改...由于是个人开发者，无法进行公众号的认证，所以没什么高级的接口权限，只能搞的简陋一点了...下一步计划再丰富丰富，目前想到了这几个功能：配合有道或者金山词霸的Api进行中英互译（API怎么用，可不可以用目前还不清楚），配合微博的Api接口整点微博热门什么的，配合豆瓣的Api接口做一个电影或者书籍查询的功能等等....公众号的服务器代码目前还部署在自己的电脑上，用nat123做了一下公网ip的映射，接下来考虑是不是要换成云服务器更为妥当....\n\n公众号在这里：\n\n{% asset_img easybill.jpg EasyBill %}\n\n目前，公众号已经开源：[WechatSubscriptionNumber](https://github.com/Hikyu/WechatSubscriptionNumber)\n\n好了，言归正传。今天学习了java的泛型知识，不总结一下老是觉得跟没学一样...\n\n<!-- more -->\n\n## 泛型的好处\n\n使用泛型的好处我觉得有两点：1：类型安全  2：减少类型强转\n\n下面通过一个例子说明:\n\n假设有一个Test类，通用的实现是:\n\n```java\nclass Test {\n\tprivate Object o;\n\n\tpublic Test(Object o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic Object getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(Object o) {\n\t\tthis.o = o;\n\t}\n}\n```\n我们可以这样使用它：\n\n```java\npublic static void main(String[] args) {\n\tTest test = new Test(new Integer(1));\n\t//编译时不报错\n\t//运行时报  java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\n\tString o = (String) test.getObject();\n}\n```\n\n看一个使用泛型的例子：\n\n```java\nclass Test<T> {\n\tprivate T o;\n\n\tpublic Test(T o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic T getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(T o) {\n\t\tthis.o = o;\n\t}\n}\n\npublic static void main(String[] args) {\n\tTest1<Integer> test = new Test1<Integer>(new Integer(1));\n\t//编译时报错，无法通过编译\n\t//String o = test.getObject();\n\n\t//正常运行\n\tInteger o = test.getObject();\n}\n```\n从上面的对比中能够看出两点：\n\n1.使用泛型之后在编译时报错而非运行时，减少了出错的几率；\n\n2.使用泛型之后编译器不再要求强转\n\n## 定义泛型\n\n泛型的机制能够在定义类、接口、方法时把类型参数化，也就是类似于方法的形参一样，把类型当做参数使用。\n\n泛型参数部分使用`<>`包裹起来，比如`<T>`，T声明了一种类型，习惯上，这个类型参数使用单个大写字母来表示，指示所定义的参数类型。有如下惯例：\n\nE：表示元素\n\nT：表示类型\n\nK：表示键\n\nV：表示值\n\nN：表示数字\n\n### 定义泛型类\n\n上面的例子就是一个很好的演示\n\n```java\nclass Test<T> {\n\tprivate T o;\n\n\tpublic Test(T o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic T getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(T o) {\n\t\tthis.o = o;\n\t}\n}\n```\n\n使用泛型定义类之后，泛型参数 T 可以运用到该类中：可以声明成员变量类型、可以声明成员函数返回值类型、可以声明成员函数参数类型。\n\n要注意：泛型参数T不能用于声明静态变量，同时也不能用于new一个对象比如：T o = new T();\n\n下面的类型擦除会说到原因。\n\n### 定义泛型接口\n\n```java\ninterface Test<T> {\n\tpublic T test(T t);\n}\n```\n使用泛型定义接口之后，泛型参数 T 可以运用到该接口中：可以声明接口函数返回值类型、可以声明接口函数参数类型。\n\n\n### 定义泛型方法\n\n可以单独给方法使用泛型，而不是泛化整个类：\n\n```java\npublic static <T> T getT(T t){\n\treturn t;\n}\n```\n使用泛型定义方法后，泛型参数 T 可以声明该方法的返回值类型、可以声明该方法的参数类型。\n\n要注意，定义方法所用的泛型参数需要在修饰符之后添加。\n\n### 定义多个泛型参数\n\n以接口为例：\n\n```java\ninterface Test<T, S> {\n\tpublic T testT(T t);\n\tpublic S testS(S s);\n}\n\npublic static void main(String[] args) {\n    //编译时报错\n\t//getT(\"s\");\n}\n```\n多个泛型参数在尖括号中使用逗号隔开。类的泛化与方法的泛化类似。\n\n### 泛型参数的界限\n\n定义泛型参数界限有这样两种意义：\n\n1.有时候我们希望限定这个泛型参数的类型为某个类的子类或者超类；\n\n2.上面的例子中可以看到，我们定义了泛型参数，向方法中传入某种类型，这种类型是未知的，因此我们无法使用这种类型定义的变量，不能够调用它的方法。\n\n```java\npublic static <T extends Number> Integer getT(T t) {\n\treturn  new Integer(t.intValue());\n}\n```\n上面例子中，`<T extends A>`表示T是A或A的子类，他限定了传入泛型方法参数的类型必须为A或A的子类，同时，在方法体中我们也可以使用t这个实参就像使用A的实例一样，调用Number具有的public方法。\n\n除了`<T extends A>`限定T是A或A的子类外，还可以使用`<T super A> `这种方式来限定T是A或A的超类。\n\nA可以是某个类或者接口。\n\n除此以外，还可以为泛型参数限定多个限制范围，如`<T extends A & B & C>`，限定范围中最多只能有一个类(某个类只能有一个父类~~)，并且他必须是限定列表中的第一个。\n\n```java\nClass A { // }\ninterface B { // }\ninterface C { // }\n\n//正确\nclass D <T extends A & B & C> { // }\n//编译时报错\nclass D <T extends A & B & C> { // }\n```\n\n### 泛型的继承\n\n看一下jdk中List的泛型继承例子：\n\n```java\npublic interface List<E> extends Collection<E>{//...}\n```\n`List<String>` 就是 `Collection<String>` 的子类。\n\n假如定义自己的接口：\n\n```java\ninterface MyList<E,P> extends List<E> {\n  void setPay(E e,P p);\n  //...\n}\n```\n\n`MyList<String,String>`、`MyList<String,Integer>`、`MyList<String,Exception>`都是`List<String>`的子类。\n\n## 使用泛型\n\n上面的例子中已经列举了一些使用泛化类或者泛化函数的例子，但是还有一些问题需要指出：\n\n1.泛型参数只接受引用类型，不适用于基本类型\n\n比如：\n\n```java\nclass Test<T> {}\n\npublic static void main(String[] args) {\n    //无法通过编译，不接受int类型的泛化参数\n\t//Test<int> test = new Test();\n}\n```\n\n而我们使用泛化函数时：\n\n```java\npublic static void main(String[] args) {\n\tgetT(1);\n}\npublic static <T> void getT(T t) {\n}\n```\n是没有问题的，通过查看生成的字节码，发现getT(1)这个方法的字节码中1被自动装箱为Integer类型。\n\n2.通配符的使用\n\n考虑下面的情况：\n\n```java\nclass Test<T> {}\npublic static void getT(Test<Number> t) {\n}\n\npublic static void main(String[] args) {\n\tTest<Double> test = new Test();\n\t//编译时报错\n\t//getT(test);\n}\n```\n报错的原因很好理解，虽然Double是Number的子类，但Test<Double>并不是Test<Number>的子类，故类型检查无法通过。这一点一定要明白。\n\n那么如果我们确实想要传入一个Test<Double>类型的形参呢？可以使用通配符：\n\n```java\nclass Test<T> {}\npublic static void main(String[] args) {\n\t\tTest<Double> test = new Test();\n\t\t//正常运行\n\t\tgetT(test);\n}\npublic static void getT(Test<? extends Number> t) {\n}\n```\n`Test<? extends Number>`扩展了形参的类型，可以是`Test<Double>`、`Test<Integer>`等，尖括号中的类型必须是Number或继承于Number。同样的，通配符也适用于super，如`Test<? super A>`。\n\n如果类型参数中既没有extends 关键字，也没有super关键字，只有一个?，代表无限定通配符。\n\n`Test<?>`与`Test<Object>`并不相同，无论T是什么类型，`Test<T>` 是 `Test<?>`的子类，但是，`Test<T>` 不是 `Test<Object>` 的子类，想想上面的例子。\n\n通常在两种情况下会使用无限定通配符：\n\n1. 如果正在编写一个方法，可以使用Object类中提供的功能来实现\n\n2. 代码实现的功能与类型参数无关，比如List.clear()与List.size()方法，还有经常使用的`Class<?>`方法，其实现的功能都与类型参数无关。\n\n一般情况下，通配符`<? extends Number>`只是出现在使用泛型的时候，而不是定义泛型的时候，就像上面的例子那样。而`<T extends Number>`这种形式出现在定义泛型的时候，而不是使用泛型的时候，不要搞混了。\n\n结合泛型的继承和通配符的使用，理解一下泛型的类型系统，也就是泛型类的继承关系：\n\n以下内容来自：[Java深度历险（五）——Java泛型](http://www.infoq.com/cn/articles/cf-java-generics)\n\n***\n引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 `List<String>`和`List<Object>`这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：\n\n相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即`List<String>`是`Collection<String>` 的子类型，`List<String>`可以替换`Collection<String>`。这种情况也适用于带有上下界的类型声明。\n当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对`Collection<? extends Number>`来说，其子类型可以在Collection这个维度上展开，即`List<? extends Number>`和`Set<? extends Number>`等；也可以在Number这个层次上展开，即`Collection<Double>`和 `Collection<Integer>`等。如此循环下去，`ArrayList<Long>`和 `HashSet<Double>`等也都算是`Collection<? extends Number>`的子类型。\n如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。\n***\n\n关于通配符的理解可以参考[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)\n\n\n## 类型擦除\n\n类型擦除发生在编译阶段，对于运行期的JVM来说，`List<int>`与`List<String>`就是同一个类，因为在编译结束之后，生成的字节码文件中，他们都是List类型。\n\n1.java编译器会在编译前进行类型检查\n\njava编译器承担了所有泛型的类型安全检查工作。\n\n2.类型擦除后保留的原始类型\n\n原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。\n\n3.自动类型转换\n\n因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？\n\n比如：\n\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        ArrayList<Date> list=new ArrayList<Date>();  \n        list.add(new Date());  \n        Date myDate=list.get(0);  \n    }\n}  \n```\n`Date myDate=list.get(0);`这里我们并没有对其返回值进行强转就可以直接获取Date类型的返回值。原因在于在字节码当中，有checkcast这么一个操作帮助我们进行了强转，这是java自动进行的。\n\n更多的关于类型擦除的知识，参考[ java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题](http://blog.csdn.net/lonelyroamer/article/details/7868820)\n\n\n## 实践\n\n最近在重构公众号服务器的过程中，用到了泛型编程的知识。\n\n```java\npublic interface BaseServiceContext<T extends ReqBaseMessage, R> {\n\tpublic void selectService(T reqMeg);\n\n\tpublic R executeRequest();\n}\n```\n上面是一个选择service的上下文接口，接收到用户请求后通过这个接口选择对应的service并且执行service。这个接口相当于一个工厂和策略模式的结合体。下面是这个接口的一种实现：\n\n```java\n//请求为文本类型，返回string类型的处理结果\npublic class TextServiceContext implements BaseServiceContext<ReqTextMessage,String> {\n\n\t@Override\n\tpublic void selectService(ReqTextMessage reqMeg) {\n\t\t//.....\n\t}\n\n\t@Override\n\tpublic String executeRequest() {\n\t\t//.....\n\t}\n}\n```\n可以看到，BaseServiceContext<ReqTextMessage,String>限定了selectService方法的参数类型和executeRequest方法的返回值类型，使其能够灵活的支持各种类型的参数和返回值。\n\n看一下在没有学习泛型之前，这个接口是怎么实现的：\n\n```java\npublic interface BaseServiceContext {\n\tpublic void selectService(ReqBaseMessage reqMeg);\n\n\tpublic Object executeRequest();\n}\n\npublic class TextServiceContext implements BaseServiceContext {\n\n\t@Override\n\tpublic void selectService(ReqBaseMessage reqMeg) {\n\t\t//根据业务逻辑对reqMeg进行强转，需要程序员自己判断\n\t\t//很有可能强转失败\n\t}\n\n\t@Override\n\tpublic Object executeRequest() {\n\t\t//返回类型为object，在调用方法的外部强转为需要的类型\n\t\t//很有可能强转失败\n\t}\n}\n```\n可以看到没有使用泛型接口的情况下，类型不安全且增大了强转失败的风险。同时也需要程序员根据业务逻辑去判断该强转成什么类型。使用泛型接口之后就没有了这些问题，只需要在使用接口时声明好他的泛型参数就o了。\n\n上面只是我在开发过程中体会到泛型的一个好处，类似的例子还有很多。\n\n## 注意事项\n\n\n\n## 参考\n\n[java 泛型编程（一）](http://peiquan.blog.51cto.com/7518552/1302898)\n\n[泛型：工作原理及其重要性](http://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html)\n\n[Java深度历险（五）——Java泛型](http://www.infoq.com/cn/articles/cf-java-generics)\n\n[java泛型详解](http://blog.csdn.net/u012152619/article/details/47253811)\n\n[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)\n\n","source":"_posts/java泛型学习.md","raw":"---\nlayout: post\ntitle: java泛型学习\ndate: 2016-10-10 20:05:03\ncategories: 编程 \ntags:\n- java\n---\n\n有一段时间没有更新博客了，过了国庆之后，好像变得更懒了~~前两天开发了一个用于记账的公众号，功能很简单，就是普通的增删查改...由于是个人开发者，无法进行公众号的认证，所以没什么高级的接口权限，只能搞的简陋一点了...下一步计划再丰富丰富，目前想到了这几个功能：配合有道或者金山词霸的Api进行中英互译（API怎么用，可不可以用目前还不清楚），配合微博的Api接口整点微博热门什么的，配合豆瓣的Api接口做一个电影或者书籍查询的功能等等....公众号的服务器代码目前还部署在自己的电脑上，用nat123做了一下公网ip的映射，接下来考虑是不是要换成云服务器更为妥当....\n\n公众号在这里：\n\n{% asset_img easybill.jpg EasyBill %}\n\n目前，公众号已经开源：[WechatSubscriptionNumber](https://github.com/Hikyu/WechatSubscriptionNumber)\n\n好了，言归正传。今天学习了java的泛型知识，不总结一下老是觉得跟没学一样...\n\n<!-- more -->\n\n## 泛型的好处\n\n使用泛型的好处我觉得有两点：1：类型安全  2：减少类型强转\n\n下面通过一个例子说明:\n\n假设有一个Test类，通用的实现是:\n\n```java\nclass Test {\n\tprivate Object o;\n\n\tpublic Test(Object o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic Object getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(Object o) {\n\t\tthis.o = o;\n\t}\n}\n```\n我们可以这样使用它：\n\n```java\npublic static void main(String[] args) {\n\tTest test = new Test(new Integer(1));\n\t//编译时不报错\n\t//运行时报  java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\n\tString o = (String) test.getObject();\n}\n```\n\n看一个使用泛型的例子：\n\n```java\nclass Test<T> {\n\tprivate T o;\n\n\tpublic Test(T o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic T getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(T o) {\n\t\tthis.o = o;\n\t}\n}\n\npublic static void main(String[] args) {\n\tTest1<Integer> test = new Test1<Integer>(new Integer(1));\n\t//编译时报错，无法通过编译\n\t//String o = test.getObject();\n\n\t//正常运行\n\tInteger o = test.getObject();\n}\n```\n从上面的对比中能够看出两点：\n\n1.使用泛型之后在编译时报错而非运行时，减少了出错的几率；\n\n2.使用泛型之后编译器不再要求强转\n\n## 定义泛型\n\n泛型的机制能够在定义类、接口、方法时把类型参数化，也就是类似于方法的形参一样，把类型当做参数使用。\n\n泛型参数部分使用`<>`包裹起来，比如`<T>`，T声明了一种类型，习惯上，这个类型参数使用单个大写字母来表示，指示所定义的参数类型。有如下惯例：\n\nE：表示元素\n\nT：表示类型\n\nK：表示键\n\nV：表示值\n\nN：表示数字\n\n### 定义泛型类\n\n上面的例子就是一个很好的演示\n\n```java\nclass Test<T> {\n\tprivate T o;\n\n\tpublic Test(T o) {\n\t\tthis.o = o;\n\t}\n\n\tpublic T getObject() {\n\t\treturn o;\n\t}\n\n\tpublic void setObject(T o) {\n\t\tthis.o = o;\n\t}\n}\n```\n\n使用泛型定义类之后，泛型参数 T 可以运用到该类中：可以声明成员变量类型、可以声明成员函数返回值类型、可以声明成员函数参数类型。\n\n要注意：泛型参数T不能用于声明静态变量，同时也不能用于new一个对象比如：T o = new T();\n\n下面的类型擦除会说到原因。\n\n### 定义泛型接口\n\n```java\ninterface Test<T> {\n\tpublic T test(T t);\n}\n```\n使用泛型定义接口之后，泛型参数 T 可以运用到该接口中：可以声明接口函数返回值类型、可以声明接口函数参数类型。\n\n\n### 定义泛型方法\n\n可以单独给方法使用泛型，而不是泛化整个类：\n\n```java\npublic static <T> T getT(T t){\n\treturn t;\n}\n```\n使用泛型定义方法后，泛型参数 T 可以声明该方法的返回值类型、可以声明该方法的参数类型。\n\n要注意，定义方法所用的泛型参数需要在修饰符之后添加。\n\n### 定义多个泛型参数\n\n以接口为例：\n\n```java\ninterface Test<T, S> {\n\tpublic T testT(T t);\n\tpublic S testS(S s);\n}\n\npublic static void main(String[] args) {\n    //编译时报错\n\t//getT(\"s\");\n}\n```\n多个泛型参数在尖括号中使用逗号隔开。类的泛化与方法的泛化类似。\n\n### 泛型参数的界限\n\n定义泛型参数界限有这样两种意义：\n\n1.有时候我们希望限定这个泛型参数的类型为某个类的子类或者超类；\n\n2.上面的例子中可以看到，我们定义了泛型参数，向方法中传入某种类型，这种类型是未知的，因此我们无法使用这种类型定义的变量，不能够调用它的方法。\n\n```java\npublic static <T extends Number> Integer getT(T t) {\n\treturn  new Integer(t.intValue());\n}\n```\n上面例子中，`<T extends A>`表示T是A或A的子类，他限定了传入泛型方法参数的类型必须为A或A的子类，同时，在方法体中我们也可以使用t这个实参就像使用A的实例一样，调用Number具有的public方法。\n\n除了`<T extends A>`限定T是A或A的子类外，还可以使用`<T super A> `这种方式来限定T是A或A的超类。\n\nA可以是某个类或者接口。\n\n除此以外，还可以为泛型参数限定多个限制范围，如`<T extends A & B & C>`，限定范围中最多只能有一个类(某个类只能有一个父类~~)，并且他必须是限定列表中的第一个。\n\n```java\nClass A { // }\ninterface B { // }\ninterface C { // }\n\n//正确\nclass D <T extends A & B & C> { // }\n//编译时报错\nclass D <T extends A & B & C> { // }\n```\n\n### 泛型的继承\n\n看一下jdk中List的泛型继承例子：\n\n```java\npublic interface List<E> extends Collection<E>{//...}\n```\n`List<String>` 就是 `Collection<String>` 的子类。\n\n假如定义自己的接口：\n\n```java\ninterface MyList<E,P> extends List<E> {\n  void setPay(E e,P p);\n  //...\n}\n```\n\n`MyList<String,String>`、`MyList<String,Integer>`、`MyList<String,Exception>`都是`List<String>`的子类。\n\n## 使用泛型\n\n上面的例子中已经列举了一些使用泛化类或者泛化函数的例子，但是还有一些问题需要指出：\n\n1.泛型参数只接受引用类型，不适用于基本类型\n\n比如：\n\n```java\nclass Test<T> {}\n\npublic static void main(String[] args) {\n    //无法通过编译，不接受int类型的泛化参数\n\t//Test<int> test = new Test();\n}\n```\n\n而我们使用泛化函数时：\n\n```java\npublic static void main(String[] args) {\n\tgetT(1);\n}\npublic static <T> void getT(T t) {\n}\n```\n是没有问题的，通过查看生成的字节码，发现getT(1)这个方法的字节码中1被自动装箱为Integer类型。\n\n2.通配符的使用\n\n考虑下面的情况：\n\n```java\nclass Test<T> {}\npublic static void getT(Test<Number> t) {\n}\n\npublic static void main(String[] args) {\n\tTest<Double> test = new Test();\n\t//编译时报错\n\t//getT(test);\n}\n```\n报错的原因很好理解，虽然Double是Number的子类，但Test<Double>并不是Test<Number>的子类，故类型检查无法通过。这一点一定要明白。\n\n那么如果我们确实想要传入一个Test<Double>类型的形参呢？可以使用通配符：\n\n```java\nclass Test<T> {}\npublic static void main(String[] args) {\n\t\tTest<Double> test = new Test();\n\t\t//正常运行\n\t\tgetT(test);\n}\npublic static void getT(Test<? extends Number> t) {\n}\n```\n`Test<? extends Number>`扩展了形参的类型，可以是`Test<Double>`、`Test<Integer>`等，尖括号中的类型必须是Number或继承于Number。同样的，通配符也适用于super，如`Test<? super A>`。\n\n如果类型参数中既没有extends 关键字，也没有super关键字，只有一个?，代表无限定通配符。\n\n`Test<?>`与`Test<Object>`并不相同，无论T是什么类型，`Test<T>` 是 `Test<?>`的子类，但是，`Test<T>` 不是 `Test<Object>` 的子类，想想上面的例子。\n\n通常在两种情况下会使用无限定通配符：\n\n1. 如果正在编写一个方法，可以使用Object类中提供的功能来实现\n\n2. 代码实现的功能与类型参数无关，比如List.clear()与List.size()方法，还有经常使用的`Class<?>`方法，其实现的功能都与类型参数无关。\n\n一般情况下，通配符`<? extends Number>`只是出现在使用泛型的时候，而不是定义泛型的时候，就像上面的例子那样。而`<T extends Number>`这种形式出现在定义泛型的时候，而不是使用泛型的时候，不要搞混了。\n\n结合泛型的继承和通配符的使用，理解一下泛型的类型系统，也就是泛型类的继承关系：\n\n以下内容来自：[Java深度历险（五）——Java泛型](http://www.infoq.com/cn/articles/cf-java-generics)\n\n***\n引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 `List<String>`和`List<Object>`这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：\n\n相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即`List<String>`是`Collection<String>` 的子类型，`List<String>`可以替换`Collection<String>`。这种情况也适用于带有上下界的类型声明。\n当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对`Collection<? extends Number>`来说，其子类型可以在Collection这个维度上展开，即`List<? extends Number>`和`Set<? extends Number>`等；也可以在Number这个层次上展开，即`Collection<Double>`和 `Collection<Integer>`等。如此循环下去，`ArrayList<Long>`和 `HashSet<Double>`等也都算是`Collection<? extends Number>`的子类型。\n如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。\n***\n\n关于通配符的理解可以参考[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)\n\n\n## 类型擦除\n\n类型擦除发生在编译阶段，对于运行期的JVM来说，`List<int>`与`List<String>`就是同一个类，因为在编译结束之后，生成的字节码文件中，他们都是List类型。\n\n1.java编译器会在编译前进行类型检查\n\njava编译器承担了所有泛型的类型安全检查工作。\n\n2.类型擦除后保留的原始类型\n\n原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。\n\n3.自动类型转换\n\n因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？\n\n比如：\n\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        ArrayList<Date> list=new ArrayList<Date>();  \n        list.add(new Date());  \n        Date myDate=list.get(0);  \n    }\n}  \n```\n`Date myDate=list.get(0);`这里我们并没有对其返回值进行强转就可以直接获取Date类型的返回值。原因在于在字节码当中，有checkcast这么一个操作帮助我们进行了强转，这是java自动进行的。\n\n更多的关于类型擦除的知识，参考[ java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题](http://blog.csdn.net/lonelyroamer/article/details/7868820)\n\n\n## 实践\n\n最近在重构公众号服务器的过程中，用到了泛型编程的知识。\n\n```java\npublic interface BaseServiceContext<T extends ReqBaseMessage, R> {\n\tpublic void selectService(T reqMeg);\n\n\tpublic R executeRequest();\n}\n```\n上面是一个选择service的上下文接口，接收到用户请求后通过这个接口选择对应的service并且执行service。这个接口相当于一个工厂和策略模式的结合体。下面是这个接口的一种实现：\n\n```java\n//请求为文本类型，返回string类型的处理结果\npublic class TextServiceContext implements BaseServiceContext<ReqTextMessage,String> {\n\n\t@Override\n\tpublic void selectService(ReqTextMessage reqMeg) {\n\t\t//.....\n\t}\n\n\t@Override\n\tpublic String executeRequest() {\n\t\t//.....\n\t}\n}\n```\n可以看到，BaseServiceContext<ReqTextMessage,String>限定了selectService方法的参数类型和executeRequest方法的返回值类型，使其能够灵活的支持各种类型的参数和返回值。\n\n看一下在没有学习泛型之前，这个接口是怎么实现的：\n\n```java\npublic interface BaseServiceContext {\n\tpublic void selectService(ReqBaseMessage reqMeg);\n\n\tpublic Object executeRequest();\n}\n\npublic class TextServiceContext implements BaseServiceContext {\n\n\t@Override\n\tpublic void selectService(ReqBaseMessage reqMeg) {\n\t\t//根据业务逻辑对reqMeg进行强转，需要程序员自己判断\n\t\t//很有可能强转失败\n\t}\n\n\t@Override\n\tpublic Object executeRequest() {\n\t\t//返回类型为object，在调用方法的外部强转为需要的类型\n\t\t//很有可能强转失败\n\t}\n}\n```\n可以看到没有使用泛型接口的情况下，类型不安全且增大了强转失败的风险。同时也需要程序员根据业务逻辑去判断该强转成什么类型。使用泛型接口之后就没有了这些问题，只需要在使用接口时声明好他的泛型参数就o了。\n\n上面只是我在开发过程中体会到泛型的一个好处，类似的例子还有很多。\n\n## 注意事项\n\n\n\n## 参考\n\n[java 泛型编程（一）](http://peiquan.blog.51cto.com/7518552/1302898)\n\n[泛型：工作原理及其重要性](http://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html)\n\n[Java深度历险（五）——Java泛型](http://www.infoq.com/cn/articles/cf-java-generics)\n\n[java泛型详解](http://blog.csdn.net/u012152619/article/details/47253811)\n\n[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)\n\n","slug":"java泛型学习","published":1,"updated":"2017-04-11T13:08:38.843Z","comments":1,"photos":[],"link":"","_id":"cj4vch4go0045x3gc000mjbtc","content":"<p>有一段时间没有更新博客了，过了国庆之后，好像变得更懒了~~前两天开发了一个用于记账的公众号，功能很简单，就是普通的增删查改…由于是个人开发者，无法进行公众号的认证，所以没什么高级的接口权限，只能搞的简陋一点了…下一步计划再丰富丰富，目前想到了这几个功能：配合有道或者金山词霸的Api进行中英互译（API怎么用，可不可以用目前还不清楚），配合微博的Api接口整点微博热门什么的，配合豆瓣的Api接口做一个电影或者书籍查询的功能等等….公众号的服务器代码目前还部署在自己的电脑上，用nat123做了一下公网ip的映射，接下来考虑是不是要换成云服务器更为妥当….</p>\n<p>公众号在这里：</p>\n<img src=\"/2016/10/10/java泛型学习/easybill.jpg\" alt=\"EasyBill\" title=\"EasyBill\">\n<p>目前，公众号已经开源：<a href=\"https://github.com/Hikyu/WechatSubscriptionNumber\" target=\"_blank\" rel=\"external\">WechatSubscriptionNumber</a></p>\n<p>好了，言归正传。今天学习了java的泛型知识，不总结一下老是觉得跟没学一样…</p>\n<a id=\"more\"></a>\n<h2 id=\"泛型的好处\"><a href=\"#泛型的好处\" class=\"headerlink\" title=\"泛型的好处\"></a>泛型的好处</h2><p>使用泛型的好处我觉得有两点：1：类型安全  2：减少类型强转</p>\n<p>下面通过一个例子说明:</p>\n<p>假设有一个Test类，通用的实现是:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Object o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以这样使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest test = <span class=\"keyword\">new</span> Test(<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div><div class=\"line\">\t<span class=\"comment\">//编译时不报错</span></div><div class=\"line\">\t<span class=\"comment\">//运行时报  java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span></div><div class=\"line\">\tString o = (String) test.getObject();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一个使用泛型的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> T o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest1&lt;Integer&gt; test = <span class=\"keyword\">new</span> Test1&lt;Integer&gt;(<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div><div class=\"line\">\t<span class=\"comment\">//编译时报错，无法通过编译</span></div><div class=\"line\">\t<span class=\"comment\">//String o = test.getObject();</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//正常运行</span></div><div class=\"line\">\tInteger o = test.getObject();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的对比中能够看出两点：</p>\n<p>1.使用泛型之后在编译时报错而非运行时，减少了出错的几率；</p>\n<p>2.使用泛型之后编译器不再要求强转</p>\n<h2 id=\"定义泛型\"><a href=\"#定义泛型\" class=\"headerlink\" title=\"定义泛型\"></a>定义泛型</h2><p>泛型的机制能够在定义类、接口、方法时把类型参数化，也就是类似于方法的形参一样，把类型当做参数使用。</p>\n<p>泛型参数部分使用<code>&lt;&gt;</code>包裹起来，比如<code>&lt;T&gt;</code>，T声明了一种类型，习惯上，这个类型参数使用单个大写字母来表示，指示所定义的参数类型。有如下惯例：</p>\n<p>E：表示元素</p>\n<p>T：表示类型</p>\n<p>K：表示键</p>\n<p>V：表示值</p>\n<p>N：表示数字</p>\n<h3 id=\"定义泛型类\"><a href=\"#定义泛型类\" class=\"headerlink\" title=\"定义泛型类\"></a>定义泛型类</h3><p>上面的例子就是一个很好的演示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> T o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义类之后，泛型参数 T 可以运用到该类中：可以声明成员变量类型、可以声明成员函数返回值类型、可以声明成员函数参数类型。</p>\n<p>要注意：泛型参数T不能用于声明静态变量，同时也不能用于new一个对象比如：T o = new T();</p>\n<p>下面的类型擦除会说到原因。</p>\n<h3 id=\"定义泛型接口\"><a href=\"#定义泛型接口\" class=\"headerlink\" title=\"定义泛型接口\"></a>定义泛型接口</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">test</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义接口之后，泛型参数 T 可以运用到该接口中：可以声明接口函数返回值类型、可以声明接口函数参数类型。</p>\n<h3 id=\"定义泛型方法\"><a href=\"#定义泛型方法\" class=\"headerlink\" title=\"定义泛型方法\"></a>定义泛型方法</h3><p>可以单独给方法使用泛型，而不是泛化整个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getT</span><span class=\"params\">(T t)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> t;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义方法后，泛型参数 T 可以声明该方法的返回值类型、可以声明该方法的参数类型。</p>\n<p>要注意，定义方法所用的泛型参数需要在修饰符之后添加。</p>\n<h3 id=\"定义多个泛型参数\"><a href=\"#定义多个泛型参数\" class=\"headerlink\" title=\"定义多个泛型参数\"></a>定义多个泛型参数</h3><p>以接口为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">S</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">testT</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> S <span class=\"title\">testS</span><span class=\"params\">(S s)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//编译时报错</span></div><div class=\"line\">\t<span class=\"comment\">//getT(\"s\");</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>多个泛型参数在尖括号中使用逗号隔开。类的泛化与方法的泛化类似。</p>\n<h3 id=\"泛型参数的界限\"><a href=\"#泛型参数的界限\" class=\"headerlink\" title=\"泛型参数的界限\"></a>泛型参数的界限</h3><p>定义泛型参数界限有这样两种意义：</p>\n<p>1.有时候我们希望限定这个泛型参数的类型为某个类的子类或者超类；</p>\n<p>2.上面的例子中可以看到，我们定义了泛型参数，向方法中传入某种类型，这种类型是未知的，因此我们无法使用这种类型定义的变量，不能够调用它的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T extends Number&gt; <span class=\"function\">Integer <span class=\"title\">getT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> Integer(t.intValue());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面例子中，<code>&lt;T extends A&gt;</code>表示T是A或A的子类，他限定了传入泛型方法参数的类型必须为A或A的子类，同时，在方法体中我们也可以使用t这个实参就像使用A的实例一样，调用Number具有的public方法。</p>\n<p>除了<code>&lt;T extends A&gt;</code>限定T是A或A的子类外，还可以使用<code>&lt;T super A&gt;</code>这种方式来限定T是A或A的超类。</p>\n<p>A可以是某个类或者接口。</p>\n<p>除此以外，还可以为泛型参数限定多个限制范围，如<code>&lt;T extends A &amp; B &amp; C&gt;</code>，限定范围中最多只能有一个类(某个类只能有一个父类~~)，并且他必须是限定列表中的第一个。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class A &#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">B</span> </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">C</span> </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//正确</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> &lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> &amp; <span class=\"title\">B</span> &amp; <span class=\"title\">C</span>&gt; </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"comment\">//编译时报错</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> &lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> &amp; <span class=\"title\">B</span> &amp; <span class=\"title\">C</span>&gt; </span>&#123; <span class=\"comment\">// &#125;</span></div></pre></td></tr></table></figure>\n<h3 id=\"泛型的继承\"><a href=\"#泛型的继承\" class=\"headerlink\" title=\"泛型的继承\"></a>泛型的继承</h3><p>看一下jdk中List的泛型继承例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;<span class=\"comment\">//...&#125;</span></div></pre></td></tr></table></figure>\n<p><code>List&lt;String&gt;</code> 就是 <code>Collection&lt;String&gt;</code> 的子类。</p>\n<p>假如定义自己的接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyList</span>&lt;<span class=\"title\">E</span>,<span class=\"title\">P</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setPay</span><span class=\"params\">(E e,P p)</span></span>;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>MyList&lt;String,String&gt;</code>、<code>MyList&lt;String,Integer&gt;</code>、<code>MyList&lt;String,Exception&gt;</code>都是<code>List&lt;String&gt;</code>的子类。</p>\n<h2 id=\"使用泛型\"><a href=\"#使用泛型\" class=\"headerlink\" title=\"使用泛型\"></a>使用泛型</h2><p>上面的例子中已经列举了一些使用泛化类或者泛化函数的例子，但是还有一些问题需要指出：</p>\n<p>1.泛型参数只接受引用类型，不适用于基本类型</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//无法通过编译，不接受int类型的泛化参数</span></div><div class=\"line\">\t<span class=\"comment\">//Test&lt;int&gt; test = new Test();</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而我们使用泛化函数时：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tgetT(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>是没有问题的，通过查看生成的字节码，发现getT(1)这个方法的字节码中1被自动装箱为Integer类型。</p>\n<p>2.通配符的使用</p>\n<p>考虑下面的情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(Test&lt;Number&gt; t)</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest&lt;Double&gt; test = <span class=\"keyword\">new</span> Test();</div><div class=\"line\">\t<span class=\"comment\">//编译时报错</span></div><div class=\"line\">\t<span class=\"comment\">//getT(test);</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>报错的原因很好理解，虽然Double是Number的子类，但Test<double>并不是Test<number>的子类，故类型检查无法通过。这一点一定要明白。</number></double></p>\n<p>那么如果我们确实想要传入一个Test<double>类型的形参呢？可以使用通配符：</double></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tTest&lt;Double&gt; test = <span class=\"keyword\">new</span> Test();</div><div class=\"line\">\t\t<span class=\"comment\">//正常运行</span></div><div class=\"line\">\t\tgetT(test);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(Test&lt;? extends Number&gt; t)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Test&lt;? extends Number&gt;</code>扩展了形参的类型，可以是<code>Test&lt;Double&gt;</code>、<code>Test&lt;Integer&gt;</code>等，尖括号中的类型必须是Number或继承于Number。同样的，通配符也适用于super，如<code>Test&lt;? super A&gt;</code>。</p>\n<p>如果类型参数中既没有extends 关键字，也没有super关键字，只有一个?，代表无限定通配符。</p>\n<p><code>Test&lt;?&gt;</code>与<code>Test&lt;Object&gt;</code>并不相同，无论T是什么类型，<code>Test&lt;T&gt;</code> 是 <code>Test&lt;?&gt;</code>的子类，但是，<code>Test&lt;T&gt;</code> 不是 <code>Test&lt;Object&gt;</code> 的子类，想想上面的例子。</p>\n<p>通常在两种情况下会使用无限定通配符：</p>\n<ol>\n<li><p>如果正在编写一个方法，可以使用Object类中提供的功能来实现</p>\n</li>\n<li><p>代码实现的功能与类型参数无关，比如List.clear()与List.size()方法，还有经常使用的<code>Class&lt;?&gt;</code>方法，其实现的功能都与类型参数无关。</p>\n</li>\n</ol>\n<p>一般情况下，通配符<code>&lt;? extends Number&gt;</code>只是出现在使用泛型的时候，而不是定义泛型的时候，就像上面的例子那样。而<code>&lt;T extends Number&gt;</code>这种形式出现在定义泛型的时候，而不是使用泛型的时候，不要搞混了。</p>\n<p>结合泛型的继承和通配符的使用，理解一下泛型的类型系统，也就是泛型类的继承关系：</p>\n<p>以下内容来自：<a href=\"http://www.infoq.com/cn/articles/cf-java-generics\" target=\"_blank\" rel=\"external\">Java深度历险（五）——Java泛型</a></p>\n<hr>\n<p>引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 <code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：</p>\n<p>相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code> 的子类型，<code>List&lt;String&gt;</code>可以替换<code>Collection&lt;String&gt;</code>。这种情况也适用于带有上下界的类型声明。<br>当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对<code>Collection&lt;? extends Number&gt;</code>来说，其子类型可以在Collection这个维度上展开，即<code>List&lt;? extends Number&gt;</code>和<code>Set&lt;? extends Number&gt;</code>等；也可以在Number这个层次上展开，即<code>Collection&lt;Double&gt;</code>和 <code>Collection&lt;Integer&gt;</code>等。如此循环下去，<code>ArrayList&lt;Long&gt;</code>和 <code>HashSet&lt;Double&gt;</code>等也都算是<code>Collection&lt;? extends Number&gt;</code>的子类型。<br>如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。</p>\n<hr>\n<p>关于通配符的理解可以参考<a href=\"https://www.zhihu.com/question/20400700\" target=\"_blank\" rel=\"external\">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></p>\n<h2 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h2><p>类型擦除发生在编译阶段，对于运行期的JVM来说，<code>List&lt;int&gt;</code>与<code>List&lt;String&gt;</code>就是同一个类，因为在编译结束之后，生成的字节码文件中，他们都是List类型。</p>\n<p>1.java编译器会在编译前进行类型检查</p>\n<p>java编译器承担了所有泛型的类型安全检查工作。</p>\n<p>2.类型擦除后保留的原始类型</p>\n<p>原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。</p>\n<p>3.自动类型转换</p>\n<p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        ArrayList&lt;Date&gt; list=<span class=\"keyword\">new</span> ArrayList&lt;Date&gt;();  </div><div class=\"line\">        list.add(<span class=\"keyword\">new</span> Date());  </div><div class=\"line\">        Date myDate=list.get(<span class=\"number\">0</span>);  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Date myDate=list.get(0);</code>这里我们并没有对其返回值进行强转就可以直接获取Date类型的返回值。原因在于在字节码当中，有checkcast这么一个操作帮助我们进行了强转，这是java自动进行的。</p>\n<p>更多的关于类型擦除的知识，参考<a href=\"http://blog.csdn.net/lonelyroamer/article/details/7868820\" target=\"_blank\" rel=\"external\"> java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>最近在重构公众号服务器的过程中，用到了泛型编程的知识。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseServiceContext</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReqBaseMessage</span>, <span class=\"title\">R</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(T reqMeg)</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> R <span class=\"title\">executeRequest</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面是一个选择service的上下文接口，接收到用户请求后通过这个接口选择对应的service并且执行service。这个接口相当于一个工厂和策略模式的结合体。下面是这个接口的一种实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//请求为文本类型，返回string类型的处理结果</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextServiceContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseServiceContext</span>&lt;<span class=\"title\">ReqTextMessage</span>,<span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqTextMessage reqMeg)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//.....</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">executeRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//.....</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，BaseServiceContext<reqtextmessage,string>限定了selectService方法的参数类型和executeRequest方法的返回值类型，使其能够灵活的支持各种类型的参数和返回值。</reqtextmessage,string></p>\n<p>看一下在没有学习泛型之前，这个接口是怎么实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseServiceContext</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqBaseMessage reqMeg)</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">executeRequest</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextServiceContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseServiceContext</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqBaseMessage reqMeg)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//根据业务逻辑对reqMeg进行强转，需要程序员自己判断</span></div><div class=\"line\">\t\t<span class=\"comment\">//很有可能强转失败</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">executeRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//返回类型为object，在调用方法的外部强转为需要的类型</span></div><div class=\"line\">\t\t<span class=\"comment\">//很有可能强转失败</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到没有使用泛型接口的情况下，类型不安全且增大了强转失败的风险。同时也需要程序员根据业务逻辑去判断该强转成什么类型。使用泛型接口之后就没有了这些问题，只需要在使用接口时声明好他的泛型参数就o了。</p>\n<p>上面只是我在开发过程中体会到泛型的一个好处，类似的例子还有很多。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://peiquan.blog.51cto.com/7518552/1302898\" target=\"_blank\" rel=\"external\">java 泛型编程（一）</a></p>\n<p><a href=\"http://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html\" target=\"_blank\" rel=\"external\">泛型：工作原理及其重要性</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/cf-java-generics\" target=\"_blank\" rel=\"external\">Java深度历险（五）——Java泛型</a></p>\n<p><a href=\"http://blog.csdn.net/u012152619/article/details/47253811\" target=\"_blank\" rel=\"external\">java泛型详解</a></p>\n<p><a href=\"https://www.zhihu.com/question/20400700\" target=\"_blank\" rel=\"external\">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></p>\n","excerpt":"<p>有一段时间没有更新博客了，过了国庆之后，好像变得更懒了~~前两天开发了一个用于记账的公众号，功能很简单，就是普通的增删查改…由于是个人开发者，无法进行公众号的认证，所以没什么高级的接口权限，只能搞的简陋一点了…下一步计划再丰富丰富，目前想到了这几个功能：配合有道或者金山词霸的Api进行中英互译（API怎么用，可不可以用目前还不清楚），配合微博的Api接口整点微博热门什么的，配合豆瓣的Api接口做一个电影或者书籍查询的功能等等….公众号的服务器代码目前还部署在自己的电脑上，用nat123做了一下公网ip的映射，接下来考虑是不是要换成云服务器更为妥当….</p>\n<p>公众号在这里：</p>\n<img src=\"/2016/10/10/java泛型学习/easybill.jpg\" alt=\"EasyBill\" title=\"EasyBill\">\n<p>目前，公众号已经开源：<a href=\"https://github.com/Hikyu/WechatSubscriptionNumber\">WechatSubscriptionNumber</a></p>\n<p>好了，言归正传。今天学习了java的泛型知识，不总结一下老是觉得跟没学一样…</p>","more":"<h2 id=\"泛型的好处\"><a href=\"#泛型的好处\" class=\"headerlink\" title=\"泛型的好处\"></a>泛型的好处</h2><p>使用泛型的好处我觉得有两点：1：类型安全  2：减少类型强转</p>\n<p>下面通过一个例子说明:</p>\n<p>假设有一个Test类，通用的实现是:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Object o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以这样使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest test = <span class=\"keyword\">new</span> Test(<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div><div class=\"line\">\t<span class=\"comment\">//编译时不报错</span></div><div class=\"line\">\t<span class=\"comment\">//运行时报  java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span></div><div class=\"line\">\tString o = (String) test.getObject();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一个使用泛型的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> T o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest1&lt;Integer&gt; test = <span class=\"keyword\">new</span> Test1&lt;Integer&gt;(<span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>));</div><div class=\"line\">\t<span class=\"comment\">//编译时报错，无法通过编译</span></div><div class=\"line\">\t<span class=\"comment\">//String o = test.getObject();</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//正常运行</span></div><div class=\"line\">\tInteger o = test.getObject();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的对比中能够看出两点：</p>\n<p>1.使用泛型之后在编译时报错而非运行时，减少了出错的几率；</p>\n<p>2.使用泛型之后编译器不再要求强转</p>\n<h2 id=\"定义泛型\"><a href=\"#定义泛型\" class=\"headerlink\" title=\"定义泛型\"></a>定义泛型</h2><p>泛型的机制能够在定义类、接口、方法时把类型参数化，也就是类似于方法的形参一样，把类型当做参数使用。</p>\n<p>泛型参数部分使用<code>&lt;&gt;</code>包裹起来，比如<code>&lt;T&gt;</code>，T声明了一种类型，习惯上，这个类型参数使用单个大写字母来表示，指示所定义的参数类型。有如下惯例：</p>\n<p>E：表示元素</p>\n<p>T：表示类型</p>\n<p>K：表示键</p>\n<p>V：表示值</p>\n<p>N：表示数字</p>\n<h3 id=\"定义泛型类\"><a href=\"#定义泛型类\" class=\"headerlink\" title=\"定义泛型类\"></a>定义泛型类</h3><p>上面的例子就是一个很好的演示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> T o;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getObject</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObject</span><span class=\"params\">(T o)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.o = o;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义类之后，泛型参数 T 可以运用到该类中：可以声明成员变量类型、可以声明成员函数返回值类型、可以声明成员函数参数类型。</p>\n<p>要注意：泛型参数T不能用于声明静态变量，同时也不能用于new一个对象比如：T o = new T();</p>\n<p>下面的类型擦除会说到原因。</p>\n<h3 id=\"定义泛型接口\"><a href=\"#定义泛型接口\" class=\"headerlink\" title=\"定义泛型接口\"></a>定义泛型接口</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">test</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义接口之后，泛型参数 T 可以运用到该接口中：可以声明接口函数返回值类型、可以声明接口函数参数类型。</p>\n<h3 id=\"定义泛型方法\"><a href=\"#定义泛型方法\" class=\"headerlink\" title=\"定义泛型方法\"></a>定义泛型方法</h3><p>可以单独给方法使用泛型，而不是泛化整个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getT</span><span class=\"params\">(T t)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> t;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用泛型定义方法后，泛型参数 T 可以声明该方法的返回值类型、可以声明该方法的参数类型。</p>\n<p>要注意，定义方法所用的泛型参数需要在修饰符之后添加。</p>\n<h3 id=\"定义多个泛型参数\"><a href=\"#定义多个泛型参数\" class=\"headerlink\" title=\"定义多个泛型参数\"></a>定义多个泛型参数</h3><p>以接口为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">S</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">testT</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> S <span class=\"title\">testS</span><span class=\"params\">(S s)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//编译时报错</span></div><div class=\"line\">\t<span class=\"comment\">//getT(\"s\");</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>多个泛型参数在尖括号中使用逗号隔开。类的泛化与方法的泛化类似。</p>\n<h3 id=\"泛型参数的界限\"><a href=\"#泛型参数的界限\" class=\"headerlink\" title=\"泛型参数的界限\"></a>泛型参数的界限</h3><p>定义泛型参数界限有这样两种意义：</p>\n<p>1.有时候我们希望限定这个泛型参数的类型为某个类的子类或者超类；</p>\n<p>2.上面的例子中可以看到，我们定义了泛型参数，向方法中传入某种类型，这种类型是未知的，因此我们无法使用这种类型定义的变量，不能够调用它的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T extends Number&gt; <span class=\"function\">Integer <span class=\"title\">getT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> Integer(t.intValue());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面例子中，<code>&lt;T extends A&gt;</code>表示T是A或A的子类，他限定了传入泛型方法参数的类型必须为A或A的子类，同时，在方法体中我们也可以使用t这个实参就像使用A的实例一样，调用Number具有的public方法。</p>\n<p>除了<code>&lt;T extends A&gt;</code>限定T是A或A的子类外，还可以使用<code>&lt;T super A&gt;</code>这种方式来限定T是A或A的超类。</p>\n<p>A可以是某个类或者接口。</p>\n<p>除此以外，还可以为泛型参数限定多个限制范围，如<code>&lt;T extends A &amp; B &amp; C&gt;</code>，限定范围中最多只能有一个类(某个类只能有一个父类~~)，并且他必须是限定列表中的第一个。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class A &#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">B</span> </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">C</span> </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//正确</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> &lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> &amp; <span class=\"title\">B</span> &amp; <span class=\"title\">C</span>&gt; </span>&#123; <span class=\"comment\">// &#125;</span></div><div class=\"line\"><span class=\"comment\">//编译时报错</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> &lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> &amp; <span class=\"title\">B</span> &amp; <span class=\"title\">C</span>&gt; </span>&#123; <span class=\"comment\">// &#125;</span></div></pre></td></tr></table></figure>\n<h3 id=\"泛型的继承\"><a href=\"#泛型的继承\" class=\"headerlink\" title=\"泛型的继承\"></a>泛型的继承</h3><p>看一下jdk中List的泛型继承例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;<span class=\"comment\">//...&#125;</span></div></pre></td></tr></table></figure>\n<p><code>List&lt;String&gt;</code> 就是 <code>Collection&lt;String&gt;</code> 的子类。</p>\n<p>假如定义自己的接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyList</span>&lt;<span class=\"title\">E</span>,<span class=\"title\">P</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setPay</span><span class=\"params\">(E e,P p)</span></span>;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>MyList&lt;String,String&gt;</code>、<code>MyList&lt;String,Integer&gt;</code>、<code>MyList&lt;String,Exception&gt;</code>都是<code>List&lt;String&gt;</code>的子类。</p>\n<h2 id=\"使用泛型\"><a href=\"#使用泛型\" class=\"headerlink\" title=\"使用泛型\"></a>使用泛型</h2><p>上面的例子中已经列举了一些使用泛化类或者泛化函数的例子，但是还有一些问题需要指出：</p>\n<p>1.泛型参数只接受引用类型，不适用于基本类型</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//无法通过编译，不接受int类型的泛化参数</span></div><div class=\"line\">\t<span class=\"comment\">//Test&lt;int&gt; test = new Test();</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而我们使用泛化函数时：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tgetT(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>是没有问题的，通过查看生成的字节码，发现getT(1)这个方法的字节码中1被自动装箱为Integer类型。</p>\n<p>2.通配符的使用</p>\n<p>考虑下面的情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(Test&lt;Number&gt; t)</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTest&lt;Double&gt; test = <span class=\"keyword\">new</span> Test();</div><div class=\"line\">\t<span class=\"comment\">//编译时报错</span></div><div class=\"line\">\t<span class=\"comment\">//getT(test);</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>报错的原因很好理解，虽然Double是Number的子类，但Test<Double>并不是Test<Number>的子类，故类型检查无法通过。这一点一定要明白。</p>\n<p>那么如果我们确实想要传入一个Test<Double>类型的形参呢？可以使用通配符：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tTest&lt;Double&gt; test = <span class=\"keyword\">new</span> Test();</div><div class=\"line\">\t\t<span class=\"comment\">//正常运行</span></div><div class=\"line\">\t\tgetT(test);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getT</span><span class=\"params\">(Test&lt;? extends Number&gt; t)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Test&lt;? extends Number&gt;</code>扩展了形参的类型，可以是<code>Test&lt;Double&gt;</code>、<code>Test&lt;Integer&gt;</code>等，尖括号中的类型必须是Number或继承于Number。同样的，通配符也适用于super，如<code>Test&lt;? super A&gt;</code>。</p>\n<p>如果类型参数中既没有extends 关键字，也没有super关键字，只有一个?，代表无限定通配符。</p>\n<p><code>Test&lt;?&gt;</code>与<code>Test&lt;Object&gt;</code>并不相同，无论T是什么类型，<code>Test&lt;T&gt;</code> 是 <code>Test&lt;?&gt;</code>的子类，但是，<code>Test&lt;T&gt;</code> 不是 <code>Test&lt;Object&gt;</code> 的子类，想想上面的例子。</p>\n<p>通常在两种情况下会使用无限定通配符：</p>\n<ol>\n<li><p>如果正在编写一个方法，可以使用Object类中提供的功能来实现</p>\n</li>\n<li><p>代码实现的功能与类型参数无关，比如List.clear()与List.size()方法，还有经常使用的<code>Class&lt;?&gt;</code>方法，其实现的功能都与类型参数无关。</p>\n</li>\n</ol>\n<p>一般情况下，通配符<code>&lt;? extends Number&gt;</code>只是出现在使用泛型的时候，而不是定义泛型的时候，就像上面的例子那样。而<code>&lt;T extends Number&gt;</code>这种形式出现在定义泛型的时候，而不是使用泛型的时候，不要搞混了。</p>\n<p>结合泛型的继承和通配符的使用，理解一下泛型的类型系统，也就是泛型类的继承关系：</p>\n<p>以下内容来自：<a href=\"http://www.infoq.com/cn/articles/cf-java-generics\">Java深度历险（五）——Java泛型</a></p>\n<hr>\n<p>引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 <code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：</p>\n<p>相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code> 的子类型，<code>List&lt;String&gt;</code>可以替换<code>Collection&lt;String&gt;</code>。这种情况也适用于带有上下界的类型声明。<br>当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对<code>Collection&lt;? extends Number&gt;</code>来说，其子类型可以在Collection这个维度上展开，即<code>List&lt;? extends Number&gt;</code>和<code>Set&lt;? extends Number&gt;</code>等；也可以在Number这个层次上展开，即<code>Collection&lt;Double&gt;</code>和 <code>Collection&lt;Integer&gt;</code>等。如此循环下去，<code>ArrayList&lt;Long&gt;</code>和 <code>HashSet&lt;Double&gt;</code>等也都算是<code>Collection&lt;? extends Number&gt;</code>的子类型。<br>如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。</p>\n<hr>\n<p>关于通配符的理解可以参考<a href=\"https://www.zhihu.com/question/20400700\">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></p>\n<h2 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h2><p>类型擦除发生在编译阶段，对于运行期的JVM来说，<code>List&lt;int&gt;</code>与<code>List&lt;String&gt;</code>就是同一个类，因为在编译结束之后，生成的字节码文件中，他们都是List类型。</p>\n<p>1.java编译器会在编译前进行类型检查</p>\n<p>java编译器承担了所有泛型的类型安全检查工作。</p>\n<p>2.类型擦除后保留的原始类型</p>\n<p>原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。</p>\n<p>3.自动类型转换</p>\n<p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        ArrayList&lt;Date&gt; list=<span class=\"keyword\">new</span> ArrayList&lt;Date&gt;();  </div><div class=\"line\">        list.add(<span class=\"keyword\">new</span> Date());  </div><div class=\"line\">        Date myDate=list.get(<span class=\"number\">0</span>);  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Date myDate=list.get(0);</code>这里我们并没有对其返回值进行强转就可以直接获取Date类型的返回值。原因在于在字节码当中，有checkcast这么一个操作帮助我们进行了强转，这是java自动进行的。</p>\n<p>更多的关于类型擦除的知识，参考<a href=\"http://blog.csdn.net/lonelyroamer/article/details/7868820\"> java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>最近在重构公众号服务器的过程中，用到了泛型编程的知识。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseServiceContext</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">ReqBaseMessage</span>, <span class=\"title\">R</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(T reqMeg)</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> R <span class=\"title\">executeRequest</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面是一个选择service的上下文接口，接收到用户请求后通过这个接口选择对应的service并且执行service。这个接口相当于一个工厂和策略模式的结合体。下面是这个接口的一种实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//请求为文本类型，返回string类型的处理结果</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextServiceContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseServiceContext</span>&lt;<span class=\"title\">ReqTextMessage</span>,<span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqTextMessage reqMeg)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//.....</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">executeRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//.....</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，BaseServiceContext<ReqTextMessage,String>限定了selectService方法的参数类型和executeRequest方法的返回值类型，使其能够灵活的支持各种类型的参数和返回值。</p>\n<p>看一下在没有学习泛型之前，这个接口是怎么实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseServiceContext</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqBaseMessage reqMeg)</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">executeRequest</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextServiceContext</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseServiceContext</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectService</span><span class=\"params\">(ReqBaseMessage reqMeg)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//根据业务逻辑对reqMeg进行强转，需要程序员自己判断</span></div><div class=\"line\">\t\t<span class=\"comment\">//很有可能强转失败</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">executeRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//返回类型为object，在调用方法的外部强转为需要的类型</span></div><div class=\"line\">\t\t<span class=\"comment\">//很有可能强转失败</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到没有使用泛型接口的情况下，类型不安全且增大了强转失败的风险。同时也需要程序员根据业务逻辑去判断该强转成什么类型。使用泛型接口之后就没有了这些问题，只需要在使用接口时声明好他的泛型参数就o了。</p>\n<p>上面只是我在开发过程中体会到泛型的一个好处，类似的例子还有很多。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://peiquan.blog.51cto.com/7518552/1302898\">java 泛型编程（一）</a></p>\n<p><a href=\"http://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html\">泛型：工作原理及其重要性</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/cf-java-generics\">Java深度历险（五）——Java泛型</a></p>\n<p><a href=\"http://blog.csdn.net/u012152619/article/details/47253811\">java泛型详解</a></p>\n<p><a href=\"https://www.zhihu.com/question/20400700\">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></p>"},{"layout":"post","date":"2016-04-14T05:48:55.000Z","title":"他可是科比布莱恩特","_content":"<center>\n\t<iframe \n\t\twidth=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen>\n\t</iframe>\n</center>\nwhat can i say, Mamba out！\n\n<!-- more -->\n\n{% asset_img kobe.jpg 科比 %}\n\n\n\n","source":"_posts/他可是科比·布莱恩特!.md","raw":"---\nlayout: post\ndate:   2016-04-14 13:48:55\ntitle: \"他可是科比布莱恩特\"\ncategories: 生活\n---\n<center>\n\t<iframe \n\t\twidth=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen>\n\t</iframe>\n</center>\nwhat can i say, Mamba out！\n\n<!-- more -->\n\n{% asset_img kobe.jpg 科比 %}\n\n\n\n","slug":"他可是科比·布莱恩特!","published":1,"updated":"2017-04-11T13:08:38.850Z","comments":1,"photos":[],"link":"","_id":"cj4vch4gr0048x3gcr9p8qlvs","content":"<p><center><br>    <iframe width=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen><br>    </iframe><br></center><br>what can i say, Mamba out！</p>\n<a id=\"more\"></a>\n<img src=\"/2016/04/14/他可是科比·布莱恩特!/kobe.jpg\" alt=\"科比\" title=\"科比\">\n","excerpt":"<p><center><br>    <iframe \n        width=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen><br>    </iframe><br></center><br>what can i say, Mamba out！</p>","more":"<img src=\"/2016/04/14/他可是科比·布莱恩特!/kobe.jpg\" alt=\"科比\" title=\"科比\">"},{"layout":"post","title":"webservice相关","date":"2017-03-15T03:22:45.000Z","_content":"> 上周最后三天去北京培训了Hadoop，了解了一些目前流行的分布式组件。在谈到这些组件的交互过程中，经常会提到RPC，webservice等关键词，所以简单了解了一下这些关键词的含义~\n\n## [WebService](https://zh.wikipedia.org/wiki/Web_services)\n\nwebservice，拆开来看就是 web（网络）和service（服务），先了解一下什么是服务：\n\n计算机的后台进程提供了某种功能，我们把提供了这种功能的进程称为守护进程（Daemon），提供的功能称为服务。比如，我们启动了数据库，数据库进程就会一直运行在后台监听连接数据库的动作，这种监听连接的功能就是一种服务。\n\n服务分为本地服务和网络服务。使用同一台机器上提供的服务就是本地服务，通过网络连接到另一台计算机使用它提供的服务就是网络服务。\n\n所以，webservice 就是通过网络使用了其他服务器提供的某种功能或获取了某些资源。\n\n这样一来，webservice就很常见了。比如我们做了一个显示天气情况的app，使用了百度地图提供的定位功能，使用了其他服务商提供的天气数据，这些都属于webservice。\n\nwebservice可以包含以下几个实现：\n\nRPC：面向过程\n\nRMI：面向对象\n\nREST：面向资源\n\n[Web Service tutorial](http://www.java2blog.com/2013/03/web-service-tutorial.html)\n\n<!-- more -->\n\n## [RPC](https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8)\n\n### 概念\n\n> 远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。\n该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。\n如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。\n\n上面的解释摘自维基百科\n\nRPC属于webservice的一种，就是在一个进程中调用另一个进程中的服务。就像调用本地方法一样调用远程服务器的方法。\n\nRPC有很多实现，包括XML-RPC、JSON-RPC、JAX-RPC等等。\n\n一次RPC调用过程就是向服务器发送一个过程调用的方法和参数，得到服务器返回的方法执行结果。RPC的本质就是一次远程调用，但更强调透明调用。RPC是跨语言的。\n\n### 使用\n\n以[Json-Rpc](http://www.jsonrpc.org) 为例，看一下RPC是如何工作的：\n\n使用java中的json-rpc实现[jsonrpc4j](https://github.com/briandilley/jsonrpc4j)：（也有其他语言的实现）\n\nCreate your service interface:\n```\npackage com.mycompany;\npublic interface UserService {\n    User createUser(String userName, String firstName, String password);\n    User createUser(String userName, String password);\n    User findUserByUserName(String userName);\n    int getUserCount();\n}\n```\nImplement it:\n```\npackage com.mycompany;\npublic class UserServiceImpl\n    implements UserService {\n\n    public User createUser(String userName, String firstName, String password) {\n        User user = new User();\n        user.setUserName(userName);\n        user.setFirstName(firstName);\n        user.setPassword(password);\n        database.saveUser(user)\n        return user;\n    }\n\n    public User createUser(String userName, String password) {\n        return this.createUser(userName, null, password);\n    }\n\n    public User findUserByUserName(String userName) {\n        return database.findUserByUserName(userName);\n    }\n\n    public int getUserCount() {\n        return database.getUserCount();\n    }\n\n}\n```\nServer\n```\nclass UserServiceServlet\n    extends HttpServlet {\n\n    private UserService userService;\n    private JsonRpcServer jsonRpcServer;\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) {\n        jsonRpcServer.handle(req, resp);\n    }\n\n    public void init(ServletConfig config) {\n        //this.userService = ...\n        this.jsonRpcServer = new JsonRpcServer(this.userService, UserService.class);\n    }\n\n}\n```\nClient\n```\nJsonRpcHttpClient client = new JsonRpcHttpClient(\n    new URL(\"http://example.com/UserService.json\"));\n\nUserService userService = ProxyUtil.createClientProxy(\n    getClass().getClassLoader(),\n    UserService.class,\n    client);\n\nUser user = userService.createUser(\"bob\", \"the builder\");\n```\n\n上面的例子只是最简单的访问方式，在分布式环境中，RPC还涉及到服务寻址，负载均衡等等问题。\n\n更加详细的RPC介绍，可以参考[RPC 是什么](http://blog.brucefeng.info/post/what-is-rpc)\n\n### 为什么是RPC\n\n在网上查看RPC资料的时候，就想到一个问题，既然RPC这么复杂，为什么不使用HTTP接口调用的方式来进行网络通信呢？以前做一些小demo的时候使用HttpClient就完全OK了。\n\n看到一个很有意思的讨论：[为什么需要RPC，而不是简单的HTTP接口](https://www.oschina.net/question/271044_2155059)\n\nRPC调用简单，适用于业务逻辑比较复杂的情况，比如分布式环境当中。RPC强调透明调用,也利于解耦。\n\n### 原理\n\n[QiuRPC](https://github.com/i1see1you/QiuRPC)：一个通用的网络RPC框架\n\n[你应该知道的 RPC 原理](http://blog.jobbole.com/92290/)\n\n## [SOAP](https://zh.wikipedia.org/wiki/SOAP)\n\nXML-RPC只能使用有限的数据类型种类和一些简单的数据结构。于是就出现了SOAP(Simple Object Access Protocol)。\n\nSOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。\n\n事实上SOAP数据使用XML数据格式，定义了一整套复杂的标签，以描述调用的远程过程、参数、返回值和出错信息等等。而且随着需要的增长，又不得增加协议以支持安全性，这使SOAP变得异常庞大，背离了简单的初衷。另一方面，各个服务器都可以基于这个协议推出自己的API，即使它们提供的服务及其相似，定义的API也不尽相同，这又导致了WSDL的诞生。\n\nWSDL (Web Service Description Language) 也遵循XML格式，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，简言之，服务发现。\n\n现在，使用Web Service的过程变成，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。\n\n[Working Soap client example](http://stackoverflow.com/questions/15948927/working-soap-client-example)\n\n[SOAP Messaging Models and Examples](https://docs.oracle.com/cd/E19340-01/820-6767/aeqfx/index.html)\n\n通过soap demo体会soap与rpc的区别\n\n## [RMI](https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8)\n\nRMI其实也属于RPC的一种，是面向对象的。RMI只能在java里玩，不支持跨语言。与RPC不同的是，RMI可以返回java对象以及基本的数据类型，RPC不允许返回对象，RPC服务的信息由外部数据表示。RMI的优势在于依靠Java序列化机制，对开发人员屏蔽了数据编排和解排的细节，要做的事情非常少。\n\n用代码说话：\n\nRMI采用的是典型的客户端-服务器端架构。首先需要定义的是服务器端的远程接口，这一步是设计好服务器端需要提供什么样的服务。对远程接口的要求很简单，只需要继承自RMI中的Remote接口即可。Remote和Serializable一样，也是标记接口。远程接口中的方法需要抛出RemoteException。定义好远程接口之后，实现该接口即可。如下面的Calculator是一个简单的远程接口。\n```\npublic interface Calculator extends Remote {\n    String calculate(String expr) throws RemoteException;\n}  \n```\n实现了远程接口的类的实例称为远程对象。创建出远程对象之后，需要把它注册到一个注册表之中。这是为了客户端能够找到该远程对象并调用。\n```\npublic class CalculatorServer implements Calculator {\n    public String calculate(String expr) throws RemoteException {\n        return expr;\n    }\n    public void start() throws RemoteException, AlreadyBoundException {\n        Calculator stub = (Calculator) UnicastRemoteObject.exportObject(this, 0);\n        Registry registry = LocateRegistry.getRegistry();\n        registry.rebind(\"Calculator\", stub);\n    }\n}\n```\nCalculatorServer是远程对象的Java类。在它的start方法中通过UnicastRemoteObject的exportObject把当前对象暴露出来，使得它可以接收来自客户端的调用请求。再通过Registry的rebind方法进行注册，使得客户端可以查找到。\n\n客户端的实现就是首先从注册表中查找到远程接口的实现对象，再调用相应的方法即可。实际的调用虽然是在服务器端完成的，但是在客户端看来，这个接口中的方法就好像是在当前JVM中一样。这就是RMI的强大之处。\n```\npublic class CalculatorClient {\n    public void calculate(String expr) {\n        try {\n            Registry registry = LocateRegistry.getRegistry(\"localhost\");\n            Calculator calculator = (Calculator) registry.lookup(\"Calculator\");\n            String result = calculator.calculate(expr);\n            System.out.println(result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n} \n```\n在运行的时候，需要首先通过rmiregistry命令来启动RMI中用到的注册表服务器。\n\n为了通过Java的序列化机制来进行传输，远程接口中的方法的参数和返回值，要么是Java的基本类型，要么是远程对象，要么是实现了 Serializable接口的Java类。当客户端通过RMI注册表找到一个远程接口的时候，所得到的其实是远程接口的一个动态代理对象。当客户端调用其中的方法的时候，方法的参数对象会在序列化之后，传输到服务器端。服务器端接收到之后，进行反序列化得到参数对象。并使用这些参数对象，在服务器端调用实际的方法。调用的返回值Java对象经过序列化之后，再发送回客户端。客户端再经过反序列化之后得到Java对象，返回给调用者。这中间的序列化过程对于使用者来说是透明的，由动态代理对象自动完成。除了序列化之外，RMI还使用了动态类加载技术。当需要进行反序列化的时候，如果该对象的类定义在当前JVM中没有找到，RMI会尝试从远端下载所需的类文件定义。可以在RMI程序启动的时候，通过JVM参数java.rmi.server.codebase来指定动态下载Java类文件的URL。  \n\n## [REST](https://zh.wikipedia.org/wiki/REST)\n\nREST只是一种软件架构的风格，而不是一种协议或者其他。\n\nREST基于HTTP协议，一般使用JSON传输数据。REST是面向资源的，资源由URI来表示。\n\n以下解释参考自[理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n---\n要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。\n\n资源（Resources）\n\nREST的名称\"表现层状态转化\"中，省略了主语。\"表现层\"其实指的是\"资源\"（Resources）的\"表现层\"。\n\n所谓\"资源\"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。\n\n所谓\"上网\"，就是与互联网上一系列的\"资源\"互动，调用它的URI。\n\n表现层（Representation）\n\n\"资源\"是一种信息实体，它可以有多种外在表现形式。我们把\"资源\"具体呈现出来的形式，叫做它的\"表现层\"（Representation）。\n\n比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。\n\nURI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的\".html\"后缀名是不必要的，因为这个后缀名表示格式，属于\"表现层\"范畴，而URI应该只代表\"资源\"的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对\"表现层\"的描述。\n\n状态转化（State Transfer）\n\n访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。\n\n互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\"状态转化\"（State Transfer）。而这种转化是建立在表现层之上的，所以就是\"表现层状态转化\"。\n\n客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。\n\n综述\n\n综合上面的解释，我们总结一下什么是RESTful架构：\n（1）每一个URI代表一种资源；\n（2）客户端和服务器之间，传递这种资源的某种表现层；\n（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现\"表现层状态转化\"。\n\n---\n\n参考[RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)设计Rest API\n\ngithub的API设计就是REST风格的。\n\n网上关于REST和PRC的争论有很多,总的来说有以下几个：\n\n安全性上：SOAP安全性高于REST\n\n成熟度上：SOAP在成熟度上优于REST\n\n效率和易用性上：REST更胜一筹\n\n## 参考\n\n[你应该知道的 RPC 原理](http://blog.jobbole.com/92290/)\n\n[RPC 是什么](http://blog.brucefeng.info/post/what-is-rpc)\n\n[Web service是什么？](http://www.ruanyifeng.com/blog/2009/08/what_is_web_service.html)\n\n[Java深度历险（十）——Java对象序列化与RMI](http://www.infoq.com/cn/articles/cf-java-object-serialization-rmi)","source":"_posts/webservice相关.md","raw":"---\nlayout: post\ntitle: webservice相关\ndate: 2017-03-15 11:22:45\ncategories: 技术\ntags: web\n---\n> 上周最后三天去北京培训了Hadoop，了解了一些目前流行的分布式组件。在谈到这些组件的交互过程中，经常会提到RPC，webservice等关键词，所以简单了解了一下这些关键词的含义~\n\n## [WebService](https://zh.wikipedia.org/wiki/Web_services)\n\nwebservice，拆开来看就是 web（网络）和service（服务），先了解一下什么是服务：\n\n计算机的后台进程提供了某种功能，我们把提供了这种功能的进程称为守护进程（Daemon），提供的功能称为服务。比如，我们启动了数据库，数据库进程就会一直运行在后台监听连接数据库的动作，这种监听连接的功能就是一种服务。\n\n服务分为本地服务和网络服务。使用同一台机器上提供的服务就是本地服务，通过网络连接到另一台计算机使用它提供的服务就是网络服务。\n\n所以，webservice 就是通过网络使用了其他服务器提供的某种功能或获取了某些资源。\n\n这样一来，webservice就很常见了。比如我们做了一个显示天气情况的app，使用了百度地图提供的定位功能，使用了其他服务商提供的天气数据，这些都属于webservice。\n\nwebservice可以包含以下几个实现：\n\nRPC：面向过程\n\nRMI：面向对象\n\nREST：面向资源\n\n[Web Service tutorial](http://www.java2blog.com/2013/03/web-service-tutorial.html)\n\n<!-- more -->\n\n## [RPC](https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8)\n\n### 概念\n\n> 远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。\n该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。\n如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。\n\n上面的解释摘自维基百科\n\nRPC属于webservice的一种，就是在一个进程中调用另一个进程中的服务。就像调用本地方法一样调用远程服务器的方法。\n\nRPC有很多实现，包括XML-RPC、JSON-RPC、JAX-RPC等等。\n\n一次RPC调用过程就是向服务器发送一个过程调用的方法和参数，得到服务器返回的方法执行结果。RPC的本质就是一次远程调用，但更强调透明调用。RPC是跨语言的。\n\n### 使用\n\n以[Json-Rpc](http://www.jsonrpc.org) 为例，看一下RPC是如何工作的：\n\n使用java中的json-rpc实现[jsonrpc4j](https://github.com/briandilley/jsonrpc4j)：（也有其他语言的实现）\n\nCreate your service interface:\n```\npackage com.mycompany;\npublic interface UserService {\n    User createUser(String userName, String firstName, String password);\n    User createUser(String userName, String password);\n    User findUserByUserName(String userName);\n    int getUserCount();\n}\n```\nImplement it:\n```\npackage com.mycompany;\npublic class UserServiceImpl\n    implements UserService {\n\n    public User createUser(String userName, String firstName, String password) {\n        User user = new User();\n        user.setUserName(userName);\n        user.setFirstName(firstName);\n        user.setPassword(password);\n        database.saveUser(user)\n        return user;\n    }\n\n    public User createUser(String userName, String password) {\n        return this.createUser(userName, null, password);\n    }\n\n    public User findUserByUserName(String userName) {\n        return database.findUserByUserName(userName);\n    }\n\n    public int getUserCount() {\n        return database.getUserCount();\n    }\n\n}\n```\nServer\n```\nclass UserServiceServlet\n    extends HttpServlet {\n\n    private UserService userService;\n    private JsonRpcServer jsonRpcServer;\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) {\n        jsonRpcServer.handle(req, resp);\n    }\n\n    public void init(ServletConfig config) {\n        //this.userService = ...\n        this.jsonRpcServer = new JsonRpcServer(this.userService, UserService.class);\n    }\n\n}\n```\nClient\n```\nJsonRpcHttpClient client = new JsonRpcHttpClient(\n    new URL(\"http://example.com/UserService.json\"));\n\nUserService userService = ProxyUtil.createClientProxy(\n    getClass().getClassLoader(),\n    UserService.class,\n    client);\n\nUser user = userService.createUser(\"bob\", \"the builder\");\n```\n\n上面的例子只是最简单的访问方式，在分布式环境中，RPC还涉及到服务寻址，负载均衡等等问题。\n\n更加详细的RPC介绍，可以参考[RPC 是什么](http://blog.brucefeng.info/post/what-is-rpc)\n\n### 为什么是RPC\n\n在网上查看RPC资料的时候，就想到一个问题，既然RPC这么复杂，为什么不使用HTTP接口调用的方式来进行网络通信呢？以前做一些小demo的时候使用HttpClient就完全OK了。\n\n看到一个很有意思的讨论：[为什么需要RPC，而不是简单的HTTP接口](https://www.oschina.net/question/271044_2155059)\n\nRPC调用简单，适用于业务逻辑比较复杂的情况，比如分布式环境当中。RPC强调透明调用,也利于解耦。\n\n### 原理\n\n[QiuRPC](https://github.com/i1see1you/QiuRPC)：一个通用的网络RPC框架\n\n[你应该知道的 RPC 原理](http://blog.jobbole.com/92290/)\n\n## [SOAP](https://zh.wikipedia.org/wiki/SOAP)\n\nXML-RPC只能使用有限的数据类型种类和一些简单的数据结构。于是就出现了SOAP(Simple Object Access Protocol)。\n\nSOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。\n\n事实上SOAP数据使用XML数据格式，定义了一整套复杂的标签，以描述调用的远程过程、参数、返回值和出错信息等等。而且随着需要的增长，又不得增加协议以支持安全性，这使SOAP变得异常庞大，背离了简单的初衷。另一方面，各个服务器都可以基于这个协议推出自己的API，即使它们提供的服务及其相似，定义的API也不尽相同，这又导致了WSDL的诞生。\n\nWSDL (Web Service Description Language) 也遵循XML格式，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，简言之，服务发现。\n\n现在，使用Web Service的过程变成，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。\n\n[Working Soap client example](http://stackoverflow.com/questions/15948927/working-soap-client-example)\n\n[SOAP Messaging Models and Examples](https://docs.oracle.com/cd/E19340-01/820-6767/aeqfx/index.html)\n\n通过soap demo体会soap与rpc的区别\n\n## [RMI](https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8)\n\nRMI其实也属于RPC的一种，是面向对象的。RMI只能在java里玩，不支持跨语言。与RPC不同的是，RMI可以返回java对象以及基本的数据类型，RPC不允许返回对象，RPC服务的信息由外部数据表示。RMI的优势在于依靠Java序列化机制，对开发人员屏蔽了数据编排和解排的细节，要做的事情非常少。\n\n用代码说话：\n\nRMI采用的是典型的客户端-服务器端架构。首先需要定义的是服务器端的远程接口，这一步是设计好服务器端需要提供什么样的服务。对远程接口的要求很简单，只需要继承自RMI中的Remote接口即可。Remote和Serializable一样，也是标记接口。远程接口中的方法需要抛出RemoteException。定义好远程接口之后，实现该接口即可。如下面的Calculator是一个简单的远程接口。\n```\npublic interface Calculator extends Remote {\n    String calculate(String expr) throws RemoteException;\n}  \n```\n实现了远程接口的类的实例称为远程对象。创建出远程对象之后，需要把它注册到一个注册表之中。这是为了客户端能够找到该远程对象并调用。\n```\npublic class CalculatorServer implements Calculator {\n    public String calculate(String expr) throws RemoteException {\n        return expr;\n    }\n    public void start() throws RemoteException, AlreadyBoundException {\n        Calculator stub = (Calculator) UnicastRemoteObject.exportObject(this, 0);\n        Registry registry = LocateRegistry.getRegistry();\n        registry.rebind(\"Calculator\", stub);\n    }\n}\n```\nCalculatorServer是远程对象的Java类。在它的start方法中通过UnicastRemoteObject的exportObject把当前对象暴露出来，使得它可以接收来自客户端的调用请求。再通过Registry的rebind方法进行注册，使得客户端可以查找到。\n\n客户端的实现就是首先从注册表中查找到远程接口的实现对象，再调用相应的方法即可。实际的调用虽然是在服务器端完成的，但是在客户端看来，这个接口中的方法就好像是在当前JVM中一样。这就是RMI的强大之处。\n```\npublic class CalculatorClient {\n    public void calculate(String expr) {\n        try {\n            Registry registry = LocateRegistry.getRegistry(\"localhost\");\n            Calculator calculator = (Calculator) registry.lookup(\"Calculator\");\n            String result = calculator.calculate(expr);\n            System.out.println(result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n} \n```\n在运行的时候，需要首先通过rmiregistry命令来启动RMI中用到的注册表服务器。\n\n为了通过Java的序列化机制来进行传输，远程接口中的方法的参数和返回值，要么是Java的基本类型，要么是远程对象，要么是实现了 Serializable接口的Java类。当客户端通过RMI注册表找到一个远程接口的时候，所得到的其实是远程接口的一个动态代理对象。当客户端调用其中的方法的时候，方法的参数对象会在序列化之后，传输到服务器端。服务器端接收到之后，进行反序列化得到参数对象。并使用这些参数对象，在服务器端调用实际的方法。调用的返回值Java对象经过序列化之后，再发送回客户端。客户端再经过反序列化之后得到Java对象，返回给调用者。这中间的序列化过程对于使用者来说是透明的，由动态代理对象自动完成。除了序列化之外，RMI还使用了动态类加载技术。当需要进行反序列化的时候，如果该对象的类定义在当前JVM中没有找到，RMI会尝试从远端下载所需的类文件定义。可以在RMI程序启动的时候，通过JVM参数java.rmi.server.codebase来指定动态下载Java类文件的URL。  \n\n## [REST](https://zh.wikipedia.org/wiki/REST)\n\nREST只是一种软件架构的风格，而不是一种协议或者其他。\n\nREST基于HTTP协议，一般使用JSON传输数据。REST是面向资源的，资源由URI来表示。\n\n以下解释参考自[理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n---\n要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。\n\n资源（Resources）\n\nREST的名称\"表现层状态转化\"中，省略了主语。\"表现层\"其实指的是\"资源\"（Resources）的\"表现层\"。\n\n所谓\"资源\"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。\n\n所谓\"上网\"，就是与互联网上一系列的\"资源\"互动，调用它的URI。\n\n表现层（Representation）\n\n\"资源\"是一种信息实体，它可以有多种外在表现形式。我们把\"资源\"具体呈现出来的形式，叫做它的\"表现层\"（Representation）。\n\n比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。\n\nURI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的\".html\"后缀名是不必要的，因为这个后缀名表示格式，属于\"表现层\"范畴，而URI应该只代表\"资源\"的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对\"表现层\"的描述。\n\n状态转化（State Transfer）\n\n访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。\n\n互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\"状态转化\"（State Transfer）。而这种转化是建立在表现层之上的，所以就是\"表现层状态转化\"。\n\n客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。\n\n综述\n\n综合上面的解释，我们总结一下什么是RESTful架构：\n（1）每一个URI代表一种资源；\n（2）客户端和服务器之间，传递这种资源的某种表现层；\n（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现\"表现层状态转化\"。\n\n---\n\n参考[RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)设计Rest API\n\ngithub的API设计就是REST风格的。\n\n网上关于REST和PRC的争论有很多,总的来说有以下几个：\n\n安全性上：SOAP安全性高于REST\n\n成熟度上：SOAP在成熟度上优于REST\n\n效率和易用性上：REST更胜一筹\n\n## 参考\n\n[你应该知道的 RPC 原理](http://blog.jobbole.com/92290/)\n\n[RPC 是什么](http://blog.brucefeng.info/post/what-is-rpc)\n\n[Web service是什么？](http://www.ruanyifeng.com/blog/2009/08/what_is_web_service.html)\n\n[Java深度历险（十）——Java对象序列化与RMI](http://www.infoq.com/cn/articles/cf-java-object-serialization-rmi)","slug":"webservice相关","published":1,"updated":"2017-04-11T13:08:38.850Z","comments":1,"photos":[],"link":"","_id":"cj4vch4gs004cx3gc7ixx0uzn","content":"<blockquote>\n<p>上周最后三天去北京培训了Hadoop，了解了一些目前流行的分布式组件。在谈到这些组件的交互过程中，经常会提到RPC，webservice等关键词，所以简单了解了一下这些关键词的含义~</p>\n</blockquote>\n<h2 id=\"WebService\"><a href=\"#WebService\" class=\"headerlink\" title=\"WebService\"></a><a href=\"https://zh.wikipedia.org/wiki/Web_services\" target=\"_blank\" rel=\"external\">WebService</a></h2><p>webservice，拆开来看就是 web（网络）和service（服务），先了解一下什么是服务：</p>\n<p>计算机的后台进程提供了某种功能，我们把提供了这种功能的进程称为守护进程（Daemon），提供的功能称为服务。比如，我们启动了数据库，数据库进程就会一直运行在后台监听连接数据库的动作，这种监听连接的功能就是一种服务。</p>\n<p>服务分为本地服务和网络服务。使用同一台机器上提供的服务就是本地服务，通过网络连接到另一台计算机使用它提供的服务就是网络服务。</p>\n<p>所以，webservice 就是通过网络使用了其他服务器提供的某种功能或获取了某些资源。</p>\n<p>这样一来，webservice就很常见了。比如我们做了一个显示天气情况的app，使用了百度地图提供的定位功能，使用了其他服务商提供的天气数据，这些都属于webservice。</p>\n<p>webservice可以包含以下几个实现：</p>\n<p>RPC：面向过程</p>\n<p>RMI：面向对象</p>\n<p>REST：面向资源</p>\n<p><a href=\"http://www.java2blog.com/2013/03/web-service-tutorial.html\" target=\"_blank\" rel=\"external\">Web Service tutorial</a></p>\n<a id=\"more\"></a>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a><a href=\"https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8\" target=\"_blank\" rel=\"external\">RPC</a></h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。<br>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。<br>如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。</p>\n</blockquote>\n<p>上面的解释摘自维基百科</p>\n<p>RPC属于webservice的一种，就是在一个进程中调用另一个进程中的服务。就像调用本地方法一样调用远程服务器的方法。</p>\n<p>RPC有很多实现，包括XML-RPC、JSON-RPC、JAX-RPC等等。</p>\n<p>一次RPC调用过程就是向服务器发送一个过程调用的方法和参数，得到服务器返回的方法执行结果。RPC的本质就是一次远程调用，但更强调透明调用。RPC是跨语言的。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>以<a href=\"http://www.jsonrpc.org\" target=\"_blank\" rel=\"external\">Json-Rpc</a> 为例，看一下RPC是如何工作的：</p>\n<p>使用java中的json-rpc实现<a href=\"https://github.com/briandilley/jsonrpc4j\" target=\"_blank\" rel=\"external\">jsonrpc4j</a>：（也有其他语言的实现）</p>\n<p>Create your service interface:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.mycompany;</div><div class=\"line\">public interface UserService &#123;</div><div class=\"line\">    User createUser(String userName, String firstName, String password);</div><div class=\"line\">    User createUser(String userName, String password);</div><div class=\"line\">    User findUserByUserName(String userName);</div><div class=\"line\">    int getUserCount();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Implement it:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.mycompany;</div><div class=\"line\">public class UserServiceImpl</div><div class=\"line\">    implements UserService &#123;</div><div class=\"line\"></div><div class=\"line\">    public User createUser(String userName, String firstName, String password) &#123;</div><div class=\"line\">        User user = new User();</div><div class=\"line\">        user.setUserName(userName);</div><div class=\"line\">        user.setFirstName(firstName);</div><div class=\"line\">        user.setPassword(password);</div><div class=\"line\">        database.saveUser(user)</div><div class=\"line\">        return user;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public User createUser(String userName, String password) &#123;</div><div class=\"line\">        return this.createUser(userName, null, password);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public User findUserByUserName(String userName) &#123;</div><div class=\"line\">        return database.findUserByUserName(userName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public int getUserCount() &#123;</div><div class=\"line\">        return database.getUserCount();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Server<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class UserServiceServlet</div><div class=\"line\">    extends HttpServlet &#123;</div><div class=\"line\"></div><div class=\"line\">    private UserService userService;</div><div class=\"line\">    private JsonRpcServer jsonRpcServer;</div><div class=\"line\"></div><div class=\"line\">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) &#123;</div><div class=\"line\">        jsonRpcServer.handle(req, resp);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void init(ServletConfig config) &#123;</div><div class=\"line\">        //this.userService = ...</div><div class=\"line\">        this.jsonRpcServer = new JsonRpcServer(this.userService, UserService.class);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Client<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">JsonRpcHttpClient client = new JsonRpcHttpClient(</div><div class=\"line\">    new URL(&quot;http://example.com/UserService.json&quot;));</div><div class=\"line\"></div><div class=\"line\">UserService userService = ProxyUtil.createClientProxy(</div><div class=\"line\">    getClass().getClassLoader(),</div><div class=\"line\">    UserService.class,</div><div class=\"line\">    client);</div><div class=\"line\"></div><div class=\"line\">User user = userService.createUser(&quot;bob&quot;, &quot;the builder&quot;);</div></pre></td></tr></table></figure></p>\n<p>上面的例子只是最简单的访问方式，在分布式环境中，RPC还涉及到服务寻址，负载均衡等等问题。</p>\n<p>更加详细的RPC介绍，可以参考<a href=\"http://blog.brucefeng.info/post/what-is-rpc\" target=\"_blank\" rel=\"external\">RPC 是什么</a></p>\n<h3 id=\"为什么是RPC\"><a href=\"#为什么是RPC\" class=\"headerlink\" title=\"为什么是RPC\"></a>为什么是RPC</h3><p>在网上查看RPC资料的时候，就想到一个问题，既然RPC这么复杂，为什么不使用HTTP接口调用的方式来进行网络通信呢？以前做一些小demo的时候使用HttpClient就完全OK了。</p>\n<p>看到一个很有意思的讨论：<a href=\"https://www.oschina.net/question/271044_2155059\" target=\"_blank\" rel=\"external\">为什么需要RPC，而不是简单的HTTP接口</a></p>\n<p>RPC调用简单，适用于业务逻辑比较复杂的情况，比如分布式环境当中。RPC强调透明调用,也利于解耦。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><a href=\"https://github.com/i1see1you/QiuRPC\" target=\"_blank\" rel=\"external\">QiuRPC</a>：一个通用的网络RPC框架</p>\n<p><a href=\"http://blog.jobbole.com/92290/\" target=\"_blank\" rel=\"external\">你应该知道的 RPC 原理</a></p>\n<h2 id=\"SOAP\"><a href=\"#SOAP\" class=\"headerlink\" title=\"SOAP\"></a><a href=\"https://zh.wikipedia.org/wiki/SOAP\" target=\"_blank\" rel=\"external\">SOAP</a></h2><p>XML-RPC只能使用有限的数据类型种类和一些简单的数据结构。于是就出现了SOAP(Simple Object Access Protocol)。</p>\n<p>SOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。</p>\n<p>事实上SOAP数据使用XML数据格式，定义了一整套复杂的标签，以描述调用的远程过程、参数、返回值和出错信息等等。而且随着需要的增长，又不得增加协议以支持安全性，这使SOAP变得异常庞大，背离了简单的初衷。另一方面，各个服务器都可以基于这个协议推出自己的API，即使它们提供的服务及其相似，定义的API也不尽相同，这又导致了WSDL的诞生。</p>\n<p>WSDL (Web Service Description Language) 也遵循XML格式，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，简言之，服务发现。</p>\n<p>现在，使用Web Service的过程变成，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。</p>\n<p><a href=\"http://stackoverflow.com/questions/15948927/working-soap-client-example\" target=\"_blank\" rel=\"external\">Working Soap client example</a></p>\n<p><a href=\"https://docs.oracle.com/cd/E19340-01/820-6767/aeqfx/index.html\" target=\"_blank\" rel=\"external\">SOAP Messaging Models and Examples</a></p>\n<p>通过soap demo体会soap与rpc的区别</p>\n<h2 id=\"RMI\"><a href=\"#RMI\" class=\"headerlink\" title=\"RMI\"></a><a href=\"https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8\" target=\"_blank\" rel=\"external\">RMI</a></h2><p>RMI其实也属于RPC的一种，是面向对象的。RMI只能在java里玩，不支持跨语言。与RPC不同的是，RMI可以返回java对象以及基本的数据类型，RPC不允许返回对象，RPC服务的信息由外部数据表示。RMI的优势在于依靠Java序列化机制，对开发人员屏蔽了数据编排和解排的细节，要做的事情非常少。</p>\n<p>用代码说话：</p>\n<p>RMI采用的是典型的客户端-服务器端架构。首先需要定义的是服务器端的远程接口，这一步是设计好服务器端需要提供什么样的服务。对远程接口的要求很简单，只需要继承自RMI中的Remote接口即可。Remote和Serializable一样，也是标记接口。远程接口中的方法需要抛出RemoteException。定义好远程接口之后，实现该接口即可。如下面的Calculator是一个简单的远程接口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Calculator extends Remote &#123;</div><div class=\"line\">    String calculate(String expr) throws RemoteException;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实现了远程接口的类的实例称为远程对象。创建出远程对象之后，需要把它注册到一个注册表之中。这是为了客户端能够找到该远程对象并调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CalculatorServer implements Calculator &#123;</div><div class=\"line\">    public String calculate(String expr) throws RemoteException &#123;</div><div class=\"line\">        return expr;</div><div class=\"line\">    &#125;</div><div class=\"line\">    public void start() throws RemoteException, AlreadyBoundException &#123;</div><div class=\"line\">        Calculator stub = (Calculator) UnicastRemoteObject.exportObject(this, 0);</div><div class=\"line\">        Registry registry = LocateRegistry.getRegistry();</div><div class=\"line\">        registry.rebind(&quot;Calculator&quot;, stub);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>CalculatorServer是远程对象的Java类。在它的start方法中通过UnicastRemoteObject的exportObject把当前对象暴露出来，使得它可以接收来自客户端的调用请求。再通过Registry的rebind方法进行注册，使得客户端可以查找到。</p>\n<p>客户端的实现就是首先从注册表中查找到远程接口的实现对象，再调用相应的方法即可。实际的调用虽然是在服务器端完成的，但是在客户端看来，这个接口中的方法就好像是在当前JVM中一样。这就是RMI的强大之处。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CalculatorClient &#123;</div><div class=\"line\">    public void calculate(String expr) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;);</div><div class=\"line\">            Calculator calculator = (Calculator) registry.lookup(&quot;Calculator&quot;);</div><div class=\"line\">            String result = calculator.calculate(expr);</div><div class=\"line\">            System.out.println(result);</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在运行的时候，需要首先通过rmiregistry命令来启动RMI中用到的注册表服务器。</p>\n<p>为了通过Java的序列化机制来进行传输，远程接口中的方法的参数和返回值，要么是Java的基本类型，要么是远程对象，要么是实现了 Serializable接口的Java类。当客户端通过RMI注册表找到一个远程接口的时候，所得到的其实是远程接口的一个动态代理对象。当客户端调用其中的方法的时候，方法的参数对象会在序列化之后，传输到服务器端。服务器端接收到之后，进行反序列化得到参数对象。并使用这些参数对象，在服务器端调用实际的方法。调用的返回值Java对象经过序列化之后，再发送回客户端。客户端再经过反序列化之后得到Java对象，返回给调用者。这中间的序列化过程对于使用者来说是透明的，由动态代理对象自动完成。除了序列化之外，RMI还使用了动态类加载技术。当需要进行反序列化的时候，如果该对象的类定义在当前JVM中没有找到，RMI会尝试从远端下载所需的类文件定义。可以在RMI程序启动的时候，通过JVM参数java.rmi.server.codebase来指定动态下载Java类文件的URL。  </p>\n<h2 id=\"REST\"><a href=\"#REST\" class=\"headerlink\" title=\"REST\"></a><a href=\"https://zh.wikipedia.org/wiki/REST\" target=\"_blank\" rel=\"external\">REST</a></h2><p>REST只是一种软件架构的风格，而不是一种协议或者其他。</p>\n<p>REST基于HTTP协议，一般使用JSON传输数据。REST是面向资源的，资源由URI来表示。</p>\n<p>以下解释参考自<a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"external\">理解RESTful架构</a></p>\n<hr>\n<p>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p>\n<p>资源（Resources）</p>\n<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>\n<p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>\n<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p>\n<p>表现层（Representation）</p>\n<p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p>\n<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>\n<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>\n<p>状态转化（State Transfer）</p>\n<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>\n<p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>\n<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>\n<p>综述</p>\n<p>综合上面的解释，我们总结一下什么是RESTful架构：<br>（1）每一个URI代表一种资源；<br>（2）客户端和服务器之间，传递这种资源的某种表现层；<br>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>\n<hr>\n<p>参考<a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"external\">RESTful API 设计指南</a>设计Rest API</p>\n<p>github的API设计就是REST风格的。</p>\n<p>网上关于REST和PRC的争论有很多,总的来说有以下几个：</p>\n<p>安全性上：SOAP安全性高于REST</p>\n<p>成熟度上：SOAP在成熟度上优于REST</p>\n<p>效率和易用性上：REST更胜一筹</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.jobbole.com/92290/\" target=\"_blank\" rel=\"external\">你应该知道的 RPC 原理</a></p>\n<p><a href=\"http://blog.brucefeng.info/post/what-is-rpc\" target=\"_blank\" rel=\"external\">RPC 是什么</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2009/08/what_is_web_service.html\" target=\"_blank\" rel=\"external\">Web service是什么？</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/cf-java-object-serialization-rmi\" target=\"_blank\" rel=\"external\">Java深度历险（十）——Java对象序列化与RMI</a></p>\n","excerpt":"<blockquote>\n<p>上周最后三天去北京培训了Hadoop，了解了一些目前流行的分布式组件。在谈到这些组件的交互过程中，经常会提到RPC，webservice等关键词，所以简单了解了一下这些关键词的含义~</p>\n</blockquote>\n<h2 id=\"WebService\"><a href=\"#WebService\" class=\"headerlink\" title=\"WebService\"></a><a href=\"https://zh.wikipedia.org/wiki/Web_services\">WebService</a></h2><p>webservice，拆开来看就是 web（网络）和service（服务），先了解一下什么是服务：</p>\n<p>计算机的后台进程提供了某种功能，我们把提供了这种功能的进程称为守护进程（Daemon），提供的功能称为服务。比如，我们启动了数据库，数据库进程就会一直运行在后台监听连接数据库的动作，这种监听连接的功能就是一种服务。</p>\n<p>服务分为本地服务和网络服务。使用同一台机器上提供的服务就是本地服务，通过网络连接到另一台计算机使用它提供的服务就是网络服务。</p>\n<p>所以，webservice 就是通过网络使用了其他服务器提供的某种功能或获取了某些资源。</p>\n<p>这样一来，webservice就很常见了。比如我们做了一个显示天气情况的app，使用了百度地图提供的定位功能，使用了其他服务商提供的天气数据，这些都属于webservice。</p>\n<p>webservice可以包含以下几个实现：</p>\n<p>RPC：面向过程</p>\n<p>RMI：面向对象</p>\n<p>REST：面向资源</p>\n<p><a href=\"http://www.java2blog.com/2013/03/web-service-tutorial.html\">Web Service tutorial</a></p>","more":"<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a><a href=\"https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8\">RPC</a></h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。<br>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。<br>如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。</p>\n</blockquote>\n<p>上面的解释摘自维基百科</p>\n<p>RPC属于webservice的一种，就是在一个进程中调用另一个进程中的服务。就像调用本地方法一样调用远程服务器的方法。</p>\n<p>RPC有很多实现，包括XML-RPC、JSON-RPC、JAX-RPC等等。</p>\n<p>一次RPC调用过程就是向服务器发送一个过程调用的方法和参数，得到服务器返回的方法执行结果。RPC的本质就是一次远程调用，但更强调透明调用。RPC是跨语言的。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>以<a href=\"http://www.jsonrpc.org\">Json-Rpc</a> 为例，看一下RPC是如何工作的：</p>\n<p>使用java中的json-rpc实现<a href=\"https://github.com/briandilley/jsonrpc4j\">jsonrpc4j</a>：（也有其他语言的实现）</p>\n<p>Create your service interface:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.mycompany;</div><div class=\"line\">public interface UserService &#123;</div><div class=\"line\">    User createUser(String userName, String firstName, String password);</div><div class=\"line\">    User createUser(String userName, String password);</div><div class=\"line\">    User findUserByUserName(String userName);</div><div class=\"line\">    int getUserCount();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Implement it:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.mycompany;</div><div class=\"line\">public class UserServiceImpl</div><div class=\"line\">    implements UserService &#123;</div><div class=\"line\"></div><div class=\"line\">    public User createUser(String userName, String firstName, String password) &#123;</div><div class=\"line\">        User user = new User();</div><div class=\"line\">        user.setUserName(userName);</div><div class=\"line\">        user.setFirstName(firstName);</div><div class=\"line\">        user.setPassword(password);</div><div class=\"line\">        database.saveUser(user)</div><div class=\"line\">        return user;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public User createUser(String userName, String password) &#123;</div><div class=\"line\">        return this.createUser(userName, null, password);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public User findUserByUserName(String userName) &#123;</div><div class=\"line\">        return database.findUserByUserName(userName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public int getUserCount() &#123;</div><div class=\"line\">        return database.getUserCount();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Server<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class UserServiceServlet</div><div class=\"line\">    extends HttpServlet &#123;</div><div class=\"line\"></div><div class=\"line\">    private UserService userService;</div><div class=\"line\">    private JsonRpcServer jsonRpcServer;</div><div class=\"line\"></div><div class=\"line\">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) &#123;</div><div class=\"line\">        jsonRpcServer.handle(req, resp);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void init(ServletConfig config) &#123;</div><div class=\"line\">        //this.userService = ...</div><div class=\"line\">        this.jsonRpcServer = new JsonRpcServer(this.userService, UserService.class);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Client<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">JsonRpcHttpClient client = new JsonRpcHttpClient(</div><div class=\"line\">    new URL(&quot;http://example.com/UserService.json&quot;));</div><div class=\"line\"></div><div class=\"line\">UserService userService = ProxyUtil.createClientProxy(</div><div class=\"line\">    getClass().getClassLoader(),</div><div class=\"line\">    UserService.class,</div><div class=\"line\">    client);</div><div class=\"line\"></div><div class=\"line\">User user = userService.createUser(&quot;bob&quot;, &quot;the builder&quot;);</div></pre></td></tr></table></figure></p>\n<p>上面的例子只是最简单的访问方式，在分布式环境中，RPC还涉及到服务寻址，负载均衡等等问题。</p>\n<p>更加详细的RPC介绍，可以参考<a href=\"http://blog.brucefeng.info/post/what-is-rpc\">RPC 是什么</a></p>\n<h3 id=\"为什么是RPC\"><a href=\"#为什么是RPC\" class=\"headerlink\" title=\"为什么是RPC\"></a>为什么是RPC</h3><p>在网上查看RPC资料的时候，就想到一个问题，既然RPC这么复杂，为什么不使用HTTP接口调用的方式来进行网络通信呢？以前做一些小demo的时候使用HttpClient就完全OK了。</p>\n<p>看到一个很有意思的讨论：<a href=\"https://www.oschina.net/question/271044_2155059\">为什么需要RPC，而不是简单的HTTP接口</a></p>\n<p>RPC调用简单，适用于业务逻辑比较复杂的情况，比如分布式环境当中。RPC强调透明调用,也利于解耦。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><a href=\"https://github.com/i1see1you/QiuRPC\">QiuRPC</a>：一个通用的网络RPC框架</p>\n<p><a href=\"http://blog.jobbole.com/92290/\">你应该知道的 RPC 原理</a></p>\n<h2 id=\"SOAP\"><a href=\"#SOAP\" class=\"headerlink\" title=\"SOAP\"></a><a href=\"https://zh.wikipedia.org/wiki/SOAP\">SOAP</a></h2><p>XML-RPC只能使用有限的数据类型种类和一些简单的数据结构。于是就出现了SOAP(Simple Object Access Protocol)。</p>\n<p>SOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。</p>\n<p>事实上SOAP数据使用XML数据格式，定义了一整套复杂的标签，以描述调用的远程过程、参数、返回值和出错信息等等。而且随着需要的增长，又不得增加协议以支持安全性，这使SOAP变得异常庞大，背离了简单的初衷。另一方面，各个服务器都可以基于这个协议推出自己的API，即使它们提供的服务及其相似，定义的API也不尽相同，这又导致了WSDL的诞生。</p>\n<p>WSDL (Web Service Description Language) 也遵循XML格式，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，简言之，服务发现。</p>\n<p>现在，使用Web Service的过程变成，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。</p>\n<p><a href=\"http://stackoverflow.com/questions/15948927/working-soap-client-example\">Working Soap client example</a></p>\n<p><a href=\"https://docs.oracle.com/cd/E19340-01/820-6767/aeqfx/index.html\">SOAP Messaging Models and Examples</a></p>\n<p>通过soap demo体会soap与rpc的区别</p>\n<h2 id=\"RMI\"><a href=\"#RMI\" class=\"headerlink\" title=\"RMI\"></a><a href=\"https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8\">RMI</a></h2><p>RMI其实也属于RPC的一种，是面向对象的。RMI只能在java里玩，不支持跨语言。与RPC不同的是，RMI可以返回java对象以及基本的数据类型，RPC不允许返回对象，RPC服务的信息由外部数据表示。RMI的优势在于依靠Java序列化机制，对开发人员屏蔽了数据编排和解排的细节，要做的事情非常少。</p>\n<p>用代码说话：</p>\n<p>RMI采用的是典型的客户端-服务器端架构。首先需要定义的是服务器端的远程接口，这一步是设计好服务器端需要提供什么样的服务。对远程接口的要求很简单，只需要继承自RMI中的Remote接口即可。Remote和Serializable一样，也是标记接口。远程接口中的方法需要抛出RemoteException。定义好远程接口之后，实现该接口即可。如下面的Calculator是一个简单的远程接口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Calculator extends Remote &#123;</div><div class=\"line\">    String calculate(String expr) throws RemoteException;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实现了远程接口的类的实例称为远程对象。创建出远程对象之后，需要把它注册到一个注册表之中。这是为了客户端能够找到该远程对象并调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CalculatorServer implements Calculator &#123;</div><div class=\"line\">    public String calculate(String expr) throws RemoteException &#123;</div><div class=\"line\">        return expr;</div><div class=\"line\">    &#125;</div><div class=\"line\">    public void start() throws RemoteException, AlreadyBoundException &#123;</div><div class=\"line\">        Calculator stub = (Calculator) UnicastRemoteObject.exportObject(this, 0);</div><div class=\"line\">        Registry registry = LocateRegistry.getRegistry();</div><div class=\"line\">        registry.rebind(&quot;Calculator&quot;, stub);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>CalculatorServer是远程对象的Java类。在它的start方法中通过UnicastRemoteObject的exportObject把当前对象暴露出来，使得它可以接收来自客户端的调用请求。再通过Registry的rebind方法进行注册，使得客户端可以查找到。</p>\n<p>客户端的实现就是首先从注册表中查找到远程接口的实现对象，再调用相应的方法即可。实际的调用虽然是在服务器端完成的，但是在客户端看来，这个接口中的方法就好像是在当前JVM中一样。这就是RMI的强大之处。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CalculatorClient &#123;</div><div class=\"line\">    public void calculate(String expr) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;);</div><div class=\"line\">            Calculator calculator = (Calculator) registry.lookup(&quot;Calculator&quot;);</div><div class=\"line\">            String result = calculator.calculate(expr);</div><div class=\"line\">            System.out.println(result);</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在运行的时候，需要首先通过rmiregistry命令来启动RMI中用到的注册表服务器。</p>\n<p>为了通过Java的序列化机制来进行传输，远程接口中的方法的参数和返回值，要么是Java的基本类型，要么是远程对象，要么是实现了 Serializable接口的Java类。当客户端通过RMI注册表找到一个远程接口的时候，所得到的其实是远程接口的一个动态代理对象。当客户端调用其中的方法的时候，方法的参数对象会在序列化之后，传输到服务器端。服务器端接收到之后，进行反序列化得到参数对象。并使用这些参数对象，在服务器端调用实际的方法。调用的返回值Java对象经过序列化之后，再发送回客户端。客户端再经过反序列化之后得到Java对象，返回给调用者。这中间的序列化过程对于使用者来说是透明的，由动态代理对象自动完成。除了序列化之外，RMI还使用了动态类加载技术。当需要进行反序列化的时候，如果该对象的类定义在当前JVM中没有找到，RMI会尝试从远端下载所需的类文件定义。可以在RMI程序启动的时候，通过JVM参数java.rmi.server.codebase来指定动态下载Java类文件的URL。  </p>\n<h2 id=\"REST\"><a href=\"#REST\" class=\"headerlink\" title=\"REST\"></a><a href=\"https://zh.wikipedia.org/wiki/REST\">REST</a></h2><p>REST只是一种软件架构的风格，而不是一种协议或者其他。</p>\n<p>REST基于HTTP协议，一般使用JSON传输数据。REST是面向资源的，资源由URI来表示。</p>\n<p>以下解释参考自<a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\">理解RESTful架构</a></p>\n<hr>\n<p>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p>\n<p>资源（Resources）</p>\n<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>\n<p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>\n<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p>\n<p>表现层（Representation）</p>\n<p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p>\n<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>\n<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>\n<p>状态转化（State Transfer）</p>\n<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>\n<p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>\n<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>\n<p>综述</p>\n<p>综合上面的解释，我们总结一下什么是RESTful架构：<br>（1）每一个URI代表一种资源；<br>（2）客户端和服务器之间，传递这种资源的某种表现层；<br>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>\n<hr>\n<p>参考<a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\">RESTful API 设计指南</a>设计Rest API</p>\n<p>github的API设计就是REST风格的。</p>\n<p>网上关于REST和PRC的争论有很多,总的来说有以下几个：</p>\n<p>安全性上：SOAP安全性高于REST</p>\n<p>成熟度上：SOAP在成熟度上优于REST</p>\n<p>效率和易用性上：REST更胜一筹</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.jobbole.com/92290/\">你应该知道的 RPC 原理</a></p>\n<p><a href=\"http://blog.brucefeng.info/post/what-is-rpc\">RPC 是什么</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2009/08/what_is_web_service.html\">Web service是什么？</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/cf-java-object-serialization-rmi\">Java深度历险（十）——Java对象序列化与RMI</a></p>"},{"layout":"post","date":"2016-07-31T09:30:55.000Z","title":"为什么是final","_content":"\n>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。\n\n注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。\n\n例子是这样的：\n\n```java\npublic class Outer {\n\tprivate int outerVar=0;\n\tpublic void testInner(final String paramVal){\n\t\tfinal Integer localVal = 1;\n\t\tInner inner = new Inner(){\n\t\t\t@Override\n\t\t\tpublic void doSomething() {\n\t\t\t\tSystem.out.println(localVal+paramVal);\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tfinal int localVal1 = 2;\n\t\tclass Inner2{\n\t\t\tpublic void testInner2(){\n\t\t\t\tSystem.out.println(localVal1);\n\t\t\t}\n\t\t}\n\t}\n\tinterface Inner{\n\t\tpublic void doSomething();\n\t}\n\tpublic static void main(String args[]){\n\t\tOuter outer = new Outer();\n\t\touter.testInner(\"hello\");\n\t}\n}\n```\n\n<!-- more -->\n\n可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。\n\n后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。\n\n我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）\n\n但是确实生成了这样几个.class文件：\n\nOuter.class:class Outer\n\nOuter$1.class:匿名内部类 new Inner(){...}\n\nOuter$1Inner2.class:class Inner2\n\nOuter$Inner.class:interface Inner\n\n这说明，匿名内部类与他的外围类之间确实是相互独立的。\n\n为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：\n\n```java\nclass kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner {\n  final java.lang.Integer val$localVar;\n\n  final java.lang.String val$paramVal;\n\n  final kyu.java.util.Outer this$0;\n\n  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);\n    Code:\n       0: aload_0\n       1: aload_1\n       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;\n       5: aload_0\n       6: aload_2\n       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;\n      10: aload_0\n      11: aload_3\n      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;\n      15: aload_0\n      16: invokespecial #4                  // Method java/lang/Object.\"<init>\":()V\n      19: return\n\n      .....\n }\n```\n\n上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参\n。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。\n\n所以，现在有两个问题：\n\n- **为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？**\n\n我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。\n\n- **局部变量或形参为什么必须是final类型？**\n\n在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。\n\n```java\nfinal Integer localVal = 1;\nInner inner = new Inner(){\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(localVar+paramVal);\n\t}\n};\n```\n\n这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。\n\nps:后来在stackoverflow上看到[Why are only final variables accessible in anonymous class?](http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class)，可以参考一下。","source":"_posts/为什么是final.md","raw":"---\nlayout: post\ndate:   2016-07-31 17:30:55\ntitle: \"为什么是final\"\ncategories: 编程\ntags: \n- java\n---\n\n>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。\n\n注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。\n\n例子是这样的：\n\n```java\npublic class Outer {\n\tprivate int outerVar=0;\n\tpublic void testInner(final String paramVal){\n\t\tfinal Integer localVal = 1;\n\t\tInner inner = new Inner(){\n\t\t\t@Override\n\t\t\tpublic void doSomething() {\n\t\t\t\tSystem.out.println(localVal+paramVal);\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tfinal int localVal1 = 2;\n\t\tclass Inner2{\n\t\t\tpublic void testInner2(){\n\t\t\t\tSystem.out.println(localVal1);\n\t\t\t}\n\t\t}\n\t}\n\tinterface Inner{\n\t\tpublic void doSomething();\n\t}\n\tpublic static void main(String args[]){\n\t\tOuter outer = new Outer();\n\t\touter.testInner(\"hello\");\n\t}\n}\n```\n\n<!-- more -->\n\n可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。\n\n后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。\n\n我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）\n\n但是确实生成了这样几个.class文件：\n\nOuter.class:class Outer\n\nOuter$1.class:匿名内部类 new Inner(){...}\n\nOuter$1Inner2.class:class Inner2\n\nOuter$Inner.class:interface Inner\n\n这说明，匿名内部类与他的外围类之间确实是相互独立的。\n\n为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：\n\n```java\nclass kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner {\n  final java.lang.Integer val$localVar;\n\n  final java.lang.String val$paramVal;\n\n  final kyu.java.util.Outer this$0;\n\n  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);\n    Code:\n       0: aload_0\n       1: aload_1\n       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;\n       5: aload_0\n       6: aload_2\n       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;\n      10: aload_0\n      11: aload_3\n      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;\n      15: aload_0\n      16: invokespecial #4                  // Method java/lang/Object.\"<init>\":()V\n      19: return\n\n      .....\n }\n```\n\n上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参\n。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。\n\n所以，现在有两个问题：\n\n- **为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？**\n\n我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。\n\n- **局部变量或形参为什么必须是final类型？**\n\n在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。\n\n```java\nfinal Integer localVal = 1;\nInner inner = new Inner(){\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(localVar+paramVal);\n\t}\n};\n```\n\n这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。\n\nps:后来在stackoverflow上看到[Why are only final variables accessible in anonymous class?](http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class)，可以参考一下。","slug":"为什么是final","published":1,"updated":"2017-04-11T13:08:38.850Z","comments":1,"photos":[],"link":"","_id":"cj4vch4gu004gx3gc9f3bbzvh","content":"<blockquote>\n<p>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。</p>\n</blockquote>\n<p>注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。</p>\n<p>例子是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> outerVar=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner</span><span class=\"params\">(<span class=\"keyword\">final</span> String paramVal)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">\t\tInner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal+paramVal);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localVal1 = <span class=\"number\">2</span>;</div><div class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner2</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal1);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Inner</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tOuter outer = <span class=\"keyword\">new</span> Outer();</div><div class=\"line\">\t\touter.testInner(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。</p>\n<p>后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。</p>\n<p>我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）</p>\n<p>但是确实生成了这样几个.class文件：</p>\n<p>Outer.class:class Outer</p>\n<p>Outer$1.class:匿名内部类 new Inner(){…}</p>\n<p>Outer$1Inner2.class:class Inner2</p>\n<p>Outer$Inner.class:interface Inner</p>\n<p>这说明，匿名内部类与他的外围类之间确实是相互独立的。</p>\n<p>为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner &#123;</div><div class=\"line\">  final java.lang.Integer val$localVar;</div><div class=\"line\"></div><div class=\"line\">  final java.lang.String val$paramVal;</div><div class=\"line\"></div><div class=\"line\">  final kyu.java.util.Outer this$0;</div><div class=\"line\"></div><div class=\"line\">  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);</div><div class=\"line\">    Code:</div><div class=\"line\">       0: aload_0</div><div class=\"line\">       1: aload_1</div><div class=\"line\">       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;</div><div class=\"line\">       5: aload_0</div><div class=\"line\">       6: aload_2</div><div class=\"line\">       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;</div><div class=\"line\">      10: aload_0</div><div class=\"line\">      11: aload_3</div><div class=\"line\">      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;</div><div class=\"line\">      15: aload_0</div><div class=\"line\">      16: invokespecial #4                  // Method java/lang/Object.\"&lt;init&gt;\":()V</div><div class=\"line\">      19: return</div><div class=\"line\"></div><div class=\"line\">      .....</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参<br>。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。</p>\n<p>所以，现在有两个问题：</p>\n<ul>\n<li><strong>为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？</strong></li>\n</ul>\n<p>我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。</p>\n<ul>\n<li><strong>局部变量或形参为什么必须是final类型？</strong></li>\n</ul>\n<p>在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">Inner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(localVar+paramVal);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。</p>\n<p>ps:后来在stackoverflow上看到<a href=\"http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class\" target=\"_blank\" rel=\"external\">Why are only final variables accessible in anonymous class?</a>，可以参考一下。</p>\n","excerpt":"<blockquote>\n<p>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。</p>\n</blockquote>\n<p>注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。</p>\n<p>例子是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> outerVar=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner</span><span class=\"params\">(<span class=\"keyword\">final</span> String paramVal)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">\t\tInner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal+paramVal);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localVal1 = <span class=\"number\">2</span>;</div><div class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner2</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal1);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Inner</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tOuter outer = <span class=\"keyword\">new</span> Outer();</div><div class=\"line\">\t\touter.testInner(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。</p>\n<p>后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。</p>\n<p>我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）</p>\n<p>但是确实生成了这样几个.class文件：</p>\n<p>Outer.class:class Outer</p>\n<p>Outer$1.class:匿名内部类 new Inner(){…}</p>\n<p>Outer$1Inner2.class:class Inner2</p>\n<p>Outer$Inner.class:interface Inner</p>\n<p>这说明，匿名内部类与他的外围类之间确实是相互独立的。</p>\n<p>为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner &#123;</div><div class=\"line\">  final java.lang.Integer val$localVar;</div><div class=\"line\"></div><div class=\"line\">  final java.lang.String val$paramVal;</div><div class=\"line\"></div><div class=\"line\">  final kyu.java.util.Outer this$0;</div><div class=\"line\"></div><div class=\"line\">  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);</div><div class=\"line\">    Code:</div><div class=\"line\">       0: aload_0</div><div class=\"line\">       1: aload_1</div><div class=\"line\">       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;</div><div class=\"line\">       5: aload_0</div><div class=\"line\">       6: aload_2</div><div class=\"line\">       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;</div><div class=\"line\">      10: aload_0</div><div class=\"line\">      11: aload_3</div><div class=\"line\">      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;</div><div class=\"line\">      15: aload_0</div><div class=\"line\">      16: invokespecial #4                  // Method java/lang/Object.\"&lt;init&gt;\":()V</div><div class=\"line\">      19: return</div><div class=\"line\"></div><div class=\"line\">      .....</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参<br>。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。</p>\n<p>所以，现在有两个问题：</p>\n<ul>\n<li><strong>为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？</strong></li>\n</ul>\n<p>我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。</p>\n<ul>\n<li><strong>局部变量或形参为什么必须是final类型？</strong></li>\n</ul>\n<p>在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">Inner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(localVar+paramVal);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。</p>\n<p>ps:后来在stackoverflow上看到<a href=\"http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class\">Why are only final variables accessible in anonymous class?</a>，可以参考一下。</p>"},{"layout":"post","title":"代码规范","date":"2016-03-29T08:31:55.000Z","_content":"\n>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。\n 所以决定总结一些规范，以后写代码要注意了~\n\n- ## **命名**\n\n  - 变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名\n\n  - 避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean\n\n  1. 方法\n\n     方法名第一个单词小写，以后每个单词首字母大写。\n\n  2. 类、接口\n\n     所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词\n\n  3. 字段、常量\n\n     成员变量、局部变量第一个单词小写，如 userName, instance。\n\n     常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。\n\n     代码中禁止使用硬编码，把一些数字或字符串定义成常用量。\n     \n\n- ## **注释**\n\n  1. 成员变量注释\n\n    ```java\n    /** 成员变量注释 */\n    protected Object mObject0;\n\n    /**\n     * 对于注释多于一行的，采用这种方式来\n     * 定义该变量\n     */\n    private Object mObject4;\n    ```\n\n  2. 方法描述\n\n    ```java\n    /**\n      * 方法描述...\n      * \n      * @param param1  参数1描述...\n      * @param param2  参数2描述...\n      * @param paramXX 参数XX描述... （注意：请将参数、描述都对齐）\n      */\n      public void doSomething(int param1, float param2, String paramXX) {}\n    ```\n\n  3.方法内部注释\n\n    可以使用 /*注释*/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。\n    \n    ```java\n    if (a == 2) {\n        return TRUE;            /* special case */\n    } else {    \n        return isprime(a);      /* works only for odd a */}\n    ```\n<!-- more -->\n\n- ## **换行、空格**\n\n  - **换行**\n\n    当代码过长造成阅读困难的时候，就应该考虑代码换行。\n\n    有这么几个原则：\n\n    1.在逗号之后换行\n\n    2.在操作符之前换行\n\n    3.考虑在表达式的外层就换行，而不是内层\n\n    4.新一行的开头应该与前一行的同一级代码对齐\n\n    5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。\n\n    **示例**\n\n    ```java\n    function(longExpression1, longExpression2, longExpression3,         \n             longExpression4, longExpression5);\n\n    var = function1(longExpression1,                \n                   function2(longExpression2,\n                             longExpression3));\n    ```\n\n    在表达式外层换行：\n\n    ```java\n    longName1 = longName2 * (longName3 + longName4 - longName5)\n                + 4 * longname6; // PREFER\n\n    longName1 = longName2 * (longName3 + longName4\n                             - longName5) + 4 * longname6; // AVOID\n\n    ```\n\n    插入8个空格的情况\n\n    ```java\n    //INDENT 8 SPACES TO AVOID VERY DEEP INDENTS\n    private static synchronized horkingLongMethodName(int anArg,\n            Object anotherArg, String yetAnotherArg,\n            Object andStillAnother) {    \n         ...\n    } \n\n    //条件表达式8空格原则\n    if ((condition1 && condition2)\n            || (condition3 && condition4)\n            ||!(condition5 && condition6)) {\n        doSomethingAboutIt();\n    }\n    ```\n\n  - **空格**\n\n    1.`{`内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。\n\n    2. 操作符左右，大括号`{}`左右，等于号左右都要有一个空格的间距。\nf\n\n- ## **参考**\n\n  [JavaCode Conventions](http://www.oracle.com/technetwork/java/codeconventions-150003.pdf)","source":"_posts/代码格式.md","raw":"---\nlayout: post\ntitle:  \"代码规范\"\ndate:   2016-03-29 16:31:55\ncategories: 编程 \ntags: \n- java\n---\n\n>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。\n 所以决定总结一些规范，以后写代码要注意了~\n\n- ## **命名**\n\n  - 变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名\n\n  - 避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean\n\n  1. 方法\n\n     方法名第一个单词小写，以后每个单词首字母大写。\n\n  2. 类、接口\n\n     所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词\n\n  3. 字段、常量\n\n     成员变量、局部变量第一个单词小写，如 userName, instance。\n\n     常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。\n\n     代码中禁止使用硬编码，把一些数字或字符串定义成常用量。\n     \n\n- ## **注释**\n\n  1. 成员变量注释\n\n    ```java\n    /** 成员变量注释 */\n    protected Object mObject0;\n\n    /**\n     * 对于注释多于一行的，采用这种方式来\n     * 定义该变量\n     */\n    private Object mObject4;\n    ```\n\n  2. 方法描述\n\n    ```java\n    /**\n      * 方法描述...\n      * \n      * @param param1  参数1描述...\n      * @param param2  参数2描述...\n      * @param paramXX 参数XX描述... （注意：请将参数、描述都对齐）\n      */\n      public void doSomething(int param1, float param2, String paramXX) {}\n    ```\n\n  3.方法内部注释\n\n    可以使用 /*注释*/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。\n    \n    ```java\n    if (a == 2) {\n        return TRUE;            /* special case */\n    } else {    \n        return isprime(a);      /* works only for odd a */}\n    ```\n<!-- more -->\n\n- ## **换行、空格**\n\n  - **换行**\n\n    当代码过长造成阅读困难的时候，就应该考虑代码换行。\n\n    有这么几个原则：\n\n    1.在逗号之后换行\n\n    2.在操作符之前换行\n\n    3.考虑在表达式的外层就换行，而不是内层\n\n    4.新一行的开头应该与前一行的同一级代码对齐\n\n    5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。\n\n    **示例**\n\n    ```java\n    function(longExpression1, longExpression2, longExpression3,         \n             longExpression4, longExpression5);\n\n    var = function1(longExpression1,                \n                   function2(longExpression2,\n                             longExpression3));\n    ```\n\n    在表达式外层换行：\n\n    ```java\n    longName1 = longName2 * (longName3 + longName4 - longName5)\n                + 4 * longname6; // PREFER\n\n    longName1 = longName2 * (longName3 + longName4\n                             - longName5) + 4 * longname6; // AVOID\n\n    ```\n\n    插入8个空格的情况\n\n    ```java\n    //INDENT 8 SPACES TO AVOID VERY DEEP INDENTS\n    private static synchronized horkingLongMethodName(int anArg,\n            Object anotherArg, String yetAnotherArg,\n            Object andStillAnother) {    \n         ...\n    } \n\n    //条件表达式8空格原则\n    if ((condition1 && condition2)\n            || (condition3 && condition4)\n            ||!(condition5 && condition6)) {\n        doSomethingAboutIt();\n    }\n    ```\n\n  - **空格**\n\n    1.`{`内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。\n\n    2. 操作符左右，大括号`{}`左右，等于号左右都要有一个空格的间距。\nf\n\n- ## **参考**\n\n  [JavaCode Conventions](http://www.oracle.com/technetwork/java/codeconventions-150003.pdf)","slug":"代码格式","published":1,"updated":"2017-04-11T13:08:38.851Z","comments":1,"photos":[],"link":"","_id":"cj4vch4gv004kx3gc8gntqqdl","content":"<blockquote>\n<p>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。<br> 所以决定总结一些规范，以后写代码要注意了~</p>\n</blockquote>\n<ul>\n<li><h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a><strong>命名</strong></h2><ul>\n<li><p>变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名</p>\n</li>\n<li><p>避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean</p>\n</li>\n</ul>\n<ol>\n<li><p>方法</p>\n<p>方法名第一个单词小写，以后每个单词首字母大写。</p>\n</li>\n<li><p>类、接口</p>\n<p>所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词</p>\n</li>\n<li><p>字段、常量</p>\n<p>成员变量、局部变量第一个单词小写，如 userName, instance。</p>\n<p>常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。</p>\n<p>代码中禁止使用硬编码，把一些数字或字符串定义成常用量。</p>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a><strong>注释</strong></h2><ol>\n<li><p>成员变量注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** 成员变量注释 */</span></div><div class=\"line\"><span class=\"keyword\">protected</span> Object mObject0;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 对于注释多于一行的，采用这种方式来</div><div class=\"line\"> * 定义该变量</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">private</span> Object mObject4;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方法描述</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * 方法描述...</div><div class=\"line\">  * </div><div class=\"line\">  * <span class=\"doctag\">@param</span> param1  参数1描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> param2  参数2描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> paramXX 参数XX描述... （注意：请将参数、描述都对齐）</div><div class=\"line\">  */</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> param1, <span class=\"keyword\">float</span> param2, String paramXX)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.方法内部注释</p>\n<p>  可以使用 /<em>注释</em>/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> TRUE;            <span class=\"comment\">/* special case */</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">    <span class=\"keyword\">return</span> isprime(a);      <span class=\"comment\">/* works only for odd a */</span>&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><h2 id=\"换行、空格\"><a href=\"#换行、空格\" class=\"headerlink\" title=\"换行、空格\"></a><strong>换行、空格</strong></h2><ul>\n<li><p><strong>换行</strong></p>\n<p>当代码过长造成阅读困难的时候，就应该考虑代码换行。</p>\n<p>有这么几个原则：</p>\n<p>1.在逗号之后换行</p>\n<p>2.在操作符之前换行</p>\n<p>3.考虑在表达式的外层就换行，而不是内层</p>\n<p>4.新一行的开头应该与前一行的同一级代码对齐</p>\n<p>5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(longExpression1, longExpression2, longExpression3,         </div><div class=\"line\">         longExpression4, longExpression5);</div><div class=\"line\"></div><div class=\"line\">var = function1(longExpression1,                </div><div class=\"line\">               function2(longExpression2,</div><div class=\"line\">                         longExpression3));</div></pre></td></tr></table></figure>\n<p>在表达式外层换行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">longName1 = longName2 * (longName3 + longName4 - longName5)</div><div class=\"line\">            + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// PREFER</span></div><div class=\"line\"></div><div class=\"line\">longName1 = longName2 * (longName3 + longName4</div><div class=\"line\">                         - longName5) + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// AVOID</span></div></pre></td></tr></table></figure>\n<p>插入8个空格的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//INDENT 8 SPACES TO AVOID VERY DEEP INDENTS</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">horkingLongMethodName</span><span class=\"params\">(<span class=\"keyword\">int</span> anArg,</span></span></div><div class=\"line\">        Object anotherArg, String yetAnotherArg,</div><div class=\"line\">        Object andStillAnother) &#123;    </div><div class=\"line\">     ...</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//条件表达式8空格原则</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((condition1 &amp;&amp; condition2)</div><div class=\"line\">        || (condition3 &amp;&amp; condition4)</div><div class=\"line\">        ||!(condition5 &amp;&amp; condition6)) &#123;</div><div class=\"line\">    doSomethingAboutIt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>空格</strong></p>\n<p>1.<code>{</code>内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。</p>\n<ol>\n<li>操作符左右，大括号<code>{}</code>左右，等于号左右都要有一个空格的间距。<br>f</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://www.oracle.com/technetwork/java/codeconventions-150003.pdf\" target=\"_blank\" rel=\"external\">JavaCode Conventions</a></p>\n</li>\n</ul>\n","excerpt":"<blockquote>\n<p>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。<br> 所以决定总结一些规范，以后写代码要注意了~</p>\n</blockquote>\n<ul>\n<li><h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a><strong>命名</strong></h2><ul>\n<li><p>变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名</p>\n</li>\n<li><p>避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean</p>\n</li>\n</ul>\n<ol>\n<li><p>方法</p>\n<p>方法名第一个单词小写，以后每个单词首字母大写。</p>\n</li>\n<li><p>类、接口</p>\n<p>所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词</p>\n</li>\n<li><p>字段、常量</p>\n<p>成员变量、局部变量第一个单词小写，如 userName, instance。</p>\n<p>常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。</p>\n<p>代码中禁止使用硬编码，把一些数字或字符串定义成常用量。</p>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a><strong>注释</strong></h2><ol>\n<li><p>成员变量注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** 成员变量注释 */</span></div><div class=\"line\"><span class=\"keyword\">protected</span> Object mObject0;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 对于注释多于一行的，采用这种方式来</div><div class=\"line\"> * 定义该变量</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">private</span> Object mObject4;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方法描述</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * 方法描述...</div><div class=\"line\">  * </div><div class=\"line\">  * <span class=\"doctag\">@param</span> param1  参数1描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> param2  参数2描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> paramXX 参数XX描述... （注意：请将参数、描述都对齐）</div><div class=\"line\">  */</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> param1, <span class=\"keyword\">float</span> param2, String paramXX)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.方法内部注释</p>\n<p>  可以使用 /<em>注释</em>/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> TRUE;            <span class=\"comment\">/* special case */</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">    <span class=\"keyword\">return</span> isprime(a);      <span class=\"comment\">/* works only for odd a */</span>&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>","more":"<ul>\n<li><h2 id=\"换行、空格\"><a href=\"#换行、空格\" class=\"headerlink\" title=\"换行、空格\"></a><strong>换行、空格</strong></h2><ul>\n<li><p><strong>换行</strong></p>\n<p>当代码过长造成阅读困难的时候，就应该考虑代码换行。</p>\n<p>有这么几个原则：</p>\n<p>1.在逗号之后换行</p>\n<p>2.在操作符之前换行</p>\n<p>3.考虑在表达式的外层就换行，而不是内层</p>\n<p>4.新一行的开头应该与前一行的同一级代码对齐</p>\n<p>5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(longExpression1, longExpression2, longExpression3,         </div><div class=\"line\">         longExpression4, longExpression5);</div><div class=\"line\"></div><div class=\"line\">var = function1(longExpression1,                </div><div class=\"line\">               function2(longExpression2,</div><div class=\"line\">                         longExpression3));</div></pre></td></tr></table></figure>\n<p>在表达式外层换行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">longName1 = longName2 * (longName3 + longName4 - longName5)</div><div class=\"line\">            + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// PREFER</span></div><div class=\"line\"></div><div class=\"line\">longName1 = longName2 * (longName3 + longName4</div><div class=\"line\">                         - longName5) + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// AVOID</span></div></pre></td></tr></table></figure>\n<p>插入8个空格的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//INDENT 8 SPACES TO AVOID VERY DEEP INDENTS</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">horkingLongMethodName</span><span class=\"params\">(<span class=\"keyword\">int</span> anArg,</div><div class=\"line\">        Object anotherArg, String yetAnotherArg,</div><div class=\"line\">        Object andStillAnother)</span> </span>&#123;    </div><div class=\"line\">     ...</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//条件表达式8空格原则</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((condition1 &amp;&amp; condition2)</div><div class=\"line\">        || (condition3 &amp;&amp; condition4)</div><div class=\"line\">        ||!(condition5 &amp;&amp; condition6)) &#123;</div><div class=\"line\">    doSomethingAboutIt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>空格</strong></p>\n<p>1.<code>{</code>内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。</p>\n<ol>\n<li>操作符左右，大括号<code>{}</code>左右，等于号左右都要有一个空格的间距。<br>f</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://www.oracle.com/technetwork/java/codeconventions-150003.pdf\">JavaCode Conventions</a></p>\n</li>\n</ul>"},{"layout":"post","title":"关于抽象类和接口","date":"2016-04-15T14:48:55.000Z","_content":"\n## 抽象类：\n\n> 使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.\n\n   - 抽象类不能被实例化\n\n   - 如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类\n\n   - 抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。\n\n   - 可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。\n   \n   - 不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。\n\n   - 抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。\n\n   - 子类中的抽象方法不能与父类的抽象方法同名\n\n   - 其余情况抽象类与普通类相同。\n\n<!-- more -->\n\n## 接口：\n\n\n > 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.\n\n   - 接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。\n\n   - 接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。\n\n   - 接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。\n\n   - 接口中没有构造方法，不能被实例化。\n\n   - 如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。\n\n   - 接口中不能含有静态代码块以及静态方法。\n\n   - 在实现多接口的时候一定要避免方法名的重复。\n\n## 区别与联系：\n   \n   - **语义**\n   \n     1. 一个类只能继承一个抽象类，但可以实现多个接口。\n\n     2. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法\n\n   - **设计思想**\n\n     >抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。\n\n     1. 抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。\n\n        对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。\n\n     2. 抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。\n    \n        抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n\n     3. 抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n\n        对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。\n\n     **示例**\n\n     门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n\n  \n```java\nabstract class Door {\n      public abstract void open();\n      public abstract void close();\n}\n```\n    \t\n\n或\n \n```java\ninterface Door {\n      public abstract void open();\n      public abstract void close();\n} \n```\n\n\n但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：\n\n1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；\n\n2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。\n\n从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。\n      \n\n```java\ninterface Alram {\n      void alarm();\n}\nabstract class Door {\n      void open();\n      void close();\n}\nclass AlarmDoor extends Door implements Alarm {\n      void oepn() {\n           //....\n      }\n      void close() {\n           //....\n      }\n      void alarm() {\n           //....\n      }\n} \n```\n---------------------\n## **对继承的思考**\n\n2016/10/27更新\n\n写代码的过程中发现java的继承经常被滥用。思考一下解决方法...\n\n1.当子类和父类属于同一个种类时使用继承，而不是拥有相同的功能。\n\n  比如：飞机能飞，鸟也能飞。但是这两种东西不应该归为一类。飞只是个功能，可以作为一个接口。\n        鸟却可以是大雁的父类，他们从本质上是一种东西\n\n2.继承可用于模板方法模式。即能够从很多类中抽象出同一个流程，把这个流程作为一个模板写在父类当中。设置好钩子供子类实现。\n\n3.既不属于同一种类又没有抽象出模板，但是多个类之间有相同的代码冗余。考虑委托，写一个通用的Utility类，吧冗余的代码放到utility类当中去，把需要的参数传进去。避免滥用继承。比如：\n\n写web服务器时，有很多controller，如果这些controller关联不大，没必要继承同一个父类。但是都有一个验证身份的verify方法，考虑把这个verify方法写到一个Utility类中，所有的controller去调用它。\n\n\n## **资料:**\n\n   [Java 中的接口有什么作用？](https://www.zhihu.com/question/20111251)\n\n   [java提高篇（四）-----抽象类与接口](http://blog.csdn.net/chenssy/article/details/12858267)\n\n","source":"_posts/关于抽象类和接口.md","raw":"---\nlayout: post\ntitle:  \"关于抽象类和接口\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-15 22:48:55\n---\n\n## 抽象类：\n\n> 使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.\n\n   - 抽象类不能被实例化\n\n   - 如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类\n\n   - 抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。\n\n   - 可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。\n   \n   - 不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。\n\n   - 抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。\n\n   - 子类中的抽象方法不能与父类的抽象方法同名\n\n   - 其余情况抽象类与普通类相同。\n\n<!-- more -->\n\n## 接口：\n\n\n > 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.\n\n   - 接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。\n\n   - 接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。\n\n   - 接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。\n\n   - 接口中没有构造方法，不能被实例化。\n\n   - 如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。\n\n   - 接口中不能含有静态代码块以及静态方法。\n\n   - 在实现多接口的时候一定要避免方法名的重复。\n\n## 区别与联系：\n   \n   - **语义**\n   \n     1. 一个类只能继承一个抽象类，但可以实现多个接口。\n\n     2. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法\n\n   - **设计思想**\n\n     >抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。\n\n     1. 抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。\n\n        对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。\n\n     2. 抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。\n    \n        抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n\n     3. 抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n\n        对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。\n\n     **示例**\n\n     门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n\n  \n```java\nabstract class Door {\n      public abstract void open();\n      public abstract void close();\n}\n```\n    \t\n\n或\n \n```java\ninterface Door {\n      public abstract void open();\n      public abstract void close();\n} \n```\n\n\n但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：\n\n1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；\n\n2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。\n\n从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。\n      \n\n```java\ninterface Alram {\n      void alarm();\n}\nabstract class Door {\n      void open();\n      void close();\n}\nclass AlarmDoor extends Door implements Alarm {\n      void oepn() {\n           //....\n      }\n      void close() {\n           //....\n      }\n      void alarm() {\n           //....\n      }\n} \n```\n---------------------\n## **对继承的思考**\n\n2016/10/27更新\n\n写代码的过程中发现java的继承经常被滥用。思考一下解决方法...\n\n1.当子类和父类属于同一个种类时使用继承，而不是拥有相同的功能。\n\n  比如：飞机能飞，鸟也能飞。但是这两种东西不应该归为一类。飞只是个功能，可以作为一个接口。\n        鸟却可以是大雁的父类，他们从本质上是一种东西\n\n2.继承可用于模板方法模式。即能够从很多类中抽象出同一个流程，把这个流程作为一个模板写在父类当中。设置好钩子供子类实现。\n\n3.既不属于同一种类又没有抽象出模板，但是多个类之间有相同的代码冗余。考虑委托，写一个通用的Utility类，吧冗余的代码放到utility类当中去，把需要的参数传进去。避免滥用继承。比如：\n\n写web服务器时，有很多controller，如果这些controller关联不大，没必要继承同一个父类。但是都有一个验证身份的verify方法，考虑把这个verify方法写到一个Utility类中，所有的controller去调用它。\n\n\n## **资料:**\n\n   [Java 中的接口有什么作用？](https://www.zhihu.com/question/20111251)\n\n   [java提高篇（四）-----抽象类与接口](http://blog.csdn.net/chenssy/article/details/12858267)\n\n","slug":"关于抽象类和接口","published":1,"updated":"2017-04-11T13:08:38.851Z","comments":1,"photos":[],"link":"","_id":"cj4vch4gy004nx3gc6x8usqre","content":"<h2 id=\"抽象类：\"><a href=\"#抽象类：\" class=\"headerlink\" title=\"抽象类：\"></a>抽象类：</h2><blockquote>\n<p>使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.</p>\n</blockquote>\n<ul>\n<li><p>抽象类不能被实例化</p>\n</li>\n<li><p>如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类</p>\n</li>\n<li><p>抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。</p>\n</li>\n<li><p>可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。</p>\n</li>\n<li><p>不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。</p>\n</li>\n<li><p>抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。</p>\n</li>\n<li><p>子类中的抽象方法不能与父类的抽象方法同名</p>\n</li>\n<li><p>其余情况抽象类与普通类相同。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"接口：\"><a href=\"#接口：\" class=\"headerlink\" title=\"接口：\"></a>接口：</h2><blockquote>\n<p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.</p>\n</blockquote>\n<ul>\n<li><p>接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。</p>\n</li>\n<li><p>接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。</p>\n</li>\n<li><p>接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。</p>\n</li>\n<li><p>接口中没有构造方法，不能被实例化。</p>\n</li>\n<li><p>如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>\n</li>\n<li><p>接口中不能含有静态代码块以及静态方法。</p>\n</li>\n<li><p>在实现多接口的时候一定要避免方法名的重复。</p>\n</li>\n</ul>\n<h2 id=\"区别与联系：\"><a href=\"#区别与联系：\" class=\"headerlink\" title=\"区别与联系：\"></a>区别与联系：</h2><ul>\n<li><p><strong>语义</strong></p>\n<ol>\n<li><p>一个类只能继承一个抽象类，但可以实现多个接口。</p>\n</li>\n<li><p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法</p>\n</li>\n</ol>\n</li>\n<li><p><strong>设计思想</strong></p>\n<blockquote>\n<p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</p>\n</blockquote>\n<ol>\n<li><p>抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。</p>\n<p>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>\n</li>\n<li><p>抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。</p>\n<p>抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。</p>\n</li>\n<li><p>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>\n<p>对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。</p>\n</li>\n</ol>\n<p><strong>示例</strong></p>\n<p>门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>\n<p>1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>\n<p>2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>\n<p>从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alram</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">oepn</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"对继承的思考\"><a href=\"#对继承的思考\" class=\"headerlink\" title=\"对继承的思考\"></a><strong>对继承的思考</strong></h2><p>2016/10/27更新</p>\n<p>写代码的过程中发现java的继承经常被滥用。思考一下解决方法…</p>\n<p>1.当子类和父类属于同一个种类时使用继承，而不是拥有相同的功能。</p>\n<p>  比如：飞机能飞，鸟也能飞。但是这两种东西不应该归为一类。飞只是个功能，可以作为一个接口。<br>        鸟却可以是大雁的父类，他们从本质上是一种东西</p>\n<p>2.继承可用于模板方法模式。即能够从很多类中抽象出同一个流程，把这个流程作为一个模板写在父类当中。设置好钩子供子类实现。</p>\n<p>3.既不属于同一种类又没有抽象出模板，但是多个类之间有相同的代码冗余。考虑委托，写一个通用的Utility类，吧冗余的代码放到utility类当中去，把需要的参数传进去。避免滥用继承。比如：</p>\n<p>写web服务器时，有很多controller，如果这些controller关联不大，没必要继承同一个父类。但是都有一个验证身份的verify方法，考虑把这个verify方法写到一个Utility类中，所有的controller去调用它。</p>\n<h2 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料:\"></a><strong>资料:</strong></h2><p>   <a href=\"https://www.zhihu.com/question/20111251\" target=\"_blank\" rel=\"external\">Java 中的接口有什么作用？</a></p>\n<p>   <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\" target=\"_blank\" rel=\"external\">java提高篇（四）—–抽象类与接口</a></p>\n","excerpt":"<h2 id=\"抽象类：\"><a href=\"#抽象类：\" class=\"headerlink\" title=\"抽象类：\"></a>抽象类：</h2><blockquote>\n<p>使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.</p>\n</blockquote>\n<ul>\n<li><p>抽象类不能被实例化</p>\n</li>\n<li><p>如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类</p>\n</li>\n<li><p>抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。</p>\n</li>\n<li><p>可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。</p>\n</li>\n<li><p>不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。</p>\n</li>\n<li><p>抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。</p>\n</li>\n<li><p>子类中的抽象方法不能与父类的抽象方法同名</p>\n</li>\n<li><p>其余情况抽象类与普通类相同。</p>\n</li>\n</ul>","more":"<h2 id=\"接口：\"><a href=\"#接口：\" class=\"headerlink\" title=\"接口：\"></a>接口：</h2><blockquote>\n<p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.</p>\n</blockquote>\n<ul>\n<li><p>接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。</p>\n</li>\n<li><p>接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。</p>\n</li>\n<li><p>接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。</p>\n</li>\n<li><p>接口中没有构造方法，不能被实例化。</p>\n</li>\n<li><p>如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>\n</li>\n<li><p>接口中不能含有静态代码块以及静态方法。</p>\n</li>\n<li><p>在实现多接口的时候一定要避免方法名的重复。</p>\n</li>\n</ul>\n<h2 id=\"区别与联系：\"><a href=\"#区别与联系：\" class=\"headerlink\" title=\"区别与联系：\"></a>区别与联系：</h2><ul>\n<li><p><strong>语义</strong></p>\n<ol>\n<li><p>一个类只能继承一个抽象类，但可以实现多个接口。</p>\n</li>\n<li><p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法</p>\n</li>\n</ol>\n</li>\n<li><p><strong>设计思想</strong></p>\n<blockquote>\n<p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</p>\n</blockquote>\n<ol>\n<li><p>抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。</p>\n<p>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>\n</li>\n<li><p>抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。</p>\n<p>抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。</p>\n</li>\n<li><p>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>\n<p>对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。</p>\n</li>\n</ol>\n<p><strong>示例</strong></p>\n<p>门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>\n<p>1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>\n<p>2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>\n<p>从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alram</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">oepn</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"对继承的思考\"><a href=\"#对继承的思考\" class=\"headerlink\" title=\"对继承的思考\"></a><strong>对继承的思考</strong></h2><p>2016/10/27更新</p>\n<p>写代码的过程中发现java的继承经常被滥用。思考一下解决方法…</p>\n<p>1.当子类和父类属于同一个种类时使用继承，而不是拥有相同的功能。</p>\n<p>  比如：飞机能飞，鸟也能飞。但是这两种东西不应该归为一类。飞只是个功能，可以作为一个接口。<br>        鸟却可以是大雁的父类，他们从本质上是一种东西</p>\n<p>2.继承可用于模板方法模式。即能够从很多类中抽象出同一个流程，把这个流程作为一个模板写在父类当中。设置好钩子供子类实现。</p>\n<p>3.既不属于同一种类又没有抽象出模板，但是多个类之间有相同的代码冗余。考虑委托，写一个通用的Utility类，吧冗余的代码放到utility类当中去，把需要的参数传进去。避免滥用继承。比如：</p>\n<p>写web服务器时，有很多controller，如果这些controller关联不大，没必要继承同一个父类。但是都有一个验证身份的verify方法，考虑把这个verify方法写到一个Utility类中，所有的controller去调用它。</p>\n<h2 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料:\"></a><strong>资料:</strong></h2><p>   <a href=\"https://www.zhihu.com/question/20111251\">Java 中的接口有什么作用？</a></p>\n<p>   <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\">java提高篇（四）—–抽象类与接口</a></p>"},{"layout":"post","title":"凉拌黄瓜","date":"2017-05-07T10:07:12.000Z","_content":"天气热起来了，突然想吃黄瓜了，打电话给我妈问了凉拌黄瓜的做法，吃起来不错~\n\n忘记拍照了...\n\n## 原料\n\n黄瓜、拉皮(粉皮)、醋、生抽、葱、蒜、盐、味精、辣椒面、香油\n\n## 做法\n\n1. 黄瓜洗净切片，葱切片，蒜切末(或蒜水)\n\n2. 黄瓜，拉皮(粉皮)放到碗中，将葱、蒜末倒入(蒜水更佳)\n\n3. 放入盐适量，香油适量，少许味精，生抽适量\n\n4. 加入香醋(根据个人口味，喜欢吃醋多加)，喜欢吃辣的可以放入适量辣椒面\n\n5. 调匀，品尝口味后可以再适当的加入上述材料，大功告成\n\n<!-- more -->","source":"_posts/凉拌黄瓜.md","raw":"---\nlayout: post\ntitle: 凉拌黄瓜\ndate: 2017-05-07 18:07:12\ncategories: 生活\ntags: 食物\n---\n天气热起来了，突然想吃黄瓜了，打电话给我妈问了凉拌黄瓜的做法，吃起来不错~\n\n忘记拍照了...\n\n## 原料\n\n黄瓜、拉皮(粉皮)、醋、生抽、葱、蒜、盐、味精、辣椒面、香油\n\n## 做法\n\n1. 黄瓜洗净切片，葱切片，蒜切末(或蒜水)\n\n2. 黄瓜，拉皮(粉皮)放到碗中，将葱、蒜末倒入(蒜水更佳)\n\n3. 放入盐适量，香油适量，少许味精，生抽适量\n\n4. 加入香醋(根据个人口味，喜欢吃醋多加)，喜欢吃辣的可以放入适量辣椒面\n\n5. 调匀，品尝口味后可以再适当的加入上述材料，大功告成\n\n<!-- more -->","slug":"凉拌黄瓜","published":1,"updated":"2017-05-07T13:30:19.420Z","comments":1,"photos":[],"link":"","_id":"cj4vch4h0004qx3gc2oqjdnvv","content":"<p>天气热起来了，突然想吃黄瓜了，打电话给我妈问了凉拌黄瓜的做法，吃起来不错~</p>\n<p>忘记拍照了…</p>\n<h2 id=\"原料\"><a href=\"#原料\" class=\"headerlink\" title=\"原料\"></a>原料</h2><p>黄瓜、拉皮(粉皮)、醋、生抽、葱、蒜、盐、味精、辣椒面、香油</p>\n<h2 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h2><ol>\n<li><p>黄瓜洗净切片，葱切片，蒜切末(或蒜水)</p>\n</li>\n<li><p>黄瓜，拉皮(粉皮)放到碗中，将葱、蒜末倒入(蒜水更佳)</p>\n</li>\n<li><p>放入盐适量，香油适量，少许味精，生抽适量</p>\n</li>\n<li><p>加入香醋(根据个人口味，喜欢吃醋多加)，喜欢吃辣的可以放入适量辣椒面</p>\n</li>\n<li><p>调匀，品尝口味后可以再适当的加入上述材料，大功告成</p>\n</li>\n</ol>\n<a id=\"more\"></a>","excerpt":"<p>天气热起来了，突然想吃黄瓜了，打电话给我妈问了凉拌黄瓜的做法，吃起来不错~</p>\n<p>忘记拍照了…</p>\n<h2 id=\"原料\"><a href=\"#原料\" class=\"headerlink\" title=\"原料\"></a>原料</h2><p>黄瓜、拉皮(粉皮)、醋、生抽、葱、蒜、盐、味精、辣椒面、香油</p>\n<h2 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h2><ol>\n<li><p>黄瓜洗净切片，葱切片，蒜切末(或蒜水)</p>\n</li>\n<li><p>黄瓜，拉皮(粉皮)放到碗中，将葱、蒜末倒入(蒜水更佳)</p>\n</li>\n<li><p>放入盐适量，香油适量，少许味精，生抽适量</p>\n</li>\n<li><p>加入香醋(根据个人口味，喜欢吃醋多加)，喜欢吃辣的可以放入适量辣椒面</p>\n</li>\n<li><p>调匀，品尝口味后可以再适当的加入上述材料，大功告成</p>\n</li>\n</ol>","more":""},{"layout":"post","title":"如何炒肉","date":"2017-05-07T13:07:12.000Z","_content":"这个炒肉是跟我妈学的，炒菜或者调面均可，很好吃～\n\n图比较丑，就不上了...\n\n## 原料\n\n里脊肉、醋、生姜、葱、蒜、酱油、花椒面、盐、味精、清水\n\n## 做法\n\n1. 将里脊肉洗净，切成小块或肉片均可\n\n2. 生姜切片、葱切段、蒜切片备用\n\n3. 锅中倒油，放入备用的里脊肉翻炒\n\n4. 倒入少许醋，继续翻炒\n\n5. 片刻后加入备用的生姜、葱蒜，花椒面(花椒水更好)、味精以及少许盐继续翻炒\n\n6. 倒入适量酱油，翻炒片刻后加入适量清水\n\n7. 小火，待水被熬的差不多时起锅，倒入碗中，完成\n\n<!-- more -->","source":"_posts/如何炒肉.md","raw":"---\nlayout: post\ntitle: 如何炒肉\ndate: 2017-05-07 21:07:12\ncategories: 生活\ntags: 食物\n---\n这个炒肉是跟我妈学的，炒菜或者调面均可，很好吃～\n\n图比较丑，就不上了...\n\n## 原料\n\n里脊肉、醋、生姜、葱、蒜、酱油、花椒面、盐、味精、清水\n\n## 做法\n\n1. 将里脊肉洗净，切成小块或肉片均可\n\n2. 生姜切片、葱切段、蒜切片备用\n\n3. 锅中倒油，放入备用的里脊肉翻炒\n\n4. 倒入少许醋，继续翻炒\n\n5. 片刻后加入备用的生姜、葱蒜，花椒面(花椒水更好)、味精以及少许盐继续翻炒\n\n6. 倒入适量酱油，翻炒片刻后加入适量清水\n\n7. 小火，待水被熬的差不多时起锅，倒入碗中，完成\n\n<!-- more -->","slug":"如何炒肉","published":1,"updated":"2017-05-07T13:30:30.022Z","comments":1,"photos":[],"link":"","_id":"cj4vch4h3004ux3gc7vzwfr1h","content":"<p>这个炒肉是跟我妈学的，炒菜或者调面均可，很好吃～</p>\n<p>图比较丑，就不上了…</p>\n<h2 id=\"原料\"><a href=\"#原料\" class=\"headerlink\" title=\"原料\"></a>原料</h2><p>里脊肉、醋、生姜、葱、蒜、酱油、花椒面、盐、味精、清水</p>\n<h2 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h2><ol>\n<li><p>将里脊肉洗净，切成小块或肉片均可</p>\n</li>\n<li><p>生姜切片、葱切段、蒜切片备用</p>\n</li>\n<li><p>锅中倒油，放入备用的里脊肉翻炒</p>\n</li>\n<li><p>倒入少许醋，继续翻炒</p>\n</li>\n<li><p>片刻后加入备用的生姜、葱蒜，花椒面(花椒水更好)、味精以及少许盐继续翻炒</p>\n</li>\n<li><p>倒入适量酱油，翻炒片刻后加入适量清水</p>\n</li>\n<li><p>小火，待水被熬的差不多时起锅，倒入碗中，完成</p>\n</li>\n</ol>\n<a id=\"more\"></a>","excerpt":"<p>这个炒肉是跟我妈学的，炒菜或者调面均可，很好吃～</p>\n<p>图比较丑，就不上了…</p>\n<h2 id=\"原料\"><a href=\"#原料\" class=\"headerlink\" title=\"原料\"></a>原料</h2><p>里脊肉、醋、生姜、葱、蒜、酱油、花椒面、盐、味精、清水</p>\n<h2 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h2><ol>\n<li><p>将里脊肉洗净，切成小块或肉片均可</p>\n</li>\n<li><p>生姜切片、葱切段、蒜切片备用</p>\n</li>\n<li><p>锅中倒油，放入备用的里脊肉翻炒</p>\n</li>\n<li><p>倒入少许醋，继续翻炒</p>\n</li>\n<li><p>片刻后加入备用的生姜、葱蒜，花椒面(花椒水更好)、味精以及少许盐继续翻炒</p>\n</li>\n<li><p>倒入适量酱油，翻炒片刻后加入适量清水</p>\n</li>\n<li><p>小火，待水被熬的差不多时起锅，倒入碗中，完成</p>\n</li>\n</ol>","more":""},{"layout":"post","title":"关于加密的一点总结","date":"2016-08-22T12:59:00.000Z","_content":"前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。\n\n## 信息摘要算法\n\n### 简介\n\n验证用户名密码的整个过程主要使用了MD5算法。严格来说，[MD5](https://zh.wikipedia.org/wiki/MD5)不是一种加密算法，而是一种信息摘要算法。\n\n所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在[这篇](http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/)总结中提到过。简单来说，就是把给出的\"信息\"经过哈希之后得到的值，就是这些内容的\"摘要\"。\n\n### 特点\n\n信息摘要算法有这样几个特点：\n\n1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。\n\n2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个[提问](http://www.zhihu.com/question/22651987).\n\n3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。\n\n满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？\n\n<!-- more -->\n\n1.一致性检验。\n\n我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。\n\n下面是jdk-7u79对应的MD5校验值，从[官方网站](https://www.oracle.com/webfolder/s/digest/7u79checksum.html)截图。\n\n{% asset_img md5.png MD5 %}\n\n2.数字签名\n\n其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。\n\n3.登陆验证\n\n模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回success\n\n3.客户端将密码经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。\n\n那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 [加盐](https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6) 的手段来保证我们密码的安全。\n\n所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。\n\n使用加盐手段后，上面的验证过程改为如下：\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt\n\n3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。\n\n### java中的MD5\n\n```java\npublic static String stringMD5(String input) {  \n  \n   try {    \n      // 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    \n      MessageDigest messageDigest =MessageDigest.getInstance(\"MD5\");  \n      // 输入的字符串转换成字节数组  \n      byte[] inputByteArray = input.getBytes();  \n  \n      // inputByteArray是输入字符串转换得到的字节数组  \n      messageDigest.update(inputByteArray);      \n  \n      // 转换并返回结果，也是字节数组，包含16个元素  \n      byte[] resultByteArray = messageDigest.digest();  \n    \n      // 字符数组转换成字符串返回  \n      return byteArrayToHex(resultByteArray);           \n   } catch (NoSuchAlgorithmException e) {   \n      return null;    \n   }  \n  \n}  \n\npublic static String byteArrayToHex(byte[] byteArray) {    \n   // 首先初始化一个字符数组，用来存放每个16进制字符    \n   char[] hexDigits = {'0','1','2','3','4','5','6','7','8','9', 'A','B','C','D','E','F' };  \n    \n   // new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    \n   char[] resultCharArray =new char[byteArray.length * 2];   \n  \n   // 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    \n   int index = 0;    \n   int pos,tmp;\n   for (byte b : byteArray) {   \n   \t  //当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！\n   \t  //为便于理解，此处对原文进行修改\n   \t  int tmp = b & 0xFF;\n   \t  pos = tmp >> 4;//得到低四位\n      resultCharArray[index++] = hexDigits[pos];  \n      pos = tmp & 0xF;//得到高四位\n      resultCharArray[index++] = hexDigits[pos];   \n   }    \n  \n   // 字符数组组合成字符串返回   \n   return new String(resultCharArray);  \n}\n```\n代码参考自[叉叉哥的BLOG](http://blog.csdn.net/xiao__gui/article/details/8148203)\n\n\n## 数字签名\n\n前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。\n\n首先了解一下两个概念：[对称加密](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86)和[非对称加密](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)。\n\n对称加密，就是信息加密解密使用相同的密钥。\n\n非对称加密，有两种密钥，公钥和私钥。\n\n公钥私钥满足以下几个特点：\n\n1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。\n\n2.顾名思义，公钥是可以公开的，而私钥是不公开的。\n\n3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。\n\n4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容\n\n5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。\n\n与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。\n\n下面看一下数字签名使用过程：\n\n1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。\n\n2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的**身份认证**。\n\n3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了**信息完整性**（一致性检验）。\n\n上面的过程能够得出数字签名的作用：**身份认证**与**完整性检验**\n\n使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。\n\n## 数字证书\n\n数字证书是用来解决公钥从哪里来的问题。\n\n可能有以下两种方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了\n\n所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。\n\n关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。\n\n## 参考\n\n网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。\n\n以下内容来自[无恙-数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html) http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n2、一个加密通信过程的演化\n\n我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：\n\n2.1 第一回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：？？？？\n\n因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”\n\n“黑客”->“客户”：你好，我是服务器\n\n因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：\n\n \n\n2.2 第二回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n      // 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n\n为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。\n\n“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。\n\n假设“黑客”想冒充“服务器”：\n\n“黑客”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。\n\n“客户”->“黑客”：？？？？\n\n由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！\n\n到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：\n\n \n\n2.3 第三回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]\n\n“服务器”->“客户”：{你的余额是100元}[私钥|RSA]\n\n注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。\n\n这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：\n\n \n\n2.4 第四回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。\n\n“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]\n\n在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。\n\n由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。\n\n \n\n总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：\n\n因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。\n客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。\n如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)\n\n到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。\n\n \n\n但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：\n\n“客户”->“黑客”：你好           //黑客截获“客户”发给“服务器”的消息\n\n“黑客”->“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”\n\n因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。\n\n为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：\n\n证书的发布机构\n证书的有效期\n公钥\n证书所有者（Subject）\n签名所使用的算法\n指纹以及指纹算法\n证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：\n\n \n\n2.5 第五回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：\n\n \n\n2.6 完整过程：\n\nstep1： “客户”向服务端发送一个通信请求\n\n“客户”->“服务器”：你好\n\n  \n\nstep2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 \n\n \n\nstep3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。\n\n“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。\n\n“服务器”->“客户”：{一个随机字符串}[私钥|RSA]\n\n \n\nstep4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。\n\n“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]\n\n…… //继续其它的通信\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n另外，也可以看看这篇博客：[阮一峰-数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)\n\n\n\n\n\n\n\n\n","source":"_posts/关于加密的一点总结.md","raw":"layout: post\ntitle: 关于加密的一点总结\ndate: 2016-08-22 20:59:00\ncategories: 技术\ntags: 加密\n---\n前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。\n\n## 信息摘要算法\n\n### 简介\n\n验证用户名密码的整个过程主要使用了MD5算法。严格来说，[MD5](https://zh.wikipedia.org/wiki/MD5)不是一种加密算法，而是一种信息摘要算法。\n\n所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在[这篇](http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/)总结中提到过。简单来说，就是把给出的\"信息\"经过哈希之后得到的值，就是这些内容的\"摘要\"。\n\n### 特点\n\n信息摘要算法有这样几个特点：\n\n1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。\n\n2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个[提问](http://www.zhihu.com/question/22651987).\n\n3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。\n\n满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？\n\n<!-- more -->\n\n1.一致性检验。\n\n我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。\n\n下面是jdk-7u79对应的MD5校验值，从[官方网站](https://www.oracle.com/webfolder/s/digest/7u79checksum.html)截图。\n\n{% asset_img md5.png MD5 %}\n\n2.数字签名\n\n其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。\n\n3.登陆验证\n\n模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回success\n\n3.客户端将密码经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。\n\n那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 [加盐](https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6) 的手段来保证我们密码的安全。\n\n所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。\n\n使用加盐手段后，上面的验证过程改为如下：\n\n1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。\n\n2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt\n\n3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台\n\n4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列\n\n5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败\n\n注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。\n\n### java中的MD5\n\n```java\npublic static String stringMD5(String input) {  \n  \n   try {    \n      // 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    \n      MessageDigest messageDigest =MessageDigest.getInstance(\"MD5\");  \n      // 输入的字符串转换成字节数组  \n      byte[] inputByteArray = input.getBytes();  \n  \n      // inputByteArray是输入字符串转换得到的字节数组  \n      messageDigest.update(inputByteArray);      \n  \n      // 转换并返回结果，也是字节数组，包含16个元素  \n      byte[] resultByteArray = messageDigest.digest();  \n    \n      // 字符数组转换成字符串返回  \n      return byteArrayToHex(resultByteArray);           \n   } catch (NoSuchAlgorithmException e) {   \n      return null;    \n   }  \n  \n}  \n\npublic static String byteArrayToHex(byte[] byteArray) {    \n   // 首先初始化一个字符数组，用来存放每个16进制字符    \n   char[] hexDigits = {'0','1','2','3','4','5','6','7','8','9', 'A','B','C','D','E','F' };  \n    \n   // new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    \n   char[] resultCharArray =new char[byteArray.length * 2];   \n  \n   // 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    \n   int index = 0;    \n   int pos,tmp;\n   for (byte b : byteArray) {   \n   \t  //当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！\n   \t  //为便于理解，此处对原文进行修改\n   \t  int tmp = b & 0xFF;\n   \t  pos = tmp >> 4;//得到低四位\n      resultCharArray[index++] = hexDigits[pos];  \n      pos = tmp & 0xF;//得到高四位\n      resultCharArray[index++] = hexDigits[pos];   \n   }    \n  \n   // 字符数组组合成字符串返回   \n   return new String(resultCharArray);  \n}\n```\n代码参考自[叉叉哥的BLOG](http://blog.csdn.net/xiao__gui/article/details/8148203)\n\n\n## 数字签名\n\n前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。\n\n首先了解一下两个概念：[对称加密](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86)和[非对称加密](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)。\n\n对称加密，就是信息加密解密使用相同的密钥。\n\n非对称加密，有两种密钥，公钥和私钥。\n\n公钥私钥满足以下几个特点：\n\n1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。\n\n2.顾名思义，公钥是可以公开的，而私钥是不公开的。\n\n3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。\n\n4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容\n\n5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。\n\n与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。\n\n下面看一下数字签名使用过程：\n\n1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。\n\n2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的**身份认证**。\n\n3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了**信息完整性**（一致性检验）。\n\n上面的过程能够得出数字签名的作用：**身份认证**与**完整性检验**\n\n使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。\n\n## 数字证书\n\n数字证书是用来解决公钥从哪里来的问题。\n\n可能有以下两种方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了\n\n所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。\n\n关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。\n\n## 参考\n\n网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。\n\n以下内容来自[无恙-数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html) http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n2、一个加密通信过程的演化\n\n我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：\n\n2.1 第一回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：？？？？\n\n因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”\n\n“黑客”->“客户”：你好，我是服务器\n\n因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：\n\n \n\n2.2 第二回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n      // 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n\n为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。\n\n“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。\n\n假设“黑客”想冒充“服务器”：\n\n“黑客”->“客户”：你好，我是服务器\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。\n\n“客户”->“黑客”：？？？？\n\n由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！\n\n到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：\n\n \n\n2.3 第三回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]\n\n“服务器”->“客户”：{你的余额是100元}[私钥|RSA]\n\n注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。\n\n这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：\n\n \n\n2.4 第四回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。\n\n“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]\n\n在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。\n\n由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。\n\n \n\n总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：\n\n因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。\n客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。\n如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)\n\n到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。\n\n \n\n但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：\n\na)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。\n\nb)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。\n\n但是这个两个方法都有一定的问题，\n\n对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。\n\n对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：\n\n“客户”->“黑客”：你好           //黑客截获“客户”发给“服务器”的消息\n\n“黑客”->“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥\n\n“客户”->“黑客”：向我证明你就是服务器\n\n“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”\n\n因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。\n\n为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：\n\n证书的发布机构\n证书的有效期\n公钥\n证书所有者（Subject）\n签名所使用的算法\n指纹以及指纹算法\n证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：\n\n \n\n2.5 第五回合：\n\n“客户”->“服务器”：你好\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥\n\n“客户”->“服务器”：向我证明你就是服务器\n\n“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]\n\n注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：\n\n \n\n2.6 完整过程：\n\nstep1： “客户”向服务端发送一个通信请求\n\n“客户”->“服务器”：你好\n\n  \n\nstep2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有\n\n“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 \n\n \n\nstep3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。\n\n“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。\n\n“服务器”->“客户”：{一个随机字符串}[私钥|RSA]\n\n \n\nstep4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。\n\n“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]\n\n“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]\n\n“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]\n\n…… //继续其它的通信\n\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n\n另外，也可以看看这篇博客：[阮一峰-数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)\n\n\n\n\n\n\n\n\n","slug":"关于加密的一点总结","published":1,"updated":"2017-04-11T13:08:38.851Z","comments":1,"photos":[],"link":"","_id":"cj4vch4h5004xx3gcged1xik4","content":"<p>前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。</p>\n<h2 id=\"信息摘要算法\"><a href=\"#信息摘要算法\" class=\"headerlink\" title=\"信息摘要算法\"></a>信息摘要算法</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>验证用户名密码的整个过程主要使用了MD5算法。严格来说，<a href=\"https://zh.wikipedia.org/wiki/MD5\" target=\"_blank\" rel=\"external\">MD5</a>不是一种加密算法，而是一种信息摘要算法。</p>\n<p>所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在<a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/\">这篇</a>总结中提到过。简单来说，就是把给出的”信息”经过哈希之后得到的值，就是这些内容的”摘要”。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>信息摘要算法有这样几个特点：</p>\n<p>1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。</p>\n<p>2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个<a href=\"http://www.zhihu.com/question/22651987\" target=\"_blank\" rel=\"external\">提问</a>.</p>\n<p>3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。</p>\n<p>满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？</p>\n<a id=\"more\"></a>\n<p>1.一致性检验。</p>\n<p>我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。</p>\n<p>下面是jdk-7u79对应的MD5校验值，从<a href=\"https://www.oracle.com/webfolder/s/digest/7u79checksum.html\" target=\"_blank\" rel=\"external\">官方网站</a>截图。</p>\n<img src=\"/2016/08/22/关于加密的一点总结/md5.png\" alt=\"MD5\" title=\"MD5\">\n<p>2.数字签名</p>\n<p>其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。</p>\n<p>3.登陆验证</p>\n<p>模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回success</p>\n<p>3.客户端将密码经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。</p>\n<p>那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 <a href=\"https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6\" target=\"_blank\" rel=\"external\">加盐</a> 的手段来保证我们密码的安全。</p>\n<p>所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。</p>\n<p>使用加盐手段后，上面的验证过程改为如下：</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt</p>\n<p>3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。</p>\n<h3 id=\"java中的MD5\"><a href=\"#java中的MD5\" class=\"headerlink\" title=\"java中的MD5\"></a>java中的MD5</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">stringMD5</span><span class=\"params\">(String input)</span> </span>&#123;  </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">      <span class=\"comment\">// 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    </span></div><div class=\"line\">      MessageDigest messageDigest =MessageDigest.getInstance(<span class=\"string\">\"MD5\"</span>);  </div><div class=\"line\">      <span class=\"comment\">// 输入的字符串转换成字节数组  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] inputByteArray = input.getBytes();  </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// inputByteArray是输入字符串转换得到的字节数组  </span></div><div class=\"line\">      messageDigest.update(inputByteArray);      </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// 转换并返回结果，也是字节数组，包含16个元素  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] resultByteArray = messageDigest.digest();  </div><div class=\"line\">    </div><div class=\"line\">      <span class=\"comment\">// 字符数组转换成字符串返回  </span></div><div class=\"line\">      <span class=\"keyword\">return</span> byteArrayToHex(resultByteArray);           </div><div class=\"line\">   &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;   </div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;    </div><div class=\"line\">   &#125;  </div><div class=\"line\">  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">byteArrayToHex</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] byteArray)</span> </span>&#123;    </div><div class=\"line\">   <span class=\"comment\">// 首先初始化一个字符数组，用来存放每个16进制字符    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] hexDigits = &#123;<span class=\"string\">'0'</span>,<span class=\"string\">'1'</span>,<span class=\"string\">'2'</span>,<span class=\"string\">'3'</span>,<span class=\"string\">'4'</span>,<span class=\"string\">'5'</span>,<span class=\"string\">'6'</span>,<span class=\"string\">'7'</span>,<span class=\"string\">'8'</span>,<span class=\"string\">'9'</span>, <span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span> &#125;;  </div><div class=\"line\">    </div><div class=\"line\">   <span class=\"comment\">// new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] resultCharArray =<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[byteArray.length * <span class=\"number\">2</span>];   </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    </span></div><div class=\"line\">   <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;    </div><div class=\"line\">   <span class=\"keyword\">int</span> pos,tmp;</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">byte</span> b : byteArray) &#123;   </div><div class=\"line\">   \t  <span class=\"comment\">//当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！</span></div><div class=\"line\">   \t  <span class=\"comment\">//为便于理解，此处对原文进行修改</span></div><div class=\"line\">   \t  <span class=\"keyword\">int</span> tmp = b &amp; <span class=\"number\">0xFF</span>;</div><div class=\"line\">   \t  pos = tmp &gt;&gt; <span class=\"number\">4</span>;<span class=\"comment\">//得到低四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];  </div><div class=\"line\">      pos = tmp &amp; <span class=\"number\">0xF</span>;<span class=\"comment\">//得到高四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];   </div><div class=\"line\">   &#125;    </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 字符数组组合成字符串返回   </span></div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(resultCharArray);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码参考自<a href=\"http://blog.csdn.net/xiao__gui/article/details/8148203\" target=\"_blank\" rel=\"external\">叉叉哥的BLOG</a></p>\n<h2 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h2><p>前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。</p>\n<p>首先了解一下两个概念：<a href=\"https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86\" target=\"_blank\" rel=\"external\">对称加密</a>和<a href=\"https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86\" target=\"_blank\" rel=\"external\">非对称加密</a>。</p>\n<p>对称加密，就是信息加密解密使用相同的密钥。</p>\n<p>非对称加密，有两种密钥，公钥和私钥。</p>\n<p>公钥私钥满足以下几个特点：</p>\n<p>1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。</p>\n<p>2.顾名思义，公钥是可以公开的，而私钥是不公开的。</p>\n<p>3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。</p>\n<p>4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容</p>\n<p>5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。</p>\n<p>与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。</p>\n<p>下面看一下数字签名使用过程：</p>\n<p>1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。</p>\n<p>2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的<strong>身份认证</strong>。</p>\n<p>3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了<strong>信息完整性</strong>（一致性检验）。</p>\n<p>上面的过程能够得出数字签名的作用：<strong>身份认证</strong>与<strong>完整性检验</strong></p>\n<p>使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。</p>\n<h2 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h2><p>数字证书是用来解决公钥从哪里来的问题。</p>\n<p>可能有以下两种方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了</p>\n<p>所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。</p>\n<p>关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。</p>\n<p>以下内容来自<a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\" target=\"_blank\" rel=\"external\">无恙-数字证书原理</a> <a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html</a></p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>2、一个加密通信过程的演化</p>\n<p>我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：</p>\n<p>2.1 第一回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：？？？？</p>\n<p>因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：</p>\n<p>2.2 第二回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<pre><code>// 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n</code></pre><p>为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。</p>\n<p>“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。</p>\n<p>假设“黑客”想冒充“服务器”：</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。</p>\n<p>“客户”-&gt;“黑客”：？？？？</p>\n<p>由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！</p>\n<p>到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：</p>\n<p>2.3 第三回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[私钥|RSA]</p>\n<p>注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。</p>\n<p>这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：</p>\n<p>2.4 第四回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。</p>\n<p>“服务器”-&gt;“客户”：{OK，收到！}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[密钥|对称加密算法]</p>\n<p>在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。</p>\n<p>由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。</p>\n<p>总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：</p>\n<p>因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。<br>客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。<br>如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)</p>\n<p>到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。</p>\n<p>但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：</p>\n<p>“客户”-&gt;“黑客”：你好           //黑客截获“客户”发给“服务器”的消息</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”</p>\n<p>因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。</p>\n<p>为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：</p>\n<p>证书的发布机构<br>证书的有效期<br>公钥<br>证书所有者（Subject）<br>签名所使用的算法<br>指纹以及指纹算法<br>证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：</p>\n<p>2.5 第五回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：</p>\n<p>2.6 完整过程：</p>\n<p>step1： “客户”向服务端发送一个通信请求</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>step2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 </p>\n<p>step3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。</p>\n<p>“服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]</p>\n<p>step4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>\n<p>“服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]</p>\n<p>…… //继续其它的通信</p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>另外，也可以看看这篇博客：<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\" target=\"_blank\" rel=\"external\">阮一峰-数字签名是什么？</a></p>\n","excerpt":"<p>前两天了解了一下数据库JDBC创建Connection的过程，其中验证用户密码的过程使用了加密算法，研究之。</p>\n<h2 id=\"信息摘要算法\"><a href=\"#信息摘要算法\" class=\"headerlink\" title=\"信息摘要算法\"></a>信息摘要算法</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>验证用户名密码的整个过程主要使用了MD5算法。严格来说，<a href=\"https://zh.wikipedia.org/wiki/MD5\">MD5</a>不是一种加密算法，而是一种信息摘要算法。</p>\n<p>所谓的信息摘要算法，其实就是一种特殊的散列算法。关于散列，之前在<a href=\"http://yukai.space/2016/04/28/java%E4%B8%AD%E7%9A%84equals%E4%B8%8Ehashcode/\">这篇</a>总结中提到过。简单来说，就是把给出的”信息”经过哈希之后得到的值，就是这些内容的”摘要”。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>信息摘要算法有这样几个特点：</p>\n<p>1.生成固定长度的摘要。以MD5为例，无论信息有多大，经过MD5哈希之后，得到的是一个128bit的值。</p>\n<p>2.算法不可逆。也就是说，不能通过摘要得到信息。可以参考一下知乎上的这个<a href=\"http://www.zhihu.com/question/22651987\">提问</a>.</p>\n<p>3.一般来说，信息不同，摘要也不同。虽然说冲突是一定存在的(无限多可能的信息映射到2的128次方这么大的集合当中)，但是好的摘要算法，要求无法找到两条消息，使他们的摘要相同。</p>\n<p>满足了以上几点的散列算法，就是一种消息摘要算法。那么消息摘要又有什么作用呢？</p>","more":"<p>1.一致性检验。</p>\n<p>我们在一些网站上下载软件的时候，这些网站会给出软件的MD5校验值。你下载完软件，把整个软件进行MD5散列，得到的值与其给出的校验值一致，则证明这个软件是正版的，未经别人修改的原装软件。这其实很好理解，理解了上面信息摘要算法的特点，就可以知道这种一致性检验的原理。MD5也可以用来检验压缩包的完整性等等。</p>\n<p>下面是jdk-7u79对应的MD5校验值，从<a href=\"https://www.oracle.com/webfolder/s/digest/7u79checksum.html\">官方网站</a>截图。</p>\n<img src=\"/2016/08/22/关于加密的一点总结/md5.png\" alt=\"MD5\" title=\"MD5\">\n<p>2.数字签名</p>\n<p>其实数字签名就是加密后的摘要，保证了信息的完整性。后面会说到。</p>\n<p>3.登陆验证</p>\n<p>模拟一次数据库用户名密码验证过程(只是模拟，真实的验证过程稍复杂)。</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回success</p>\n<p>3.客户端将密码经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>从上面的过程中可以看出，我们并没有在网络中传输密码的明文，而是经过散列之后的散列值。即使黑客截获了这个密码的散列值，他也无法逆向推算出我们的密码。</p>\n<p>那么，设想一种情况，黑客截获了密码的散列值，是不是他可以向后台发送这个散列值来进行数据库的连接呢？好像是存在这种风险，所以，我们就需要一种 <a href=\"https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6\">加盐</a> 的手段来保证我们密码的安全。</p>\n<p>所谓加盐，就是在密码的任意固定位置插入一段随机字符串，让散列后的结果和使用原始密码的散列结果不相符。</p>\n<p>使用加盐手段后，上面的验证过程改为如下：</p>\n<p>1.首先客户端向数据库后台发起创建connection的请求，将要连接数据库名DB和用户名User发送到后台。</p>\n<p>2.数据库后台查到确实存在数据库DB与用户User，返回盐Salt</p>\n<p>3.客户端将密码与2中得到的Salt拼接，将得到新的字符串经过MD5计算后的散列值发给数据库后台</p>\n<p>4.数据库后台取出之前收到的User对应的密码(假设密码是明文)，与2中发给客户端的Salt拼接得到新的字符串，使用MD5进行散列</p>\n<p>5.将4中得到的散列值与3中的散列值比较，一致则返回连接创建成功，否则创建连接失败</p>\n<p>注意，每次后台向客户端返回的Salt都是一个随机值，所以即使黑客截获了我们经过散列后的值，也是无法用在下一次登陆的。</p>\n<h3 id=\"java中的MD5\"><a href=\"#java中的MD5\" class=\"headerlink\" title=\"java中的MD5\"></a>java中的MD5</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">stringMD5</span><span class=\"params\">(String input)</span> </span>&#123;  </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">      <span class=\"comment\">// 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）    </span></div><div class=\"line\">      MessageDigest messageDigest =MessageDigest.getInstance(<span class=\"string\">\"MD5\"</span>);  </div><div class=\"line\">      <span class=\"comment\">// 输入的字符串转换成字节数组  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] inputByteArray = input.getBytes();  </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// inputByteArray是输入字符串转换得到的字节数组  </span></div><div class=\"line\">      messageDigest.update(inputByteArray);      </div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">// 转换并返回结果，也是字节数组，包含16个元素  </span></div><div class=\"line\">      <span class=\"keyword\">byte</span>[] resultByteArray = messageDigest.digest();  </div><div class=\"line\">    </div><div class=\"line\">      <span class=\"comment\">// 字符数组转换成字符串返回  </span></div><div class=\"line\">      <span class=\"keyword\">return</span> byteArrayToHex(resultByteArray);           </div><div class=\"line\">   &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;   </div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;    </div><div class=\"line\">   &#125;  </div><div class=\"line\">  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">byteArrayToHex</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] byteArray)</span> </span>&#123;    </div><div class=\"line\">   <span class=\"comment\">// 首先初始化一个字符数组，用来存放每个16进制字符    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] hexDigits = &#123;<span class=\"string\">'0'</span>,<span class=\"string\">'1'</span>,<span class=\"string\">'2'</span>,<span class=\"string\">'3'</span>,<span class=\"string\">'4'</span>,<span class=\"string\">'5'</span>,<span class=\"string\">'6'</span>,<span class=\"string\">'7'</span>,<span class=\"string\">'8'</span>,<span class=\"string\">'9'</span>, <span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span> &#125;;  </div><div class=\"line\">    </div><div class=\"line\">   <span class=\"comment\">// new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））    </span></div><div class=\"line\">   <span class=\"keyword\">char</span>[] resultCharArray =<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[byteArray.length * <span class=\"number\">2</span>];   </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去    </span></div><div class=\"line\">   <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;    </div><div class=\"line\">   <span class=\"keyword\">int</span> pos,tmp;</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">byte</span> b : byteArray) &#123;   </div><div class=\"line\">   \t  <span class=\"comment\">//当时对这段代码不是很理解，使用计算器二进制、十进制、十六进制倒腾一下就好啦！</span></div><div class=\"line\">   \t  <span class=\"comment\">//为便于理解，此处对原文进行修改</span></div><div class=\"line\">   \t  <span class=\"keyword\">int</span> tmp = b &amp; <span class=\"number\">0xFF</span>;</div><div class=\"line\">   \t  pos = tmp &gt;&gt; <span class=\"number\">4</span>;<span class=\"comment\">//得到低四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];  </div><div class=\"line\">      pos = tmp &amp; <span class=\"number\">0xF</span>;<span class=\"comment\">//得到高四位</span></div><div class=\"line\">      resultCharArray[index++] = hexDigits[pos];   </div><div class=\"line\">   &#125;    </div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// 字符数组组合成字符串返回   </span></div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(resultCharArray);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码参考自<a href=\"http://blog.csdn.net/xiao__gui/article/details/8148203\">叉叉哥的BLOG</a></p>\n<h2 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h2><p>前面也说了，数字签名其实就是加密后的摘要，也用到了信息摘要算法。</p>\n<p>首先了解一下两个概念：<a href=\"https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86\">对称加密</a>和<a href=\"https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86\">非对称加密</a>。</p>\n<p>对称加密，就是信息加密解密使用相同的密钥。</p>\n<p>非对称加密，有两种密钥，公钥和私钥。</p>\n<p>公钥私钥满足以下几个特点：</p>\n<p>1.公钥与私钥一一对应，一把公钥只对应一把私钥，反过来也成立。</p>\n<p>2.顾名思义，公钥是可以公开的，而私钥是不公开的。</p>\n<p>3.公钥与私钥，知道其中一个，并不能计算出另外一个。即公开的公钥不能威胁到私钥的秘密性质。</p>\n<p>4.公钥可以解密私钥加密的内容，私钥也可以解密公钥加密的内容</p>\n<p>5.公钥加密的内容，通过公钥无法解密，只能由私钥解密。私钥同理。</p>\n<p>与对称密钥加密相比，公钥加密无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。</p>\n<p>下面看一下数字签名使用过程：</p>\n<p>1.数字签名是将摘要信息用发送者A的私钥加密，与原始信息一起传送给接收者B。</p>\n<p>2.B使用A的公钥对A私钥加密后的摘要信息进行解密，如果解密成功，则说明接收到的内容确实由A发出。这就完成了发送者A的<strong>身份认证</strong>。</p>\n<p>3.B对收到的原始信息使用信息摘要算法得到其哈希值，与2中解密的内容进行比较，如果一致，证明原始信息未经篡改。保证了<strong>信息完整性</strong>（一致性检验）。</p>\n<p>上面的过程能够得出数字签名的作用：<strong>身份认证</strong>与<strong>完整性检验</strong></p>\n<p>使用数字签名可以用来声明版权，检查盗版等等。Android中也有数字签名的影子。</p>\n<h2 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h2><p>数字证书是用来解决公钥从哪里来的问题。</p>\n<p>可能有以下两种方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了</p>\n<p>所以，数字证书就出现了。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。</p>\n<p>关于数字证书，网上也有很多解释。由于我自己也没有十分了解数字证书，故不再赘述。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>网上看到一篇文章，对数字签名和数字证书进行了十分生动的介绍。</p>\n<p>以下内容来自<a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\">无恙-数字证书原理</a> <a href=\"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html\">http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html</a></p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>2、一个加密通信过程的演化</p>\n<p>我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：</p>\n<p>2.1 第一回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：？？？？</p>\n<p>因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：</p>\n<p>2.2 第二回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<pre><code>// 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用私钥对“你好，我是服务器”进行加密后的结果。\n</code></pre><p>为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。</p>\n<p>“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。</p>\n<p>假设“黑客”想冒充“服务器”：</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。</p>\n<p>“客户”-&gt;“黑客”：？？？？</p>\n<p>由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！</p>\n<p>到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：</p>\n<p>2.3 第三回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[私钥|RSA]</p>\n<p>注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。</p>\n<p>这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：</p>\n<p>2.4 第四回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>“客户”-&gt;“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。</p>\n<p>“服务器”-&gt;“客户”：{OK，收到！}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你的余额是100元}[密钥|对称加密算法]</p>\n<p>在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。</p>\n<p>由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。</p>\n<p>总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：</p>\n<p>因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。<br>客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。<br>如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)</p>\n<p>到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。</p>\n<p>但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：</p>\n<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。</p>\n<p>b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。</p>\n<p>但是这个两个方法都有一定的问题，</p>\n<p>对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。</p>\n<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：</p>\n<p>“客户”-&gt;“黑客”：你好           //黑客截获“客户”发给“服务器”的消息</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥</p>\n<p>“客户”-&gt;“黑客”：向我证明你就是服务器</p>\n<p>“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”</p>\n<p>因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。</p>\n<p>为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：</p>\n<p>证书的发布机构<br>证书的有效期<br>公钥<br>证书所有者（Subject）<br>签名所使用的算法<br>指纹以及指纹算法<br>证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：</p>\n<p>2.5 第五回合：</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>\n<p>注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：</p>\n<p>2.6 完整过程：</p>\n<p>step1： “客户”向服务端发送一个通信请求</p>\n<p>“客户”-&gt;“服务器”：你好</p>\n<p>step2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有</p>\n<p>“服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 </p>\n<p>step3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>\n<p>“客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。</p>\n<p>“服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]</p>\n<p>step4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>\n<p>“服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]</p>\n<p>“客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>\n<p>“服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]</p>\n<p>…… //继续其它的通信</p>\n<p>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</p>\n<p>另外，也可以看看这篇博客：<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\">阮一峰-数字签名是什么？</a></p>"},{"layout":"post","title":"土豆烧肉","date":"2017-04-19T04:01:30.000Z","_content":"\n## 原料\n\n土豆、五花肉、姜片、葱、酱油、料酒、盐、青椒、白糖、胡椒面\n\n## 做法\n\n1. 五花肉切块洗净，土豆洗净、去皮，然后切块放到水中备用。青椒切片、葱切段、姜切片备用。\n\n2. 锅中水烧开，放两片姜片，倒入洗净的肉块，汆烫两分钟(注意时间不要太长)，捞出肉块沥干备用\n\n3. 锅中倒油，油七成热后加入加入姜片、葱段、胡椒面爆香，然后倒入肉块煸炒(注意时间不要太长，否则肉会变老)\n\n4. 倒入酱油、精盐、料酒，倒入土豆青椒和肉块一起翻炒几下\n\n5. 加入清水(高汤)刚好没过肉块，加入两小勺盐，适当的撒一点白糖，煮沸后转小火，盖上锅盖烧20分钟\n\n6. 汤锅中汤汁差不多的时候，大火收汁，撒点葱末装盘\n\n<!-- more -->\n\n## 成品\n\n{% asset_img tudou.jpg 土豆烧肉 %}\n\n\n","source":"_posts/土豆烧肉.md","raw":"---\nlayout: post\ntitle: 土豆烧肉\ndate: 2017-04-19 12:01:30\ncategories: 生活\ntags: 食物\n---\n\n## 原料\n\n土豆、五花肉、姜片、葱、酱油、料酒、盐、青椒、白糖、胡椒面\n\n## 做法\n\n1. 五花肉切块洗净，土豆洗净、去皮，然后切块放到水中备用。青椒切片、葱切段、姜切片备用。\n\n2. 锅中水烧开，放两片姜片，倒入洗净的肉块，汆烫两分钟(注意时间不要太长)，捞出肉块沥干备用\n\n3. 锅中倒油，油七成热后加入加入姜片、葱段、胡椒面爆香，然后倒入肉块煸炒(注意时间不要太长，否则肉会变老)\n\n4. 倒入酱油、精盐、料酒，倒入土豆青椒和肉块一起翻炒几下\n\n5. 加入清水(高汤)刚好没过肉块，加入两小勺盐，适当的撒一点白糖，煮沸后转小火，盖上锅盖烧20分钟\n\n6. 汤锅中汤汁差不多的时候，大火收汁，撒点葱末装盘\n\n<!-- more -->\n\n## 成品\n\n{% asset_img tudou.jpg 土豆烧肉 %}\n\n\n","slug":"土豆烧肉","published":1,"updated":"2017-04-19T04:05:18.783Z","comments":1,"photos":[],"link":"","_id":"cj4vch4h70051x3gcmko29u43","content":"<h2 id=\"原料\"><a href=\"#原料\" class=\"headerlink\" title=\"原料\"></a>原料</h2><p>土豆、五花肉、姜片、葱、酱油、料酒、盐、青椒、白糖、胡椒面</p>\n<h2 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h2><ol>\n<li><p>五花肉切块洗净，土豆洗净、去皮，然后切块放到水中备用。青椒切片、葱切段、姜切片备用。</p>\n</li>\n<li><p>锅中水烧开，放两片姜片，倒入洗净的肉块，汆烫两分钟(注意时间不要太长)，捞出肉块沥干备用</p>\n</li>\n<li><p>锅中倒油，油七成热后加入加入姜片、葱段、胡椒面爆香，然后倒入肉块煸炒(注意时间不要太长，否则肉会变老)</p>\n</li>\n<li><p>倒入酱油、精盐、料酒，倒入土豆青椒和肉块一起翻炒几下</p>\n</li>\n<li><p>加入清水(高汤)刚好没过肉块，加入两小勺盐，适当的撒一点白糖，煮沸后转小火，盖上锅盖烧20分钟</p>\n</li>\n<li><p>汤锅中汤汁差不多的时候，大火收汁，撒点葱末装盘</p>\n</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"成品\"><a href=\"#成品\" class=\"headerlink\" title=\"成品\"></a>成品</h2><img src=\"/2017/04/19/土豆烧肉/tudou.jpg\" alt=\"土豆烧肉\" title=\"土豆烧肉\">\n","excerpt":"<h2 id=\"原料\"><a href=\"#原料\" class=\"headerlink\" title=\"原料\"></a>原料</h2><p>土豆、五花肉、姜片、葱、酱油、料酒、盐、青椒、白糖、胡椒面</p>\n<h2 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h2><ol>\n<li><p>五花肉切块洗净，土豆洗净、去皮，然后切块放到水中备用。青椒切片、葱切段、姜切片备用。</p>\n</li>\n<li><p>锅中水烧开，放两片姜片，倒入洗净的肉块，汆烫两分钟(注意时间不要太长)，捞出肉块沥干备用</p>\n</li>\n<li><p>锅中倒油，油七成热后加入加入姜片、葱段、胡椒面爆香，然后倒入肉块煸炒(注意时间不要太长，否则肉会变老)</p>\n</li>\n<li><p>倒入酱油、精盐、料酒，倒入土豆青椒和肉块一起翻炒几下</p>\n</li>\n<li><p>加入清水(高汤)刚好没过肉块，加入两小勺盐，适当的撒一点白糖，煮沸后转小火，盖上锅盖烧20分钟</p>\n</li>\n<li><p>汤锅中汤汁差不多的时候，大火收汁，撒点葱末装盘</p>\n</li>\n</ol>","more":"<h2 id=\"成品\"><a href=\"#成品\" class=\"headerlink\" title=\"成品\"></a>成品</h2><img src=\"/2017/04/19/土豆烧肉/tudou.jpg\" alt=\"土豆烧肉\" title=\"土豆烧肉\">"},{"title":"如何从外网访问家里的电脑","date":"2017-06-04T16:43:06.000Z","_content":"\n> 今天逛论坛的时候偶然间看到了电信用户可以轻松获得公网IP的一条内容，于是看了下自己的(本人用电信)路由器ip，惊喜的发现竟然是公网ip...之前都没有注意到....\n> 有了公网IP，就可以做一些好玩的事了。最直接的就是可以把自己的主机当服务器来用了，省去了购买VPS的费用，在公司或者其他地方也可以连到家里的主机，传东西什么的也很方便...\n\n<!-- more -->\n\n## 判断是否是公网IP\n\n首先要判断运营商分配给自己的IP是否是公网IP，如果没有公网IP，一切都是白搭...移动和联通的不太清楚，电信用户是可以直接获取到公网IP的。\n\n我的路由器是TP-LINK，在电脑地址栏输入路由器地址192.168.1.1，进入路由器web界面\n\n在路由设置->上网设置界面，可以看到WAN口的IP地址。\n\n{% asset_img 1.png wan %}\n\n此时，打开google，查询一下外网IP(或者直接打开http://www.ip138.com/)。\n\n{% asset_img 2.png 外网ip %}\n\n如果路由器WAN口的IP地址和查到的外网IP地址相同，可以确定这个ip地址就是运营商分配给你的公网IP，可以拿来使用。\n\nPS：我们在自己的机器上用ipconfig查询得到的IP地址，往往是路由器分配给我们主机的私有IP地址，有以下几类：\n\n10.0.0.0～10.255.255.255\n\n172.16.0.0～172.31.255.255\n\n192.168.0.0～192.168.255.255\n\n这样的IP地址是属于本地局域网的，因特网中的所有路由器，对于目的地址是上面几类的数据报一律不进行转发。所以，因特网上的机器是无法访问我们的主机的。\n\n当然，如果你没有使用路由器，而是直接把应当插在路由器WAN口的网线插在电脑上的话，ping出来的地址就直接就是公网IP...\n\n## 动态域名解析\n\n实际上，运营商每次分配给我们的公网IP是不一样的，都是从IP池里随机取的。可以重启路由器观察一下，每当你重启一次路由器之后，公网IP就会切换。\n这样就会造成一个问题：假如我们要通过公网IP来访问我们在家里的主机，但是这个IP不是固定的，随时有可能切换，我们不可能在他切换的时候感知到(其实是可以的)，即使可以，每次还要确认这个公网IP，是不是太low了？\n\n这就需要动态域名解析来解决。简单来说就是将这些公网IP映射到一个域名上，无论IP怎么切换，我们只要通过这个域名就能得到IP，并进行访问，至于域名和动态IP怎么映射，我们不必关心，只要记住这个域名就好了。\n\nTP-LINK本身有自己动态域名解析服务，还支持花生壳的动态域名解析服务。在路由器应用管理->DDNS 界面可以选择动态域名解析服务提供方，以及免费域名。我这里就选择了TP-LINK的域名解析服务，简单快捷。\n\n{% asset_img 3.png 域名解析 %}\n\n填写好域名信息并保存之后，打开控制台，ping一下这个域名。如果ping返回的响应结果ip地址就是我们的公网IP，那么动态域名配置成功。\n\n## 端口映射\n\n试想一下，连接到路由器上的设备往往不止一个，有电脑，平板，手机...路由器会为每个设备分配一个私有地址，而这些设备共享一个公网IP，大家轮换使用(NAT映射)。那么，我们要从外网访问家里的主机时，只有公网IP，如何在这众多的设备中选择出我们的主机呢？\n\n端口映射解决了这个问题。先看看怎么配置端口映射。在应用管理->虚拟服务器 中添加一行映射。\n\n{% asset_img 4.png 端口映射 %}\n\n上图中，外部端口是在外网访问我们局域网主机提供的服务时指定的端口，内部端口是局域网主机提供服务的真实端口，IP地址是要访问的局域网主机的私有IP地址，可以通过ipconfig获得，协议类型是传输层协议，一般选ALL即可。\n\n举个例子，我们想要访问局域网主机的ssh服务，ssh:yukai@debiao.tpddns.cn:8888， 8888是外部端口，路由器拿到这个端口，去查端口映射表，将请求转发到192.168.1.105的22端口，也就是内部端口，也是我们主机ssh服务的端口。这样便完成了外网与局域网主机的通信。\n\n还有一个问题，如果路由器采用DHCP的方式为局域网内的设备分配私有IP，那么这个IP往往是有时效性的，这一次你的主机是192.168.1.105，说不定过一会就自动切换到其他IP了。这样的话对我们的端口映射会有影响。可以修改路由器设置，为局域网主机分配固定的私有IP地址。\n\n进入应用管理->IP与MAC绑定，在IP与MAC映射表中，选择要绑定的IP与主机。主机的mac地址可以使用ipconfig查询。\n\n{% asset_img 5.png 静态ip %}\n\n## 效果\n\n{% asset_img 6.png web %}\n\n上图是在自己的电脑上开了一个web服务，可以看到，通过域名+端口可以访问到自己主机提供的这个服务。\n\n{% asset_img 7.png ssh %}\n\nssh的22端口映射一到8888，在外网通过域名+端口8888可以连接到主机的ssh。\n\n## 最后\n\n计划买个树莓派研究研究，在上面搭建博客或者爬虫什么的，通过上面的设置就可以直接访问树莓派啦～～美滋滋","source":"_posts/如何从外网访问家里的电脑.md","raw":"---\ntitle: 如何从外网访问家里的电脑\ndate: 2017-06-05 00:43:06\ncategories: 技术\ntags: linux\n---\n\n> 今天逛论坛的时候偶然间看到了电信用户可以轻松获得公网IP的一条内容，于是看了下自己的(本人用电信)路由器ip，惊喜的发现竟然是公网ip...之前都没有注意到....\n> 有了公网IP，就可以做一些好玩的事了。最直接的就是可以把自己的主机当服务器来用了，省去了购买VPS的费用，在公司或者其他地方也可以连到家里的主机，传东西什么的也很方便...\n\n<!-- more -->\n\n## 判断是否是公网IP\n\n首先要判断运营商分配给自己的IP是否是公网IP，如果没有公网IP，一切都是白搭...移动和联通的不太清楚，电信用户是可以直接获取到公网IP的。\n\n我的路由器是TP-LINK，在电脑地址栏输入路由器地址192.168.1.1，进入路由器web界面\n\n在路由设置->上网设置界面，可以看到WAN口的IP地址。\n\n{% asset_img 1.png wan %}\n\n此时，打开google，查询一下外网IP(或者直接打开http://www.ip138.com/)。\n\n{% asset_img 2.png 外网ip %}\n\n如果路由器WAN口的IP地址和查到的外网IP地址相同，可以确定这个ip地址就是运营商分配给你的公网IP，可以拿来使用。\n\nPS：我们在自己的机器上用ipconfig查询得到的IP地址，往往是路由器分配给我们主机的私有IP地址，有以下几类：\n\n10.0.0.0～10.255.255.255\n\n172.16.0.0～172.31.255.255\n\n192.168.0.0～192.168.255.255\n\n这样的IP地址是属于本地局域网的，因特网中的所有路由器，对于目的地址是上面几类的数据报一律不进行转发。所以，因特网上的机器是无法访问我们的主机的。\n\n当然，如果你没有使用路由器，而是直接把应当插在路由器WAN口的网线插在电脑上的话，ping出来的地址就直接就是公网IP...\n\n## 动态域名解析\n\n实际上，运营商每次分配给我们的公网IP是不一样的，都是从IP池里随机取的。可以重启路由器观察一下，每当你重启一次路由器之后，公网IP就会切换。\n这样就会造成一个问题：假如我们要通过公网IP来访问我们在家里的主机，但是这个IP不是固定的，随时有可能切换，我们不可能在他切换的时候感知到(其实是可以的)，即使可以，每次还要确认这个公网IP，是不是太low了？\n\n这就需要动态域名解析来解决。简单来说就是将这些公网IP映射到一个域名上，无论IP怎么切换，我们只要通过这个域名就能得到IP，并进行访问，至于域名和动态IP怎么映射，我们不必关心，只要记住这个域名就好了。\n\nTP-LINK本身有自己动态域名解析服务，还支持花生壳的动态域名解析服务。在路由器应用管理->DDNS 界面可以选择动态域名解析服务提供方，以及免费域名。我这里就选择了TP-LINK的域名解析服务，简单快捷。\n\n{% asset_img 3.png 域名解析 %}\n\n填写好域名信息并保存之后，打开控制台，ping一下这个域名。如果ping返回的响应结果ip地址就是我们的公网IP，那么动态域名配置成功。\n\n## 端口映射\n\n试想一下，连接到路由器上的设备往往不止一个，有电脑，平板，手机...路由器会为每个设备分配一个私有地址，而这些设备共享一个公网IP，大家轮换使用(NAT映射)。那么，我们要从外网访问家里的主机时，只有公网IP，如何在这众多的设备中选择出我们的主机呢？\n\n端口映射解决了这个问题。先看看怎么配置端口映射。在应用管理->虚拟服务器 中添加一行映射。\n\n{% asset_img 4.png 端口映射 %}\n\n上图中，外部端口是在外网访问我们局域网主机提供的服务时指定的端口，内部端口是局域网主机提供服务的真实端口，IP地址是要访问的局域网主机的私有IP地址，可以通过ipconfig获得，协议类型是传输层协议，一般选ALL即可。\n\n举个例子，我们想要访问局域网主机的ssh服务，ssh:yukai@debiao.tpddns.cn:8888， 8888是外部端口，路由器拿到这个端口，去查端口映射表，将请求转发到192.168.1.105的22端口，也就是内部端口，也是我们主机ssh服务的端口。这样便完成了外网与局域网主机的通信。\n\n还有一个问题，如果路由器采用DHCP的方式为局域网内的设备分配私有IP，那么这个IP往往是有时效性的，这一次你的主机是192.168.1.105，说不定过一会就自动切换到其他IP了。这样的话对我们的端口映射会有影响。可以修改路由器设置，为局域网主机分配固定的私有IP地址。\n\n进入应用管理->IP与MAC绑定，在IP与MAC映射表中，选择要绑定的IP与主机。主机的mac地址可以使用ipconfig查询。\n\n{% asset_img 5.png 静态ip %}\n\n## 效果\n\n{% asset_img 6.png web %}\n\n上图是在自己的电脑上开了一个web服务，可以看到，通过域名+端口可以访问到自己主机提供的这个服务。\n\n{% asset_img 7.png ssh %}\n\nssh的22端口映射一到8888，在外网通过域名+端口8888可以连接到主机的ssh。\n\n## 最后\n\n计划买个树莓派研究研究，在上面搭建博客或者爬虫什么的，通过上面的设置就可以直接访问树莓派啦～～美滋滋","slug":"如何从外网访问家里的电脑","published":1,"updated":"2017-06-04T18:03:20.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4vch4h90054x3gc61vobcd1","content":"<blockquote>\n<p>今天逛论坛的时候偶然间看到了电信用户可以轻松获得公网IP的一条内容，于是看了下自己的(本人用电信)路由器ip，惊喜的发现竟然是公网ip…之前都没有注意到….<br>有了公网IP，就可以做一些好玩的事了。最直接的就是可以把自己的主机当服务器来用了，省去了购买VPS的费用，在公司或者其他地方也可以连到家里的主机，传东西什么的也很方便…</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"判断是否是公网IP\"><a href=\"#判断是否是公网IP\" class=\"headerlink\" title=\"判断是否是公网IP\"></a>判断是否是公网IP</h2><p>首先要判断运营商分配给自己的IP是否是公网IP，如果没有公网IP，一切都是白搭…移动和联通的不太清楚，电信用户是可以直接获取到公网IP的。</p>\n<p>我的路由器是TP-LINK，在电脑地址栏输入路由器地址192.168.1.1，进入路由器web界面</p>\n<p>在路由设置-&gt;上网设置界面，可以看到WAN口的IP地址。</p>\n<img src=\"/2017/06/05/如何从外网访问家里的电脑/1.png\" alt=\"wan\" title=\"wan\">\n<p>此时，打开google，查询一下外网IP(或者直接打开<a href=\"http://www.ip138.com/)。\" target=\"_blank\" rel=\"external\">http://www.ip138.com/)。</a></p>\n<img src=\"/2017/06/05/如何从外网访问家里的电脑/2.png\" alt=\"外网ip\" title=\"外网ip\">\n<p>如果路由器WAN口的IP地址和查到的外网IP地址相同，可以确定这个ip地址就是运营商分配给你的公网IP，可以拿来使用。</p>\n<p>PS：我们在自己的机器上用ipconfig查询得到的IP地址，往往是路由器分配给我们主机的私有IP地址，有以下几类：</p>\n<p>10.0.0.0～10.255.255.255</p>\n<p>172.16.0.0～172.31.255.255</p>\n<p>192.168.0.0～192.168.255.255</p>\n<p>这样的IP地址是属于本地局域网的，因特网中的所有路由器，对于目的地址是上面几类的数据报一律不进行转发。所以，因特网上的机器是无法访问我们的主机的。</p>\n<p>当然，如果你没有使用路由器，而是直接把应当插在路由器WAN口的网线插在电脑上的话，ping出来的地址就直接就是公网IP…</p>\n<h2 id=\"动态域名解析\"><a href=\"#动态域名解析\" class=\"headerlink\" title=\"动态域名解析\"></a>动态域名解析</h2><p>实际上，运营商每次分配给我们的公网IP是不一样的，都是从IP池里随机取的。可以重启路由器观察一下，每当你重启一次路由器之后，公网IP就会切换。<br>这样就会造成一个问题：假如我们要通过公网IP来访问我们在家里的主机，但是这个IP不是固定的，随时有可能切换，我们不可能在他切换的时候感知到(其实是可以的)，即使可以，每次还要确认这个公网IP，是不是太low了？</p>\n<p>这就需要动态域名解析来解决。简单来说就是将这些公网IP映射到一个域名上，无论IP怎么切换，我们只要通过这个域名就能得到IP，并进行访问，至于域名和动态IP怎么映射，我们不必关心，只要记住这个域名就好了。</p>\n<p>TP-LINK本身有自己动态域名解析服务，还支持花生壳的动态域名解析服务。在路由器应用管理-&gt;DDNS 界面可以选择动态域名解析服务提供方，以及免费域名。我这里就选择了TP-LINK的域名解析服务，简单快捷。</p>\n<img src=\"/2017/06/05/如何从外网访问家里的电脑/3.png\" alt=\"域名解析\" title=\"域名解析\">\n<p>填写好域名信息并保存之后，打开控制台，ping一下这个域名。如果ping返回的响应结果ip地址就是我们的公网IP，那么动态域名配置成功。</p>\n<h2 id=\"端口映射\"><a href=\"#端口映射\" class=\"headerlink\" title=\"端口映射\"></a>端口映射</h2><p>试想一下，连接到路由器上的设备往往不止一个，有电脑，平板，手机…路由器会为每个设备分配一个私有地址，而这些设备共享一个公网IP，大家轮换使用(NAT映射)。那么，我们要从外网访问家里的主机时，只有公网IP，如何在这众多的设备中选择出我们的主机呢？</p>\n<p>端口映射解决了这个问题。先看看怎么配置端口映射。在应用管理-&gt;虚拟服务器 中添加一行映射。</p>\n<img src=\"/2017/06/05/如何从外网访问家里的电脑/4.png\" alt=\"端口映射\" title=\"端口映射\">\n<p>上图中，外部端口是在外网访问我们局域网主机提供的服务时指定的端口，内部端口是局域网主机提供服务的真实端口，IP地址是要访问的局域网主机的私有IP地址，可以通过ipconfig获得，协议类型是传输层协议，一般选ALL即可。</p>\n<p>举个例子，我们想要访问局域网主机的ssh服务，ssh:yukai@debiao.tpddns.cn:8888， 8888是外部端口，路由器拿到这个端口，去查端口映射表，将请求转发到192.168.1.105的22端口，也就是内部端口，也是我们主机ssh服务的端口。这样便完成了外网与局域网主机的通信。</p>\n<p>还有一个问题，如果路由器采用DHCP的方式为局域网内的设备分配私有IP，那么这个IP往往是有时效性的，这一次你的主机是192.168.1.105，说不定过一会就自动切换到其他IP了。这样的话对我们的端口映射会有影响。可以修改路由器设置，为局域网主机分配固定的私有IP地址。</p>\n<p>进入应用管理-&gt;IP与MAC绑定，在IP与MAC映射表中，选择要绑定的IP与主机。主机的mac地址可以使用ipconfig查询。</p>\n<img src=\"/2017/06/05/如何从外网访问家里的电脑/5.png\" alt=\"静态ip\" title=\"静态ip\">\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><img src=\"/2017/06/05/如何从外网访问家里的电脑/6.png\" alt=\"web\" title=\"web\">\n<p>上图是在自己的电脑上开了一个web服务，可以看到，通过域名+端口可以访问到自己主机提供的这个服务。</p>\n<img src=\"/2017/06/05/如何从外网访问家里的电脑/7.png\" alt=\"ssh\" title=\"ssh\">\n<p>ssh的22端口映射一到8888，在外网通过域名+端口8888可以连接到主机的ssh。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>计划买个树莓派研究研究，在上面搭建博客或者爬虫什么的，通过上面的设置就可以直接访问树莓派啦～～美滋滋</p>\n","excerpt":"<blockquote>\n<p>今天逛论坛的时候偶然间看到了电信用户可以轻松获得公网IP的一条内容，于是看了下自己的(本人用电信)路由器ip，惊喜的发现竟然是公网ip…之前都没有注意到….<br>有了公网IP，就可以做一些好玩的事了。最直接的就是可以把自己的主机当服务器来用了，省去了购买VPS的费用，在公司或者其他地方也可以连到家里的主机，传东西什么的也很方便…</p>\n</blockquote>","more":"<h2 id=\"判断是否是公网IP\"><a href=\"#判断是否是公网IP\" class=\"headerlink\" title=\"判断是否是公网IP\"></a>判断是否是公网IP</h2><p>首先要判断运营商分配给自己的IP是否是公网IP，如果没有公网IP，一切都是白搭…移动和联通的不太清楚，电信用户是可以直接获取到公网IP的。</p>\n<p>我的路由器是TP-LINK，在电脑地址栏输入路由器地址192.168.1.1，进入路由器web界面</p>\n<p>在路由设置-&gt;上网设置界面，可以看到WAN口的IP地址。</p>\n<img src=\"/2017/06/05/如何从外网访问家里的电脑/1.png\" alt=\"wan\" title=\"wan\">\n<p>此时，打开google，查询一下外网IP(或者直接打开<a href=\"http://www.ip138.com/)。\">http://www.ip138.com/)。</a></p>\n<img src=\"/2017/06/05/如何从外网访问家里的电脑/2.png\" alt=\"外网ip\" title=\"外网ip\">\n<p>如果路由器WAN口的IP地址和查到的外网IP地址相同，可以确定这个ip地址就是运营商分配给你的公网IP，可以拿来使用。</p>\n<p>PS：我们在自己的机器上用ipconfig查询得到的IP地址，往往是路由器分配给我们主机的私有IP地址，有以下几类：</p>\n<p>10.0.0.0～10.255.255.255</p>\n<p>172.16.0.0～172.31.255.255</p>\n<p>192.168.0.0～192.168.255.255</p>\n<p>这样的IP地址是属于本地局域网的，因特网中的所有路由器，对于目的地址是上面几类的数据报一律不进行转发。所以，因特网上的机器是无法访问我们的主机的。</p>\n<p>当然，如果你没有使用路由器，而是直接把应当插在路由器WAN口的网线插在电脑上的话，ping出来的地址就直接就是公网IP…</p>\n<h2 id=\"动态域名解析\"><a href=\"#动态域名解析\" class=\"headerlink\" title=\"动态域名解析\"></a>动态域名解析</h2><p>实际上，运营商每次分配给我们的公网IP是不一样的，都是从IP池里随机取的。可以重启路由器观察一下，每当你重启一次路由器之后，公网IP就会切换。<br>这样就会造成一个问题：假如我们要通过公网IP来访问我们在家里的主机，但是这个IP不是固定的，随时有可能切换，我们不可能在他切换的时候感知到(其实是可以的)，即使可以，每次还要确认这个公网IP，是不是太low了？</p>\n<p>这就需要动态域名解析来解决。简单来说就是将这些公网IP映射到一个域名上，无论IP怎么切换，我们只要通过这个域名就能得到IP，并进行访问，至于域名和动态IP怎么映射，我们不必关心，只要记住这个域名就好了。</p>\n<p>TP-LINK本身有自己动态域名解析服务，还支持花生壳的动态域名解析服务。在路由器应用管理-&gt;DDNS 界面可以选择动态域名解析服务提供方，以及免费域名。我这里就选择了TP-LINK的域名解析服务，简单快捷。</p>\n<img src=\"/2017/06/05/如何从外网访问家里的电脑/3.png\" alt=\"域名解析\" title=\"域名解析\">\n<p>填写好域名信息并保存之后，打开控制台，ping一下这个域名。如果ping返回的响应结果ip地址就是我们的公网IP，那么动态域名配置成功。</p>\n<h2 id=\"端口映射\"><a href=\"#端口映射\" class=\"headerlink\" title=\"端口映射\"></a>端口映射</h2><p>试想一下，连接到路由器上的设备往往不止一个，有电脑，平板，手机…路由器会为每个设备分配一个私有地址，而这些设备共享一个公网IP，大家轮换使用(NAT映射)。那么，我们要从外网访问家里的主机时，只有公网IP，如何在这众多的设备中选择出我们的主机呢？</p>\n<p>端口映射解决了这个问题。先看看怎么配置端口映射。在应用管理-&gt;虚拟服务器 中添加一行映射。</p>\n<img src=\"/2017/06/05/如何从外网访问家里的电脑/4.png\" alt=\"端口映射\" title=\"端口映射\">\n<p>上图中，外部端口是在外网访问我们局域网主机提供的服务时指定的端口，内部端口是局域网主机提供服务的真实端口，IP地址是要访问的局域网主机的私有IP地址，可以通过ipconfig获得，协议类型是传输层协议，一般选ALL即可。</p>\n<p>举个例子，我们想要访问局域网主机的ssh服务，ssh:yukai@debiao.tpddns.cn:8888， 8888是外部端口，路由器拿到这个端口，去查端口映射表，将请求转发到192.168.1.105的22端口，也就是内部端口，也是我们主机ssh服务的端口。这样便完成了外网与局域网主机的通信。</p>\n<p>还有一个问题，如果路由器采用DHCP的方式为局域网内的设备分配私有IP，那么这个IP往往是有时效性的，这一次你的主机是192.168.1.105，说不定过一会就自动切换到其他IP了。这样的话对我们的端口映射会有影响。可以修改路由器设置，为局域网主机分配固定的私有IP地址。</p>\n<p>进入应用管理-&gt;IP与MAC绑定，在IP与MAC映射表中，选择要绑定的IP与主机。主机的mac地址可以使用ipconfig查询。</p>\n<img src=\"/2017/06/05/如何从外网访问家里的电脑/5.png\" alt=\"静态ip\" title=\"静态ip\">\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><img src=\"/2017/06/05/如何从外网访问家里的电脑/6.png\" alt=\"web\" title=\"web\">\n<p>上图是在自己的电脑上开了一个web服务，可以看到，通过域名+端口可以访问到自己主机提供的这个服务。</p>\n<img src=\"/2017/06/05/如何从外网访问家里的电脑/7.png\" alt=\"ssh\" title=\"ssh\">\n<p>ssh的22端口映射一到8888，在外网通过域名+端口8888可以连接到主机的ssh。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>计划买个树莓派研究研究，在上面搭建博客或者爬虫什么的，通过上面的设置就可以直接访问树莓派啦～～美滋滋</p>"},{"layout":"post","title":"常用快捷键总结","date":"2016-03-22T08:31:55.000Z","_content":"- ## ECLIPSE:\n\n   **查看代码**\n   \n   Ctrl+O 搜索当前类变量及方法\n\n   Ctrl+H 打开搜索对话框\n\n   Ctrl+Shift+G  搜索选中变量或方法的引用\n\n   Ctrl+D 删除当前行\n\n   Ctrl+Shift+F 格式化代码\n\n   F4 查看当前类继承结构\n\n   Ctrl+Shift+R 搜索类，文件等资源\n\n   Ctrl+Shift+O 倒包\n   \n   Ctrl + 1 ：快速修复\n  \n   Ctrl + Shift + /(小键盘) ：收起左侧导航树或代码(依据当前焦点而定)\n\n   Ctrl + *(小键盘) ：展开代码\n\n   Shift + Enter ：在当前行下方插入一行空行\n\n   Alt + 向上键 ：当前行与上方行交换\n\n   Alt + 向下键 ：当前行与下方行交换\n\n   Shift + Alt + R : 重命名\n\n   Shift + Alt + L (表达式末尾)：为表达式赋值为局部变量\n\n   Shift + 向上键/向下键 : 选中此行\n\n   Shift + Alt + M : 提取选中代码为一个方法\n\n   Ctrl + . : 下一个错误\n\n   <!-- more -->\n\n   **调试**\n     \n     F5 进入方法内部\n     \n     F6 顺序执行到下一行\n     \n     F7 跳出方法，返回调用处\n     \n     F8 执行到下一个断点\n\n     Ctrl+Shift+I  查看选中表达式的值\n\n     Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法\n\n     Ctrl+R   运行到光标所在的行\n     \n- ## WINDOWS:\n   \n   ALT+TAB 切换窗口\n   \n   ALT+F4  关闭窗口\n   \n   Ctrl+L  锁定\n   \n   Windows+D 显示桌面\n   \n   Windows+E 打开我的电脑\n   \n   Windows+R 打开运行对话框\n   \n   Ctrl+Z 撤销上一步操作\n   \n   Ctrl+Y 恢复撤销的操作\n   \n   Ctrl+Shift+Esc 打开任务管理器\n\n   按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口\n   \n- ## Chorme:\n  \n   Ctrl+N 打开新窗口\n   \n   Ctrl+Tab 切换标签页\n   \n   Ctrl+L 选中网址栏\n   \n   Ctrl+T 新建标签页\n   \n   Ctrl+Shift+T 重新打开上次关闭的标签页\n   \n   Home 转至网页顶部\n   \n   Ctrl+W 关闭标签页\n   \n","source":"_posts/常用快捷键总结.md","raw":"---\nlayout: post\ntitle:  \"常用快捷键总结\"\ndate:   2016-03-22 16:31:55\ncategories: 工具\ntags: \n- 快捷键\n---\n- ## ECLIPSE:\n\n   **查看代码**\n   \n   Ctrl+O 搜索当前类变量及方法\n\n   Ctrl+H 打开搜索对话框\n\n   Ctrl+Shift+G  搜索选中变量或方法的引用\n\n   Ctrl+D 删除当前行\n\n   Ctrl+Shift+F 格式化代码\n\n   F4 查看当前类继承结构\n\n   Ctrl+Shift+R 搜索类，文件等资源\n\n   Ctrl+Shift+O 倒包\n   \n   Ctrl + 1 ：快速修复\n  \n   Ctrl + Shift + /(小键盘) ：收起左侧导航树或代码(依据当前焦点而定)\n\n   Ctrl + *(小键盘) ：展开代码\n\n   Shift + Enter ：在当前行下方插入一行空行\n\n   Alt + 向上键 ：当前行与上方行交换\n\n   Alt + 向下键 ：当前行与下方行交换\n\n   Shift + Alt + R : 重命名\n\n   Shift + Alt + L (表达式末尾)：为表达式赋值为局部变量\n\n   Shift + 向上键/向下键 : 选中此行\n\n   Shift + Alt + M : 提取选中代码为一个方法\n\n   Ctrl + . : 下一个错误\n\n   <!-- more -->\n\n   **调试**\n     \n     F5 进入方法内部\n     \n     F6 顺序执行到下一行\n     \n     F7 跳出方法，返回调用处\n     \n     F8 执行到下一个断点\n\n     Ctrl+Shift+I  查看选中表达式的值\n\n     Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法\n\n     Ctrl+R   运行到光标所在的行\n     \n- ## WINDOWS:\n   \n   ALT+TAB 切换窗口\n   \n   ALT+F4  关闭窗口\n   \n   Ctrl+L  锁定\n   \n   Windows+D 显示桌面\n   \n   Windows+E 打开我的电脑\n   \n   Windows+R 打开运行对话框\n   \n   Ctrl+Z 撤销上一步操作\n   \n   Ctrl+Y 恢复撤销的操作\n   \n   Ctrl+Shift+Esc 打开任务管理器\n\n   按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口\n   \n- ## Chorme:\n  \n   Ctrl+N 打开新窗口\n   \n   Ctrl+Tab 切换标签页\n   \n   Ctrl+L 选中网址栏\n   \n   Ctrl+T 新建标签页\n   \n   Ctrl+Shift+T 重新打开上次关闭的标签页\n   \n   Home 转至网页顶部\n   \n   Ctrl+W 关闭标签页\n   \n","slug":"常用快捷键总结","published":1,"updated":"2017-04-11T13:08:38.851Z","comments":1,"photos":[],"link":"","_id":"cj4vch4ha0058x3gc42p23pbo","content":"<ul>\n<li><h2 id=\"ECLIPSE\"><a href=\"#ECLIPSE\" class=\"headerlink\" title=\"ECLIPSE:\"></a>ECLIPSE:</h2><p> <strong>查看代码</strong></p>\n<p> Ctrl+O 搜索当前类变量及方法</p>\n<p> Ctrl+H 打开搜索对话框</p>\n<p> Ctrl+Shift+G  搜索选中变量或方法的引用</p>\n<p> Ctrl+D 删除当前行</p>\n<p> Ctrl+Shift+F 格式化代码</p>\n<p> F4 查看当前类继承结构</p>\n<p> Ctrl+Shift+R 搜索类，文件等资源</p>\n<p> Ctrl+Shift+O 倒包</p>\n<p> Ctrl + 1 ：快速修复</p>\n<p> Ctrl + Shift + /(小键盘) ：收起左侧导航树或代码(依据当前焦点而定)</p>\n<p> Ctrl + *(小键盘) ：展开代码</p>\n<p> Shift + Enter ：在当前行下方插入一行空行</p>\n<p> Alt + 向上键 ：当前行与上方行交换</p>\n<p> Alt + 向下键 ：当前行与下方行交换</p>\n<p> Shift + Alt + R : 重命名</p>\n<p> Shift + Alt + L (表达式末尾)：为表达式赋值为局部变量</p>\n<p> Shift + 向上键/向下键 : 选中此行</p>\n<p> Shift + Alt + M : 提取选中代码为一个方法</p>\n<p> Ctrl + . : 下一个错误</p>\n <a id=\"more\"></a>\n<p> <strong>调试</strong></p>\n<p>   F5 进入方法内部</p>\n<p>   F6 顺序执行到下一行</p>\n<p>   F7 跳出方法，返回调用处</p>\n<p>   F8 执行到下一个断点</p>\n<p>   Ctrl+Shift+I  查看选中表达式的值</p>\n<p>   Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法</p>\n<p>   Ctrl+R   运行到光标所在的行</p>\n</li>\n<li><h2 id=\"WINDOWS\"><a href=\"#WINDOWS\" class=\"headerlink\" title=\"WINDOWS:\"></a>WINDOWS:</h2><p> ALT+TAB 切换窗口</p>\n<p> ALT+F4  关闭窗口</p>\n<p> Ctrl+L  锁定</p>\n<p> Windows+D 显示桌面</p>\n<p> Windows+E 打开我的电脑</p>\n<p> Windows+R 打开运行对话框</p>\n<p> Ctrl+Z 撤销上一步操作</p>\n<p> Ctrl+Y 恢复撤销的操作</p>\n<p> Ctrl+Shift+Esc 打开任务管理器</p>\n<p> 按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口</p>\n</li>\n<li><h2 id=\"Chorme\"><a href=\"#Chorme\" class=\"headerlink\" title=\"Chorme:\"></a>Chorme:</h2><p> Ctrl+N 打开新窗口</p>\n<p> Ctrl+Tab 切换标签页</p>\n<p> Ctrl+L 选中网址栏</p>\n<p> Ctrl+T 新建标签页</p>\n<p> Ctrl+Shift+T 重新打开上次关闭的标签页</p>\n<p> Home 转至网页顶部</p>\n<p> Ctrl+W 关闭标签页</p>\n</li>\n</ul>\n","excerpt":"<ul>\n<li><h2 id=\"ECLIPSE\"><a href=\"#ECLIPSE\" class=\"headerlink\" title=\"ECLIPSE:\"></a>ECLIPSE:</h2><p> <strong>查看代码</strong></p>\n<p> Ctrl+O 搜索当前类变量及方法</p>\n<p> Ctrl+H 打开搜索对话框</p>\n<p> Ctrl+Shift+G  搜索选中变量或方法的引用</p>\n<p> Ctrl+D 删除当前行</p>\n<p> Ctrl+Shift+F 格式化代码</p>\n<p> F4 查看当前类继承结构</p>\n<p> Ctrl+Shift+R 搜索类，文件等资源</p>\n<p> Ctrl+Shift+O 倒包</p>\n<p> Ctrl + 1 ：快速修复</p>\n<p> Ctrl + Shift + /(小键盘) ：收起左侧导航树或代码(依据当前焦点而定)</p>\n<p> Ctrl + *(小键盘) ：展开代码</p>\n<p> Shift + Enter ：在当前行下方插入一行空行</p>\n<p> Alt + 向上键 ：当前行与上方行交换</p>\n<p> Alt + 向下键 ：当前行与下方行交换</p>\n<p> Shift + Alt + R : 重命名</p>\n<p> Shift + Alt + L (表达式末尾)：为表达式赋值为局部变量</p>\n<p> Shift + 向上键/向下键 : 选中此行</p>\n<p> Shift + Alt + M : 提取选中代码为一个方法</p>\n<p> Ctrl + . : 下一个错误</p>","more":"<p> <strong>调试</strong></p>\n<p>   F5 进入方法内部</p>\n<p>   F6 顺序执行到下一行</p>\n<p>   F7 跳出方法，返回调用处</p>\n<p>   F8 执行到下一个断点</p>\n<p>   Ctrl+Shift+I  查看选中表达式的值</p>\n<p>   Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法</p>\n<p>   Ctrl+R   运行到光标所在的行</p>\n</li>\n<li><h2 id=\"WINDOWS\"><a href=\"#WINDOWS\" class=\"headerlink\" title=\"WINDOWS:\"></a>WINDOWS:</h2><p> ALT+TAB 切换窗口</p>\n<p> ALT+F4  关闭窗口</p>\n<p> Ctrl+L  锁定</p>\n<p> Windows+D 显示桌面</p>\n<p> Windows+E 打开我的电脑</p>\n<p> Windows+R 打开运行对话框</p>\n<p> Ctrl+Z 撤销上一步操作</p>\n<p> Ctrl+Y 恢复撤销的操作</p>\n<p> Ctrl+Shift+Esc 打开任务管理器</p>\n<p> 按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口</p>\n</li>\n<li><h2 id=\"Chorme\"><a href=\"#Chorme\" class=\"headerlink\" title=\"Chorme:\"></a>Chorme:</h2><p> Ctrl+N 打开新窗口</p>\n<p> Ctrl+Tab 切换标签页</p>\n<p> Ctrl+L 选中网址栏</p>\n<p> Ctrl+T 新建标签页</p>\n<p> Ctrl+Shift+T 重新打开上次关闭的标签页</p>\n<p> Home 转至网页顶部</p>\n<p> Ctrl+W 关闭标签页</p>\n</li>\n</ul>"},{"title":"并发场景下缓存的创建","date":"2017-06-24T11:34:24.000Z","_content":"> 问题背景：\n> 现场提了一个新的需求：jdbc需要提供一个新的接口，用于查询session的执行进度。后台提供了查询视图，jdbc要做的只是在这个接口中查询这个视图，获得当前session的执行进度返回给客户。\n> 查询当前session的执行进度，说明当前session很有可能正在执行某条sql，是阻塞的。所以需要通过创建新的session并以当前session的sessionID作为条件在视图中查找当前session的执行情况。这个接口的调用在某些特定场景下是比较频繁的，比如用户每隔5秒就需要调用一次，那么每次都创建新的session去查询是不是显得太low？是不是可以在第一次查询时创建新的session，然后缓存起来，下次可以直接用？于是涉及到了缓存session的问题。（其实完全可以使用连接池来做到缓存，这次讨论的是并发场景下缓存的创建问题~~思路主要来自于《java并发编程实战》）\n\n<!-- more -->\n\n## 使用HashMap建立缓存\n\n```java\npublic class ConnCache {\n\tprivate final Map<String, Connection> cache;\n\tprivate final ConnFactory factory;\n\tpublic ConnCache(ConnFactory factory) {\n\t\tcache = new HashMap<>();\n\t\tthis.factory = factory;\n\t}\n\t\n\tpublic synchronized Connection get(String key) throws SQLException {\n\t\tConnection connection = cache.get(key);\n\t\tif (connection == null) {\n\t\t\tconnection = factory.getConn();\n\t\t\tcache.put(key, connection);\n\t\t}\n\t\treturn connection;\n\t}\n}\n\ninterface ConnFactory {\n\tConnection getConn() throws SQLException;\n}\n```\n上面的ConnFactory.getConn()创建新的session，是一个相对耗时的操作。用户需要获得session时调用ConnCache.get()方法，先从map中查找是否有对应的session(key可以设计为连接串+用户名映射到指定的session)，如果没有，那么创建一个新的session，放到map里面，然后返回。\n\n注意到整个get方法是被synchronized修饰的，因为HashMap不是线程安全的，如果有多个线程同时访问HashMap会出现[并发问题](http://coolshell.cn/articles/9606.html)。\nsynchronized确保了两个线程不会同时访问HashMap。但是这么做也有一个问题，对整个get方法同步会使访问同一ConnCache对象get方法的线程串行化，如果一个线程正在调用这个方法，那么其他想要调用get方法的线程需要排队等候，很有可能被阻塞很长时间(创建session是个耗时的动作)。这种情况是由于锁的粒度较大带来的伸缩性问题。\n\n{% asset_img 1.png 使用HashMap建立缓存 %}\n\n## 使用ConcurrentHashMap建立缓存\n\n我们很容易想到使用ConcurrentHashMap来代替HashMap，ConcurrentHashMap本身就是线程安全的，采用了分段锁的技术，并发性能相对于加锁的HashMap要好上很多。使用ConcurrentHashMap后，我们就不需要在访问底层的Map时进行同步了。\n\n```java\npublic class ConnCache {\n\tprivate final Map<String, Connection> cache;\n\tprivate final ConnFactory factory;\n\tpublic ConnCache(ConnFactory factory) {\n\t\tcache = new ConcurrentHashMap<>();\n\t\tthis.factory = factory;\n\t}\n\t\n\tpublic Connection get(String key) throws SQLException {\n\t\tConnection connection = cache.get(key);\n\t\tif (connection == null) {\n\t\t\tconnection = factory.getConn();\n\t\t\tcache.put(key, connection);\n\t\t}\n\t\treturn connection;\n\t}\n}\n\ninterface ConnFactory {\n\tConnection getConn() throws SQLException;\n}\n```\n上面这种方法相对于第一种方法，减小了锁的粒度，有着更好的并发性能。但是他也有一个严重的问题：如果一个线程在调用get方法时没有命中缓存，那么他会去创建一个新的session，然后放到map里面。如果在创建session的过程中，另一个线程也调用了get方法传入同样的key，那么就会导致重复创建的问题(这种情况很有可能出现，因为创建session是个耗时的操作)。\n\n{% asset_img 2.png 使用ConcurrentHashMap建立缓存 %}\n\n所以，我们需要某种方法来知道当前是否有其他线程在创建指定的session，如果有，则等待这个线程创建完毕，然后直接获取创建好的session。这样就能避免一次session多余的创建。\n\n这时，我们就需要FutureTask来实现这个功能。FutureTask表示一个计算过程，这个过程可能计算完成，也可能正在运行。如果计算完毕，那么调用FutureTask.get()就会立即返回结果，否则，该方法会一直阻塞，直到有结果可用。\ncategories: 生活\ntags: 食物\n## 基于FutureTask建立缓存\n\n```java\npublic class ConnCache {\n\tprivate final Map<String, Future<Connection>> cache;\n\tprivate final ConnFactory factory;\n\tpublic ConnCache(ConnFactory factory) {\n\t\tcache = new ConcurrentHashMap<>();\n\t\tthis.factory = factory;\n\t}\n\t\n\tpublic Connection get(String key) throws SQLException {\n\t\tFuture<Connection> future = cache.get(key);\n\t\tif (future == null) {\n\t\t\tCallable<Connection> eval = new Callable<Connection>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Connection call() throws Exception {\n\t\t\t\t\treturn factory.getConn();\n\t\t\t\t}\n\t\t\t};\n\t\t\tFutureTask<Connection> task = new FutureTask<>(eval);\n\t\t\tfuture = task;\n\t\t\tcache.put(key, task);\n\t\t\ttask.run();\n\t\t}\n\t\ttry {\n\t\t\treturn future.get();\n\t\t} catch (InterruptedException e) {\n\t\t\tthrow new SQLException(e);\n\t\t} catch (ExecutionException e) {\n\t\t\tthrow new SQLException(e);\n\t\t}\n\t}\n}\n\ninterface ConnFactory {categories: 生活\ntags: 食物\n\tConnection getConn() throws SQLException;\n}\n```\n与第二种方法相反，上面的方法是先检查创建session的动作是否开始(第二种方法是检查session创建是否完成)，如果已经有线程在创建指定的session，就等待其创建完毕，然后获取结果。\n\n看起来已经很完美了，但是还有一个并发缺陷: if代码块中不是原子的先检查再执行操作，两个线程很有可能同时检查到缓存为空，然后重复创建了session。\n\n{% asset_img 3.png 基于FutureTask建立缓存 %}\n\n解决这个问题的方法有一种思路：把创建好的FutureTask放入到Map这一步需要是一个原子操作，如果对应的FutureTask已经存在了，调用已存在的FutureTask.get()方法即可。\n\n## 最终的实现\n\nConcurrentHashMap提供了一个同步方法：putIfAbsent()\n\n```java\npublic class ConnCache {\n\tprivate final Map<String, Future<Connection>> cache;\n\tprivate final ConnFactory factory;\n\tpublic ConnCache(ConnFactory factory) {\n\t\tcache = new ConcurrentHashMap<>();\n\t\tthis.factory = factory;\n\t}\n\t\n\tpublic Connection get(String key) throws SQLException {\n\t\tFuture<Connection> future = cache.get(key);\n\t\tif (future == null) {\n\t\t\tCallable<Connection> eval = new Callable<Connection>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Connection call() throws Exception {\n\t\t\t\t\treturn factory.getConn();\n\t\t\t\t}\n\t\t\t};\n\t\t\tFutureTask<Connection> task = new FutureTask<>(eval);\n\t\t\tfuture = cache.putIfAbsent(key, task);\n\t\t\tif (future == null) {\n\t\t\t\tfuture = task;\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\treturn future.get();\n\t\t} catch (InterruptedException e) {\n\t\t\tcache.remove(future);\n\t\t\tthrow new SQLException(e);\n\t\t} catch (ExecutionException e) {\n\t\t\tcache.remove(future);\n\t\t\tthrow new SQLException(e);\n\t\t}\n\t}\n}\n\ninterface ConnFactory {\n\tConnection getConn() throws SQLException;\n}\n```\n\n上面的演示是对并发场景的一个思考。实际的缓存在使用中还要考虑缓存过期时间(可以在FutureTask的子类中实现)，缓存清理算法等问题。我们也可以通过泛型将上面的代码设计为一个通用的缓存框架：\n\n```java\npublic class Cache<K, V> implements Factory<K, V>{\n\tprivate final Map<K, Future<V>> cache;\n\tprivate final Factory<K,V> factory;\n\tpublic Cache(Factory<K, V> factory) {\n\t\tcache = new ConcurrentHashMap<>();\n\t\tthis.factory = factory;\n\t}\n\t\n\tpublic V get(K key) throws InterruptedException {\n\t\tFuture<V> future = cache.get(key);\n\t\tif (future == null) {\n\t\t\tCallable<V> eval = new Callable<V>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic V call() throws Exception {\n\t\t\t\t\treturn factory.get(key);\n\t\t\t\t}\n\t\t\t};\n\t\t\tFutureTask<V> task = new FutureTask<>(eval);\n\t\t\tfuture = cache.putIfAbsent(key, task);\n\t\t\tif (future == null) {\n\t\t\t\tfuture = task;\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\treturn future.get();\n\t\t} catch (ExecutionException e) {\n\t\t\tcache.remove(future);\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t}\n\n}\n\ninterface Factory<K, V> {\n\tV get(K key) throws InterruptedException;\n}\n```","source":"_posts/并发场景下缓存的创建.md","raw":"---\ntitle: 并发场景下缓存的创建\ndate: 2017-06-24 19:34:24\ncategories: 编程\ntags: \n- 多线程\n- java\n---\n> 问题背景：\n> 现场提了一个新的需求：jdbc需要提供一个新的接口，用于查询session的执行进度。后台提供了查询视图，jdbc要做的只是在这个接口中查询这个视图，获得当前session的执行进度返回给客户。\n> 查询当前session的执行进度，说明当前session很有可能正在执行某条sql，是阻塞的。所以需要通过创建新的session并以当前session的sessionID作为条件在视图中查找当前session的执行情况。这个接口的调用在某些特定场景下是比较频繁的，比如用户每隔5秒就需要调用一次，那么每次都创建新的session去查询是不是显得太low？是不是可以在第一次查询时创建新的session，然后缓存起来，下次可以直接用？于是涉及到了缓存session的问题。（其实完全可以使用连接池来做到缓存，这次讨论的是并发场景下缓存的创建问题~~思路主要来自于《java并发编程实战》）\n\n<!-- more -->\n\n## 使用HashMap建立缓存\n\n```java\npublic class ConnCache {\n\tprivate final Map<String, Connection> cache;\n\tprivate final ConnFactory factory;\n\tpublic ConnCache(ConnFactory factory) {\n\t\tcache = new HashMap<>();\n\t\tthis.factory = factory;\n\t}\n\t\n\tpublic synchronized Connection get(String key) throws SQLException {\n\t\tConnection connection = cache.get(key);\n\t\tif (connection == null) {\n\t\t\tconnection = factory.getConn();\n\t\t\tcache.put(key, connection);\n\t\t}\n\t\treturn connection;\n\t}\n}\n\ninterface ConnFactory {\n\tConnection getConn() throws SQLException;\n}\n```\n上面的ConnFactory.getConn()创建新的session，是一个相对耗时的操作。用户需要获得session时调用ConnCache.get()方法，先从map中查找是否有对应的session(key可以设计为连接串+用户名映射到指定的session)，如果没有，那么创建一个新的session，放到map里面，然后返回。\n\n注意到整个get方法是被synchronized修饰的，因为HashMap不是线程安全的，如果有多个线程同时访问HashMap会出现[并发问题](http://coolshell.cn/articles/9606.html)。\nsynchronized确保了两个线程不会同时访问HashMap。但是这么做也有一个问题，对整个get方法同步会使访问同一ConnCache对象get方法的线程串行化，如果一个线程正在调用这个方法，那么其他想要调用get方法的线程需要排队等候，很有可能被阻塞很长时间(创建session是个耗时的动作)。这种情况是由于锁的粒度较大带来的伸缩性问题。\n\n{% asset_img 1.png 使用HashMap建立缓存 %}\n\n## 使用ConcurrentHashMap建立缓存\n\n我们很容易想到使用ConcurrentHashMap来代替HashMap，ConcurrentHashMap本身就是线程安全的，采用了分段锁的技术，并发性能相对于加锁的HashMap要好上很多。使用ConcurrentHashMap后，我们就不需要在访问底层的Map时进行同步了。\n\n```java\npublic class ConnCache {\n\tprivate final Map<String, Connection> cache;\n\tprivate final ConnFactory factory;\n\tpublic ConnCache(ConnFactory factory) {\n\t\tcache = new ConcurrentHashMap<>();\n\t\tthis.factory = factory;\n\t}\n\t\n\tpublic Connection get(String key) throws SQLException {\n\t\tConnection connection = cache.get(key);\n\t\tif (connection == null) {\n\t\t\tconnection = factory.getConn();\n\t\t\tcache.put(key, connection);\n\t\t}\n\t\treturn connection;\n\t}\n}\n\ninterface ConnFactory {\n\tConnection getConn() throws SQLException;\n}\n```\n上面这种方法相对于第一种方法，减小了锁的粒度，有着更好的并发性能。但是他也有一个严重的问题：如果一个线程在调用get方法时没有命中缓存，那么他会去创建一个新的session，然后放到map里面。如果在创建session的过程中，另一个线程也调用了get方法传入同样的key，那么就会导致重复创建的问题(这种情况很有可能出现，因为创建session是个耗时的操作)。\n\n{% asset_img 2.png 使用ConcurrentHashMap建立缓存 %}\n\n所以，我们需要某种方法来知道当前是否有其他线程在创建指定的session，如果有，则等待这个线程创建完毕，然后直接获取创建好的session。这样就能避免一次session多余的创建。\n\n这时，我们就需要FutureTask来实现这个功能。FutureTask表示一个计算过程，这个过程可能计算完成，也可能正在运行。如果计算完毕，那么调用FutureTask.get()就会立即返回结果，否则，该方法会一直阻塞，直到有结果可用。\ncategories: 生活\ntags: 食物\n## 基于FutureTask建立缓存\n\n```java\npublic class ConnCache {\n\tprivate final Map<String, Future<Connection>> cache;\n\tprivate final ConnFactory factory;\n\tpublic ConnCache(ConnFactory factory) {\n\t\tcache = new ConcurrentHashMap<>();\n\t\tthis.factory = factory;\n\t}\n\t\n\tpublic Connection get(String key) throws SQLException {\n\t\tFuture<Connection> future = cache.get(key);\n\t\tif (future == null) {\n\t\t\tCallable<Connection> eval = new Callable<Connection>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Connection call() throws Exception {\n\t\t\t\t\treturn factory.getConn();\n\t\t\t\t}\n\t\t\t};\n\t\t\tFutureTask<Connection> task = new FutureTask<>(eval);\n\t\t\tfuture = task;\n\t\t\tcache.put(key, task);\n\t\t\ttask.run();\n\t\t}\n\t\ttry {\n\t\t\treturn future.get();\n\t\t} catch (InterruptedException e) {\n\t\t\tthrow new SQLException(e);\n\t\t} catch (ExecutionException e) {\n\t\t\tthrow new SQLException(e);\n\t\t}\n\t}\n}\n\ninterface ConnFactory {categories: 生活\ntags: 食物\n\tConnection getConn() throws SQLException;\n}\n```\n与第二种方法相反，上面的方法是先检查创建session的动作是否开始(第二种方法是检查session创建是否完成)，如果已经有线程在创建指定的session，就等待其创建完毕，然后获取结果。\n\n看起来已经很完美了，但是还有一个并发缺陷: if代码块中不是原子的先检查再执行操作，两个线程很有可能同时检查到缓存为空，然后重复创建了session。\n\n{% asset_img 3.png 基于FutureTask建立缓存 %}\n\n解决这个问题的方法有一种思路：把创建好的FutureTask放入到Map这一步需要是一个原子操作，如果对应的FutureTask已经存在了，调用已存在的FutureTask.get()方法即可。\n\n## 最终的实现\n\nConcurrentHashMap提供了一个同步方法：putIfAbsent()\n\n```java\npublic class ConnCache {\n\tprivate final Map<String, Future<Connection>> cache;\n\tprivate final ConnFactory factory;\n\tpublic ConnCache(ConnFactory factory) {\n\t\tcache = new ConcurrentHashMap<>();\n\t\tthis.factory = factory;\n\t}\n\t\n\tpublic Connection get(String key) throws SQLException {\n\t\tFuture<Connection> future = cache.get(key);\n\t\tif (future == null) {\n\t\t\tCallable<Connection> eval = new Callable<Connection>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Connection call() throws Exception {\n\t\t\t\t\treturn factory.getConn();\n\t\t\t\t}\n\t\t\t};\n\t\t\tFutureTask<Connection> task = new FutureTask<>(eval);\n\t\t\tfuture = cache.putIfAbsent(key, task);\n\t\t\tif (future == null) {\n\t\t\t\tfuture = task;\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\treturn future.get();\n\t\t} catch (InterruptedException e) {\n\t\t\tcache.remove(future);\n\t\t\tthrow new SQLException(e);\n\t\t} catch (ExecutionException e) {\n\t\t\tcache.remove(future);\n\t\t\tthrow new SQLException(e);\n\t\t}\n\t}\n}\n\ninterface ConnFactory {\n\tConnection getConn() throws SQLException;\n}\n```\n\n上面的演示是对并发场景的一个思考。实际的缓存在使用中还要考虑缓存过期时间(可以在FutureTask的子类中实现)，缓存清理算法等问题。我们也可以通过泛型将上面的代码设计为一个通用的缓存框架：\n\n```java\npublic class Cache<K, V> implements Factory<K, V>{\n\tprivate final Map<K, Future<V>> cache;\n\tprivate final Factory<K,V> factory;\n\tpublic Cache(Factory<K, V> factory) {\n\t\tcache = new ConcurrentHashMap<>();\n\t\tthis.factory = factory;\n\t}\n\t\n\tpublic V get(K key) throws InterruptedException {\n\t\tFuture<V> future = cache.get(key);\n\t\tif (future == null) {\n\t\t\tCallable<V> eval = new Callable<V>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic V call() throws Exception {\n\t\t\t\t\treturn factory.get(key);\n\t\t\t\t}\n\t\t\t};\n\t\t\tFutureTask<V> task = new FutureTask<>(eval);\n\t\t\tfuture = cache.putIfAbsent(key, task);\n\t\t\tif (future == null) {\n\t\t\t\tfuture = task;\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\treturn future.get();\n\t\t} catch (ExecutionException e) {\n\t\t\tcache.remove(future);\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t}\n\n}\n\ninterface Factory<K, V> {\n\tV get(K key) throws InterruptedException;\n}\n```","slug":"并发场景下缓存的创建","published":1,"updated":"2017-06-28T11:43:45.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4vch4hc005bx3gcde6sd842","content":"<blockquote>\n<p>问题背景：<br>现场提了一个新的需求：jdbc需要提供一个新的接口，用于查询session的执行进度。后台提供了查询视图，jdbc要做的只是在这个接口中查询这个视图，获得当前session的执行进度返回给客户。<br>查询当前session的执行进度，说明当前session很有可能正在执行某条sql，是阻塞的。所以需要通过创建新的session并以当前session的sessionID作为条件在视图中查找当前session的执行情况。这个接口的调用在某些特定场景下是比较频繁的，比如用户每隔5秒就需要调用一次，那么每次都创建新的session去查询是不是显得太low？是不是可以在第一次查询时创建新的session，然后缓存起来，下次可以直接用？于是涉及到了缓存session的问题。（其实完全可以使用连接池来做到缓存，这次讨论的是并发场景下缓存的创建问题~~思路主要来自于《java并发编程实战》）</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"使用HashMap建立缓存\"><a href=\"#使用HashMap建立缓存\" class=\"headerlink\" title=\"使用HashMap建立缓存\"></a>使用HashMap建立缓存</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConnCache</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Connection&gt; cache;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConnFactory factory;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConnCache</span><span class=\"params\">(ConnFactory factory)</span> </span>&#123;</div><div class=\"line\">\t\tcache = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.factory = factory;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Connection <span class=\"title\">get</span><span class=\"params\">(String key)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">\t\tConnection connection = cache.get(key);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (connection == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tconnection = factory.getConn();</div><div class=\"line\">\t\t\tcache.put(key, connection);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> connection;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConnFactory</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\">Connection <span class=\"title\">getConn</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的ConnFactory.getConn()创建新的session，是一个相对耗时的操作。用户需要获得session时调用ConnCache.get()方法，先从map中查找是否有对应的session(key可以设计为连接串+用户名映射到指定的session)，如果没有，那么创建一个新的session，放到map里面，然后返回。</p>\n<p>注意到整个get方法是被synchronized修饰的，因为HashMap不是线程安全的，如果有多个线程同时访问HashMap会出现<a href=\"http://coolshell.cn/articles/9606.html\" target=\"_blank\" rel=\"external\">并发问题</a>。<br>synchronized确保了两个线程不会同时访问HashMap。但是这么做也有一个问题，对整个get方法同步会使访问同一ConnCache对象get方法的线程串行化，如果一个线程正在调用这个方法，那么其他想要调用get方法的线程需要排队等候，很有可能被阻塞很长时间(创建session是个耗时的动作)。这种情况是由于锁的粒度较大带来的伸缩性问题。</p>\n<img src=\"/2017/06/24/并发场景下缓存的创建/1.png\" alt=\"使用HashMap建立缓存\" title=\"使用HashMap建立缓存\">\n<h2 id=\"使用ConcurrentHashMap建立缓存\"><a href=\"#使用ConcurrentHashMap建立缓存\" class=\"headerlink\" title=\"使用ConcurrentHashMap建立缓存\"></a>使用ConcurrentHashMap建立缓存</h2><p>我们很容易想到使用ConcurrentHashMap来代替HashMap，ConcurrentHashMap本身就是线程安全的，采用了分段锁的技术，并发性能相对于加锁的HashMap要好上很多。使用ConcurrentHashMap后，我们就不需要在访问底层的Map时进行同步了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConnCache</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Connection&gt; cache;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConnFactory factory;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConnCache</span><span class=\"params\">(ConnFactory factory)</span> </span>&#123;</div><div class=\"line\">\t\tcache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.factory = factory;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">get</span><span class=\"params\">(String key)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">\t\tConnection connection = cache.get(key);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (connection == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tconnection = factory.getConn();</div><div class=\"line\">\t\t\tcache.put(key, connection);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> connection;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConnFactory</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\">Connection <span class=\"title\">getConn</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这种方法相对于第一种方法，减小了锁的粒度，有着更好的并发性能。但是他也有一个严重的问题：如果一个线程在调用get方法时没有命中缓存，那么他会去创建一个新的session，然后放到map里面。如果在创建session的过程中，另一个线程也调用了get方法传入同样的key，那么就会导致重复创建的问题(这种情况很有可能出现，因为创建session是个耗时的操作)。</p>\n<img src=\"/2017/06/24/并发场景下缓存的创建/2.png\" alt=\"使用ConcurrentHashMap建立缓存\" title=\"使用ConcurrentHashMap建立缓存\">\n<p>所以，我们需要某种方法来知道当前是否有其他线程在创建指定的session，如果有，则等待这个线程创建完毕，然后直接获取创建好的session。这样就能避免一次session多余的创建。</p>\n<p>这时，我们就需要FutureTask来实现这个功能。FutureTask表示一个计算过程，这个过程可能计算完成，也可能正在运行。如果计算完毕，那么调用FutureTask.get()就会立即返回结果，否则，该方法会一直阻塞，直到有结果可用。<br>categories: 生活<br>tags: 食物</p>\n<h2 id=\"基于FutureTask建立缓存\"><a href=\"#基于FutureTask建立缓存\" class=\"headerlink\" title=\"基于FutureTask建立缓存\"></a>基于FutureTask建立缓存</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConnCache</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Future&lt;Connection&gt;&gt; cache;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConnFactory factory;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConnCache</span><span class=\"params\">(ConnFactory factory)</span> </span>&#123;</div><div class=\"line\">\t\tcache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.factory = factory;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">get</span><span class=\"params\">(String key)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">\t\tFuture&lt;Connection&gt; future = cache.get(key);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (future == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tCallable&lt;Connection&gt; eval = <span class=\"keyword\">new</span> Callable&lt;Connection&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> factory.getConn();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t\tFutureTask&lt;Connection&gt; task = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(eval);</div><div class=\"line\">\t\t\tfuture = task;</div><div class=\"line\">\t\t\tcache.put(key, task);</div><div class=\"line\">\t\t\ttask.run();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> future.get();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLException(e);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLException(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConnFactory</span> </span>&#123;categories: 生活</div><div class=\"line\">tags: 食物</div><div class=\"line\">\t<span class=\"function\">Connection <span class=\"title\">getConn</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>与第二种方法相反，上面的方法是先检查创建session的动作是否开始(第二种方法是检查session创建是否完成)，如果已经有线程在创建指定的session，就等待其创建完毕，然后获取结果。</p>\n<p>看起来已经很完美了，但是还有一个并发缺陷: if代码块中不是原子的先检查再执行操作，两个线程很有可能同时检查到缓存为空，然后重复创建了session。</p>\n<img src=\"/2017/06/24/并发场景下缓存的创建/3.png\" alt=\"基于FutureTask建立缓存\" title=\"基于FutureTask建立缓存\">\n<p>解决这个问题的方法有一种思路：把创建好的FutureTask放入到Map这一步需要是一个原子操作，如果对应的FutureTask已经存在了，调用已存在的FutureTask.get()方法即可。</p>\n<h2 id=\"最终的实现\"><a href=\"#最终的实现\" class=\"headerlink\" title=\"最终的实现\"></a>最终的实现</h2><p>ConcurrentHashMap提供了一个同步方法：putIfAbsent()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConnCache</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Future&lt;Connection&gt;&gt; cache;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConnFactory factory;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConnCache</span><span class=\"params\">(ConnFactory factory)</span> </span>&#123;</div><div class=\"line\">\t\tcache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.factory = factory;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">get</span><span class=\"params\">(String key)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">\t\tFuture&lt;Connection&gt; future = cache.get(key);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (future == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tCallable&lt;Connection&gt; eval = <span class=\"keyword\">new</span> Callable&lt;Connection&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> factory.getConn();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t\tFutureTask&lt;Connection&gt; task = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(eval);</div><div class=\"line\">\t\t\tfuture = cache.putIfAbsent(key, task);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (future == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tfuture = task;</div><div class=\"line\">\t\t\t\ttask.run();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> future.get();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\tcache.remove(future);</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLException(e);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</div><div class=\"line\">\t\t\tcache.remove(future);</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLException(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConnFactory</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\">Connection <span class=\"title\">getConn</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的演示是对并发场景的一个思考。实际的缓存在使用中还要考虑缓存过期时间(可以在FutureTask的子类中实现)，缓存清理算法等问题。我们也可以通过泛型将上面的代码设计为一个通用的缓存框架：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cache</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Factory</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt;</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K, Future&lt;V&gt;&gt; cache;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Factory&lt;K,V&gt; factory;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cache</span><span class=\"params\">(Factory&lt;K, V&gt; factory)</span> </span>&#123;</div><div class=\"line\">\t\tcache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.factory = factory;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">\t\tFuture&lt;V&gt; future = cache.get(key);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (future == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tCallable&lt;V&gt; eval = <span class=\"keyword\">new</span> Callable&lt;V&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> factory.get(key);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t\tFutureTask&lt;V&gt; task = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(eval);</div><div class=\"line\">\t\t\tfuture = cache.putIfAbsent(key, task);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (future == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tfuture = task;</div><div class=\"line\">\t\t\t\ttask.run();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> future.get();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</div><div class=\"line\">\t\t\tcache.remove(future);</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Factory</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">(K key)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"<blockquote>\n<p>问题背景：<br>现场提了一个新的需求：jdbc需要提供一个新的接口，用于查询session的执行进度。后台提供了查询视图，jdbc要做的只是在这个接口中查询这个视图，获得当前session的执行进度返回给客户。<br>查询当前session的执行进度，说明当前session很有可能正在执行某条sql，是阻塞的。所以需要通过创建新的session并以当前session的sessionID作为条件在视图中查找当前session的执行情况。这个接口的调用在某些特定场景下是比较频繁的，比如用户每隔5秒就需要调用一次，那么每次都创建新的session去查询是不是显得太low？是不是可以在第一次查询时创建新的session，然后缓存起来，下次可以直接用？于是涉及到了缓存session的问题。（其实完全可以使用连接池来做到缓存，这次讨论的是并发场景下缓存的创建问题~~思路主要来自于《java并发编程实战》）</p>\n</blockquote>","more":"<h2 id=\"使用HashMap建立缓存\"><a href=\"#使用HashMap建立缓存\" class=\"headerlink\" title=\"使用HashMap建立缓存\"></a>使用HashMap建立缓存</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConnCache</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Connection&gt; cache;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConnFactory factory;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConnCache</span><span class=\"params\">(ConnFactory factory)</span> </span>&#123;</div><div class=\"line\">\t\tcache = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.factory = factory;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Connection <span class=\"title\">get</span><span class=\"params\">(String key)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">\t\tConnection connection = cache.get(key);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (connection == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tconnection = factory.getConn();</div><div class=\"line\">\t\t\tcache.put(key, connection);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> connection;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConnFactory</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\">Connection <span class=\"title\">getConn</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的ConnFactory.getConn()创建新的session，是一个相对耗时的操作。用户需要获得session时调用ConnCache.get()方法，先从map中查找是否有对应的session(key可以设计为连接串+用户名映射到指定的session)，如果没有，那么创建一个新的session，放到map里面，然后返回。</p>\n<p>注意到整个get方法是被synchronized修饰的，因为HashMap不是线程安全的，如果有多个线程同时访问HashMap会出现<a href=\"http://coolshell.cn/articles/9606.html\">并发问题</a>。<br>synchronized确保了两个线程不会同时访问HashMap。但是这么做也有一个问题，对整个get方法同步会使访问同一ConnCache对象get方法的线程串行化，如果一个线程正在调用这个方法，那么其他想要调用get方法的线程需要排队等候，很有可能被阻塞很长时间(创建session是个耗时的动作)。这种情况是由于锁的粒度较大带来的伸缩性问题。</p>\n<img src=\"/2017/06/24/并发场景下缓存的创建/1.png\" alt=\"使用HashMap建立缓存\" title=\"使用HashMap建立缓存\">\n<h2 id=\"使用ConcurrentHashMap建立缓存\"><a href=\"#使用ConcurrentHashMap建立缓存\" class=\"headerlink\" title=\"使用ConcurrentHashMap建立缓存\"></a>使用ConcurrentHashMap建立缓存</h2><p>我们很容易想到使用ConcurrentHashMap来代替HashMap，ConcurrentHashMap本身就是线程安全的，采用了分段锁的技术，并发性能相对于加锁的HashMap要好上很多。使用ConcurrentHashMap后，我们就不需要在访问底层的Map时进行同步了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConnCache</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Connection&gt; cache;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConnFactory factory;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConnCache</span><span class=\"params\">(ConnFactory factory)</span> </span>&#123;</div><div class=\"line\">\t\tcache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.factory = factory;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">get</span><span class=\"params\">(String key)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">\t\tConnection connection = cache.get(key);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (connection == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tconnection = factory.getConn();</div><div class=\"line\">\t\t\tcache.put(key, connection);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> connection;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConnFactory</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\">Connection <span class=\"title\">getConn</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这种方法相对于第一种方法，减小了锁的粒度，有着更好的并发性能。但是他也有一个严重的问题：如果一个线程在调用get方法时没有命中缓存，那么他会去创建一个新的session，然后放到map里面。如果在创建session的过程中，另一个线程也调用了get方法传入同样的key，那么就会导致重复创建的问题(这种情况很有可能出现，因为创建session是个耗时的操作)。</p>\n<img src=\"/2017/06/24/并发场景下缓存的创建/2.png\" alt=\"使用ConcurrentHashMap建立缓存\" title=\"使用ConcurrentHashMap建立缓存\">\n<p>所以，我们需要某种方法来知道当前是否有其他线程在创建指定的session，如果有，则等待这个线程创建完毕，然后直接获取创建好的session。这样就能避免一次session多余的创建。</p>\n<p>这时，我们就需要FutureTask来实现这个功能。FutureTask表示一个计算过程，这个过程可能计算完成，也可能正在运行。如果计算完毕，那么调用FutureTask.get()就会立即返回结果，否则，该方法会一直阻塞，直到有结果可用。<br>categories: 生活<br>tags: 食物</p>\n<h2 id=\"基于FutureTask建立缓存\"><a href=\"#基于FutureTask建立缓存\" class=\"headerlink\" title=\"基于FutureTask建立缓存\"></a>基于FutureTask建立缓存</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConnCache</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Future&lt;Connection&gt;&gt; cache;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConnFactory factory;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConnCache</span><span class=\"params\">(ConnFactory factory)</span> </span>&#123;</div><div class=\"line\">\t\tcache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.factory = factory;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">get</span><span class=\"params\">(String key)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">\t\tFuture&lt;Connection&gt; future = cache.get(key);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (future == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tCallable&lt;Connection&gt; eval = <span class=\"keyword\">new</span> Callable&lt;Connection&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> factory.getConn();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t\tFutureTask&lt;Connection&gt; task = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(eval);</div><div class=\"line\">\t\t\tfuture = task;</div><div class=\"line\">\t\t\tcache.put(key, task);</div><div class=\"line\">\t\t\ttask.run();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> future.get();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLException(e);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLException(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConnFactory</span> </span>&#123;categories: 生活</div><div class=\"line\">tags: 食物</div><div class=\"line\">\t<span class=\"function\">Connection <span class=\"title\">getConn</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>与第二种方法相反，上面的方法是先检查创建session的动作是否开始(第二种方法是检查session创建是否完成)，如果已经有线程在创建指定的session，就等待其创建完毕，然后获取结果。</p>\n<p>看起来已经很完美了，但是还有一个并发缺陷: if代码块中不是原子的先检查再执行操作，两个线程很有可能同时检查到缓存为空，然后重复创建了session。</p>\n<img src=\"/2017/06/24/并发场景下缓存的创建/3.png\" alt=\"基于FutureTask建立缓存\" title=\"基于FutureTask建立缓存\">\n<p>解决这个问题的方法有一种思路：把创建好的FutureTask放入到Map这一步需要是一个原子操作，如果对应的FutureTask已经存在了，调用已存在的FutureTask.get()方法即可。</p>\n<h2 id=\"最终的实现\"><a href=\"#最终的实现\" class=\"headerlink\" title=\"最终的实现\"></a>最终的实现</h2><p>ConcurrentHashMap提供了一个同步方法：putIfAbsent()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConnCache</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Future&lt;Connection&gt;&gt; cache;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConnFactory factory;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConnCache</span><span class=\"params\">(ConnFactory factory)</span> </span>&#123;</div><div class=\"line\">\t\tcache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.factory = factory;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">get</span><span class=\"params\">(String key)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">\t\tFuture&lt;Connection&gt; future = cache.get(key);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (future == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tCallable&lt;Connection&gt; eval = <span class=\"keyword\">new</span> Callable&lt;Connection&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> factory.getConn();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t\tFutureTask&lt;Connection&gt; task = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(eval);</div><div class=\"line\">\t\t\tfuture = cache.putIfAbsent(key, task);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (future == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tfuture = task;</div><div class=\"line\">\t\t\t\ttask.run();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> future.get();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\tcache.remove(future);</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLException(e);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</div><div class=\"line\">\t\t\tcache.remove(future);</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLException(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConnFactory</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\">Connection <span class=\"title\">getConn</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的演示是对并发场景的一个思考。实际的缓存在使用中还要考虑缓存过期时间(可以在FutureTask的子类中实现)，缓存清理算法等问题。我们也可以通过泛型将上面的代码设计为一个通用的缓存框架：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cache</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Factory</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt;</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K, Future&lt;V&gt;&gt; cache;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Factory&lt;K,V&gt; factory;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cache</span><span class=\"params\">(Factory&lt;K, V&gt; factory)</span> </span>&#123;</div><div class=\"line\">\t\tcache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.factory = factory;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">\t\tFuture&lt;V&gt; future = cache.get(key);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (future == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tCallable&lt;V&gt; eval = <span class=\"keyword\">new</span> Callable&lt;V&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> factory.get(key);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t\tFutureTask&lt;V&gt; task = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(eval);</div><div class=\"line\">\t\t\tfuture = cache.putIfAbsent(key, task);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (future == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tfuture = task;</div><div class=\"line\">\t\t\t\ttask.run();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> future.get();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</div><div class=\"line\">\t\t\tcache.remove(future);</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Factory</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">(K key)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"layout":"post","title":"毕业了","date":"2016-06-30T15:48:55.000Z","_content":"<iframe \n\tframeborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\">\n</iframe>\n毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。\n\n<!-- more -->\n\n转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。\n\n但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？\n\n大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。\n\n希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。\n\n{% asset_img graduation1.jpg 毕业照 %}\n\n{% asset_img graduation2.jpg 毕设之后金客来 %}\n\n{% asset_img graduation3.jpg 跳蚤市场卖书 %}\n\n{% asset_img graduation4.jpg 去唱K %}\n\n{% asset_img graduation5.jpg 毕业照之前 %}\n\n{% asset_img graduation6.jpg 机房老师 %}\n\n{% asset_img graduation7.jpg 毕业照之前 %}\n\n{% asset_img graduation8.jpg 我和张蕾 %}\n\n\n\n\n","source":"_posts/毕业了.md","raw":"---\nlayout: post\ntitle:  \"毕业了\"\ncategories: 生活 \ndate:  2016-06-30 23:48:55\n---\n<iframe \n\tframeborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\">\n</iframe>\n毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。\n\n<!-- more -->\n\n转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。\n\n但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？\n\n大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。\n\n希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。\n\n{% asset_img graduation1.jpg 毕业照 %}\n\n{% asset_img graduation2.jpg 毕设之后金客来 %}\n\n{% asset_img graduation3.jpg 跳蚤市场卖书 %}\n\n{% asset_img graduation4.jpg 去唱K %}\n\n{% asset_img graduation5.jpg 毕业照之前 %}\n\n{% asset_img graduation6.jpg 机房老师 %}\n\n{% asset_img graduation7.jpg 毕业照之前 %}\n\n{% asset_img graduation8.jpg 我和张蕾 %}\n\n\n\n\n","slug":"毕业了","published":1,"updated":"2017-04-11T13:08:38.852Z","comments":1,"photos":[],"link":"","_id":"cj4vch4hd005fx3gcmjzj8udg","content":"<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\"><br></iframe><br>毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。</p>\n<a id=\"more\"></a>\n<p>转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。</p>\n<p>但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？</p>\n<p>大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。</p>\n<p>希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。</p>\n<img src=\"/2016/06/30/毕业了/graduation1.jpg\" alt=\"毕业照\" title=\"毕业照\">\n<img src=\"/2016/06/30/毕业了/graduation2.jpg\" alt=\"毕设之后金客来\" title=\"毕设之后金客来\">\n<img src=\"/2016/06/30/毕业了/graduation3.jpg\" alt=\"跳蚤市场卖书\" title=\"跳蚤市场卖书\">\n<img src=\"/2016/06/30/毕业了/graduation4.jpg\" alt=\"去唱K\" title=\"去唱K\">\n<img src=\"/2016/06/30/毕业了/graduation5.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation6.jpg\" alt=\"机房老师\" title=\"机房老师\">\n<img src=\"/2016/06/30/毕业了/graduation7.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation8.jpg\" alt=\"我和张蕾\" title=\"我和张蕾\">\n","excerpt":"<p><iframe \n    frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=27759600&auto=1&height=66\"><br></iframe><br>毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。</p>","more":"<p>转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。</p>\n<p>但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？</p>\n<p>大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。</p>\n<p>希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。</p>\n<img src=\"/2016/06/30/毕业了/graduation1.jpg\" alt=\"毕业照\" title=\"毕业照\">\n<img src=\"/2016/06/30/毕业了/graduation2.jpg\" alt=\"毕设之后金客来\" title=\"毕设之后金客来\">\n<img src=\"/2016/06/30/毕业了/graduation3.jpg\" alt=\"跳蚤市场卖书\" title=\"跳蚤市场卖书\">\n<img src=\"/2016/06/30/毕业了/graduation4.jpg\" alt=\"去唱K\" title=\"去唱K\">\n<img src=\"/2016/06/30/毕业了/graduation5.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation6.jpg\" alt=\"机房老师\" title=\"机房老师\">\n<img src=\"/2016/06/30/毕业了/graduation7.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation8.jpg\" alt=\"我和张蕾\" title=\"我和张蕾\">"},{"layout":"post","title":"木耳炒山药","date":"2017-04-16T12:36:36.000Z","_content":"\n> 天气越来越热了，今天炒了一个比较清淡的菜--木耳炒山药。\n\n## 原料\n\n长山药、黑木耳、青椒、食用油、鸡精、盐、淀粉、葱、蒜、胡椒面\n\n<!-- more -->\n## 做法\n\n1. 山药切片，入锅钞水后捞出备用\n\n2. 黑木耳温水浸泡\n\n3. 少量淀粉和水勾兑\n\n4. 青椒切片(我还把剩下的胡萝卜丝搁一块了)，切好葱蒜备用\n\n5. 锅内倒入少量油，油热后放入葱蒜胡椒面炸香\n\n6. 倒入钞好的山药翻炒，随后加入青椒和木耳一起翻炒\n\n7. 加入适量的盐和鸡精，随后将备勾兑好的水淀粉倒入\n\n8. 翻炒片刻，淋少许油出锅\n\n## 成品\n\n{% asset_img cai.jpg 木耳炒山药 %}\n\n\n","source":"_posts/木耳炒山药.md","raw":"---\nlayout: post\ntitle: 木耳炒山药\ndate: 2017-04-16 20:36:36\ncategories: 生活\ntags: 食物\n---\n\n> 天气越来越热了，今天炒了一个比较清淡的菜--木耳炒山药。\n\n## 原料\n\n长山药、黑木耳、青椒、食用油、鸡精、盐、淀粉、葱、蒜、胡椒面\n\n<!-- more -->\n## 做法\n\n1. 山药切片，入锅钞水后捞出备用\n\n2. 黑木耳温水浸泡\n\n3. 少量淀粉和水勾兑\n\n4. 青椒切片(我还把剩下的胡萝卜丝搁一块了)，切好葱蒜备用\n\n5. 锅内倒入少量油，油热后放入葱蒜胡椒面炸香\n\n6. 倒入钞好的山药翻炒，随后加入青椒和木耳一起翻炒\n\n7. 加入适量的盐和鸡精，随后将备勾兑好的水淀粉倒入\n\n8. 翻炒片刻，淋少许油出锅\n\n## 成品\n\n{% asset_img cai.jpg 木耳炒山药 %}\n\n\n","slug":"木耳炒山药","published":1,"updated":"2017-04-26T14:07:39.952Z","comments":1,"photos":[],"link":"","_id":"cj4vch4he005ix3gc51g2zifu","content":"<blockquote>\n<p>天气越来越热了，今天炒了一个比较清淡的菜–木耳炒山药。</p>\n</blockquote>\n<h2 id=\"原料\"><a href=\"#原料\" class=\"headerlink\" title=\"原料\"></a>原料</h2><p>长山药、黑木耳、青椒、食用油、鸡精、盐、淀粉、葱、蒜、胡椒面</p>\n<a id=\"more\"></a>\n<h2 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h2><ol>\n<li><p>山药切片，入锅钞水后捞出备用</p>\n</li>\n<li><p>黑木耳温水浸泡</p>\n</li>\n<li><p>少量淀粉和水勾兑</p>\n</li>\n<li><p>青椒切片(我还把剩下的胡萝卜丝搁一块了)，切好葱蒜备用</p>\n</li>\n<li><p>锅内倒入少量油，油热后放入葱蒜胡椒面炸香</p>\n</li>\n<li><p>倒入钞好的山药翻炒，随后加入青椒和木耳一起翻炒</p>\n</li>\n<li><p>加入适量的盐和鸡精，随后将备勾兑好的水淀粉倒入</p>\n</li>\n<li><p>翻炒片刻，淋少许油出锅</p>\n</li>\n</ol>\n<h2 id=\"成品\"><a href=\"#成品\" class=\"headerlink\" title=\"成品\"></a>成品</h2><img src=\"/2017/04/16/木耳炒山药/cai.jpg\" alt=\"木耳炒山药\" title=\"木耳炒山药\">\n","excerpt":"<blockquote>\n<p>天气越来越热了，今天炒了一个比较清淡的菜–木耳炒山药。</p>\n</blockquote>\n<h2 id=\"原料\"><a href=\"#原料\" class=\"headerlink\" title=\"原料\"></a>原料</h2><p>长山药、黑木耳、青椒、食用油、鸡精、盐、淀粉、葱、蒜、胡椒面</p>","more":"<h2 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h2><ol>\n<li><p>山药切片，入锅钞水后捞出备用</p>\n</li>\n<li><p>黑木耳温水浸泡</p>\n</li>\n<li><p>少量淀粉和水勾兑</p>\n</li>\n<li><p>青椒切片(我还把剩下的胡萝卜丝搁一块了)，切好葱蒜备用</p>\n</li>\n<li><p>锅内倒入少量油，油热后放入葱蒜胡椒面炸香</p>\n</li>\n<li><p>倒入钞好的山药翻炒，随后加入青椒和木耳一起翻炒</p>\n</li>\n<li><p>加入适量的盐和鸡精，随后将备勾兑好的水淀粉倒入</p>\n</li>\n<li><p>翻炒片刻，淋少许油出锅</p>\n</li>\n</ol>\n<h2 id=\"成品\"><a href=\"#成品\" class=\"headerlink\" title=\"成品\"></a>成品</h2><img src=\"/2017/04/16/木耳炒山药/cai.jpg\" alt=\"木耳炒山药\" title=\"木耳炒山药\">"},{"title":"建造者模式的使用","date":"2017-05-29T12:29:50.000Z","_content":"> 因为一个新项目的原因，去北京呆了半个多月，所以有好长时间没有写博客了。这段时间在写代码的过程中，学习到了建造者模式的一种用法，记录下来(设计模式在平时也会用到，网上文章多如牛毛，所以没怎么写关于设计模式这方面的日志)\n\n## 建造者模式\n\n建造者模式用来创建一个内部结构复杂的对象，拥有多个组成部分。建造者模式可以使用户无需知道这些组件的装配细节，只需要指定复杂对象的类型就可以得到该对象。\n\n有的复杂对象的组装还可能有一些限制条件，比如，某些属性必须存在，某些属性的初始化需要遵从一定的顺序等等。举一个修两层楼的比方：必须打好地基才能盖第一层楼，第一层盖好后才能盖第二层。\n\n复杂对象的创建过程被封装到一个建造者对象里面，用户可以直接使用建造者建造完毕的对象，而不必关心建造过程。\n\n{% asset_img builder.jpg builder %}\n\n<!-- more -->\n\n建造者模式包含上面几个对象：\n\nBuilder：抽象建造者\n\nConcreteBuilder：具体建造者\n\nDirector：指挥者\n\nProduct：产品角色\n\n还是用修楼那个例子来分析：\n\n**Client:**\n```java\npackage space.kyu.mode.builder;\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tBuilder builder = new OneBuilder();\n\t\tDirector director = new Director();\n\t\tdirector.build(builder);\n\t\tBuilding building = builder.getResult();\n\t\tSystem.out.println(building);\n\t}\n}\n```\n\n**Director:**\n```java\npackage space.kyu.mode.builder;\n\npublic class Director {\n\tpublic void build(Builder builder) {\n\t\tbuilder.buildFoundation();\n\t\tbuilder.buildLayer();\n\t\tbuilder.buildSecondLayer();\n\t}\n}\n```\n\n**Building:**\n```java\npackage space.kyu.mode.builder;\n\npublic class Building {\n\tprivate int foundation;//地基深度\n\tprivate int layer;//一层高度\n\tprivate int secondLayer;//二层高度\n\tpublic int getFoundation() {\n\t\treturn foundation;\n\t}\n\tpublic void setFoundation(int foundation) {\n\t\tthis.foundation = foundation;\n\t}\n\tpublic int getLayer() {\n\t\treturn layer;\n\t}\n\tpublic void setLayer(int layer) {\n\t\tthis.layer = layer;\n\t}\n\tpublic int getSecondLayer() {\n\t\treturn secondLayer;\n\t}\n\tpublic void setSecondLayer(int secondLayer) {\n\t\tthis.secondLayer = secondLayer;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Building [foundation=\" + foundation + \", layer=\" + layer\n\t\t\t\t+ \", secondLayer=\" + secondLayer + \"]\";\n\t}\n\t\n}\n\n```\n\n**Builder:**\n```java\npackage space.kyu.mode.builder;\n\ninterface Builder {\n\tvoid buildFoundation();\n\tvoid buildLayer();\n\tvoid buildSecondLayer();\n\tBuilding getResult();\n}\n```\n\n**OneBuilder:**\n```java\npackage space.kyu.mode.builder;\n\npublic class OneBuilder implements Builder {\n\tBuilding building = new Building();\n\t@Override\n\tpublic void buildFoundation() {\n\t\tbuilding.setFoundation(5);对象\n\t}\n\n\t@Override\n\tpublic void buildLayer() {\n\t\tbuilding.setLayer(3);\n\t}\n\n\t@Override\n\tpublic void buildSecondLayer() {\n\t\tbuilding.setSecondLayer(3);\n\t}\n\n\t@Override\n\tpublic Building getResult() {\n\t\treturn building;\n\t}\n\n}\n```\n\n**TwoBuilder:**\n```java\npackage space.kyu.mode.builder;\n\npublic class TwoBuilder implements Builder {\n\tBuilding building = new Building();\n\t@Override\n\tpublic void buildFoundation() {\n\t\tbuilding.setFoundation(4);\n\t}\n\n\t@Override\n\tpublic void buildLayer() {\n\t\tbuilding.setLayer(2);\n\t}\n\n\t@Override\n\tpublic void buildSecondLayer() {\n\t\tbuilding.setSecondLayer(2);\n\t}\n\n\t@Override\n\tpublic Building getResult() {\n\t\treturn building;\n\t}\n\n}\n```\n\n上面的例子中：\n\n类Client就是用户\n\n类Director就是指挥者Director\n\n类Builder就是抽象建造者Builder\n\n类Building就是产品Product\n\n类OneBuilder、TwoBuilder就是实际建造者\n\n可以看到，我们在客户端中只需要指定实际建造者，指挥类就可以为我们生成想要的产品。我们完全不需要知道这个二层小楼的建造过程，使用者与建造过程顺利解藕。并且，如果需要不同设计方案的二层小楼，我们只需要再实现一个实际建造者，并在客户端中指定即可。而且，修改一个实际建造者不会影响到其他的实现。\n\n建造者模式与工厂方法模式很类似，如果把上面的指挥类当作客户端的话，那么他基本上就是一个工厂方法模式了。\n\n建造者模式 与工厂方法模式的区别就在于增加了这个指挥类，因此建造者模式适用于创建过程更加复杂的对象。\n\n## 扩展\n\n其实这个扩展才是这篇日志的重点，是建造者模式的一种延伸，也是我在这段时间里面学习到的一种用法。\n\n这个用法一开始是在使用`org.apache.http.client.utils.URIBuilder`的时候学到的，当时用到的时候就觉得眼前一亮，马上想到了建造者模式的Builder，而且使用了流式接口，用起来很顺畅的感觉...\n\n后来看到了网上的一篇文章[设计模式（十）——建造者模式的实践](http://www.hollischuang.com/archives/1533)讲的就是这个用法，也是翻译了老外的一篇博客。原文已经分析的很好了，所以直接转载过来了。(作者的其他博客也是很通俗易懂的，值的学习)\n\n以下内容引用自[设计模式（十）——建造者模式的实践](http://www.hollischuang.com/archives/1533)\n\n-------\n我不打算深入介绍设计模式的细节内容，因为有很多这方面的文章和书籍可供参考。\n\n本文主要关注于告诉你为什么以及在什么情况下你应该考虑使用建造者模式。\n\n然而，值得一提的是本文中的模式和GOF中的提出的有点不一样。那种原生的模式主要侧重于抽象构造的过程以达到通过修改builder的实现来得到不同的结果的目的。本文中主要介绍的这种模式并没有那么复杂，因为我删除了不必要的多个构造函数、多个可选参数以及大量的setter/getter方法。\n\n假设你有一个类，其中包含大量属性。就像下面的User类一样。假设你想让这个类是不可变的。\n\n```java\npublic class User {\n    private final String firstName;    //required\n    private final String lastName;    //required\n    private final int age;    //optional\n    private final String phone;    //optional\n    private final String address;    //optional\n    ...\n}\n```\n\n在这样的类中，有一些属性是必须的（required）而另外一些是可选的（optional）。如果你想要构造这个类的实例，你会怎么做？把所有属性都设置成final类型，然后使用构造函数初始化他们嘛？但是，如果你想让这个类的调用者可以从众多的可选参数中选择自己想要的进行设置怎么办？\n\n第一个可想到的方案可能是重载多个构造函数，其中有一个只初始化必要的参数，还有一个会在初始化必要的参数同时初始化所有的可选参数，还有一些其他的构造函数介于两者之间，就是一次多初始化一个可选参数。就像下面的代码：\n\n```java\npublic User(String firstName, String lastName) {\n    this(firstName, lastName, 0);\n}\n\npublic User(String firstName, String lastName, int age) {\n    this(firstName, lastName, age, \"\");\n}\n\npublic User(String firstName, String lastName, int age, String phone) {\n    this(firstName, lastName, age, phone, \"\");\n}\n\npublic User(String firstName, String lastName, int age, String phone, String address) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n    this.phone = phone;\n    this.address = address;\n}\n```\n\n首先可以肯定的是，这样做是可以满足要求的。\n\n当然，这种方式的缺点也是很明显的。当一个类中只有几个参数的时候还好，如果一旦类中的参数逐渐增大，那么这个类就会变得很难阅读和维护。更重要的是，这样的一个类，调用者会很难使用。我到底应该使用哪个构造方法？是包含两个参数的还是包含三个参数的？如果我没有传递值的话那些属性的默认值是什么？如果我只想对address赋值而不对age和phone赋值怎么办？遇到这种情况可能我只能调用那个参数最全的构造函数，然后对于我不想要的参数值传递一个默认值。\n\n此外，如果多个参数的类型都相同那就很容易让人困惑，第一个String类型的参数到底是number还是address呢？\n\n还有没有其他方案可选择呢？我们可以遵循JaveBean规范，定义一个只包含无参数的构造方法和getter、setter方法的JavaBean。\n\n```java\npublic class User {\n    private String firstName; // required\n    private String lastName; // required\n    private int age; // optional\n    private String phone; // optional\n    private String address;  //optional\n\n    public String getFirstName() {\n        return firstName;\n    }\n    public void setFirstName(String firstName) {\n        this.firstName = firstName;\n    }\n    public String getLastName() {\n        return lastName;\n    }\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public String getPhone() {\n        return phone;\n    }\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n    public String getAddress() {\n        return address;\n    }\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n```\n\n这种方式看上去很容易阅读和维护。对于调用者来说，我只需要创建一个空的对象，然后对于我想设置的参数调用setter方法设置就好了。这难道还有什么问题吗？其实存在两个问题。第一个问题是该类的实例状态不固定。如果你想创建一个User对象，该对象的5个属性都要赋值，那么直到所有的setXX方法都被调用之前，该对象都没有一个完整的状态。这意味着在该对象状态还不完整的时候，一部分客户端程序可能看见这个对象并且以为该对象已经构造完成。\n\n这种方法的第二个不足是User类是易变的（因为没有属性是final的）。你将会失去不可变对象带来的所有优点。\n\n幸运的是应对这种场景我们有第三种选择，建造者模式。解决方案类似如下所示：\n\n```java\npublic class User {\n    private final String firstName; // required\n    private final String lastName; // required\n    private final int age; // optional\n    private final String phone; // optional\n    private final String address; // optional\n\n    private User(UserBuilder builder) {\n        this.firstName = builder.firstName;\n        this.lastName = builder.lastName;\n        this.age = builder.age;\n        this.phone = builder.phone;\n        this.address = builder.address;\n    }\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public static class UserBuilder {\n        private final String firstName;\n        private final String lastName;\n        private int age;\n        private String phone;\n        private String address;\n\n        public UserBuilder(String firstName, String lastName) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n        }\n\n        public UserBuilder age(int age) {\n            this.age = age;\n            return this;\n        }\n\n        public UserBuilder phone(String phone) {\n            this.phone = phone;\n            return this;\n        }\n\n        public UserBuilder address(String address) {\n            this.address = address;\n            return this;\n        }\n\n        public User build() {\n            return new User(this);\n        }\n\n    }\n}\n```\n\n值得注意的几个要点:\n\n>User类的构造函数是私有的，这意味着你不能在外面直接创建这个类的对象。\n\n>该类是不可变的。所有属性都是final类型的，在构造方法里面被赋值。另外，我们只为它们提供了getter方法。\n\n>builder类使用流式接口风格，让客户端代码阅读起来更容易（我们马上就会看到一个它的例子）\n\n>builder的构造方法只接收必要的参数，为了确保这些属性在构造方法里赋值，只有这些属性被定义成final类型。\n\n>使用建造者模式有在本文开始时提到的两种方法的所有优点，并且没有它们的缺点。客户端代码写起来更简单，更重要的是，更易读。我听过的关于该模式的唯一批判是你必须在builder类里面复制类的属性。然而，考虑到这个事实，builder类通常是需要建造的类的一个静态类成员，它们一起扩展起来相当容易。（译者表示没明白为设定为静态成员扩展起来就容易了。设为静态成员我认为有一个好处就是可以避免出现is not an enclosing class的编译问题，创建对象时候更加方便）\n\n现在，试图创建一个新的User对象的客户端代码看起来如何那？让我们来看一下：\n\n```java\npublic User getUser() {\n    return new\n            User.UserBuilder(\"Jhon\", \"Doe\")\n            .age(30)\n            .phone(\"1234567\")\n            .address(\"Fake address 1234\")\n            .build();\n}\n```\n\n译者注：如果UserBuilder没有设置为static的，以上代码会有编译错误。错误提示：User is not an enclosing class\n\n以上代码看上去相当整洁。我们可以只通过一行代码就可以创建一个User对象，并且这行代码也很容易读懂。除此之外，这样还能确保无论何时你想获取该类的对象都不会是不完整的（译者注：因为创建对象的过程是一气呵成的，一旦对象创建完成之后就不可修改了）。\n\n这种模式非常灵活，一个单独的builder类可以通过在调用build方法之前改变builder的属性来创建多个对象。builder类甚至可以在每次调用之间自动补全一些生成的字段，例如一个id或者序列号。\n\n值得注意的是，像构造函数一样，builder可以对参数的合法性进行检查，一旦发现参数不合法可以抛出IllegalStateException异常。\n\n但是，很重要的一点是，如果要检查参数的合法性，一定要先把参数传递给对象，然后在检查对象中的参数是否合法。其原因是因为builder并不是线程安全的。如果我们在创建真正的对象之前验证参数，参数值可能被另一个线程在参数验证完和参数被拷贝完成之间的时间修改。这段时间周期被称作“脆弱之窗”。我们的例子中情况如下：\n\n```java\npublic User build() {\n    User user = new user(this);\n    if (user.getAge() > 120) {\n        throw new IllegalStateException(“Age out of range”); // thread-safe\n    }\n    return user;\n}\n```\n上一个代码版本是线程安全的因为我们首先创建user对象，然后在不可变对象上验证条件约束。下面的代码在功能上看起来一样但是它不是线程安全的，你应该避免这么做：\n\n```java\npublic User build() {\n    if (age > 120) {\n        throw new IllegalStateException(“Age out of range”); // bad, not thread-safe\n    }\n    // This is the window of opportunity for a second thread to modify the value of age\n    return new User(this);\n}   \n```\n\n建造者模式最后的一个优点是builder可以作为参数传递给一个方法，让该方法有为客户端创建一个或者多个对象的能力，而不需要知道创建对象的任何细节。为了这么做你可能通常需要一个如下所示的简单接口：\n```java\npublic interface Builder {\n    T build();\n}\n```\n\n借用之前的User例子，UserBuilder类可以实现Builder。如此，我们可以有如下的代码：\n\nUserCollection buildUserCollection(Builder userBuilder){...}\n\n译者注：关于这这最后一个优点的部分内容并没太看懂，希望有理解的人能过不吝赐教。\n\n-------","source":"_posts/建造者模式的使用.md","raw":"---\ntitle: 建造者模式的使用\ndate: 2017-05-29 20:29:50\ncategories: 编程\ntags: java\n---\n> 因为一个新项目的原因，去北京呆了半个多月，所以有好长时间没有写博客了。这段时间在写代码的过程中，学习到了建造者模式的一种用法，记录下来(设计模式在平时也会用到，网上文章多如牛毛，所以没怎么写关于设计模式这方面的日志)\n\n## 建造者模式\n\n建造者模式用来创建一个内部结构复杂的对象，拥有多个组成部分。建造者模式可以使用户无需知道这些组件的装配细节，只需要指定复杂对象的类型就可以得到该对象。\n\n有的复杂对象的组装还可能有一些限制条件，比如，某些属性必须存在，某些属性的初始化需要遵从一定的顺序等等。举一个修两层楼的比方：必须打好地基才能盖第一层楼，第一层盖好后才能盖第二层。\n\n复杂对象的创建过程被封装到一个建造者对象里面，用户可以直接使用建造者建造完毕的对象，而不必关心建造过程。\n\n{% asset_img builder.jpg builder %}\n\n<!-- more -->\n\n建造者模式包含上面几个对象：\n\nBuilder：抽象建造者\n\nConcreteBuilder：具体建造者\n\nDirector：指挥者\n\nProduct：产品角色\n\n还是用修楼那个例子来分析：\n\n**Client:**\n```java\npackage space.kyu.mode.builder;\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tBuilder builder = new OneBuilder();\n\t\tDirector director = new Director();\n\t\tdirector.build(builder);\n\t\tBuilding building = builder.getResult();\n\t\tSystem.out.println(building);\n\t}\n}\n```\n\n**Director:**\n```java\npackage space.kyu.mode.builder;\n\npublic class Director {\n\tpublic void build(Builder builder) {\n\t\tbuilder.buildFoundation();\n\t\tbuilder.buildLayer();\n\t\tbuilder.buildSecondLayer();\n\t}\n}\n```\n\n**Building:**\n```java\npackage space.kyu.mode.builder;\n\npublic class Building {\n\tprivate int foundation;//地基深度\n\tprivate int layer;//一层高度\n\tprivate int secondLayer;//二层高度\n\tpublic int getFoundation() {\n\t\treturn foundation;\n\t}\n\tpublic void setFoundation(int foundation) {\n\t\tthis.foundation = foundation;\n\t}\n\tpublic int getLayer() {\n\t\treturn layer;\n\t}\n\tpublic void setLayer(int layer) {\n\t\tthis.layer = layer;\n\t}\n\tpublic int getSecondLayer() {\n\t\treturn secondLayer;\n\t}\n\tpublic void setSecondLayer(int secondLayer) {\n\t\tthis.secondLayer = secondLayer;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Building [foundation=\" + foundation + \", layer=\" + layer\n\t\t\t\t+ \", secondLayer=\" + secondLayer + \"]\";\n\t}\n\t\n}\n\n```\n\n**Builder:**\n```java\npackage space.kyu.mode.builder;\n\ninterface Builder {\n\tvoid buildFoundation();\n\tvoid buildLayer();\n\tvoid buildSecondLayer();\n\tBuilding getResult();\n}\n```\n\n**OneBuilder:**\n```java\npackage space.kyu.mode.builder;\n\npublic class OneBuilder implements Builder {\n\tBuilding building = new Building();\n\t@Override\n\tpublic void buildFoundation() {\n\t\tbuilding.setFoundation(5);对象\n\t}\n\n\t@Override\n\tpublic void buildLayer() {\n\t\tbuilding.setLayer(3);\n\t}\n\n\t@Override\n\tpublic void buildSecondLayer() {\n\t\tbuilding.setSecondLayer(3);\n\t}\n\n\t@Override\n\tpublic Building getResult() {\n\t\treturn building;\n\t}\n\n}\n```\n\n**TwoBuilder:**\n```java\npackage space.kyu.mode.builder;\n\npublic class TwoBuilder implements Builder {\n\tBuilding building = new Building();\n\t@Override\n\tpublic void buildFoundation() {\n\t\tbuilding.setFoundation(4);\n\t}\n\n\t@Override\n\tpublic void buildLayer() {\n\t\tbuilding.setLayer(2);\n\t}\n\n\t@Override\n\tpublic void buildSecondLayer() {\n\t\tbuilding.setSecondLayer(2);\n\t}\n\n\t@Override\n\tpublic Building getResult() {\n\t\treturn building;\n\t}\n\n}\n```\n\n上面的例子中：\n\n类Client就是用户\n\n类Director就是指挥者Director\n\n类Builder就是抽象建造者Builder\n\n类Building就是产品Product\n\n类OneBuilder、TwoBuilder就是实际建造者\n\n可以看到，我们在客户端中只需要指定实际建造者，指挥类就可以为我们生成想要的产品。我们完全不需要知道这个二层小楼的建造过程，使用者与建造过程顺利解藕。并且，如果需要不同设计方案的二层小楼，我们只需要再实现一个实际建造者，并在客户端中指定即可。而且，修改一个实际建造者不会影响到其他的实现。\n\n建造者模式与工厂方法模式很类似，如果把上面的指挥类当作客户端的话，那么他基本上就是一个工厂方法模式了。\n\n建造者模式 与工厂方法模式的区别就在于增加了这个指挥类，因此建造者模式适用于创建过程更加复杂的对象。\n\n## 扩展\n\n其实这个扩展才是这篇日志的重点，是建造者模式的一种延伸，也是我在这段时间里面学习到的一种用法。\n\n这个用法一开始是在使用`org.apache.http.client.utils.URIBuilder`的时候学到的，当时用到的时候就觉得眼前一亮，马上想到了建造者模式的Builder，而且使用了流式接口，用起来很顺畅的感觉...\n\n后来看到了网上的一篇文章[设计模式（十）——建造者模式的实践](http://www.hollischuang.com/archives/1533)讲的就是这个用法，也是翻译了老外的一篇博客。原文已经分析的很好了，所以直接转载过来了。(作者的其他博客也是很通俗易懂的，值的学习)\n\n以下内容引用自[设计模式（十）——建造者模式的实践](http://www.hollischuang.com/archives/1533)\n\n-------\n我不打算深入介绍设计模式的细节内容，因为有很多这方面的文章和书籍可供参考。\n\n本文主要关注于告诉你为什么以及在什么情况下你应该考虑使用建造者模式。\n\n然而，值得一提的是本文中的模式和GOF中的提出的有点不一样。那种原生的模式主要侧重于抽象构造的过程以达到通过修改builder的实现来得到不同的结果的目的。本文中主要介绍的这种模式并没有那么复杂，因为我删除了不必要的多个构造函数、多个可选参数以及大量的setter/getter方法。\n\n假设你有一个类，其中包含大量属性。就像下面的User类一样。假设你想让这个类是不可变的。\n\n```java\npublic class User {\n    private final String firstName;    //required\n    private final String lastName;    //required\n    private final int age;    //optional\n    private final String phone;    //optional\n    private final String address;    //optional\n    ...\n}\n```\n\n在这样的类中，有一些属性是必须的（required）而另外一些是可选的（optional）。如果你想要构造这个类的实例，你会怎么做？把所有属性都设置成final类型，然后使用构造函数初始化他们嘛？但是，如果你想让这个类的调用者可以从众多的可选参数中选择自己想要的进行设置怎么办？\n\n第一个可想到的方案可能是重载多个构造函数，其中有一个只初始化必要的参数，还有一个会在初始化必要的参数同时初始化所有的可选参数，还有一些其他的构造函数介于两者之间，就是一次多初始化一个可选参数。就像下面的代码：\n\n```java\npublic User(String firstName, String lastName) {\n    this(firstName, lastName, 0);\n}\n\npublic User(String firstName, String lastName, int age) {\n    this(firstName, lastName, age, \"\");\n}\n\npublic User(String firstName, String lastName, int age, String phone) {\n    this(firstName, lastName, age, phone, \"\");\n}\n\npublic User(String firstName, String lastName, int age, String phone, String address) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n    this.phone = phone;\n    this.address = address;\n}\n```\n\n首先可以肯定的是，这样做是可以满足要求的。\n\n当然，这种方式的缺点也是很明显的。当一个类中只有几个参数的时候还好，如果一旦类中的参数逐渐增大，那么这个类就会变得很难阅读和维护。更重要的是，这样的一个类，调用者会很难使用。我到底应该使用哪个构造方法？是包含两个参数的还是包含三个参数的？如果我没有传递值的话那些属性的默认值是什么？如果我只想对address赋值而不对age和phone赋值怎么办？遇到这种情况可能我只能调用那个参数最全的构造函数，然后对于我不想要的参数值传递一个默认值。\n\n此外，如果多个参数的类型都相同那就很容易让人困惑，第一个String类型的参数到底是number还是address呢？\n\n还有没有其他方案可选择呢？我们可以遵循JaveBean规范，定义一个只包含无参数的构造方法和getter、setter方法的JavaBean。\n\n```java\npublic class User {\n    private String firstName; // required\n    private String lastName; // required\n    private int age; // optional\n    private String phone; // optional\n    private String address;  //optional\n\n    public String getFirstName() {\n        return firstName;\n    }\n    public void setFirstName(String firstName) {\n        this.firstName = firstName;\n    }\n    public String getLastName() {\n        return lastName;\n    }\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public String getPhone() {\n        return phone;\n    }\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n    public String getAddress() {\n        return address;\n    }\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n```\n\n这种方式看上去很容易阅读和维护。对于调用者来说，我只需要创建一个空的对象，然后对于我想设置的参数调用setter方法设置就好了。这难道还有什么问题吗？其实存在两个问题。第一个问题是该类的实例状态不固定。如果你想创建一个User对象，该对象的5个属性都要赋值，那么直到所有的setXX方法都被调用之前，该对象都没有一个完整的状态。这意味着在该对象状态还不完整的时候，一部分客户端程序可能看见这个对象并且以为该对象已经构造完成。\n\n这种方法的第二个不足是User类是易变的（因为没有属性是final的）。你将会失去不可变对象带来的所有优点。\n\n幸运的是应对这种场景我们有第三种选择，建造者模式。解决方案类似如下所示：\n\n```java\npublic class User {\n    private final String firstName; // required\n    private final String lastName; // required\n    private final int age; // optional\n    private final String phone; // optional\n    private final String address; // optional\n\n    private User(UserBuilder builder) {\n        this.firstName = builder.firstName;\n        this.lastName = builder.lastName;\n        this.age = builder.age;\n        this.phone = builder.phone;\n        this.address = builder.address;\n    }\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public static class UserBuilder {\n        private final String firstName;\n        private final String lastName;\n        private int age;\n        private String phone;\n        private String address;\n\n        public UserBuilder(String firstName, String lastName) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n        }\n\n        public UserBuilder age(int age) {\n            this.age = age;\n            return this;\n        }\n\n        public UserBuilder phone(String phone) {\n            this.phone = phone;\n            return this;\n        }\n\n        public UserBuilder address(String address) {\n            this.address = address;\n            return this;\n        }\n\n        public User build() {\n            return new User(this);\n        }\n\n    }\n}\n```\n\n值得注意的几个要点:\n\n>User类的构造函数是私有的，这意味着你不能在外面直接创建这个类的对象。\n\n>该类是不可变的。所有属性都是final类型的，在构造方法里面被赋值。另外，我们只为它们提供了getter方法。\n\n>builder类使用流式接口风格，让客户端代码阅读起来更容易（我们马上就会看到一个它的例子）\n\n>builder的构造方法只接收必要的参数，为了确保这些属性在构造方法里赋值，只有这些属性被定义成final类型。\n\n>使用建造者模式有在本文开始时提到的两种方法的所有优点，并且没有它们的缺点。客户端代码写起来更简单，更重要的是，更易读。我听过的关于该模式的唯一批判是你必须在builder类里面复制类的属性。然而，考虑到这个事实，builder类通常是需要建造的类的一个静态类成员，它们一起扩展起来相当容易。（译者表示没明白为设定为静态成员扩展起来就容易了。设为静态成员我认为有一个好处就是可以避免出现is not an enclosing class的编译问题，创建对象时候更加方便）\n\n现在，试图创建一个新的User对象的客户端代码看起来如何那？让我们来看一下：\n\n```java\npublic User getUser() {\n    return new\n            User.UserBuilder(\"Jhon\", \"Doe\")\n            .age(30)\n            .phone(\"1234567\")\n            .address(\"Fake address 1234\")\n            .build();\n}\n```\n\n译者注：如果UserBuilder没有设置为static的，以上代码会有编译错误。错误提示：User is not an enclosing class\n\n以上代码看上去相当整洁。我们可以只通过一行代码就可以创建一个User对象，并且这行代码也很容易读懂。除此之外，这样还能确保无论何时你想获取该类的对象都不会是不完整的（译者注：因为创建对象的过程是一气呵成的，一旦对象创建完成之后就不可修改了）。\n\n这种模式非常灵活，一个单独的builder类可以通过在调用build方法之前改变builder的属性来创建多个对象。builder类甚至可以在每次调用之间自动补全一些生成的字段，例如一个id或者序列号。\n\n值得注意的是，像构造函数一样，builder可以对参数的合法性进行检查，一旦发现参数不合法可以抛出IllegalStateException异常。\n\n但是，很重要的一点是，如果要检查参数的合法性，一定要先把参数传递给对象，然后在检查对象中的参数是否合法。其原因是因为builder并不是线程安全的。如果我们在创建真正的对象之前验证参数，参数值可能被另一个线程在参数验证完和参数被拷贝完成之间的时间修改。这段时间周期被称作“脆弱之窗”。我们的例子中情况如下：\n\n```java\npublic User build() {\n    User user = new user(this);\n    if (user.getAge() > 120) {\n        throw new IllegalStateException(“Age out of range”); // thread-safe\n    }\n    return user;\n}\n```\n上一个代码版本是线程安全的因为我们首先创建user对象，然后在不可变对象上验证条件约束。下面的代码在功能上看起来一样但是它不是线程安全的，你应该避免这么做：\n\n```java\npublic User build() {\n    if (age > 120) {\n        throw new IllegalStateException(“Age out of range”); // bad, not thread-safe\n    }\n    // This is the window of opportunity for a second thread to modify the value of age\n    return new User(this);\n}   \n```\n\n建造者模式最后的一个优点是builder可以作为参数传递给一个方法，让该方法有为客户端创建一个或者多个对象的能力，而不需要知道创建对象的任何细节。为了这么做你可能通常需要一个如下所示的简单接口：\n```java\npublic interface Builder {\n    T build();\n}\n```\n\n借用之前的User例子，UserBuilder类可以实现Builder。如此，我们可以有如下的代码：\n\nUserCollection buildUserCollection(Builder userBuilder){...}\n\n译者注：关于这这最后一个优点的部分内容并没太看懂，希望有理解的人能过不吝赐教。\n\n-------","slug":"建造者模式的使用","published":1,"updated":"2017-05-29T14:54:49.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4vch4hf005lx3gcejozbob7","content":"<blockquote>\n<p>因为一个新项目的原因，去北京呆了半个多月，所以有好长时间没有写博客了。这段时间在写代码的过程中，学习到了建造者模式的一种用法，记录下来(设计模式在平时也会用到，网上文章多如牛毛，所以没怎么写关于设计模式这方面的日志)</p>\n</blockquote>\n<h2 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h2><p>建造者模式用来创建一个内部结构复杂的对象，拥有多个组成部分。建造者模式可以使用户无需知道这些组件的装配细节，只需要指定复杂对象的类型就可以得到该对象。</p>\n<p>有的复杂对象的组装还可能有一些限制条件，比如，某些属性必须存在，某些属性的初始化需要遵从一定的顺序等等。举一个修两层楼的比方：必须打好地基才能盖第一层楼，第一层盖好后才能盖第二层。</p>\n<p>复杂对象的创建过程被封装到一个建造者对象里面，用户可以直接使用建造者建造完毕的对象，而不必关心建造过程。</p>\n<img src=\"/2017/05/29/建造者模式的使用/builder.jpg\" alt=\"builder\" title=\"builder\">\n<a id=\"more\"></a>\n<p>建造者模式包含上面几个对象：</p>\n<p>Builder：抽象建造者</p>\n<p>ConcreteBuilder：具体建造者</p>\n<p>Director：指挥者</p>\n<p>Product：产品角色</p>\n<p>还是用修楼那个例子来分析：</p>\n<p><strong>Client:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> space.kyu.mode.builder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tBuilder builder = <span class=\"keyword\">new</span> OneBuilder();</div><div class=\"line\">\t\tDirector director = <span class=\"keyword\">new</span> Director();</div><div class=\"line\">\t\tdirector.build(builder);</div><div class=\"line\">\t\tBuilding building = builder.getResult();</div><div class=\"line\">\t\tSystem.out.println(building);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>Director:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> space.kyu.mode.builder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Director</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(Builder builder)</span> </span>&#123;</div><div class=\"line\">\t\tbuilder.buildFoundation();</div><div class=\"line\">\t\tbuilder.buildLayer();</div><div class=\"line\">\t\tbuilder.buildSecondLayer();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>Building:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> space.kyu.mode.builder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Building</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> foundation;<span class=\"comment\">//地基深度</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> layer;<span class=\"comment\">//一层高度</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> secondLayer;<span class=\"comment\">//二层高度</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getFoundation</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> foundation;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFoundation</span><span class=\"params\">(<span class=\"keyword\">int</span> foundation)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.foundation = foundation;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getLayer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> layer;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLayer</span><span class=\"params\">(<span class=\"keyword\">int</span> layer)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.layer = layer;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSecondLayer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> secondLayer;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSecondLayer</span><span class=\"params\">(<span class=\"keyword\">int</span> secondLayer)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.secondLayer = secondLayer;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Building [foundation=\"</span> + foundation + <span class=\"string\">\", layer=\"</span> + layer</div><div class=\"line\">\t\t\t\t+ <span class=\"string\">\", secondLayer=\"</span> + secondLayer + <span class=\"string\">\"]\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>Builder:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> space.kyu.mode.builder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">buildFoundation</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">buildLayer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">buildSecondLayer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t<span class=\"function\">Building <span class=\"title\">getResult</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>OneBuilder:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> space.kyu.mode.builder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OneBuilder</span> <span class=\"keyword\">implements</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\">\tBuilding building = <span class=\"keyword\">new</span> Building();</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildFoundation</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tbuilding.setFoundation(<span class=\"number\">5</span>);对象</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildLayer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tbuilding.setLayer(<span class=\"number\">3</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildSecondLayer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tbuilding.setSecondLayer(<span class=\"number\">3</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Building <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> building;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>TwoBuilder:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> space.kyu.mode.builder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TwoBuilder</span> <span class=\"keyword\">implements</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\">\tBuilding building = <span class=\"keyword\">new</span> Building();</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildFoundation</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tbuilding.setFoundation(<span class=\"number\">4</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildLayer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tbuilding.setLayer(<span class=\"number\">2</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildSecondLayer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tbuilding.setSecondLayer(<span class=\"number\">2</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Building <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> building;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的例子中：</p>\n<p>类Client就是用户</p>\n<p>类Director就是指挥者Director</p>\n<p>类Builder就是抽象建造者Builder</p>\n<p>类Building就是产品Product</p>\n<p>类OneBuilder、TwoBuilder就是实际建造者</p>\n<p>可以看到，我们在客户端中只需要指定实际建造者，指挥类就可以为我们生成想要的产品。我们完全不需要知道这个二层小楼的建造过程，使用者与建造过程顺利解藕。并且，如果需要不同设计方案的二层小楼，我们只需要再实现一个实际建造者，并在客户端中指定即可。而且，修改一个实际建造者不会影响到其他的实现。</p>\n<p>建造者模式与工厂方法模式很类似，如果把上面的指挥类当作客户端的话，那么他基本上就是一个工厂方法模式了。</p>\n<p>建造者模式 与工厂方法模式的区别就在于增加了这个指挥类，因此建造者模式适用于创建过程更加复杂的对象。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>其实这个扩展才是这篇日志的重点，是建造者模式的一种延伸，也是我在这段时间里面学习到的一种用法。</p>\n<p>这个用法一开始是在使用<code>org.apache.http.client.utils.URIBuilder</code>的时候学到的，当时用到的时候就觉得眼前一亮，马上想到了建造者模式的Builder，而且使用了流式接口，用起来很顺畅的感觉…</p>\n<p>后来看到了网上的一篇文章<a href=\"http://www.hollischuang.com/archives/1533\" target=\"_blank\" rel=\"external\">设计模式（十）——建造者模式的实践</a>讲的就是这个用法，也是翻译了老外的一篇博客。原文已经分析的很好了，所以直接转载过来了。(作者的其他博客也是很通俗易懂的，值的学习)</p>\n<p>以下内容引用自<a href=\"http://www.hollischuang.com/archives/1533\" target=\"_blank\" rel=\"external\">设计模式（十）——建造者模式的实践</a></p>\n<hr>\n<p>我不打算深入介绍设计模式的细节内容，因为有很多这方面的文章和书籍可供参考。</p>\n<p>本文主要关注于告诉你为什么以及在什么情况下你应该考虑使用建造者模式。</p>\n<p>然而，值得一提的是本文中的模式和GOF中的提出的有点不一样。那种原生的模式主要侧重于抽象构造的过程以达到通过修改builder的实现来得到不同的结果的目的。本文中主要介绍的这种模式并没有那么复杂，因为我删除了不必要的多个构造函数、多个可选参数以及大量的setter/getter方法。</p>\n<p>假设你有一个类，其中包含大量属性。就像下面的User类一样。假设你想让这个类是不可变的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String firstName;    <span class=\"comment\">//required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String lastName;    <span class=\"comment\">//required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age;    <span class=\"comment\">//optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String phone;    <span class=\"comment\">//optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String address;    <span class=\"comment\">//optional</span></div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这样的类中，有一些属性是必须的（required）而另外一些是可选的（optional）。如果你想要构造这个类的实例，你会怎么做？把所有属性都设置成final类型，然后使用构造函数初始化他们嘛？但是，如果你想让这个类的调用者可以从众多的可选参数中选择自己想要的进行设置怎么办？</p>\n<p>第一个可想到的方案可能是重载多个构造函数，其中有一个只初始化必要的参数，还有一个会在初始化必要的参数同时初始化所有的可选参数，还有一些其他的构造函数介于两者之间，就是一次多初始化一个可选参数。就像下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String firstName, String lastName)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(firstName, lastName, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String firstName, String lastName, <span class=\"keyword\">int</span> age)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(firstName, lastName, age, <span class=\"string\">\"\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String firstName, String lastName, <span class=\"keyword\">int</span> age, String phone)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(firstName, lastName, age, phone, <span class=\"string\">\"\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String firstName, String lastName, <span class=\"keyword\">int</span> age, String phone, String address)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.firstName = firstName;</div><div class=\"line\">    <span class=\"keyword\">this</span>.lastName = lastName;</div><div class=\"line\">    <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">    <span class=\"keyword\">this</span>.phone = phone;</div><div class=\"line\">    <span class=\"keyword\">this</span>.address = address;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先可以肯定的是，这样做是可以满足要求的。</p>\n<p>当然，这种方式的缺点也是很明显的。当一个类中只有几个参数的时候还好，如果一旦类中的参数逐渐增大，那么这个类就会变得很难阅读和维护。更重要的是，这样的一个类，调用者会很难使用。我到底应该使用哪个构造方法？是包含两个参数的还是包含三个参数的？如果我没有传递值的话那些属性的默认值是什么？如果我只想对address赋值而不对age和phone赋值怎么办？遇到这种情况可能我只能调用那个参数最全的构造函数，然后对于我不想要的参数值传递一个默认值。</p>\n<p>此外，如果多个参数的类型都相同那就很容易让人困惑，第一个String类型的参数到底是number还是address呢？</p>\n<p>还有没有其他方案可选择呢？我们可以遵循JaveBean规范，定义一个只包含无参数的构造方法和getter、setter方法的JavaBean。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> String firstName; <span class=\"comment\">// required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String lastName; <span class=\"comment\">// required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age; <span class=\"comment\">// optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String phone; <span class=\"comment\">// optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String address;  <span class=\"comment\">//optional</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getFirstName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> firstName;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFirstName</span><span class=\"params\">(String firstName)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.firstName = firstName;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLastName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> lastName;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLastName</span><span class=\"params\">(String lastName)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.lastName = lastName;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> age;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPhone</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> phone;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPhone</span><span class=\"params\">(String phone)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.phone = phone;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAddress</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> address;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAddress</span><span class=\"params\">(String address)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.address = address;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方式看上去很容易阅读和维护。对于调用者来说，我只需要创建一个空的对象，然后对于我想设置的参数调用setter方法设置就好了。这难道还有什么问题吗？其实存在两个问题。第一个问题是该类的实例状态不固定。如果你想创建一个User对象，该对象的5个属性都要赋值，那么直到所有的setXX方法都被调用之前，该对象都没有一个完整的状态。这意味着在该对象状态还不完整的时候，一部分客户端程序可能看见这个对象并且以为该对象已经构造完成。</p>\n<p>这种方法的第二个不足是User类是易变的（因为没有属性是final的）。你将会失去不可变对象带来的所有优点。</p>\n<p>幸运的是应对这种场景我们有第三种选择，建造者模式。解决方案类似如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String firstName; <span class=\"comment\">// required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String lastName; <span class=\"comment\">// required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age; <span class=\"comment\">// optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String phone; <span class=\"comment\">// optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String address; <span class=\"comment\">// optional</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">User</span><span class=\"params\">(UserBuilder builder)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.firstName = builder.firstName;</div><div class=\"line\">        <span class=\"keyword\">this</span>.lastName = builder.lastName;</div><div class=\"line\">        <span class=\"keyword\">this</span>.age = builder.age;</div><div class=\"line\">        <span class=\"keyword\">this</span>.phone = builder.phone;</div><div class=\"line\">        <span class=\"keyword\">this</span>.address = builder.address;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getFirstName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> firstName;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLastName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> lastName;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> age;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPhone</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> phone;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAddress</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> address;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserBuilder</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String firstName;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String lastName;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</div><div class=\"line\">        <span class=\"keyword\">private</span> String phone;</div><div class=\"line\">        <span class=\"keyword\">private</span> String address;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserBuilder</span><span class=\"params\">(String firstName, String lastName)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.firstName = firstName;</div><div class=\"line\">            <span class=\"keyword\">this</span>.lastName = lastName;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> UserBuilder <span class=\"title\">age</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> UserBuilder <span class=\"title\">phone</span><span class=\"params\">(String phone)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.phone = phone;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> UserBuilder <span class=\"title\">address</span><span class=\"params\">(String address)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.address = address;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>值得注意的几个要点:</p>\n<blockquote>\n<p>User类的构造函数是私有的，这意味着你不能在外面直接创建这个类的对象。</p>\n<p>该类是不可变的。所有属性都是final类型的，在构造方法里面被赋值。另外，我们只为它们提供了getter方法。</p>\n<p>builder类使用流式接口风格，让客户端代码阅读起来更容易（我们马上就会看到一个它的例子）</p>\n<p>builder的构造方法只接收必要的参数，为了确保这些属性在构造方法里赋值，只有这些属性被定义成final类型。</p>\n<p>使用建造者模式有在本文开始时提到的两种方法的所有优点，并且没有它们的缺点。客户端代码写起来更简单，更重要的是，更易读。我听过的关于该模式的唯一批判是你必须在builder类里面复制类的属性。然而，考虑到这个事实，builder类通常是需要建造的类的一个静态类成员，它们一起扩展起来相当容易。（译者表示没明白为设定为静态成员扩展起来就容易了。设为静态成员我认为有一个好处就是可以避免出现is not an enclosing class的编译问题，创建对象时候更加方便）</p>\n</blockquote>\n<p>现在，试图创建一个新的User对象的客户端代码看起来如何那？让我们来看一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUser</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span></div><div class=\"line\">            User.UserBuilder(<span class=\"string\">\"Jhon\"</span>, <span class=\"string\">\"Doe\"</span>)</div><div class=\"line\">            .age(<span class=\"number\">30</span>)</div><div class=\"line\">            .phone(<span class=\"string\">\"1234567\"</span>)</div><div class=\"line\">            .address(<span class=\"string\">\"Fake address 1234\"</span>)</div><div class=\"line\">            .build();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>译者注：如果UserBuilder没有设置为static的，以上代码会有编译错误。错误提示：User is not an enclosing class</p>\n<p>以上代码看上去相当整洁。我们可以只通过一行代码就可以创建一个User对象，并且这行代码也很容易读懂。除此之外，这样还能确保无论何时你想获取该类的对象都不会是不完整的（译者注：因为创建对象的过程是一气呵成的，一旦对象创建完成之后就不可修改了）。</p>\n<p>这种模式非常灵活，一个单独的builder类可以通过在调用build方法之前改变builder的属性来创建多个对象。builder类甚至可以在每次调用之间自动补全一些生成的字段，例如一个id或者序列号。</p>\n<p>值得注意的是，像构造函数一样，builder可以对参数的合法性进行检查，一旦发现参数不合法可以抛出IllegalStateException异常。</p>\n<p>但是，很重要的一点是，如果要检查参数的合法性，一定要先把参数传递给对象，然后在检查对象中的参数是否合法。其原因是因为builder并不是线程安全的。如果我们在创建真正的对象之前验证参数，参数值可能被另一个线程在参数验证完和参数被拷贝完成之间的时间修改。这段时间周期被称作“脆弱之窗”。我们的例子中情况如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    User user = <span class=\"keyword\">new</span> user(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (user.getAge() &gt; <span class=\"number\">120</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(“Age out of range”); <span class=\"comment\">// thread-safe</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> user;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上一个代码版本是线程安全的因为我们首先创建user对象，然后在不可变对象上验证条件约束。下面的代码在功能上看起来一样但是它不是线程安全的，你应该避免这么做：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (age &gt; <span class=\"number\">120</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(“Age out of range”); <span class=\"comment\">// bad, not thread-safe</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// This is the window of opportunity for a second thread to modify the value of age</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>建造者模式最后的一个优点是builder可以作为参数传递给一个方法，让该方法有为客户端创建一个或者多个对象的能力，而不需要知道创建对象的任何细节。为了这么做你可能通常需要一个如下所示的简单接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\">T <span class=\"title\">build</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>借用之前的User例子，UserBuilder类可以实现Builder。如此，我们可以有如下的代码：</p>\n<p>UserCollection buildUserCollection(Builder userBuilder){…}</p>\n<p>译者注：关于这这最后一个优点的部分内容并没太看懂，希望有理解的人能过不吝赐教。</p>\n<hr>\n","excerpt":"<blockquote>\n<p>因为一个新项目的原因，去北京呆了半个多月，所以有好长时间没有写博客了。这段时间在写代码的过程中，学习到了建造者模式的一种用法，记录下来(设计模式在平时也会用到，网上文章多如牛毛，所以没怎么写关于设计模式这方面的日志)</p>\n</blockquote>\n<h2 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h2><p>建造者模式用来创建一个内部结构复杂的对象，拥有多个组成部分。建造者模式可以使用户无需知道这些组件的装配细节，只需要指定复杂对象的类型就可以得到该对象。</p>\n<p>有的复杂对象的组装还可能有一些限制条件，比如，某些属性必须存在，某些属性的初始化需要遵从一定的顺序等等。举一个修两层楼的比方：必须打好地基才能盖第一层楼，第一层盖好后才能盖第二层。</p>\n<p>复杂对象的创建过程被封装到一个建造者对象里面，用户可以直接使用建造者建造完毕的对象，而不必关心建造过程。</p>\n<img src=\"/2017/05/29/建造者模式的使用/builder.jpg\" alt=\"builder\" title=\"builder\">","more":"<p>建造者模式包含上面几个对象：</p>\n<p>Builder：抽象建造者</p>\n<p>ConcreteBuilder：具体建造者</p>\n<p>Director：指挥者</p>\n<p>Product：产品角色</p>\n<p>还是用修楼那个例子来分析：</p>\n<p><strong>Client:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> space.kyu.mode.builder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tBuilder builder = <span class=\"keyword\">new</span> OneBuilder();</div><div class=\"line\">\t\tDirector director = <span class=\"keyword\">new</span> Director();</div><div class=\"line\">\t\tdirector.build(builder);</div><div class=\"line\">\t\tBuilding building = builder.getResult();</div><div class=\"line\">\t\tSystem.out.println(building);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>Director:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> space.kyu.mode.builder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Director</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(Builder builder)</span> </span>&#123;</div><div class=\"line\">\t\tbuilder.buildFoundation();</div><div class=\"line\">\t\tbuilder.buildLayer();</div><div class=\"line\">\t\tbuilder.buildSecondLayer();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>Building:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> space.kyu.mode.builder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Building</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> foundation;<span class=\"comment\">//地基深度</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> layer;<span class=\"comment\">//一层高度</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> secondLayer;<span class=\"comment\">//二层高度</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getFoundation</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> foundation;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFoundation</span><span class=\"params\">(<span class=\"keyword\">int</span> foundation)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.foundation = foundation;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getLayer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> layer;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLayer</span><span class=\"params\">(<span class=\"keyword\">int</span> layer)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.layer = layer;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSecondLayer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> secondLayer;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSecondLayer</span><span class=\"params\">(<span class=\"keyword\">int</span> secondLayer)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.secondLayer = secondLayer;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Building [foundation=\"</span> + foundation + <span class=\"string\">\", layer=\"</span> + layer</div><div class=\"line\">\t\t\t\t+ <span class=\"string\">\", secondLayer=\"</span> + secondLayer + <span class=\"string\">\"]\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>Builder:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> space.kyu.mode.builder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">buildFoundation</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">buildLayer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">buildSecondLayer</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t<span class=\"function\">Building <span class=\"title\">getResult</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>OneBuilder:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> space.kyu.mode.builder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OneBuilder</span> <span class=\"keyword\">implements</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\">\tBuilding building = <span class=\"keyword\">new</span> Building();</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildFoundation</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tbuilding.setFoundation(<span class=\"number\">5</span>);对象</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildLayer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tbuilding.setLayer(<span class=\"number\">3</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildSecondLayer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tbuilding.setSecondLayer(<span class=\"number\">3</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Building <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> building;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>TwoBuilder:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> space.kyu.mode.builder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TwoBuilder</span> <span class=\"keyword\">implements</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\">\tBuilding building = <span class=\"keyword\">new</span> Building();</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildFoundation</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tbuilding.setFoundation(<span class=\"number\">4</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildLayer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tbuilding.setLayer(<span class=\"number\">2</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildSecondLayer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tbuilding.setSecondLayer(<span class=\"number\">2</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Building <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> building;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的例子中：</p>\n<p>类Client就是用户</p>\n<p>类Director就是指挥者Director</p>\n<p>类Builder就是抽象建造者Builder</p>\n<p>类Building就是产品Product</p>\n<p>类OneBuilder、TwoBuilder就是实际建造者</p>\n<p>可以看到，我们在客户端中只需要指定实际建造者，指挥类就可以为我们生成想要的产品。我们完全不需要知道这个二层小楼的建造过程，使用者与建造过程顺利解藕。并且，如果需要不同设计方案的二层小楼，我们只需要再实现一个实际建造者，并在客户端中指定即可。而且，修改一个实际建造者不会影响到其他的实现。</p>\n<p>建造者模式与工厂方法模式很类似，如果把上面的指挥类当作客户端的话，那么他基本上就是一个工厂方法模式了。</p>\n<p>建造者模式 与工厂方法模式的区别就在于增加了这个指挥类，因此建造者模式适用于创建过程更加复杂的对象。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>其实这个扩展才是这篇日志的重点，是建造者模式的一种延伸，也是我在这段时间里面学习到的一种用法。</p>\n<p>这个用法一开始是在使用<code>org.apache.http.client.utils.URIBuilder</code>的时候学到的，当时用到的时候就觉得眼前一亮，马上想到了建造者模式的Builder，而且使用了流式接口，用起来很顺畅的感觉…</p>\n<p>后来看到了网上的一篇文章<a href=\"http://www.hollischuang.com/archives/1533\">设计模式（十）——建造者模式的实践</a>讲的就是这个用法，也是翻译了老外的一篇博客。原文已经分析的很好了，所以直接转载过来了。(作者的其他博客也是很通俗易懂的，值的学习)</p>\n<p>以下内容引用自<a href=\"http://www.hollischuang.com/archives/1533\">设计模式（十）——建造者模式的实践</a></p>\n<hr>\n<p>我不打算深入介绍设计模式的细节内容，因为有很多这方面的文章和书籍可供参考。</p>\n<p>本文主要关注于告诉你为什么以及在什么情况下你应该考虑使用建造者模式。</p>\n<p>然而，值得一提的是本文中的模式和GOF中的提出的有点不一样。那种原生的模式主要侧重于抽象构造的过程以达到通过修改builder的实现来得到不同的结果的目的。本文中主要介绍的这种模式并没有那么复杂，因为我删除了不必要的多个构造函数、多个可选参数以及大量的setter/getter方法。</p>\n<p>假设你有一个类，其中包含大量属性。就像下面的User类一样。假设你想让这个类是不可变的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String firstName;    <span class=\"comment\">//required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String lastName;    <span class=\"comment\">//required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age;    <span class=\"comment\">//optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String phone;    <span class=\"comment\">//optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String address;    <span class=\"comment\">//optional</span></div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这样的类中，有一些属性是必须的（required）而另外一些是可选的（optional）。如果你想要构造这个类的实例，你会怎么做？把所有属性都设置成final类型，然后使用构造函数初始化他们嘛？但是，如果你想让这个类的调用者可以从众多的可选参数中选择自己想要的进行设置怎么办？</p>\n<p>第一个可想到的方案可能是重载多个构造函数，其中有一个只初始化必要的参数，还有一个会在初始化必要的参数同时初始化所有的可选参数，还有一些其他的构造函数介于两者之间，就是一次多初始化一个可选参数。就像下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String firstName, String lastName)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(firstName, lastName, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String firstName, String lastName, <span class=\"keyword\">int</span> age)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(firstName, lastName, age, <span class=\"string\">\"\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String firstName, String lastName, <span class=\"keyword\">int</span> age, String phone)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(firstName, lastName, age, phone, <span class=\"string\">\"\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String firstName, String lastName, <span class=\"keyword\">int</span> age, String phone, String address)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.firstName = firstName;</div><div class=\"line\">    <span class=\"keyword\">this</span>.lastName = lastName;</div><div class=\"line\">    <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">    <span class=\"keyword\">this</span>.phone = phone;</div><div class=\"line\">    <span class=\"keyword\">this</span>.address = address;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先可以肯定的是，这样做是可以满足要求的。</p>\n<p>当然，这种方式的缺点也是很明显的。当一个类中只有几个参数的时候还好，如果一旦类中的参数逐渐增大，那么这个类就会变得很难阅读和维护。更重要的是，这样的一个类，调用者会很难使用。我到底应该使用哪个构造方法？是包含两个参数的还是包含三个参数的？如果我没有传递值的话那些属性的默认值是什么？如果我只想对address赋值而不对age和phone赋值怎么办？遇到这种情况可能我只能调用那个参数最全的构造函数，然后对于我不想要的参数值传递一个默认值。</p>\n<p>此外，如果多个参数的类型都相同那就很容易让人困惑，第一个String类型的参数到底是number还是address呢？</p>\n<p>还有没有其他方案可选择呢？我们可以遵循JaveBean规范，定义一个只包含无参数的构造方法和getter、setter方法的JavaBean。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> String firstName; <span class=\"comment\">// required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String lastName; <span class=\"comment\">// required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age; <span class=\"comment\">// optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String phone; <span class=\"comment\">// optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String address;  <span class=\"comment\">//optional</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getFirstName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> firstName;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFirstName</span><span class=\"params\">(String firstName)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.firstName = firstName;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLastName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> lastName;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLastName</span><span class=\"params\">(String lastName)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.lastName = lastName;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> age;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPhone</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> phone;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPhone</span><span class=\"params\">(String phone)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.phone = phone;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAddress</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> address;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAddress</span><span class=\"params\">(String address)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.address = address;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方式看上去很容易阅读和维护。对于调用者来说，我只需要创建一个空的对象，然后对于我想设置的参数调用setter方法设置就好了。这难道还有什么问题吗？其实存在两个问题。第一个问题是该类的实例状态不固定。如果你想创建一个User对象，该对象的5个属性都要赋值，那么直到所有的setXX方法都被调用之前，该对象都没有一个完整的状态。这意味着在该对象状态还不完整的时候，一部分客户端程序可能看见这个对象并且以为该对象已经构造完成。</p>\n<p>这种方法的第二个不足是User类是易变的（因为没有属性是final的）。你将会失去不可变对象带来的所有优点。</p>\n<p>幸运的是应对这种场景我们有第三种选择，建造者模式。解决方案类似如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String firstName; <span class=\"comment\">// required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String lastName; <span class=\"comment\">// required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age; <span class=\"comment\">// optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String phone; <span class=\"comment\">// optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String address; <span class=\"comment\">// optional</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">User</span><span class=\"params\">(UserBuilder builder)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.firstName = builder.firstName;</div><div class=\"line\">        <span class=\"keyword\">this</span>.lastName = builder.lastName;</div><div class=\"line\">        <span class=\"keyword\">this</span>.age = builder.age;</div><div class=\"line\">        <span class=\"keyword\">this</span>.phone = builder.phone;</div><div class=\"line\">        <span class=\"keyword\">this</span>.address = builder.address;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getFirstName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> firstName;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLastName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> lastName;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> age;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPhone</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> phone;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAddress</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> address;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserBuilder</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String firstName;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String lastName;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</div><div class=\"line\">        <span class=\"keyword\">private</span> String phone;</div><div class=\"line\">        <span class=\"keyword\">private</span> String address;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserBuilder</span><span class=\"params\">(String firstName, String lastName)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.firstName = firstName;</div><div class=\"line\">            <span class=\"keyword\">this</span>.lastName = lastName;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> UserBuilder <span class=\"title\">age</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> UserBuilder <span class=\"title\">phone</span><span class=\"params\">(String phone)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.phone = phone;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> UserBuilder <span class=\"title\">address</span><span class=\"params\">(String address)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.address = address;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>值得注意的几个要点:</p>\n<blockquote>\n<p>User类的构造函数是私有的，这意味着你不能在外面直接创建这个类的对象。</p>\n<p>该类是不可变的。所有属性都是final类型的，在构造方法里面被赋值。另外，我们只为它们提供了getter方法。</p>\n<p>builder类使用流式接口风格，让客户端代码阅读起来更容易（我们马上就会看到一个它的例子）</p>\n<p>builder的构造方法只接收必要的参数，为了确保这些属性在构造方法里赋值，只有这些属性被定义成final类型。</p>\n<p>使用建造者模式有在本文开始时提到的两种方法的所有优点，并且没有它们的缺点。客户端代码写起来更简单，更重要的是，更易读。我听过的关于该模式的唯一批判是你必须在builder类里面复制类的属性。然而，考虑到这个事实，builder类通常是需要建造的类的一个静态类成员，它们一起扩展起来相当容易。（译者表示没明白为设定为静态成员扩展起来就容易了。设为静态成员我认为有一个好处就是可以避免出现is not an enclosing class的编译问题，创建对象时候更加方便）</p>\n</blockquote>\n<p>现在，试图创建一个新的User对象的客户端代码看起来如何那？让我们来看一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUser</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span></div><div class=\"line\">            User.UserBuilder(<span class=\"string\">\"Jhon\"</span>, <span class=\"string\">\"Doe\"</span>)</div><div class=\"line\">            .age(<span class=\"number\">30</span>)</div><div class=\"line\">            .phone(<span class=\"string\">\"1234567\"</span>)</div><div class=\"line\">            .address(<span class=\"string\">\"Fake address 1234\"</span>)</div><div class=\"line\">            .build();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>译者注：如果UserBuilder没有设置为static的，以上代码会有编译错误。错误提示：User is not an enclosing class</p>\n<p>以上代码看上去相当整洁。我们可以只通过一行代码就可以创建一个User对象，并且这行代码也很容易读懂。除此之外，这样还能确保无论何时你想获取该类的对象都不会是不完整的（译者注：因为创建对象的过程是一气呵成的，一旦对象创建完成之后就不可修改了）。</p>\n<p>这种模式非常灵活，一个单独的builder类可以通过在调用build方法之前改变builder的属性来创建多个对象。builder类甚至可以在每次调用之间自动补全一些生成的字段，例如一个id或者序列号。</p>\n<p>值得注意的是，像构造函数一样，builder可以对参数的合法性进行检查，一旦发现参数不合法可以抛出IllegalStateException异常。</p>\n<p>但是，很重要的一点是，如果要检查参数的合法性，一定要先把参数传递给对象，然后在检查对象中的参数是否合法。其原因是因为builder并不是线程安全的。如果我们在创建真正的对象之前验证参数，参数值可能被另一个线程在参数验证完和参数被拷贝完成之间的时间修改。这段时间周期被称作“脆弱之窗”。我们的例子中情况如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    User user = <span class=\"keyword\">new</span> user(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (user.getAge() &gt; <span class=\"number\">120</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(“Age out of range”); <span class=\"comment\">// thread-safe</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> user;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上一个代码版本是线程安全的因为我们首先创建user对象，然后在不可变对象上验证条件约束。下面的代码在功能上看起来一样但是它不是线程安全的，你应该避免这么做：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (age &gt; <span class=\"number\">120</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(“Age out of range”); <span class=\"comment\">// bad, not thread-safe</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// This is the window of opportunity for a second thread to modify the value of age</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>建造者模式最后的一个优点是builder可以作为参数传递给一个方法，让该方法有为客户端创建一个或者多个对象的能力，而不需要知道创建对象的任何细节。为了这么做你可能通常需要一个如下所示的简单接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\">T <span class=\"title\">build</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>借用之前的User例子，UserBuilder类可以实现Builder。如此，我们可以有如下的代码：</p>\n<p>UserCollection buildUserCollection(Builder userBuilder){…}</p>\n<p>译者注：关于这这最后一个优点的部分内容并没太看懂，希望有理解的人能过不吝赐教。</p>\n<hr>"},{"layout":"post","title":"理解notify notifyall sleep","date":"2016-08-31T13:27:09.000Z","_content":"\n今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。\n\n## 从线程状态说起\n\n一般的操作系统中，线程的状态大概有这么几个：\n\n1. 执行：线程获得cpu，程序正在执行\n\n2. 就绪：线程已经准备好运行，只要获得cpu，便立即执行\n\n3. 阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度\n\n4. 挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。\n\n5. 激活：把一个挂起的线程激活\n\n着重理解一下几个关键状态的转换：\n\n活动就绪-->静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。\n\n活动阻塞-->静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。\n\n注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。\n\n画个图理解一下：\n\n{% asset_img 线程状态.png %}\n\n线程创建和终止状态不再讨论。\n\n<!-- more -->\n\n## wait\n\nwait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。\n\n当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。\n\n调用wait方法，相当于上图中**执行->活动阻塞->静止阻塞**的过程。同时，wait方法释放了对象的锁，然后阻塞，挂起，等待被唤醒。\n\n## notify\n\n当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒(挂起)的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒(激活),这个过程相当于上图中**静止阻塞->活动阻塞**的过程。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。\n\n此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图**活动阻塞->活动就绪**的过程。此时线程等待调度执行。\n\n需要注意的是，notify不恰当使用很有可能造成死锁问题。\n\n## notifyAll\n\n当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒(挂起)的线程(调用了A的wait方法的线程)唤醒(激活)。这些线程会开始竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。\n\n## sleep\n\n与以上三个关键字不同的是，sleep方法是Thread中的方法。\n\n当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。调用sleep的目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;\n\n调用线程Y的sleep(1000)sleep方法，相当于上图中**执行->静止就绪状态**。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。\n\n## synchronized\n\n当程序执行遇到synchronized关键字的时候，若此时锁被占用，则线程被阻塞。相当于上图中**执行->活动阻塞**过程。\n\nPS：上述的几个状态跟java中描述的Thread.state并不尽相同。而且底层真正的运行情况(OS的线程状态)是否是跟以上描述相同也有待考究。但是我理解的这几个关键字对外的表现应该与上述描述是一样的。\n\n参考知乎上的一个提问：[java sleep和wait的区别的疑惑?](https://www.zhihu.com/question/23328075)\n\n## 使用场景\n\nObject.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？\n\n在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。\n\n例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。","source":"_posts/理解notify notifyall sleep.md","raw":"layout: post\ntitle: 理解notify notifyall sleep\ndate: 2016-08-31 21:27:09\ncategories: 编程\ntags:\n- java\n- 多线程 \n---\n\n今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。\n\n## 从线程状态说起\n\n一般的操作系统中，线程的状态大概有这么几个：\n\n1. 执行：线程获得cpu，程序正在执行\n\n2. 就绪：线程已经准备好运行，只要获得cpu，便立即执行\n\n3. 阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度\n\n4. 挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。\n\n5. 激活：把一个挂起的线程激活\n\n着重理解一下几个关键状态的转换：\n\n活动就绪-->静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。\n\n活动阻塞-->静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。\n\n注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。\n\n画个图理解一下：\n\n{% asset_img 线程状态.png %}\n\n线程创建和终止状态不再讨论。\n\n<!-- more -->\n\n## wait\n\nwait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。\n\n当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。\n\n调用wait方法，相当于上图中**执行->活动阻塞->静止阻塞**的过程。同时，wait方法释放了对象的锁，然后阻塞，挂起，等待被唤醒。\n\n## notify\n\n当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒(挂起)的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒(激活),这个过程相当于上图中**静止阻塞->活动阻塞**的过程。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。\n\n此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图**活动阻塞->活动就绪**的过程。此时线程等待调度执行。\n\n需要注意的是，notify不恰当使用很有可能造成死锁问题。\n\n## notifyAll\n\n当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒(挂起)的线程(调用了A的wait方法的线程)唤醒(激活)。这些线程会开始竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。\n\n## sleep\n\n与以上三个关键字不同的是，sleep方法是Thread中的方法。\n\n当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。调用sleep的目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;\n\n调用线程Y的sleep(1000)sleep方法，相当于上图中**执行->静止就绪状态**。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。\n\n## synchronized\n\n当程序执行遇到synchronized关键字的时候，若此时锁被占用，则线程被阻塞。相当于上图中**执行->活动阻塞**过程。\n\nPS：上述的几个状态跟java中描述的Thread.state并不尽相同。而且底层真正的运行情况(OS的线程状态)是否是跟以上描述相同也有待考究。但是我理解的这几个关键字对外的表现应该与上述描述是一样的。\n\n参考知乎上的一个提问：[java sleep和wait的区别的疑惑?](https://www.zhihu.com/question/23328075)\n\n## 使用场景\n\nObject.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？\n\n在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。\n\n例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。","slug":"理解notify notifyall sleep","published":1,"updated":"2017-04-11T13:08:38.858Z","comments":1,"photos":[],"link":"","_id":"cj4vch4hh005ox3gcee7j5h3s","content":"<p>今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。</p>\n<h2 id=\"从线程状态说起\"><a href=\"#从线程状态说起\" class=\"headerlink\" title=\"从线程状态说起\"></a>从线程状态说起</h2><p>一般的操作系统中，线程的状态大概有这么几个：</p>\n<ol>\n<li><p>执行：线程获得cpu，程序正在执行</p>\n</li>\n<li><p>就绪：线程已经准备好运行，只要获得cpu，便立即执行</p>\n</li>\n<li><p>阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度</p>\n</li>\n<li><p>挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。</p>\n</li>\n<li><p>激活：把一个挂起的线程激活</p>\n</li>\n</ol>\n<p>着重理解一下几个关键状态的转换：</p>\n<p>活动就绪–&gt;静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。</p>\n<p>活动阻塞–&gt;静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。</p>\n<p>注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。</p>\n<p>画个图理解一下：</p>\n<img src=\"/2016/08/31/理解notify%20notifyall%20sleep/线程状态.png\" alt=\"线程状态.png\" title=\"\">\n<p>线程创建和终止状态不再讨论。</p>\n<a id=\"more\"></a>\n<h2 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h2><p>wait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。</p>\n<p>当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。</p>\n<p>调用wait方法，相当于上图中<strong>执行-&gt;活动阻塞-&gt;静止阻塞</strong>的过程。同时，wait方法释放了对象的锁，然后阻塞，挂起，等待被唤醒。</p>\n<h2 id=\"notify\"><a href=\"#notify\" class=\"headerlink\" title=\"notify\"></a>notify</h2><p>当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒(挂起)的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒(激活),这个过程相当于上图中<strong>静止阻塞-&gt;活动阻塞</strong>的过程。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。</p>\n<p>此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图<strong>活动阻塞-&gt;活动就绪</strong>的过程。此时线程等待调度执行。</p>\n<p>需要注意的是，notify不恰当使用很有可能造成死锁问题。</p>\n<h2 id=\"notifyAll\"><a href=\"#notifyAll\" class=\"headerlink\" title=\"notifyAll\"></a>notifyAll</h2><p>当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒(挂起)的线程(调用了A的wait方法的线程)唤醒(激活)。这些线程会开始竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。</p>\n<h2 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep\"></a>sleep</h2><p>与以上三个关键字不同的是，sleep方法是Thread中的方法。</p>\n<p>当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。调用sleep的目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;</p>\n<p>调用线程Y的sleep(1000)sleep方法，相当于上图中<strong>执行-&gt;静止就绪状态</strong>。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。</p>\n<h2 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h2><p>当程序执行遇到synchronized关键字的时候，若此时锁被占用，则线程被阻塞。相当于上图中<strong>执行-&gt;活动阻塞</strong>过程。</p>\n<p>PS：上述的几个状态跟java中描述的Thread.state并不尽相同。而且底层真正的运行情况(OS的线程状态)是否是跟以上描述相同也有待考究。但是我理解的这几个关键字对外的表现应该与上述描述是一样的。</p>\n<p>参考知乎上的一个提问：<a href=\"https://www.zhihu.com/question/23328075\" target=\"_blank\" rel=\"external\">java sleep和wait的区别的疑惑?</a></p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>Object.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？</p>\n<p>在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。</p>\n<p>例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。</p>\n","excerpt":"<p>今天下班时和同事偶尔谈起了锁的一些问题，发现自己对这些基本一无所知。只是会使用synchronized关键字来进行简单的同步。之前也想把java并发包的源码看一下，但是最近一直没有时间，阅读源码计划也搁置了一段时间了，等重构完JDBC就先把java IO部分理一下吧。晚上回来翻了一下操作系统的书，总结一下java中基础的notify、notifyall、sleep。网上关于这三个关键字的文章有很多，理解一下，记下来。</p>\n<h2 id=\"从线程状态说起\"><a href=\"#从线程状态说起\" class=\"headerlink\" title=\"从线程状态说起\"></a>从线程状态说起</h2><p>一般的操作系统中，线程的状态大概有这么几个：</p>\n<ol>\n<li><p>执行：线程获得cpu，程序正在执行</p>\n</li>\n<li><p>就绪：线程已经准备好运行，只要获得cpu，便立即执行</p>\n</li>\n<li><p>阻塞：线程等待某些资源，暂时无法执行。这时该线程放弃cpu，引起线程调度</p>\n</li>\n<li><p>挂起：由于某种原因，线程被挂起，线程处于静止状态。若此时线程正在执行，挂起后暂停执行，让出cpu;若原本处于就绪状态，则暂不接受调度。</p>\n</li>\n<li><p>激活：把一个挂起的线程激活</p>\n</li>\n</ol>\n<p>着重理解一下几个关键状态的转换：</p>\n<p>活动就绪–&gt;静止就绪：当线程处于未被挂起的就绪状态时，称为活动就绪，此时线程接收调度。当该线程被挂起后，转变为静止就绪，暂不接受调度。</p>\n<p>活动阻塞–&gt;静止阻塞：当线程处于未被挂起的阻塞状态时，称为活动阻塞。当该线程被挂起后，转变为静止阻塞。当线程等待的事件出现后，从静止阻塞转变为静止就绪。</p>\n<p>注意：挂起和阻塞均会使线程让出cpu，不同就在于阻塞一旦获得等待事件，就转变为就绪状态，接受调度；挂起需要激活操作后，转变为就绪状态，接收调度。</p>\n<p>画个图理解一下：</p>\n<img src=\"/2016/08/31/理解notify%20notifyall%20sleep/线程状态.png\" alt=\"线程状态.png\" title=\"\">\n<p>线程创建和终止状态不再讨论。</p>","more":"<h2 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h2><p>wait、notify、notifyAll三个方法都是Object的方法。每个对象都拥有这三个方法。</p>\n<p>当在线程中调用某个对象A的wait方法时，释放该对象的锁，同时让出cpu的使用权。前提是需拥有该对象A的锁，故wait方法需要在synchronized(A)的作用域中使用。</p>\n<p>调用wait方法，相当于上图中<strong>执行-&gt;活动阻塞-&gt;静止阻塞</strong>的过程。同时，wait方法释放了对象的锁，然后阻塞，挂起，等待被唤醒。</p>\n<h2 id=\"notify\"><a href=\"#notify\" class=\"headerlink\" title=\"notify\"></a>notify</h2><p>当在线程Y中调用某个对象A的notify方法时，系统从众多等待被唤醒(挂起)的线程(调用了A的wait方法的线程)中选出一个线程X，将其唤醒(激活),这个过程相当于上图中<strong>静止阻塞-&gt;活动阻塞</strong>的过程。此时该线程X会重新开始对A对象锁的请求。跟wait一样，notify也需要在synchronized(A)的作用域中调用，当Y线程运行出synchronized(A)的作用域后，释放A对象的锁。</p>\n<p>此时，线程X会得到A对象的锁(只唤醒了他一个嘛)，这个过程相当于上图<strong>活动阻塞-&gt;活动就绪</strong>的过程。此时线程等待调度执行。</p>\n<p>需要注意的是，notify不恰当使用很有可能造成死锁问题。</p>\n<h2 id=\"notifyAll\"><a href=\"#notifyAll\" class=\"headerlink\" title=\"notifyAll\"></a>notifyAll</h2><p>当在线程Y中调用某个对象A的notifyAll方法时，系统将所有等待被唤醒(挂起)的线程(调用了A的wait方法的线程)唤醒(激活)。这些线程会开始竞争A对象的锁。(注意notify与notifyAll的区别就在于唤醒一个等待线程还是所有的等待线程。线程被唤醒后将参与对锁的竞争，未被唤醒的线程不参与锁的竞争。)之后就跟notify一样了，线程Y运行出synchronized(A)的作用域，释放A对象的锁。</p>\n<h2 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep\"></a>sleep</h2><p>与以上三个关键字不同的是，sleep方法是Thread中的方法。</p>\n<p>当调用某个线程Y的sleep(1000)方法时，线程Y挂起，放弃cpu的使用权。与wait不同的是，他不会释放对象的锁。故sleep方法可以在非synchronized作用域使用。调用sleep的目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;</p>\n<p>调用线程Y的sleep(1000)sleep方法，相当于上图中<strong>执行-&gt;静止就绪状态</strong>。当过1000毫秒之后，线程Y被激活，从静止就绪转为活动就绪状态。此时线程Y等待调度执行。</p>\n<h2 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h2><p>当程序执行遇到synchronized关键字的时候，若此时锁被占用，则线程被阻塞。相当于上图中<strong>执行-&gt;活动阻塞</strong>过程。</p>\n<p>PS：上述的几个状态跟java中描述的Thread.state并不尽相同。而且底层真正的运行情况(OS的线程状态)是否是跟以上描述相同也有待考究。但是我理解的这几个关键字对外的表现应该与上述描述是一样的。</p>\n<p>参考知乎上的一个提问：<a href=\"https://www.zhihu.com/question/23328075\">java sleep和wait的区别的疑惑?</a></p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>Object.wait()方法需要在synchronized的作用域中使用。某线程中调用对象A的wait方法会释放该对象A的锁,线程让出cpu。什么时候会用到这个方法？获得对象的锁却又主动释放它？</p>\n<p>在一些生产者消费者的问题中可能会用到wait和notify方法。比如使用一个buffer，当消费者获得buffer的锁，检测到buffer为空时使用wait方法，释放锁，等待生产者填满buffer后调用buffer的notify方法通知消费者去使用buffer。</p>\n<p>例子自己写了一个，感觉挺low，网上很多优秀的例子，代码就不贴了。</p>"},{"layout":"post","title":"糖醋里脊","date":"2017-04-09T10:12:15.000Z","_content":"\n今天给女朋友做了一道菜：糖醋里脊。如图，还算是比较成功的～\n\n## 原料\n\n猪里脊肉、白糖、醋、料酒、盐、番茄酱、葱蒜、胡椒粉、面粉、淀粉\n\n<!-- more -->\n\n## 制作方法\n\n1. 将醋、糖、料酒、盐，少许水和淀粉混合成调味汁儿备用，比例糖4醋3料酒1，水、盐适量。\n\n2. 将里脊切成粗条状，放入碗中。加入盐、胡椒粉、料酒抓匀后腌制20分钟。\n\n3. 将腌制好的里脊肉沥水后倒入碗中，打入一个鸡蛋，抓匀。\n\n4. 将面粉(可以加点淀粉)倒入碗中，依次将里脊肉放入面粉中，保证里脊粘上一层面粉。\n\n5. 锅中加入油，烧至六成热，转中小火，逐个将粘上面粉的肉条放入，炸约一分钟捞出沥油。\n\n6. 将锅里的油继续加热，油温八九成热时，倒入肉条复炸片刻至金黄色酥脆后，捞出沥油。\n\n7. 锅中留少许底油加热，爆香葱蒜末。加入番茄酱炒香。加入调好的糖醋汁煮至浓稠。\n\n8. 下入炸好的里脊条快速翻匀，出锅装盘。\n\n## 成品\n\n{% asset_img wufan.jpg 糖醋里脊 %}\n\n","source":"_posts/糖醋里脊.md","raw":"---\nlayout: post\ntitle: 糖醋里脊\ndate: 2017-04-09 18:12:15\ncategories: 生活\ntags: 食物\n---\n\n今天给女朋友做了一道菜：糖醋里脊。如图，还算是比较成功的～\n\n## 原料\n\n猪里脊肉、白糖、醋、料酒、盐、番茄酱、葱蒜、胡椒粉、面粉、淀粉\n\n<!-- more -->\n\n## 制作方法\n\n1. 将醋、糖、料酒、盐，少许水和淀粉混合成调味汁儿备用，比例糖4醋3料酒1，水、盐适量。\n\n2. 将里脊切成粗条状，放入碗中。加入盐、胡椒粉、料酒抓匀后腌制20分钟。\n\n3. 将腌制好的里脊肉沥水后倒入碗中，打入一个鸡蛋，抓匀。\n\n4. 将面粉(可以加点淀粉)倒入碗中，依次将里脊肉放入面粉中，保证里脊粘上一层面粉。\n\n5. 锅中加入油，烧至六成热，转中小火，逐个将粘上面粉的肉条放入，炸约一分钟捞出沥油。\n\n6. 将锅里的油继续加热，油温八九成热时，倒入肉条复炸片刻至金黄色酥脆后，捞出沥油。\n\n7. 锅中留少许底油加热，爆香葱蒜末。加入番茄酱炒香。加入调好的糖醋汁煮至浓稠。\n\n8. 下入炸好的里脊条快速翻匀，出锅装盘。\n\n## 成品\n\n{% asset_img wufan.jpg 糖醋里脊 %}\n\n","slug":"糖醋里脊","published":1,"updated":"2017-05-08T12:40:05.290Z","comments":1,"photos":[],"link":"","_id":"cj4vch4hi005rx3gctdc20u8e","content":"<p>今天给女朋友做了一道菜：糖醋里脊。如图，还算是比较成功的～</p>\n<h2 id=\"原料\"><a href=\"#原料\" class=\"headerlink\" title=\"原料\"></a>原料</h2><p>猪里脊肉、白糖、醋、料酒、盐、番茄酱、葱蒜、胡椒粉、面粉、淀粉</p>\n<a id=\"more\"></a>\n<h2 id=\"制作方法\"><a href=\"#制作方法\" class=\"headerlink\" title=\"制作方法\"></a>制作方法</h2><ol>\n<li><p>将醋、糖、料酒、盐，少许水和淀粉混合成调味汁儿备用，比例糖4醋3料酒1，水、盐适量。</p>\n</li>\n<li><p>将里脊切成粗条状，放入碗中。加入盐、胡椒粉、料酒抓匀后腌制20分钟。</p>\n</li>\n<li><p>将腌制好的里脊肉沥水后倒入碗中，打入一个鸡蛋，抓匀。</p>\n</li>\n<li><p>将面粉(可以加点淀粉)倒入碗中，依次将里脊肉放入面粉中，保证里脊粘上一层面粉。</p>\n</li>\n<li><p>锅中加入油，烧至六成热，转中小火，逐个将粘上面粉的肉条放入，炸约一分钟捞出沥油。</p>\n</li>\n<li><p>将锅里的油继续加热，油温八九成热时，倒入肉条复炸片刻至金黄色酥脆后，捞出沥油。</p>\n</li>\n<li><p>锅中留少许底油加热，爆香葱蒜末。加入番茄酱炒香。加入调好的糖醋汁煮至浓稠。</p>\n</li>\n<li><p>下入炸好的里脊条快速翻匀，出锅装盘。</p>\n</li>\n</ol>\n<h2 id=\"成品\"><a href=\"#成品\" class=\"headerlink\" title=\"成品\"></a>成品</h2><img src=\"/2017/04/09/糖醋里脊/wufan.jpg\" alt=\"糖醋里脊\" title=\"糖醋里脊\">\n","excerpt":"<p>今天给女朋友做了一道菜：糖醋里脊。如图，还算是比较成功的～</p>\n<h2 id=\"原料\"><a href=\"#原料\" class=\"headerlink\" title=\"原料\"></a>原料</h2><p>猪里脊肉、白糖、醋、料酒、盐、番茄酱、葱蒜、胡椒粉、面粉、淀粉</p>","more":"<h2 id=\"制作方法\"><a href=\"#制作方法\" class=\"headerlink\" title=\"制作方法\"></a>制作方法</h2><ol>\n<li><p>将醋、糖、料酒、盐，少许水和淀粉混合成调味汁儿备用，比例糖4醋3料酒1，水、盐适量。</p>\n</li>\n<li><p>将里脊切成粗条状，放入碗中。加入盐、胡椒粉、料酒抓匀后腌制20分钟。</p>\n</li>\n<li><p>将腌制好的里脊肉沥水后倒入碗中，打入一个鸡蛋，抓匀。</p>\n</li>\n<li><p>将面粉(可以加点淀粉)倒入碗中，依次将里脊肉放入面粉中，保证里脊粘上一层面粉。</p>\n</li>\n<li><p>锅中加入油，烧至六成热，转中小火，逐个将粘上面粉的肉条放入，炸约一分钟捞出沥油。</p>\n</li>\n<li><p>将锅里的油继续加热，油温八九成热时，倒入肉条复炸片刻至金黄色酥脆后，捞出沥油。</p>\n</li>\n<li><p>锅中留少许底油加热，爆香葱蒜末。加入番茄酱炒香。加入调好的糖醋汁煮至浓稠。</p>\n</li>\n<li><p>下入炸好的里脊条快速翻匀，出锅装盘。</p>\n</li>\n</ol>\n<h2 id=\"成品\"><a href=\"#成品\" class=\"headerlink\" title=\"成品\"></a>成品</h2><img src=\"/2017/04/09/糖醋里脊/wufan.jpg\" alt=\"糖醋里脊\" title=\"糖醋里脊\">"},{"layout":"post","title":"线程池异常处理方案","date":"2017-04-26T12:07:01.000Z","_content":"\n> 最近一直在看《java并发编程实战》这本书，之前看过一点，放弃了，现在重新拿过来学习一下。这本书是老外写的，我买的是翻译版。不得不吐槽这本书的翻译，句子晦涩难懂，而且已经读到有好几处错误，差不多跟谷歌翻译一个水平...但是没办法，谁让咱英语差呢？多读几遍，结合jdk源码也能看个大概...\n\n> 执行多线程并发任务的时候，如果任务类型相同，一般会考虑使用线程池，一方面利用了并发的优势，一方面避免创建大量线程得不偿失。使用线程池执行的任务一般是我们自己的代码，或者第三方的代码，有没有想过，如果这些代码抛出异常时，线程池会怎么处理呢？如果不处理又会有什么影响？\n\n<!-- more -->\n\n## 异常的影响\n\n[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章列举了一个由于RuntimeException引发的线程泄漏问题：\n\n>考虑这样一个假设的中间件服务器应用程序，它聚合来自各种输入源的消息，然后将它们提交到外部服务器应用程序，从外部应用程序接收响应并将响应路由回适当的输入源。对于每个输入源，都有一个以其自己的方式接受其输入消息的插件（通过扫描文件目录、等待套接字连接、轮询数据库表等）。插件可以由第三方编写，即使它们是在服务器 JVM 上运行的。这个应用程序拥有（至少）两个内部工作队列 ― 从插件处接收的正在等待被发送到服务器的消息（“出站消息”队列），以及从服务器接收的正在等待被传递到适当插件的响应（“入站响应”队列）。通过调用插件对象上的服务例程 incomingResponse() ，消息被路由到最初发出请求的插件。\n\n>从插件接收消息后，就被排列到出站消息队列中。由一个或多个从队列读取消息的线程处理出站消息队列中的消息、记录其来源并将它提交给远程服务器应用程序（假定通过 Web 服务接口）。远程应用程序最终通过 Web 服务接口返回响应，然后我们的服务器将接收的响应排列到入站响应队列中。一个或多个响应线程从入站响应队列读取消息并将其路由到适当的插件，从而完成往返“旅程”。\n在这个应用程序中，有两个消息队列，分别用于出站请求和入站响应，不同的插件内可能也有另外的队列。我们还有几种服务线程，一个从出站消息队列读取请求并将其提交给外部服务器，一个从入站响应队列读取响应并将其路由到插件，在用于向套接字或其它外部请求源提供服务的插件中可能也有一些线程。\n\n>如果这些线程中的一个（如响应分派线程）消失了，将会发生什么？因为插件仍能够提交新消息，所以它们可能不会立即注意到某些方面出错了。消息仍将通过各种输入源到达，并通过我们的应用程序提交到外部服务。因为插件并不期待立即获得其响应，因此它仍没有意识到出了问题。最后，接收的响应将排满队列。如果它们存储在内存中，那么最终将耗尽内存。即使不耗尽内存，也会有人在某个时刻发现响应得不到传递 ― 但这可能需要一些时间，因为系统的其它方面仍能正常发挥作用。\n\n>当主要的任务处理方面由线程池而不是单个线程来处理时，对于偶然的线程泄漏的后果有一定程度的保护，因为一个执行得很好的八线程的线程池，用七个线程完成其工作的效率可能仍可以接受。起初，可能没有任何显著的差异。但是，系统性能最终将下降，虽然这种下降的方式不易被察觉。\n\n>服务器应用程序中的线程泄漏问题在于不是总是容易从外部检测它。因为大多数线程只处理服务器的部分工作负载，或可能仅处理特定类型的后台任务，所以当程序实际上遭遇严重故障时，在用户看来它仍在正常工作。这一点，再加上引起线程泄漏的因素并不总是留下明显痕迹，就会引起令人惊讶甚或使人迷惑的应用程序行为。\n\n我们在使用线程池处理并行任务时，在线程池的生命周期当中，将通过某种抽象机制(Runnable)调用许多未知的代码，这些代码有可能是我们自己写的，也有可能来自第三方。任何代码都有可能抛出一个RuntimeException，如果这些提交的Runnable抛出了RuntimeException，线程池可以捕获他，线程池有可能会创建一个新的线程来代替这个因为抛出异常而结束的线程，也有可能什么也不做(这要看线程池的策略)。即使不会造成线程泄漏，我们也会丢失这个任务的执行情况，无法感知任务执行出现了异常。\n\n所以，有必要处理提交到线程池运行的代码抛出的异常。\n\n## 如何处理异常\n\n### 简单了解线程池\n\n{% asset_img siwei.png threadpool %}\n\n上面是我画的思维导图\n\n先介绍一下jdk中线程池的实现：\n\n{% asset_img threadpool.png threadpool %}\n\nExecutor定义了一个通用的并发任务框架，即通过execute方法执行一个任务。\n\nExecutorService定义了并发框架(线程池)的生命周期。\n\nAbstractExecutorService、ThreadPoolExecutor、ScheduledThreadPoolExecutor实现了并发任务框架(线程池)。其中ScheduledThreadPoolExecutor支持定时及周期性任务的执行。\n\nExecutors相当于一个线程池工厂类，返回了不同执行策略的线程池对象。\n\n我们一般使用Executors.new...方法来得到某种线程池：\n\n```\nnewCachedThreadPool\n创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n\nnewFixedThreadPool\n创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n\nnewSingleThreadExecutor\n创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n\nnewScheduledThreadPool\n创建一个定长线程池，支持定时及周期性任务执行。\n```\n其中，前三者返回ExecutorService实例，他们的实现为ThreadPoolExecutor或其包装类；newScheduledThreadPool返回的是ScheduledExecutorService实例，他的实现为ScheduledThreadPoolExecutor或其包装类。\n\n```java\nExecutorService exec = Executors.newFixedThreadPool(8);\n```\n以上述代码为例，得到ExecutorService实例后，我们可以通过两种方式提交任务(Runnable):\n\n- `exec.execute(runnable)`\n\n- `exec.submit(runnable)`\n\n对于这两种不同的任务提交方式，我们有不同的异常处理办法。\n\n### exec.submit(runnable)\n\n{% asset_img submit.png submit %}\n\n使用`exec.submit(runnable)`这种方式提交任务时，submit方法会将我们的Runnable包装为一个RunnableFuture对象，这个对象实际上是FutureTask实例，然后将这个FutureTask交给execute方法执行。\n\n{% asset_img future.png future %}\n\nFuture用来管理任务的生命周期，将Future实例提交给异步线程执行后，可以调用Future.get方法获取任务执行的结果。我们知道Runnable执行是没有返回结果的，那么这个结果是怎么来的？\n\n{% asset_img callable.png futuretask %}\n\n可以看到，在FutureTask的构造方法中，将Runnable包装成了一个Callable类型的对象。\n\n{% asset_img futuretask_run.png futuretask_run %}\n\nFutureTask的run方法中，调用了callable对象的call方法，也就调用了我们传入的Runnable对象的run方法。可以看到，如果代码(Runnable)抛出异常，会被捕获并且把这个异常保存下来。\n\n{% asset_img futuretask_get.png futuretask_get %}\n\n{% asset_img futuretask_report.png futuretask_report %}\n\n可以看到，在调用get方法时，会将保存的异常重新抛出。所以，我们在使用submit方法提交任务的时候，利用返回的Future对象，通过他的get方法可以得到任务运行中抛出的异常，然后针对异常做一些处理。\n\n由于我们在调用submit时并没有给Runnable指定返回结果，所以在将Runnable包装为Callable的时候，会传入一个null，故get方法返回一个null.\n\n当然，我们也可以直接传入Callable类型的任务，这样就可以获取任务执行返回结果，并且得到任务执行抛出的异常。\n\n这就是使用线程池时处理任务中抛出异常的第一种方法：**使用ExecutorService.submit执行任务，利用返回的Future对象的get方法接收抛出的异常，然后进行处理**\n\n### exec.execute(runnable)\n\n利用Future.get得到任务抛出的异常的缺点在于，我们需要显式的遍历Future，调用get方法获取每个任务执行抛出的异常，然后处理。\n\n很多时候我们仅仅是使用`exec.execute(runnable)`这种方法来提交我们的任务。这种情况下任务抛出的异常如何处理呢？\n\n在使用`exec.execute(runnable)`提交任务的时候(submit其实也是调用execute方法执行)，我们的任务最终会被一个Worker对象执行。这个Worker内部封装了一个Thread对象，这个Thread就是线程池的工作者线程。工作者线程会调用runWorker方法来执行我们提交的任务：(代码比较长，就直接粘过来了)\n\n```java\nfinal void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n        w.unlock(); // allow interrupts\n        boolean completedAbruptly = true;\n        try {\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                // If pool is stopping, ensure thread is interrupted;\n                // if not, ensure thread is not interrupted.  This\n                // requires a recheck in second case to deal with\n                // shutdownNow race while clearing interrupt\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } catch (Error x) {\n                        thrown = x; throw x;\n                    } catch (Throwable x) {\n                        thrown = x; throw new Error(x);\n                    } finally {\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n}\n```\n上面代码的基本意思就是不停的从任务队列中取出任务执行，如果任务代码(task.run)抛出异常，会被最内层的`try--catch`块捕获，然后重新抛出。注意到最里面的finally块，在重新\n抛出异常之前，要先执行`afterExecute`方法，这个方法的默认实现为空，即什么也不做。我们可以在这个方法上做点文章，这就是我们的第二种方法，\n**重写`ThreadPoolExecutor.afterExecute`方法，处理传递到`afterExecute`方法中的异常**：\n\n```java\nclass ExtendedExecutor extends ThreadPoolExecutor {\n   // ...\n   protected void afterExecute(Runnable r, Throwable t) {\n     super.afterExecute(r, t);\n     if (t == null && r instanceof Future<?>) {\n       try {\n         Object result = ((Future<?>) r).get();\n       } catch (CancellationException ce) {\n           t = ce;\n       } catch (ExecutionException ee) {\n           t = ee.getCause();\n       } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt(); // ignore/reset\n       }\n     }\n     if (t != null)\n       System.out.println(t);\n   }\n }\n```\n> When actions are enclosed in tasks (such as FutureTask) either explicitly or via methods such as submit, these task objects catch and maintain computational exceptions, and so they do not cause abrupt termination, and the internal exceptions are not passed to this method. If you would like to trap both kinds of failures in this method, you can further probe for such cases, as in this sample subclass that prints either the direct cause or the underlying exception if a task has been aborted:\n\n上面是java doc给出的建议。可以看到，代码中还处理了`task`是`FutureTask`的情况。回想一下`submit`方式提交任务的情况：\n\n- 在submit方法中，我们传入的Runnable/Callable(要执行的任务)被封装为FutureTask对象，交给`execute`方法执行\n\n- 经过一系列操作，提交的FutureTask对象被Worker对象中的工作者线程所执行，也就是runWorker方法\n\n  此时的代码运行情况：runWorker->submit方法封装的FutureTask的run方法->我们提交的Runnable的run方法\n\n- 此时从`我们提交的Runnable的run方法`中抛出了一个未检测异常RunnableException，被FutureTask的run方法捕获\n\n- FutureTask的run方法捕获异常后保存，不再重新抛出。同时意味着run方法执行结束。\n\n- runWorker方法没有检测到异常，`task.run`当作正常运行结束。但是还是会执行afterExecute方法。\n\n经过这样的梳理，上面的代码为什么这么写就一目了然了。\n\n上面已经提到了两种解决任务代码抛出未检测异常的方案。接下来是第三种：\n\n当一个线程因为未捕获的异常而退出时，JVM会把这个事件报告给应用提供的`UncaughtExceptionHandler`异常处理器，如果没有提供任何的异常处理器，那么默认的行为就是将堆栈信息输送到System.err。\n\n看一下上面的`runWorker`方法，如果`task.run`(任务代码)抛出了异常，异常会层层抛出，最终导致这个线程退出。此时这个抛出的异常就会传递到`UncaughtExceptionHandler`实例当中，由`uncaughtException(Thread t,Throwable e)`这个方法处理。\n\n于是就有了第三种解决任务代码抛出异常的方案：**为工作者线程设置`UncaughtExceptionHandler`，在`uncaughtException`方法中处理异常**\n\n注意，这个方案不适用与使用`submit`方式提交任务的情况，原因上面也提到了，FutureTask的run方法捕获异常后保存，不再重新抛出，意味着`runWorker`方法并不会捕获到抛出的异常，线程也就不会退出，也不会执行我们设置的`UncaughtExceptionHandler`。\n\n如何为工作者线程设置`UncaughtExceptionHandler`呢？`ThreadPoolExecutor`的构造函数提供一个`ThreadFactory`，可以在其中设置我们自定义的`UncaughtExceptionHandler`，这里不再赘述。\n\n至于第四中方案，就很简单了：**在我们提供的Runnable的run方法中捕获任务代码可能抛出的所有异常，包括未检测异常**。这种方法比较简单，也有他的局限性，不够灵活，我们的处理被局限在了线程代码边界之内。\n\n## 总结\n\n通过上面的分析我们得到了四种解决任务代码抛异常的方案：\n\n- **在我们提供的Runnable的run方法中捕获任务代码可能抛出的所有异常，包括未检测异常**\n\n- **使用ExecutorService.submit执行任务，利用返回的Future对象的get方法接收抛出的异常，然后进行处理**\n\n- **重写`ThreadPoolExecutor.afterExecute`方法，处理传递到`afterExecute`方法中的异常**\n\n- **为工作者线程设置`UncaughtExceptionHandler`，在`uncaughtException`方法中处理异常**\n\n要注意的是，使用最后一种方案时，无法处理以`submit`的方式提交的任务。\n","source":"_posts/线程池异常处理方案.md","raw":"---\nlayout: post\ntitle: 线程池异常处理方案\ndate: 2017-04-26 20:07:01\ncategories: 编程\ntags: \n- java\n- 多线程\n---\n\n> 最近一直在看《java并发编程实战》这本书，之前看过一点，放弃了，现在重新拿过来学习一下。这本书是老外写的，我买的是翻译版。不得不吐槽这本书的翻译，句子晦涩难懂，而且已经读到有好几处错误，差不多跟谷歌翻译一个水平...但是没办法，谁让咱英语差呢？多读几遍，结合jdk源码也能看个大概...\n\n> 执行多线程并发任务的时候，如果任务类型相同，一般会考虑使用线程池，一方面利用了并发的优势，一方面避免创建大量线程得不偿失。使用线程池执行的任务一般是我们自己的代码，或者第三方的代码，有没有想过，如果这些代码抛出异常时，线程池会怎么处理呢？如果不处理又会有什么影响？\n\n<!-- more -->\n\n## 异常的影响\n\n[Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/)这篇文章列举了一个由于RuntimeException引发的线程泄漏问题：\n\n>考虑这样一个假设的中间件服务器应用程序，它聚合来自各种输入源的消息，然后将它们提交到外部服务器应用程序，从外部应用程序接收响应并将响应路由回适当的输入源。对于每个输入源，都有一个以其自己的方式接受其输入消息的插件（通过扫描文件目录、等待套接字连接、轮询数据库表等）。插件可以由第三方编写，即使它们是在服务器 JVM 上运行的。这个应用程序拥有（至少）两个内部工作队列 ― 从插件处接收的正在等待被发送到服务器的消息（“出站消息”队列），以及从服务器接收的正在等待被传递到适当插件的响应（“入站响应”队列）。通过调用插件对象上的服务例程 incomingResponse() ，消息被路由到最初发出请求的插件。\n\n>从插件接收消息后，就被排列到出站消息队列中。由一个或多个从队列读取消息的线程处理出站消息队列中的消息、记录其来源并将它提交给远程服务器应用程序（假定通过 Web 服务接口）。远程应用程序最终通过 Web 服务接口返回响应，然后我们的服务器将接收的响应排列到入站响应队列中。一个或多个响应线程从入站响应队列读取消息并将其路由到适当的插件，从而完成往返“旅程”。\n在这个应用程序中，有两个消息队列，分别用于出站请求和入站响应，不同的插件内可能也有另外的队列。我们还有几种服务线程，一个从出站消息队列读取请求并将其提交给外部服务器，一个从入站响应队列读取响应并将其路由到插件，在用于向套接字或其它外部请求源提供服务的插件中可能也有一些线程。\n\n>如果这些线程中的一个（如响应分派线程）消失了，将会发生什么？因为插件仍能够提交新消息，所以它们可能不会立即注意到某些方面出错了。消息仍将通过各种输入源到达，并通过我们的应用程序提交到外部服务。因为插件并不期待立即获得其响应，因此它仍没有意识到出了问题。最后，接收的响应将排满队列。如果它们存储在内存中，那么最终将耗尽内存。即使不耗尽内存，也会有人在某个时刻发现响应得不到传递 ― 但这可能需要一些时间，因为系统的其它方面仍能正常发挥作用。\n\n>当主要的任务处理方面由线程池而不是单个线程来处理时，对于偶然的线程泄漏的后果有一定程度的保护，因为一个执行得很好的八线程的线程池，用七个线程完成其工作的效率可能仍可以接受。起初，可能没有任何显著的差异。但是，系统性能最终将下降，虽然这种下降的方式不易被察觉。\n\n>服务器应用程序中的线程泄漏问题在于不是总是容易从外部检测它。因为大多数线程只处理服务器的部分工作负载，或可能仅处理特定类型的后台任务，所以当程序实际上遭遇严重故障时，在用户看来它仍在正常工作。这一点，再加上引起线程泄漏的因素并不总是留下明显痕迹，就会引起令人惊讶甚或使人迷惑的应用程序行为。\n\n我们在使用线程池处理并行任务时，在线程池的生命周期当中，将通过某种抽象机制(Runnable)调用许多未知的代码，这些代码有可能是我们自己写的，也有可能来自第三方。任何代码都有可能抛出一个RuntimeException，如果这些提交的Runnable抛出了RuntimeException，线程池可以捕获他，线程池有可能会创建一个新的线程来代替这个因为抛出异常而结束的线程，也有可能什么也不做(这要看线程池的策略)。即使不会造成线程泄漏，我们也会丢失这个任务的执行情况，无法感知任务执行出现了异常。\n\n所以，有必要处理提交到线程池运行的代码抛出的异常。\n\n## 如何处理异常\n\n### 简单了解线程池\n\n{% asset_img siwei.png threadpool %}\n\n上面是我画的思维导图\n\n先介绍一下jdk中线程池的实现：\n\n{% asset_img threadpool.png threadpool %}\n\nExecutor定义了一个通用的并发任务框架，即通过execute方法执行一个任务。\n\nExecutorService定义了并发框架(线程池)的生命周期。\n\nAbstractExecutorService、ThreadPoolExecutor、ScheduledThreadPoolExecutor实现了并发任务框架(线程池)。其中ScheduledThreadPoolExecutor支持定时及周期性任务的执行。\n\nExecutors相当于一个线程池工厂类，返回了不同执行策略的线程池对象。\n\n我们一般使用Executors.new...方法来得到某种线程池：\n\n```\nnewCachedThreadPool\n创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n\nnewFixedThreadPool\n创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n\nnewSingleThreadExecutor\n创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n\nnewScheduledThreadPool\n创建一个定长线程池，支持定时及周期性任务执行。\n```\n其中，前三者返回ExecutorService实例，他们的实现为ThreadPoolExecutor或其包装类；newScheduledThreadPool返回的是ScheduledExecutorService实例，他的实现为ScheduledThreadPoolExecutor或其包装类。\n\n```java\nExecutorService exec = Executors.newFixedThreadPool(8);\n```\n以上述代码为例，得到ExecutorService实例后，我们可以通过两种方式提交任务(Runnable):\n\n- `exec.execute(runnable)`\n\n- `exec.submit(runnable)`\n\n对于这两种不同的任务提交方式，我们有不同的异常处理办法。\n\n### exec.submit(runnable)\n\n{% asset_img submit.png submit %}\n\n使用`exec.submit(runnable)`这种方式提交任务时，submit方法会将我们的Runnable包装为一个RunnableFuture对象，这个对象实际上是FutureTask实例，然后将这个FutureTask交给execute方法执行。\n\n{% asset_img future.png future %}\n\nFuture用来管理任务的生命周期，将Future实例提交给异步线程执行后，可以调用Future.get方法获取任务执行的结果。我们知道Runnable执行是没有返回结果的，那么这个结果是怎么来的？\n\n{% asset_img callable.png futuretask %}\n\n可以看到，在FutureTask的构造方法中，将Runnable包装成了一个Callable类型的对象。\n\n{% asset_img futuretask_run.png futuretask_run %}\n\nFutureTask的run方法中，调用了callable对象的call方法，也就调用了我们传入的Runnable对象的run方法。可以看到，如果代码(Runnable)抛出异常，会被捕获并且把这个异常保存下来。\n\n{% asset_img futuretask_get.png futuretask_get %}\n\n{% asset_img futuretask_report.png futuretask_report %}\n\n可以看到，在调用get方法时，会将保存的异常重新抛出。所以，我们在使用submit方法提交任务的时候，利用返回的Future对象，通过他的get方法可以得到任务运行中抛出的异常，然后针对异常做一些处理。\n\n由于我们在调用submit时并没有给Runnable指定返回结果，所以在将Runnable包装为Callable的时候，会传入一个null，故get方法返回一个null.\n\n当然，我们也可以直接传入Callable类型的任务，这样就可以获取任务执行返回结果，并且得到任务执行抛出的异常。\n\n这就是使用线程池时处理任务中抛出异常的第一种方法：**使用ExecutorService.submit执行任务，利用返回的Future对象的get方法接收抛出的异常，然后进行处理**\n\n### exec.execute(runnable)\n\n利用Future.get得到任务抛出的异常的缺点在于，我们需要显式的遍历Future，调用get方法获取每个任务执行抛出的异常，然后处理。\n\n很多时候我们仅仅是使用`exec.execute(runnable)`这种方法来提交我们的任务。这种情况下任务抛出的异常如何处理呢？\n\n在使用`exec.execute(runnable)`提交任务的时候(submit其实也是调用execute方法执行)，我们的任务最终会被一个Worker对象执行。这个Worker内部封装了一个Thread对象，这个Thread就是线程池的工作者线程。工作者线程会调用runWorker方法来执行我们提交的任务：(代码比较长，就直接粘过来了)\n\n```java\nfinal void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n        w.unlock(); // allow interrupts\n        boolean completedAbruptly = true;\n        try {\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                // If pool is stopping, ensure thread is interrupted;\n                // if not, ensure thread is not interrupted.  This\n                // requires a recheck in second case to deal with\n                // shutdownNow race while clearing interrupt\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } catch (Error x) {\n                        thrown = x; throw x;\n                    } catch (Throwable x) {\n                        thrown = x; throw new Error(x);\n                    } finally {\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n}\n```\n上面代码的基本意思就是不停的从任务队列中取出任务执行，如果任务代码(task.run)抛出异常，会被最内层的`try--catch`块捕获，然后重新抛出。注意到最里面的finally块，在重新\n抛出异常之前，要先执行`afterExecute`方法，这个方法的默认实现为空，即什么也不做。我们可以在这个方法上做点文章，这就是我们的第二种方法，\n**重写`ThreadPoolExecutor.afterExecute`方法，处理传递到`afterExecute`方法中的异常**：\n\n```java\nclass ExtendedExecutor extends ThreadPoolExecutor {\n   // ...\n   protected void afterExecute(Runnable r, Throwable t) {\n     super.afterExecute(r, t);\n     if (t == null && r instanceof Future<?>) {\n       try {\n         Object result = ((Future<?>) r).get();\n       } catch (CancellationException ce) {\n           t = ce;\n       } catch (ExecutionException ee) {\n           t = ee.getCause();\n       } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt(); // ignore/reset\n       }\n     }\n     if (t != null)\n       System.out.println(t);\n   }\n }\n```\n> When actions are enclosed in tasks (such as FutureTask) either explicitly or via methods such as submit, these task objects catch and maintain computational exceptions, and so they do not cause abrupt termination, and the internal exceptions are not passed to this method. If you would like to trap both kinds of failures in this method, you can further probe for such cases, as in this sample subclass that prints either the direct cause or the underlying exception if a task has been aborted:\n\n上面是java doc给出的建议。可以看到，代码中还处理了`task`是`FutureTask`的情况。回想一下`submit`方式提交任务的情况：\n\n- 在submit方法中，我们传入的Runnable/Callable(要执行的任务)被封装为FutureTask对象，交给`execute`方法执行\n\n- 经过一系列操作，提交的FutureTask对象被Worker对象中的工作者线程所执行，也就是runWorker方法\n\n  此时的代码运行情况：runWorker->submit方法封装的FutureTask的run方法->我们提交的Runnable的run方法\n\n- 此时从`我们提交的Runnable的run方法`中抛出了一个未检测异常RunnableException，被FutureTask的run方法捕获\n\n- FutureTask的run方法捕获异常后保存，不再重新抛出。同时意味着run方法执行结束。\n\n- runWorker方法没有检测到异常，`task.run`当作正常运行结束。但是还是会执行afterExecute方法。\n\n经过这样的梳理，上面的代码为什么这么写就一目了然了。\n\n上面已经提到了两种解决任务代码抛出未检测异常的方案。接下来是第三种：\n\n当一个线程因为未捕获的异常而退出时，JVM会把这个事件报告给应用提供的`UncaughtExceptionHandler`异常处理器，如果没有提供任何的异常处理器，那么默认的行为就是将堆栈信息输送到System.err。\n\n看一下上面的`runWorker`方法，如果`task.run`(任务代码)抛出了异常，异常会层层抛出，最终导致这个线程退出。此时这个抛出的异常就会传递到`UncaughtExceptionHandler`实例当中，由`uncaughtException(Thread t,Throwable e)`这个方法处理。\n\n于是就有了第三种解决任务代码抛出异常的方案：**为工作者线程设置`UncaughtExceptionHandler`，在`uncaughtException`方法中处理异常**\n\n注意，这个方案不适用与使用`submit`方式提交任务的情况，原因上面也提到了，FutureTask的run方法捕获异常后保存，不再重新抛出，意味着`runWorker`方法并不会捕获到抛出的异常，线程也就不会退出，也不会执行我们设置的`UncaughtExceptionHandler`。\n\n如何为工作者线程设置`UncaughtExceptionHandler`呢？`ThreadPoolExecutor`的构造函数提供一个`ThreadFactory`，可以在其中设置我们自定义的`UncaughtExceptionHandler`，这里不再赘述。\n\n至于第四中方案，就很简单了：**在我们提供的Runnable的run方法中捕获任务代码可能抛出的所有异常，包括未检测异常**。这种方法比较简单，也有他的局限性，不够灵活，我们的处理被局限在了线程代码边界之内。\n\n## 总结\n\n通过上面的分析我们得到了四种解决任务代码抛异常的方案：\n\n- **在我们提供的Runnable的run方法中捕获任务代码可能抛出的所有异常，包括未检测异常**\n\n- **使用ExecutorService.submit执行任务，利用返回的Future对象的get方法接收抛出的异常，然后进行处理**\n\n- **重写`ThreadPoolExecutor.afterExecute`方法，处理传递到`afterExecute`方法中的异常**\n\n- **为工作者线程设置`UncaughtExceptionHandler`，在`uncaughtException`方法中处理异常**\n\n要注意的是，使用最后一种方案时，无法处理以`submit`的方式提交的任务。\n","slug":"线程池异常处理方案","published":1,"updated":"2017-05-04T12:07:00.242Z","comments":1,"photos":[],"link":"","_id":"cj4vch4hk005ux3gc8t489q0w","content":"<blockquote>\n<p>最近一直在看《java并发编程实战》这本书，之前看过一点，放弃了，现在重新拿过来学习一下。这本书是老外写的，我买的是翻译版。不得不吐槽这本书的翻译，句子晦涩难懂，而且已经读到有好几处错误，差不多跟谷歌翻译一个水平…但是没办法，谁让咱英语差呢？多读几遍，结合jdk源码也能看个大概…</p>\n<p>执行多线程并发任务的时候，如果任务类型相同，一般会考虑使用线程池，一方面利用了并发的优势，一方面避免创建大量线程得不偿失。使用线程池执行的任务一般是我们自己的代码，或者第三方的代码，有没有想过，如果这些代码抛出异常时，线程池会怎么处理呢？如果不处理又会有什么影响？</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"异常的影响\"><a href=\"#异常的影响\" class=\"headerlink\" title=\"异常的影响\"></a>异常的影响</h2><p><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\" target=\"_blank\" rel=\"external\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章列举了一个由于RuntimeException引发的线程泄漏问题：</p>\n<blockquote>\n<p>考虑这样一个假设的中间件服务器应用程序，它聚合来自各种输入源的消息，然后将它们提交到外部服务器应用程序，从外部应用程序接收响应并将响应路由回适当的输入源。对于每个输入源，都有一个以其自己的方式接受其输入消息的插件（通过扫描文件目录、等待套接字连接、轮询数据库表等）。插件可以由第三方编写，即使它们是在服务器 JVM 上运行的。这个应用程序拥有（至少）两个内部工作队列 ― 从插件处接收的正在等待被发送到服务器的消息（“出站消息”队列），以及从服务器接收的正在等待被传递到适当插件的响应（“入站响应”队列）。通过调用插件对象上的服务例程 incomingResponse() ，消息被路由到最初发出请求的插件。</p>\n<p>从插件接收消息后，就被排列到出站消息队列中。由一个或多个从队列读取消息的线程处理出站消息队列中的消息、记录其来源并将它提交给远程服务器应用程序（假定通过 Web 服务接口）。远程应用程序最终通过 Web 服务接口返回响应，然后我们的服务器将接收的响应排列到入站响应队列中。一个或多个响应线程从入站响应队列读取消息并将其路由到适当的插件，从而完成往返“旅程”。<br>在这个应用程序中，有两个消息队列，分别用于出站请求和入站响应，不同的插件内可能也有另外的队列。我们还有几种服务线程，一个从出站消息队列读取请求并将其提交给外部服务器，一个从入站响应队列读取响应并将其路由到插件，在用于向套接字或其它外部请求源提供服务的插件中可能也有一些线程。</p>\n<p>如果这些线程中的一个（如响应分派线程）消失了，将会发生什么？因为插件仍能够提交新消息，所以它们可能不会立即注意到某些方面出错了。消息仍将通过各种输入源到达，并通过我们的应用程序提交到外部服务。因为插件并不期待立即获得其响应，因此它仍没有意识到出了问题。最后，接收的响应将排满队列。如果它们存储在内存中，那么最终将耗尽内存。即使不耗尽内存，也会有人在某个时刻发现响应得不到传递 ― 但这可能需要一些时间，因为系统的其它方面仍能正常发挥作用。</p>\n<p>当主要的任务处理方面由线程池而不是单个线程来处理时，对于偶然的线程泄漏的后果有一定程度的保护，因为一个执行得很好的八线程的线程池，用七个线程完成其工作的效率可能仍可以接受。起初，可能没有任何显著的差异。但是，系统性能最终将下降，虽然这种下降的方式不易被察觉。</p>\n<p>服务器应用程序中的线程泄漏问题在于不是总是容易从外部检测它。因为大多数线程只处理服务器的部分工作负载，或可能仅处理特定类型的后台任务，所以当程序实际上遭遇严重故障时，在用户看来它仍在正常工作。这一点，再加上引起线程泄漏的因素并不总是留下明显痕迹，就会引起令人惊讶甚或使人迷惑的应用程序行为。</p>\n</blockquote>\n<p>我们在使用线程池处理并行任务时，在线程池的生命周期当中，将通过某种抽象机制(Runnable)调用许多未知的代码，这些代码有可能是我们自己写的，也有可能来自第三方。任何代码都有可能抛出一个RuntimeException，如果这些提交的Runnable抛出了RuntimeException，线程池可以捕获他，线程池有可能会创建一个新的线程来代替这个因为抛出异常而结束的线程，也有可能什么也不做(这要看线程池的策略)。即使不会造成线程泄漏，我们也会丢失这个任务的执行情况，无法感知任务执行出现了异常。</p>\n<p>所以，有必要处理提交到线程池运行的代码抛出的异常。</p>\n<h2 id=\"如何处理异常\"><a href=\"#如何处理异常\" class=\"headerlink\" title=\"如何处理异常\"></a>如何处理异常</h2><h3 id=\"简单了解线程池\"><a href=\"#简单了解线程池\" class=\"headerlink\" title=\"简单了解线程池\"></a>简单了解线程池</h3><img src=\"/2017/04/26/线程池异常处理方案/siwei.png\" alt=\"threadpool\" title=\"threadpool\">\n<p>上面是我画的思维导图</p>\n<p>先介绍一下jdk中线程池的实现：</p>\n<img src=\"/2017/04/26/线程池异常处理方案/threadpool.png\" alt=\"threadpool\" title=\"threadpool\">\n<p>Executor定义了一个通用的并发任务框架，即通过execute方法执行一个任务。</p>\n<p>ExecutorService定义了并发框架(线程池)的生命周期。</p>\n<p>AbstractExecutorService、ThreadPoolExecutor、ScheduledThreadPoolExecutor实现了并发任务框架(线程池)。其中ScheduledThreadPoolExecutor支持定时及周期性任务的执行。</p>\n<p>Executors相当于一个线程池工厂类，返回了不同执行策略的线程池对象。</p>\n<p>我们一般使用Executors.new…方法来得到某种线程池：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">newCachedThreadPool</div><div class=\"line\">创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</div><div class=\"line\"></div><div class=\"line\">newFixedThreadPool</div><div class=\"line\">创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</div><div class=\"line\"></div><div class=\"line\">newSingleThreadExecutor</div><div class=\"line\">创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</div><div class=\"line\"></div><div class=\"line\">newScheduledThreadPool</div><div class=\"line\">创建一个定长线程池，支持定时及周期性任务执行。</div></pre></td></tr></table></figure>\n<p>其中，前三者返回ExecutorService实例，他们的实现为ThreadPoolExecutor或其包装类；newScheduledThreadPool返回的是ScheduledExecutorService实例，他的实现为ScheduledThreadPoolExecutor或其包装类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">8</span>);</div></pre></td></tr></table></figure>\n<p>以上述代码为例，得到ExecutorService实例后，我们可以通过两种方式提交任务(Runnable):</p>\n<ul>\n<li><p><code>exec.execute(runnable)</code></p>\n</li>\n<li><p><code>exec.submit(runnable)</code></p>\n</li>\n</ul>\n<p>对于这两种不同的任务提交方式，我们有不同的异常处理办法。</p>\n<h3 id=\"exec-submit-runnable\"><a href=\"#exec-submit-runnable\" class=\"headerlink\" title=\"exec.submit(runnable)\"></a>exec.submit(runnable)</h3><img src=\"/2017/04/26/线程池异常处理方案/submit.png\" alt=\"submit\" title=\"submit\">\n<p>使用<code>exec.submit(runnable)</code>这种方式提交任务时，submit方法会将我们的Runnable包装为一个RunnableFuture对象，这个对象实际上是FutureTask实例，然后将这个FutureTask交给execute方法执行。</p>\n<img src=\"/2017/04/26/线程池异常处理方案/future.png\" alt=\"future\" title=\"future\">\n<p>Future用来管理任务的生命周期，将Future实例提交给异步线程执行后，可以调用Future.get方法获取任务执行的结果。我们知道Runnable执行是没有返回结果的，那么这个结果是怎么来的？</p>\n<img src=\"/2017/04/26/线程池异常处理方案/callable.png\" alt=\"futuretask\" title=\"futuretask\">\n<p>可以看到，在FutureTask的构造方法中，将Runnable包装成了一个Callable类型的对象。</p>\n<img src=\"/2017/04/26/线程池异常处理方案/futuretask_run.png\" alt=\"futuretask_run\" title=\"futuretask_run\">\n<p>FutureTask的run方法中，调用了callable对象的call方法，也就调用了我们传入的Runnable对象的run方法。可以看到，如果代码(Runnable)抛出异常，会被捕获并且把这个异常保存下来。</p>\n<img src=\"/2017/04/26/线程池异常处理方案/futuretask_get.png\" alt=\"futuretask_get\" title=\"futuretask_get\">\n<img src=\"/2017/04/26/线程池异常处理方案/futuretask_report.png\" alt=\"futuretask_report\" title=\"futuretask_report\">\n<p>可以看到，在调用get方法时，会将保存的异常重新抛出。所以，我们在使用submit方法提交任务的时候，利用返回的Future对象，通过他的get方法可以得到任务运行中抛出的异常，然后针对异常做一些处理。</p>\n<p>由于我们在调用submit时并没有给Runnable指定返回结果，所以在将Runnable包装为Callable的时候，会传入一个null，故get方法返回一个null.</p>\n<p>当然，我们也可以直接传入Callable类型的任务，这样就可以获取任务执行返回结果，并且得到任务执行抛出的异常。</p>\n<p>这就是使用线程池时处理任务中抛出异常的第一种方法：<strong>使用ExecutorService.submit执行任务，利用返回的Future对象的get方法接收抛出的异常，然后进行处理</strong></p>\n<h3 id=\"exec-execute-runnable\"><a href=\"#exec-execute-runnable\" class=\"headerlink\" title=\"exec.execute(runnable)\"></a>exec.execute(runnable)</h3><p>利用Future.get得到任务抛出的异常的缺点在于，我们需要显式的遍历Future，调用get方法获取每个任务执行抛出的异常，然后处理。</p>\n<p>很多时候我们仅仅是使用<code>exec.execute(runnable)</code>这种方法来提交我们的任务。这种情况下任务抛出的异常如何处理呢？</p>\n<p>在使用<code>exec.execute(runnable)</code>提交任务的时候(submit其实也是调用execute方法执行)，我们的任务最终会被一个Worker对象执行。这个Worker内部封装了一个Thread对象，这个Thread就是线程池的工作者线程。工作者线程会调用runWorker方法来执行我们提交的任务：(代码比较长，就直接粘过来了)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</div><div class=\"line\">        Thread wt = Thread.currentThread();</div><div class=\"line\">        Runnable task = w.firstTask;</div><div class=\"line\">        w.firstTask = <span class=\"keyword\">null</span>;</div><div class=\"line\">        w.unlock(); <span class=\"comment\">// allow interrupts</span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                w.lock();</div><div class=\"line\">                <span class=\"comment\">// If pool is stopping, ensure thread is interrupted;</span></div><div class=\"line\">                <span class=\"comment\">// if not, ensure thread is not interrupted.  This</span></div><div class=\"line\">                <span class=\"comment\">// requires a recheck in second case to deal with</span></div><div class=\"line\">                <span class=\"comment\">// shutdownNow race while clearing interrupt</span></div><div class=\"line\">                <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class=\"line\">                     (Thread.interrupted() &amp;&amp;</div><div class=\"line\">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class=\"line\">                    !wt.isInterrupted())</div><div class=\"line\">                    wt.interrupt();</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    beforeExecute(wt, task);</div><div class=\"line\">                    Throwable thrown = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        task.run();</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</div><div class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                        afterExecute(task, thrown);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    task = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    w.completedTasks++;</div><div class=\"line\">                    w.unlock();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            completedAbruptly = <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            processWorkerExit(w, completedAbruptly);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码的基本意思就是不停的从任务队列中取出任务执行，如果任务代码(task.run)抛出异常，会被最内层的<code>try--catch</code>块捕获，然后重新抛出。注意到最里面的finally块，在重新<br>抛出异常之前，要先执行<code>afterExecute</code>方法，这个方法的默认实现为空，即什么也不做。我们可以在这个方法上做点文章，这就是我们的第二种方法，<br><strong>重写<code>ThreadPoolExecutor.afterExecute</code>方法，处理传递到<code>afterExecute</code>方法中的异常</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendedExecutor</span> <span class=\"keyword\">extends</span> <span class=\"title\">ThreadPoolExecutor</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">afterExecute</span><span class=\"params\">(Runnable r, Throwable t)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">super</span>.afterExecute(r, t);</div><div class=\"line\">     <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span> &amp;&amp; r <span class=\"keyword\">instanceof</span> Future&lt;?&gt;) &#123;</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         Object result = ((Future&lt;?&gt;) r).get();</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (CancellationException ce) &#123;</div><div class=\"line\">           t = ce;</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (ExecutionException ee) &#123;</div><div class=\"line\">           t = ee.getCause();</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (InterruptedException ie) &#123;</div><div class=\"line\">           Thread.currentThread().interrupt(); <span class=\"comment\">// ignore/reset</span></div><div class=\"line\">       &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>)</div><div class=\"line\">       System.out.println(t);</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>When actions are enclosed in tasks (such as FutureTask) either explicitly or via methods such as submit, these task objects catch and maintain computational exceptions, and so they do not cause abrupt termination, and the internal exceptions are not passed to this method. If you would like to trap both kinds of failures in this method, you can further probe for such cases, as in this sample subclass that prints either the direct cause or the underlying exception if a task has been aborted:</p>\n</blockquote>\n<p>上面是java doc给出的建议。可以看到，代码中还处理了<code>task</code>是<code>FutureTask</code>的情况。回想一下<code>submit</code>方式提交任务的情况：</p>\n<ul>\n<li><p>在submit方法中，我们传入的Runnable/Callable(要执行的任务)被封装为FutureTask对象，交给<code>execute</code>方法执行</p>\n</li>\n<li><p>经过一系列操作，提交的FutureTask对象被Worker对象中的工作者线程所执行，也就是runWorker方法</p>\n<p>此时的代码运行情况：runWorker-&gt;submit方法封装的FutureTask的run方法-&gt;我们提交的Runnable的run方法</p>\n</li>\n<li><p>此时从<code>我们提交的Runnable的run方法</code>中抛出了一个未检测异常RunnableException，被FutureTask的run方法捕获</p>\n</li>\n<li><p>FutureTask的run方法捕获异常后保存，不再重新抛出。同时意味着run方法执行结束。</p>\n</li>\n<li><p>runWorker方法没有检测到异常，<code>task.run</code>当作正常运行结束。但是还是会执行afterExecute方法。</p>\n</li>\n</ul>\n<p>经过这样的梳理，上面的代码为什么这么写就一目了然了。</p>\n<p>上面已经提到了两种解决任务代码抛出未检测异常的方案。接下来是第三种：</p>\n<p>当一个线程因为未捕获的异常而退出时，JVM会把这个事件报告给应用提供的<code>UncaughtExceptionHandler</code>异常处理器，如果没有提供任何的异常处理器，那么默认的行为就是将堆栈信息输送到System.err。</p>\n<p>看一下上面的<code>runWorker</code>方法，如果<code>task.run</code>(任务代码)抛出了异常，异常会层层抛出，最终导致这个线程退出。此时这个抛出的异常就会传递到<code>UncaughtExceptionHandler</code>实例当中，由<code>uncaughtException(Thread t,Throwable e)</code>这个方法处理。</p>\n<p>于是就有了第三种解决任务代码抛出异常的方案：<strong>为工作者线程设置<code>UncaughtExceptionHandler</code>，在<code>uncaughtException</code>方法中处理异常</strong></p>\n<p>注意，这个方案不适用与使用<code>submit</code>方式提交任务的情况，原因上面也提到了，FutureTask的run方法捕获异常后保存，不再重新抛出，意味着<code>runWorker</code>方法并不会捕获到抛出的异常，线程也就不会退出，也不会执行我们设置的<code>UncaughtExceptionHandler</code>。</p>\n<p>如何为工作者线程设置<code>UncaughtExceptionHandler</code>呢？<code>ThreadPoolExecutor</code>的构造函数提供一个<code>ThreadFactory</code>，可以在其中设置我们自定义的<code>UncaughtExceptionHandler</code>，这里不再赘述。</p>\n<p>至于第四中方案，就很简单了：<strong>在我们提供的Runnable的run方法中捕获任务代码可能抛出的所有异常，包括未检测异常</strong>。这种方法比较简单，也有他的局限性，不够灵活，我们的处理被局限在了线程代码边界之内。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面的分析我们得到了四种解决任务代码抛异常的方案：</p>\n<ul>\n<li><p><strong>在我们提供的Runnable的run方法中捕获任务代码可能抛出的所有异常，包括未检测异常</strong></p>\n</li>\n<li><p><strong>使用ExecutorService.submit执行任务，利用返回的Future对象的get方法接收抛出的异常，然后进行处理</strong></p>\n</li>\n<li><p><strong>重写<code>ThreadPoolExecutor.afterExecute</code>方法，处理传递到<code>afterExecute</code>方法中的异常</strong></p>\n</li>\n<li><p><strong>为工作者线程设置<code>UncaughtExceptionHandler</code>，在<code>uncaughtException</code>方法中处理异常</strong></p>\n</li>\n</ul>\n<p>要注意的是，使用最后一种方案时，无法处理以<code>submit</code>的方式提交的任务。</p>\n","excerpt":"<blockquote>\n<p>最近一直在看《java并发编程实战》这本书，之前看过一点，放弃了，现在重新拿过来学习一下。这本书是老外写的，我买的是翻译版。不得不吐槽这本书的翻译，句子晦涩难懂，而且已经读到有好几处错误，差不多跟谷歌翻译一个水平…但是没办法，谁让咱英语差呢？多读几遍，结合jdk源码也能看个大概…</p>\n<p>执行多线程并发任务的时候，如果任务类型相同，一般会考虑使用线程池，一方面利用了并发的优势，一方面避免创建大量线程得不偿失。使用线程池执行的任务一般是我们自己的代码，或者第三方的代码，有没有想过，如果这些代码抛出异常时，线程池会怎么处理呢？如果不处理又会有什么影响？</p>\n</blockquote>","more":"<h2 id=\"异常的影响\"><a href=\"#异常的影响\" class=\"headerlink\" title=\"异常的影响\"></a>异常的影响</h2><p><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp0924/\">Java 理论与实践: 嗨，我的线程到哪里去了？</a>这篇文章列举了一个由于RuntimeException引发的线程泄漏问题：</p>\n<blockquote>\n<p>考虑这样一个假设的中间件服务器应用程序，它聚合来自各种输入源的消息，然后将它们提交到外部服务器应用程序，从外部应用程序接收响应并将响应路由回适当的输入源。对于每个输入源，都有一个以其自己的方式接受其输入消息的插件（通过扫描文件目录、等待套接字连接、轮询数据库表等）。插件可以由第三方编写，即使它们是在服务器 JVM 上运行的。这个应用程序拥有（至少）两个内部工作队列 ― 从插件处接收的正在等待被发送到服务器的消息（“出站消息”队列），以及从服务器接收的正在等待被传递到适当插件的响应（“入站响应”队列）。通过调用插件对象上的服务例程 incomingResponse() ，消息被路由到最初发出请求的插件。</p>\n<p>从插件接收消息后，就被排列到出站消息队列中。由一个或多个从队列读取消息的线程处理出站消息队列中的消息、记录其来源并将它提交给远程服务器应用程序（假定通过 Web 服务接口）。远程应用程序最终通过 Web 服务接口返回响应，然后我们的服务器将接收的响应排列到入站响应队列中。一个或多个响应线程从入站响应队列读取消息并将其路由到适当的插件，从而完成往返“旅程”。<br>在这个应用程序中，有两个消息队列，分别用于出站请求和入站响应，不同的插件内可能也有另外的队列。我们还有几种服务线程，一个从出站消息队列读取请求并将其提交给外部服务器，一个从入站响应队列读取响应并将其路由到插件，在用于向套接字或其它外部请求源提供服务的插件中可能也有一些线程。</p>\n<p>如果这些线程中的一个（如响应分派线程）消失了，将会发生什么？因为插件仍能够提交新消息，所以它们可能不会立即注意到某些方面出错了。消息仍将通过各种输入源到达，并通过我们的应用程序提交到外部服务。因为插件并不期待立即获得其响应，因此它仍没有意识到出了问题。最后，接收的响应将排满队列。如果它们存储在内存中，那么最终将耗尽内存。即使不耗尽内存，也会有人在某个时刻发现响应得不到传递 ― 但这可能需要一些时间，因为系统的其它方面仍能正常发挥作用。</p>\n<p>当主要的任务处理方面由线程池而不是单个线程来处理时，对于偶然的线程泄漏的后果有一定程度的保护，因为一个执行得很好的八线程的线程池，用七个线程完成其工作的效率可能仍可以接受。起初，可能没有任何显著的差异。但是，系统性能最终将下降，虽然这种下降的方式不易被察觉。</p>\n<p>服务器应用程序中的线程泄漏问题在于不是总是容易从外部检测它。因为大多数线程只处理服务器的部分工作负载，或可能仅处理特定类型的后台任务，所以当程序实际上遭遇严重故障时，在用户看来它仍在正常工作。这一点，再加上引起线程泄漏的因素并不总是留下明显痕迹，就会引起令人惊讶甚或使人迷惑的应用程序行为。</p>\n</blockquote>\n<p>我们在使用线程池处理并行任务时，在线程池的生命周期当中，将通过某种抽象机制(Runnable)调用许多未知的代码，这些代码有可能是我们自己写的，也有可能来自第三方。任何代码都有可能抛出一个RuntimeException，如果这些提交的Runnable抛出了RuntimeException，线程池可以捕获他，线程池有可能会创建一个新的线程来代替这个因为抛出异常而结束的线程，也有可能什么也不做(这要看线程池的策略)。即使不会造成线程泄漏，我们也会丢失这个任务的执行情况，无法感知任务执行出现了异常。</p>\n<p>所以，有必要处理提交到线程池运行的代码抛出的异常。</p>\n<h2 id=\"如何处理异常\"><a href=\"#如何处理异常\" class=\"headerlink\" title=\"如何处理异常\"></a>如何处理异常</h2><h3 id=\"简单了解线程池\"><a href=\"#简单了解线程池\" class=\"headerlink\" title=\"简单了解线程池\"></a>简单了解线程池</h3><img src=\"/2017/04/26/线程池异常处理方案/siwei.png\" alt=\"threadpool\" title=\"threadpool\">\n<p>上面是我画的思维导图</p>\n<p>先介绍一下jdk中线程池的实现：</p>\n<img src=\"/2017/04/26/线程池异常处理方案/threadpool.png\" alt=\"threadpool\" title=\"threadpool\">\n<p>Executor定义了一个通用的并发任务框架，即通过execute方法执行一个任务。</p>\n<p>ExecutorService定义了并发框架(线程池)的生命周期。</p>\n<p>AbstractExecutorService、ThreadPoolExecutor、ScheduledThreadPoolExecutor实现了并发任务框架(线程池)。其中ScheduledThreadPoolExecutor支持定时及周期性任务的执行。</p>\n<p>Executors相当于一个线程池工厂类，返回了不同执行策略的线程池对象。</p>\n<p>我们一般使用Executors.new…方法来得到某种线程池：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">newCachedThreadPool</div><div class=\"line\">创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</div><div class=\"line\"></div><div class=\"line\">newFixedThreadPool</div><div class=\"line\">创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</div><div class=\"line\"></div><div class=\"line\">newSingleThreadExecutor</div><div class=\"line\">创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</div><div class=\"line\"></div><div class=\"line\">newScheduledThreadPool</div><div class=\"line\">创建一个定长线程池，支持定时及周期性任务执行。</div></pre></td></tr></table></figure>\n<p>其中，前三者返回ExecutorService实例，他们的实现为ThreadPoolExecutor或其包装类；newScheduledThreadPool返回的是ScheduledExecutorService实例，他的实现为ScheduledThreadPoolExecutor或其包装类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">8</span>);</div></pre></td></tr></table></figure>\n<p>以上述代码为例，得到ExecutorService实例后，我们可以通过两种方式提交任务(Runnable):</p>\n<ul>\n<li><p><code>exec.execute(runnable)</code></p>\n</li>\n<li><p><code>exec.submit(runnable)</code></p>\n</li>\n</ul>\n<p>对于这两种不同的任务提交方式，我们有不同的异常处理办法。</p>\n<h3 id=\"exec-submit-runnable\"><a href=\"#exec-submit-runnable\" class=\"headerlink\" title=\"exec.submit(runnable)\"></a>exec.submit(runnable)</h3><img src=\"/2017/04/26/线程池异常处理方案/submit.png\" alt=\"submit\" title=\"submit\">\n<p>使用<code>exec.submit(runnable)</code>这种方式提交任务时，submit方法会将我们的Runnable包装为一个RunnableFuture对象，这个对象实际上是FutureTask实例，然后将这个FutureTask交给execute方法执行。</p>\n<img src=\"/2017/04/26/线程池异常处理方案/future.png\" alt=\"future\" title=\"future\">\n<p>Future用来管理任务的生命周期，将Future实例提交给异步线程执行后，可以调用Future.get方法获取任务执行的结果。我们知道Runnable执行是没有返回结果的，那么这个结果是怎么来的？</p>\n<img src=\"/2017/04/26/线程池异常处理方案/callable.png\" alt=\"futuretask\" title=\"futuretask\">\n<p>可以看到，在FutureTask的构造方法中，将Runnable包装成了一个Callable类型的对象。</p>\n<img src=\"/2017/04/26/线程池异常处理方案/futuretask_run.png\" alt=\"futuretask_run\" title=\"futuretask_run\">\n<p>FutureTask的run方法中，调用了callable对象的call方法，也就调用了我们传入的Runnable对象的run方法。可以看到，如果代码(Runnable)抛出异常，会被捕获并且把这个异常保存下来。</p>\n<img src=\"/2017/04/26/线程池异常处理方案/futuretask_get.png\" alt=\"futuretask_get\" title=\"futuretask_get\">\n<img src=\"/2017/04/26/线程池异常处理方案/futuretask_report.png\" alt=\"futuretask_report\" title=\"futuretask_report\">\n<p>可以看到，在调用get方法时，会将保存的异常重新抛出。所以，我们在使用submit方法提交任务的时候，利用返回的Future对象，通过他的get方法可以得到任务运行中抛出的异常，然后针对异常做一些处理。</p>\n<p>由于我们在调用submit时并没有给Runnable指定返回结果，所以在将Runnable包装为Callable的时候，会传入一个null，故get方法返回一个null.</p>\n<p>当然，我们也可以直接传入Callable类型的任务，这样就可以获取任务执行返回结果，并且得到任务执行抛出的异常。</p>\n<p>这就是使用线程池时处理任务中抛出异常的第一种方法：<strong>使用ExecutorService.submit执行任务，利用返回的Future对象的get方法接收抛出的异常，然后进行处理</strong></p>\n<h3 id=\"exec-execute-runnable\"><a href=\"#exec-execute-runnable\" class=\"headerlink\" title=\"exec.execute(runnable)\"></a>exec.execute(runnable)</h3><p>利用Future.get得到任务抛出的异常的缺点在于，我们需要显式的遍历Future，调用get方法获取每个任务执行抛出的异常，然后处理。</p>\n<p>很多时候我们仅仅是使用<code>exec.execute(runnable)</code>这种方法来提交我们的任务。这种情况下任务抛出的异常如何处理呢？</p>\n<p>在使用<code>exec.execute(runnable)</code>提交任务的时候(submit其实也是调用execute方法执行)，我们的任务最终会被一个Worker对象执行。这个Worker内部封装了一个Thread对象，这个Thread就是线程池的工作者线程。工作者线程会调用runWorker方法来执行我们提交的任务：(代码比较长，就直接粘过来了)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</div><div class=\"line\">        Thread wt = Thread.currentThread();</div><div class=\"line\">        Runnable task = w.firstTask;</div><div class=\"line\">        w.firstTask = <span class=\"keyword\">null</span>;</div><div class=\"line\">        w.unlock(); <span class=\"comment\">// allow interrupts</span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                w.lock();</div><div class=\"line\">                <span class=\"comment\">// If pool is stopping, ensure thread is interrupted;</span></div><div class=\"line\">                <span class=\"comment\">// if not, ensure thread is not interrupted.  This</span></div><div class=\"line\">                <span class=\"comment\">// requires a recheck in second case to deal with</span></div><div class=\"line\">                <span class=\"comment\">// shutdownNow race while clearing interrupt</span></div><div class=\"line\">                <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class=\"line\">                     (Thread.interrupted() &amp;&amp;</div><div class=\"line\">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class=\"line\">                    !wt.isInterrupted())</div><div class=\"line\">                    wt.interrupt();</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    beforeExecute(wt, task);</div><div class=\"line\">                    Throwable thrown = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        task.run();</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</div><div class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                        afterExecute(task, thrown);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    task = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    w.completedTasks++;</div><div class=\"line\">                    w.unlock();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            completedAbruptly = <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            processWorkerExit(w, completedAbruptly);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码的基本意思就是不停的从任务队列中取出任务执行，如果任务代码(task.run)抛出异常，会被最内层的<code>try--catch</code>块捕获，然后重新抛出。注意到最里面的finally块，在重新<br>抛出异常之前，要先执行<code>afterExecute</code>方法，这个方法的默认实现为空，即什么也不做。我们可以在这个方法上做点文章，这就是我们的第二种方法，<br><strong>重写<code>ThreadPoolExecutor.afterExecute</code>方法，处理传递到<code>afterExecute</code>方法中的异常</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendedExecutor</span> <span class=\"keyword\">extends</span> <span class=\"title\">ThreadPoolExecutor</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">afterExecute</span><span class=\"params\">(Runnable r, Throwable t)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">super</span>.afterExecute(r, t);</div><div class=\"line\">     <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span> &amp;&amp; r <span class=\"keyword\">instanceof</span> Future&lt;?&gt;) &#123;</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         Object result = ((Future&lt;?&gt;) r).get();</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (CancellationException ce) &#123;</div><div class=\"line\">           t = ce;</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (ExecutionException ee) &#123;</div><div class=\"line\">           t = ee.getCause();</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (InterruptedException ie) &#123;</div><div class=\"line\">           Thread.currentThread().interrupt(); <span class=\"comment\">// ignore/reset</span></div><div class=\"line\">       &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>)</div><div class=\"line\">       System.out.println(t);</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>When actions are enclosed in tasks (such as FutureTask) either explicitly or via methods such as submit, these task objects catch and maintain computational exceptions, and so they do not cause abrupt termination, and the internal exceptions are not passed to this method. If you would like to trap both kinds of failures in this method, you can further probe for such cases, as in this sample subclass that prints either the direct cause or the underlying exception if a task has been aborted:</p>\n</blockquote>\n<p>上面是java doc给出的建议。可以看到，代码中还处理了<code>task</code>是<code>FutureTask</code>的情况。回想一下<code>submit</code>方式提交任务的情况：</p>\n<ul>\n<li><p>在submit方法中，我们传入的Runnable/Callable(要执行的任务)被封装为FutureTask对象，交给<code>execute</code>方法执行</p>\n</li>\n<li><p>经过一系列操作，提交的FutureTask对象被Worker对象中的工作者线程所执行，也就是runWorker方法</p>\n<p>此时的代码运行情况：runWorker-&gt;submit方法封装的FutureTask的run方法-&gt;我们提交的Runnable的run方法</p>\n</li>\n<li><p>此时从<code>我们提交的Runnable的run方法</code>中抛出了一个未检测异常RunnableException，被FutureTask的run方法捕获</p>\n</li>\n<li><p>FutureTask的run方法捕获异常后保存，不再重新抛出。同时意味着run方法执行结束。</p>\n</li>\n<li><p>runWorker方法没有检测到异常，<code>task.run</code>当作正常运行结束。但是还是会执行afterExecute方法。</p>\n</li>\n</ul>\n<p>经过这样的梳理，上面的代码为什么这么写就一目了然了。</p>\n<p>上面已经提到了两种解决任务代码抛出未检测异常的方案。接下来是第三种：</p>\n<p>当一个线程因为未捕获的异常而退出时，JVM会把这个事件报告给应用提供的<code>UncaughtExceptionHandler</code>异常处理器，如果没有提供任何的异常处理器，那么默认的行为就是将堆栈信息输送到System.err。</p>\n<p>看一下上面的<code>runWorker</code>方法，如果<code>task.run</code>(任务代码)抛出了异常，异常会层层抛出，最终导致这个线程退出。此时这个抛出的异常就会传递到<code>UncaughtExceptionHandler</code>实例当中，由<code>uncaughtException(Thread t,Throwable e)</code>这个方法处理。</p>\n<p>于是就有了第三种解决任务代码抛出异常的方案：<strong>为工作者线程设置<code>UncaughtExceptionHandler</code>，在<code>uncaughtException</code>方法中处理异常</strong></p>\n<p>注意，这个方案不适用与使用<code>submit</code>方式提交任务的情况，原因上面也提到了，FutureTask的run方法捕获异常后保存，不再重新抛出，意味着<code>runWorker</code>方法并不会捕获到抛出的异常，线程也就不会退出，也不会执行我们设置的<code>UncaughtExceptionHandler</code>。</p>\n<p>如何为工作者线程设置<code>UncaughtExceptionHandler</code>呢？<code>ThreadPoolExecutor</code>的构造函数提供一个<code>ThreadFactory</code>，可以在其中设置我们自定义的<code>UncaughtExceptionHandler</code>，这里不再赘述。</p>\n<p>至于第四中方案，就很简单了：<strong>在我们提供的Runnable的run方法中捕获任务代码可能抛出的所有异常，包括未检测异常</strong>。这种方法比较简单，也有他的局限性，不够灵活，我们的处理被局限在了线程代码边界之内。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面的分析我们得到了四种解决任务代码抛异常的方案：</p>\n<ul>\n<li><p><strong>在我们提供的Runnable的run方法中捕获任务代码可能抛出的所有异常，包括未检测异常</strong></p>\n</li>\n<li><p><strong>使用ExecutorService.submit执行任务，利用返回的Future对象的get方法接收抛出的异常，然后进行处理</strong></p>\n</li>\n<li><p><strong>重写<code>ThreadPoolExecutor.afterExecute</code>方法，处理传递到<code>afterExecute</code>方法中的异常</strong></p>\n</li>\n<li><p><strong>为工作者线程设置<code>UncaughtExceptionHandler</code>，在<code>uncaughtException</code>方法中处理异常</strong></p>\n</li>\n</ul>\n<p>要注意的是，使用最后一种方案时，无法处理以<code>submit</code>的方式提交的任务。</p>"},{"layout":"post","title":"记录工作遇到的坑","date":"2016-09-24T08:30:44.000Z","_content":"\n昨天晚上12.30才进的家门，回来之后还远程合了个代码打了个包，发布restAPI新版本之用。这一周的主要工作就是在做一个web服务器，是一个集群的中间件。因为着急发布新版本，所以昨晚加班到12点多...\n\n主要实现了几个接口，实现了ssl双向验证功能。其实ssl双向验证的功能主要是了解ssl原理之后如何配置的问题。期间还学习了session和cookie的原理。ssl与cookie、session单开一篇进行总结。这篇日志记录一下这周工作中遇到的一些坑，不一定是技术上的，但是遇到这些小问题还是耽误了一些时间。这篇日志也会持续更新，把以后遇到的坑都总结到这里来。\n\n希望以后遇到类似的情况能够迅速找到原因将其解决，同时也希望能帮助到可能会看到这篇文章的人。\n\n## Spring项目通过export方法打包为jar的问题\n\n在前面的日志中已经有[专门的一篇](http://yukai.space/2016/09/19/Spring%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAjar/)来总结这个问题:**当通过export方式打包Spring项目时，一定要记得勾选Add Directory Entries这个选项，否则spring无法正确扫描到controller，发生404**\n\n## 使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常\n\n假如你的项目中有一个类似下面的controller来接收一个请求：\n\n```java\n@GET\n@RequestMapping(\"web/{groupName}\")\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\npublic void getWorkerAddress(HttpServletRequest request, HttpServletResponse response,\n\t\t@PathVariable String groupName) {\n\t\tdoSomething...\n}\t\t\n\n```\n\n当你的项目运行时你发起一个`http://ip:port/web/groupName1`这样的请求，那么很有可能服务器会报这样一个异常：**java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.**\n\n大概的意思就是参数名称信息没有在类文件中找到。若是浏览器为客户端，浏览器的页面是这样的：\n\n{% asset_img error.png error %}\n\n解决这个异常的方法有两种：\n\n**1.在@PathVariable注解后面加上参数名，比如：@PathVariable(\"groupName\")**\n\n<!-- more -->\n\n**2.编译时将debug信息勾选进去：**\n\n{% asset_img compiler.png compiler %}\n\n编译时把上图绿色框中的单选框勾选，就不会报异常。原因在于Local variable属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量名称和描述符之间的映射关系。\n\n顺便了解一下上面四个选项的作用：\n\n{% asset_img gengeration.png compiler %}\n\n图片截取自：[Eclipse用户手册](http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-compiler.htm)\n\n其实就是java工程编译时的一些选项。当我们在debug时遇到问题，比如断点打不上，source not found等等或许修改这些选项可以得到解决。\n\n参考一篇文章：[java编译时生成调试信息选项详解（javac -g）](http://daimojingdeyu.iteye.com/blog/679030)\n\n## Windows环境下使用Curl，要使用双引号包裹内容\n\nweb服务器是通过curl来测试的。之前自己也没用过这个所谓的命令行浏览器工具。在机器上装好curl之后，把测试那边提供的脚本拿过来，由于脚本是linux环境下的，做了一点修改之后(其实就是直接换成.bat啦)就直接跑了。脚本内容类似这样：\n\n```\ncurl -X POST -H 'content-type: application/json' -d @del.txt https://localhost:8899/web/rest/data/load/topictarget  -k -b cookie.txt>delresult.txt\n```\n\n但是实际测试的过程中，发现收到的post的数据为null，确定了不是服务器的问题之后，感觉应该是curl使用的问题。查了一些资料，是说post的数据要使用双引号包裹，而不是单引号。由于是从del.txt中提取post的数据，所以不存在这个问题。后来将content-type: application/json 的单引号换成双引号之后，问题解决。\n\n**所以：Windows环境下使用Curl，要使用双引号包裹需要加引号的内容，而不是单引号**\n\n## Spring项目运行过程中，@Autowired注解的变量为null的问题\n\n2016/09/09 更新\n\n这两天开发了一个公众账号来做一些简单的记账工作。后台服务器是用springboot搭建的，测试过程中遇到了这么个情况:\n\n在运行时服务器报了空指针NullPointerException异常，debug看了一下，发现是一个使用了@Autowired注解的变量没有被初始化。但是按理来说使用了@Autowired注解某个变量后spring会自动为我们实例化这个变量的啊！谷歌了一下，找到了一个类似的情况：[Why is my Spring @Autowired field null?](http://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null).\n\n下面模拟一下问题出现的场景(代码来自上面的链接)：\n\n```java\n@Controller\npublic class MileageFeeController {    \n    @RequestMapping(\"/mileage/{miles}\")\n    @ResponseBody\n    public float mileageFee(@PathVariable int miles) {\n        MileageFeeCalculator calc = new MileageFeeCalculator();\n        return calc.mileageCharge(miles);\n    }\n}\n\n@Service\npublic class MileageFeeCalculator {\n\n    @Autowired\n    private MileageRateService rateService; // <--- should be autowired, is null\n\n    public float mileageCharge(final int miles) {\n        return (miles * rateService.ratePerMile()); // <--- throws NPE\n    }\n}\n\n@Service\npublic class MileageFeeCalculator {\n\n    @Autowired\n    private MileageRateService rateService; // <--- should be autowired, is null\n\n    public float mileageCharge(final int miles) {\n        return (miles * rateService.ratePerMile()); // <--- throws NPE\n    }\n}\n```\n\n访问MileageFeeController时报错：\n\n```\njava.lang.NullPointerException: null\n    at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13)\n    at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14)\n```\n\n可以看到，变量rateService是个空值。导致空指针异常...\n\n原因就在于MileageFeeController.mileageFee中使用了new这种方式实例化了MileageFeeCalculator对象，该对象中的rateService为空，我们使用new这种方式实例化对象时，无法通过spring的@Autowired注解自动实例化对象中的属性。解决的方法就是实例化对象时应该通知spring，使其能够自动配置。\n\n我采用了上述链接中的第三种方法，解决了问题：\n\n```java\n@Component\npublic class ApplicationContextHolder implements ApplicationContextAware {\n    private static ApplicationContext context;\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        context = applicationContext;   \n    }\n\n    public static ApplicationContext getContext() {\n        return context;\n    }\n}\n\n@Controller\npublic class MileageFeeController {    \n    @RequestMapping(\"/mileage/{miles}\")\n    @ResponseBody\n    public float mileageFee(@PathVariable int miles) {\n        MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);\n        return calc.mileageCharge(miles);\n    }\n}\n```\n\n发生这些问题的原因还是在于对框架的不熟悉，内部原理不甚明了。有机会真得研究研究spring的源码~~\n\n## @RestController与@Controller\n\n2016/10/24 更新\n\nSpringboot 使用 Thymeleaf 模板 打算给公众号加一点地图功能，按照[这个教程](https://hellokoding.com/spring-boot-hello-world-example-with-thymeleaf/)在springboot项目中配置Thymeleaf，但是每次都没有正确返回html页面，反而是返回了这个html的名称。试了几次才发现自己用错了@RestController这个注解...Controller代码如下：\n\n```java\n@RestController\n@RequestMapping(\"/wechat\")\npublic class MapController {\n    @RequestMapping(\"/map/showRestaurant\")\n    public String showRestaurant(@RequestParam(value = \"location_x\", required = true) String location_x,\n            @RequestParam(value = \"location_y\", required = true) String location_y,\n            @RequestParam(value = \"label\", required = true) String label, Model model) {\n        model.addAttribute(\"locationx\", location_x);\n        model.addAttribute(\"locationy\", location_y);\n        model.addAttribute(\"label\",label);\n        return \"hello\";\n    }\n}\n\n```\n问题原因就在于上面的@RestController这个注解，将其替换为@Controller便解决了。\n \n根本原因在于@RestController与@Controller[这两个注解之间的区别](http://stackoverflow.com/questions/25242321/difference-between-spring-controller-and-restcontroller-annotation)\n\n## Linux下可靠的启动webservice\n\n2016/12/14 更新\n\n今天线上webservice发现了一个问题，技服把出现的问题描述和日志发给了我，需要解决一下。最终确定不是代码的问题，而是linux下启动程序的方式引发的一个错误。虽然简单，却很容易被疏忽导致问题的发生，值得记录下来。\n情况是这样的，每次springboot程序会不定时自动停止，观察log发现，每次挂掉之前都会打印一行log,大致意思是，代码中调用的系统程序tail退出了。查看代码时发现确实在tail程序退出时会打印这么一行日志，但却是正常表现，程序运行在一个死循环当中，随后就会重启tail这个程序。循环当中也做了相应的异常捕获，按道理来说webservice不应该挂掉。初步怀疑多次启动tail导致内存泄漏以至于程序退出。由于代码中没有对内存泄漏这种error类型的异常捕获和记录到日志，从日志中无法判断是否发生了内存泄漏。代码中实现了Throwable级别异常的捕获，并记录异常信息到日志，再次抛出该异常。\n打包，发送给技服到测试机上去跑。一会之后，又挂了。观察新的Log，竟然与之前的没什么区别，并没有什么新的异常信息输出。也就是说，压根没有异常从代码中抛出。很有可能是程序被认为关闭或被系统干掉了。但是之前询问技服，对方否定了这种情况。\n这就怪了。继续观察日志，此时，发现这么一行：`Unregistering JMX-exposed beans on shutdown`.确实是springboot退出时打印的信息。google之，大部分的答案是没有添加依赖`spring-boot-starter-web`所导致springboot无法启动。与现在的情况不符，当前情况是启动正常，运行时突然挂掉。\n再次询问技服是否kill掉了运行webservice的进程。技服否认，说该程序时运行在后台的，继续询问如何运行在后台，回答是： `java -jar MyApplication.jar & `\n果然，使用这种方式运行在后台的程序，当ssh断掉或关闭bash窗口后，程序依然会被系统干掉，父进程都被干掉了，子进程也一并干掉了...\n正确的启动方式应为：`nohup java -jar MyApplication.jar &`\n\n```\nnohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。\n\n该命令的一般形式为：nohup command &\n\n使用nohup命令提交作业\n\n如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：\n\nnohup command > myout.file 2>&1 &\n\n在上面的例子中，输出被重定向到myout.file文件中。\n```\n该问题虽然不是很难解决，但是很容易被忽略。故在此记录。\n\n## 持续更新中....\n\n\n\n\n\n\n\n\n","source":"_posts/记录这周工作遇到的坑.md","raw":"---\nlayout: post\ntitle: 记录工作遇到的坑\ndate: 2016-09-24 16:30:44\ncategories: 技术 \ntags: \n- spring\n- curl\n---\n\n昨天晚上12.30才进的家门，回来之后还远程合了个代码打了个包，发布restAPI新版本之用。这一周的主要工作就是在做一个web服务器，是一个集群的中间件。因为着急发布新版本，所以昨晚加班到12点多...\n\n主要实现了几个接口，实现了ssl双向验证功能。其实ssl双向验证的功能主要是了解ssl原理之后如何配置的问题。期间还学习了session和cookie的原理。ssl与cookie、session单开一篇进行总结。这篇日志记录一下这周工作中遇到的一些坑，不一定是技术上的，但是遇到这些小问题还是耽误了一些时间。这篇日志也会持续更新，把以后遇到的坑都总结到这里来。\n\n希望以后遇到类似的情况能够迅速找到原因将其解决，同时也希望能帮助到可能会看到这篇文章的人。\n\n## Spring项目通过export方法打包为jar的问题\n\n在前面的日志中已经有[专门的一篇](http://yukai.space/2016/09/19/Spring%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAjar/)来总结这个问题:**当通过export方式打包Spring项目时，一定要记得勾选Add Directory Entries这个选项，否则spring无法正确扫描到controller，发生404**\n\n## 使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常\n\n假如你的项目中有一个类似下面的controller来接收一个请求：\n\n```java\n@GET\n@RequestMapping(\"web/{groupName}\")\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\npublic void getWorkerAddress(HttpServletRequest request, HttpServletResponse response,\n\t\t@PathVariable String groupName) {\n\t\tdoSomething...\n}\t\t\n\n```\n\n当你的项目运行时你发起一个`http://ip:port/web/groupName1`这样的请求，那么很有可能服务器会报这样一个异常：**java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.**\n\n大概的意思就是参数名称信息没有在类文件中找到。若是浏览器为客户端，浏览器的页面是这样的：\n\n{% asset_img error.png error %}\n\n解决这个异常的方法有两种：\n\n**1.在@PathVariable注解后面加上参数名，比如：@PathVariable(\"groupName\")**\n\n<!-- more -->\n\n**2.编译时将debug信息勾选进去：**\n\n{% asset_img compiler.png compiler %}\n\n编译时把上图绿色框中的单选框勾选，就不会报异常。原因在于Local variable属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量名称和描述符之间的映射关系。\n\n顺便了解一下上面四个选项的作用：\n\n{% asset_img gengeration.png compiler %}\n\n图片截取自：[Eclipse用户手册](http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-compiler.htm)\n\n其实就是java工程编译时的一些选项。当我们在debug时遇到问题，比如断点打不上，source not found等等或许修改这些选项可以得到解决。\n\n参考一篇文章：[java编译时生成调试信息选项详解（javac -g）](http://daimojingdeyu.iteye.com/blog/679030)\n\n## Windows环境下使用Curl，要使用双引号包裹内容\n\nweb服务器是通过curl来测试的。之前自己也没用过这个所谓的命令行浏览器工具。在机器上装好curl之后，把测试那边提供的脚本拿过来，由于脚本是linux环境下的，做了一点修改之后(其实就是直接换成.bat啦)就直接跑了。脚本内容类似这样：\n\n```\ncurl -X POST -H 'content-type: application/json' -d @del.txt https://localhost:8899/web/rest/data/load/topictarget  -k -b cookie.txt>delresult.txt\n```\n\n但是实际测试的过程中，发现收到的post的数据为null，确定了不是服务器的问题之后，感觉应该是curl使用的问题。查了一些资料，是说post的数据要使用双引号包裹，而不是单引号。由于是从del.txt中提取post的数据，所以不存在这个问题。后来将content-type: application/json 的单引号换成双引号之后，问题解决。\n\n**所以：Windows环境下使用Curl，要使用双引号包裹需要加引号的内容，而不是单引号**\n\n## Spring项目运行过程中，@Autowired注解的变量为null的问题\n\n2016/09/09 更新\n\n这两天开发了一个公众账号来做一些简单的记账工作。后台服务器是用springboot搭建的，测试过程中遇到了这么个情况:\n\n在运行时服务器报了空指针NullPointerException异常，debug看了一下，发现是一个使用了@Autowired注解的变量没有被初始化。但是按理来说使用了@Autowired注解某个变量后spring会自动为我们实例化这个变量的啊！谷歌了一下，找到了一个类似的情况：[Why is my Spring @Autowired field null?](http://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null).\n\n下面模拟一下问题出现的场景(代码来自上面的链接)：\n\n```java\n@Controller\npublic class MileageFeeController {    \n    @RequestMapping(\"/mileage/{miles}\")\n    @ResponseBody\n    public float mileageFee(@PathVariable int miles) {\n        MileageFeeCalculator calc = new MileageFeeCalculator();\n        return calc.mileageCharge(miles);\n    }\n}\n\n@Service\npublic class MileageFeeCalculator {\n\n    @Autowired\n    private MileageRateService rateService; // <--- should be autowired, is null\n\n    public float mileageCharge(final int miles) {\n        return (miles * rateService.ratePerMile()); // <--- throws NPE\n    }\n}\n\n@Service\npublic class MileageFeeCalculator {\n\n    @Autowired\n    private MileageRateService rateService; // <--- should be autowired, is null\n\n    public float mileageCharge(final int miles) {\n        return (miles * rateService.ratePerMile()); // <--- throws NPE\n    }\n}\n```\n\n访问MileageFeeController时报错：\n\n```\njava.lang.NullPointerException: null\n    at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13)\n    at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14)\n```\n\n可以看到，变量rateService是个空值。导致空指针异常...\n\n原因就在于MileageFeeController.mileageFee中使用了new这种方式实例化了MileageFeeCalculator对象，该对象中的rateService为空，我们使用new这种方式实例化对象时，无法通过spring的@Autowired注解自动实例化对象中的属性。解决的方法就是实例化对象时应该通知spring，使其能够自动配置。\n\n我采用了上述链接中的第三种方法，解决了问题：\n\n```java\n@Component\npublic class ApplicationContextHolder implements ApplicationContextAware {\n    private static ApplicationContext context;\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        context = applicationContext;   \n    }\n\n    public static ApplicationContext getContext() {\n        return context;\n    }\n}\n\n@Controller\npublic class MileageFeeController {    \n    @RequestMapping(\"/mileage/{miles}\")\n    @ResponseBody\n    public float mileageFee(@PathVariable int miles) {\n        MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);\n        return calc.mileageCharge(miles);\n    }\n}\n```\n\n发生这些问题的原因还是在于对框架的不熟悉，内部原理不甚明了。有机会真得研究研究spring的源码~~\n\n## @RestController与@Controller\n\n2016/10/24 更新\n\nSpringboot 使用 Thymeleaf 模板 打算给公众号加一点地图功能，按照[这个教程](https://hellokoding.com/spring-boot-hello-world-example-with-thymeleaf/)在springboot项目中配置Thymeleaf，但是每次都没有正确返回html页面，反而是返回了这个html的名称。试了几次才发现自己用错了@RestController这个注解...Controller代码如下：\n\n```java\n@RestController\n@RequestMapping(\"/wechat\")\npublic class MapController {\n    @RequestMapping(\"/map/showRestaurant\")\n    public String showRestaurant(@RequestParam(value = \"location_x\", required = true) String location_x,\n            @RequestParam(value = \"location_y\", required = true) String location_y,\n            @RequestParam(value = \"label\", required = true) String label, Model model) {\n        model.addAttribute(\"locationx\", location_x);\n        model.addAttribute(\"locationy\", location_y);\n        model.addAttribute(\"label\",label);\n        return \"hello\";\n    }\n}\n\n```\n问题原因就在于上面的@RestController这个注解，将其替换为@Controller便解决了。\n \n根本原因在于@RestController与@Controller[这两个注解之间的区别](http://stackoverflow.com/questions/25242321/difference-between-spring-controller-and-restcontroller-annotation)\n\n## Linux下可靠的启动webservice\n\n2016/12/14 更新\n\n今天线上webservice发现了一个问题，技服把出现的问题描述和日志发给了我，需要解决一下。最终确定不是代码的问题，而是linux下启动程序的方式引发的一个错误。虽然简单，却很容易被疏忽导致问题的发生，值得记录下来。\n情况是这样的，每次springboot程序会不定时自动停止，观察log发现，每次挂掉之前都会打印一行log,大致意思是，代码中调用的系统程序tail退出了。查看代码时发现确实在tail程序退出时会打印这么一行日志，但却是正常表现，程序运行在一个死循环当中，随后就会重启tail这个程序。循环当中也做了相应的异常捕获，按道理来说webservice不应该挂掉。初步怀疑多次启动tail导致内存泄漏以至于程序退出。由于代码中没有对内存泄漏这种error类型的异常捕获和记录到日志，从日志中无法判断是否发生了内存泄漏。代码中实现了Throwable级别异常的捕获，并记录异常信息到日志，再次抛出该异常。\n打包，发送给技服到测试机上去跑。一会之后，又挂了。观察新的Log，竟然与之前的没什么区别，并没有什么新的异常信息输出。也就是说，压根没有异常从代码中抛出。很有可能是程序被认为关闭或被系统干掉了。但是之前询问技服，对方否定了这种情况。\n这就怪了。继续观察日志，此时，发现这么一行：`Unregistering JMX-exposed beans on shutdown`.确实是springboot退出时打印的信息。google之，大部分的答案是没有添加依赖`spring-boot-starter-web`所导致springboot无法启动。与现在的情况不符，当前情况是启动正常，运行时突然挂掉。\n再次询问技服是否kill掉了运行webservice的进程。技服否认，说该程序时运行在后台的，继续询问如何运行在后台，回答是： `java -jar MyApplication.jar & `\n果然，使用这种方式运行在后台的程序，当ssh断掉或关闭bash窗口后，程序依然会被系统干掉，父进程都被干掉了，子进程也一并干掉了...\n正确的启动方式应为：`nohup java -jar MyApplication.jar &`\n\n```\nnohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。\n\n该命令的一般形式为：nohup command &\n\n使用nohup命令提交作业\n\n如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：\n\nnohup command > myout.file 2>&1 &\n\n在上面的例子中，输出被重定向到myout.file文件中。\n```\n该问题虽然不是很难解决，但是很容易被忽略。故在此记录。\n\n## 持续更新中....\n\n\n\n\n\n\n\n\n","slug":"记录这周工作遇到的坑","published":1,"updated":"2017-04-11T13:08:38.860Z","comments":1,"photos":[],"link":"","_id":"cj4vch4hl005xx3gcvmq8xhew","content":"<p>昨天晚上12.30才进的家门，回来之后还远程合了个代码打了个包，发布restAPI新版本之用。这一周的主要工作就是在做一个web服务器，是一个集群的中间件。因为着急发布新版本，所以昨晚加班到12点多…</p>\n<p>主要实现了几个接口，实现了ssl双向验证功能。其实ssl双向验证的功能主要是了解ssl原理之后如何配置的问题。期间还学习了session和cookie的原理。ssl与cookie、session单开一篇进行总结。这篇日志记录一下这周工作中遇到的一些坑，不一定是技术上的，但是遇到这些小问题还是耽误了一些时间。这篇日志也会持续更新，把以后遇到的坑都总结到这里来。</p>\n<p>希望以后遇到类似的情况能够迅速找到原因将其解决，同时也希望能帮助到可能会看到这篇文章的人。</p>\n<h2 id=\"Spring项目通过export方法打包为jar的问题\"><a href=\"#Spring项目通过export方法打包为jar的问题\" class=\"headerlink\" title=\"Spring项目通过export方法打包为jar的问题\"></a>Spring项目通过export方法打包为jar的问题</h2><p>在前面的日志中已经有<a href=\"http://yukai.space/2016/09/19/Spring%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAjar/\">专门的一篇</a>来总结这个问题:<strong>当通过export方式打包Spring项目时，一定要记得勾选Add Directory Entries这个选项，否则spring无法正确扫描到controller，发生404</strong></p>\n<h2 id=\"使用-PathVariable注解时抛出java-lang-IllegalArgumentException异常\"><a href=\"#使用-PathVariable注解时抛出java-lang-IllegalArgumentException异常\" class=\"headerlink\" title=\"使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常\"></a>使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常</h2><p>假如你的项目中有一个类似下面的controller来接收一个请求：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@GET</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"web/&#123;groupName&#125;\"</span>)</div><div class=\"line\"><span class=\"meta\">@Consumes</span>(MediaType.APPLICATION_JSON)</div><div class=\"line\"><span class=\"meta\">@Produces</span>(MediaType.APPLICATION_JSON)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getWorkerAddress</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response,</span></span></div><div class=\"line\">\t\t@PathVariable String groupName) &#123;</div><div class=\"line\">\t\tdoSomething...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当你的项目运行时你发起一个<code>http://ip:port/web/groupName1</code>这样的请求，那么很有可能服务器会报这样一个异常：<strong>java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.</strong></p>\n<p>大概的意思就是参数名称信息没有在类文件中找到。若是浏览器为客户端，浏览器的页面是这样的：</p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/error.png\" alt=\"error\" title=\"error\">\n<p>解决这个异常的方法有两种：</p>\n<p><strong>1.在@PathVariable注解后面加上参数名，比如：@PathVariable(“groupName”)</strong></p>\n<a id=\"more\"></a>\n<p><strong>2.编译时将debug信息勾选进去：</strong></p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/compiler.png\" alt=\"compiler\" title=\"compiler\">\n<p>编译时把上图绿色框中的单选框勾选，就不会报异常。原因在于Local variable属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量名称和描述符之间的映射关系。</p>\n<p>顺便了解一下上面四个选项的作用：</p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/gengeration.png\" alt=\"compiler\" title=\"compiler\">\n<p>图片截取自：<a href=\"http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-compiler.htm\" target=\"_blank\" rel=\"external\">Eclipse用户手册</a></p>\n<p>其实就是java工程编译时的一些选项。当我们在debug时遇到问题，比如断点打不上，source not found等等或许修改这些选项可以得到解决。</p>\n<p>参考一篇文章：<a href=\"http://daimojingdeyu.iteye.com/blog/679030\" target=\"_blank\" rel=\"external\">java编译时生成调试信息选项详解（javac -g）</a></p>\n<h2 id=\"Windows环境下使用Curl，要使用双引号包裹内容\"><a href=\"#Windows环境下使用Curl，要使用双引号包裹内容\" class=\"headerlink\" title=\"Windows环境下使用Curl，要使用双引号包裹内容\"></a>Windows环境下使用Curl，要使用双引号包裹内容</h2><p>web服务器是通过curl来测试的。之前自己也没用过这个所谓的命令行浏览器工具。在机器上装好curl之后，把测试那边提供的脚本拿过来，由于脚本是linux环境下的，做了一点修改之后(其实就是直接换成.bat啦)就直接跑了。脚本内容类似这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -X POST -H &apos;content-type: application/json&apos; -d @del.txt https://localhost:8899/web/rest/data/load/topictarget  -k -b cookie.txt&gt;delresult.txt</div></pre></td></tr></table></figure>\n<p>但是实际测试的过程中，发现收到的post的数据为null，确定了不是服务器的问题之后，感觉应该是curl使用的问题。查了一些资料，是说post的数据要使用双引号包裹，而不是单引号。由于是从del.txt中提取post的数据，所以不存在这个问题。后来将content-type: application/json 的单引号换成双引号之后，问题解决。</p>\n<p><strong>所以：Windows环境下使用Curl，要使用双引号包裹需要加引号的内容，而不是单引号</strong></p>\n<h2 id=\"Spring项目运行过程中，-Autowired注解的变量为null的问题\"><a href=\"#Spring项目运行过程中，-Autowired注解的变量为null的问题\" class=\"headerlink\" title=\"Spring项目运行过程中，@Autowired注解的变量为null的问题\"></a>Spring项目运行过程中，@Autowired注解的变量为null的问题</h2><p>2016/09/09 更新</p>\n<p>这两天开发了一个公众账号来做一些简单的记账工作。后台服务器是用springboot搭建的，测试过程中遇到了这么个情况:</p>\n<p>在运行时服务器报了空指针NullPointerException异常，debug看了一下，发现是一个使用了@Autowired注解的变量没有被初始化。但是按理来说使用了@Autowired注解某个变量后spring会自动为我们实例化这个变量的啊！谷歌了一下，找到了一个类似的情况：<a href=\"http://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null\" target=\"_blank\" rel=\"external\">Why is my Spring @Autowired field null?</a>.</p>\n<p>下面模拟一下问题出现的场景(代码来自上面的链接)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeController</span> </span>&#123;    </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mileage/&#123;miles&#125;\"</span>)</div><div class=\"line\">    <span class=\"meta\">@ResponseBody</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageFee</span><span class=\"params\">(@PathVariable <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        MileageFeeCalculator calc = <span class=\"keyword\">new</span> MileageFeeCalculator();</div><div class=\"line\">        <span class=\"keyword\">return</span> calc.mileageCharge(miles);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Service</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeCalculator</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> MileageRateService rateService; <span class=\"comment\">// &lt;--- should be autowired, is null</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageCharge</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (miles * rateService.ratePerMile()); <span class=\"comment\">// &lt;--- throws NPE</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Service</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeCalculator</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> MileageRateService rateService; <span class=\"comment\">// &lt;--- should be autowired, is null</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageCharge</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (miles * rateService.ratePerMile()); <span class=\"comment\">// &lt;--- throws NPE</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>访问MileageFeeController时报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.NullPointerException: null</div><div class=\"line\">    at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13)</div><div class=\"line\">    at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14)</div></pre></td></tr></table></figure>\n<p>可以看到，变量rateService是个空值。导致空指针异常…</p>\n<p>原因就在于MileageFeeController.mileageFee中使用了new这种方式实例化了MileageFeeCalculator对象，该对象中的rateService为空，我们使用new这种方式实例化对象时，无法通过spring的@Autowired注解自动实例化对象中的属性。解决的方法就是实例化对象时应该通知spring，使其能够自动配置。</p>\n<p>我采用了上述链接中的第三种方法，解决了问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Component</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationContextHolder</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationContextAware</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ApplicationContext context;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</div><div class=\"line\">        context = applicationContext;   </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ApplicationContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> context;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeController</span> </span>&#123;    </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mileage/&#123;miles&#125;\"</span>)</div><div class=\"line\">    <span class=\"meta\">@ResponseBody</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageFee</span><span class=\"params\">(@PathVariable <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);</div><div class=\"line\">        <span class=\"keyword\">return</span> calc.mileageCharge(miles);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>发生这些问题的原因还是在于对框架的不熟悉，内部原理不甚明了。有机会真得研究研究spring的源码~~</p>\n<h2 id=\"RestController与-Controller\"><a href=\"#RestController与-Controller\" class=\"headerlink\" title=\"@RestController与@Controller\"></a>@RestController与@Controller</h2><p>2016/10/24 更新</p>\n<p>Springboot 使用 Thymeleaf 模板 打算给公众号加一点地图功能，按照<a href=\"https://hellokoding.com/spring-boot-hello-world-example-with-thymeleaf/\" target=\"_blank\" rel=\"external\">这个教程</a>在springboot项目中配置Thymeleaf，但是每次都没有正确返回html页面，反而是返回了这个html的名称。试了几次才发现自己用错了@RestController这个注解…Controller代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@RestController</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/wechat\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapController</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/map/showRestaurant\"</span>)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showRestaurant</span><span class=\"params\">(@RequestParam(value = <span class=\"string\">\"location_x\"</span>, required = <span class=\"keyword\">true</span>)</span> String location_x,</span></div><div class=\"line\">            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"location_y\"</span>, required = <span class=\"keyword\">true</span>)</span> String location_y,</div><div class=\"line\">            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"label\"</span>, required = <span class=\"keyword\">true</span>)</span> String label, Model model) &#123;</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"locationx\"</span>, location_x);</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"locationy\"</span>, location_y);</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"label\"</span>,label);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"hello\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>问题原因就在于上面的@RestController这个注解，将其替换为@Controller便解决了。</p>\n<p>根本原因在于@RestController与@Controller<a href=\"http://stackoverflow.com/questions/25242321/difference-between-spring-controller-and-restcontroller-annotation\" target=\"_blank\" rel=\"external\">这两个注解之间的区别</a></p>\n<h2 id=\"Linux下可靠的启动webservice\"><a href=\"#Linux下可靠的启动webservice\" class=\"headerlink\" title=\"Linux下可靠的启动webservice\"></a>Linux下可靠的启动webservice</h2><p>2016/12/14 更新</p>\n<p>今天线上webservice发现了一个问题，技服把出现的问题描述和日志发给了我，需要解决一下。最终确定不是代码的问题，而是linux下启动程序的方式引发的一个错误。虽然简单，却很容易被疏忽导致问题的发生，值得记录下来。<br>情况是这样的，每次springboot程序会不定时自动停止，观察log发现，每次挂掉之前都会打印一行log,大致意思是，代码中调用的系统程序tail退出了。查看代码时发现确实在tail程序退出时会打印这么一行日志，但却是正常表现，程序运行在一个死循环当中，随后就会重启tail这个程序。循环当中也做了相应的异常捕获，按道理来说webservice不应该挂掉。初步怀疑多次启动tail导致内存泄漏以至于程序退出。由于代码中没有对内存泄漏这种error类型的异常捕获和记录到日志，从日志中无法判断是否发生了内存泄漏。代码中实现了Throwable级别异常的捕获，并记录异常信息到日志，再次抛出该异常。<br>打包，发送给技服到测试机上去跑。一会之后，又挂了。观察新的Log，竟然与之前的没什么区别，并没有什么新的异常信息输出。也就是说，压根没有异常从代码中抛出。很有可能是程序被认为关闭或被系统干掉了。但是之前询问技服，对方否定了这种情况。<br>这就怪了。继续观察日志，此时，发现这么一行：<code>Unregistering JMX-exposed beans on shutdown</code>.确实是springboot退出时打印的信息。google之，大部分的答案是没有添加依赖<code>spring-boot-starter-web</code>所导致springboot无法启动。与现在的情况不符，当前情况是启动正常，运行时突然挂掉。<br>再次询问技服是否kill掉了运行webservice的进程。技服否认，说该程序时运行在后台的，继续询问如何运行在后台，回答是： <code>java -jar MyApplication.jar &amp;</code><br>果然，使用这种方式运行在后台的程序，当ssh断掉或关闭bash窗口后，程序依然会被系统干掉，父进程都被干掉了，子进程也一并干掉了…<br>正确的启动方式应为：<code>nohup java -jar MyApplication.jar &amp;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。</div><div class=\"line\"></div><div class=\"line\">该命令的一般形式为：nohup command &amp;</div><div class=\"line\"></div><div class=\"line\">使用nohup命令提交作业</div><div class=\"line\"></div><div class=\"line\">如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</div><div class=\"line\"></div><div class=\"line\">nohup command &gt; myout.file 2&gt;&amp;1 &amp;</div><div class=\"line\"></div><div class=\"line\">在上面的例子中，输出被重定向到myout.file文件中。</div></pre></td></tr></table></figure>\n<p>该问题虽然不是很难解决，但是很容易被忽略。故在此记录。</p>\n<h2 id=\"持续更新中…\"><a href=\"#持续更新中…\" class=\"headerlink\" title=\"持续更新中….\"></a>持续更新中….</h2>","excerpt":"<p>昨天晚上12.30才进的家门，回来之后还远程合了个代码打了个包，发布restAPI新版本之用。这一周的主要工作就是在做一个web服务器，是一个集群的中间件。因为着急发布新版本，所以昨晚加班到12点多…</p>\n<p>主要实现了几个接口，实现了ssl双向验证功能。其实ssl双向验证的功能主要是了解ssl原理之后如何配置的问题。期间还学习了session和cookie的原理。ssl与cookie、session单开一篇进行总结。这篇日志记录一下这周工作中遇到的一些坑，不一定是技术上的，但是遇到这些小问题还是耽误了一些时间。这篇日志也会持续更新，把以后遇到的坑都总结到这里来。</p>\n<p>希望以后遇到类似的情况能够迅速找到原因将其解决，同时也希望能帮助到可能会看到这篇文章的人。</p>\n<h2 id=\"Spring项目通过export方法打包为jar的问题\"><a href=\"#Spring项目通过export方法打包为jar的问题\" class=\"headerlink\" title=\"Spring项目通过export方法打包为jar的问题\"></a>Spring项目通过export方法打包为jar的问题</h2><p>在前面的日志中已经有<a href=\"http://yukai.space/2016/09/19/Spring%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%BAjar/\">专门的一篇</a>来总结这个问题:<strong>当通过export方式打包Spring项目时，一定要记得勾选Add Directory Entries这个选项，否则spring无法正确扫描到controller，发生404</strong></p>\n<h2 id=\"使用-PathVariable注解时抛出java-lang-IllegalArgumentException异常\"><a href=\"#使用-PathVariable注解时抛出java-lang-IllegalArgumentException异常\" class=\"headerlink\" title=\"使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常\"></a>使用@PathVariable注解时抛出java.lang.IllegalArgumentException异常</h2><p>假如你的项目中有一个类似下面的controller来接收一个请求：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@GET</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"web/&#123;groupName&#125;\"</span>)</div><div class=\"line\"><span class=\"meta\">@Consumes</span>(MediaType.APPLICATION_JSON)</div><div class=\"line\"><span class=\"meta\">@Produces</span>(MediaType.APPLICATION_JSON)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getWorkerAddress</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response,</div><div class=\"line\">\t\t@PathVariable String groupName)</span> </span>&#123;</div><div class=\"line\">\t\tdoSomething...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当你的项目运行时你发起一个<code>http://ip:port/web/groupName1</code>这样的请求，那么很有可能服务器会报这样一个异常：<strong>java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.</strong></p>\n<p>大概的意思就是参数名称信息没有在类文件中找到。若是浏览器为客户端，浏览器的页面是这样的：</p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/error.png\" alt=\"error\" title=\"error\">\n<p>解决这个异常的方法有两种：</p>\n<p><strong>1.在@PathVariable注解后面加上参数名，比如：@PathVariable(“groupName”)</strong></p>","more":"<p><strong>2.编译时将debug信息勾选进去：</strong></p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/compiler.png\" alt=\"compiler\" title=\"compiler\">\n<p>编译时把上图绿色框中的单选框勾选，就不会报异常。原因在于Local variable属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量名称和描述符之间的映射关系。</p>\n<p>顺便了解一下上面四个选项的作用：</p>\n<img src=\"/2016/09/24/记录这周工作遇到的坑/gengeration.png\" alt=\"compiler\" title=\"compiler\">\n<p>图片截取自：<a href=\"http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-compiler.htm\">Eclipse用户手册</a></p>\n<p>其实就是java工程编译时的一些选项。当我们在debug时遇到问题，比如断点打不上，source not found等等或许修改这些选项可以得到解决。</p>\n<p>参考一篇文章：<a href=\"http://daimojingdeyu.iteye.com/blog/679030\">java编译时生成调试信息选项详解（javac -g）</a></p>\n<h2 id=\"Windows环境下使用Curl，要使用双引号包裹内容\"><a href=\"#Windows环境下使用Curl，要使用双引号包裹内容\" class=\"headerlink\" title=\"Windows环境下使用Curl，要使用双引号包裹内容\"></a>Windows环境下使用Curl，要使用双引号包裹内容</h2><p>web服务器是通过curl来测试的。之前自己也没用过这个所谓的命令行浏览器工具。在机器上装好curl之后，把测试那边提供的脚本拿过来，由于脚本是linux环境下的，做了一点修改之后(其实就是直接换成.bat啦)就直接跑了。脚本内容类似这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -X POST -H &apos;content-type: application/json&apos; -d @del.txt https://localhost:8899/web/rest/data/load/topictarget  -k -b cookie.txt&gt;delresult.txt</div></pre></td></tr></table></figure>\n<p>但是实际测试的过程中，发现收到的post的数据为null，确定了不是服务器的问题之后，感觉应该是curl使用的问题。查了一些资料，是说post的数据要使用双引号包裹，而不是单引号。由于是从del.txt中提取post的数据，所以不存在这个问题。后来将content-type: application/json 的单引号换成双引号之后，问题解决。</p>\n<p><strong>所以：Windows环境下使用Curl，要使用双引号包裹需要加引号的内容，而不是单引号</strong></p>\n<h2 id=\"Spring项目运行过程中，-Autowired注解的变量为null的问题\"><a href=\"#Spring项目运行过程中，-Autowired注解的变量为null的问题\" class=\"headerlink\" title=\"Spring项目运行过程中，@Autowired注解的变量为null的问题\"></a>Spring项目运行过程中，@Autowired注解的变量为null的问题</h2><p>2016/09/09 更新</p>\n<p>这两天开发了一个公众账号来做一些简单的记账工作。后台服务器是用springboot搭建的，测试过程中遇到了这么个情况:</p>\n<p>在运行时服务器报了空指针NullPointerException异常，debug看了一下，发现是一个使用了@Autowired注解的变量没有被初始化。但是按理来说使用了@Autowired注解某个变量后spring会自动为我们实例化这个变量的啊！谷歌了一下，找到了一个类似的情况：<a href=\"http://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null\">Why is my Spring @Autowired field null?</a>.</p>\n<p>下面模拟一下问题出现的场景(代码来自上面的链接)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeController</span> </span>&#123;    </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mileage/&#123;miles&#125;\"</span>)</div><div class=\"line\">    <span class=\"meta\">@ResponseBody</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageFee</span><span class=\"params\">(@PathVariable <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        MileageFeeCalculator calc = <span class=\"keyword\">new</span> MileageFeeCalculator();</div><div class=\"line\">        <span class=\"keyword\">return</span> calc.mileageCharge(miles);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Service</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeCalculator</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> MileageRateService rateService; <span class=\"comment\">// &lt;--- should be autowired, is null</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageCharge</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (miles * rateService.ratePerMile()); <span class=\"comment\">// &lt;--- throws NPE</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Service</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeCalculator</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> MileageRateService rateService; <span class=\"comment\">// &lt;--- should be autowired, is null</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageCharge</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (miles * rateService.ratePerMile()); <span class=\"comment\">// &lt;--- throws NPE</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>访问MileageFeeController时报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.NullPointerException: null</div><div class=\"line\">    at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13)</div><div class=\"line\">    at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14)</div></pre></td></tr></table></figure>\n<p>可以看到，变量rateService是个空值。导致空指针异常…</p>\n<p>原因就在于MileageFeeController.mileageFee中使用了new这种方式实例化了MileageFeeCalculator对象，该对象中的rateService为空，我们使用new这种方式实例化对象时，无法通过spring的@Autowired注解自动实例化对象中的属性。解决的方法就是实例化对象时应该通知spring，使其能够自动配置。</p>\n<p>我采用了上述链接中的第三种方法，解决了问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Component</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationContextHolder</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationContextAware</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ApplicationContext context;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</div><div class=\"line\">        context = applicationContext;   </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ApplicationContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> context;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MileageFeeController</span> </span>&#123;    </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mileage/&#123;miles&#125;\"</span>)</div><div class=\"line\">    <span class=\"meta\">@ResponseBody</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">mileageFee</span><span class=\"params\">(@PathVariable <span class=\"keyword\">int</span> miles)</span> </span>&#123;</div><div class=\"line\">        MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class);</div><div class=\"line\">        <span class=\"keyword\">return</span> calc.mileageCharge(miles);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>发生这些问题的原因还是在于对框架的不熟悉，内部原理不甚明了。有机会真得研究研究spring的源码~~</p>\n<h2 id=\"RestController与-Controller\"><a href=\"#RestController与-Controller\" class=\"headerlink\" title=\"@RestController与@Controller\"></a>@RestController与@Controller</h2><p>2016/10/24 更新</p>\n<p>Springboot 使用 Thymeleaf 模板 打算给公众号加一点地图功能，按照<a href=\"https://hellokoding.com/spring-boot-hello-world-example-with-thymeleaf/\">这个教程</a>在springboot项目中配置Thymeleaf，但是每次都没有正确返回html页面，反而是返回了这个html的名称。试了几次才发现自己用错了@RestController这个注解…Controller代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@RestController</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/wechat\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapController</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/map/showRestaurant\"</span>)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showRestaurant</span><span class=\"params\">(@RequestParam(value = <span class=\"string\">\"location_x\"</span>, required = <span class=\"keyword\">true</span>)</span> String location_x,</div><div class=\"line\">            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"location_y\"</span>, required = <span class=\"keyword\">true</span>)</span> String location_y,</div><div class=\"line\">            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"label\"</span>, required = <span class=\"keyword\">true</span>)</span> String label, Model model) </span>&#123;</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"locationx\"</span>, location_x);</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"locationy\"</span>, location_y);</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"label\"</span>,label);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"hello\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>问题原因就在于上面的@RestController这个注解，将其替换为@Controller便解决了。</p>\n<p>根本原因在于@RestController与@Controller<a href=\"http://stackoverflow.com/questions/25242321/difference-between-spring-controller-and-restcontroller-annotation\">这两个注解之间的区别</a></p>\n<h2 id=\"Linux下可靠的启动webservice\"><a href=\"#Linux下可靠的启动webservice\" class=\"headerlink\" title=\"Linux下可靠的启动webservice\"></a>Linux下可靠的启动webservice</h2><p>2016/12/14 更新</p>\n<p>今天线上webservice发现了一个问题，技服把出现的问题描述和日志发给了我，需要解决一下。最终确定不是代码的问题，而是linux下启动程序的方式引发的一个错误。虽然简单，却很容易被疏忽导致问题的发生，值得记录下来。<br>情况是这样的，每次springboot程序会不定时自动停止，观察log发现，每次挂掉之前都会打印一行log,大致意思是，代码中调用的系统程序tail退出了。查看代码时发现确实在tail程序退出时会打印这么一行日志，但却是正常表现，程序运行在一个死循环当中，随后就会重启tail这个程序。循环当中也做了相应的异常捕获，按道理来说webservice不应该挂掉。初步怀疑多次启动tail导致内存泄漏以至于程序退出。由于代码中没有对内存泄漏这种error类型的异常捕获和记录到日志，从日志中无法判断是否发生了内存泄漏。代码中实现了Throwable级别异常的捕获，并记录异常信息到日志，再次抛出该异常。<br>打包，发送给技服到测试机上去跑。一会之后，又挂了。观察新的Log，竟然与之前的没什么区别，并没有什么新的异常信息输出。也就是说，压根没有异常从代码中抛出。很有可能是程序被认为关闭或被系统干掉了。但是之前询问技服，对方否定了这种情况。<br>这就怪了。继续观察日志，此时，发现这么一行：<code>Unregistering JMX-exposed beans on shutdown</code>.确实是springboot退出时打印的信息。google之，大部分的答案是没有添加依赖<code>spring-boot-starter-web</code>所导致springboot无法启动。与现在的情况不符，当前情况是启动正常，运行时突然挂掉。<br>再次询问技服是否kill掉了运行webservice的进程。技服否认，说该程序时运行在后台的，继续询问如何运行在后台，回答是： <code>java -jar MyApplication.jar &amp;</code><br>果然，使用这种方式运行在后台的程序，当ssh断掉或关闭bash窗口后，程序依然会被系统干掉，父进程都被干掉了，子进程也一并干掉了…<br>正确的启动方式应为：<code>nohup java -jar MyApplication.jar &amp;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。</div><div class=\"line\"></div><div class=\"line\">该命令的一般形式为：nohup command &amp;</div><div class=\"line\"></div><div class=\"line\">使用nohup命令提交作业</div><div class=\"line\"></div><div class=\"line\">如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</div><div class=\"line\"></div><div class=\"line\">nohup command &gt; myout.file 2&gt;&amp;1 &amp;</div><div class=\"line\"></div><div class=\"line\">在上面的例子中，输出被重定向到myout.file文件中。</div></pre></td></tr></table></figure>\n<p>该问题虽然不是很难解决，但是很容易被忽略。故在此记录。</p>\n<h2 id=\"持续更新中…\"><a href=\"#持续更新中…\" class=\"headerlink\" title=\"持续更新中….\"></a>持续更新中….</h2>"},{"layout":"post","title":"理解java内存模型","date":"2016-09-10T02:32:40.000Z","_content":"\n最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~\n\n## 并发为啥会出现问题\n\nPS：2016/9/13更新：今天在地铁上看到这篇文章：[Java 并发原理无废话指南](http://toutiao.io/posts/493923/app_preview),感觉跟我这一小节要说明的问题比较相似，参考一下。\n\n### 原子性\n\n其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：\n\n```java\npublic class BankAccount {\n\tprivate static int accountBalance = 10000;\n\n\tstatic class Save implements Runnable {\n\t\tprivate int money;\n\n\t\tpublic Save(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\t//存钱\n\t\t\tint tempAccount = accountBalance + money;\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次存入：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tstatic class Obtain implements Runnable {\n\n\t\tprivate int money;\n\n\t\tpublic Obtain(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (money > accountBalance) {\n\t\t\t\tSystem.out.println(\"余额不足\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//取钱\n\t\t\tint tempAccount = accountBalance - money;\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);//艾玛，卡了一秒\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次取出：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tint saveMoney = 10000;\n\t\tint obtainMoney = 10000;\n\t\t//自己取钱\n\t\tThread obtain = new Thread(new Obtain(obtainMoney));\n\t\t//老婆存钱\n\t\tThread save = new Thread(new Save(saveMoney));\n\t\tobtain.start();\n\t\tsave.start();\n\t}\n\n}\n```\n\n<!-- more -->\n\n输出结果：\n\n```\n此次存入：10000\n当前余额：20000\n此次取出：10000\n当前余额：0\n```\n\n可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。\n\n分析一下出现问题的原因：\n\n出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。\n\n这就涉及到线程并发的第一个问题：原子性。\n\n我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。\n\n```\n//取钱\nint tempAccount = accountBalance - money;\n\n//设置余额\naccountBalance = tempAccount;\n```\n\n为了实现这种错误的效果，我故意把\n\n```\naccountBalance -= accountBalance;\n```\n\n拆成了上面的两行。其实`accountBalance -= accountBalance;`本身就不是一个原子操作，拆成两行是为了放大这种效果。\n\n通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。\n\n原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。\n\njava中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。\n\n那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。\n\n### 可见性\n\n组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。\n\nJava虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）\n\n画个图：\n\n{% asset_img 内存模型.png 内存模型 %}\n\n这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。\n\n我们回到上述的例子：\n\n上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似`accountBalance -= accountBalance;`这样的操作是原子性操作，设想以下的场景：\n\n1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时`accountBalance~ = 20000;accountBalance = 10000;`\n\n2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时`accountBalance~ = 0;accountBalance = 10000;`\n\n3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；\n\n4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；\n\n通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。\n\n我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。\n\n### 有序性\n\nCpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。\n\n以下例子来自《深入理解Java虚拟机》：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\nconfigOptions = new HashMap();\nconfigText = readConfigFile(flieName);\nprocessConfigOptions(configText,configOptions);\ninitialized = true;\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\nwhile(!initialized){\n\tsleep();\n}\n//使用线程A中初始化好的配置信息\ndoSomethingWithConfig();\n```\n\n在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码`initialized=true`被提前执行，这样线程B中使用配置信息的代码就可能出现错误。\n\n所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\npublic synchronized void init(){\n\tconfigOptions = new HashMap();\n\tconfigText = readConfigFile(flieName);\n\tprocessConfigOptions(configText,configOptions);\n\tinitialized = true;\n}\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\npublic synchronized void doSomething(){\n\twhile(!initialized){\n\t\tsleep();\n\t}\n\t//使用线程A中初始化好的配置信息\n\tdoSomethingWithConfig();\n}\n```\n注意上面两个方法在同一个类中实现。\n\n至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇[synchronized的用法](http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/)，对synchronized的使用更加得心应手啦！\n\n## 先行发生原则\n\n没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。\n\n比如我想到了之前宇哥跟我提到的一个bug:\n\n在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。\n\n后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用`calendar.setTime(date);`,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个`calendar.setTime(date);`，结果肯定就变得混乱了。\n\n上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。\n\n解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。\n\n先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。\n\n还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：\n\n```\n//以下操作在线程A中执行\ni = 1;\n\n//以下操作在线程B中执行\nj = i;\n\n//以下操作在线程C中执行\ni = 2;\n```\n\n假设线程A中的操作`i=1`先行发生于线程B的操作`j=i`,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，`i=1`的结果可以被B观察到。\n\n现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。\n\n其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。\n\n你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性...\n\n如果还没有理解所谓的先行发生原则的话，可以看一下[这篇文章](http://ifeve.com/easy-happens-before/)。\n\n下面介绍几个java内存模型中存在的先行发生关系：\n\n**程序次序规则**：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。\n\n**管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。\n\n**volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。\n\n**传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。\n\n以上只是一部分先行发生关系，其他的不再一一介绍。\n\n那么，先行发生原则如何使用呢？我们看一个例子：\n\n```java\nprivate int value = 0;\n\npublic void setValue(int value){\n\tthis.value = value;\n}\n\npublic int getValue(){\n\treturn value;\n}\n```\n\n假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？\n\n套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看[这个](http://wiki.jikexueyuan.com/project/java-memory-model/lock.html)\n\n通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。\n\n## Volatile关键字\n\n通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。\n\nvolatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：**保证内存可见性和禁止重排序**。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：\n\n```java\npublic class VolatileTest {\n\tpublic static volatile int race = 0;\n\t\n\tpublic static void increase(){\n\t\trace++;\n\t}\n\t\n\tprivate static int THREAD_COUNT = 20;\n\t\n\tpublic static void main(String args[]) {\n\t\tThread[] threads = new Thread[THREAD_COUNT];\n\t\tfor (int i = 0; i < THREAD_COUNT; i++) {\n\t\t\tthreads[i] = new Thread(new Runnable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i< 10000; i++) {\n\t\t\t\t\t\tincrease();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthreads[i].start();\n\t\t}\n\t\twhile (Thread.activeCount()>1) {\n\t\t\tThread.yield();\n\t\t}\n\t\tSystem.out.println(race);\n\t}\n}\n\n```\n\n```\n运行结果：130310 //每次运行结果并不相同\n```\n\n可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于`race++`,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。\n\n这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。\n\n现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：**每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量**。\n\n当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。\n\n当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。\n\n关于volatile怎么实现内存可见性，是通过一个叫[内存屏障](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C)的东西来实现的。具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。\n\n关于volatile关键字的禁止重排序，具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n我们从先行发生原则的角度看一下volatile的禁止重排序：\n\n{% asset_img volatile.png volatile先行发生原则 %}\n\n其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。\n\n根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。\n\n即：**普通读写不能与其后的所有写volatile变量重排序**。同理，**普通读写不能与之前的所有读volatile变量重排序**。\n\n下面看看volatile的使用场景：\n\n1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n\n2.变量不需要与其他状态的变量共同参与不变约束。\n\n第一点就很好理解了，volatile不保证原子性嘛~~\n\n**第二点我也有点疑惑，待研究...**\n\n关于volatile的使用场景，可以看看这篇文章：[Java 理论与实践: 正确使用 Volatile 变量](http://www.ibm.com/developerworks/cn/java/j-jtp06197.html)\n\n## 最后\n\n终于把自己想要总结的写完了~~断断续续写了四个小时...好累...\n\n加油！\n\n\n\n\n\n","source":"_posts/理解java内存模型.md","raw":"---\nlayout: post\ntitle: 理解java内存模型\ndate: 2016-09-10 10:32:40\ncategories: 技术\ntags: java\n---\n\n最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~\n\n## 并发为啥会出现问题\n\nPS：2016/9/13更新：今天在地铁上看到这篇文章：[Java 并发原理无废话指南](http://toutiao.io/posts/493923/app_preview),感觉跟我这一小节要说明的问题比较相似，参考一下。\n\n### 原子性\n\n其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：\n\n```java\npublic class BankAccount {\n\tprivate static int accountBalance = 10000;\n\n\tstatic class Save implements Runnable {\n\t\tprivate int money;\n\n\t\tpublic Save(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\t//存钱\n\t\t\tint tempAccount = accountBalance + money;\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次存入：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tstatic class Obtain implements Runnable {\n\n\t\tprivate int money;\n\n\t\tpublic Obtain(int money) {\n\t\t\tthis.money = money;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (money > accountBalance) {\n\t\t\t\tSystem.out.println(\"余额不足\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//取钱\n\t\t\tint tempAccount = accountBalance - money;\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);//艾玛，卡了一秒\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t//设置余额\n\t\t\taccountBalance = tempAccount;\n\t\t\tSystem.out.println(\"此次取出：\" + money);\n\t\t\tSystem.out.println(\"当前余额：\" + accountBalance);\n\t\t}\n\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tint saveMoney = 10000;\n\t\tint obtainMoney = 10000;\n\t\t//自己取钱\n\t\tThread obtain = new Thread(new Obtain(obtainMoney));\n\t\t//老婆存钱\n\t\tThread save = new Thread(new Save(saveMoney));\n\t\tobtain.start();\n\t\tsave.start();\n\t}\n\n}\n```\n\n<!-- more -->\n\n输出结果：\n\n```\n此次存入：10000\n当前余额：20000\n此次取出：10000\n当前余额：0\n```\n\n可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。\n\n分析一下出现问题的原因：\n\n出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。\n\n这就涉及到线程并发的第一个问题：原子性。\n\n我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。\n\n```\n//取钱\nint tempAccount = accountBalance - money;\n\n//设置余额\naccountBalance = tempAccount;\n```\n\n为了实现这种错误的效果，我故意把\n\n```\naccountBalance -= accountBalance;\n```\n\n拆成了上面的两行。其实`accountBalance -= accountBalance;`本身就不是一个原子操作，拆成两行是为了放大这种效果。\n\n通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。\n\n原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。\n\njava中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。\n\n那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。\n\n### 可见性\n\n组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。\n\nJava虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）\n\n画个图：\n\n{% asset_img 内存模型.png 内存模型 %}\n\n这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。\n\n我们回到上述的例子：\n\n上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似`accountBalance -= accountBalance;`这样的操作是原子性操作，设想以下的场景：\n\n1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时`accountBalance~ = 20000;accountBalance = 10000;`\n\n2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时`accountBalance~ = 0;accountBalance = 10000;`\n\n3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；\n\n4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；\n\n通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。\n\n我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。\n\n### 有序性\n\nCpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。\n\n以下例子来自《深入理解Java虚拟机》：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\nconfigOptions = new HashMap();\nconfigText = readConfigFile(flieName);\nprocessConfigOptions(configText,configOptions);\ninitialized = true;\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\nwhile(!initialized){\n\tsleep();\n}\n//使用线程A中初始化好的配置信息\ndoSomethingWithConfig();\n```\n\n在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码`initialized=true`被提前执行，这样线程B中使用配置信息的代码就可能出现错误。\n\n所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：\n\n```java\nMap configOptions;\nchar[] configText;\n\nboolean initialized = false;\n\n//假设以下代码在线程A中执行\n//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用\npublic synchronized void init(){\n\tconfigOptions = new HashMap();\n\tconfigText = readConfigFile(flieName);\n\tprocessConfigOptions(configText,configOptions);\n\tinitialized = true;\n}\n\n//假设以下代码在线程B中执行\n//等待initialized为true,代表线程A已经把配置信息初始化完成\npublic synchronized void doSomething(){\n\twhile(!initialized){\n\t\tsleep();\n\t}\n\t//使用线程A中初始化好的配置信息\n\tdoSomethingWithConfig();\n}\n```\n注意上面两个方法在同一个类中实现。\n\n至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇[synchronized的用法](http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/)，对synchronized的使用更加得心应手啦！\n\n## 先行发生原则\n\n没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。\n\n比如我想到了之前宇哥跟我提到的一个bug:\n\n在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。\n\n后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用`calendar.setTime(date);`,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个`calendar.setTime(date);`，结果肯定就变得混乱了。\n\n上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。\n\n解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。\n\n先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。\n\n还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：\n\n```\n//以下操作在线程A中执行\ni = 1;\n\n//以下操作在线程B中执行\nj = i;\n\n//以下操作在线程C中执行\ni = 2;\n```\n\n假设线程A中的操作`i=1`先行发生于线程B的操作`j=i`,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，`i=1`的结果可以被B观察到。\n\n现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。\n\n其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。\n\n你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性...\n\n如果还没有理解所谓的先行发生原则的话，可以看一下[这篇文章](http://ifeve.com/easy-happens-before/)。\n\n下面介绍几个java内存模型中存在的先行发生关系：\n\n**程序次序规则**：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。\n\n**管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。\n\n**volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。\n\n**传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。\n\n以上只是一部分先行发生关系，其他的不再一一介绍。\n\n那么，先行发生原则如何使用呢？我们看一个例子：\n\n```java\nprivate int value = 0;\n\npublic void setValue(int value){\n\tthis.value = value;\n}\n\npublic int getValue(){\n\treturn value;\n}\n```\n\n假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？\n\n套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看[这个](http://wiki.jikexueyuan.com/project/java-memory-model/lock.html)\n\n通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。\n\n## Volatile关键字\n\n通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。\n\nvolatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：**保证内存可见性和禁止重排序**。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：\n\n```java\npublic class VolatileTest {\n\tpublic static volatile int race = 0;\n\t\n\tpublic static void increase(){\n\t\trace++;\n\t}\n\t\n\tprivate static int THREAD_COUNT = 20;\n\t\n\tpublic static void main(String args[]) {\n\t\tThread[] threads = new Thread[THREAD_COUNT];\n\t\tfor (int i = 0; i < THREAD_COUNT; i++) {\n\t\t\tthreads[i] = new Thread(new Runnable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i< 10000; i++) {\n\t\t\t\t\t\tincrease();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthreads[i].start();\n\t\t}\n\t\twhile (Thread.activeCount()>1) {\n\t\t\tThread.yield();\n\t\t}\n\t\tSystem.out.println(race);\n\t}\n}\n\n```\n\n```\n运行结果：130310 //每次运行结果并不相同\n```\n\n可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于`race++`,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。\n\n这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。\n\n现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：**每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量**。\n\n当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。\n\n当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。\n\n关于volatile怎么实现内存可见性，是通过一个叫[内存屏障](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C)的东西来实现的。具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。\n\n关于volatile关键字的禁止重排序，具体的可以看下[这个](http://tech.meituan.com/java-memory-reordering.html)\n\n我们从先行发生原则的角度看一下volatile的禁止重排序：\n\n{% asset_img volatile.png volatile先行发生原则 %}\n\n其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。\n\n根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。\n\n即：**普通读写不能与其后的所有写volatile变量重排序**。同理，**普通读写不能与之前的所有读volatile变量重排序**。\n\n下面看看volatile的使用场景：\n\n1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n\n2.变量不需要与其他状态的变量共同参与不变约束。\n\n第一点就很好理解了，volatile不保证原子性嘛~~\n\n**第二点我也有点疑惑，待研究...**\n\n关于volatile的使用场景，可以看看这篇文章：[Java 理论与实践: 正确使用 Volatile 变量](http://www.ibm.com/developerworks/cn/java/j-jtp06197.html)\n\n## 最后\n\n终于把自己想要总结的写完了~~断断续续写了四个小时...好累...\n\n加油！\n\n\n\n\n\n","slug":"理解java内存模型","published":1,"updated":"2017-04-11T13:08:38.857Z","comments":1,"photos":[],"link":"","_id":"cj4vch4hn0060x3gc8iekus2n","content":"<p>最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~</p>\n<h2 id=\"并发为啥会出现问题\"><a href=\"#并发为啥会出现问题\" class=\"headerlink\" title=\"并发为啥会出现问题\"></a>并发为啥会出现问题</h2><p>PS：2016/9/13更新：今天在地铁上看到这篇文章：<a href=\"http://toutiao.io/posts/493923/app_preview\" target=\"_blank\" rel=\"external\">Java 并发原理无废话指南</a>,感觉跟我这一小节要说明的问题比较相似，参考一下。</p>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankAccount</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> accountBalance = <span class=\"number\">10000</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Save</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Save</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//存钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance + money;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次存入：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Obtain</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Obtain</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (money &gt; accountBalance) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"余额不足\"</span>);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//取钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance - money;</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//艾玛，卡了一秒</span></div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次取出：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> saveMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> obtainMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"comment\">//自己取钱</span></div><div class=\"line\">\t\tThread obtain = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Obtain(obtainMoney));</div><div class=\"line\">\t\t<span class=\"comment\">//老婆存钱</span></div><div class=\"line\">\t\tThread save = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Save(saveMoney));</div><div class=\"line\">\t\tobtain.start();</div><div class=\"line\">\t\tsave.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">此次存入：10000</div><div class=\"line\">当前余额：20000</div><div class=\"line\">此次取出：10000</div><div class=\"line\">当前余额：0</div></pre></td></tr></table></figure>\n<p>可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。</p>\n<p>分析一下出现问题的原因：</p>\n<p>出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。</p>\n<p>这就涉及到线程并发的第一个问题：原子性。</p>\n<p>我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//取钱</div><div class=\"line\">int tempAccount = accountBalance - money;</div><div class=\"line\"></div><div class=\"line\">//设置余额</div><div class=\"line\">accountBalance = tempAccount;</div></pre></td></tr></table></figure>\n<p>为了实现这种错误的效果，我故意把</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">accountBalance -= accountBalance;</div></pre></td></tr></table></figure>\n<p>拆成了上面的两行。其实<code>accountBalance -= accountBalance;</code>本身就不是一个原子操作，拆成两行是为了放大这种效果。</p>\n<p>通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。</p>\n<p>原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。</p>\n<p>java中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。</p>\n<p>那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。</p>\n<h3 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h3><p>组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。</p>\n<p>Java虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）</p>\n<p>画个图：</p>\n<img src=\"/2016/09/10/理解java内存模型/内存模型.png\" alt=\"内存模型\" title=\"内存模型\">\n<p>这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。</p>\n<p>我们回到上述的例子：</p>\n<p>上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似<code>accountBalance -= accountBalance;</code>这样的操作是原子性操作，设想以下的场景：</p>\n<p>1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时<code>accountBalance~ = 20000;accountBalance = 10000;</code></p>\n<p>2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时<code>accountBalance~ = 0;accountBalance = 10000;</code></p>\n<p>3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；</p>\n<p>4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；</p>\n<p>通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。</p>\n<p>我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。</p>\n<h3 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h3><p>Cpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。</p>\n<p>以下例子来自《深入理解Java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\">configOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">configText = readConfigFile(flieName);</div><div class=\"line\">processConfigOptions(configText,configOptions);</div><div class=\"line\">initialized = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\tsleep();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">doSomethingWithConfig();</div></pre></td></tr></table></figure>\n<p>在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码<code>initialized=true</code>被提前执行，这样线程B中使用配置信息的代码就可能出现错误。</p>\n<p>所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tconfigOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">\tconfigText = readConfigFile(flieName);</div><div class=\"line\">\tprocessConfigOptions(configText,configOptions);</div><div class=\"line\">\tinitialized = <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\t\tsleep();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">\tdoSomethingWithConfig();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意上面两个方法在同一个类中实现。</p>\n<p>至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇<a href=\"http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/\">synchronized的用法</a>，对synchronized的使用更加得心应手啦！</p>\n<h2 id=\"先行发生原则\"><a href=\"#先行发生原则\" class=\"headerlink\" title=\"先行发生原则\"></a>先行发生原则</h2><p>没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。</p>\n<p>比如我想到了之前宇哥跟我提到的一个bug:</p>\n<p>在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。</p>\n<p>后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用<code>calendar.setTime(date);</code>,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个<code>calendar.setTime(date);</code>，结果肯定就变得混乱了。</p>\n<p>上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。</p>\n<p>解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。</p>\n<p>先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。</p>\n<p>还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下操作在线程A中执行</div><div class=\"line\">i = 1;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程B中执行</div><div class=\"line\">j = i;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程C中执行</div><div class=\"line\">i = 2;</div></pre></td></tr></table></figure>\n<p>假设线程A中的操作<code>i=1</code>先行发生于线程B的操作<code>j=i</code>,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，<code>i=1</code>的结果可以被B观察到。</p>\n<p>现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。</p>\n<p>其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。</p>\n<p>你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性…</p>\n<p>如果还没有理解所谓的先行发生原则的话，可以看一下<a href=\"http://ifeve.com/easy-happens-before/\" target=\"_blank\" rel=\"external\">这篇文章</a>。</p>\n<p>下面介绍几个java内存模型中存在的先行发生关系：</p>\n<p><strong>程序次序规则</strong>：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。</p>\n<p><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。</p>\n<p><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。</p>\n<p><strong>传递性</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。</p>\n<p>以上只是一部分先行发生关系，其他的不再一一介绍。</p>\n<p>那么，先行发生原则如何使用呢？我们看一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？</p>\n<p>套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看<a href=\"http://wiki.jikexueyuan.com/project/java-memory-model/lock.html\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。</p>\n<h2 id=\"Volatile关键字\"><a href=\"#Volatile关键字\" class=\"headerlink\" title=\"Volatile关键字\"></a>Volatile关键字</h2><p>通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。</p>\n<p>volatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：<strong>保证内存可见性和禁止重排序</strong>。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> race = <span class=\"number\">0</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\trace++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> THREAD_COUNT = <span class=\"number\">20</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\tThread[] threads = <span class=\"keyword\">new</span> Thread[THREAD_COUNT];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; THREAD_COUNT; i++) &#123;</div><div class=\"line\">\t\t\tthreads[i] = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t\t\t</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"number\">10000</span>; i++) &#123;</div><div class=\"line\">\t\t\t\t\t\tincrease();</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t\tthreads[i].start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (Thread.activeCount()&gt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">\t\t\tThread.yield();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.println(race);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">运行结果：130310 //每次运行结果并不相同</div></pre></td></tr></table></figure>\n<p>可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于<code>race++</code>,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。</p>\n<p>这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。</p>\n<p>现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：<strong>每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量</strong>。</p>\n<p>当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。</p>\n<p>当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。</p>\n<p>关于volatile怎么实现内存可见性，是通过一个叫<a href=\"https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C\" target=\"_blank\" rel=\"external\">内存屏障</a>的东西来实现的。具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。</p>\n<p>关于volatile关键字的禁止重排序，具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>我们从先行发生原则的角度看一下volatile的禁止重排序：</p>\n<img src=\"/2016/09/10/理解java内存模型/volatile.png\" alt=\"volatile先行发生原则\" title=\"volatile先行发生原则\">\n<p>其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。</p>\n<p>根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。</p>\n<p>即：<strong>普通读写不能与其后的所有写volatile变量重排序</strong>。同理，<strong>普通读写不能与之前的所有读volatile变量重排序</strong>。</p>\n<p>下面看看volatile的使用场景：</p>\n<p>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>\n<p>2.变量不需要与其他状态的变量共同参与不变约束。</p>\n<p>第一点就很好理解了，volatile不保证原子性嘛~~</p>\n<p><strong>第二点我也有点疑惑，待研究…</strong></p>\n<p>关于volatile的使用场景，可以看看这篇文章：<a href=\"http://www.ibm.com/developerworks/cn/java/j-jtp06197.html\" target=\"_blank\" rel=\"external\">Java 理论与实践: 正确使用 Volatile 变量</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>终于把自己想要总结的写完了~~断断续续写了四个小时…好累…</p>\n<p>加油！</p>\n","excerpt":"<p>最近一直在看周志明所著的《深入理解Java虚拟机》，看到java内存模型这一章。自己从网上也查了一些资料，算是对java内存模型有了一个大概的认识，对理解和编写java并发有很大的帮助。有一段时间没再写博客了，正好利用周末的时间把自己学到的java内存模型的知识总结一下。Have a nice day~</p>\n<h2 id=\"并发为啥会出现问题\"><a href=\"#并发为啥会出现问题\" class=\"headerlink\" title=\"并发为啥会出现问题\"></a>并发为啥会出现问题</h2><p>PS：2016/9/13更新：今天在地铁上看到这篇文章：<a href=\"http://toutiao.io/posts/493923/app_preview\">Java 并发原理无废话指南</a>,感觉跟我这一小节要说明的问题比较相似，参考一下。</p>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>其实去了解java内存模型主要是为java并发打下基础。我刚学编程接触多线程的时候，关于多线程并发为什么会有并发问题有过一些思考，老师或者网上的例子都会给出一个类似这样的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankAccount</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> accountBalance = <span class=\"number\">10000</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Save</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Save</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//存钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance + money;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次存入：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Obtain</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Obtain</span><span class=\"params\">(<span class=\"keyword\">int</span> money)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.money = money;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (money &gt; accountBalance) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"余额不足\"</span>);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//取钱</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tempAccount = accountBalance - money;</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//艾玛，卡了一秒</span></div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//设置余额</span></div><div class=\"line\">\t\t\taccountBalance = tempAccount;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"此次取出：\"</span> + money);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"当前余额：\"</span> + accountBalance);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> saveMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> obtainMoney = <span class=\"number\">10000</span>;</div><div class=\"line\">\t\t<span class=\"comment\">//自己取钱</span></div><div class=\"line\">\t\tThread obtain = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Obtain(obtainMoney));</div><div class=\"line\">\t\t<span class=\"comment\">//老婆存钱</span></div><div class=\"line\">\t\tThread save = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Save(saveMoney));</div><div class=\"line\">\t\tobtain.start();</div><div class=\"line\">\t\tsave.start();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">此次存入：10000</div><div class=\"line\">当前余额：20000</div><div class=\"line\">此次取出：10000</div><div class=\"line\">当前余额：0</div></pre></td></tr></table></figure>\n<p>可以看到，老婆往账户上存钱，自己从账户上取钱，两个线程同时发生，（为了保证获得演示效果，我们让取钱过程卡了一秒），结果苦逼了，账户上余额为零了，跟老婆解释不清了。</p>\n<p>分析一下出现问题的原因：</p>\n<p>出现这个问题的原因就在于两个人操作同一个账户，在一个人修改账户余额的时候另一个人也在修改账户余额，造成结果混乱。账户余额就是共享变量，操作账户的人就是并发线程，我们把这两个线程叫做自己线程和老婆线程。</p>\n<p>这就涉及到线程并发的第一个问题：原子性。</p>\n<p>我们可以看出来，出现上面的问题的主要原因其实有两部分：取钱和设置余额。取钱和设置余额这两个动作并不是原子操作，他们是分开执行的。如果在取完钱之后自己线程被挂起（这个挂起跟线程调度有关，我们在程序中模拟了这个挂起操作），老婆线程开始存钱。老婆线程存完钱后，自己线程又把刚刚的tempAccount设回余额，使旧的tempAccount覆盖了新的accountBalance，造成结果错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//取钱</div><div class=\"line\">int tempAccount = accountBalance - money;</div><div class=\"line\"></div><div class=\"line\">//设置余额</div><div class=\"line\">accountBalance = tempAccount;</div></pre></td></tr></table></figure>\n<p>为了实现这种错误的效果，我故意把</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">accountBalance -= accountBalance;</div></pre></td></tr></table></figure>\n<p>拆成了上面的两行。其实<code>accountBalance -= accountBalance;</code>本身就不是一个原子操作，拆成两行是为了放大这种效果。</p>\n<p>通过上面的分析，我们得出，某些读写共享变量的操作如果不是原子操作，多线程并发的情况下会出现并发问题。如何判断是否需要进行原子操作，跟业务逻辑有关，需要我们自己去判断。注意，常见的x=y,x++等都不是原子操作。</p>\n<p>原子性是出现并发问题的重要因素，大多数情况下多线程并发出现问题都跟没有实现原子操作有关。原子性实现了多个线程并发访问某段代码的时候，使这些线程能够有序访问。因为实现原子操作代码的一旦被执行，就不能被打断，其他线程想要访问的时候，只能阻塞等待。</p>\n<p>java中实现原子性使用了synchronized关键字，在synchronized块之间的代码具备原子性。把上面代码中的两个run方法声明为synchronized的，这样的话，这段代码中涉及到的对共享变量的操作就不会随意被打断，要么存完钱再去取，要么取完钱再去存，不会有上述代码提到的问题。</p>\n<p>那么，该段代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？下面看内存可见性。</p>\n<h3 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h3><p>组成原理中学过，为了更充分的利用CPU的性能，往往要在内存与处理器之间加一层：Cache（缓存），来作为内存与处理器之间的缓冲：将处理器需要的数据复制到缓存当中，当运算结束后再从缓存同步回内存当中。因为缓存的速度远远快于内存，这样处理器无需等待缓慢的内存读写，解决了处理器与内存的速度矛盾。</p>\n<p>Java虚拟机也有类似的机制，每个线程有其自己的工作内存(类似前面的Cache)，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量。（这里的变量指被各个线程共享的变量，比如堆中的对象和方法区中的变量。）</p>\n<p>画个图：</p>\n<img src=\"/2016/09/10/理解java内存模型/内存模型.png\" alt=\"内存模型\" title=\"内存模型\">\n<p>这样的机制会带来另一个问题：缓存一致性。多个线程共同处理同一个变量时，各自的缓存中的数据并不一致，同步回主内存的数据以谁的缓存数据为准呢？这就带来了并发问题。</p>\n<p>我们回到上述的例子：</p>\n<p>上面例子中的代码出现并发问题仅仅是因为没有对共享变量实现原子操作吗？现在我们知道自己线程和老婆线程有各自的工作内存，他们各自对accountBalance 的读写都是基于工作内存的。然后在恰当的时机同步回主内存。现在我们假设类似<code>accountBalance -= accountBalance;</code>这样的操作是原子性操作，设想以下的场景：</p>\n<p>1.老婆线程向账户中存10000，此时操作老婆线程工作内存中的accountBalance~(我们使用~来表明这个变量是工作内存当中的)，此时<code>accountBalance~ = 20000;accountBalance = 10000;</code></p>\n<p>2.自己线程现在向账户中取10000，此时操作自己线程工作内存中的accountBalance~(注意此accountBalance~跟老婆线程中的accountBalance~不是同一个)，此时<code>accountBalance~ = 0;accountBalance = 10000;</code></p>\n<p>3.现在老婆线程把自己的accountBalance~刷回主内存，此时accountBalance = 20000；</p>\n<p>4.现在自己线程把自己的accountBalance~刷回主内存，此时accountBalance = 0；</p>\n<p>通过以上的分析，看到了即使我们使对共享变量的写操作实现了原子性，但由于内存可见性的问题，依然存在并发问题。这就是造成多线程并发的第二个原因：内存可见性。</p>\n<p>我们在原子性分析最后还说了，通过使用synchronized关键字可以保证不存在并发问题，是因为synchronized不仅实现了代码原子性操作，还保证了内存可见性。每次执行加锁和释放锁的同时，都会把线程的工作内存和主内存进行同步。一方面，它使自己线程和老婆线程只能串行操作账户余额，另一方面，他保证了当老婆线程存完钱之后会把自己工作内存中的accountBalance~刷回主内存。设想synchronized没有实现内存可见性的话，上面的问题依旧存在，注意这和互斥没有什么关系，此时两个线程依旧是串行访问。解释这么啰嗦主要是让大家明白原子操作和内存可见是造成并发问题的两个不同因素，但是通过锁可以同时解决这两个因素带来的问题。</p>\n<h3 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h3><p>Cpu在执行指令的时候，为了优化提高Cpu运行程序的速度，会将多条指令不按程序规定的顺序分发给各个不同的电路单元处理，叫做指令重排序。注意乱序执行的指令之间没有数据依赖关系，因为乱序执行的结果必须保证结果的正确性。理解起来比较麻烦，通过一个例子来看一下。</p>\n<p>以下例子来自《深入理解Java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\">configOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">configText = readConfigFile(flieName);</div><div class=\"line\">processConfigOptions(configText,configOptions);</div><div class=\"line\">initialized = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\tsleep();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">doSomethingWithConfig();</div></pre></td></tr></table></figure>\n<p>在上面的例子中，由于指令重排序的优化，导致线程A中最后一句代码<code>initialized=true</code>被提前执行，这样线程B中使用配置信息的代码就可能出现错误。</p>\n<p>所以，指令重排序也是造成并发问题的一个因素。在java中，synchronized关键字也可以解决指令重排序带来的并发问题，他可以保证线程之间操作的有序性。如果使用synchronized关键字将上面例子中访问initialized的相关代码包裹起来，就保证了这种多线程之间操作的有序性。因为使用synchronized关键字后，持有同一个锁的两个同步块只能串行的进入，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">Map configOptions;</div><div class=\"line\"><span class=\"keyword\">char</span>[] configText;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">boolean</span> initialized = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程A中执行</span></div><div class=\"line\"><span class=\"comment\">//模拟读取配置信息，当读取完成后将initialized设置为true通知其他线程配置可用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tconfigOptions = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">\tconfigText = readConfigFile(flieName);</div><div class=\"line\">\tprocessConfigOptions(configText,configOptions);</div><div class=\"line\">\tinitialized = <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设以下代码在线程B中执行</span></div><div class=\"line\"><span class=\"comment\">//等待initialized为true,代表线程A已经把配置信息初始化完成</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(!initialized)&#123;</div><div class=\"line\">\t\tsleep();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//使用线程A中初始化好的配置信息</span></div><div class=\"line\">\tdoSomethingWithConfig();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意上面两个方法在同一个类中实现。</p>\n<p>至此，我们分析出了造成多线程并发问题的三个原因：原子性、可见性、原子性。并且知道了通过synchronized可以解决这三个因素带来的并发问题。java中大部分的并发控制都能通过synchronized来实现。再结合之前写的一篇<a href=\"http://yukai.space/2016/08/16/synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/\">synchronized的用法</a>，对synchronized的使用更加得心应手啦！</p>\n<h2 id=\"先行发生原则\"><a href=\"#先行发生原则\" class=\"headerlink\" title=\"先行发生原则\"></a>先行发生原则</h2><p>没有理解先行发生原则之前，看到网上很多博客提到这个，感觉很高深有木有~~~，理解了他之后，发现其实也挺简单。理解先行发生原则有助于我们判断线程是否安全，并发环境下两个操作之间是否存在数据冲突的问题。通过阅读《深入理解java虚拟机》和参阅网上的一些博客，我认为通过先行发生原则可以使我们知道自己写的多线程程序是否会因为可见性、原子性两个因素导致并发问题产生。至于原子性带来的问题，应该是程序员自己去分析具体的业务逻辑场景，并不能通过套用先行发生原则来判断自己的程序是否有并发问题。</p>\n<p>比如我想到了之前宇哥跟我提到的一个bug:</p>\n<p>在JDBC中获取日期之后通过一个静态的SimpleDateFormat对象把日期类型转换为字符串返回给用户。高并发情况下出现了这样一个问题：返回的日期是错误的，跟用户期待的日期不一致。</p>\n<p>后来通过反复排查，最后发现是这个静态SimpleDateFormat对象造成的并发问题，他内部有一个Calendar对象，每次执行format方法的时候会调用<code>calendar.setTime(date);</code>,很明显当某个线程中在日期转换过程中被挂起的时候，恰好另一个线程也在执行转换日期的代码，他们调用同一个SimpleDateFormat对象中的同一个<code>calendar.setTime(date);</code>，结果肯定就变得混乱了。</p>\n<p>上面的问题就是静态SimpleDateFormat对象被共享带来的结果，实际上也是原子性的问题，跟有序性和可见性并没有太大的关系。这就是所谓的业务逻辑相关，需要我们自己去分析。</p>\n<p>解释了半天先行发生原则的作用和使用条件，下面该说说先行发生原则本身。</p>\n<p>先行发生原则是指：如果说操作A先行发生于操作B，也就是发生在操作B之前，操作A产生的影响能被操作B观察到。</p>\n<p>还是用《深入理解java虚拟机》中的例子来解释(真的是一本好书啊，一定要多看几遍)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下操作在线程A中执行</div><div class=\"line\">i = 1;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程B中执行</div><div class=\"line\">j = i;</div><div class=\"line\"></div><div class=\"line\">//以下操作在线程C中执行</div><div class=\"line\">i = 2;</div></pre></td></tr></table></figure>\n<p>假设线程A中的操作<code>i=1</code>先行发生于线程B的操作<code>j=i</code>,那么可以确定在线程B的操作执行之后，j一定等于1。因为：根据先行发生原则，<code>i=1</code>的结果可以被B观察到。</p>\n<p>现在保持A先行发生于B，线程C出现在A与B之间，但是线程C与B没有先行发生关系。那么j会等于多少呢？答案至不确定。因为线程C对变量i的影响可能会被B观察到，也可能不会。因为两者之间没有先行发生关系。</p>\n<p>其实说白了，先行发生原则就是操作A在时间上或者逻辑上比B先发生，那么B一定能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。</p>\n<p>你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的内存可见性和有序性…</p>\n<p>如果还没有理解所谓的先行发生原则的话，可以看一下<a href=\"http://ifeve.com/easy-happens-before/\">这篇文章</a>。</p>\n<p>下面介绍几个java内存模型中存在的先行发生关系：</p>\n<p><strong>程序次序规则</strong>：一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。</p>\n<p><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。</p>\n<p><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。</p>\n<p><strong>传递性</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。</p>\n<p>以上只是一部分先行发生关系，其他的不再一一介绍。</p>\n<p>那么，先行发生原则如何使用呢？我们看一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设存在线程A和B，A先调用了setValue(1),然后线程B调用了同一个对象的getValue(),那么线程B收到的返回值是多少？</p>\n<p>套用上面存在的先行发生关系，我们发现，虽然线程A在操作时间上先行发生于线程B，但是无法确定B中的getValue()方法的返回结果。也就是说，这里的操作是不安全的。此时我们可以通过synchronized关键字来解决。可以看看<a href=\"http://wiki.jikexueyuan.com/project/java-memory-model/lock.html\">这个</a></p>\n<p>通过上面的分析，我们了解了先行发生原则的作用：判断内存可见性与重排序是否造成并发问题。</p>\n<h2 id=\"Volatile关键字\"><a href=\"#Volatile关键字\" class=\"headerlink\" title=\"Volatile关键字\"></a>Volatile关键字</h2><p>通过上面的学习，再来看volatile就变得简单很多了。之前我对这个关键字也是看的云里雾里，现在仍然有个小疑问，后面会提到。</p>\n<p>volatile关键字想必都不陌生，有时候在同步中会看到他。那么volatile究竟有什么作用呢?其实他实现了两个功能：<strong>保证内存可见性和禁止重排序</strong>。基于上面的内容应该对这个关键字心里有了个大概。那么，如何使用它呢？看一个例子就会用了。同样来自《深入理解java虚拟机》：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> race = <span class=\"number\">0</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\trace++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> THREAD_COUNT = <span class=\"number\">20</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">\t\tThread[] threads = <span class=\"keyword\">new</span> Thread[THREAD_COUNT];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; THREAD_COUNT; i++) &#123;</div><div class=\"line\">\t\t\tthreads[i] = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t\t\t</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"number\">10000</span>; i++) &#123;</div><div class=\"line\">\t\t\t\t\t\tincrease();</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t\tthreads[i].start();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (Thread.activeCount()&gt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">\t\t\tThread.yield();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.println(race);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">运行结果：130310 //每次运行结果并不相同</div></pre></td></tr></table></figure>\n<p>可以看到，虽然使用了volatile关键字，但是并没有达到我们预期的效果：race=200000。Execute me?你特么在逗我？原因就在于<code>race++</code>,我们上面也提到过，这种自增运算并不是原子性的，恰好，volatile也没有保证原子性。所以出现了不理想的结果。</p>\n<p>这个时候应该会有人说：volatile不是实现了内存可见性吗？自增运算虽然不是原子性的，但20个线程在访问race的时候不应该看到的是最新的值嘛？赋值的时候不是对主内存中的race操作吗？跟原子性有毛关系？以前的我就是这么想的。</p>\n<p>现在我们来了解一下volatile的内存可见性是怎么实现的。前面也说了：<strong>每个线程有其自己的工作内存，线程对变量的读写必须在工作内存中进行，而不能直接读写主存中的变量</strong>。</p>\n<p>当遇到读volatile变量的时候，会立即把主存中的变量值同步到工作内存当中。</p>\n<p>当遇到写volatile变量的时候，会立即把工作内存中的变量值同步到主存中。</p>\n<p>关于volatile怎么实现内存可见性，是通过一个叫<a href=\"https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C\">内存屏障</a>的东西来实现的。具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\">这个</a></p>\n<p>所以说：所谓的实现内存可见性并不是直接操作主内存，还是通过工作内存来实现的。当某线程把race的值取到操作栈顶的时候，volatile关键字保证了race值在此时是正确的，与主内存同步的。但是在执行race++的后续指令的时候(race++不是原子性操作，通过多个指令完成)，其他线程可能已经更新了race的值了，操作栈顶的race值变成了过期的数据，race++执行完毕后可能把较小的race值同步回主内存。</p>\n<p>关于volatile关键字的禁止重排序，具体的可以看下<a href=\"http://tech.meituan.com/java-memory-reordering.html\">这个</a></p>\n<p>我们从先行发生原则的角度看一下volatile的禁止重排序：</p>\n<img src=\"/2016/09/10/理解java内存模型/volatile.png\" alt=\"volatile先行发生原则\" title=\"volatile先行发生原则\">\n<p>其中：i是普通变量，x是被volatile修饰的变量。A、B操作在一个线程当中，C、D操作在另一个线程当中。B先于C执行。</p>\n<p>根据前面的volatile先行发生关系，我们可以得出，B先行发生于C，又因为A先行发生于B(程序次序规则)，所以A先行发生于C。那么A产生的影响一定会被C观察到，当B被执行的时候，会将当前工作内存中的变量都刷回到主内存当中，并通知其他线程同步主内存到自己的工作内存。这样便保证了A产生的影响一定会被C观察到。同时，A不能被重排序到B之后，因为这样的话，A产生是影响便不能被C观察到了，违背了先行发生原则。</p>\n<p>即：<strong>普通读写不能与其后的所有写volatile变量重排序</strong>。同理，<strong>普通读写不能与之前的所有读volatile变量重排序</strong>。</p>\n<p>下面看看volatile的使用场景：</p>\n<p>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>\n<p>2.变量不需要与其他状态的变量共同参与不变约束。</p>\n<p>第一点就很好理解了，volatile不保证原子性嘛~~</p>\n<p><strong>第二点我也有点疑惑，待研究…</strong></p>\n<p>关于volatile的使用场景，可以看看这篇文章：<a href=\"http://www.ibm.com/developerworks/cn/java/j-jtp06197.html\">Java 理论与实践: 正确使用 Volatile 变量</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>终于把自己想要总结的写完了~~断断续续写了四个小时…好累…</p>\n<p>加油！</p>"},{"layout":"post","date":"2016-08-15T06:54:55.000Z","title":"一些计划","comments":0,"_content":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe>\n转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。\n\n上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的[作者](https://github.com/A-limon/pacman)，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名[www.yukai.space](www.yukai.space)作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。\n\n## 关于学习\n\n程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：\n\n### java\n\n吃饭的家伙，必须得用好了。虽然用java写过不少\"小DEMO\",但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：\n\n- Thinking In Java\n\n- Effect Java\n\n- 大话设计模式\n\n- 深入理解Jvm虚拟机\n\n- 重构：改善既有的代码\n\n前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。\n\n<!-- more -->\n\n### Linux\n\n一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。\n\n从 鸟哥的Linux私房菜 开始吧。\n\n### Groovy\n\n第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。\n\n### 数据库\n\n说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把<<数据库系统概论>>通读一遍吧。贪多嚼不烂。\n\n以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。\n\n## 关于减肥\n\n确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：\n\n腹肌轮：80\n\n卷腹：50\n\n哑铃深蹲：40\n\n俯卧撑：80\n\n其他健身动作：若干\n\n跑步：一周至少三次\n\n## 关于理财\n\n写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。\n\n写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。\n\n以上","source":"_posts/一些计划.md","raw":"---\nlayout: post\ndate: 2016-08-15 14:54:55\ncategories: 生活\ntitle: 一些计划\ncomments: false\n---\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe>\n转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。\n\n上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的[作者](https://github.com/A-limon/pacman)，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名[www.yukai.space](www.yukai.space)作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。\n\n## 关于学习\n\n程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：\n\n### java\n\n吃饭的家伙，必须得用好了。虽然用java写过不少\"小DEMO\",但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：\n\n- Thinking In Java\n\n- Effect Java\n\n- 大话设计模式\n\n- 深入理解Jvm虚拟机\n\n- 重构：改善既有的代码\n\n前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。\n\n<!-- more -->\n\n### Linux\n\n一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。\n\n从 鸟哥的Linux私房菜 开始吧。\n\n### Groovy\n\n第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。\n\n### 数据库\n\n说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把<<数据库系统概论>>通读一遍吧。贪多嚼不烂。\n\n以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。\n\n## 关于减肥\n\n确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：\n\n腹肌轮：80\n\n卷腹：50\n\n哑铃深蹲：40\n\n俯卧撑：80\n\n其他健身动作：若干\n\n跑步：一周至少三次\n\n## 关于理财\n\n写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。\n\n写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。\n\n以上","slug":"一些计划","published":1,"updated":"2017-04-11T13:08:38.850Z","photos":[],"link":"","_id":"cj4vch4jt006xx3gc0l8drpeo","content":"<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe><br>转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。</p>\n<p>上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的<a href=\"https://github.com/A-limon/pacman\" target=\"_blank\" rel=\"external\">作者</a>，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名<a href=\"www.yukai.space\">www.yukai.space</a>作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。</p>\n<h2 id=\"关于学习\"><a href=\"#关于学习\" class=\"headerlink\" title=\"关于学习\"></a>关于学习</h2><p>程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：</p>\n<h3 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h3><p>吃饭的家伙，必须得用好了。虽然用java写过不少”小DEMO”,但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：</p>\n<ul>\n<li><p>Thinking In Java</p>\n</li>\n<li><p>Effect Java</p>\n</li>\n<li><p>大话设计模式</p>\n</li>\n<li><p>深入理解Jvm虚拟机</p>\n</li>\n<li><p>重构：改善既有的代码</p>\n</li>\n</ul>\n<p>前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。</p>\n<a id=\"more\"></a>\n<h3 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h3><p>一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。</p>\n<p>从 鸟哥的Linux私房菜 开始吧。</p>\n<h3 id=\"Groovy\"><a href=\"#Groovy\" class=\"headerlink\" title=\"Groovy\"></a>Groovy</h3><p>第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。</p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把&lt;&lt;数据库系统概论&gt;&gt;通读一遍吧。贪多嚼不烂。</p>\n<p>以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。</p>\n<h2 id=\"关于减肥\"><a href=\"#关于减肥\" class=\"headerlink\" title=\"关于减肥\"></a>关于减肥</h2><p>确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：</p>\n<p>腹肌轮：80</p>\n<p>卷腹：50</p>\n<p>哑铃深蹲：40</p>\n<p>俯卧撑：80</p>\n<p>其他健身动作：若干</p>\n<p>跑步：一周至少三次</p>\n<h2 id=\"关于理财\"><a href=\"#关于理财\" class=\"headerlink\" title=\"关于理财\"></a>关于理财</h2><p>写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。</p>\n<p>写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。</p>\n<p>以上</p>\n","excerpt":"<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=168153&auto=1&height=66\"></iframe><br>转眼之间毕业已有整整两个月。这两个月里，大家各奔东西，找工作的找工作，考研的继续考研。跟我一起工作了一个多月的哥们也要辞职去考研了，直接原因是刚发的工资让我们都很失望，房价的飞速上涨又让我们这些刚刚步入工作岗位的年轻人感到一阵恐慌。最后或许考研是个不错的解决方案，起码三年内不用考虑这些烂事了，而且据说考研后薪资与本科生大大的不同，具体情况因人而异吧。生活就是这样，真的猛士，敢于直面这操蛋的人生。是时候来点正能量了，无论如何生活都是要继续的。砖，还是要搬的。</p>\n<p>上周末把博客从Jekyll迁移到了Hexo，使用了PacMan的模板。在此要感谢模板的<a href=\"https://github.com/A-limon/pacman\">作者</a>，使我这样一个对前端一窍不通的菜鸟也能整出另自己满意的博客效果。花了61大洋买了五年的域名<a href=\"www.yukai.space\">www.yukai.space</a>作为博客的新域名。域名是从阿里云上买的，我认为是相当便宜了。希望有一个新的开始。在此作出一些生活和学习上的计划，让自己能有所改变吧。</p>\n<h2 id=\"关于学习\"><a href=\"#关于学习\" class=\"headerlink\" title=\"关于学习\"></a>关于学习</h2><p>程序员的价值在于不断学习，工作中我也发现自己真的是太菜了，专业水平有待提高，从以下几个方面开始吧：</p>\n<h3 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h3><p>吃饭的家伙，必须得用好了。虽然用java写过不少”小DEMO”,但是java中的很多东西自己并没有涉及，或者只是知道怎么用。说白了就是基础上还要下功夫。这点上决定从读JDK源代码开始，现在在读java中的集合类。前段时间在重构JDBC的过程中，发现自己对面向对象好像理解的较之前更为深刻了。面向对象和设计模式也是我接下来要重点关注的地方。毕竟是要励志成为架构师的男人，哈哈哈。下面列出读书清单：</p>\n<ul>\n<li><p>Thinking In Java</p>\n</li>\n<li><p>Effect Java</p>\n</li>\n<li><p>大话设计模式</p>\n</li>\n<li><p>深入理解Jvm虚拟机</p>\n</li>\n<li><p>重构：改善既有的代码</p>\n</li>\n</ul>\n<p>前两本书可以作为工具书来使用。后三本计划在今年之前读一遍。</p>","more":"<h3 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h3><p>一直都有学习Linux的想法，但是自己的工作跟Linux基本不沾边，所以给了我偷懒的理由。接下来的学习计划中，要开始接触Linux，不求有多懂，起码要到会用的程度吧，比如熟悉命令行，shell等这些最基本的东西，顺利的话，希望将来的开发环境可以逐渐转移到Linux上去，我也不知道为什么要这么做，就是觉得应该这么做。</p>\n<p>从 鸟哥的Linux私房菜 开始吧。</p>\n<h3 id=\"Groovy\"><a href=\"#Groovy\" class=\"headerlink\" title=\"Groovy\"></a>Groovy</h3><p>第一次知道这个语言还是在学校弄安卓的时候，Gradle所使用的构建语言。Groovy可以说是java平台的脚本语言。如今函数式编程大火，自己也应该多接触一些类似的东西，方便以后向java8过渡。</p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>说来惭愧，自己虽然是在开发数据库产品的公司工作，但数据库知识却匮乏的一塌糊涂，甚至于书写基本的sql语句都有问题。先把&lt;&lt;数据库系统概论&gt;&gt;通读一遍吧。贪多嚼不烂。</p>\n<p>以上说的都是一些大概的学习计划，至于具体的细节，我现在也没有清晰的想法。本来还想定一些关于英语及前端知识等的学习计划，但是发现在当前的工作中并不是能够体现其作用。所以先把上面所说的几点做好吧。至于所谓的做好我也无法论断是多好，只是自己心里有个谱。上面所列几点的学习时间暂定为到今年年底。</p>\n<h2 id=\"关于减肥\"><a href=\"#关于减肥\" class=\"headerlink\" title=\"关于减肥\"></a>关于减肥</h2><p>确切的说，应该叫健身，因为本身也不算很胖，140上下吧。去年的现在大概是120左右，刚上大学那会才112。工作之后猛涨十多斤，这让人感到恐慌。女票也一直催我减肥，六块腹肌也逐渐要融为一体了。前段时间每天跑步，坚持了不到一个月吧，因为种种原因停止了（说实话，上一天班去跑步真的有点累）。还是应该健身的，毕竟还有八块腹肌的梦。那样应该感觉很帅吧。下面是我定的每天要锻炼的项目：</p>\n<p>腹肌轮：80</p>\n<p>卷腹：50</p>\n<p>哑铃深蹲：40</p>\n<p>俯卧撑：80</p>\n<p>其他健身动作：若干</p>\n<p>跑步：一周至少三次</p>\n<h2 id=\"关于理财\"><a href=\"#关于理财\" class=\"headerlink\" title=\"关于理财\"></a>关于理财</h2><p>写下这个题目我都有点不好意思。现在浑身上下就剩一千多块，工资也不多。下个月初又要交房租了。刚工作就遭遇经济危机。前几天看了一篇理财的文章，觉得自己也应该把钱管理起来了，起码做到收支平衡吧。具体的计划就不在这里写了，今晚好好计划计划，先从记账开始。</p>\n<p>写了上面这些，感觉对于接下来的规划还不是很清晰。但起码心中有数，希望在接下来的日子里可以充实一些。</p>\n<p>以上</p>"}],"PostAsset":[{"_id":"source/_posts/I-O总结/javaio.png","slug":"javaio.png","post":"cj4vch4f3002ix3gc4oguy8zc","modified":1,"renderable":0},{"_id":"source/_posts/毕业了/graduation8.jpg","slug":"graduation8.jpg","post":"cj4vch4hd005fx3gcmjzj8udg","modified":1,"renderable":0},{"_id":"source/_posts/毕业了/graduation2.jpg","slug":"graduation2.jpg","post":"cj4vch4hd005fx3gcmjzj8udg","modified":1,"renderable":0},{"_id":"source/_posts/I-O总结/io.png","slug":"io.png","post":"cj4vch4f3002ix3gc4oguy8zc","modified":1,"renderable":0},{"_id":"source/_posts/毕业了/graduation1.jpg","slug":"graduation1.jpg","post":"cj4vch4hd005fx3gcmjzj8udg","modified":1,"renderable":0},{"_id":"source/_posts/毕业了/graduation7.jpg","slug":"graduation7.jpg","post":"cj4vch4hd005fx3gcmjzj8udg","modified":1,"renderable":0},{"_id":"source/_posts/Java集合框架学习总结/collection.png","post":"cj4vch4cq0006x3gcgs4w8b6d","slug":"collection.png","modified":1,"renderable":1},{"_id":"source/_posts/hexo博客备份方案/blog.png","post":"cj4vch4db000kx3gc1jf3zrzp","slug":"blog.png","modified":1,"renderable":1},{"_id":"source/_posts/java中的equals与hashcode/entry.png","post":"cj4vch4dt0012x3gciy0ynjrz","slug":"entry.png","modified":1,"renderable":1},{"_id":"source/_posts/java任务取消/java.png","post":"cj4vch4ek001qx3gc42f6y1s2","slug":"java.png","modified":1,"renderable":1},{"_id":"source/_posts/java异常的学习/java.png","post":"cj4vch4ew0024x3gconby8327","slug":"java.png","modified":1,"renderable":1},{"_id":"source/_posts/java文件描述符/filedescriptors.png","post":"cj4vch4ez002bx3gcjoo9h8ni","slug":"filedescriptors.png","modified":1,"renderable":1},{"_id":"source/_posts/maven学习笔记/mvn.png","post":"cj4vch4fv003kx3gcma546ka1","slug":"mvn.png","modified":1,"renderable":1},{"_id":"source/_posts/java泛型学习/easybill.jpg","post":"cj4vch4go0045x3gc000mjbtc","slug":"easybill.jpg","modified":1,"renderable":1},{"_id":"source/_posts/他可是科比·布莱恩特!/kobe.jpg","post":"cj4vch4gr0048x3gcr9p8qlvs","slug":"kobe.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于加密的一点总结/md5.png","post":"cj4vch4h5004xx3gcged1xik4","slug":"md5.png","modified":1,"renderable":1},{"_id":"source/_posts/土豆烧肉/tudou.jpg","post":"cj4vch4h70051x3gcmko29u43","slug":"tudou.jpg","modified":1,"renderable":1},{"_id":"source/_posts/木耳炒山药/cai.jpg","post":"cj4vch4he005ix3gc51g2zifu","slug":"cai.jpg","modified":1,"renderable":1},{"_id":"source/_posts/建造者模式的使用/builder.jpg","post":"cj4vch4hf005lx3gcejozbob7","slug":"builder.jpg","modified":1,"renderable":1},{"_id":"source/_posts/理解notify notifyall sleep/线程状态.png","post":"cj4vch4hh005ox3gcee7j5h3s","slug":"线程状态.png","modified":1,"renderable":1},{"_id":"source/_posts/centos7BCM驱动安装/demo.png","post":"cj4vch4d5000gx3gcu8dhfbkn","slug":"demo.png","modified":1,"renderable":1},{"_id":"source/_posts/centos7BCM驱动安装/iwconfig.png","post":"cj4vch4d5000gx3gcu8dhfbkn","slug":"iwconfig.png","modified":1,"renderable":1},{"_id":"source/_posts/java类加载/classloader.png","post":"cj4vch4f7002mx3gcinkla7np","slug":"classloader.png","modified":1,"renderable":1},{"_id":"source/_posts/java类加载/jiazai.png","post":"cj4vch4f7002mx3gcinkla7np","slug":"jiazai.png","modified":1,"renderable":1},{"_id":"source/_posts/java注解/decode.jpg","post":"cj4vch4f9002px3gc883v03la","slug":"decode.jpg","modified":1,"renderable":1},{"_id":"source/_posts/java注解/doc.jpg","post":"cj4vch4f9002px3gc883v03la","slug":"doc.jpg","modified":1,"renderable":1},{"_id":"source/_posts/糖醋里脊/tangculiji.jpg","post":"cj4vch4hi005rx3gctdc20u8e","slug":"tangculiji.jpg","modified":1,"renderable":1},{"_id":"source/_posts/糖醋里脊/wufan.jpg","post":"cj4vch4hi005rx3gctdc20u8e","slug":"wufan.jpg","modified":1,"renderable":1},{"_id":"source/_posts/理解java内存模型/volatile.png","post":"cj4vch4hn0060x3gc8iekus2n","slug":"volatile.png","modified":1,"renderable":1},{"_id":"source/_posts/理解java内存模型/内存模型.png","post":"cj4vch4hn0060x3gc8iekus2n","slug":"内存模型.png","modified":1,"renderable":1},{"_id":"source/_posts/java中的编码问题/reader.png","post":"cj4vch4eg001kx3gc3een0w3k","slug":"reader.png","modified":1,"renderable":1},{"_id":"source/_posts/java中的编码问题/utf8.png","post":"cj4vch4eg001kx3gc3een0w3k","slug":"utf8.png","modified":1,"renderable":1},{"_id":"source/_posts/java中的编码问题/writer.png","post":"cj4vch4eg001kx3gc3een0w3k","slug":"writer.png","modified":1,"renderable":1},{"_id":"source/_posts/java线程池的使用/pool.jpg","slug":"pool.jpg","post":"cj4vch4fd002wx3gchw2fa5yb","modified":1,"renderable":0},{"_id":"source/_posts/java线程池的使用/pool_execute.jpg","post":"cj4vch4fd002wx3gchw2fa5yb","slug":"pool_execute.jpg","modified":1,"renderable":1},{"_id":"source/_posts/java线程池的使用/pool_uml.png","post":"cj4vch4fd002wx3gchw2fa5yb","slug":"pool_uml.png","modified":1,"renderable":1},{"_id":"source/_posts/java远程调试学习/jdpa.png","post":"cj4vch4fh0033x3gcaxcr2fsn","slug":"jdpa.png","modified":1,"renderable":1},{"_id":"source/_posts/java远程调试学习/remote.png","post":"cj4vch4fh0033x3gcaxcr2fsn","slug":"remote.png","modified":1,"renderable":1},{"_id":"source/_posts/java远程调试学习/setting.png","post":"cj4vch4fh0033x3gcaxcr2fsn","slug":"setting.png","modified":1,"renderable":1},{"_id":"source/_posts/并发场景下缓存的创建/1.png","post":"cj4vch4hc005bx3gcde6sd842","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/并发场景下缓存的创建/2.png","post":"cj4vch4hc005bx3gcde6sd842","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/并发场景下缓存的创建/3.png","post":"cj4vch4hc005bx3gcde6sd842","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/记录这周工作遇到的坑/compiler.png","post":"cj4vch4hl005xx3gcvmq8xhew","slug":"compiler.png","modified":1,"renderable":1},{"_id":"source/_posts/记录这周工作遇到的坑/error.png","post":"cj4vch4hl005xx3gcvmq8xhew","slug":"error.png","modified":1,"renderable":1},{"_id":"source/_posts/记录这周工作遇到的坑/gengeration.png","post":"cj4vch4hl005xx3gcvmq8xhew","slug":"gengeration.png","modified":1,"renderable":1},{"_id":"source/_posts/ssl总结/sslprocess.jpg","post":"cj4vch4g4003ux3gc4uxol5mv","slug":"sslprocess.jpg","modified":1,"renderable":1},{"_id":"source/_posts/ssl总结/zhifubao.png","post":"cj4vch4g4003ux3gc4uxol5mv","slug":"zhifubao.png","modified":1,"renderable":1},{"_id":"source/_posts/ssl总结/zhufubao1.png","post":"cj4vch4g4003ux3gc4uxol5mv","slug":"zhufubao1.png","modified":1,"renderable":1},{"_id":"source/_posts/ssl总结/zhufubao2.png","post":"cj4vch4g4003ux3gc4uxol5mv","slug":"zhufubao2.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-NIO-MappedByteBuffer/io.png","post":"cj4vch4ce0002x3gc2nw17j6i","slug":"io.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-NIO-MappedByteBuffer/内存文件映射.png","post":"cj4vch4ce0002x3gc2nw17j6i","slug":"内存文件映射.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-NIO-MappedByteBuffer/虚拟内存.png","post":"cj4vch4ce0002x3gc2nw17j6i","slug":"虚拟内存.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-NIO-MappedByteBuffer/页表.jpg","post":"cj4vch4ce0002x3gc2nw17j6i","slug":"页表.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Java-NIO-MappedByteBuffer/页表1.png","post":"cj4vch4ce0002x3gc2nw17j6i","slug":"页表1.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-NIO-Channel/api.png","post":"cj4vch4d0000bx3gcisiamfn0","slug":"api.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-NIO-Channel/bytechannel.png","post":"cj4vch4d0000bx3gcisiamfn0","slug":"bytechannel.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-NIO-Channel/channel-uml.png","post":"cj4vch4d0000bx3gcisiamfn0","slug":"channel-uml.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-NIO-Channel/channel.png","post":"cj4vch4d0000bx3gcisiamfn0","slug":"channel.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-NIO-Channel/filechannel.png","post":"cj4vch4d0000bx3gcisiamfn0","slug":"filechannel.png","modified":1,"renderable":1},{"_id":"source/_posts/Spring项目打包为jar/1.png","post":"cj4vch4cu0008x3gcfpi0wi5v","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/Spring项目打包为jar/2.png","post":"cj4vch4cu0008x3gcfpi0wi5v","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Spring项目打包为jar/3.png","post":"cj4vch4cu0008x3gcfpi0wi5v","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/Spring项目打包为jar/4.png","post":"cj4vch4cu0008x3gcfpi0wi5v","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/Spring项目打包为jar/5.png","post":"cj4vch4cu0008x3gcfpi0wi5v","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/java-NIO-Buffer/1.png","post":"cj4vch4dr000zx3gctknkgebc","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/java-NIO-Buffer/2.png","post":"cj4vch4dr000zx3gctknkgebc","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/java-NIO-Buffer/3.png","post":"cj4vch4dr000zx3gctknkgebc","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/java-NIO-Buffer/buffer.png","post":"cj4vch4dr000zx3gctknkgebc","slug":"buffer.png","modified":1,"renderable":1},{"_id":"source/_posts/java-NIO-Buffer/buffer_api.png","post":"cj4vch4dr000zx3gctknkgebc","slug":"buffer_api.png","modified":1,"renderable":1},{"_id":"source/_posts/linux分区/cipan.png","post":"cj4vch4ff002zx3gc34a2ztrd","slug":"cipan.png","modified":1,"renderable":1},{"_id":"source/_posts/linux分区/fen.png","post":"cj4vch4ff002zx3gc34a2ztrd","slug":"fen.png","modified":1,"renderable":1},{"_id":"source/_posts/linux分区/kuozhan.png","post":"cj4vch4ff002zx3gc34a2ztrd","slug":"kuozhan.png","modified":1,"renderable":1},{"_id":"source/_posts/linux分区/yindao.jpg","post":"cj4vch4ff002zx3gc34a2ztrd","slug":"yindao.jpg","modified":1,"renderable":1},{"_id":"source/_posts/linux分区/zhumian.jpg","post":"cj4vch4ff002zx3gc34a2ztrd","slug":"zhumian.jpg","modified":1,"renderable":1},{"_id":"source/_posts/java代理机制/1.png","post":"cj4vch4ei001nx3gc6pg6nwgy","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/java代理机制/2.png","post":"cj4vch4ei001nx3gc6pg6nwgy","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/java代理机制/3.png","post":"cj4vch4ei001nx3gc6pg6nwgy","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/java代理机制/4.png","post":"cj4vch4ei001nx3gc6pg6nwgy","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/java代理机制/5.png","post":"cj4vch4ei001nx3gc6pg6nwgy","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/java代理机制/Proxy.jpg","post":"cj4vch4ei001nx3gc6pg6nwgy","slug":"Proxy.jpg","modified":1,"renderable":1},{"_id":"source/_posts/java代理机制/seq_Proxy.jpg","post":"cj4vch4ei001nx3gc6pg6nwgy","slug":"seq_Proxy.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Eclipse编码问题终极解决方案/1.png","post":"cj4vch4ey0028x3gc087lbhl2","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/Eclipse编码问题终极解决方案/2.png","post":"cj4vch4ey0028x3gc087lbhl2","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Eclipse编码问题终极解决方案/3.png","post":"cj4vch4ey0028x3gc087lbhl2","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/Eclipse编码问题终极解决方案/4.png","post":"cj4vch4ey0028x3gc087lbhl2","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/Eclipse编码问题终极解决方案/5.png","post":"cj4vch4ey0028x3gc087lbhl2","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/Eclipse编码问题终极解决方案/6.png","post":"cj4vch4ey0028x3gc087lbhl2","slug":"6.png","modified":1,"renderable":1},{"_id":"source/_posts/Eclipse编码问题终极解决方案/7.png","post":"cj4vch4ey0028x3gc087lbhl2","slug":"7.png","modified":1,"renderable":1},{"_id":"source/_posts/如何从外网访问家里的电脑/1.png","post":"cj4vch4h90054x3gc61vobcd1","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/如何从外网访问家里的电脑/2.png","post":"cj4vch4h90054x3gc61vobcd1","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/如何从外网访问家里的电脑/3.png","post":"cj4vch4h90054x3gc61vobcd1","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/如何从外网访问家里的电脑/4.png","post":"cj4vch4h90054x3gc61vobcd1","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/如何从外网访问家里的电脑/5.png","post":"cj4vch4h90054x3gc61vobcd1","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/如何从外网访问家里的电脑/6.png","post":"cj4vch4h90054x3gc61vobcd1","slug":"6.png","modified":1,"renderable":1},{"_id":"source/_posts/如何从外网访问家里的电脑/7.png","post":"cj4vch4h90054x3gc61vobcd1","slug":"7.png","modified":1,"renderable":1},{"_id":"source/_posts/I-O总结/child-817369__340.jpg","post":"cj4vch4f3002ix3gc4oguy8zc","slug":"child-817369__340.jpg","modified":1,"renderable":1},{"_id":"source/_posts/I-O总结/decoder.jpg","post":"cj4vch4f3002ix3gc4oguy8zc","slug":"decoder.jpg","modified":1,"renderable":1},{"_id":"source/_posts/I-O总结/decorator.jpg","post":"cj4vch4f3002ix3gc4oguy8zc","slug":"decorator.jpg","modified":1,"renderable":1},{"_id":"source/_posts/I-O总结/encoder.jpg","post":"cj4vch4f3002ix3gc4oguy8zc","slug":"encoder.jpg","modified":1,"renderable":1},{"_id":"source/_posts/I-O总结/javaio2.bmp","slug":"javaio2.bmp","post":"cj4vch4f3002ix3gc4oguy8zc","modified":1,"renderable":0},{"_id":"source/_posts/I-O总结/stream.png","post":"cj4vch4f3002ix3gc4oguy8zc","slug":"stream.png","modified":1,"renderable":1},{"_id":"source/_posts/毕业了/graduation3.jpg","post":"cj4vch4hd005fx3gcmjzj8udg","slug":"graduation3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/毕业了/graduation4.jpg","slug":"graduation4.jpg","post":"cj4vch4hd005fx3gcmjzj8udg","modified":1,"renderable":0},{"_id":"source/_posts/毕业了/graduation5.jpg","post":"cj4vch4hd005fx3gcmjzj8udg","slug":"graduation5.jpg","modified":1,"renderable":1},{"_id":"source/_posts/毕业了/graduation6.jpg","post":"cj4vch4hd005fx3gcmjzj8udg","slug":"graduation6.jpg","modified":1,"renderable":1},{"_id":"source/_posts/线程池异常处理方案/callable.png","post":"cj4vch4hk005ux3gc8t489q0w","slug":"callable.png","modified":1,"renderable":1},{"_id":"source/_posts/线程池异常处理方案/future.png","post":"cj4vch4hk005ux3gc8t489q0w","slug":"future.png","modified":1,"renderable":1},{"_id":"source/_posts/线程池异常处理方案/futuretask.png","post":"cj4vch4hk005ux3gc8t489q0w","slug":"futuretask.png","modified":1,"renderable":1},{"_id":"source/_posts/线程池异常处理方案/futuretask_get.png","post":"cj4vch4hk005ux3gc8t489q0w","slug":"futuretask_get.png","modified":1,"renderable":1},{"_id":"source/_posts/线程池异常处理方案/futuretask_report.png","post":"cj4vch4hk005ux3gc8t489q0w","slug":"futuretask_report.png","modified":1,"renderable":1},{"_id":"source/_posts/线程池异常处理方案/futuretask_run.png","post":"cj4vch4hk005ux3gc8t489q0w","slug":"futuretask_run.png","modified":1,"renderable":1},{"_id":"source/_posts/线程池异常处理方案/siwei.png","post":"cj4vch4hk005ux3gc8t489q0w","slug":"siwei.png","modified":1,"renderable":1},{"_id":"source/_posts/线程池异常处理方案/submit.png","post":"cj4vch4hk005ux3gc8t489q0w","slug":"submit.png","modified":1,"renderable":1},{"_id":"source/_posts/线程池异常处理方案/threadpool.png","post":"cj4vch4hk005ux3gc8t489q0w","slug":"threadpool.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cj4vch4c40000x3gchkvgw2bl","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4d5000fx3gchwkph1na"},{"post_id":"cj4vch4d3000ex3gcxazfvf0o","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4de000lx3gcpqhcknhl"},{"post_id":"cj4vch4ce0002x3gc2nw17j6i","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4dk000qx3gc4weslmwv"},{"post_id":"cj4vch4d5000gx3gcu8dhfbkn","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4do000tx3gcgyb5nhd6"},{"post_id":"cj4vch4db000kx3gc1jf3zrzp","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4dq000yx3gc6d1j8n52"},{"post_id":"cj4vch4cq0006x3gcgs4w8b6d","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4ds0011x3gccboxdube"},{"post_id":"cj4vch4dh000nx3gclbltd9bg","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4dw0015x3gc46eswhjz"},{"post_id":"cj4vch4dk000rx3gcn8icwiby","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4e10018x3gct2xx0wwi"},{"post_id":"cj4vch4cu0008x3gcfpi0wi5v","category_id":"cj4vch4dk000px3gcnkpw8h12","_id":"cj4vch4e6001bx3gcd2pyzqbd"},{"post_id":"cj4vch4dp000ux3gch4yg8st0","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4e8001fx3gc5utmz88i"},{"post_id":"cj4vch4dr000zx3gctknkgebc","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4ef001ix3gcttcq04u6"},{"post_id":"cj4vch4d0000bx3gcisiamfn0","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4ei001mx3gc91srpuju"},{"post_id":"cj4vch4dt0012x3gciy0ynjrz","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4ej001px3gc2y42eqf0"},{"post_id":"cj4vch4dx0016x3gc2gritirj","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4el001tx3gcm9wf2wnd"},{"post_id":"cj4vch4e40019x3gcwabbztnf","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4ep001wx3gcp3d2gow9"},{"post_id":"cj4vch4e6001dx3gcddwjrk2s","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4es0020x3gc28pmqea0"},{"post_id":"cj4vch4e8001gx3gcn7xlim1t","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4ev0023x3gc413mr44u"},{"post_id":"cj4vch4eg001kx3gc3een0w3k","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4ex0027x3gcy03kkx08"},{"post_id":"cj4vch4ei001nx3gc6pg6nwgy","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4ez002ax3gct0ufcgz2"},{"post_id":"cj4vch4ek001qx3gc42f6y1s2","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4f0002dx3gccrjlwqy3"},{"post_id":"cj4vch4em001ux3gcv08z0ehf","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4f3002hx3gcn9k86s5f"},{"post_id":"cj4vch4ep001xx3gcqmbixfae","category_id":"cj4vch4dk000px3gcnkpw8h12","_id":"cj4vch4f7002kx3gcy0op9z1g"},{"post_id":"cj4vch4es0021x3gcys3bnp16","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4f9002ox3gc75n61rvp"},{"post_id":"cj4vch4ey0028x3gc087lbhl2","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4fa002rx3gc9pjpuyji"},{"post_id":"cj4vch4ez002bx3gcjoo9h8ni","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4fc002vx3gcutg2nhua"},{"post_id":"cj4vch4f0002fx3gct53d76kk","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4ff002yx3gcmkhlkcza"},{"post_id":"cj4vch4f3002ix3gc4oguy8zc","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4fh0032x3gcj2rd90wf"},{"post_id":"cj4vch4f7002mx3gcinkla7np","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4fj0035x3gc3n5hzvot"},{"post_id":"cj4vch4f9002px3gc883v03la","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4fp0039x3gc2wr0rj5l"},{"post_id":"cj4vch4fb002sx3gcp30cgktp","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4fr003cx3gcawnhg0ud"},{"post_id":"cj4vch4fd002wx3gchw2fa5yb","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4ft003fx3gcrjwxs3r2"},{"post_id":"cj4vch4ff002zx3gc34a2ztrd","category_id":"cj4vch4dk000px3gcnkpw8h12","_id":"cj4vch4fv003jx3gc8itkswmn"},{"post_id":"cj4vch4fh0033x3gcaxcr2fsn","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4fx003mx3gcwkkcc6y3"},{"post_id":"cj4vch4fj0036x3gcgmhx1dj7","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4g2003qx3gc8eh50tgc"},{"post_id":"cj4vch4fq003ax3gch59ndxyn","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4g4003tx3gcvv8dvaqq"},{"post_id":"cj4vch4fr003dx3gceyflusit","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4g6003xx3gcdgmowar0"},{"post_id":"cj4vch4ft003hx3gcray0xdtj","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4gl0040x3gch1cl7769"},{"post_id":"cj4vch4fv003kx3gcma546ka1","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4go0044x3gc4k0id5pm"},{"post_id":"cj4vch4fy003nx3gckasvqopm","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4gq0047x3gcwgkubrii"},{"post_id":"cj4vch4g2003rx3gcruq31d3n","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4gs004ax3gc1knjnznt"},{"post_id":"cj4vch4g4003ux3gc4uxol5mv","category_id":"cj4vch4dk000px3gcnkpw8h12","_id":"cj4vch4gu004fx3gcvujywhj5"},{"post_id":"cj4vch4g7003yx3gc457asqlt","category_id":"cj4vch4dk000px3gcnkpw8h12","_id":"cj4vch4gv004ix3gclof9dkvb"},{"post_id":"cj4vch4gl0041x3gcbq7crzvb","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4gx004mx3gcabn5751d"},{"post_id":"cj4vch4go0045x3gc000mjbtc","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4h0004px3gcwkwp05wg"},{"post_id":"cj4vch4gs004cx3gc7ixx0uzn","category_id":"cj4vch4dk000px3gcnkpw8h12","_id":"cj4vch4h3004tx3gcxs4wtmh0"},{"post_id":"cj4vch4gu004gx3gc9f3bbzvh","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4h5004wx3gc43kbalw4"},{"post_id":"cj4vch4gv004kx3gc8gntqqdl","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4h70050x3gc1g0x0ao9"},{"post_id":"cj4vch4gr0048x3gcr9p8qlvs","category_id":"cj4vch4gu004ex3gcva47uy74","_id":"cj4vch4h80053x3gc03ylrv07"},{"post_id":"cj4vch4gy004nx3gc6x8usqre","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4ha0057x3gcyxgvluo5"},{"post_id":"cj4vch4h0004qx3gc2oqjdnvv","category_id":"cj4vch4gu004ex3gcva47uy74","_id":"cj4vch4hb005ax3gcx4k2i9of"},{"post_id":"cj4vch4h3004ux3gc7vzwfr1h","category_id":"cj4vch4gu004ex3gcva47uy74","_id":"cj4vch4hd005ex3gcktwii5xv"},{"post_id":"cj4vch4h5004xx3gcged1xik4","category_id":"cj4vch4dk000px3gcnkpw8h12","_id":"cj4vch4he005hx3gc3n81pkaw"},{"post_id":"cj4vch4h70051x3gcmko29u43","category_id":"cj4vch4gu004ex3gcva47uy74","_id":"cj4vch4hf005kx3gc0e94c47f"},{"post_id":"cj4vch4h90054x3gc61vobcd1","category_id":"cj4vch4dk000px3gcnkpw8h12","_id":"cj4vch4hh005nx3gc475wr489"},{"post_id":"cj4vch4ha0058x3gc42p23pbo","category_id":"cj4vch4cp0005x3gct7jfyf5u","_id":"cj4vch4hi005qx3gcghzjzpu2"},{"post_id":"cj4vch4hc005bx3gcde6sd842","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4hk005tx3gcmwa2kzew"},{"post_id":"cj4vch4hd005fx3gcmjzj8udg","category_id":"cj4vch4gu004ex3gcva47uy74","_id":"cj4vch4hl005wx3gc1l525iav"},{"post_id":"cj4vch4he005ix3gc51g2zifu","category_id":"cj4vch4gu004ex3gcva47uy74","_id":"cj4vch4hn005zx3gcaasis6rj"},{"post_id":"cj4vch4hf005lx3gcejozbob7","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4ho0063x3gcj0fttsb4"},{"post_id":"cj4vch4hh005ox3gcee7j5h3s","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4hp0065x3gcpj49r2d5"},{"post_id":"cj4vch4hi005rx3gctdc20u8e","category_id":"cj4vch4gu004ex3gcva47uy74","_id":"cj4vch4hp0067x3gcrn06n26i"},{"post_id":"cj4vch4hk005ux3gc8t489q0w","category_id":"cj4vch4d1000cx3gchfuzp20b","_id":"cj4vch4hp0069x3gcoprj2aah"},{"post_id":"cj4vch4hl005xx3gcvmq8xhew","category_id":"cj4vch4dk000px3gcnkpw8h12","_id":"cj4vch4hq006bx3gc4gqix10q"},{"post_id":"cj4vch4hn0060x3gc8iekus2n","category_id":"cj4vch4dk000px3gcnkpw8h12","_id":"cj4vch4hq006dx3gcxkn058os"},{"post_id":"cj4vch4jt006xx3gc0l8drpeo","category_id":"cj4vch4gu004ex3gcva47uy74","_id":"cj4vch4jx006yx3gcw4o61w5f"}],"PostTag":[{"post_id":"cj4vch4c40000x3gchkvgw2bl","tag_id":"cj4vch4cj0004x3gcw4mds7ri","_id":"cj4vch4d2000dx3gcr7l6z88y"},{"post_id":"cj4vch4ce0002x3gc2nw17j6i","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4db000jx3gcj1innrj2"},{"post_id":"cj4vch4d5000gx3gcu8dhfbkn","tag_id":"cj4vch4cj0004x3gcw4mds7ri","_id":"cj4vch4dg000mx3gcnz4soztk"},{"post_id":"cj4vch4dh000nx3gclbltd9bg","tag_id":"cj4vch4cj0004x3gcw4mds7ri","_id":"cj4vch4do000sx3gcf84ivvpu"},{"post_id":"cj4vch4dk000rx3gcn8icwiby","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4dq000wx3gckmmdadne"},{"post_id":"cj4vch4cq0006x3gcgs4w8b6d","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4ds0010x3gcuaobu3zn"},{"post_id":"cj4vch4cq0006x3gcgs4w8b6d","tag_id":"cj4vch4di000ox3gc70c90bw2","_id":"cj4vch4dw0013x3gcwe6bosss"},{"post_id":"cj4vch4dr000zx3gctknkgebc","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4e10017x3gc93e2c8ym"},{"post_id":"cj4vch4dt0012x3gciy0ynjrz","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4e5001ax3gcf8en5fs2"},{"post_id":"cj4vch4dx0016x3gc2gritirj","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4e8001ex3gcl0tjqdov"},{"post_id":"cj4vch4e40019x3gcwabbztnf","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4ef001hx3gcknp4tuow"},{"post_id":"cj4vch4cu0008x3gcfpi0wi5v","tag_id":"cj4vch4dq000vx3gcxrqi3isf","_id":"cj4vch4ei001lx3gcajfk68qt"},{"post_id":"cj4vch4cu0008x3gcfpi0wi5v","tag_id":"cj4vch4dw0014x3gcwh0e9fpe","_id":"cj4vch4ej001ox3gctgveu7lw"},{"post_id":"cj4vch4e6001dx3gcddwjrk2s","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4el001sx3gcvz0t2cg0"},{"post_id":"cj4vch4d0000bx3gcisiamfn0","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4eo001vx3gcql75av6x"},{"post_id":"cj4vch4ei001nx3gc6pg6nwgy","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4es001zx3gcotnmuat7"},{"post_id":"cj4vch4d3000ex3gcxazfvf0o","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4ev0022x3gc230skxjs"},{"post_id":"cj4vch4d3000ex3gcxazfvf0o","tag_id":"cj4vch4eg001jx3gcrfo9rr2l","_id":"cj4vch4ex0025x3gcebr9vdyz"},{"post_id":"cj4vch4em001ux3gcv08z0ehf","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4ez0029x3gc7lxf596c"},{"post_id":"cj4vch4em001ux3gcv08z0ehf","tag_id":"cj4vch4eg001jx3gcrfo9rr2l","_id":"cj4vch4f0002cx3gcj2glmmt4"},{"post_id":"cj4vch4db000kx3gc1jf3zrzp","tag_id":"cj4vch4el001rx3gc1ug0hec3","_id":"cj4vch4f3002gx3gc79h4zovj"},{"post_id":"cj4vch4ep001xx3gcqmbixfae","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4f7002jx3gcvotvagg0"},{"post_id":"cj4vch4es0021x3gcys3bnp16","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4f9002nx3gcb6tn654n"},{"post_id":"cj4vch4dp000ux3gch4yg8st0","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4fa002qx3gcrek9ymfy"},{"post_id":"cj4vch4dp000ux3gch4yg8st0","tag_id":"cj4vch4es001yx3gcub8t6ikl","_id":"cj4vch4fc002ux3gc2fvx0h42"},{"post_id":"cj4vch4ew0024x3gconby8327","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4fe002xx3gcx3un3bsr"},{"post_id":"cj4vch4ez002bx3gcjoo9h8ni","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4fh0031x3gccjphz40v"},{"post_id":"cj4vch4eg001kx3gc3een0w3k","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4fj0034x3gcgjl1j1j4"},{"post_id":"cj4vch4eg001kx3gc3een0w3k","tag_id":"cj4vch4ex0026x3gc8lx2cjlr","_id":"cj4vch4fp0037x3gc5c20mjkf"},{"post_id":"cj4vch4f0002fx3gct53d76kk","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4fr003bx3gc17bet58x"},{"post_id":"cj4vch4ek001qx3gc42f6y1s2","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4fs003ex3gcch8uy3gh"},{"post_id":"cj4vch4ek001qx3gc42f6y1s2","tag_id":"cj4vch4es001yx3gcub8t6ikl","_id":"cj4vch4fv003ix3gca7swlq4z"},{"post_id":"cj4vch4f7002mx3gcinkla7np","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4fx003lx3gcx0wfrhfe"},{"post_id":"cj4vch4f9002px3gc883v03la","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4g2003px3gcwz4znksb"},{"post_id":"cj4vch4ey0028x3gc087lbhl2","tag_id":"cj4vch4f7002lx3gc4dx0di50","_id":"cj4vch4g4003sx3gc1avpnhym"},{"post_id":"cj4vch4fd002wx3gchw2fa5yb","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4g6003wx3gc6t6drcux"},{"post_id":"cj4vch4fd002wx3gchw2fa5yb","tag_id":"cj4vch4es001yx3gcub8t6ikl","_id":"cj4vch4gl003zx3gceayo7mwy"},{"post_id":"cj4vch4f3002ix3gc4oguy8zc","tag_id":"cj4vch4fc002tx3gc6n93zh68","_id":"cj4vch4go0042x3gcm8xaw18f"},{"post_id":"cj4vch4ff002zx3gc34a2ztrd","tag_id":"cj4vch4cj0004x3gcw4mds7ri","_id":"cj4vch4gq0046x3gc1p8nw1tl"},{"post_id":"cj4vch4fq003ax3gch59ndxyn","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4gs0049x3gccspwgsf2"},{"post_id":"cj4vch4fq003ax3gch59ndxyn","tag_id":"cj4vch4es001yx3gcub8t6ikl","_id":"cj4vch4gu004dx3gcgee4su85"},{"post_id":"cj4vch4fb002sx3gcp30cgktp","tag_id":"cj4vch4fg0030x3gczvye56uj","_id":"cj4vch4gv004hx3gcn5w5jwff"},{"post_id":"cj4vch4fb002sx3gcp30cgktp","tag_id":"cj4vch4fp0038x3gc5z4c1ywo","_id":"cj4vch4gx004lx3gcd0urt3ji"},{"post_id":"cj4vch4fh0033x3gcaxcr2fsn","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4h0004ox3gca6nxe9vl"},{"post_id":"cj4vch4fh0033x3gcaxcr2fsn","tag_id":"cj4vch4ft003gx3gc1qu9s4ei","_id":"cj4vch4h3004sx3gc7uo8y6dp"},{"post_id":"cj4vch4fy003nx3gckasvqopm","tag_id":"cj4vch4cj0004x3gcw4mds7ri","_id":"cj4vch4h5004vx3gcs8ya1p7q"},{"post_id":"cj4vch4g2003rx3gcruq31d3n","tag_id":"cj4vch4es001yx3gcub8t6ikl","_id":"cj4vch4h7004zx3gcjlcyf6ml"},{"post_id":"cj4vch4g2003rx3gcruq31d3n","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4h80052x3gcgg4z8u6q"},{"post_id":"cj4vch4fj0036x3gcgmhx1dj7","tag_id":"cj4vch4g1003ox3gc6igslmsd","_id":"cj4vch4ha0055x3gcjgwkzlqu"},{"post_id":"cj4vch4g7003yx3gc457asqlt","tag_id":"cj4vch4cj0004x3gcw4mds7ri","_id":"cj4vch4hb0059x3gcmpkc3awh"},{"post_id":"cj4vch4fr003dx3gceyflusit","tag_id":"cj4vch4g6003vx3gcf1bwr4pk","_id":"cj4vch4hc005cx3gcxwm1qt7c"},{"post_id":"cj4vch4fr003dx3gceyflusit","tag_id":"cj4vch4ex0026x3gc8lx2cjlr","_id":"cj4vch4he005gx3gcsha03jji"},{"post_id":"cj4vch4gl0041x3gcbq7crzvb","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4hf005jx3gct8vat3wx"},{"post_id":"cj4vch4gl0041x3gcbq7crzvb","tag_id":"cj4vch4es001yx3gcub8t6ikl","_id":"cj4vch4hh005mx3gcnke0snms"},{"post_id":"cj4vch4go0045x3gc000mjbtc","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4hi005px3gcohioy8xk"},{"post_id":"cj4vch4ft003hx3gcray0xdtj","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4hk005sx3gcpp9gbb8h"},{"post_id":"cj4vch4ft003hx3gcray0xdtj","tag_id":"cj4vch4go0043x3gcspj8za8i","_id":"cj4vch4hl005vx3gcnh2mwm8j"},{"post_id":"cj4vch4gu004gx3gc9f3bbzvh","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4hn005yx3gc2ws61bpz"},{"post_id":"cj4vch4fv003kx3gcma546ka1","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4ho0062x3gckg18b7ho"},{"post_id":"cj4vch4fv003kx3gcma546ka1","tag_id":"cj4vch4go0043x3gcspj8za8i","_id":"cj4vch4hp0064x3gcou3d6uf5"},{"post_id":"cj4vch4gv004kx3gc8gntqqdl","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4hp0066x3gcoowrxq7f"},{"post_id":"cj4vch4gy004nx3gc6x8usqre","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4hp0068x3gcgsnrc69j"},{"post_id":"cj4vch4g4003ux3gc4uxol5mv","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4hq006ax3gcki84y7b8"},{"post_id":"cj4vch4g4003ux3gc4uxol5mv","tag_id":"cj4vch4gv004jx3gcevmvw7rb","_id":"cj4vch4hq006cx3gcep20f6m3"},{"post_id":"cj4vch4gs004cx3gc7ixx0uzn","tag_id":"cj4vch4h2004rx3gcvz7sxhnm","_id":"cj4vch4hq006ex3gciss37c60"},{"post_id":"cj4vch4h5004xx3gcged1xik4","tag_id":"cj4vch4gv004jx3gcevmvw7rb","_id":"cj4vch4hq006fx3gcyibekaa9"},{"post_id":"cj4vch4h70051x3gcmko29u43","tag_id":"cj4vch4h7004yx3gcsu5idhsc","_id":"cj4vch4hq006gx3gcloos4xxm"},{"post_id":"cj4vch4h0004qx3gc2oqjdnvv","tag_id":"cj4vch4h7004yx3gcsu5idhsc","_id":"cj4vch4hq006hx3gc17j460bs"},{"post_id":"cj4vch4h90054x3gc61vobcd1","tag_id":"cj4vch4cj0004x3gcw4mds7ri","_id":"cj4vch4hq006ix3gcm73nia7a"},{"post_id":"cj4vch4h3004ux3gc7vzwfr1h","tag_id":"cj4vch4h7004yx3gcsu5idhsc","_id":"cj4vch4hq006jx3gcjwj4xrgt"},{"post_id":"cj4vch4hc005bx3gcde6sd842","tag_id":"cj4vch4es001yx3gcub8t6ikl","_id":"cj4vch4hq006kx3gclvtapa54"},{"post_id":"cj4vch4hc005bx3gcde6sd842","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4hq006lx3gctbztc48h"},{"post_id":"cj4vch4he005ix3gc51g2zifu","tag_id":"cj4vch4h7004yx3gcsu5idhsc","_id":"cj4vch4hq006mx3gcc6kasktj"},{"post_id":"cj4vch4ha0058x3gc42p23pbo","tag_id":"cj4vch4hd005dx3gc2i8rq0ag","_id":"cj4vch4hq006nx3gcqufm388i"},{"post_id":"cj4vch4hf005lx3gcejozbob7","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4hr006ox3gcxnmp1m1o"},{"post_id":"cj4vch4hh005ox3gcee7j5h3s","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4hr006px3gcxtmjb8dj"},{"post_id":"cj4vch4hh005ox3gcee7j5h3s","tag_id":"cj4vch4es001yx3gcub8t6ikl","_id":"cj4vch4hr006qx3gcsml2tsxb"},{"post_id":"cj4vch4hi005rx3gctdc20u8e","tag_id":"cj4vch4h7004yx3gcsu5idhsc","_id":"cj4vch4hr006rx3gcae732pg9"},{"post_id":"cj4vch4hk005ux3gc8t489q0w","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4hr006sx3gc5ykg4vxr"},{"post_id":"cj4vch4hk005ux3gc8t489q0w","tag_id":"cj4vch4es001yx3gcub8t6ikl","_id":"cj4vch4hr006tx3gc0dya2qu9"},{"post_id":"cj4vch4hn0060x3gc8iekus2n","tag_id":"cj4vch4d0000ax3gce0itgmfl","_id":"cj4vch4hr006ux3gcxp7ky2t5"},{"post_id":"cj4vch4hl005xx3gcvmq8xhew","tag_id":"cj4vch4dw0014x3gcwh0e9fpe","_id":"cj4vch4hr006vx3gchu3roe40"},{"post_id":"cj4vch4hl005xx3gcvmq8xhew","tag_id":"cj4vch4ho0061x3gcmsdir9a4","_id":"cj4vch4hr006wx3gc7pnv9oi6"}],"Tag":[{"name":"linux","_id":"cj4vch4cj0004x3gcw4mds7ri"},{"name":"java","_id":"cj4vch4d0000ax3gce0itgmfl"},{"name":"源码","_id":"cj4vch4di000ox3gc70c90bw2"},{"name":"服务器","_id":"cj4vch4dq000vx3gcxrqi3isf"},{"name":"spring","_id":"cj4vch4dw0014x3gcwh0e9fpe"},{"name":"ant","_id":"cj4vch4eg001jx3gcrfo9rr2l"},{"name":"hexo","_id":"cj4vch4el001rx3gc1ug0hec3"},{"name":"多线程","_id":"cj4vch4es001yx3gcub8t6ikl"},{"name":"编码","_id":"cj4vch4ex0026x3gc8lx2cjlr"},{"name":"Eclipse","_id":"cj4vch4f7002lx3gc4dx0di50"},{"name":"java io","_id":"cj4vch4fc002tx3gc6n93zh68"},{"name":"junit","_id":"cj4vch4fg0030x3gczvye56uj"},{"name":"测试","_id":"cj4vch4fp0038x3gc5z4c1ywo"},{"name":"调试","_id":"cj4vch4ft003gx3gc1qu9s4ei"},{"name":"markdown","_id":"cj4vch4g1003ox3gc6igslmsd"},{"name":"python","_id":"cj4vch4g6003vx3gcf1bwr4pk"},{"name":"maven","_id":"cj4vch4go0043x3gcspj8za8i"},{"name":"加密","_id":"cj4vch4gv004jx3gcevmvw7rb"},{"name":"web","_id":"cj4vch4h2004rx3gcvz7sxhnm"},{"name":"食物","_id":"cj4vch4h7004yx3gcsu5idhsc"},{"name":"快捷键","_id":"cj4vch4hd005dx3gc2i8rq0ag"},{"name":"curl","_id":"cj4vch4ho0061x3gcmsdir9a4"}]}}