{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/pacman/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/author.jpg","path":"img/author.jpg","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/xiaoxin.ico","path":"img/xiaoxin.ico","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/xiaoxin.png","path":"img/xiaoxin.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/pacman/source/js/jquery-2.1.0.min.js","path":"js/jquery-2.1.0.min.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/img/xiaoxin.jpg","path":"img/xiaoxin.jpg","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0}],"Cache":[{"_id":"themes/pacman/LICENSE","hash":"4847e5a63399a0ef85af6844fd19a48c69a8869c","modified":1471163188030},{"_id":"themes/pacman/README.md","hash":"9f0be78dbd1f34f44a955cf02bbe03f979c7a1e6","modified":1471163188035},{"_id":"themes/pacman/_config.yml","hash":"d5eebc9920072cb99823e7f4e6366f88d99d2bb6","modified":1471163188042},{"_id":"source/_posts/Ant的使用.md","hash":"0b9556e59d1dd1eb68ccfcd427d009ececb9302b","modified":1471165582810},{"_id":"source/_posts/ant编译java工程jdk路径的设置.md","hash":"363cd4e9b485f14f3ecace15eb756efbb92b4cb9","modified":1471163187863},{"_id":"source/_posts/java_Tips.md","hash":"7d057cd39a8e28ad7d81304f7b71d623838cb9b7","modified":1471163187869},{"_id":"source/_posts/java中的ThreadLocal.md","hash":"f9cc4f6fea9ba91ed338be75b2dfaea987c44f53","modified":1471163187877},{"_id":"source/_posts/java中的equals与hashcode.md","hash":"f73295e763e7b7e86544b79d55434058615f31bf","modified":1471165905221},{"_id":"source/_posts/java中的volatile与synchronized.md","hash":"a59bcb9cdb11bbff46e1abda0c0451b70e29fa29","modified":1471163187886},{"_id":"source/_posts/java中的枚举.md","hash":"42c1a7327329e60a0b73f55197268cda9e6af7a8","modified":1471165856616},{"_id":"source/_posts/java中的类型转换.md","hash":"1248e2002c9d056665889ad30c3821f5ec8bfe93","modified":1471163187899},{"_id":"source/_posts/java中的编码问题.md","hash":"2ad4315b8d8f63d859e28d5e4f7073fa7a485a06","modified":1471165882744},{"_id":"source/_posts/java同步锁锁什么.md","hash":"e864394007c4efd37534180170957618c31402ea","modified":1471163187914},{"_id":"source/_posts/java源码阅读-集合类-ArrayList.md","hash":"4014db44d43cbfe660e8ada2e1aa3628b16ca8a1","modified":1471163187920},{"_id":"source/_posts/junit使用.md","hash":"73be3a7510e33351504f753f6646465d9f835f2c","modified":1471163187926},{"_id":"source/_posts/markdown.md","hash":"74564b0853bc2c4f29b2b92268dd9bdd6eceb49f","modified":1471163187932},{"_id":"source/_posts/notify问题.md","hash":"1380f520f0812cb8ed93fc302b58bcde3c89b6db","modified":1471165791722},{"_id":"source/_posts/sphinx安装问题.md","hash":"d8e860a7bf662aec845ba3792ea1ad9b9f7c289d","modified":1471163187941},{"_id":"source/_posts/为什么是final.md","hash":"bf251e6074bb2cf6228f63049a51de1519e79fe3","modified":1471163187942},{"_id":"source/_posts/他可是科比·布莱恩特!.md","hash":"2dde1cdef9d4958a816e454002358e9e9ddac07a","modified":1471163187943},{"_id":"source/_posts/代码格式.md","hash":"b8d8ec128ce39cb2199a51ecfd2fd04c6fefb758","modified":1471163187957},{"_id":"source/_posts/关于抽象类和接口.md","hash":"227f5f427cee51015baa90d2114ed06098d5bac8","modified":1471165817537},{"_id":"source/_posts/常用快捷键总结.md","hash":"bdae2b8857bbfa51fbda2ed8e7df26efdcd7e8f0","modified":1471163187963},{"_id":"source/_posts/毕业了.md","hash":"4981a9b7307b03dccef6da1b40f1528fbccc2670","modified":1471163187968},{"_id":"themes/pacman/languages/default.yml","hash":"9ffaaf4dbe83f1f343ea702e59493dc6f3f46877","modified":1471163188043},{"_id":"themes/pacman/languages/zh-CN.yml","hash":"680d877a531f8df04b30b462a5131b5d3a8ca372","modified":1471163188047},{"_id":"themes/pacman/languages/zh-TW.yml","hash":"08a6eae3c1e48f96690ca4c29ce67f8d6ff9a8bd","modified":1471163188051},{"_id":"themes/pacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1471163188190},{"_id":"themes/pacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1471163188194},{"_id":"themes/pacman/layout/index.ejs","hash":"dc463eb532313dcdddea9c1a0c8f5a35dbd55f6e","modified":1471163188195},{"_id":"themes/pacman/layout/layout.ejs","hash":"4a5ff6004214906b9ca159fc4187b8923c7bcd11","modified":1471163188196},{"_id":"themes/pacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1471163188197},{"_id":"themes/pacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1471163188201},{"_id":"themes/pacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1471163188202},{"_id":"themes/pacman/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1471163188204},{"_id":"source/_posts/java中的编码问题/reader.png","hash":"4cf16c765f0952a9134bc5097270d3a6b2679f76","modified":1471163187907},{"_id":"source/_posts/java中的编码问题/utf8.png","hash":"f4a2eb95b15e12d6957c07099fafd42d9b6c035e","modified":1471163187908},{"_id":"source/_posts/java中的编码问题/writer.png","hash":"3ac4dcf3e18dc011372297be5069f387fef0e9f9","modified":1471163187910},{"_id":"themes/pacman/layout/_widget/archive.ejs","hash":"b82d7fb0d1119738a9f9bb747d415e8c99e454ae","modified":1471163188174},{"_id":"themes/pacman/layout/_widget/category.ejs","hash":"ab647b97f55e550af54598dee0c4bb132ef43c46","modified":1471163188176},{"_id":"themes/pacman/layout/_widget/links.ejs","hash":"0d5ef5c05694fb61020fedffbdebe02cb6361c8d","modified":1471163188177},{"_id":"themes/pacman/layout/_widget/rss.ejs","hash":"ebfb11bdd603cd6e4dcf3949cc52e38009615c25","modified":1471163188180},{"_id":"themes/pacman/layout/_widget/tag.ejs","hash":"b994f8c43b190b852568e355944d5af151dcefe6","modified":1471163188186},{"_id":"themes/pacman/layout/_widget/tagcloud.ejs","hash":"317d420f5448c7452290e37f0ed8516cb73f4068","modified":1471163188187},{"_id":"themes/pacman/layout/_partial/after_footer.ejs","hash":"db09ae62aa29b4c6495c698f9bb14d718a637423","modified":1471163188052},{"_id":"themes/pacman/layout/_partial/archive.ejs","hash":"2241d64f001c96cffa4a129ebea177a5421d147d","modified":1471163188053},{"_id":"themes/pacman/layout/_partial/article.ejs","hash":"8e446ec97c30774807657fc9fb7bceb6905699aa","modified":1471163188066},{"_id":"themes/pacman/layout/_partial/categories.ejs","hash":"2b77ff6cbc8571cab27c3bdc4ad51a79510bbca2","modified":1471163188071},{"_id":"themes/pacman/layout/_partial/footer.ejs","hash":"497a37f6246d4f1b91039762655dfcb01849c4b6","modified":1471163188081},{"_id":"themes/pacman/layout/_partial/google_analytics.ejs","hash":"7ebccafcfdaca5cb5b8f4f06548f1d50958726ef","modified":1471163188094},{"_id":"themes/pacman/layout/_partial/head.ejs","hash":"dc9ecf58ae7990f16089784e33753dd94ed4becc","modified":1471163188109},{"_id":"themes/pacman/layout/_partial/header.ejs","hash":"dc77ad898bdd8273d5bff00923197a5345aa02ca","modified":1471163188121},{"_id":"themes/pacman/layout/_partial/pagination.ejs","hash":"6cf37f844f150af4bbe212610da61e5140317de9","modified":1471163188123},{"_id":"themes/pacman/layout/_partial/search.ejs","hash":"5f1c22e78158cdb77f2af28517b6cbe96150fdd5","modified":1471163188171},{"_id":"themes/pacman/layout/_partial/sidebar.ejs","hash":"565979955cecaab9105b23f668aa63bf97e9c20e","modified":1471163188172},{"_id":"themes/pacman/layout/_partial/tags.ejs","hash":"c5c858742b29e6364da2e1d098e7d6cd8cef038f","modified":1471163188173},{"_id":"themes/pacman/source/css/style.styl","hash":"fd9224ce13feac0a9b406c28d9bafbd4deda42f5","modified":1471163188241},{"_id":"themes/pacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1471163188243},{"_id":"themes/pacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1471163188245},{"_id":"themes/pacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1471163188246},{"_id":"themes/pacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1471163188247},{"_id":"themes/pacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1471163188248},{"_id":"themes/pacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1471163188250},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1471163188261},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1471163188272},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1471163188295},{"_id":"themes/pacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1471163188304},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1471163188321},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1471163188336},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1471163188341},{"_id":"themes/pacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1471163188357},{"_id":"themes/pacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1471163188384},{"_id":"themes/pacman/source/img/author.jpg","hash":"cf5161efc731fc892ab04b77c2369c7fdad21d87","modified":1471163188389},{"_id":"themes/pacman/source/img/favicon.ico","hash":"fa2c03e9eb35f2f423a1c85c85c278649a857532","modified":1471163188390},{"_id":"themes/pacman/source/img/logo.svg","hash":"cef3f0bb4bf3661dd3a58c81b9a7be79601a0bfb","modified":1471163188394},{"_id":"themes/pacman/source/img/xiaoxin.ico","hash":"82778e9316d3d1d366442a8f5d0468dda013d983","modified":1471163188395},{"_id":"themes/pacman/source/img/xiaoxin.png","hash":"479898e56ba23fdc6c68a611939316ad58f6e78c","modified":1471163188402},{"_id":"source/_posts/他可是科比·布莱恩特!/kobe.jpg","hash":"5e2e8343a4fba076d7475cc6cda941d21176be44","modified":1471163187950},{"_id":"source/_posts/毕业了/graduation5.jpg","hash":"976ff6965b27f578d365ae139db1c8d5c298d757","modified":1471163188006},{"_id":"source/_posts/毕业了/graduation6.jpg","hash":"4f36689e7db00afd3f2bc3b4c33480e9d1f1a99c","modified":1471163188013},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.svg","hash":"739808e56a56e10a03bc93d03eb55abd19590942","modified":1471163188329},{"_id":"themes/pacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1471163188376},{"_id":"themes/pacman/source/js/jquery-2.1.0.min.js","hash":"0faaa0c56f563693cdeafa299f97e3d5bd6fcdd8","modified":1471163188443},{"_id":"themes/pacman/source/img/xiaoxin.jpg","hash":"2ee983f8da1be448bd89e8fe0b7c093606bf9788","modified":1471163188401},{"_id":"themes/pacman/layout/_partial/post/article.ejs","hash":"d6f989cf2be408cb8573629f260c75b20df42982","modified":1471163188129},{"_id":"themes/pacman/layout/_partial/post/catetags.ejs","hash":"fa03892b35dc344de7a722b9393978286c0376fe","modified":1471163188130},{"_id":"themes/pacman/layout/_partial/post/comment.ejs","hash":"f0e21c685c0e3fe78c9b5f5f6d4eb9c1b5cf036f","modified":1471163188136},{"_id":"themes/pacman/layout/_partial/post/footer.ejs","hash":"a4dc14cd47d22f1b73860bc3c7f424eae3d282dd","modified":1471163188137},{"_id":"themes/pacman/layout/_partial/post/gallery.ejs","hash":"6bd8723f24b192158e6e840bf14028503ad50045","modified":1471163188138},{"_id":"themes/pacman/layout/_partial/post/header.ejs","hash":"953e6feaf7b156fab79165342e9bca0ef54384ba","modified":1471163188148},{"_id":"themes/pacman/layout/_partial/post/jiathis.ejs","hash":"5043a5058887cf6ad15182cfde345d36cb6ab323","modified":1471163188156},{"_id":"themes/pacman/layout/_partial/post/pagination.ejs","hash":"7b2c70d381d6d6f8a55d89180a9bc0f27118812e","modified":1471163188160},{"_id":"themes/pacman/source/css/_base/code.styl","hash":"577798b3c101be20b7ceb3d1e0421b4c4426d0ce","modified":1471163188210},{"_id":"themes/pacman/source/css/_base/font.styl","hash":"772749cc7c6a47410bb667f8127b37767d029283","modified":1471163188211},{"_id":"themes/pacman/source/css/_base/public.styl","hash":"a9d7524315303734f3f47e5e875a14b867888a50","modified":1471163188217},{"_id":"themes/pacman/source/css/_base/variable.styl","hash":"9a569db82e70eb1a826eb58a7d4b002aafa47d8e","modified":1471163188218},{"_id":"themes/pacman/source/css/_partial/article.styl","hash":"ffc40f735883bea18297dd380ad78ed554c9d5fb","modified":1471163188223},{"_id":"themes/pacman/source/css/_partial/aside.styl","hash":"ac937e5921c4084f29249819d51224ebc4296225","modified":1471163188224},{"_id":"themes/pacman/source/css/_partial/duoshuo.styl","hash":"3ec423b734639614fbd11ec2c3445d3a03f5231d","modified":1471163188228},{"_id":"themes/pacman/source/css/_partial/footer.styl","hash":"65c0ea98fdda93d266f9bc5b9af9032c46fb479b","modified":1471163188233},{"_id":"themes/pacman/source/css/_partial/gallery.styl","hash":"b85a32c4bc71f720d74143a17a202fe8fa067950","modified":1471163188234},{"_id":"themes/pacman/source/css/_partial/header.styl","hash":"7d4ef4b2b1916909f8f198519f576c3d712d7423","modified":1471163188235},{"_id":"themes/pacman/source/css/_partial/helper.styl","hash":"554a7bc576b1419f0055ff56113d4be803b118d1","modified":1471163188236},{"_id":"themes/pacman/source/css/_partial/index.styl","hash":"a00aafe86d0238bf58f093834b6ae7406e918ec0","modified":1471163188240},{"_id":"themes/pacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1471163188251},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1471163188252},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1471163188253},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1471163188254},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1471163188255},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1471163188256},{"_id":"source/_posts/毕业了/graduation3.jpg","hash":"54cffe443f66930659fe9d0a6ee12154ce8d5c28","modified":1471163187990},{"_id":"themes/pacman/source/font/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1471163188367},{"_id":"source/_posts/毕业了/graduation2.jpg","hash":"ccffa377b02496a0f2437578d7f6d35b879373a5","modified":1471163187984},{"_id":"source/_posts/毕业了/graduation8.jpg","hash":"ab88166275c1a01036fe3680407dfff9f52c3434","modified":1471163188028},{"_id":"source/_posts/毕业了/graduation1.jpg","hash":"55cd28acab408b9a81fd6877a47e24d20749e20c","modified":1471163187977},{"_id":"source/_posts/毕业了/graduation7.jpg","hash":"4ef31ad176f81cde92dff0958cfc0b70d789e754","modified":1471163188020},{"_id":"source/_posts/毕业了/graduation4.jpg","hash":"e84c1f0a512f1aba02163ba3a8cf39460b9cb28b","modified":1471163188000},{"_id":"public/2016/07/12/java源码阅读-集合类-ArrayList/index.html","hash":"7430749157ffced0af43c77fa051930f09aaf304","modified":1471165957752},{"_id":"public/2016/06/30/毕业了/index.html","hash":"531dd3be4788453cffd91768b281191adf6438cb","modified":1471165957753},{"_id":"public/2016/04/25/ant编译java工程jdk路径的设置/index.html","hash":"b4f0d8edf2f6f654deaa4ec69282c03daa00d117","modified":1471165957753},{"_id":"public/2016/04/14/他可是科比·布莱恩特!/index.html","hash":"dbf3d78290de48265fd41795c087123bc66494d8","modified":1471165957753},{"_id":"public/2016/04/12/junit使用/index.html","hash":"d958904a5a80dc471d6376a46a9bc6a4187ed834","modified":1471165957754},{"_id":"public/2016/03/30/sphinx安装问题/index.html","hash":"a33719b5d6357ed0c22beebadf9786295ca6fbaa","modified":1471165957754},{"_id":"public/2016/03/22/常用快捷键总结/index.html","hash":"e476856d01100837718fe24c14f502646b5be92a","modified":1471165957754},{"_id":"public/2015/12/17/java中的volatile与synchronized/index.html","hash":"30217a8a5ab09dd34f2c1a2a0a3f6ed18dccc3e9","modified":1471165957754},{"_id":"public/2015/12/17/java同步锁锁什么/index.html","hash":"dfd9492ebb0eece514b1bc12663e3eedfa8ea897","modified":1471165957754},{"_id":"public/archives/index.html","hash":"567781aed84b9111c38556aecdd3bf74ced2c7f6","modified":1471165957755},{"_id":"public/archives/page/2/index.html","hash":"38749cc33de7a2ece0afc144bf412ed3673fb20f","modified":1471165957755},{"_id":"public/archives/page/3/index.html","hash":"79183d3eefd8975c7fdf09ef545846ab6559a7d2","modified":1471165957755},{"_id":"public/archives/2015/index.html","hash":"bf021a3bf1093cceae90e3a5e40aeace4eff9b3d","modified":1471165957755},{"_id":"public/archives/2015/12/index.html","hash":"327661f7dca617e9fa3853bc1eb98c9a8b44ded1","modified":1471165957755},{"_id":"public/archives/2016/index.html","hash":"6f7b2999d7b9f0f4f25109ef41797b0b6a3b6d97","modified":1471165957755},{"_id":"public/archives/2016/page/2/index.html","hash":"a2930df4aabbd55b3b84a40fcb4ef27eb73c2d52","modified":1471165957755},{"_id":"public/archives/2016/03/index.html","hash":"ec8ebe5cbd05f8b71c2d892e3b7ba310293c3b6d","modified":1471165957755},{"_id":"public/archives/2016/04/index.html","hash":"5e37dc0179ba04cd4046784c2af3aa40d0922b83","modified":1471165957755},{"_id":"public/archives/2016/06/index.html","hash":"a0b8ea9fd4e8c7b378c49ca7b919619382dc145a","modified":1471165957756},{"_id":"public/archives/2016/07/index.html","hash":"a7bbf9753876b4fb2ceea8980cc8225134cfdcc9","modified":1471165957756},{"_id":"public/categories/工具/index.html","hash":"1fd6e3a625d0e1e9d10b9b9e7d186f9a5631a415","modified":1471165957756},{"_id":"public/categories/编程/index.html","hash":"b837e36eba954e200a1db1568d5a64e2f1b4325a","modified":1471165957756},{"_id":"public/categories/编程/page/2/index.html","hash":"b155dbc53cc92e3e5b7473a09041b5099ad6e228","modified":1471165957756},{"_id":"public/categories/java-多线程/index.html","hash":"8dc5097a0358f55d8bd8968bc844a961179ae834","modified":1471165378455},{"_id":"public/categories/生活/index.html","hash":"790732900447a37c16d867f729f424f376a5caff","modified":1471165957756},{"_id":"public/index.html","hash":"e8b1333eae8b5f565793c17f30ab2e92a9b50f55","modified":1471165957757},{"_id":"public/page/2/index.html","hash":"ced97b4e476a5439498d9791c56fe3ee2e8b5762","modified":1471165957757},{"_id":"public/page/3/index.html","hash":"857441f6803e9d3ee4416a14324a1eeb31601c84","modified":1471165957757},{"_id":"public/tags/java/index.html","hash":"9f2416999d229fd3ca8c983d63dd4bc30a926e5b","modified":1471165957756},{"_id":"public/tags/java/page/2/index.html","hash":"034c6866e603dfce8d9c88a1ca46d8e6093db698","modified":1471165957756},{"_id":"public/tags/ant/index.html","hash":"513bd13d3e59cf05b1d745cb002caa9c15fe1c4b","modified":1471165957756},{"_id":"public/tags/多线程/index.html","hash":"25e2e2ed79919f8f597d8f7ac6adfa78ea91ad1b","modified":1471165957756},{"_id":"public/tags/编码/index.html","hash":"de105f66340d42890c05a771030681dd22219198","modified":1471165957757},{"_id":"public/tags/junit/index.html","hash":"dd01a1cc2959d999b9e0e8ac36cddd2a7166ebd1","modified":1471165957757},{"_id":"public/tags/测试/index.html","hash":"19b3990f159281fa7e04f61c38a2b57f7e44c7c3","modified":1471165957757},{"_id":"public/tags/markdown/index.html","hash":"de9266df2fd2edc08eabfc86d9d886733453a63c","modified":1471165957757},{"_id":"public/tags/python/index.html","hash":"013a75c72f59781446b2ead84a9ae96af1260391","modified":1471165957757},{"_id":"public/tags/快捷键/index.html","hash":"e091643a0be4befd878fc199e53c7f4977d10d25","modified":1471165957757},{"_id":"public/2016/07/31/为什么是final/index.html","hash":"036012e538c88b72f1ac2f186205a200974044eb","modified":1471165957757},{"_id":"public/2016/07/24/java_Tips/index.html","hash":"42088e03cde9a29c94fcf9f97ec0d943dbff53b2","modified":1471165957757},{"_id":"public/2016/07/18/Ant的使用/index.html","hash":"7eb623feca214b4923a21eb07e3a78503ea6fff9","modified":1471165957758},{"_id":"public/2016/06/30/java中的枚举/index.html","hash":"3e5384dc07382f4ed59befb199f435fea447f1a3","modified":1471165957758},{"_id":"public/2016/06/21/java中的ThreadLocal/index.html","hash":"491f6b6db4bc20ebc60abcf49b12345f76bcaa50","modified":1471165957758},{"_id":"public/2016/04/28/java中的类型转换/index.html","hash":"701a8bc3fc85237e1604cd818b5851927ee0476f","modified":1471165957758},{"_id":"public/2016/04/28/java中的equals与hashcode/index.html","hash":"39c7602601167d52c52bcde9f60866ae56af30ad","modified":1471165957758},{"_id":"public/2016/04/20/java中的编码问题/index.html","hash":"596a1a921617397899ce7f0900b68e7a14ca3d0a","modified":1471165957758},{"_id":"public/2016/04/15/关于抽象类和接口/index.html","hash":"ecd5b0bdff662a47113b6069319e9b6760ea47a9","modified":1471165957758},{"_id":"public/2016/03/29/代码格式/index.html","hash":"fe37ebd818eace129cca4e11c79834e17eed8bb3","modified":1471165957758},{"_id":"public/2016/03/03/markdown/index.html","hash":"166e8f2db6d894194bdce4ef41ae28a0d3c6a412","modified":1471165957758},{"_id":"public/2015/12/21/notify问题/index.html","hash":"eed67ed8462b36e75a07b158fdde996f64b41dcf","modified":1471165957759},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1471163325811},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1471163325811},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1471163325811},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1471163325811},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1471163325811},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1471163325812},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1471163325812},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1471163325812},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1471163325812},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1471163325812},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1471163325812},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1471163325812},{"_id":"public/img/author.jpg","hash":"cf5161efc731fc892ab04b77c2369c7fdad21d87","modified":1471163325812},{"_id":"public/img/favicon.ico","hash":"fa2c03e9eb35f2f423a1c85c85c278649a857532","modified":1471163325812},{"_id":"public/img/logo.svg","hash":"cef3f0bb4bf3661dd3a58c81b9a7be79601a0bfb","modified":1471163325813},{"_id":"public/img/xiaoxin.ico","hash":"82778e9316d3d1d366442a8f5d0468dda013d983","modified":1471163325813},{"_id":"public/img/xiaoxin.png","hash":"479898e56ba23fdc6c68a611939316ad58f6e78c","modified":1471163325813},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1471163325813},{"_id":"public/2016/04/20/java中的编码问题/reader.png","hash":"4cf16c765f0952a9134bc5097270d3a6b2679f76","modified":1471163325813},{"_id":"public/2016/04/20/java中的编码问题/utf8.png","hash":"f4a2eb95b15e12d6957c07099fafd42d9b6c035e","modified":1471163325813},{"_id":"public/2016/04/20/java中的编码问题/writer.png","hash":"3ac4dcf3e18dc011372297be5069f387fef0e9f9","modified":1471163325813},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"739808e56a56e10a03bc93d03eb55abd19590942","modified":1471163327294},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1471163327295},{"_id":"public/img/xiaoxin.jpg","hash":"2ee983f8da1be448bd89e8fe0b7c093606bf9788","modified":1471163327296},{"_id":"public/2016/04/14/他可是科比·布莱恩特!/kobe.jpg","hash":"5e2e8343a4fba076d7475cc6cda941d21176be44","modified":1471163327296},{"_id":"public/2016/06/30/毕业了/graduation5.jpg","hash":"976ff6965b27f578d365ae139db1c8d5c298d757","modified":1471163327296},{"_id":"public/2016/06/30/毕业了/graduation6.jpg","hash":"4f36689e7db00afd3f2bc3b4c33480e9d1f1a99c","modified":1471163327296},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1471163327309},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1471163327309},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1471163327309},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1471163327309},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1471163327309},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1471163327310},{"_id":"public/css/style.css","hash":"e3e1ec9060ce2fa8cae11c2e113dd1b45cfed017","modified":1471163327310},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1471163327310},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1471163327310},{"_id":"public/js/jquery-2.1.0.min.js","hash":"98884258cbdb0d939fa2c5e74fc7ac9e56d8170f","modified":1471163327310},{"_id":"public/font/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1471163327313},{"_id":"public/2016/06/30/毕业了/graduation3.jpg","hash":"54cffe443f66930659fe9d0a6ee12154ce8d5c28","modified":1471163327313},{"_id":"public/2016/06/30/毕业了/graduation2.jpg","hash":"ccffa377b02496a0f2437578d7f6d35b879373a5","modified":1471163327315},{"_id":"public/2016/06/30/毕业了/graduation8.jpg","hash":"ab88166275c1a01036fe3680407dfff9f52c3434","modified":1471163327315},{"_id":"public/2016/06/30/毕业了/graduation1.jpg","hash":"55cd28acab408b9a81fd6877a47e24d20749e20c","modified":1471163327354},{"_id":"public/2016/06/30/毕业了/graduation7.jpg","hash":"4ef31ad176f81cde92dff0958cfc0b70d789e754","modified":1471163327354},{"_id":"public/2016/06/30/毕业了/graduation4.jpg","hash":"e84c1f0a512f1aba02163ba3a8cf39460b9cb28b","modified":1471163327402},{"_id":"source/CNAME","hash":"75913de577e6e2674855228ebb98f985574fdca1","modified":1471149316499},{"_id":"public/CNAME","hash":"75913de577e6e2674855228ebb98f985574fdca1","modified":1471164636455}],"Category":[{"name":"工具","_id":"cirucnp7p0003jkqckg3ji5gv"},{"name":"编程","_id":"cirucnp820008jkqczfxmxo6f"},{"name":"java 多线程","_id":"cirucnp9m0018jkqcb0pj0ofc"},{"name":"生活","_id":"cirucnpad001jjkqc538267m7"}],"Data":[],"Page":[],"Post":[{"layout":"post","date":"2016-07-18T04:48:55.000Z","title":"ANT的使用","_content":"\n>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和[Ant](http://ant.apache.org/)打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。\n\n## 教程\n\nAnt是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。\n\n[Ant Tutorial](http://www.tutorialspoint.com/ant/index.htm)\n\n[Ant 实践](http://www.uml.org.cn/j2ee/j2ee091302.htm#content)\n\n另外附上Ant常用命令：\n\n[Overview of Apache Ant Tasks](https://ant.apache.org/manual/tasksoverview.html)\n\n## 实践\n\n下面是自己写的build.xml。存在这里，以后用到可以参考。\n\n下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。\n\n- **build.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n    Oscar XcluseterHibernate Ant build file\n-->\n<project name=\"OSCAR-XCLUSETER-HIBERNATE\" default=\"usage\" basedir=\".\">\n\t<target name=\"build\" depends=\"clean\" />\n\n\t<target name=\"init\" description=\"default init\">\n\t\t<property file=\"build.properties\" />\n\n\t\t<!-- Project Properties -->\n\t\t<property name=\"project\" value=\"oscarXcluseterHibernate3\" />\n\t\t<property name=\"name\" value=\"OSCAR HIBERNATE\" />\n\t\t<tstamp>\n\t\t\t<format property=\"year\" pattern=\"yyyy\" locale=\"zh_CN\" />\n\t\t\t<format property=\"builddate\" pattern=\"yyMMdd\" locale=\"zh_CN\" />\n\t\t</tstamp>\n\t\t<property name=\"version\" value=\"${version.major}.${version.minor}.${version.revision}${version.suffix}\" />\n\t\t<property name=\"version.number\" value=\"${version.major}.${version.minor}.${version.revision}\" />\n\t\t<property name=\"version.major.minor\" value=\"${version.major}.${version.minor}\" />\n\n\t\t<property name=\"final.name\" value=\"${project}\" />\n\t\t<property name=\"vesrion.build\" value=\"build${builddate} ${version.subbuild} ${version.buildID} for ALL \" />\n\n\t\t<!-- Build Defaults -->\n\t\t<property name=\"src.dir\" value=\"${basedir}/src\" />\n\t\t<property name=\"lib.dir\" value=\"${basedir}/lib\" />\n\t\t<property name=\"build.home\" value=\"${basedir}\" />\n\t\t<property name=\"build.src\" value=\"${basedir}/build\" />\n\t\t<property name=\"build.dest\" value=\"${basedir}/antClasses\" />\n\t\t<property name=\"build.release\" value=\"${basedir}/release\" />\n\t\t<property name=\"build.tmp\" value=\"${basedir}/tmp\" />\n\n\t\t<!-- JAR artifacts -->\n\t\t<property name=\"hiberante3.jar\" value=\"${lib.dir}/hibernate3.jar\" />\n\n\t\t<!-- Version info filter set -->\n\t\t<tstamp>\n\t\t\t<format property=\"DSTAMP\" pattern=\"yyyyMMdd\" locale=\"zh_CN\" />\n\t\t\t<format property=\"TSTAMP\" pattern=\"hhmm\" />\n\t\t</tstamp>\n\t\t<filterset id=\"version.filters\">\n\t\t\t<filter token=\"VERSION_NUMBER\" value=\"${version.number}\" />\n\t\t\t<filter token=\"BUNDLE_NAME\" value=\"${vesrion.name}\" />\n\t\t\t<filter token=\"BUNDLE_VERSION\" value=\"${version}${DSTAMP}${TSTAMP}\" />\n\t\t\t<filter token=\"BUILD_VERSION\" value=\"${vesrion.build}\" />\n\t\t</filterset>\n\t\t<path id=\"classpath\">\n\t\t\t<pathelement location=\"${hiberante3.jar}\" />\n\t\t</path>\n\t</target>\n\n\t<target name=\"usage\" depends=\"init\">\n\t\t<echo message=\"${name} Build file\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" available targets are:\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"   package  --> generates oscarXcluseterHibernate file\" />\n\t\t<echo message=\"   build    --> compiles the source code\" />\n\t\t<echo message=\"   clean    --> cleans up the directory\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" See the comments inside the build.xml file for more details.\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"\" />\n\t</target>\n\n\t<!-- Just build -->\n\t<target name=\"compile-prepare\" depends=\"init\" description=\"Prepare for compile\">\n\n\t\t<!-- create directories -->\n\t\t<mkdir dir=\"${build.src}\" />\n\t\t<mkdir dir=\"${build.dest}\" />\n\n\t\t<!-- copy src files -->\n\t\t<copy todir=\"${build.src}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${src.dir}\">\n\t\t\t\t<exclude name=\"**/*.MF\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"compile\" depends=\"compile-prepare\" description=\"compile the project\">\n\n\t\t<!-- Compiles the source directory  -->\n\t\t<javac srcdir=\"${build.src}\" \n\t\t\tdestdir=\"${build.dest}\" \n\t\t\tdebug=\"${build.debug}\" \n\t\t\tdeprecation=\"${build.deprecation}\" \n\t\t\tsource=\"${build.source}\" \n\t\t\ttarget=\"${build.target}\" \n\t\t\tcompiler=\"${build.compiler}\" \n\t\t\toptimize=\"${build.optimize}\" \n\t\t\tincludes=\"**/*.java\" \n\t\t\texcludes=\"**/CVS/**,**/.svn/**\" \n\t\t\tencoding=\"GB18030\"\n\t\t\tincludeantruntime=\"false\"\n\t\t\texecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"\n\t\t\tfork=\"yes\">\n\t\t\t<classpath refid=\"classpath\" />\n\t\t</javac>\n\n\t\t<!-- copy src files exclude java file-->\n\t\t<copy todir=\"${build.dest}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${build.src}\">\n\t\t\t\t<exclude name=\"**/*.java\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"build-manifests\" depends=\"init,compile-prepare\">\n\t\t<!-- Filtering tokens for JAR manifests-->\n\t\t<filter token=\"source.jdk\" value=\"${build.source}\" />\n\t\t<filter token=\"target.jdk\" value=\"${build.target}\" />\n\t\t<mkdir dir=\"${build.tmp}\" />\n\t\t<copy todir=\"${build.tmp}\" overwrite=\"yes\" filtering=\"yes\" encoding=\"GB18030\">\n\t\t\t<filterset refid=\"version.filters\" />\n\t\t\t<fileset dir=\"src/META-INF\" includes=\"MANIFEST.MF\" />\n\t\t</copy>\n\t</target>\n\n\t<target name=\"package\" depends=\"compile,build-manifests\" description=\"create jar file\">\n\t\t<mkdir dir=\"${build.release}\" />\n\t\t<jar jarfile=\"${build.release}/${final.name}.jar\" manifest=\"${build.tmp}/MANIFEST.MF\" basedir=\"${build.dest}\" includes=\"**\" />\n\t</target>\n\n\t<target name=\"clean\" depends=\"package\">\n\t\t<delete dir=\"${build.src}\" />\n\t\t<delete dir=\"${build.dest}\" />\n\t\t<delete dir=\"${build.tmp}\" />\n\t</target>\n</project>\n\n```\n\n- **build.properties**\n\n```java\n\n# -----------------------------------------------------------------------------\n# build.properties\n#\n# This is an example \"build.properties\" file, used to customize building \n# OSCAR-JDBC for your local environment.  It defines the location of all external\n# modules that OSCAR-JDBC depends on.\n# -----------------------------------------------------------------------------\n\n# ----- Version Control Flags -----\nvesrion.name=Main\nversion.major=1\nversion.minor=0\nversion.revision=0\nversion.suffix=x\nversion.subbuild=001\nversion.buildID=00000000\n\nbuild.source=1.5\nbuild.target=1.5\nbuild.debug=false\nbuild.optimize=true\nbuild.compiler=javac1.5\n\n```","source":"_posts/Ant的使用.md","raw":"---\nlayout: post\ndate:   2016-07-18 12:48:55\ntitle:  \"ANT的使用\"\ncategories: 工具\ntags: \n- java\n- ant\n---\n\n>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和[Ant](http://ant.apache.org/)打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。\n\n## 教程\n\nAnt是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。\n\n[Ant Tutorial](http://www.tutorialspoint.com/ant/index.htm)\n\n[Ant 实践](http://www.uml.org.cn/j2ee/j2ee091302.htm#content)\n\n另外附上Ant常用命令：\n\n[Overview of Apache Ant Tasks](https://ant.apache.org/manual/tasksoverview.html)\n\n## 实践\n\n下面是自己写的build.xml。存在这里，以后用到可以参考。\n\n下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。\n\n- **build.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n    Oscar XcluseterHibernate Ant build file\n-->\n<project name=\"OSCAR-XCLUSETER-HIBERNATE\" default=\"usage\" basedir=\".\">\n\t<target name=\"build\" depends=\"clean\" />\n\n\t<target name=\"init\" description=\"default init\">\n\t\t<property file=\"build.properties\" />\n\n\t\t<!-- Project Properties -->\n\t\t<property name=\"project\" value=\"oscarXcluseterHibernate3\" />\n\t\t<property name=\"name\" value=\"OSCAR HIBERNATE\" />\n\t\t<tstamp>\n\t\t\t<format property=\"year\" pattern=\"yyyy\" locale=\"zh_CN\" />\n\t\t\t<format property=\"builddate\" pattern=\"yyMMdd\" locale=\"zh_CN\" />\n\t\t</tstamp>\n\t\t<property name=\"version\" value=\"${version.major}.${version.minor}.${version.revision}${version.suffix}\" />\n\t\t<property name=\"version.number\" value=\"${version.major}.${version.minor}.${version.revision}\" />\n\t\t<property name=\"version.major.minor\" value=\"${version.major}.${version.minor}\" />\n\n\t\t<property name=\"final.name\" value=\"${project}\" />\n\t\t<property name=\"vesrion.build\" value=\"build${builddate} ${version.subbuild} ${version.buildID} for ALL \" />\n\n\t\t<!-- Build Defaults -->\n\t\t<property name=\"src.dir\" value=\"${basedir}/src\" />\n\t\t<property name=\"lib.dir\" value=\"${basedir}/lib\" />\n\t\t<property name=\"build.home\" value=\"${basedir}\" />\n\t\t<property name=\"build.src\" value=\"${basedir}/build\" />\n\t\t<property name=\"build.dest\" value=\"${basedir}/antClasses\" />\n\t\t<property name=\"build.release\" value=\"${basedir}/release\" />\n\t\t<property name=\"build.tmp\" value=\"${basedir}/tmp\" />\n\n\t\t<!-- JAR artifacts -->\n\t\t<property name=\"hiberante3.jar\" value=\"${lib.dir}/hibernate3.jar\" />\n\n\t\t<!-- Version info filter set -->\n\t\t<tstamp>\n\t\t\t<format property=\"DSTAMP\" pattern=\"yyyyMMdd\" locale=\"zh_CN\" />\n\t\t\t<format property=\"TSTAMP\" pattern=\"hhmm\" />\n\t\t</tstamp>\n\t\t<filterset id=\"version.filters\">\n\t\t\t<filter token=\"VERSION_NUMBER\" value=\"${version.number}\" />\n\t\t\t<filter token=\"BUNDLE_NAME\" value=\"${vesrion.name}\" />\n\t\t\t<filter token=\"BUNDLE_VERSION\" value=\"${version}${DSTAMP}${TSTAMP}\" />\n\t\t\t<filter token=\"BUILD_VERSION\" value=\"${vesrion.build}\" />\n\t\t</filterset>\n\t\t<path id=\"classpath\">\n\t\t\t<pathelement location=\"${hiberante3.jar}\" />\n\t\t</path>\n\t</target>\n\n\t<target name=\"usage\" depends=\"init\">\n\t\t<echo message=\"${name} Build file\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" available targets are:\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"   package  --> generates oscarXcluseterHibernate file\" />\n\t\t<echo message=\"   build    --> compiles the source code\" />\n\t\t<echo message=\"   clean    --> cleans up the directory\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\" See the comments inside the build.xml file for more details.\" />\n\t\t<echo message=\"-------------------------------------------------------------\" />\n\t\t<echo message=\"\" />\n\t\t<echo message=\"\" />\n\t</target>\n\n\t<!-- Just build -->\n\t<target name=\"compile-prepare\" depends=\"init\" description=\"Prepare for compile\">\n\n\t\t<!-- create directories -->\n\t\t<mkdir dir=\"${build.src}\" />\n\t\t<mkdir dir=\"${build.dest}\" />\n\n\t\t<!-- copy src files -->\n\t\t<copy todir=\"${build.src}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${src.dir}\">\n\t\t\t\t<exclude name=\"**/*.MF\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"compile\" depends=\"compile-prepare\" description=\"compile the project\">\n\n\t\t<!-- Compiles the source directory  -->\n\t\t<javac srcdir=\"${build.src}\" \n\t\t\tdestdir=\"${build.dest}\" \n\t\t\tdebug=\"${build.debug}\" \n\t\t\tdeprecation=\"${build.deprecation}\" \n\t\t\tsource=\"${build.source}\" \n\t\t\ttarget=\"${build.target}\" \n\t\t\tcompiler=\"${build.compiler}\" \n\t\t\toptimize=\"${build.optimize}\" \n\t\t\tincludes=\"**/*.java\" \n\t\t\texcludes=\"**/CVS/**,**/.svn/**\" \n\t\t\tencoding=\"GB18030\"\n\t\t\tincludeantruntime=\"false\"\n\t\t\texecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"\n\t\t\tfork=\"yes\">\n\t\t\t<classpath refid=\"classpath\" />\n\t\t</javac>\n\n\t\t<!-- copy src files exclude java file-->\n\t\t<copy todir=\"${build.dest}\" overwrite=\"yes\">\n\t\t\t<fileset dir=\"${build.src}\">\n\t\t\t\t<exclude name=\"**/*.java\" />\n\t\t\t</fileset>\n\t\t</copy>\n\t</target>\n\n\t<target name=\"build-manifests\" depends=\"init,compile-prepare\">\n\t\t<!-- Filtering tokens for JAR manifests-->\n\t\t<filter token=\"source.jdk\" value=\"${build.source}\" />\n\t\t<filter token=\"target.jdk\" value=\"${build.target}\" />\n\t\t<mkdir dir=\"${build.tmp}\" />\n\t\t<copy todir=\"${build.tmp}\" overwrite=\"yes\" filtering=\"yes\" encoding=\"GB18030\">\n\t\t\t<filterset refid=\"version.filters\" />\n\t\t\t<fileset dir=\"src/META-INF\" includes=\"MANIFEST.MF\" />\n\t\t</copy>\n\t</target>\n\n\t<target name=\"package\" depends=\"compile,build-manifests\" description=\"create jar file\">\n\t\t<mkdir dir=\"${build.release}\" />\n\t\t<jar jarfile=\"${build.release}/${final.name}.jar\" manifest=\"${build.tmp}/MANIFEST.MF\" basedir=\"${build.dest}\" includes=\"**\" />\n\t</target>\n\n\t<target name=\"clean\" depends=\"package\">\n\t\t<delete dir=\"${build.src}\" />\n\t\t<delete dir=\"${build.dest}\" />\n\t\t<delete dir=\"${build.tmp}\" />\n\t</target>\n</project>\n\n```\n\n- **build.properties**\n\n```java\n\n# -----------------------------------------------------------------------------\n# build.properties\n#\n# This is an example \"build.properties\" file, used to customize building \n# OSCAR-JDBC for your local environment.  It defines the location of all external\n# modules that OSCAR-JDBC depends on.\n# -----------------------------------------------------------------------------\n\n# ----- Version Control Flags -----\nvesrion.name=Main\nversion.major=1\nversion.minor=0\nversion.revision=0\nversion.suffix=x\nversion.subbuild=001\nversion.buildID=00000000\n\nbuild.source=1.5\nbuild.target=1.5\nbuild.debug=false\nbuild.optimize=true\nbuild.compiler=javac1.5\n\n```","slug":"Ant的使用","published":1,"updated":"2016-08-14T09:06:22.810Z","_id":"cirucnp7a0000jkqcmbrnz0xw","comments":1,"photos":[],"link":"","content":"<blockquote>\n<p>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和<a href=\"http://ant.apache.org/\" target=\"_blank\" rel=\"external\">Ant</a>打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。</p>\n</blockquote>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><p>Ant是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。</p>\n<p><a href=\"http://www.tutorialspoint.com/ant/index.htm\" target=\"_blank\" rel=\"external\">Ant Tutorial</a></p>\n<p><a href=\"http://www.uml.org.cn/j2ee/j2ee091302.htm#content\" target=\"_blank\" rel=\"external\">Ant 实践</a></p>\n<p>另外附上Ant常用命令：</p>\n<p><a href=\"https://ant.apache.org/manual/tasksoverview.html\" target=\"_blank\" rel=\"external\">Overview of Apache Ant Tasks</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>下面是自己写的build.xml。存在这里，以后用到可以参考。</p>\n<p>下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。</p>\n<ul>\n<li><strong>build.xml</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"comment\">&lt;!--</span></div><div class=\"line\">    Oscar XcluseterHibernate Ant build file</div><div class=\"line\">--&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">name</span>=<span class=\"string\">\"OSCAR-XCLUSETER-HIBERNATE\"</span> <span class=\"attr\">default</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\".\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"clean\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"default init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">file</span>=<span class=\"string\">\"build.properties\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Project Properties --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"project\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"oscarXcluseterHibernate3\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"OSCAR HIBERNATE\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"year\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyy\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"builddate\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;$&#123;version.suffix&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.number\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.major.minor\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"final.name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;project&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"vesrion.build\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"build$&#123;builddate&#125; $&#123;version.subbuild&#125; $&#123;version.buildID&#125; for ALL \"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Build Defaults --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"src.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/src\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lib.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/lib\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.home\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.src\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/build\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.dest\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/antClasses\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.release\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/release\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.tmp\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/tmp\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- JAR artifacts --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hiberante3.jar\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;lib.dir&#125;/hibernate3.jar\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Version info filter set --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"DSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"TSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"hhmm\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">id</span>=<span class=\"string\">\"version.filters\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"VERSION_NUMBER\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.number&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_NAME\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.name&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version&#125;$&#123;DSTAMP&#125;$&#123;TSTAMP&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUILD_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.build&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">filterset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"classpath\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">pathelement</span> <span class=\"attr\">location</span>=<span class=\"string\">\"$&#123;hiberante3.jar&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"$&#123;name&#125; Build file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" available targets are:\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   package  --&gt; generates oscarXcluseterHibernate file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   build    --&gt; compiles the source code\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   clean    --&gt; cleans up the directory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" See the comments inside the build.xml file for more details.\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- Just build --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"Prepare for compile\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- create directories --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;src.dir&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"compile the project\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Compiles the source directory  --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">javac</span> <span class=\"attr\">srcdir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> </span></div><div class=\"line\">\t\t\t<span class=\"attr\">destdir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">debug</span>=<span class=\"string\">\"$&#123;build.debug&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">deprecation</span>=<span class=\"string\">\"$&#123;build.deprecation&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">source</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">target</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">compiler</span>=<span class=\"string\">\"$&#123;build.compiler&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">optimize</span>=<span class=\"string\">\"$&#123;build.optimize&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">includes</span>=<span class=\"string\">\"**/*.java\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">excludes</span>=<span class=\"string\">\"**/CVS/**,**/.svn/**\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">includeantruntime</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">executable</span>=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">fork</span>=<span class=\"string\">\"yes\"</span>&gt;</div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">classpath</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"classpath\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">javac</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files exclude java file--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.java\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build-manifests\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init,compile-prepare\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Filtering tokens for JAR manifests--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"source.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"target.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">filtering</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"version.filters\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"src/META-INF\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"MANIFEST.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"package\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile,build-manifests\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"create jar file\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.release&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">jar</span> <span class=\"attr\">jarfile</span>=<span class=\"string\">\"$&#123;build.release&#125;/$&#123;final.name&#125;.jar\"</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"$&#123;build.tmp&#125;/MANIFEST.MF\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"**\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"clean\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"package\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li><strong>build.properties</strong></li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"># build.properties</div><div class=\"line\">#</div><div class=\"line\"># This is an example \"build.properties\" file, used to customize building </div><div class=\"line\"># OSCAR-JDBC for your local environment.  It defines the location of all external</div><div class=\"line\"># modules that OSCAR-JDBC depends on.</div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\"># ----- Version Control Flags -----</div><div class=\"line\">vesrion.name=Main</div><div class=\"line\">version.major=1</div><div class=\"line\">version.minor=0</div><div class=\"line\">version.revision=0</div><div class=\"line\">version.suffix=x</div><div class=\"line\">version.subbuild=001</div><div class=\"line\">version.buildID=00000000</div><div class=\"line\"></div><div class=\"line\">build.source=1.5</div><div class=\"line\">build.target=1.5</div><div class=\"line\">build.debug=false</div><div class=\"line\">build.optimize=true</div><div class=\"line\">build.compiler=javac1.5</div></pre></td></tr></table></figure>","excerpt":"","more":"<blockquote>\n<p>之前写Android的时候一直想学习构建工具Gradle，但一直没有花功夫去研究。由于平时工作中使用的IDE为Eclipse，所以免不了和<a href=\"http://ant.apache.org/\">Ant</a>打交道。今天工作的时候需要自己使用Ant打包一个工程，遂研究一番。</p>\n</blockquote>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><p>Ant是一个很成熟的构建工具了，网上也有许多教程。参考了很多。学习下面两篇教程可以快速上手。</p>\n<p><a href=\"http://www.tutorialspoint.com/ant/index.htm\">Ant Tutorial</a></p>\n<p><a href=\"http://www.uml.org.cn/j2ee/j2ee091302.htm#content\">Ant 实践</a></p>\n<p>另外附上Ant常用命令：</p>\n<p><a href=\"https://ant.apache.org/manual/tasksoverview.html\">Overview of Apache Ant Tasks</a></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>下面是自己写的build.xml。存在这里，以后用到可以参考。</p>\n<p>下面的例子用来编译、打包一个java工程，这个工程是一个Hibernate方言包的开发。该工程还引用到了其他jar包。</p>\n<ul>\n<li><strong>build.xml</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"comment\">&lt;!--</div><div class=\"line\">    Oscar XcluseterHibernate Ant build file</div><div class=\"line\">--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">name</span>=<span class=\"string\">\"OSCAR-XCLUSETER-HIBERNATE\"</span> <span class=\"attr\">default</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\".\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"clean\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"default init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">file</span>=<span class=\"string\">\"build.properties\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Project Properties --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"project\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"oscarXcluseterHibernate3\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"OSCAR HIBERNATE\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"year\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyy\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"builddate\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;$&#123;version.suffix&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.number\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;.$&#123;version.revision&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"version.major.minor\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.major&#125;.$&#123;version.minor&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"final.name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;project&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"vesrion.build\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"build$&#123;builddate&#125; $&#123;version.subbuild&#125; $&#123;version.buildID&#125; for ALL \"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Build Defaults --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"src.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/src\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lib.dir\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/lib\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.home\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.src\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/build\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.dest\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/antClasses\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.release\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/release\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build.tmp\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;basedir&#125;/tmp\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- JAR artifacts --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hiberante3.jar\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;lib.dir&#125;/hibernate3.jar\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Version info filter set --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"DSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"yyyyMMdd\"</span> <span class=\"attr\">locale</span>=<span class=\"string\">\"zh_CN\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">format</span> <span class=\"attr\">property</span>=<span class=\"string\">\"TSTAMP\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"hhmm\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tstamp</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">id</span>=<span class=\"string\">\"version.filters\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"VERSION_NUMBER\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version.number&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_NAME\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.name&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUNDLE_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;version&#125;$&#123;DSTAMP&#125;$&#123;TSTAMP&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"BUILD_VERSION\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;vesrion.build&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">filterset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"classpath\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">pathelement</span> <span class=\"attr\">location</span>=<span class=\"string\">\"$&#123;hiberante3.jar&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"usage\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"$&#123;name&#125; Build file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" available targets are:\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   package  --&gt; generates oscarXcluseterHibernate file\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   build    --&gt; compiles the source code\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"   clean    --&gt; cleans up the directory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\" See the comments inside the build.xml file for more details.\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"-------------------------------------------------------------\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- Just build --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"Prepare for compile\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- create directories --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;src.dir&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"compile\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile-prepare\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"compile the project\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Compiles the source directory  --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">javac</span> <span class=\"attr\">srcdir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">destdir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">debug</span>=<span class=\"string\">\"$&#123;build.debug&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">deprecation</span>=<span class=\"string\">\"$&#123;build.deprecation&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">source</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">target</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">compiler</span>=<span class=\"string\">\"$&#123;build.compiler&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">optimize</span>=<span class=\"string\">\"$&#123;build.optimize&#125;\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">includes</span>=<span class=\"string\">\"**/*.java\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">excludes</span>=<span class=\"string\">\"**/CVS/**,**/.svn/**\"</span> </div><div class=\"line\">\t\t\t<span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">includeantruntime</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">executable</span>=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22\\bin\\javac\"</span></div><div class=\"line\">\t\t\t<span class=\"attr\">fork</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">classpath</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"classpath\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">javac</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- copy src files exclude java file--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">exclude</span> <span class=\"attr\">name</span>=<span class=\"string\">\"**/*.java\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"build-manifests\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"init,compile-prepare\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- Filtering tokens for JAR manifests--&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"source.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.source&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">token</span>=<span class=\"string\">\"target.jdk\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;build.target&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> <span class=\"attr\">overwrite</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">filtering</span>=<span class=\"string\">\"yes\"</span> <span class=\"attr\">encoding</span>=<span class=\"string\">\"GB18030\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">filterset</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"version.filters\"</span> /&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"src/META-INF\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"MANIFEST.MF\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"package\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"compile,build-manifests\"</span> <span class=\"attr\">description</span>=<span class=\"string\">\"create jar file\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mkdir</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.release&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">jar</span> <span class=\"attr\">jarfile</span>=<span class=\"string\">\"$&#123;build.release&#125;/$&#123;final.name&#125;.jar\"</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"$&#123;build.tmp&#125;/MANIFEST.MF\"</span> <span class=\"attr\">basedir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> <span class=\"attr\">includes</span>=<span class=\"string\">\"**\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">target</span> <span class=\"attr\">name</span>=<span class=\"string\">\"clean\"</span> <span class=\"attr\">depends</span>=<span class=\"string\">\"package\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.src&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.dest&#125;\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"$&#123;build.tmp&#125;\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li><strong>build.properties</strong></li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"># build.properties</div><div class=\"line\">#</div><div class=\"line\"># This is an example \"build.properties\" file, used to customize building </div><div class=\"line\"># OSCAR-JDBC for your local environment.  It defines the location of all external</div><div class=\"line\"># modules that OSCAR-JDBC depends on.</div><div class=\"line\"># -----------------------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\"># ----- Version Control Flags -----</div><div class=\"line\">vesrion.name=Main</div><div class=\"line\">version.major=1</div><div class=\"line\">version.minor=0</div><div class=\"line\">version.revision=0</div><div class=\"line\">version.suffix=x</div><div class=\"line\">version.subbuild=001</div><div class=\"line\">version.buildID=00000000</div><div class=\"line\"></div><div class=\"line\">build.source=1.5</div><div class=\"line\">build.target=1.5</div><div class=\"line\">build.debug=false</div><div class=\"line\">build.optimize=true</div><div class=\"line\">build.compiler=javac1.5</div></pre></td></tr></table></figure>"},{"layout":"post","title":"java编程技巧","date":"2016-07-24T04:48:55.000Z","_content":"\n>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~\n\n **1**. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层\n\n **2**. if语句中,判断条件尽量不要使用if(!...)的形式，这样只会使代码更加难以理解\n\n **3**. 循环内不要不断创建对象引用，而应该：\n\n```java\n     Object obj = null;\n     for (int i = 0; i <= count; i++) { \n      obj = new Object(); \n     }\n```\n\n **4**. 不要在循环条件中重复计算变量，比如：\n\n```java\n    for (int i = 0; i <= obj.size(); i++){...}\n```\n\n **5**. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字\n\n **6**. 尽量采用懒加载的策略，即在需要的时候才创建,例如：\n\n```java\n    String str = \"aaa\";\n    if (i == 1) { \n       list.add(str);\n    }\n```\n\n建议替换为：\n\n```java\n\n\tif (i == 1) { \n     String str = \"aaa\"; list.add(str);\n   }\n```\n\n\n **7**. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码\n\n **8**. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能\n\n **9**. 使用&& ,\\|\\| 操作符时，将首先需要满足的条件置于操作符之前。因为&& 和 \\|\\| 具有短路性。另外，体会if(e. key==k\\|\\|k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用\\|\\|将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）\n\n **10**. 尽量用for each语句代替for循环\n\n **11**. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。\n\n **12**. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。\n       \n```java\n    if(\"hello\".equals(variable)){...}\n```\n\n **13**. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：\n\n```java\n    if(string.indexof(character) != -1){...}`\n```\n\n应改为：\n\n```java\n    if(string.indexof(character) >0 ){...}\n```\n\n **14**. 避免意外的赋值，比如：\n \n```java\n    if(variable == 5){...}`\n```\n\n应改为：\n\n```java\n    if(5 == variable){...}\n```\n\n避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出`if(variable = 5)`这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~\n\n **15**. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：\n\n```java\n\tif(array.length > 0){...}\n```\n\n应改为：\n\n```java\n\tif(array != null && array.length > 0){...}\n```\n\n\n **16**. 确保只有一个退出点。比如：\n\n```java\n    private boolean isEligible(int age){\n\n    \tif(age > 18) {\n\n    \t\treturn true;\n\n    \t} else {\n\n            return false;\n    \t}\n\n    }\n```\n\n应改为：\n\n```java\n    private boolean isEligible(int age){\n\n    \tboolean result;\n\n    \tif(age > 18) {\n\n    \t\tresult = true;\n\n    \t} else {\n\n            result = false;\n    \t}\n\n    \treturn result;\n\n    }\n```\n\n **17**. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。\n\n```java\n \tprivate boolean isEligible(final int age){...}\n```\n\n **18**. 把多个if语句组合成单一if语句。比如：\n\n```java\n\tif(age > 18){\n\t\tif(!man){...}\n\t}\n```\n\n应改为：\n\n```java\n\tif(age > 18 && !man){...}\n```\n\n\n","source":"_posts/java_Tips.md","raw":"---\nlayout: post\ntitle: \"java编程技巧\"\ncategories: 编程\ntags: \n- java\ndate:   2016-7-24 12:48:55\n---\n\n>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~\n\n **1**. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层\n\n **2**. if语句中,判断条件尽量不要使用if(!...)的形式，这样只会使代码更加难以理解\n\n **3**. 循环内不要不断创建对象引用，而应该：\n\n```java\n     Object obj = null;\n     for (int i = 0; i <= count; i++) { \n      obj = new Object(); \n     }\n```\n\n **4**. 不要在循环条件中重复计算变量，比如：\n\n```java\n    for (int i = 0; i <= obj.size(); i++){...}\n```\n\n **5**. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字\n\n **6**. 尽量采用懒加载的策略，即在需要的时候才创建,例如：\n\n```java\n    String str = \"aaa\";\n    if (i == 1) { \n       list.add(str);\n    }\n```\n\n建议替换为：\n\n```java\n\n\tif (i == 1) { \n     String str = \"aaa\"; list.add(str);\n   }\n```\n\n\n **7**. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码\n\n **8**. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能\n\n **9**. 使用&& ,\\|\\| 操作符时，将首先需要满足的条件置于操作符之前。因为&& 和 \\|\\| 具有短路性。另外，体会if(e. key==k\\|\\|k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用\\|\\|将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）\n\n **10**. 尽量用for each语句代替for循环\n\n **11**. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。\n\n **12**. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。\n       \n```java\n    if(\"hello\".equals(variable)){...}\n```\n\n **13**. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：\n\n```java\n    if(string.indexof(character) != -1){...}`\n```\n\n应改为：\n\n```java\n    if(string.indexof(character) >0 ){...}\n```\n\n **14**. 避免意外的赋值，比如：\n \n```java\n    if(variable == 5){...}`\n```\n\n应改为：\n\n```java\n    if(5 == variable){...}\n```\n\n避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出`if(variable = 5)`这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~\n\n **15**. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：\n\n```java\n\tif(array.length > 0){...}\n```\n\n应改为：\n\n```java\n\tif(array != null && array.length > 0){...}\n```\n\n\n **16**. 确保只有一个退出点。比如：\n\n```java\n    private boolean isEligible(int age){\n\n    \tif(age > 18) {\n\n    \t\treturn true;\n\n    \t} else {\n\n            return false;\n    \t}\n\n    }\n```\n\n应改为：\n\n```java\n    private boolean isEligible(int age){\n\n    \tboolean result;\n\n    \tif(age > 18) {\n\n    \t\tresult = true;\n\n    \t} else {\n\n            result = false;\n    \t}\n\n    \treturn result;\n\n    }\n```\n\n **17**. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。\n\n```java\n \tprivate boolean isEligible(final int age){...}\n```\n\n **18**. 把多个if语句组合成单一if语句。比如：\n\n```java\n\tif(age > 18){\n\t\tif(!man){...}\n\t}\n```\n\n应改为：\n\n```java\n\tif(age > 18 && !man){...}\n```\n\n\n","slug":"java_Tips","published":1,"updated":"2016-08-14T08:26:27.869Z","comments":1,"photos":[],"link":"","_id":"cirucnp7g0001jkqce1gfyfud","content":"<blockquote>\n<p>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~</p>\n</blockquote>\n<p> <strong>1</strong>. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层</p>\n<p> <strong>2</strong>. if语句中,判断条件尽量不要使用if(!…)的形式，这样只会使代码更加难以理解</p>\n<p> <strong>3</strong>. 循环内不要不断创建对象引用，而应该：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= count; i++) &#123; </div><div class=\"line\"> obj = <span class=\"keyword\">new</span> Object(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>4</strong>. 不要在循环条件中重复计算变量，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= obj.size(); i++)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>5</strong>. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字</p>\n<p> <strong>6</strong>. 尽量采用懒加载的策略，即在需要的时候才创建,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str = <span class=\"string\">\"aaa\"</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">   list.add(str);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>建议替换为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">    String str = <span class=\"string\">\"aaa\"</span>; list.add(str);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p> <strong>7</strong>. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码</p>\n<p> <strong>8</strong>. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能</p>\n<p> <strong>9</strong>. 使用&amp;&amp; ,|| 操作符时，将首先需要满足的条件置于操作符之前。因为&amp;&amp; 和 || 具有短路性。另外，体会if(e. key==k||k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用||将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）</p>\n<p> <strong>10</strong>. 尽量用for each语句代替for循环</p>\n<p> <strong>11</strong>. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。</p>\n<p> <strong>12</strong>. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">\"hello\"</span>.equals(variable))&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>13</strong>. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) != -<span class=\"number\">1</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) &gt;<span class=\"number\">0</span> )&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>14</strong>. 避免意外的赋值，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(variable == <span class=\"number\">5</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">5</span> == variable)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出<code>if(variable = 5)</code>这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~</p>\n<p> <strong>15</strong>. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array != <span class=\"keyword\">null</span> &amp;&amp; array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>16</strong>. 确保只有一个退出点。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">boolean</span> result;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tresult = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        result = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>17</strong>. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>18</strong>. 把多个if语句组合成单一if语句。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>)&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(!man)&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span> &amp;&amp; !man)&#123;...&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<blockquote>\n<p>突然想到把自己平时用到的，网上看到的java编程过程中的小技巧总结下来~~</p>\n</blockquote>\n<p> <strong>1</strong>. 循环中尽量不要使用try..catch 代码块，应该将其放在最外层</p>\n<p> <strong>2</strong>. if语句中,判断条件尽量不要使用if(!…)的形式，这样只会使代码更加难以理解</p>\n<p> <strong>3</strong>. 循环内不要不断创建对象引用，而应该：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= count; i++) &#123; </div><div class=\"line\"> obj = <span class=\"keyword\">new</span> Object(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>4</strong>. 不要在循环条件中重复计算变量，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= obj.size(); i++)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>5</strong>. 避免使用”魔术数字”,所有的数字值都应该赋予一个有意义的变量，使用这个变量，而不是数字</p>\n<p> <strong>6</strong>. 尽量采用懒加载的策略，即在需要的时候才创建,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str = <span class=\"string\">\"aaa\"</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">   list.add(str);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>建议替换为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; </div><div class=\"line\">    String str = <span class=\"string\">\"aaa\"</span>; list.add(str);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p> <strong>7</strong>. 使用同步代码块替代同步方法,同步代码块里只放需要同步的代码</p>\n<p> <strong>8</strong>. 乘(除)2或者2的倍数时，尽量选择移位操作，提高性能</p>\n<p> <strong>9</strong>. 使用&amp;&amp; ,|| 操作符时，将首先需要满足的条件置于操作符之前。因为&amp;&amp; 和 || 具有短路性。另外，体会if(e. key==k||k.equals(e.key)) 的细节。判断条件的目的是要求满足k.equals(e.key)。用||将（e.key==k）与 k.equals(e.key)连接起来，在性能上有更好的表现。（HashMap源码）</p>\n<p> <strong>10</strong>. 尽量用for each语句代替for循环</p>\n<p> <strong>11</strong>. 在java中小数类型默认为double,若对精度没有很高要求，应该显示的声明为float.如 3.14f。</p>\n<p> <strong>12</strong>. 调用equals()函数时(或其他类似函数)，将string字符串放在左边进行比较，防止空指针异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">\"hello\"</span>.equals(variable))&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>13</strong>. 在使用一些通过返回int判断状态的函数时，不要相信-1。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) != -<span class=\"number\">1</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(string.indexof(character) &gt;<span class=\"number\">0</span> )&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>14</strong>. 避免意外的赋值，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(variable == <span class=\"number\">5</span>)&#123;...&#125;`</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">5</span> == variable)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>避免不小心将5赋给variable。但是在我使用jdk1.7的时候，倘如你在条件判断语句中写出<code>if(variable = 5)</code>这样的句子，编译器会自动报警。不过，养成好的编程习惯总是没有错的~</p>\n<p> <strong>15</strong>. 检查NULL。在调用集合或者数组的成员函数时，请确保他已经存在，而不是NULL。这是我编程时很容易犯的错误。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(array != <span class=\"keyword\">null</span> &amp;&amp; array.length &gt; <span class=\"number\">0</span>)&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>16</strong>. 确保只有一个退出点。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">boolean</span> result;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tresult = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        result = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>17</strong>. 以final类型标记方法参数。当你不小心修改参数值时，编译器会报警。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEligible</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p> <strong>18</strong>. 把多个if语句组合成单一if语句。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span>)&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(!man)&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>应改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(age &gt; <span class=\"number\">18</span> &amp;&amp; !man)&#123;...&#125;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"ANT编译java工程经jdk路径的设置","date":"2016-04-25T04:48:55.000Z","_content":"\n> 今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。\n\n打包过程中总是报：\n\n```java\n[javac] 警告: [options] 未与 -source 1.5 一起设置引导类路径\n[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:50: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()\n[javac] public class Driver implements java.sql.Driver {\n....\n```\n\n类似这样的一堆错误。\n\n没有过多的思考，百度之...出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。\n\n严重的浪费时间和影响心情，遂放弃。\n\n静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。\n\n后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。\n\n重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。\n\n等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’\n\n果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加\n\n```java\nexecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"\nfork=\"yes\"\n```\n\nBuild Successfull.\n\n这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：\n\n1.不要用百度\n\n2.先思考问题原因，再寻找解决方案\n\n3.学习英语，尽量用英文搜索\n\n## 参考\n\n[Change JDK for running <ANT> task from within build xml](http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml)\n\n\n","source":"_posts/ant编译java工程jdk路径的设置.md","raw":"---\nlayout: post\ntitle:  \"ANT编译java工程经jdk路径的设置\"\ncategories: 工具\ntags: \n- java\n- ant\ndate:   2016-04-25 12:48:55\n---\n\n> 今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。\n\n打包过程中总是报：\n\n```java\n[javac] 警告: [options] 未与 -source 1.5 一起设置引导类路径\n[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:50: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()\n[javac] public class Driver implements java.sql.Driver {\n....\n```\n\n类似这样的一堆错误。\n\n没有过多的思考，百度之...出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。\n\n严重的浪费时间和影响心情，遂放弃。\n\n静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。\n\n后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。\n\n重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。\n\n等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’\n\n果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加\n\n```java\nexecutable=\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"\nfork=\"yes\"\n```\n\nBuild Successfull.\n\n这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：\n\n1.不要用百度\n\n2.先思考问题原因，再寻找解决方案\n\n3.学习英语，尽量用英文搜索\n\n## 参考\n\n[Change JDK for running <ANT> task from within build xml](http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml)\n\n\n","slug":"ant编译java工程jdk路径的设置","published":1,"updated":"2016-08-14T08:26:27.863Z","comments":1,"photos":[],"link":"","_id":"cirucnp7q0004jkqc36e1eqog","content":"<blockquote>\n<p>今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。</p>\n</blockquote>\n<p>打包过程中总是报：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[javac] 警告: [options] 未与 -source <span class=\"number\">1.5</span> 一起设置引导类路径</div><div class=\"line\">[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:<span class=\"number\">50</span>: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()</div><div class=\"line\">[javac] <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>类似这样的一堆错误。</p>\n<p>没有过多的思考，百度之…出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。</p>\n<p>严重的浪费时间和影响心情，遂放弃。</p>\n<p>静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。</p>\n<p>后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。</p>\n<p>重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。</p>\n<p>等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’</p>\n<p>果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">executable=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"</span></div><div class=\"line\">fork=<span class=\"string\">\"yes\"</span></div></pre></td></tr></table></figure>\n<p>Build Successfull.</p>\n<p>这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：</p>\n<p>1.不要用百度</p>\n<p>2.先思考问题原因，再寻找解决方案</p>\n<p>3.学习英语，尽量用英文搜索</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml\" target=\"_blank\" rel=\"external\">Change JDK for running <ant> task from within build xml</ant></a></p>\n","excerpt":"","more":"<blockquote>\n<p>今天工作的时候涉及到使用ant对项目进行编译，打包。此前只知道ant是一个构建工具（当然，现在也是），也基本上没有接触过。但是build.xml是从仓库下载的已经配置好的文件。本来想着只要在eclipse轻轻一点Ant Build 就万事大吉，但是这个打包却折腾了我两个小时。</p>\n</blockquote>\n<p>打包过程中总是报：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[javac] 警告: [options] 未与 -source <span class=\"number\">1.5</span> 一起设置引导类路径</div><div class=\"line\">[javac] E:\\doc\\oscartools\\driver\\oscarJavaDriver\\jdbc\\V1.0\\build\\com\\oscar\\Driver.java:<span class=\"number\">50</span>: 错误: com.oscar.Driver不是抽象的, 并且未覆盖java.sql.Driver中的抽象方法getParentLogger()</div><div class=\"line\">[javac] <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>类似这样的一堆错误。</p>\n<p>没有过多的思考，百度之…出现了一堆没用的资料和争论。80%的时间花在了看这些人扯淡上面（或许正真的大神并不关注这些问题）。</p>\n<p>严重的浪费时间和影响心情，遂放弃。</p>\n<p>静下来想想，工程的java build path使用1.5，java compiler 使用1.5，没什么问题啊。。。</p>\n<p>后来灵光一现，build.xml中的javac难道与java home有关（原谅我现在才想到）？java home使用jdk为1.7，遂改为1.5。</p>\n<p>重启eclipse，悲催，eclipse要求jdk必须大于等于1.7。</p>\n<p>等等，如果不同的工程依赖不同的jdk的话，修改java home并不是一个明智的解决方案，一定可以针对某个工程修改它所依赖的javac，谷歌之 ‘ant set java_home in build.xml’</p>\n<p>果然，stackoverflow拯救了我，只需要在build.xml文件中javac标签下添加</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">executable=<span class=\"string\">\"C:\\Program Files\\Java\\jdk1.5.0_22/bin/javac\"</span></div><div class=\"line\">fork=<span class=\"string\">\"yes\"</span></div></pre></td></tr></table></figure>\n<p>Build Successfull.</p>\n<p>这次的总结并不是为了学习ant(有学习Gradle的计划)，只是从这次解决问题的过程中，学会了：</p>\n<p>1.不要用百度</p>\n<p>2.先思考问题原因，再寻找解决方案</p>\n<p>3.学习英语，尽量用英文搜索</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://stackoverflow.com/questions/17594075/change-jdk-for-running-ant-task-from-within-build-xml\">Change JDK for running <ANT> task from within build xml</a></p>\n"},{"layout":"post","title":"java中的equals与hashcode","date":"2016-04-28T04:48:55.000Z","_content":"\n>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。\n\n## 什么是hashcode,hashcode的作用是什么\n\nhashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。\n\n理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，也就是记录所在的位置。\n\n按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。\n\nhashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。\n\n注：以下代码均来自jdk1.7\n\nString中hashCode()方法的实现：\n\n```java\npublic int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            char val[] = value;\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n}\n```\n\n## 什么是equals(Object obj)方法\n\nequals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：\n\n```java\npublic boolean equals(Object obj) {\n        return (this == obj);\n}\n```\n\n也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。\n\n这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。\n\nString中equals(Object obj)方法的实现：\n\n```java\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String) anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                            return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n}\n```\n\n## 在java中hashcode方法与equals方法的作用\n\n首先看一下HashMap中的put方法：\n\n```java\npublic V put(K key, V value) {\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n        if (key == null)\n            return putForNullKey(value);\n        int hash = hash(key);//得到hash值\n        int i = indexFor(hash, table.length);//找到槽\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n\n        modCount++;\n        addEntry(hash, key, value, i);\n        return null;\n    }\n\n```\n\n我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。\n\n首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：\n\n```java\nfinal int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n可以看到，这个方法里调用了key本身的hashCode方法，得到了他的hashcode，然后对该hashcode进行了一些操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，他指向了记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？其实这跟记录在散列表中的存放方式有关系(HashMap底层存储就是一个散列表数组),有兴趣可以看看[这个](https://www.zhihu.com/question/20733617)\n\n接下来，int i = indexFor(hash, table.length);找到所谓的槽，也就是记录存在的位置。\n\n要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。\n\n散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？反过来说，能否给出一个散列函数，其可以保证对于所有调用它的对象都可以返回一个唯一的hashcode？恐怕这是很难做到的吧。此时就会产生冲突。从另一个角度来讲，我们的散列表长度是有限的，有用这有限的空间存储更多的记录，势必会产生冲突。这也是我们理解hashcode的一个重要的点：**不同的对象(equals返回false)可以有相同的hashcode**。\n\n那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：\n\n<img src=\"/assets/images/entry.png\" width=\"600\" height=\"400\"  /> \n\n其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3....为散列表的索引位置。\n\n接下来的代码  `for (Entry<K,V> e = table[i]; e != null; e = e.next)`就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：`addEntry(hash, key, value, i);`.\n\n那么，怎么判断两个关键码在逻辑上是否相同呢？\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`\n\n可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：e.hash == hash 。为什么要加这样的判断我们之前也提到了，那就是冲突造成同一个槽里有不同的对象存在，这些对象的hashcode可能相同，也可能不同(hashcode经过取模运算散列到同一个位置)。我们知道**不同的对象(equals返回false)可以有相同的hashcode**。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：**相同的对象(equals返回true)hashcode一定相等**。\n\n`e.hash == hash && ((k = e.key) == key`这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断**关键码是否相等**，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。\n\n`key.equals(k)`：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`这句代码中其实包含了一种短路思想，\\|\\| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。\n\n至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。\n\n## 总结\n\n通过上面的分析，我们知道了hashcode与equals的几个关键：\n\n#### 1.**不同的对象(equals返回false)可以有相同的hashcode**\n\n#### 2.**相同的对象(equals返回true)hashcode一定相等**\n\n#### 3.**若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义**（对1、2的遵守）\n\n[关于如何重写equals方法与hashCode方法](http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java)\n\n## equals与==\n\n\"==\" 比较的是两个对象的内存地址，是物理意义上的相等\n\nequals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等\n\n两个对象进行比较：\n\n**== 返回true，则equals一定返回true**；\n\n**equals返回true，== 不一定返回true**。\n\n\n\n\n\n\n\n","source":"_posts/java中的equals与hashcode.md","raw":"---\nlayout: post\ntitle:  \"java中的equals与hashcode\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-28 12:48:55\n---\n\n>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。\n\n## 什么是hashcode,hashcode的作用是什么\n\nhashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。\n\n理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，也就是记录所在的位置。\n\n按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。\n\nhashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。\n\n注：以下代码均来自jdk1.7\n\nString中hashCode()方法的实现：\n\n```java\npublic int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            char val[] = value;\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n}\n```\n\n## 什么是equals(Object obj)方法\n\nequals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：\n\n```java\npublic boolean equals(Object obj) {\n        return (this == obj);\n}\n```\n\n也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。\n\n这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。\n\nString中equals(Object obj)方法的实现：\n\n```java\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String) anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                            return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n}\n```\n\n## 在java中hashcode方法与equals方法的作用\n\n首先看一下HashMap中的put方法：\n\n```java\npublic V put(K key, V value) {\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n        if (key == null)\n            return putForNullKey(value);\n        int hash = hash(key);//得到hash值\n        int i = indexFor(hash, table.length);//找到槽\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n\n        modCount++;\n        addEntry(hash, key, value, i);\n        return null;\n    }\n\n```\n\n我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。\n\n首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：\n\n```java\nfinal int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n可以看到，这个方法里调用了key本身的hashCode方法，得到了他的hashcode，然后对该hashcode进行了一些操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，他指向了记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？其实这跟记录在散列表中的存放方式有关系(HashMap底层存储就是一个散列表数组),有兴趣可以看看[这个](https://www.zhihu.com/question/20733617)\n\n接下来，int i = indexFor(hash, table.length);找到所谓的槽，也就是记录存在的位置。\n\n要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。\n\n散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？反过来说，能否给出一个散列函数，其可以保证对于所有调用它的对象都可以返回一个唯一的hashcode？恐怕这是很难做到的吧。此时就会产生冲突。从另一个角度来讲，我们的散列表长度是有限的，有用这有限的空间存储更多的记录，势必会产生冲突。这也是我们理解hashcode的一个重要的点：**不同的对象(equals返回false)可以有相同的hashcode**。\n\n那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：\n\n<img src=\"/assets/images/entry.png\" width=\"600\" height=\"400\"  /> \n\n其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3....为散列表的索引位置。\n\n接下来的代码  `for (Entry<K,V> e = table[i]; e != null; e = e.next)`就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：`addEntry(hash, key, value, i);`.\n\n那么，怎么判断两个关键码在逻辑上是否相同呢？\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`\n\n可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：e.hash == hash 。为什么要加这样的判断我们之前也提到了，那就是冲突造成同一个槽里有不同的对象存在，这些对象的hashcode可能相同，也可能不同(hashcode经过取模运算散列到同一个位置)。我们知道**不同的对象(equals返回false)可以有相同的hashcode**。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：**相同的对象(equals返回true)hashcode一定相等**。\n\n`e.hash == hash && ((k = e.key) == key`这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断**关键码是否相等**，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。\n\n`key.equals(k)`：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。\n\n`if (e.hash == hash && ((k = e.key) == key || key.equals(k)))`这句代码中其实包含了一种短路思想，\\|\\| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。\n\n至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。\n\n## 总结\n\n通过上面的分析，我们知道了hashcode与equals的几个关键：\n\n#### 1.**不同的对象(equals返回false)可以有相同的hashcode**\n\n#### 2.**相同的对象(equals返回true)hashcode一定相等**\n\n#### 3.**若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义**（对1、2的遵守）\n\n[关于如何重写equals方法与hashCode方法](http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java)\n\n## equals与==\n\n\"==\" 比较的是两个对象的内存地址，是物理意义上的相等\n\nequals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等\n\n两个对象进行比较：\n\n**== 返回true，则equals一定返回true**；\n\n**equals返回true，== 不一定返回true**。\n\n\n\n\n\n\n\n","slug":"java中的equals与hashcode","published":1,"updated":"2016-08-14T09:11:45.221Z","_id":"cirucnp7v0005jkqcrel5dfk6","comments":1,"photos":[],"link":"","content":"<blockquote>\n<p>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。</p>\n</blockquote>\n<h2 id=\"什么是hashcode-hashcode的作用是什么\"><a href=\"#什么是hashcode-hashcode的作用是什么\" class=\"headerlink\" title=\"什么是hashcode,hashcode的作用是什么\"></a>什么是hashcode,hashcode的作用是什么</h2><p>hashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。</p>\n<p>理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，也就是记录所在的位置。</p>\n<p>按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。</p>\n<p>hashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。</p>\n<p>注：以下代码均来自jdk1.7</p>\n<p>String中hashCode()方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hash;</div><div class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">char</span> val[] = value;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</div><div class=\"line\">                h = <span class=\"number\">31</span> * h + val[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            hash = h;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> h;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"什么是equals-Object-obj-方法\"><a href=\"#什么是equals-Object-obj-方法\" class=\"headerlink\" title=\"什么是equals(Object obj)方法\"></a>什么是equals(Object obj)方法</h2><p>equals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。</p>\n<p>这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。</p>\n<p>String中equals(Object obj)方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            String anotherString = (String) anObject;</div><div class=\"line\">            <span class=\"keyword\">int</span> n = value.length;</div><div class=\"line\">            <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> v1[] = value;</div><div class=\"line\">                <span class=\"keyword\">char</span> v2[] = anotherString.value;</div><div class=\"line\">                <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (v1[i] != v2[i])</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                    i++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"在java中hashcode方法与equals方法的作用\"><a href=\"#在java中hashcode方法与equals方法的作用\" class=\"headerlink\" title=\"在java中hashcode方法与equals方法的作用\"></a>在java中hashcode方法与equals方法的作用</h2><p>首先看一下HashMap中的put方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</div><div class=\"line\">            inflateTable(threshold);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> putForNullKey(value);</div><div class=\"line\">        <span class=\"keyword\">int</span> hash = hash(key);<span class=\"comment\">//得到hash值</span></div><div class=\"line\">        <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//找到槽</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\">            Object k;</div><div class=\"line\">            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class=\"line\">                V oldValue = e.value;</div><div class=\"line\">                e.value = value;</div><div class=\"line\">                e.recordAccess(<span class=\"keyword\">this</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        modCount++;</div><div class=\"line\">        addEntry(hash, key, value, i);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。</p>\n<p>首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hashSeed;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != h &amp;&amp; k <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        h ^= k.hashCode();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></div><div class=\"line\">        <span class=\"comment\">// constant multiples at each bit position have a bounded</span></div><div class=\"line\">        <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></div><div class=\"line\">        h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这个方法里调用了key本身的hashCode方法，得到了他的hashcode，然后对该hashcode进行了一些操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，他指向了记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？其实这跟记录在散列表中的存放方式有关系(HashMap底层存储就是一个散列表数组),有兴趣可以看看<a href=\"https://www.zhihu.com/question/20733617\" target=\"_blank\" rel=\"external\">这个</a></p>\n<p>接下来，int i = indexFor(hash, table.length);找到所谓的槽，也就是记录存在的位置。</p>\n<p>要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。</p>\n<p>散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？反过来说，能否给出一个散列函数，其可以保证对于所有调用它的对象都可以返回一个唯一的hashcode？恐怕这是很难做到的吧。此时就会产生冲突。从另一个角度来讲，我们的散列表长度是有限的，有用这有限的空间存储更多的记录，势必会产生冲突。这也是我们理解hashcode的一个重要的点：<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。</p>\n<p>那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：</p>\n<p><img src=\"/assets/images/entry.png\" width=\"600\" height=\"400\"> </p>\n<p>其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3….为散列表的索引位置。</p>\n<p>接下来的代码  <code>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next)</code>就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：<code>addEntry(hash, key, value, i);</code>.</p>\n<p>那么，怎么判断两个关键码在逻辑上是否相同呢？</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code></p>\n<p>可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：e.hash == hash 。为什么要加这样的判断我们之前也提到了，那就是冲突造成同一个槽里有不同的对象存在，这些对象的hashcode可能相同，也可能不同(hashcode经过取模运算散列到同一个位置)。我们知道<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：<strong>相同的对象(equals返回true)hashcode一定相等</strong>。</p>\n<p><code>e.hash == hash &amp;&amp; ((k = e.key) == key</code>这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断<strong>关键码是否相等</strong>，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。</p>\n<p><code>key.equals(k)</code>：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>这句代码中其实包含了一种短路思想，|| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。</p>\n<p>至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面的分析，我们知道了hashcode与equals的几个关键：</p>\n<h4 id=\"1-不同的对象-equals返回false-可以有相同的hashcode\"><a href=\"#1-不同的对象-equals返回false-可以有相同的hashcode\" class=\"headerlink\" title=\"1.不同的对象(equals返回false)可以有相同的hashcode\"></a>1.<strong>不同的对象(equals返回false)可以有相同的hashcode</strong></h4><h4 id=\"2-相同的对象-equals返回true-hashcode一定相等\"><a href=\"#2-相同的对象-equals返回true-hashcode一定相等\" class=\"headerlink\" title=\"2.相同的对象(equals返回true)hashcode一定相等\"></a>2.<strong>相同的对象(equals返回true)hashcode一定相等</strong></h4><h4 id=\"3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"><a href=\"#3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\" class=\"headerlink\" title=\"3.若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"></a>3.<strong>若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义</strong>（对1、2的遵守）</h4><p><a href=\"http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java\" target=\"_blank\" rel=\"external\">关于如何重写equals方法与hashCode方法</a></p>\n<h2 id=\"equals与\"><a href=\"#equals与\" class=\"headerlink\" title=\"equals与==\"></a>equals与==</h2><p>“==” 比较的是两个对象的内存地址，是物理意义上的相等</p>\n<p>equals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等</p>\n<p>两个对象进行比较：</p>\n<p><strong>== 返回true，则equals一定返回true</strong>；</p>\n<p><strong>equals返回true，== 不一定返回true</strong>。</p>\n","excerpt":"","more":"<blockquote>\n<p>最近读了HashMap的源码，对HashCode与equals有了一定的了解，总结一下，顺便理一下HashMap中的核心算法。</p>\n</blockquote>\n<h2 id=\"什么是hashcode-hashcode的作用是什么\"><a href=\"#什么是hashcode-hashcode的作用是什么\" class=\"headerlink\" title=\"什么是hashcode,hashcode的作用是什么\"></a>什么是hashcode,hashcode的作用是什么</h2><p>hashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。</p>\n<p>理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，也就是记录所在的位置。</p>\n<p>按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。</p>\n<p>hashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。</p>\n<p>注：以下代码均来自jdk1.7</p>\n<p>String中hashCode()方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hash;</div><div class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">char</span> val[] = value;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</div><div class=\"line\">                h = <span class=\"number\">31</span> * h + val[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            hash = h;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> h;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"什么是equals-Object-obj-方法\"><a href=\"#什么是equals-Object-obj-方法\" class=\"headerlink\" title=\"什么是equals(Object obj)方法\"></a>什么是equals(Object obj)方法</h2><p>equals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。</p>\n<p>这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。</p>\n<p>String中equals(Object obj)方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            String anotherString = (String) anObject;</div><div class=\"line\">            <span class=\"keyword\">int</span> n = value.length;</div><div class=\"line\">            <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> v1[] = value;</div><div class=\"line\">                <span class=\"keyword\">char</span> v2[] = anotherString.value;</div><div class=\"line\">                <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (v1[i] != v2[i])</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                    i++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"在java中hashcode方法与equals方法的作用\"><a href=\"#在java中hashcode方法与equals方法的作用\" class=\"headerlink\" title=\"在java中hashcode方法与equals方法的作用\"></a>在java中hashcode方法与equals方法的作用</h2><p>首先看一下HashMap中的put方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</div><div class=\"line\">            inflateTable(threshold);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> putForNullKey(value);</div><div class=\"line\">        <span class=\"keyword\">int</span> hash = hash(key);<span class=\"comment\">//得到hash值</span></div><div class=\"line\">        <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//找到槽</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\">            Object k;</div><div class=\"line\">            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class=\"line\">                V oldValue = e.value;</div><div class=\"line\">                e.value = value;</div><div class=\"line\">                e.recordAccess(<span class=\"keyword\">this</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        modCount++;</div><div class=\"line\">        addEntry(hash, key, value, i);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。</p>\n<p>首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> h = hashSeed;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != h &amp;&amp; k <span class=\"keyword\">instanceof</span> String) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        h ^= k.hashCode();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></div><div class=\"line\">        <span class=\"comment\">// constant multiples at each bit position have a bounded</span></div><div class=\"line\">        <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></div><div class=\"line\">        h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这个方法里调用了key本身的hashCode方法，得到了他的hashcode，然后对该hashcode进行了一些操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，他指向了记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？其实这跟记录在散列表中的存放方式有关系(HashMap底层存储就是一个散列表数组),有兴趣可以看看<a href=\"https://www.zhihu.com/question/20733617\">这个</a></p>\n<p>接下来，int i = indexFor(hash, table.length);找到所谓的槽，也就是记录存在的位置。</p>\n<p>要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。</p>\n<p>散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？反过来说，能否给出一个散列函数，其可以保证对于所有调用它的对象都可以返回一个唯一的hashcode？恐怕这是很难做到的吧。此时就会产生冲突。从另一个角度来讲，我们的散列表长度是有限的，有用这有限的空间存储更多的记录，势必会产生冲突。这也是我们理解hashcode的一个重要的点：<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。</p>\n<p>那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：</p>\n<p><img src=\"/assets/images/entry.png\" width=\"600\" height=\"400\"  /> </p>\n<p>其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3….为散列表的索引位置。</p>\n<p>接下来的代码  <code>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next)</code>就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：<code>addEntry(hash, key, value, i);</code>.</p>\n<p>那么，怎么判断两个关键码在逻辑上是否相同呢？</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code></p>\n<p>可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：e.hash == hash 。为什么要加这样的判断我们之前也提到了，那就是冲突造成同一个槽里有不同的对象存在，这些对象的hashcode可能相同，也可能不同(hashcode经过取模运算散列到同一个位置)。我们知道<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：<strong>相同的对象(equals返回true)hashcode一定相等</strong>。</p>\n<p><code>e.hash == hash &amp;&amp; ((k = e.key) == key</code>这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断<strong>关键码是否相等</strong>，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。</p>\n<p><code>key.equals(k)</code>：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。</p>\n<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>这句代码中其实包含了一种短路思想，|| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。</p>\n<p>至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面的分析，我们知道了hashcode与equals的几个关键：</p>\n<h4 id=\"1-不同的对象-equals返回false-可以有相同的hashcode\"><a href=\"#1-不同的对象-equals返回false-可以有相同的hashcode\" class=\"headerlink\" title=\"1.不同的对象(equals返回false)可以有相同的hashcode\"></a>1.<strong>不同的对象(equals返回false)可以有相同的hashcode</strong></h4><h4 id=\"2-相同的对象-equals返回true-hashcode一定相等\"><a href=\"#2-相同的对象-equals返回true-hashcode一定相等\" class=\"headerlink\" title=\"2.相同的对象(equals返回true)hashcode一定相等\"></a>2.<strong>相同的对象(equals返回true)hashcode一定相等</strong></h4><h4 id=\"3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"><a href=\"#3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\" class=\"headerlink\" title=\"3.若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）\"></a>3.<strong>若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义</strong>（对1、2的遵守）</h4><p><a href=\"http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java\">关于如何重写equals方法与hashCode方法</a></p>\n<h2 id=\"equals与\"><a href=\"#equals与\" class=\"headerlink\" title=\"equals与==\"></a>equals与==</h2><p>“==” 比较的是两个对象的内存地址，是物理意义上的相等</p>\n<p>equals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等</p>\n<p>两个对象进行比较：</p>\n<p><strong>== 返回true，则equals一定返回true</strong>；</p>\n<p><strong>equals返回true，== 不一定返回true</strong>。</p>\n"},{"layout":"post","title":"java中的ThreadLocal","date":"2016-06-21T04:48:55.000Z","_content":"\n> 今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal...\n\n## **问题背景**：\n\n每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：\n\n```java\nLsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());\n```\n\n其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。\n\n遂改之：\n\n```java\nLsnVo lv = ((DispatchConnection) conn).getLsnVo();\n```\n\n将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。\n\n曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。\n\n后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！\n\nPS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29\n\nso,按照上面的改法问题解决了。\n\n那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。\n\n这就是ThreadLocal的一个典型应用场景。\n\n## **ThreadLocal原理**：\n\n使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。\n\nThreadLocal的set和get方法：\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n}\n\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            return (T)map.get(this);\n\n        // Maps are constructed lazily.  if the map for this thread\n        // doesn't exist, create it, with this ThreadLocal and its\n        // initial value as its only entry.\n        T value = initialValue();\n        createMap(t, value);\n        return value;\n}\n```\n\n可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。\n\n很容易明白他的工作原理。\n\n## **应用场景**\n\n之前看了网上很多资料说ThreadLocal的应用场景：\n\n1.解决了多线程共享对象的问题，\n\n2.实现线程间的数据隔离，每个线程都有他自己的变量副本。\n\n对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。\n\n对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。\n\n我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：\n\n1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。\n\n2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。\n\n所以，使用ThreadLocal的场景应该是这样：**这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。**\n\nPS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。\n\n另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。\n\n我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。\n","source":"_posts/java中的ThreadLocal.md","raw":"---\nlayout: post\ntitle:  \"java中的ThreadLocal\"\ncategories: 编程\ntags: \n- java\n- 多线程\ndate:   2016-06-21 12:48:55\n---\n\n> 今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal...\n\n## **问题背景**：\n\n每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：\n\n```java\nLsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());\n```\n\n其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。\n\n遂改之：\n\n```java\nLsnVo lv = ((DispatchConnection) conn).getLsnVo();\n```\n\n将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。\n\n曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。\n\n后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！\n\nPS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29\n\nso,按照上面的改法问题解决了。\n\n那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。\n\n这就是ThreadLocal的一个典型应用场景。\n\n## **ThreadLocal原理**：\n\n使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。\n\nThreadLocal的set和get方法：\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n}\n\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            return (T)map.get(this);\n\n        // Maps are constructed lazily.  if the map for this thread\n        // doesn't exist, create it, with this ThreadLocal and its\n        // initial value as its only entry.\n        T value = initialValue();\n        createMap(t, value);\n        return value;\n}\n```\n\n可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。\n\n很容易明白他的工作原理。\n\n## **应用场景**\n\n之前看了网上很多资料说ThreadLocal的应用场景：\n\n1.解决了多线程共享对象的问题，\n\n2.实现线程间的数据隔离，每个线程都有他自己的变量副本。\n\n对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。\n\n对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。\n\n我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：\n\n1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。\n\n2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。\n\n所以，使用ThreadLocal的场景应该是这样：**这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。**\n\nPS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。\n\n另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。\n\n我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。\n","slug":"java中的ThreadLocal","published":1,"updated":"2016-08-14T08:26:27.877Z","comments":1,"photos":[],"link":"","_id":"cirucnp800007jkqc5ecknap6","content":"<blockquote>\n<p>今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal…</p>\n</blockquote>\n<h2 id=\"问题背景：\"><a href=\"#问题背景：\" class=\"headerlink\" title=\"问题背景：\"></a><strong>问题背景</strong>：</h2><p>每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());</div></pre></td></tr></table></figure>\n<p>其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。</p>\n<p>遂改之：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((DispatchConnection) conn).getLsnVo();</div></pre></td></tr></table></figure>\n<p>将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。</p>\n<p>曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。</p>\n<p>后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！</p>\n<p>PS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29</p>\n<p>so,按照上面的改法问题解决了。</p>\n<p>那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。</p>\n<p>这就是ThreadLocal的一个典型应用场景。</p>\n<h2 id=\"ThreadLocal原理：\"><a href=\"#ThreadLocal原理：\" class=\"headerlink\" title=\"ThreadLocal原理：\"></a><strong>ThreadLocal原理</strong>：</h2><p>使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。</p>\n<p>ThreadLocal的set和get方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> (T)map.get(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Maps are constructed lazily.  if the map for this thread</span></div><div class=\"line\">        <span class=\"comment\">// doesn't exist, create it, with this ThreadLocal and its</span></div><div class=\"line\">        <span class=\"comment\">// initial value as its only entry.</span></div><div class=\"line\">        T value = initialValue();</div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。</p>\n<p>很容易明白他的工作原理。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h2><p>之前看了网上很多资料说ThreadLocal的应用场景：</p>\n<p>1.解决了多线程共享对象的问题，</p>\n<p>2.实现线程间的数据隔离，每个线程都有他自己的变量副本。</p>\n<p>对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。</p>\n<p>对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。</p>\n<p>我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：</p>\n<p>1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。</p>\n<p>2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。</p>\n<p>所以，使用ThreadLocal的场景应该是这样：<strong>这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。</strong></p>\n<p>PS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。</p>\n<p>另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。</p>\n<p>我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。</p>\n","excerpt":"","more":"<blockquote>\n<p>今天测试那边在做压力测试的时候，发现新版本的Jdbc占用CPU很高，导致并发量降低，研究半天，发现出问题的地方在于每条语句执行过后都会调用ThreadLocal的get方法。研究一番ThreadLocal…</p>\n</blockquote>\n<h2 id=\"问题背景：\"><a href=\"#问题背景：\" class=\"headerlink\" title=\"问题背景：\"></a><strong>问题背景</strong>：</h2><p>每次sql语句执行结束之后，最后都会接受后台传回的ReadyForQueryPacket包，标记语句执行完毕。在新版本的协议当中，针对读写分离的功能，在这个包中增加了一些要接收的数据：标记数据库主机状态的lsn。这个lsn标志着主备机之间的数据是否存在差异。每次执行完sql语句之后，都要将数据库后台传回来的lsn与当前主机的lsn进行比较，从而决定下一步的读写过程。每次取本机的lsn操作长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((LsnVo)DispatchConnection.threadLocalLsn.get());</div></pre></td></tr></table></figure>\n<p>其中，threadLocalLsn是DispatchConnection中的一个ThreadLocal类的静态对象。由于每次执行sql语句之后都会执行它的get方法，导致不必要的cpu浪费。这就是cpu异常的原因。</p>\n<p>遂改之：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LsnVo lv = ((DispatchConnection) conn).getLsnVo();</div></pre></td></tr></table></figure>\n<p>将threadLocalLsn的get方法的执行提前到DispatchConnection的构造函数中去，之后的每次读取都是直接读取在DispatchConnection保存的成员变量。避免了频繁的get方法调用。</p>\n<p>曾经在这里还有个疑问，那就是我认为不可以将这个get方法提前到DispatchConnection初始化当中，理由是如果有多个线程操作同一个DispatchConnection对象的时候，他们其实读取的是同一个lsn,造成共享变量的问题，而实际上lsn是一个线程级变量，不应该被多个线程共享。</p>\n<p>后来，宇哥跟我解释说一般不会有多个线程操作同一个connection 的场景，因为这样很容易造成不可预知的后果（事务提交等被打乱）。看来还是对数据库这块的知识太缺乏啊！</p>\n<p>PS:后来还是出问题了，使用线程池的时候，确实有可能发生上面多线程并发的情况。改回原来版本，性能下降问题依然存在，现未找到合适的解决办法。2016/7/29</p>\n<p>so,按照上面的改法问题解决了。</p>\n<p>那为什么要使用ThreadLocal存储lsn呢？前面也说了lsn是一个线程级变量，每个线程可以有多个connection，但这多个connection应当操作同一个lsn对象。</p>\n<p>这就是ThreadLocal的一个典型应用场景。</p>\n<h2 id=\"ThreadLocal原理：\"><a href=\"#ThreadLocal原理：\" class=\"headerlink\" title=\"ThreadLocal原理：\"></a><strong>ThreadLocal原理</strong>：</h2><p>使用ThreadLocal存储变量，实现了线程级别的变量，即同一个线程内这个变量只有一个。</p>\n<p>ThreadLocal的set和get方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        ThreadLocalMap map = getMap(t);</div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> (T)map.get(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Maps are constructed lazily.  if the map for this thread</span></div><div class=\"line\">        <span class=\"comment\">// doesn't exist, create it, with this ThreadLocal and its</span></div><div class=\"line\">        <span class=\"comment\">// initial value as its only entry.</span></div><div class=\"line\">        T value = initialValue();</div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，我们存入ThreadLocal的变量最终存到一个ThreadLocalMap中，这个ThreadLocalMap实际上是Thread的成员变量。这个ThreadLocalMap以ThreadLocal为键，是因为，在一个线程中很可能不只有一个ThreadLocal对象，每个ThreadLocal所要存储的Value值也不同。每次调用ThreadLocal的get方法时，都会去当前线程的ThreadLocalMap中找到对应的值。起到线程隔离的效果。</p>\n<p>很容易明白他的工作原理。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h2><p>之前看了网上很多资料说ThreadLocal的应用场景：</p>\n<p>1.解决了多线程共享对象的问题，</p>\n<p>2.实现线程间的数据隔离，每个线程都有他自己的变量副本。</p>\n<p>对于1，这样的说法现在看起来也有些勉强，首先不能说解决了多线程共享对象的问题，因为如果一个对象需要多个线程共享（在某些场景下这是必须的），那么他在内存中应该只有一份，但是使用ThreadLocal之后会有多个内存对象存在，而不是多个引用指向同一片内存。这样的话只能通过线程同步或者其他方法解决这种问题。但是在上面的场景中，说ThreadLocal解决了多线程共享对象的问题，也说得通。但是要加一个前提，那就是这个所谓的共享对象其实是可以不共享的，并不是必须共享的。比如上面的场景中，DispatchConnection 中 的masterLsn代表主机的状态，这个Lsn是可以不设为全局的（虽然主机只有一台，代表主机真实状态的Lsn也只有一个），每个线程可以有自己的masterLsn来表示当前主机的状态，因为在同一个线程中，每次的数据库读写操作是基于上一次操作进行的。</p>\n<p>对于2，每个线程有自己的变量副本。在上面的场景中，每个线程都应该操作同一个masterLsn。比如，首先创建了一个DispatchConnection，使用这个connection对数据库进行了更新操作，更新DispatchConnection中的masterLsn，然后关闭这个connection。紧接着又创建一个新的DispatchConnection，使用这个connection对数据库进行一些新的操作，比如查询刚才的更新。这个时候，需要将刚刚获得的masterLsn发送到备机，使备机与主机进行同步工作，然后才可以查询到上一个DispatchConnection所做的更新。所以，虽然创建了新的DispatchConnection，但前后两个DispatchConnection中的masterLsn应该是一样的，即这个masterLsn在同一个线程中应该只有一个，无论创建多少DispatchConnection（masterLsn是DispatchConnection的成员变量），这些connection中的Lsn都指向同一个对象。 故，使用ThreadLocal保存该masterLsn到DispatchConnection中。</p>\n<p>我们总结一下使用ThreadLocal存储某个变量的场景，或者说条件：</p>\n<p>1.这个变量在同一个线程中只允许有一个，比如上面的masterLsn，尽管包含masterLsn的DispatchConnection被创建了多次，但是他们的成员变量masterLsn指向同一个对象。</p>\n<p>2.要满足1中的条件，可以将该变量设为static的。此时多个线程共享这同一个变量，内存中独一份。但是这个时候会产生同步问题，代码的复杂度上升，也容易出问题。</p>\n<p>所以，使用ThreadLocal的场景应该是这样：<strong>这个变量不同的线程之间不需要共享，也就是这个变量不要求是全局的。同时，在同一个线程中，这个变量要求只有一个，即这个变量为线程级别的变量。</strong></p>\n<p>PS:既然说这个变量是线程级别的变量，那为什么不在这个线程类中创建这样一个变量呢？注意，线程的创建有时是不可控的，在上面的场景中，创建线程的基本上是使用DispatchConnection的用户，我们不能要求用户去创建masterLsn，更何况，这个masterLsn是属于DispatchConnection这个类，而DispatchConnection有可能创建销毁多次。</p>\n<p>另外，网上提到使用ThreadLocal的一个好处：避免了参数的传递增加程序复杂性。</p>\n<p>我不太理解这个好处从哪里体现出来。如果说要避免参数传递，将这个参数设为类的成员变量也可以解决。应用ThreadLocal的情况是：把ThreadLocal设为了成员变量，把这个参数存入ThreadLocal中。这个虽然说是避免了参数的传递，但这与使用ThreadLocal的目的相去甚远。使用ThreadLocal最主要还是解决线程级别的变量的问题。</p>\n"},{"layout":"post","title":"java中的volatile与synchronized","date":"2015-12-17T06:50:55.000Z","_content":"\n> 在之前的工作过程中涉及到多线程的问题，虽然多线程啥的都会用，但对于synchronized与volatile一直不知其所以然。所以花时间来总结总结。\n\n## 1.java内存模型\n\n## 2.volatile\n\n## 3.synchronized\n","source":"_posts/java中的volatile与synchronized.md","raw":"---\nlayout: post\ntitle:  \"java中的volatile与synchronized\"\ncategories: 编程\ndate:   2015-12-17 14:50:55\ntags: \n- java\n- 多线程\n---\n\n> 在之前的工作过程中涉及到多线程的问题，虽然多线程啥的都会用，但对于synchronized与volatile一直不知其所以然。所以花时间来总结总结。\n\n## 1.java内存模型\n\n## 2.volatile\n\n## 3.synchronized\n","slug":"java中的volatile与synchronized","published":1,"updated":"2016-08-14T08:26:27.886Z","comments":1,"photos":[],"link":"","_id":"cirucnp84000ajkqcqt2zd6ig","content":"<blockquote>\n<p>在之前的工作过程中涉及到多线程的问题，虽然多线程啥的都会用，但对于synchronized与volatile一直不知其所以然。所以花时间来总结总结。</p>\n</blockquote>\n<h2 id=\"1-java内存模型\"><a href=\"#1-java内存模型\" class=\"headerlink\" title=\"1.java内存模型\"></a>1.java内存模型</h2><h2 id=\"2-volatile\"><a href=\"#2-volatile\" class=\"headerlink\" title=\"2.volatile\"></a>2.volatile</h2><h2 id=\"3-synchronized\"><a href=\"#3-synchronized\" class=\"headerlink\" title=\"3.synchronized\"></a>3.synchronized</h2>","excerpt":"","more":"<blockquote>\n<p>在之前的工作过程中涉及到多线程的问题，虽然多线程啥的都会用，但对于synchronized与volatile一直不知其所以然。所以花时间来总结总结。</p>\n</blockquote>\n<h2 id=\"1-java内存模型\"><a href=\"#1-java内存模型\" class=\"headerlink\" title=\"1.java内存模型\"></a>1.java内存模型</h2><h2 id=\"2-volatile\"><a href=\"#2-volatile\" class=\"headerlink\" title=\"2.volatile\"></a>2.volatile</h2><h2 id=\"3-synchronized\"><a href=\"#3-synchronized\" class=\"headerlink\" title=\"3.synchronized\"></a>3.synchronized</h2>"},{"layout":"post","title":"java中的枚举","date":"2016-06-30T04:48:55.000Z","_content":"\n> 已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。\n\nJava中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。\n  \n## 使用场景：\n\n每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。\n\n## 与 public static final 的常量定义方式进行比较：\n\n在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：\n\n```java\npublic class State {\n\tpublic static final int Normal = 0;//正常\n\tpublic static final int Update = 1;//已更新\n\tpublic static final int Delete = 2;//已删除\n}\n```\n\n使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：\n\n```java\npublic void doSomething(int state){\n\tswitch(state){\n\t\tcase State.Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Update:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n1. 在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。\n\n2. 另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。\n\n3. 因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。\n\n那如果换成枚举常量呢？\n\n```java\npublic enum State {\n\tNormal,Update,Delete\n}\n```\n\n类型安全检查：\n\n```java\npublic void doSomething(State state){\n\tswitch(state){\n\t\tcase Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase Update:\n\t\t  ...\n\t\t  break;\n\t\tcase Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。\n\n另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。\n\n## 枚举类型的使用\n\n- **常量**：\n\n```java\npublic enum State{\n\tNormal,Update,Delete\n}\n```\n\n遍历枚举常量：\n\n```java\n   for(State state:State.values()){\n   \t\tSystem.out.println(state);\n   }\n```\n\n- **自定义属性、方法**：\n\n```java\npublic enum State{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }    \n}\n\npublic void test(){\n\tfor (State state : State.values()) {\n\t    //输出：正常:0 已更新:1 已删除:2\n\t\tSystem.out.println(state);\n\t}\n}\n```\n\n实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。\n其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。\n\n因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。\n\n- **实现接口**\n\n```java\npublic interface HandleState{\n\tvoid printState();\n}\n\npublic enum State implements HandleState{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }  \n\n    public void printState() {\n\t\tSystem.out.println(this);\n\t}\n}\n```\n\n可以看到，枚举和一般的类一样都可以实现接口。\n\n- **Enum 相关工具类**\n\nJDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。\n\n## **4.** 参考\n\n[java enum的用法详解[转]](https://hacpai.com/article/1437056657634)\n\n[Java 语言中Enum类型的使用介绍](https://www.ibm.com/developerworks/cn/java/j-lo-enum/)","source":"_posts/java中的枚举.md","raw":"---\nlayout: post\ntitle:  \"java中的枚举\"\ncategories: 编程\ntags: \n- java\ndate:   2016-06-30 12:48:55\n---\n\n> 已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。\n\nJava中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。\n  \n## 使用场景：\n\n每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。\n\n## 与 public static final 的常量定义方式进行比较：\n\n在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：\n\n```java\npublic class State {\n\tpublic static final int Normal = 0;//正常\n\tpublic static final int Update = 1;//已更新\n\tpublic static final int Delete = 2;//已删除\n}\n```\n\n使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：\n\n```java\npublic void doSomething(int state){\n\tswitch(state){\n\t\tcase State.Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Update:\n\t\t  ...\n\t\t  break;\n\t\tcase State.Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n1. 在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。\n\n2. 另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。\n\n3. 因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。\n\n那如果换成枚举常量呢？\n\n```java\npublic enum State {\n\tNormal,Update,Delete\n}\n```\n\n类型安全检查：\n\n```java\npublic void doSomething(State state){\n\tswitch(state){\n\t\tcase Normal:\n\t\t  ...\n\t\t  break;\n\t\tcase Update:\n\t\t  ...\n\t\t  break;\n\t\tcase Delete:\n\t\t  ...\n\t\t  break;\n\t\tdefault:\n\t\t  ...\n\t}\n}\n```\n\n调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。\n\n另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。\n\n## 枚举类型的使用\n\n- **常量**：\n\n```java\npublic enum State{\n\tNormal,Update,Delete\n}\n```\n\n遍历枚举常量：\n\n```java\n   for(State state:State.values()){\n   \t\tSystem.out.println(state);\n   }\n```\n\n- **自定义属性、方法**：\n\n```java\npublic enum State{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }    \n}\n\npublic void test(){\n\tfor (State state : State.values()) {\n\t    //输出：正常:0 已更新:1 已删除:2\n\t\tSystem.out.println(state);\n\t}\n}\n```\n\n实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。\n其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。\n\n因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。\n\n- **实现接口**\n\n```java\npublic interface HandleState{\n\tvoid printState();\n}\n\npublic enum State implements HandleState{\n\t//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号\n\tNormal(\"正常\",0),Update(\"已更新\",1),Delete(\"已删除\",2);\n\tprivate String name;\n\tprivate int index;\n\t// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化\n    private State(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n\n    // get set 方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    // 普通方法\n    public static String getName(int index) {\n        for (State c : State .values()) {\n            if (c.getIndex() == index) {\n                return c.name;\n            }\n        }\n        return null;\n    }\n\n    //覆盖toString方法,这样调试就不会看到魔术数字啦\n    @Override\n    public String toString(){\n    \treturn name+\":\"+index;\n    }  \n\n    public void printState() {\n\t\tSystem.out.println(this);\n\t}\n}\n```\n\n可以看到，枚举和一般的类一样都可以实现接口。\n\n- **Enum 相关工具类**\n\nJDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。\n\n## **4.** 参考\n\n[java enum的用法详解[转]](https://hacpai.com/article/1437056657634)\n\n[Java 语言中Enum类型的使用介绍](https://www.ibm.com/developerworks/cn/java/j-lo-enum/)","slug":"java中的枚举","published":1,"updated":"2016-08-14T09:10:56.616Z","_id":"cirucnp8a000cjkqc6pfryloc","comments":1,"photos":[],"link":"","content":"<blockquote>\n<p>已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。</p>\n</blockquote>\n<p>Java中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。</p>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><p>每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。</p>\n<h2 id=\"与-public-static-final-的常量定义方式进行比较：\"><a href=\"#与-public-static-final-的常量定义方式进行比较：\" class=\"headerlink\" title=\"与 public static final 的常量定义方式进行比较：\"></a>与 public static final 的常量定义方式进行比较：</h2><p>在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">State</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Normal = <span class=\"number\">0</span>;<span class=\"comment\">//正常</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Update = <span class=\"number\">1</span>;<span class=\"comment\">//已更新</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Delete = <span class=\"number\">2</span>;<span class=\"comment\">//已删除</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。</p>\n</li>\n<li><p>另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。</p>\n</li>\n<li><p>因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。</p>\n</li>\n</ol>\n<p>那如果换成枚举常量呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类型安全检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(State state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。</p>\n<p>另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。</p>\n<h2 id=\"枚举类型的使用\"><a href=\"#枚举类型的使用\" class=\"headerlink\" title=\"枚举类型的使用\"></a>枚举类型的使用</h2><ul>\n<li><strong>常量</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遍历枚举常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(State state:State.values())&#123;</div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>自定义属性、方法</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (State state : State.values()) &#123;</div><div class=\"line\">\t    <span class=\"comment\">//输出：正常:0 已更新:1 已删除:2</span></div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。<br>其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(“正常”,0),Update(“已更新”,1),Delete(“已删除”,2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。</p>\n<p>因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。</p>\n<ul>\n<li><strong>实现接口</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandleState</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State implements HandleState&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，枚举和一般的类一样都可以实现接口。</p>\n<ul>\n<li><strong>Enum 相关工具类</strong></li>\n</ul>\n<p>JDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。</p>\n<h2 id=\"4-参考\"><a href=\"#4-参考\" class=\"headerlink\" title=\"4. 参考\"></a><strong>4.</strong> 参考</h2><p><a href=\"https://hacpai.com/article/1437056657634\" target=\"_blank\" rel=\"external\">java enum的用法详解[转]</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-enum/\" target=\"_blank\" rel=\"external\">Java 语言中Enum类型的使用介绍</a></p>\n","excerpt":"","more":"<blockquote>\n<p>已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。</p>\n</blockquote>\n<p>Java中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。</p>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><p>每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。</p>\n<h2 id=\"与-public-static-final-的常量定义方式进行比较：\"><a href=\"#与-public-static-final-的常量定义方式进行比较：\" class=\"headerlink\" title=\"与 public static final 的常量定义方式进行比较：\"></a>与 public static final 的常量定义方式进行比较：</h2><p>在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">State</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Normal = <span class=\"number\">0</span>;<span class=\"comment\">//正常</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Update = <span class=\"number\">1</span>;<span class=\"comment\">//已更新</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> Delete = <span class=\"number\">2</span>;<span class=\"comment\">//已删除</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> State.Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。</p>\n</li>\n<li><p>另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。</p>\n</li>\n<li><p>因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。</p>\n</li>\n</ol>\n<p>那如果换成枚举常量呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类型安全检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(State state)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">switch</span>(state)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Normal:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Update:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> Delete:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t\t  <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t  ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。</p>\n<p>另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。</p>\n<h2 id=\"枚举类型的使用\"><a href=\"#枚举类型的使用\" class=\"headerlink\" title=\"枚举类型的使用\"></a>枚举类型的使用</h2><ul>\n<li><strong>常量</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\tNormal,Update,Delete</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遍历枚举常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(State state:State.values())&#123;</div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>自定义属性、方法</strong>：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (State state : State.values()) &#123;</div><div class=\"line\">\t    <span class=\"comment\">//输出：正常:0 已更新:1 已删除:2</span></div><div class=\"line\">\t\tSystem.out.println(state);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。<br>其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal(“正常”,0),Update(“已更新”,1),Delete(“已删除”,2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。</p>\n<p>因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。</p>\n<ul>\n<li><strong>实现接口</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandleState</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State implements HandleState&#123;</div><div class=\"line\">\t<span class=\"comment\">//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号</span></div><div class=\"line\">\tNormal(<span class=\"string\">\"正常\"</span>,<span class=\"number\">0</span>),Update(<span class=\"string\">\"已更新\"</span>,<span class=\"number\">1</span>),Delete(<span class=\"string\">\"已删除\"</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t<span class=\"keyword\">private</span> String name;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</div><div class=\"line\">\t<span class=\"comment\">// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// get set 方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 普通方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (State c : State .values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (c.getIndex() == index) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> c.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//覆盖toString方法,这样调试就不会看到魔术数字啦</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> name+<span class=\"string\">\":\"</span>+index;</div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printState</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，枚举和一般的类一样都可以实现接口。</p>\n<ul>\n<li><strong>Enum 相关工具类</strong></li>\n</ul>\n<p>JDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。</p>\n<h2 id=\"4-参考\"><a href=\"#4-参考\" class=\"headerlink\" title=\"4. 参考\"></a><strong>4.</strong> 参考</h2><p><a href=\"https://hacpai.com/article/1437056657634\">java enum的用法详解[转]</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-enum/\">Java 语言中Enum类型的使用介绍</a></p>\n"},{"layout":"post","title":"java中的类型转换","date":"2016-04-28T04:48:55.000Z","_content":"\n>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：\n\n## **基本类型**\n\n- **基本类型优先级**\n\n首先来看java中的基本类型有哪些：\n\nbyte：byte数据类型是一个8位有符号二进制补码整数。\n\nshort：short数据类型为16位有符号二进制补码整数。\n\nint：int数据类型是一个32位有符号二进制补码整数\n\nlong: long数据类型是一个64位二进制补码整数\n\nfloat: float数据类型是单精度、32位、符合IEEE 754标准的浮点数\n\nboolean: boolean数据类型只有两个可能的值：true和false\n\ndouble: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；\n\nchar: char数据类型是一个16位的Unicode字符\n\n基本类型优先级由低到高排序：\n\n(byte short char) int long float double\n\n其中，byte short char 平级\n\n- **转换规则**\n\n1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算\n\n3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。\n\n2.byte short char 他们三者在计算时，首先会转换为int类型\n\n3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。\n\n4.boolean不能与其他类型转换\n\n\n## **类类型**\n\n类类型之间的转换有以下几个规则：\n\n1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。\n\n2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。\n\n3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。\n  \n说的比较拗口，用代码来解释吧。\n\n```java\npublic class Test {\n\n    class Father {}\n\t\n    class Son extends Father{}\n\t\n    class Daughter extends Father {}\n\n    @org.junit.Test\n    public void test(){\n        Father fatherApp;\n        Son sonApp;\n        Daughter daughterApp;\n        Father fatherIns=new Father();\n        Son sonIns=new Son();\n        Daughter daughterIns=new Daughter();\n\t\t\n        //目标类型为父类，源类型为子类，自动转换\n        fatherApp=sonIns;   \n        //源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。\n        sonApp=(Son) fatherIns;\n        //源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        \n        sonApp=(Son) fatherApp;\n        //目标类型与源类型不存在父子关系，编译无法通过\n        daughterApp=sonIns;  \n\t\t\n    }\t\n}\n```\n\n\n\n## **参考**\n\n[Java 7之基础类型第1篇 - Java数据类型](http://blog.csdn.net/mazhimazh/article/details/16799925)\n\n[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)\n\n[ Java中的类型转换](http://blog.csdn.net/darxin/article/details/5163043)\n","source":"_posts/java中的类型转换.md","raw":"---\nlayout: post\ntitle:  \"java中的类型转换\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-28 12:48:55\n---\n\n>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：\n\n## **基本类型**\n\n- **基本类型优先级**\n\n首先来看java中的基本类型有哪些：\n\nbyte：byte数据类型是一个8位有符号二进制补码整数。\n\nshort：short数据类型为16位有符号二进制补码整数。\n\nint：int数据类型是一个32位有符号二进制补码整数\n\nlong: long数据类型是一个64位二进制补码整数\n\nfloat: float数据类型是单精度、32位、符合IEEE 754标准的浮点数\n\nboolean: boolean数据类型只有两个可能的值：true和false\n\ndouble: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；\n\nchar: char数据类型是一个16位的Unicode字符\n\n基本类型优先级由低到高排序：\n\n(byte short char) int long float double\n\n其中，byte short char 平级\n\n- **转换规则**\n\n1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算\n\n3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。\n\n2.byte short char 他们三者在计算时，首先会转换为int类型\n\n3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。\n\n4.boolean不能与其他类型转换\n\n\n## **类类型**\n\n类类型之间的转换有以下几个规则：\n\n1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。\n\n2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。\n\n3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。\n  \n说的比较拗口，用代码来解释吧。\n\n```java\npublic class Test {\n\n    class Father {}\n\t\n    class Son extends Father{}\n\t\n    class Daughter extends Father {}\n\n    @org.junit.Test\n    public void test(){\n        Father fatherApp;\n        Son sonApp;\n        Daughter daughterApp;\n        Father fatherIns=new Father();\n        Son sonIns=new Son();\n        Daughter daughterIns=new Daughter();\n\t\t\n        //目标类型为父类，源类型为子类，自动转换\n        fatherApp=sonIns;   \n        //源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。\n        sonApp=(Son) fatherIns;\n        //源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        \n        sonApp=(Son) fatherApp;\n        //目标类型与源类型不存在父子关系，编译无法通过\n        daughterApp=sonIns;  \n\t\t\n    }\t\n}\n```\n\n\n\n## **参考**\n\n[Java 7之基础类型第1篇 - Java数据类型](http://blog.csdn.net/mazhimazh/article/details/16799925)\n\n[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)\n\n[ Java中的类型转换](http://blog.csdn.net/darxin/article/details/5163043)\n","slug":"java中的类型转换","published":1,"updated":"2016-08-14T08:26:27.899Z","comments":1,"photos":[],"link":"","_id":"cirucnp8j000gjkqc05763md0","content":"<blockquote>\n<p>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：</p>\n</blockquote>\n<h2 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a><strong>基本类型</strong></h2><ul>\n<li><strong>基本类型优先级</strong></li>\n</ul>\n<p>首先来看java中的基本类型有哪些：</p>\n<p>byte：byte数据类型是一个8位有符号二进制补码整数。</p>\n<p>short：short数据类型为16位有符号二进制补码整数。</p>\n<p>int：int数据类型是一个32位有符号二进制补码整数</p>\n<p>long: long数据类型是一个64位二进制补码整数</p>\n<p>float: float数据类型是单精度、32位、符合IEEE 754标准的浮点数</p>\n<p>boolean: boolean数据类型只有两个可能的值：true和false</p>\n<p>double: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</p>\n<p>char: char数据类型是一个16位的Unicode字符</p>\n<p>基本类型优先级由低到高排序：</p>\n<p>(byte short char) int long float double</p>\n<p>其中，byte short char 平级</p>\n<ul>\n<li><strong>转换规则</strong></li>\n</ul>\n<p>1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算</p>\n<p>3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。</p>\n<p>2.byte short char 他们三者在计算时，首先会转换为int类型</p>\n<p>3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。</p>\n<p>4.boolean不能与其他类型转换</p>\n<h2 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a><strong>类类型</strong></h2><p>类类型之间的转换有以下几个规则：</p>\n<p>1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。</p>\n<p>2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。</p>\n<p>3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。</p>\n<p>说的比较拗口，用代码来解释吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@org</span>.junit.<span class=\"function\">Test</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span>&#123;</div><div class=\"line\">        Father fatherApp;</div><div class=\"line\">        Son sonApp;</div><div class=\"line\">        Daughter daughterApp;</div><div class=\"line\">        Father fatherIns=<span class=\"keyword\">new</span> Father();</div><div class=\"line\">        Son sonIns=<span class=\"keyword\">new</span> Son();</div><div class=\"line\">        Daughter daughterIns=<span class=\"keyword\">new</span> Daughter();</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\">//目标类型为父类，源类型为子类，自动转换</span></div><div class=\"line\">        fatherApp=sonIns;   </div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。</span></div><div class=\"line\">        sonApp=(Son) fatherIns;</div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        </span></div><div class=\"line\">        sonApp=(Son) fatherApp;</div><div class=\"line\">        <span class=\"comment\">//目标类型与源类型不存在父子关系，编译无法通过</span></div><div class=\"line\">        daughterApp=sonIns;  </div><div class=\"line\">\t\t</div><div class=\"line\">    &#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://blog.csdn.net/mazhimazh/article/details/16799925\" target=\"_blank\" rel=\"external\">Java 7之基础类型第1篇 - Java数据类型</a></p>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\" target=\"_blank\" rel=\"external\">The Java™ Tutorials</a></p>\n<p><a href=\"http://blog.csdn.net/darxin/article/details/5163043\" target=\"_blank\" rel=\"external\"> Java中的类型转换</a></p>\n","excerpt":"","more":"<blockquote>\n<p>以前一直对java中的类型转换了解的不是很清楚，因为平时写代码有IDE的帮助，所以往往忽略这一块的内容，但往往就是这样的小知识点不清楚，很有可能造成很大的错误。所以在闲暇时间总结一下这些可能被遗忘的知识点。网上已经有很多相关的介绍文章了，现在来梳理一番：</p>\n</blockquote>\n<h2 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a><strong>基本类型</strong></h2><ul>\n<li><strong>基本类型优先级</strong></li>\n</ul>\n<p>首先来看java中的基本类型有哪些：</p>\n<p>byte：byte数据类型是一个8位有符号二进制补码整数。</p>\n<p>short：short数据类型为16位有符号二进制补码整数。</p>\n<p>int：int数据类型是一个32位有符号二进制补码整数</p>\n<p>long: long数据类型是一个64位二进制补码整数</p>\n<p>float: float数据类型是单精度、32位、符合IEEE 754标准的浮点数</p>\n<p>boolean: boolean数据类型只有两个可能的值：true和false</p>\n<p>double: double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</p>\n<p>char: char数据类型是一个16位的Unicode字符</p>\n<p>基本类型优先级由低到高排序：</p>\n<p>(byte short char) int long float double</p>\n<p>其中，byte short char 平级</p>\n<ul>\n<li><strong>转换规则</strong></li>\n</ul>\n<p>1.有多种数据类型混合计算的时候，低优先级类型自动提升为优先级最大的那个类型再来继续计算</p>\n<p>3.高优先级类型转换为低优先级类型时，需要强制类型转换，并且有可能丢失精度或溢出。</p>\n<p>2.byte short char 他们三者在计算时，首先会转换为int类型</p>\n<p>3.由于byte short char三者平级，他们之间互相转换时需进行强制类型转换。</p>\n<p>4.boolean不能与其他类型转换</p>\n<h2 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a><strong>类类型</strong></h2><p>类类型之间的转换有以下几个规则：</p>\n<p>1.当源类型与目标类型不存在父子关系时，转换无法进行，编译时会出现错误。包括两个类为继承同一个父类这种情况，也是不可以进行转换的。</p>\n<p>2.源类型是子类，目标类型是父类时，不必强制转换。只是屏蔽了一些子类才有的功能。</p>\n<p>3.源类型是父类，目标类型是子类时，要分两种情况：第一，源类型指向的对象就是父类类型。此时不能进行强制转换，编译器可以通过，但运行时会报类型转换错误。第二，源类型指向的对象是子类类型。此时可以进行强制转换，还原子类。</p>\n<p>说的比较拗口，用代码来解释吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;&#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@org</span>.junit.<span class=\"function\">Test</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        Father fatherApp;</div><div class=\"line\">        Son sonApp;</div><div class=\"line\">        Daughter daughterApp;</div><div class=\"line\">        Father fatherIns=<span class=\"keyword\">new</span> Father();</div><div class=\"line\">        Son sonIns=<span class=\"keyword\">new</span> Son();</div><div class=\"line\">        Daughter daughterIns=<span class=\"keyword\">new</span> Daughter();</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\">//目标类型为父类，源类型为子类，自动转换</span></div><div class=\"line\">        fatherApp=sonIns;   </div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向父类对象,运行时报错。</span></div><div class=\"line\">        sonApp=(Son) fatherIns;</div><div class=\"line\">        <span class=\"comment\">//源类型为父类，目标类型为子类，且源类型指向子类对象，还原子类        </span></div><div class=\"line\">        sonApp=(Son) fatherApp;</div><div class=\"line\">        <span class=\"comment\">//目标类型与源类型不存在父子关系，编译无法通过</span></div><div class=\"line\">        daughterApp=sonIns;  </div><div class=\"line\">\t\t</div><div class=\"line\">    &#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://blog.csdn.net/mazhimazh/article/details/16799925\">Java 7之基础类型第1篇 - Java数据类型</a></p>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\">The Java™ Tutorials</a></p>\n<p><a href=\"http://blog.csdn.net/darxin/article/details/5163043\"> Java中的类型转换</a></p>\n"},{"layout":"post","title":"java中的编码问题","date":"2016-04-20T04:48:55.000Z","_content":"\n>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。\n\n## 编码\n什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。\n\n- #### **[Ascii编码](http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&fromid=99077&type=syn)**\n\n标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。\n\n- #### **[GB2312](http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&fromid=483170&type=syn)**\n\nGB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。\n\n- #### **[UTF-8](http://baike.baidu.com/view/25412.htm)**\n\n事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是[Unicode编码](http://baike.baidu.com/item/unicode)\n事实上，Unicode也是一套字符集。\n\n**字符集**简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字\"严\"。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？\n\n这是因为：\n\n比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n\n\nUTF-8就是在互联网上使用最广的一种Unicode的实现方式。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8的编码规则很简单，只有两条： \n\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 \n\n2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n\n下面以utf-8为例，看下编码的过程。\n\n{% asset_img utf8.png utf-8 %}\n\n根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。\n\n以汉字”严”为例，演示如何实现UTF-8编码。\n\n已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。\n\n还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。\n\n## java 中的编码\n\n- #### **class文件与内存中的编码**\n\n{% asset_img javaencode.jpg %}\n\n上图说明了java编码转换的过程\n\n首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。\n\njava程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。\n\n**总结**:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。\n\n- #### **InputStreamReader与OutputStreamWriter**\n\n{% asset_img reader.png %}\n{% asset_img writer.png %}\n\nReader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。\n\n写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。\n\n```java\n String file = \"c:/stream.txt\"; \n String charset = \"UTF-8\"; \n // 写字符换转成字节流\n FileOutputStream outputStream = new FileOutputStream(file); \n OutputStreamWriter writer = new OutputStreamWriter( \n outputStream, charset); \n try { \n    writer.write(\"这是要保存的中文字符\"); \n } finally { \n    writer.close(); \n } \n // 读取字节转换成字符\n FileInputStream inputStream = new FileInputStream(file); \n InputStreamReader reader = new InputStreamReader( \n inputStream, charset); \n StringBuffer buffer = new StringBuffer(); \n char[] buf = new char[64]; \n int count = 0; \n try { \n    while ((count = reader.read(buf)) != -1) { \n        buffer.append(buf, 0, count); \n    } \n } finally { \n    reader.close(); \n }\n```\n\n- #### **String与byte[]**\n\n利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。\n\n```java\nString str=\"中\";  \n// 将内存中的str(utf-16)转换为系统默认编码的字节数组\nbyte[] bytes1 = str.getBytes();  \n// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 \nbyte[] bytes2 = str.getBytes(\"ISO-8859-1\");\n// 正常显示中    \nSystem.out.println(new String(bytes1));  \n// 输出\"?\"      \nSystem.out.println(new String(bytes2));      \n```\n\n利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。\n\n```java\n// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”\nbyte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31};  \n// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符\nString str1 = new String(bytes);                      \n// 将bytes按照ISO-8859-1解码，产生Unicode字符\nString str2= new String(bytes,\"ISO-8859-1\");          \n// 中1  将Unicode字符转换为GBK编码输出\nSystem.out.println(str1);                             \n\n/*\n *在ISO-8859-1编码方式中没有对应0xD6和0xD0\n *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”\n *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。\n */ \nSystem.out.println(str2);    // ??1                             \n```\n\n- #### **CharSet**\n\n从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。\n\n```java\nCharset charset = Charset.forName(\"UTF-8\");   \nByteBuffer byteBuffer = charset.encode(string);   \nCharBuffer charBuffer = charset.decode(byteBuffer); \n```\n\n## 延伸 byte\n\n字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。\n\n无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。\n\n有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.\n\n## 参考\n\n[十分钟搞清字符集和字符编码](http://cenalulu.github.io/linux/character-encoding/)\n\n[字符编码笔记：ASCII，Unicode和UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n[java编码转换过程](http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html)\n\n[Java 7之基础 - 编码与解码](http://blog.csdn.net/mazhimazh/article/details/19327421)\n\n[深入分析 Java 中的中文编码问题](https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/)","source":"_posts/java中的编码问题.md","raw":"---\nlayout: post\ntitle:  \"java中的编码问题\"\ncategories: 编程\ntags: \n- java\n- 编码\ndate:   2016-04-20 12:48:55\n---\n\n>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。\n\n## 编码\n什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。\n\n- #### **[Ascii编码](http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&fromid=99077&type=syn)**\n\n标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。\n\n- #### **[GB2312](http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&fromid=483170&type=syn)**\n\nGB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。\n\n- #### **[UTF-8](http://baike.baidu.com/view/25412.htm)**\n\n事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是[Unicode编码](http://baike.baidu.com/item/unicode)\n事实上，Unicode也是一套字符集。\n\n**字符集**简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字\"严\"。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？\n\n这是因为：\n\n比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n\n\nUTF-8就是在互联网上使用最广的一种Unicode的实现方式。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8的编码规则很简单，只有两条： \n\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 \n\n2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n\n下面以utf-8为例，看下编码的过程。\n\n{% asset_img utf8.png utf-8 %}\n\n根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。\n\n以汉字”严”为例，演示如何实现UTF-8编码。\n\n已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。\n\n还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。\n\n## java 中的编码\n\n- #### **class文件与内存中的编码**\n\n{% asset_img javaencode.jpg %}\n\n上图说明了java编码转换的过程\n\n首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。\n\njava程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。\n\n**总结**:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。\n\n- #### **InputStreamReader与OutputStreamWriter**\n\n{% asset_img reader.png %}\n{% asset_img writer.png %}\n\nReader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。\n\n写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。\n\n```java\n String file = \"c:/stream.txt\"; \n String charset = \"UTF-8\"; \n // 写字符换转成字节流\n FileOutputStream outputStream = new FileOutputStream(file); \n OutputStreamWriter writer = new OutputStreamWriter( \n outputStream, charset); \n try { \n    writer.write(\"这是要保存的中文字符\"); \n } finally { \n    writer.close(); \n } \n // 读取字节转换成字符\n FileInputStream inputStream = new FileInputStream(file); \n InputStreamReader reader = new InputStreamReader( \n inputStream, charset); \n StringBuffer buffer = new StringBuffer(); \n char[] buf = new char[64]; \n int count = 0; \n try { \n    while ((count = reader.read(buf)) != -1) { \n        buffer.append(buf, 0, count); \n    } \n } finally { \n    reader.close(); \n }\n```\n\n- #### **String与byte[]**\n\n利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。\n\n```java\nString str=\"中\";  \n// 将内存中的str(utf-16)转换为系统默认编码的字节数组\nbyte[] bytes1 = str.getBytes();  \n// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 \nbyte[] bytes2 = str.getBytes(\"ISO-8859-1\");\n// 正常显示中    \nSystem.out.println(new String(bytes1));  \n// 输出\"?\"      \nSystem.out.println(new String(bytes2));      \n```\n\n利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。\n\n```java\n// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”\nbyte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31};  \n// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符\nString str1 = new String(bytes);                      \n// 将bytes按照ISO-8859-1解码，产生Unicode字符\nString str2= new String(bytes,\"ISO-8859-1\");          \n// 中1  将Unicode字符转换为GBK编码输出\nSystem.out.println(str1);                             \n\n/*\n *在ISO-8859-1编码方式中没有对应0xD6和0xD0\n *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”\n *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。\n */ \nSystem.out.println(str2);    // ??1                             \n```\n\n- #### **CharSet**\n\n从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。\n\n```java\nCharset charset = Charset.forName(\"UTF-8\");   \nByteBuffer byteBuffer = charset.encode(string);   \nCharBuffer charBuffer = charset.decode(byteBuffer); \n```\n\n## 延伸 byte\n\n字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。\n\n无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。\n\n有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.\n\n## 参考\n\n[十分钟搞清字符集和字符编码](http://cenalulu.github.io/linux/character-encoding/)\n\n[字符编码笔记：ASCII，Unicode和UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n[java编码转换过程](http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html)\n\n[Java 7之基础 - 编码与解码](http://blog.csdn.net/mazhimazh/article/details/19327421)\n\n[深入分析 Java 中的中文编码问题](https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/)","slug":"java中的编码问题","published":1,"updated":"2016-08-14T09:11:22.744Z","_id":"cirucnp8n000jjkqcj9qkcaww","comments":1,"photos":[],"link":"","content":"<blockquote>\n<p>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。</p>\n</blockquote>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。</p>\n<ul>\n<li><h4 id=\"Ascii编码\"><a href=\"#Ascii编码\" class=\"headerlink\" title=\"Ascii编码\"></a><strong><a href=\"http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&amp;fromid=99077&amp;type=syn\" target=\"_blank\" rel=\"external\">Ascii编码</a></strong></h4></li>\n</ul>\n<p>标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。</p>\n<ul>\n<li><h4 id=\"GB2312\"><a href=\"#GB2312\" class=\"headerlink\" title=\"GB2312\"></a><strong><a href=\"http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&amp;fromid=483170&amp;type=syn\" target=\"_blank\" rel=\"external\">GB2312</a></strong></h4></li>\n</ul>\n<p>GB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p>\n<ul>\n<li><h4 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a><strong><a href=\"http://baike.baidu.com/view/25412.htm\" target=\"_blank\" rel=\"external\">UTF-8</a></strong></h4></li>\n</ul>\n<p>事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是<a href=\"http://baike.baidu.com/item/unicode\" target=\"_blank\" rel=\"external\">Unicode编码</a><br>事实上，Unicode也是一套字符集。</p>\n<p><strong>字符集</strong>简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？</p>\n<p>这是因为：</p>\n<p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。<br>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>\n<p>UTF-8就是在互联网上使用最广的一种Unicode的实现方式。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<p>UTF-8的编码规则很简单，只有两条： </p>\n<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </p>\n<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>\n<p>下面以utf-8为例，看下编码的过程。</p>\n<img src=\"/2016/04/20/java中的编码问题/utf8.png\" alt=\"utf-8\" title=\"utf-8\">\n<p>根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。</p>\n<p>以汉字”严”为例，演示如何实现UTF-8编码。</p>\n<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。</p>\n<p>还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。</p>\n<h2 id=\"java-中的编码\"><a href=\"#java-中的编码\" class=\"headerlink\" title=\"java 中的编码\"></a>java 中的编码</h2><ul>\n<li><h4 id=\"class文件与内存中的编码\"><a href=\"#class文件与内存中的编码\" class=\"headerlink\" title=\"class文件与内存中的编码\"></a><strong>class文件与内存中的编码</strong></h4></li>\n</ul>\n\n<p>上图说明了java编码转换的过程</p>\n<p>首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。</p>\n<p>java程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。</p>\n<p><strong>总结</strong>:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。</p>\n<ul>\n<li><h4 id=\"InputStreamReader与OutputStreamWriter\"><a href=\"#InputStreamReader与OutputStreamWriter\" class=\"headerlink\" title=\"InputStreamReader与OutputStreamWriter\"></a><strong>InputStreamReader与OutputStreamWriter</strong></h4></li>\n</ul>\n<img src=\"/2016/04/20/java中的编码问题/reader.png\" alt=\"reader.png\" title=\"\">\n<img src=\"/2016/04/20/java中的编码问题/writer.png\" alt=\"writer.png\" title=\"\">\n<p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。</p>\n<p>写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">String file = <span class=\"string\">\"c:/stream.txt\"</span>; </div><div class=\"line\">String charset = <span class=\"string\">\"UTF-8\"</span>; </div><div class=\"line\"><span class=\"comment\">// 写字符换转成字节流</span></div><div class=\"line\">FileOutputStream outputStream = <span class=\"keyword\">new</span> FileOutputStream(file); </div><div class=\"line\">OutputStreamWriter writer = <span class=\"keyword\">new</span> OutputStreamWriter( </div><div class=\"line\">outputStream, charset); </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   writer.write(<span class=\"string\">\"这是要保存的中文字符\"</span>); </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   writer.close(); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"comment\">// 读取字节转换成字符</span></div><div class=\"line\">FileInputStream inputStream = <span class=\"keyword\">new</span> FileInputStream(file); </div><div class=\"line\">InputStreamReader reader = <span class=\"keyword\">new</span> InputStreamReader( </div><div class=\"line\">inputStream, charset); </div><div class=\"line\">StringBuffer buffer = <span class=\"keyword\">new</span> StringBuffer(); </div><div class=\"line\"><span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>]; </div><div class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   <span class=\"keyword\">while</span> ((count = reader.read(buf)) != -<span class=\"number\">1</span>) &#123; </div><div class=\"line\">       buffer.append(buf, <span class=\"number\">0</span>, count); </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   reader.close(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"String与byte\"><a href=\"#String与byte\" class=\"headerlink\" title=\"String与byte[]\"></a><strong>String与byte[]</strong></h4></li>\n</ul>\n<p>利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"string\">\"中\"</span>;  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为系统默认编码的字节数组</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = str.getBytes();  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 </span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = str.getBytes(<span class=\"string\">\"ISO-8859-1\"</span>);</div><div class=\"line\"><span class=\"comment\">// 正常显示中    </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes1));  </div><div class=\"line\"><span class=\"comment\">// 输出\"?\"      </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes2));</div></pre></td></tr></table></figure>\n<p>利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes = &#123;(<span class=\"keyword\">byte</span>)<span class=\"number\">0xD6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0xD0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0x31</span>&#125;;  </div><div class=\"line\"><span class=\"comment\">// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符</span></div><div class=\"line\">String str1 = <span class=\"keyword\">new</span> String(bytes);                      </div><div class=\"line\"><span class=\"comment\">// 将bytes按照ISO-8859-1解码，产生Unicode字符</span></div><div class=\"line\">String str2= <span class=\"keyword\">new</span> String(bytes,<span class=\"string\">\"ISO-8859-1\"</span>);          </div><div class=\"line\"><span class=\"comment\">// 中1  将Unicode字符转换为GBK编码输出</span></div><div class=\"line\">System.out.println(str1);                             </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> *在ISO-8859-1编码方式中没有对应0xD6和0xD0</div><div class=\"line\"> *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”</div><div class=\"line\"> *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。</div><div class=\"line\"> */ </div><div class=\"line\">System.out.println(str2);    <span class=\"comment\">// ??1</span></div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"CharSet\"><a href=\"#CharSet\" class=\"headerlink\" title=\"CharSet\"></a><strong>CharSet</strong></h4></li>\n</ul>\n<p>从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(<span class=\"string\">\"UTF-8\"</span>);   </div><div class=\"line\">ByteBuffer byteBuffer = charset.encode(string);   </div><div class=\"line\">CharBuffer charBuffer = charset.decode(byteBuffer);</div></pre></td></tr></table></figure>\n<h2 id=\"延伸-byte\"><a href=\"#延伸-byte\" class=\"headerlink\" title=\"延伸 byte\"></a>延伸 byte</h2><p>字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。</p>\n<p>无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。</p>\n<p>有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://cenalulu.github.io/linux/character-encoding/\" target=\"_blank\" rel=\"external\">十分钟搞清字符集和字符编码</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\" target=\"_blank\" rel=\"external\">字符编码笔记：ASCII，Unicode和UTF-8</a></p>\n<p><a href=\"http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html\" target=\"_blank\" rel=\"external\">java编码转换过程</a></p>\n<p><a href=\"http://blog.csdn.net/mazhimazh/article/details/19327421\" target=\"_blank\" rel=\"external\">Java 7之基础 - 编码与解码</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/\" target=\"_blank\" rel=\"external\">深入分析 Java 中的中文编码问题</a></p>\n","excerpt":"","more":"<blockquote>\n<p>最近在工作过程中总是被编码困扰，出现了很多意想不到的情况。故上网查看资料，总结一番。</p>\n</blockquote>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>什么是编码？程序员应该都知道计算机能够识别的只是1和0，我们看到的文字、图片、视频等在计算机的 世界里都是以二进制的形式存在的。包括你的硬盘或者网络上传输的字节序列，都是无数个0和1组成的。英文字母，数字，汉字等都是字符。不同字符对应二进制数的规则，也就是说不同的字符翻译为不同的0、1组合，就是字符的编码。这个过程的逆过程，就是解码。</p>\n<ul>\n<li><h4 id=\"Ascii编码\"><a href=\"#Ascii编码\" class=\"headerlink\" title=\"Ascii编码\"></a><strong><a href=\"http://baike.baidu.com/view/15482.htm?fromtitle=ascii%E7%A0%81&amp;fromid=99077&amp;type=syn\">Ascii编码</a></strong></h4></li>\n</ul>\n<p>标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。(一个字节8位)。缺点是只能显示128个字符，显示的字符十分有限，比如对中文就无能为力了。</p>\n<ul>\n<li><h4 id=\"GB2312\"><a href=\"#GB2312\" class=\"headerlink\" title=\"GB2312\"></a><strong><a href=\"http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&amp;fromid=483170&amp;type=syn\">GB2312</a></strong></h4></li>\n</ul>\n<p>GB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p>\n<ul>\n<li><h4 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a><strong><a href=\"http://baike.baidu.com/view/25412.htm\">UTF-8</a></strong></h4></li>\n</ul>\n<p>事实上世界上那么多国家，存在更多的字符是前面的编码所不能表示的。不同国家的不同编码之间也不能够兼容。所以就需要一套通用的编码能够表示世界上所有的符号，这就是<a href=\"http://baike.baidu.com/item/unicode\">Unicode编码</a><br>事实上，Unicode也是一套字符集。</p>\n<p><strong>字符集</strong>简单说就是字符的集合。它规定了每个字符对应的二进制编码。比如Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。那既然字符集中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？</p>\n<p>这是因为：</p>\n<p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。<br>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>\n<p>UTF-8就是在互联网上使用最广的一种Unicode的实现方式。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<p>UTF-8的编码规则很简单，只有两条： </p>\n<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </p>\n<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>\n<p>下面以utf-8为例，看下编码的过程。</p>\n<img src=\"/2016/04/20/java中的编码问题/utf8.png\" alt=\"utf-8\" title=\"utf-8\">\n<p>根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。</p>\n<p>以汉字”严”为例，演示如何实现UTF-8编码。</p>\n<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。</p>\n<p>还有一些编码就不再一一介绍了，具体用到的话可以百度或谷歌。</p>\n<h2 id=\"java-中的编码\"><a href=\"#java-中的编码\" class=\"headerlink\" title=\"java 中的编码\"></a>java 中的编码</h2><ul>\n<li><h4 id=\"class文件与内存中的编码\"><a href=\"#class文件与内存中的编码\" class=\"headerlink\" title=\"class文件与内存中的编码\"></a><strong>class文件与内存中的编码</strong></h4></li>\n</ul>\n\n<p>上图说明了java编码转换的过程</p>\n<p>首先，java源文件是可以用很多种编码保存的。在使用javac编译源文件时，如果没有指定源文件的编码，javac会默认源文件是以系统默认编码编写的，（Windows通常为GBK），javac使用该编码格式对源文件进行解码并将其中的字符以UTF-8输出到Class文件中。如果源文件并不是已系统默认编码保存的，那么javac读进来的时候就会出现乱码问题。</p>\n<p>java程序在运行时，jvm内存中的所有字符的表现形式都是UTF-16。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。</p>\n<p><strong>总结</strong>:Java语言中 不同字符集编码的转换 都是通过Unicode编码作为中介来完成的。</p>\n<ul>\n<li><h4 id=\"InputStreamReader与OutputStreamWriter\"><a href=\"#InputStreamReader与OutputStreamWriter\" class=\"headerlink\" title=\"InputStreamReader与OutputStreamWriter\"></a><strong>InputStreamReader与OutputStreamWriter</strong></h4></li>\n</ul>\n<img src=\"/2016/04/20/java中的编码问题/reader.png\" alt=\"reader.png\" title=\"\">\n<img src=\"/2016/04/20/java中的编码问题/writer.png\" alt=\"writer.png\" title=\"\">\n<p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。</p>\n<p>写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">String file = <span class=\"string\">\"c:/stream.txt\"</span>; </div><div class=\"line\">String charset = <span class=\"string\">\"UTF-8\"</span>; </div><div class=\"line\"><span class=\"comment\">// 写字符换转成字节流</span></div><div class=\"line\">FileOutputStream outputStream = <span class=\"keyword\">new</span> FileOutputStream(file); </div><div class=\"line\">OutputStreamWriter writer = <span class=\"keyword\">new</span> OutputStreamWriter( </div><div class=\"line\">outputStream, charset); </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   writer.write(<span class=\"string\">\"这是要保存的中文字符\"</span>); </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   writer.close(); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"comment\">// 读取字节转换成字符</span></div><div class=\"line\">FileInputStream inputStream = <span class=\"keyword\">new</span> FileInputStream(file); </div><div class=\"line\">InputStreamReader reader = <span class=\"keyword\">new</span> InputStreamReader( </div><div class=\"line\">inputStream, charset); </div><div class=\"line\">StringBuffer buffer = <span class=\"keyword\">new</span> StringBuffer(); </div><div class=\"line\"><span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">64</span>]; </div><div class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; </div><div class=\"line\"><span class=\"keyword\">try</span> &#123; </div><div class=\"line\">   <span class=\"keyword\">while</span> ((count = reader.read(buf)) != -<span class=\"number\">1</span>) &#123; </div><div class=\"line\">       buffer.append(buf, <span class=\"number\">0</span>, count); </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">   reader.close(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"String与byte\"><a href=\"#String与byte\" class=\"headerlink\" title=\"String与byte[]\"></a><strong>String与byte[]</strong></h4></li>\n</ul>\n<p>利用String类的getBytes()方法返回不同字符集的字节流数据，其本质是从Unicode字符集编码向其它字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"string\">\"中\"</span>;  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为系统默认编码的字节数组</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes1 = str.getBytes();  </div><div class=\"line\"><span class=\"comment\">// 将内存中的str(utf-16)转换为ISO-8859-1编码的字节数组                 </span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes2 = str.getBytes(<span class=\"string\">\"ISO-8859-1\"</span>);</div><div class=\"line\"><span class=\"comment\">// 正常显示中    </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes1));  </div><div class=\"line\"><span class=\"comment\">// 输出\"?\"      </span></div><div class=\"line\">System.out.println(<span class=\"keyword\">new</span> String(bytes2));</div></pre></td></tr></table></figure>\n<p>利用String类的构造方法根据不同字符集的字节流数据产生一个字符串对象，其本质是从其它字符集编码向Unicode字符集编码转换的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// GBK中0xD6 0xD0表示“中”，0x31表示字符“1”</span></div><div class=\"line\"><span class=\"keyword\">byte</span>[] bytes = &#123;(<span class=\"keyword\">byte</span>)<span class=\"number\">0xD6</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0xD0</span>, (<span class=\"keyword\">byte</span>)<span class=\"number\">0x31</span>&#125;;  </div><div class=\"line\"><span class=\"comment\">// 将bytes按照系统默认编码格式(GBK)解码,产生Unicode字符</span></div><div class=\"line\">String str1 = <span class=\"keyword\">new</span> String(bytes);                      </div><div class=\"line\"><span class=\"comment\">// 将bytes按照ISO-8859-1解码，产生Unicode字符</span></div><div class=\"line\">String str2= <span class=\"keyword\">new</span> String(bytes,<span class=\"string\">\"ISO-8859-1\"</span>);          </div><div class=\"line\"><span class=\"comment\">// 中1  将Unicode字符转换为GBK编码输出</span></div><div class=\"line\">System.out.println(str1);                             </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\"> *在ISO-8859-1编码方式中没有对应0xD6和0xD0</div><div class=\"line\"> *的字符，所以前两个字符会产生两个问号，由于0x31*在ISO-8859-1编码中对应字符“1”</div><div class=\"line\"> *（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。</div><div class=\"line\"> */</span> </div><div class=\"line\">System.out.println(str2);    <span class=\"comment\">// ??1</span></div></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"CharSet\"><a href=\"#CharSet\" class=\"headerlink\" title=\"CharSet\"></a><strong>CharSet</strong></h4></li>\n</ul>\n<p>从jdk1.4开始，java提供了Charset 类，这个类中提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = Charset.forName(<span class=\"string\">\"UTF-8\"</span>);   </div><div class=\"line\">ByteBuffer byteBuffer = charset.encode(string);   </div><div class=\"line\">CharBuffer charBuffer = charset.decode(byteBuffer);</div></pre></td></tr></table></figure>\n<h2 id=\"延伸-byte\"><a href=\"#延伸-byte\" class=\"headerlink\" title=\"延伸 byte\"></a>延伸 byte</h2><p>字节数据类型是一个8位有符号二进制补码整数。它具有-128最小值和127的最大值。</p>\n<p>无论是硬盘上数据的存放还是数据在网络上传输，其中的内容都是二进制数据。当你想把一些文本文件或者视频保存时，这些数据会转化为二进制序列存放于你的硬盘。同样，当你使用网络聊天，发语音和图片，程序都会将这些数据转化为（编码）二进制序列进行传输。在java中，这些二进制序列以两个字节为单位，使用Unicode字符集形成byte数组。程序处理的时候再把这些byte数组进行合适的处理（解码）呈现到屏幕上。</p>\n<p>有关byte与其他数据类型的转换不再多写，用到的时候再从网上查资料吧。只要知道其中的原理，soeasy.</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://cenalulu.github.io/linux/character-encoding/\">十分钟搞清字符集和字符编码</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\">字符编码笔记：ASCII，Unicode和UTF-8</a></p>\n<p><a href=\"http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/java-code-conversion-process.html\">java编码转换过程</a></p>\n<p><a href=\"http://blog.csdn.net/mazhimazh/article/details/19327421\">Java 7之基础 - 编码与解码</a></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/\">深入分析 Java 中的中文编码问题</a></p>\n"},{"layout":"post","title":"java同步锁锁什么","date":"2015-12-17T06:10:55.000Z","_content":"\n在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：\n情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;\nThreadTest中的成员变量 j 被赋值为 i \n在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;\n在synchronized块中，我改变了这个 j 的值。代码大概是这样的：\n\n```\t\t\t\t\t   \nInteger j;\nThreadTest(Integer i){\n\t\tj=i;\n}\npublic void run() {\n\t\tsynchronized(j){\n\t\t  j++;\n\t\t}\n}\n\n```\n\n1. 一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。\n\n2. 另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。\n\n苦逼了。结果不对\n后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，\n即 void test(Object  i){\n\t\ti.dosomething()......\n   }\n函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。\n这样就解释了出错的 原因：\nInteger 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。\n所以 \n\n对于 1. \n\n当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望\n\n对于 2. \n\n使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步\n\t\t\t\t\t\t\t\n上面的情况也证明了，**synchronized 锁的是内存 ，而不是指向内存的引用**。\n\t\t\t\t\t\t\t\n这样的情况也说明了另外一种情况的问题，那就是**在函数中给实参分配内存,实际在函数体外是得不到这个对象的**。\n\t\t\t\t\t\t\t\n解决的办法：\n放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，\n各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。","source":"_posts/java同步锁锁什么.md","raw":"---\nlayout: post\ntitle:  \"java同步锁锁什么\"\ndate:   2015-12-17 14:10:55\ncategories: 编程\ntags: \n- java\n- 多线程\n---\n\n在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：\n情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;\nThreadTest中的成员变量 j 被赋值为 i \n在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;\n在synchronized块中，我改变了这个 j 的值。代码大概是这样的：\n\n```\t\t\t\t\t   \nInteger j;\nThreadTest(Integer i){\n\t\tj=i;\n}\npublic void run() {\n\t\tsynchronized(j){\n\t\t  j++;\n\t\t}\n}\n\n```\n\n1. 一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。\n\n2. 另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。\n\n苦逼了。结果不对\n后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，\n即 void test(Object  i){\n\t\ti.dosomething()......\n   }\n函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。\n这样就解释了出错的 原因：\nInteger 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。\n所以 \n\n对于 1. \n\n当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望\n\n对于 2. \n\n使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步\n\t\t\t\t\t\t\t\n上面的情况也证明了，**synchronized 锁的是内存 ，而不是指向内存的引用**。\n\t\t\t\t\t\t\t\n这样的情况也说明了另外一种情况的问题，那就是**在函数中给实参分配内存,实际在函数体外是得不到这个对象的**。\n\t\t\t\t\t\t\t\n解决的办法：\n放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，\n各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。","slug":"java同步锁锁什么","published":1,"updated":"2016-08-14T08:26:27.914Z","comments":1,"photos":[],"link":"","_id":"cirucnp8v000ojkqcpyix0ljy","content":"<p>在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：<br>情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;<br>ThreadTest中的成员变量 j 被赋值为 i<br>在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;<br>在synchronized块中，我改变了这个 j 的值。代码大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer j;</div><div class=\"line\">ThreadTest(Integer i)&#123;</div><div class=\"line\">\t\tj=i;</div><div class=\"line\">&#125;</div><div class=\"line\">public void run() &#123;</div><div class=\"line\">\t\tsynchronized(j)&#123;</div><div class=\"line\">\t\t  j++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。</p>\n</li>\n<li><p>另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。</p>\n</li>\n</ol>\n<p>苦逼了。结果不对<br>后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，<br>即 void test(Object  i){<br>        i.dosomething()……<br>   }<br>函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。<br>这样就解释了出错的 原因：<br>Integer 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。<br>所以 </p>\n<p>对于 1. </p>\n<p>当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望</p>\n<p>对于 2. </p>\n<p>使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步</p>\n<p>上面的情况也证明了，<strong>synchronized 锁的是内存 ，而不是指向内存的引用</strong>。</p>\n<p>这样的情况也说明了另外一种情况的问题，那就是<strong>在函数中给实参分配内存,实际在函数体外是得不到这个对象的</strong>。</p>\n<p>解决的办法：<br>放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，<br>各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。</p>\n","excerpt":"","more":"<p>在今天的苦逼遍代码的过程中，有这样一个问题困扰了我半天：<br>情景是这样的：有N个线程ThreadTest，在类A中被创建。构造ThreadTest，向其传入A中的成员变量 Integer i;<br>ThreadTest中的成员变量 j 被赋值为 i<br>在 ThreadTest 的 run 方法中，我 加入了 synchronized块，对象锁正是 j ;<br>在synchronized块中，我改变了这个 j 的值。代码大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer j;</div><div class=\"line\">ThreadTest(Integer i)&#123;</div><div class=\"line\">\t\tj=i;</div><div class=\"line\">&#125;</div><div class=\"line\">public void run() &#123;</div><div class=\"line\">\t\tsynchronized(j)&#123;</div><div class=\"line\">\t\t  j++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>一方面 我希望这N个线程操作的是同一个 Integer （引用），我需要多个线程改变这个 Integer 的值 来更新进度条。</p>\n</li>\n<li><p>另一方面，各个线程之间还要互斥地访问这个变量。于是有了上面的写法。</p>\n</li>\n</ol>\n<p>苦逼了。结果不对<br>后来想了想，发现了这样一个问题：当调用 Java 中的一个函数的时候传入实参对象引用，在这个函数内部会将这个引用复制一份，<br>即 void test(Object  i){<br>        i.dosomething()……<br>   }<br>函数体中的i 与 传入的实参 i 实际上是两个不同的引用 指向了同一份内存。<br>这样就解释了出错的 原因：<br>Integer 是不可变类 当对 Integer 进行加减操作时，会 重新new 一份出来赋给 原来的引用变量。<br>所以 </p>\n<p>对于 1. </p>\n<p>当执行j++ 的时候，j已经指向了另一个内存 此时 这个 j 与其他线程中的 j 都不是同一个对象了 无法实现操作同一个对象的愿望</p>\n<p>对于 2. </p>\n<p>使用 synchronized块，对象锁为 j ,这个时候各个线程中的j 已经不是同一个对象了 所以就无法同步</p>\n<p>上面的情况也证明了，<strong>synchronized 锁的是内存 ，而不是指向内存的引用</strong>。</p>\n<p>这样的情况也说明了另外一种情况的问题，那就是<strong>在函数中给实参分配内存,实际在函数体外是得不到这个对象的</strong>。</p>\n<p>解决的办法：<br>放弃使用 Integer（当初使用Integer而不是int的原因就在于各个线程希望操作同一个对象），用一个类将int 封装起来，将这个类对象作为同步关键字，<br>各个线程操作这个对象中的 int 。这样，所有的线程都在修改同一份内存里的东西。</p>\n"},{"layout":"post","title":"java源码阅读-Arraylist","date":"2016-07-12T04:48:55.000Z","_content":"\n>上班半个月了，有点迷茫，不知道自己该学点什么。什么都想学，什么都不会。看到网上的[一篇文章](http://www.iteye.com/topic/1113732)，我觉得自己也该看点源码之类的了，不能总是抱着设计模式，JVM的书啃(还都没怎么看)。前两天尝试自己封装一下JDBC的测试代码，改了又改，总觉得不对劲，遂放弃。是时候看看大神的代码来吸取点经验了，希望有所收获。\n\n我决定根据上面文章中作者提到的学习路径去看代码，首先就是JDK中的核心代码。第一篇就来研究一下JAVA中的集合类-Arraylist。\n\n## 1.集合基础\n\njava有一套[集合框架](http://docs.oracle.com/javase/tutorial/collections/index.html)，Arraylist等集合类都是这个框架的成员。首先看一下最顶层的几个接口：\n\n<img src=\"http://docs.oracle.com/javase/tutorial/figures/collections/colls-coreInterfaces.gif\" width=\"800\" height=\"600\"  /> \n\n\n\n\n\n\n\n","source":"_posts/java源码阅读-集合类-ArrayList.md","raw":"---\nlayout: post\ntitle: \"java源码阅读-Arraylist\"\ncategories: 编程 \ntags: \n- java\ndate:   2016-07-12 12:48:55\n---\n\n>上班半个月了，有点迷茫，不知道自己该学点什么。什么都想学，什么都不会。看到网上的[一篇文章](http://www.iteye.com/topic/1113732)，我觉得自己也该看点源码之类的了，不能总是抱着设计模式，JVM的书啃(还都没怎么看)。前两天尝试自己封装一下JDBC的测试代码，改了又改，总觉得不对劲，遂放弃。是时候看看大神的代码来吸取点经验了，希望有所收获。\n\n我决定根据上面文章中作者提到的学习路径去看代码，首先就是JDK中的核心代码。第一篇就来研究一下JAVA中的集合类-Arraylist。\n\n## 1.集合基础\n\njava有一套[集合框架](http://docs.oracle.com/javase/tutorial/collections/index.html)，Arraylist等集合类都是这个框架的成员。首先看一下最顶层的几个接口：\n\n<img src=\"http://docs.oracle.com/javase/tutorial/figures/collections/colls-coreInterfaces.gif\" width=\"800\" height=\"600\"  /> \n\n\n\n\n\n\n\n","slug":"java源码阅读-集合类-ArrayList","published":1,"updated":"2016-08-14T08:26:27.920Z","comments":1,"photos":[],"link":"","_id":"cirucnp8z000rjkqclbimqk1u","content":"<blockquote>\n<p>上班半个月了，有点迷茫，不知道自己该学点什么。什么都想学，什么都不会。看到网上的<a href=\"http://www.iteye.com/topic/1113732\" target=\"_blank\" rel=\"external\">一篇文章</a>，我觉得自己也该看点源码之类的了，不能总是抱着设计模式，JVM的书啃(还都没怎么看)。前两天尝试自己封装一下JDBC的测试代码，改了又改，总觉得不对劲，遂放弃。是时候看看大神的代码来吸取点经验了，希望有所收获。</p>\n</blockquote>\n<p>我决定根据上面文章中作者提到的学习路径去看代码，首先就是JDK中的核心代码。第一篇就来研究一下JAVA中的集合类-Arraylist。</p>\n<h2 id=\"1-集合基础\"><a href=\"#1-集合基础\" class=\"headerlink\" title=\"1.集合基础\"></a>1.集合基础</h2><p>java有一套<a href=\"http://docs.oracle.com/javase/tutorial/collections/index.html\" target=\"_blank\" rel=\"external\">集合框架</a>，Arraylist等集合类都是这个框架的成员。首先看一下最顶层的几个接口：</p>\n<p><img src=\"http://docs.oracle.com/javase/tutorial/figures/collections/colls-coreInterfaces.gif\" width=\"800\" height=\"600\"> </p>\n","excerpt":"","more":"<blockquote>\n<p>上班半个月了，有点迷茫，不知道自己该学点什么。什么都想学，什么都不会。看到网上的<a href=\"http://www.iteye.com/topic/1113732\">一篇文章</a>，我觉得自己也该看点源码之类的了，不能总是抱着设计模式，JVM的书啃(还都没怎么看)。前两天尝试自己封装一下JDBC的测试代码，改了又改，总觉得不对劲，遂放弃。是时候看看大神的代码来吸取点经验了，希望有所收获。</p>\n</blockquote>\n<p>我决定根据上面文章中作者提到的学习路径去看代码，首先就是JDK中的核心代码。第一篇就来研究一下JAVA中的集合类-Arraylist。</p>\n<h2 id=\"1-集合基础\"><a href=\"#1-集合基础\" class=\"headerlink\" title=\"1.集合基础\"></a>1.集合基础</h2><p>java有一套<a href=\"http://docs.oracle.com/javase/tutorial/collections/index.html\">集合框架</a>，Arraylist等集合类都是这个框架的成员。首先看一下最顶层的几个接口：</p>\n<p><img src=\"http://docs.oracle.com/javase/tutorial/figures/collections/colls-coreInterfaces.gif\" width=\"800\" height=\"600\"  /> </p>\n"},{"layout":"post","date":"2016-04-12T04:48:55.000Z","title":"Junit的使用","_content":"\n>[Junit](http://junit.org/junit4/)是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。\n\n\n\n\n\n\n\n**资料**\n\n[Unit Testing with JUnit - Tutorial](http://www.vogella.com/tutorials/JUnit/article.html)\n\n[JUnit Tutorial](http://www.tutorialspoint.com/junit/)\n\n[走进java测试利器-junit](http://developer.51cto.com/art/201103/252490.htm)\n\n","source":"_posts/junit使用.md","raw":"---\nlayout: post\ndate:   2016-04-12 12:48:55\ntitle: \"Junit的使用\"\ncategories: 工具\ntags: \n- junit\n- 测试\n---\n\n>[Junit](http://junit.org/junit4/)是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。\n\n\n\n\n\n\n\n**资料**\n\n[Unit Testing with JUnit - Tutorial](http://www.vogella.com/tutorials/JUnit/article.html)\n\n[JUnit Tutorial](http://www.tutorialspoint.com/junit/)\n\n[走进java测试利器-junit](http://developer.51cto.com/art/201103/252490.htm)\n\n","slug":"junit使用","published":1,"updated":"2016-08-14T08:26:27.926Z","comments":1,"photos":[],"link":"","_id":"cirucnp94000wjkqctkiprdot","content":"<blockquote>\n<p><a href=\"http://junit.org/junit4/\" target=\"_blank\" rel=\"external\">Junit</a>是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。</p>\n</blockquote>\n<p><strong>资料</strong></p>\n<p><a href=\"http://www.vogella.com/tutorials/JUnit/article.html\" target=\"_blank\" rel=\"external\">Unit Testing with JUnit - Tutorial</a></p>\n<p><a href=\"http://www.tutorialspoint.com/junit/\" target=\"_blank\" rel=\"external\">JUnit Tutorial</a></p>\n<p><a href=\"http://developer.51cto.com/art/201103/252490.htm\" target=\"_blank\" rel=\"external\">走进java测试利器-junit</a></p>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"http://junit.org/junit4/\">Junit</a>是一个Java语言的单元测试框架。利用这个框架编写测试用例，junit会按照规则自动对你要测试的代码进行测试，并给出测试结果。</p>\n</blockquote>\n<p><strong>资料</strong></p>\n<p><a href=\"http://www.vogella.com/tutorials/JUnit/article.html\">Unit Testing with JUnit - Tutorial</a></p>\n<p><a href=\"http://www.tutorialspoint.com/junit/\">JUnit Tutorial</a></p>\n<p><a href=\"http://developer.51cto.com/art/201103/252490.htm\">走进java测试利器-junit</a></p>\n"},{"layout":"post","title":"Markdown","date":"2016-03-03T14:10:55.000Z","_content":"\n>[Markdown][markdown-com] 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。\n\n# 常用语法\n \n makedown 语法  \n\n---\n\n## 代码\n\n\\`\\`\\`\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\\`\\`\\`\n\nUse the \\`printf()` function.\n\n---\n\n\n## 标题\n\n\\# 标题1\n\n\\## 标题2\n\n\\### 标题3\n\n\\#### 标题4\n\n\\##### 标题5\n\n\\###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n\n2. 有序列表2\n\n\n\\- 无序列表1\n\n\\- 无序列表2\n\n\\* 无序列表3\n\n\\+ 无序列表4\n\n---\n\n## 链接\n\n\\[谷歌](http://www.google.com)\n\n这是一个 \\[例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 \\[例子] \\[id] 参考链接.\n\n\\[id]: http://google.com/ \"google\"\n\n\n自动链接\n\n```\n<http://example.com/>\n```\n\n---\n\n## 图片\n\n行内链接：\n\\!\\[](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n\\!\\[img]\n\n\\[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n```\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n```\n---\n\n## 引用\n\n\\> 引用\n\n\\>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n\\*这里是斜体\\*\n\n\\*\\*这里是粗体\\*\\*\n\n\\*\\*\\*这里是粗斜体\\*\\*\\*\n\n---\n\n## 表格\n\ndog \\| bird \\| cat\n\n----\\|------\\|----\n\nfoo \\| foo  \\| foo\n\nbar \\| bar  \\| bar\n\nbaz \\| baz  \\| baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\\\   反斜线\n  \n   \\\\`   反引号\n   \n   \\\\*   星号\n   \n   \\\\_   底线\n   \n   \\\\{}  花括号\n   \n   \\\\[]  方括号\n   \n   \\\\()  括弧\n   \n   \\\\#   井字号\n   \n   \\\\+   加号\n   \n   \\\\-   减号\n   \n   \\\\.   英文句点\n   \n   \\\\!   惊叹号\n\n---\n\n## 删除线\n\n\\~~删除这里的内容~~\n\n---\n\n\n\n\n# 效果\n\nmakedown 语法  \n---\n\n## 代码\n\n```\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\n```\n\nUse the `printf()` function.\n\n---\n\n\n## 标题\n\n# 标题1\n\n## 标题2\n\n### 标题3\n\n#### 标题4\n\n##### 标题5\n\n###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n2. 有序列表2\n\n\n- 无序列表1\n- 无序列表2\n* 无序列表3\n+ 无序列表4\n\n---\n\n## 链接\n\n[谷歌](http://www.google.com)\n\n这是一个 [例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 [例子] [id] 参考链接.\n[id]: http://google.com/  \"google\"\n\n\n自动链接\n<http://example.com/>\n\n---\n\n## 图片\n\n行内链接：\n![](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n![img]\n\n[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n\n---\n\n## 引用\n\n> 引用\n\n>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n*这里是斜体*\n\n**这里是粗体**\n\n***这里是粗斜体***\n\n---\n\n## 表格\n\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\   反斜线\n  \n   \\`   反引号\n   \n   \\*   星号\n   \n   \\_   底线\n   \n   \\{}  花括号\n   \n   \\[]  方括号\n   \n   \\()  括弧\n   \n   \\#   井字号\n   \n   \\+   加号\n   \n   \\-   减号\n   \n   \\.   英文句点\n   \n   \\!   惊叹号\n\n---\n\n## 删除线\n\n~~删除这里的内容~~\n\n---\n\n## 一些参考\n\n[Markdown 语法说明 (简体中文版)](http://www.markdown.cn/)\n\n[Markdown 维基百科 ](https://zh.wikipedia.org/wiki/Markdown)\n\n---\n\n[markdown-com]:      http://wowubuntu.com/markdown/\n","source":"_posts/markdown.md","raw":"---\nlayout: post\ntitle:  \"Markdown\"\ndate:   2016-03-03 22:10:55\ncategories: 工具\ntags: \n- markdown\n---\n\n>[Markdown][markdown-com] 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。\n\n# 常用语法\n \n makedown 语法  \n\n---\n\n## 代码\n\n\\`\\`\\`\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\\`\\`\\`\n\nUse the \\`printf()` function.\n\n---\n\n\n## 标题\n\n\\# 标题1\n\n\\## 标题2\n\n\\### 标题3\n\n\\#### 标题4\n\n\\##### 标题5\n\n\\###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n\n2. 有序列表2\n\n\n\\- 无序列表1\n\n\\- 无序列表2\n\n\\* 无序列表3\n\n\\+ 无序列表4\n\n---\n\n## 链接\n\n\\[谷歌](http://www.google.com)\n\n这是一个 \\[例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 \\[例子] \\[id] 参考链接.\n\n\\[id]: http://google.com/ \"google\"\n\n\n自动链接\n\n```\n<http://example.com/>\n```\n\n---\n\n## 图片\n\n行内链接：\n\\!\\[](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n\\!\\[img]\n\n\\[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n```\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n```\n---\n\n## 引用\n\n\\> 引用\n\n\\>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n\\*这里是斜体\\*\n\n\\*\\*这里是粗体\\*\\*\n\n\\*\\*\\*这里是粗斜体\\*\\*\\*\n\n---\n\n## 表格\n\ndog \\| bird \\| cat\n\n----\\|------\\|----\n\nfoo \\| foo  \\| foo\n\nbar \\| bar  \\| bar\n\nbaz \\| baz  \\| baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\\\   反斜线\n  \n   \\\\`   反引号\n   \n   \\\\*   星号\n   \n   \\\\_   底线\n   \n   \\\\{}  花括号\n   \n   \\\\[]  方括号\n   \n   \\\\()  括弧\n   \n   \\\\#   井字号\n   \n   \\\\+   加号\n   \n   \\\\-   减号\n   \n   \\\\.   英文句点\n   \n   \\\\!   惊叹号\n\n---\n\n## 删除线\n\n\\~~删除这里的内容~~\n\n---\n\n\n\n\n# 效果\n\nmakedown 语法  \n---\n\n## 代码\n\n```\npublic void main(String args[]){\n    System.out.print(\"Hello World\");\n}\n\n```\n\nUse the `printf()` function.\n\n---\n\n\n## 标题\n\n# 标题1\n\n## 标题2\n\n### 标题3\n\n#### 标题4\n\n##### 标题5\n\n###### 标题6\n\n---\n\n## 列表\n\n1. 有序列表1\n2. 有序列表2\n\n\n- 无序列表1\n- 无序列表2\n* 无序列表3\n+ 无序列表4\n\n---\n\n## 链接\n\n[谷歌](http://www.google.com)\n\n这是一个 [例子](http://google.com/ \"google\") 行内链接.\n\n这是一个 [例子] [id] 参考链接.\n[id]: http://google.com/  \"google\"\n\n\n自动链接\n<http://example.com/>\n\n---\n\n## 图片\n\n行内链接：\n![](http://img3.3lian.com/2013/s1/65/d/104.jpg)\n\n参考链接：\n![img]\n\n[img]:http://img3.3lian.com/2013/s1/65/d/104.jpg\n\n指定宽高：需用html标记\n\n<img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  \n\n---\n\n## 引用\n\n> 引用\n\n>> 嵌套引用\n\n---\n\n## 粗体 斜体\n\n*这里是斜体*\n\n**这里是粗体**\n\n***这里是粗斜体***\n\n---\n\n## 表格\n\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n\n---\n## 转义 \n   利用 *\\\\* 进行转义 \n    \n   \\\\   反斜线\n  \n   \\`   反引号\n   \n   \\*   星号\n   \n   \\_   底线\n   \n   \\{}  花括号\n   \n   \\[]  方括号\n   \n   \\()  括弧\n   \n   \\#   井字号\n   \n   \\+   加号\n   \n   \\-   减号\n   \n   \\.   英文句点\n   \n   \\!   惊叹号\n\n---\n\n## 删除线\n\n~~删除这里的内容~~\n\n---\n\n## 一些参考\n\n[Markdown 语法说明 (简体中文版)](http://www.markdown.cn/)\n\n[Markdown 维基百科 ](https://zh.wikipedia.org/wiki/Markdown)\n\n---\n\n[markdown-com]:      http://wowubuntu.com/markdown/\n","slug":"markdown","published":1,"updated":"2016-08-14T08:26:27.932Z","comments":1,"photos":[],"link":"","_id":"cirucnp97000zjkqcacgpqzmx","content":"<blockquote>\n<p><a href=\"http://wowubuntu.com/markdown/\" target=\"_blank\" rel=\"external\">Markdown</a> 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>\n</blockquote>\n<p> 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。</p>\n<h1 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h1><p> makedown 语法  </p>\n<hr>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>```<br>public void main(String args[]){<br>    System.out.print(“Hello World”);<br>}<br>```</p>\n<p>Use the `printf()` function.</p>\n<hr>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p># 标题1</p>\n<p>## 标题2</p>\n<p>### 标题3</p>\n<p>#### 标题4</p>\n<p>##### 标题5</p>\n<p>###### 标题6</p>\n<hr>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li><p>有序列表1</p>\n</li>\n<li><p>有序列表2</p>\n</li>\n</ol>\n<p>- 无序列表1</p>\n<p>- 无序列表2</p>\n<p>* 无序列表3</p>\n<p>+ 无序列表4</p>\n<hr>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>[谷歌](<a href=\"http://www.google.com\" target=\"_blank\" rel=\"external\">http://www.google.com</a>)</p>\n<p>这是一个 [例子](<a href=\"http://google.com/\" target=\"_blank\" rel=\"external\">http://google.com/</a> “google”) 行内链接.</p>\n<p>这是一个 [例子] [id] 参考链接.</p>\n<p>[id]: <a href=\"http://google.com/\" target=\"_blank\" rel=\"external\">http://google.com/</a> “google”</p>\n<p>自动链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;http://example.com/&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br>![](<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" target=\"_blank\" rel=\"external\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a>)</p>\n<p>参考链接：<br>![img]</p>\n<p>[img]:<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" target=\"_blank\" rel=\"external\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a></p>\n<p>指定宽高：需用html标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;img src=&quot;http://img3.3lian.com/2013/s1/65/d/104.jpg&quot; width=&quot;200&quot; height=&quot;128&quot;  /&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>> 引用</p>\n<p>>&gt; 嵌套引用</p>\n<hr>\n<h2 id=\"粗体-斜体\"><a href=\"#粗体-斜体\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p>*这里是斜体*</p>\n<p>**这里是粗体**</p>\n<p>***这里是粗斜体***</p>\n<hr>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>dog | bird | cat</p>\n<p>—-|——|—-</p>\n<p>foo | foo  | foo</p>\n<p>bar | bar  | bar</p>\n<p>baz | baz  | baz</p>\n<hr>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\\\   反斜线</p>\n<p>   \\`   反引号</p>\n<p>   \\*   星号</p>\n<p>   \\_   底线</p>\n<p>   \\{}  花括号</p>\n<p>   \\[]  方括号</p>\n<p>   \\()  括弧</p>\n<p>   \\#   井字号</p>\n<p>   \\+   加号</p>\n<p>   \\-   减号</p>\n<p>   \\.   英文句点</p>\n<p>   \\!   惊叹号</p>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>~~删除这里的内容~~</p>\n<hr>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><h2 id=\"makedown-语法\"><a href=\"#makedown-语法\" class=\"headerlink\" title=\"makedown 语法  \"></a>makedown 语法  </h2><h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void main(String args[])&#123;</div><div class=\"line\">    System.out.print(&quot;Hello World&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Use the <code>printf()</code> function.</p>\n<hr>\n<h2 id=\"标题-1\"><a href=\"#标题-1\" class=\"headerlink\" title=\"标题\"></a>标题</h2><h1 id=\"标题1\"><a href=\"#标题1\" class=\"headerlink\" title=\"标题1\"></a>标题1</h1><h2 id=\"标题2\"><a href=\"#标题2\" class=\"headerlink\" title=\"标题2\"></a>标题2</h2><h3 id=\"标题3\"><a href=\"#标题3\" class=\"headerlink\" title=\"标题3\"></a>标题3</h3><h4 id=\"标题4\"><a href=\"#标题4\" class=\"headerlink\" title=\"标题4\"></a>标题4</h4><h5 id=\"标题5\"><a href=\"#标题5\" class=\"headerlink\" title=\"标题5\"></a>标题5</h5><h6 id=\"标题6\"><a href=\"#标题6\" class=\"headerlink\" title=\"标题6\"></a>标题6</h6><hr>\n<h2 id=\"列表-1\"><a href=\"#列表-1\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n</ul>\n<ul>\n<li>无序列表3</li>\n</ul>\n<ul>\n<li>无序列表4</li>\n</ul>\n<hr>\n<h2 id=\"链接-1\"><a href=\"#链接-1\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://www.google.com\" target=\"_blank\" rel=\"external\">谷歌</a></p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\" target=\"_blank\" rel=\"external\">例子</a> 行内链接.</p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\" target=\"_blank\" rel=\"external\">例子</a> 参考链接.</p>\n<p>自动链接<br><a href=\"http://example.com/\" target=\"_blank\" rel=\"external\">http://example.com/</a></p>\n<hr>\n<h2 id=\"图片-1\"><a href=\"#图片-1\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"\"></p>\n<p>参考链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"img\"></p>\n<p>指定宽高：需用html标记</p>\n<p><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\">  </p>\n<hr>\n<h2 id=\"引用-1\"><a href=\"#引用-1\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>引用</p>\n<blockquote>\n<p>嵌套引用</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"粗体-斜体-1\"><a href=\"#粗体-斜体-1\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p><em>这里是斜体</em></p>\n<p><strong>这里是粗体</strong></p>\n<p><strong><em>这里是粗斜体</em></strong></p>\n<hr>\n<h2 id=\"表格-1\"><a href=\"#表格-1\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th>dog</th>\n<th>bird</th>\n<th>cat</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>foo</td>\n<td>foo</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>bar</td>\n<td>bar</td>\n</tr>\n<tr>\n<td>baz</td>\n<td>baz</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"转义-1\"><a href=\"#转义-1\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\   反斜线</p>\n<p>   `   反引号</p>\n<p>   *   星号</p>\n<p>   _   底线</p>\n<p>   {}  花括号</p>\n<p>   []  方括号</p>\n<p>   ()  括弧</p>\n<p>   #   井字号</p>\n<p>   +   加号</p>\n<p>   -   减号</p>\n<p>   .   英文句点</p>\n<p>   !   惊叹号</p>\n<hr>\n<h2 id=\"删除线-1\"><a href=\"#删除线-1\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p><del>删除这里的内容</del></p>\n<hr>\n<h2 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h2><p><a href=\"http://www.markdown.cn/\" target=\"_blank\" rel=\"external\">Markdown 语法说明 (简体中文版)</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"external\">Markdown 维基百科 </a></p>\n<hr>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"http://wowubuntu.com/markdown/\">Markdown</a> 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>\n</blockquote>\n<p> 即：Markdown 就是一种类似于Html的标记语言，比Html更简单，通过转换之后使普通文本内容具有一定的格式。</p>\n<h1 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h1><p> makedown 语法  </p>\n<hr>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>```<br>public void main(String args[]){<br>    System.out.print(“Hello World”);<br>}<br>```</p>\n<p>Use the `printf()` function.</p>\n<hr>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p># 标题1</p>\n<p>## 标题2</p>\n<p>### 标题3</p>\n<p>#### 标题4</p>\n<p>##### 标题5</p>\n<p>###### 标题6</p>\n<hr>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li><p>有序列表1</p>\n</li>\n<li><p>有序列表2</p>\n</li>\n</ol>\n<p>- 无序列表1</p>\n<p>- 无序列表2</p>\n<p>* 无序列表3</p>\n<p>+ 无序列表4</p>\n<hr>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>[谷歌](<a href=\"http://www.google.com\">http://www.google.com</a>)</p>\n<p>这是一个 [例子](<a href=\"http://google.com/\">http://google.com/</a> “google”) 行内链接.</p>\n<p>这是一个 [例子] [id] 参考链接.</p>\n<p>[id]: <a href=\"http://google.com/\">http://google.com/</a> “google”</p>\n<p>自动链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;http://example.com/&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br>![](<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a>)</p>\n<p>参考链接：<br>![img]</p>\n<p>[img]:<a href=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\">http://img3.3lian.com/2013/s1/65/d/104.jpg</a></p>\n<p>指定宽高：需用html标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;img src=&quot;http://img3.3lian.com/2013/s1/65/d/104.jpg&quot; width=&quot;200&quot; height=&quot;128&quot;  /&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>> 引用</p>\n<p>>&gt; 嵌套引用</p>\n<hr>\n<h2 id=\"粗体-斜体\"><a href=\"#粗体-斜体\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p>*这里是斜体*</p>\n<p>**这里是粗体**</p>\n<p>***这里是粗斜体***</p>\n<hr>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>dog | bird | cat</p>\n<p>—-|——|—-</p>\n<p>foo | foo  | foo</p>\n<p>bar | bar  | bar</p>\n<p>baz | baz  | baz</p>\n<hr>\n<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\\\   反斜线</p>\n<p>   \\`   反引号</p>\n<p>   \\*   星号</p>\n<p>   \\_   底线</p>\n<p>   \\{}  花括号</p>\n<p>   \\[]  方括号</p>\n<p>   \\()  括弧</p>\n<p>   \\#   井字号</p>\n<p>   \\+   加号</p>\n<p>   \\-   减号</p>\n<p>   \\.   英文句点</p>\n<p>   \\!   惊叹号</p>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>~~删除这里的内容~~</p>\n<hr>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><h2 id=\"makedown-语法\"><a href=\"#makedown-语法\" class=\"headerlink\" title=\"makedown 语法  \"></a>makedown 语法  </h2><h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void main(String args[])&#123;</div><div class=\"line\">    System.out.print(&quot;Hello World&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Use the <code>printf()</code> function.</p>\n<hr>\n<h2 id=\"标题-1\"><a href=\"#标题-1\" class=\"headerlink\" title=\"标题\"></a>标题</h2><h1 id=\"标题1\"><a href=\"#标题1\" class=\"headerlink\" title=\"标题1\"></a>标题1</h1><h2 id=\"标题2\"><a href=\"#标题2\" class=\"headerlink\" title=\"标题2\"></a>标题2</h2><h3 id=\"标题3\"><a href=\"#标题3\" class=\"headerlink\" title=\"标题3\"></a>标题3</h3><h4 id=\"标题4\"><a href=\"#标题4\" class=\"headerlink\" title=\"标题4\"></a>标题4</h4><h5 id=\"标题5\"><a href=\"#标题5\" class=\"headerlink\" title=\"标题5\"></a>标题5</h5><h6 id=\"标题6\"><a href=\"#标题6\" class=\"headerlink\" title=\"标题6\"></a>标题6</h6><hr>\n<h2 id=\"列表-1\"><a href=\"#列表-1\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n</ul>\n<ul>\n<li>无序列表3</li>\n</ul>\n<ul>\n<li>无序列表4</li>\n</ul>\n<hr>\n<h2 id=\"链接-1\"><a href=\"#链接-1\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://www.google.com\">谷歌</a></p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\">例子</a> 行内链接.</p>\n<p>这是一个 <a href=\"http://google.com/\" title=\"google\">例子</a> 参考链接.</p>\n<p>自动链接<br><a href=\"http://example.com/\">http://example.com/</a></p>\n<hr>\n<h2 id=\"图片-1\"><a href=\"#图片-1\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>行内链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"\"></p>\n<p>参考链接：<br><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" alt=\"img\"></p>\n<p>指定宽高：需用html标记</p>\n<p><img src=\"http://img3.3lian.com/2013/s1/65/d/104.jpg\" width=\"200\" height=\"128\"  />  </p>\n<hr>\n<h2 id=\"引用-1\"><a href=\"#引用-1\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>引用</p>\n<blockquote>\n<p>嵌套引用</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"粗体-斜体-1\"><a href=\"#粗体-斜体-1\" class=\"headerlink\" title=\"粗体 斜体\"></a>粗体 斜体</h2><p><em>这里是斜体</em></p>\n<p><strong>这里是粗体</strong></p>\n<p><strong><em>这里是粗斜体</em></strong></p>\n<hr>\n<h2 id=\"表格-1\"><a href=\"#表格-1\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th>dog</th>\n<th>bird</th>\n<th>cat</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>foo</td>\n<td>foo</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>bar</td>\n<td>bar</td>\n</tr>\n<tr>\n<td>baz</td>\n<td>baz</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"转义-1\"><a href=\"#转义-1\" class=\"headerlink\" title=\"转义\"></a>转义</h2><p>   利用 <em>\\</em> 进行转义 </p>\n<p>   \\   反斜线</p>\n<p>   `   反引号</p>\n<p>   *   星号</p>\n<p>   _   底线</p>\n<p>   {}  花括号</p>\n<p>   []  方括号</p>\n<p>   ()  括弧</p>\n<p>   #   井字号</p>\n<p>   +   加号</p>\n<p>   -   减号</p>\n<p>   .   英文句点</p>\n<p>   !   惊叹号</p>\n<hr>\n<h2 id=\"删除线-1\"><a href=\"#删除线-1\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p><del>删除这里的内容</del></p>\n<hr>\n<h2 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h2><p><a href=\"http://www.markdown.cn/\">Markdown 语法说明 (简体中文版)</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\">Markdown 维基百科 </a></p>\n<hr>\n"},{"layout":"post","title":"notify 问题","date":"2015-12-21T04:48:55.000Z","_content":"\n今天遇到了这么个情况：\n有线程若干，我需要他们按顺序执行。\n代码大概长这样：\n\n```\nclass SyncTag {\n\tpublic int threadNO;\n\tpublic SyncTag() {\n\t    threadNO = 0;\n\t}\n}\nclass ThreadA extend Thread{\n\tSyncTag syncTag;\n\tint scriptNO;\n\tThreadA(SyncTag syncTag,int scriptNO){\n\t\t\tthis.syncTag=syncTag;\n\t\t\tthis.scriptNO=scriptNO;\n\t}\n\tpublic void Run(){\n\t\t\tsynchronized (syncTag) {\n                if (syncTag.threadNO != scriptNO) {\n                        try {\n                                syncTag.wait();\n                        } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                        }\n                }\n                dosomething();\n                syncTag.threadNO++;\n                syncTag.notifyAll();\n\t\t\t}\n\t}\n}\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t    SyncTag syncTag=new SyncTag();\n\t\t\tfor(int i=0;i<10;++i){\n\t\t\t\tThreadA t=new ThreadA(syncTag,i);\n\t\t\t\tt.start();\n\t\t\t}\n\t}\n}\n```\n\n结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。\n研究一番，发现是 notify 与notifyAll 在捣鬼。\n当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。\n其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。\n\t\t \n当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，\n剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，\n没抢到的老实等着。\n\t\t \n这就是notify 与 notifyAll两者的区别.\n\t\t \n那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。\n原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合\nsyncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，\n如果不符合，就继续wait.符合则执行。\n很简单，将 \n\n```java\nif (syncTag.threadNO != scriptNO) {\n        try {\n                syncTag.wait();\n            } catch (InterruptedException e) {\n                                    e.printStackTrace();\n            }\n}\n```\n\n这部分代码 改为： \n\n```java\nwhile (syncTag.threadNO != scriptNO) {\n\t\ttry {\n\t\t\t\tsyncTag.wait();\n\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n这个问题就解决了。\n\t \n## **延伸**：\n假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：\n设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO\n这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们\n中的一个。于是陷入死锁，无尽的等待。\n\t\t \n所以，具体使用notify还是notifyAll 就得具体情况具体分析了。","source":"_posts/notify问题.md","raw":"---\nlayout: post\ntitle:  \"notify 问题\"\ndate:   2015-12-21 12:48:55\ncategories: 编程\ntags:\n- java\n- 多线程 \n---\n\n今天遇到了这么个情况：\n有线程若干，我需要他们按顺序执行。\n代码大概长这样：\n\n```\nclass SyncTag {\n\tpublic int threadNO;\n\tpublic SyncTag() {\n\t    threadNO = 0;\n\t}\n}\nclass ThreadA extend Thread{\n\tSyncTag syncTag;\n\tint scriptNO;\n\tThreadA(SyncTag syncTag,int scriptNO){\n\t\t\tthis.syncTag=syncTag;\n\t\t\tthis.scriptNO=scriptNO;\n\t}\n\tpublic void Run(){\n\t\t\tsynchronized (syncTag) {\n                if (syncTag.threadNO != scriptNO) {\n                        try {\n                                syncTag.wait();\n                        } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                        }\n                }\n                dosomething();\n                syncTag.threadNO++;\n                syncTag.notifyAll();\n\t\t\t}\n\t}\n}\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t    SyncTag syncTag=new SyncTag();\n\t\t\tfor(int i=0;i<10;++i){\n\t\t\t\tThreadA t=new ThreadA(syncTag,i);\n\t\t\t\tt.start();\n\t\t\t}\n\t}\n}\n```\n\n结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。\n研究一番，发现是 notify 与notifyAll 在捣鬼。\n当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。\n其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。\n\t\t \n当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，\n剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，\n没抢到的老实等着。\n\t\t \n这就是notify 与 notifyAll两者的区别.\n\t\t \n那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。\n原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合\nsyncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，\n如果不符合，就继续wait.符合则执行。\n很简单，将 \n\n```java\nif (syncTag.threadNO != scriptNO) {\n        try {\n                syncTag.wait();\n            } catch (InterruptedException e) {\n                                    e.printStackTrace();\n            }\n}\n```\n\n这部分代码 改为： \n\n```java\nwhile (syncTag.threadNO != scriptNO) {\n\t\ttry {\n\t\t\t\tsyncTag.wait();\n\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n这个问题就解决了。\n\t \n## **延伸**：\n假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：\n设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO\n这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们\n中的一个。于是陷入死锁，无尽的等待。\n\t\t \n所以，具体使用notify还是notifyAll 就得具体情况具体分析了。","slug":"notify问题","published":1,"updated":"2016-08-14T09:09:51.722Z","_id":"cirucnp9f0013jkqc6jbnrq5e","comments":1,"photos":[],"link":"","content":"<p>今天遇到了这么个情况：<br>有线程若干，我需要他们按顺序执行。<br>代码大概长这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SyncTag &#123;</div><div class=\"line\">\tpublic int threadNO;</div><div class=\"line\">\tpublic SyncTag() &#123;</div><div class=\"line\">\t    threadNO = 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class ThreadA extend Thread&#123;</div><div class=\"line\">\tSyncTag syncTag;</div><div class=\"line\">\tint scriptNO;</div><div class=\"line\">\tThreadA(SyncTag syncTag,int scriptNO)&#123;</div><div class=\"line\">\t\t\tthis.syncTag=syncTag;</div><div class=\"line\">\t\t\tthis.scriptNO=scriptNO;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void Run()&#123;</div><div class=\"line\">\t\t\tsynchronized (syncTag) &#123;</div><div class=\"line\">                if (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">                        try &#123;</div><div class=\"line\">                                syncTag.wait();</div><div class=\"line\">                        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                dosomething();</div><div class=\"line\">                syncTag.threadNO++;</div><div class=\"line\">                syncTag.notifyAll();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">public class Test&#123;</div><div class=\"line\">\tpublic static void main(String args[])&#123;</div><div class=\"line\">\t\t    SyncTag syncTag=new SyncTag();</div><div class=\"line\">\t\t\tfor(int i=0;i&lt;10;++i)&#123;</div><div class=\"line\">\t\t\t\tThreadA t=new ThreadA(syncTag,i);</div><div class=\"line\">\t\t\t\tt.start();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。<br>研究一番，发现是 notify 与notifyAll 在捣鬼。<br>当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。<br>其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。</p>\n<p>当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，<br>剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，<br>没抢到的老实等着。</p>\n<p>这就是notify 与 notifyAll两者的区别.</p>\n<p>那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。<br>原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合<br>syncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，<br>如果不符合，就继续wait.符合则执行。<br>很简单，将 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                syncTag.wait();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这部分代码 改为： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tsyncTag.wait();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个问题就解决了。</p>\n<h2 id=\"延伸：\"><a href=\"#延伸：\" class=\"headerlink\" title=\"延伸：\"></a><strong>延伸</strong>：</h2><p>假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：<br>设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO<br>这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们<br>中的一个。于是陷入死锁，无尽的等待。</p>\n<p>所以，具体使用notify还是notifyAll 就得具体情况具体分析了。</p>\n","excerpt":"","more":"<p>今天遇到了这么个情况：<br>有线程若干，我需要他们按顺序执行。<br>代码大概长这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SyncTag &#123;</div><div class=\"line\">\tpublic int threadNO;</div><div class=\"line\">\tpublic SyncTag() &#123;</div><div class=\"line\">\t    threadNO = 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class ThreadA extend Thread&#123;</div><div class=\"line\">\tSyncTag syncTag;</div><div class=\"line\">\tint scriptNO;</div><div class=\"line\">\tThreadA(SyncTag syncTag,int scriptNO)&#123;</div><div class=\"line\">\t\t\tthis.syncTag=syncTag;</div><div class=\"line\">\t\t\tthis.scriptNO=scriptNO;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void Run()&#123;</div><div class=\"line\">\t\t\tsynchronized (syncTag) &#123;</div><div class=\"line\">                if (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">                        try &#123;</div><div class=\"line\">                                syncTag.wait();</div><div class=\"line\">                        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                dosomething();</div><div class=\"line\">                syncTag.threadNO++;</div><div class=\"line\">                syncTag.notifyAll();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">public class Test&#123;</div><div class=\"line\">\tpublic static void main(String args[])&#123;</div><div class=\"line\">\t\t    SyncTag syncTag=new SyncTag();</div><div class=\"line\">\t\t\tfor(int i=0;i&lt;10;++i)&#123;</div><div class=\"line\">\t\t\t\tThreadA t=new ThreadA(syncTag,i);</div><div class=\"line\">\t\t\t\tt.start();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果却不是像我预料的那样。这十个线程的执行顺序竟然是混乱的，无序的。虽然他们是之间实现了串行执行。<br>研究一番，发现是 notify 与notifyAll 在捣鬼。<br>当调用 同步对象（syncTag）的notify方法 的时候，唤醒了N多等待资源线程中的一个（即 调用了同步对象的wait 方法而阻塞的那些线程）；至于唤醒哪个线程，是不确定的。<br>其他的线程仍然在阻塞，需要被notify 或者 notifyAll 唤醒。</p>\n<p>当调用同步对象（syncTag）的notifyAll方法 的时候，所有进入wait 方法而阻塞的那些线程都被唤醒了。他们中的一个会抢到同步锁（syncTag），继续执行下去，<br>剩下的没有获得锁的线程则继续等待。与上面情况不同的是，这些等待的线层不再需要notify或者notifyAll去唤醒了，一旦拥有锁的线程放弃锁，这些线程就一拥而上，去抢占锁，抢到的运行，<br>没抢到的老实等着。</p>\n<p>这就是notify 与 notifyAll两者的区别.</p>\n<p>那么我遇到的问题是否是因为使用了notifyAll 的原因呢？其实并不是。即使我改成notify ，这些线程也没有按照顺序去运行。<br>原因在于：当某个先执行的线程（线程0）调用了notify 或者notifyAll 之后，某个线程被选中了。但是这个选中的线程并不一定是线程1.因为唤醒某个线程之后，他并不会再去检查是否符合<br>syncTag.threadNO == scriptNO 这个条件，只要被唤醒了，又恰好拥有了锁。那他就执行下去了。我们只需要让他在执行之前再检查一下是否 符合syncTag.threadNO == scriptNO 这个条件，<br>如果不符合，就继续wait.符合则执行。<br>很简单，将 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                syncTag.wait();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                                    e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这部分代码 改为： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (syncTag.threadNO != scriptNO) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tsyncTag.wait();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个问题就解决了。</p>\n<h2 id=\"延伸：\"><a href=\"#延伸：\" class=\"headerlink\" title=\"延伸：\"></a><strong>延伸</strong>：</h2><p>假设这样一种情况：我们按照上面的方法把代码改了，但同时把下面的 notifyAll 改为 notify.问题又出现了：<br>设想一下，如果线程0执行完毕之后调用syncTag.notify（），唤醒某个线程（线程3），但是在这个线程中恰好不满足 syncTag.threadNO == scriptNO<br>这个条件。那么这个线程（线程3）会继续wait. 这个时候，所有的线程都在 wait,但并没有一个线程在运行，也没有其他线程能够调用 notify或者notifyAll来唤醒他们<br>中的一个。于是陷入死锁，无尽的等待。</p>\n<p>所以，具体使用notify还是notifyAll 就得具体情况具体分析了。</p>\n"},{"layout":"post","date":"2016-03-30T04:48:55.000Z","title":"sphinx安装问题","_content":"\n>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python\n 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。\n\n>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是\n Python2，Python3与Python2是不兼容的，在编码问题上报错。\n\n>遂改之，卸载Python3，安装Python2.问题来了。\n\n安装完Python2之后，使用 easy_install sphinx \n指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：\n\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 4-5: ordi al not in range(128)\n\n意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内\n，就会抛出异常（ordinal not in range(128)）。\n\n看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆\n.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。\n\n后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。\n\n首先所有修改的动作都是要创建一个叫 **sitecustomize.py**的文件，为什么要创建这个文件呢，是因为python在启动的时候会\n去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。\n\n修改默认字符编码的代码很简单就2行：\n\n```\n\n# sitecustomize.py                   # this file can be anywhere in your Python path,\n# but it usually goes in ${pythondir}/lib/site-packages/\nimport sys\nsys.setdefaultencoding('utf-8') \n\n```\n\n写完这个文件放哪里呢？\n\nwindows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 \n\nok,现在再次运行 easy_install sphinx ，可以通过安装了！\n\nps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。\n\n**参考**\n\n[解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误](http://wangye.org/blog/archives/629/)\n\n[永久修改python默认的字符编码为utf-8](http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html)       \n","source":"_posts/sphinx安装问题.md","raw":"---\nlayout: post\ndate:   2016-03-30 12:48:55\ntitle: \"sphinx安装问题\"\ncategories: 工具\ntags: \n- python\n- 编码\n---\n\n>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python\n 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。\n\n>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是\n Python2，Python3与Python2是不兼容的，在编码问题上报错。\n\n>遂改之，卸载Python3，安装Python2.问题来了。\n\n安装完Python2之后，使用 easy_install sphinx \n指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：\n\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 4-5: ordi al not in range(128)\n\n意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内\n，就会抛出异常（ordinal not in range(128)）。\n\n看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆\n.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。\n\n后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。\n\n首先所有修改的动作都是要创建一个叫 **sitecustomize.py**的文件，为什么要创建这个文件呢，是因为python在启动的时候会\n去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。\n\n修改默认字符编码的代码很简单就2行：\n\n```\n\n# sitecustomize.py                   # this file can be anywhere in your Python path,\n# but it usually goes in ${pythondir}/lib/site-packages/\nimport sys\nsys.setdefaultencoding('utf-8') \n\n```\n\n写完这个文件放哪里呢？\n\nwindows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 \n\nok,现在再次运行 easy_install sphinx ，可以通过安装了！\n\nps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。\n\n**参考**\n\n[解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误](http://wangye.org/blog/archives/629/)\n\n[永久修改python默认的字符编码为utf-8](http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html)       \n","slug":"sphinx安装问题","published":1,"updated":"2016-08-14T08:26:27.941Z","comments":1,"photos":[],"link":"","_id":"cirucnp9i0016jkqc3uaxwig0","content":"<blockquote>\n<p>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python<br> 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。</p>\n<p>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是<br> Python2，Python3与Python2是不兼容的，在编码问题上报错。</p>\n<p>遂改之，卸载Python3，安装Python2.问题来了。</p>\n</blockquote>\n<p>安装完Python2之后，使用 easy_install sphinx<br>指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：</p>\n<p>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 4-5: ordi al not in range(128)</p>\n<p>意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内<br>，就会抛出异常（ordinal not in range(128)）。</p>\n<p>看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆<br>.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。</p>\n<p>后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。</p>\n<p>首先所有修改的动作都是要创建一个叫 <strong>sitecustomize.py</strong>的文件，为什么要创建这个文件呢，是因为python在启动的时候会<br>去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。</p>\n<p>修改默认字符编码的代码很简单就2行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># sitecustomize.py                   # this file can be anywhere in your Python path,</div><div class=\"line\"># but it usually goes in $&#123;pythondir&#125;/lib/site-packages/</div><div class=\"line\">import sys</div><div class=\"line\">sys.setdefaultencoding(&apos;utf-8&apos;)</div></pre></td></tr></table></figure>\n<p>写完这个文件放哪里呢？</p>\n<p>windows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 </p>\n<p>ok,现在再次运行 easy_install sphinx ，可以通过安装了！</p>\n<p>ps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"http://wangye.org/blog/archives/629/\" target=\"_blank\" rel=\"external\">解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html\" target=\"_blank\" rel=\"external\">永久修改python默认的字符编码为utf-8</a>       </p>\n","excerpt":"","more":"<blockquote>\n<p>领导给安排的任务是修改数据库的帮助手册。从仓库下载了代码以后就一直在倒腾环境的安装。生成文档的工具是Python<br> 环境下的Sphinx。就是这个Sphinx,昨天倒腾了一天都没装上，郁闷。</p>\n<p>一开始安装Python3，到是一路顺畅，没有什么问题。但是在使用Sphinx的时候就报错了。原因是之前文档的创建环境是<br> Python2，Python3与Python2是不兼容的，在编码问题上报错。</p>\n<p>遂改之，卸载Python3，安装Python2.问题来了。</p>\n</blockquote>\n<p>安装完Python2之后，使用 easy_install sphinx<br>指令来安装sphinx。可是死活装不上，换源和使用pip都不行，苦逼。报这样一个错误：</p>\n<p>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 4-5: ordi al not in range(128)</p>\n<p>意思就是Python执行环境的默认编码是ascii码，Python调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内<br>，就会抛出异常（ordinal not in range(128)）。</p>\n<p>看了一下报错的位置，都是在安装sphinx之前安装的所需的依赖出了问题，都是一堆<br>.py文件。某些函数读取字符流的时候出了问题。这可咋整。。。我也没法知道他读的流是啥啊。</p>\n<p>后来想到了一个解决办法，那就是修改Python编码环境为UTF-8，问题可能就迎刃而解了。</p>\n<p>首先所有修改的动作都是要创建一个叫 <strong>sitecustomize.py</strong>的文件，为什么要创建这个文件呢，是因为python在启动的时候会<br>去load的这个文件，所以你如果要修改一些启动的变量就可以把操作写在这个文件。</p>\n<p>修改默认字符编码的代码很简单就2行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># sitecustomize.py                   # this file can be anywhere in your Python path,</div><div class=\"line\"># but it usually goes in $&#123;pythondir&#125;/lib/site-packages/</div><div class=\"line\">import sys</div><div class=\"line\">sys.setdefaultencoding(&apos;utf-8&apos;)</div></pre></td></tr></table></figure>\n<p>写完这个文件放哪里呢？</p>\n<p>windows :存放在你python的安装的目录Lib\\site-packages(比如C:\\Python27\\Lib\\site-packages)里。 </p>\n<p>ok,现在再次运行 easy_install sphinx ，可以通过安装了！</p>\n<p>ps:Python3 已经解决了这个问题，所以在Python3 环境下不会出现这个错误。</p>\n<p><strong>参考</strong></p>\n<p><a href=\"http://wangye.org/blog/archives/629/\">解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_494e45fe0102e3p9.html\">永久修改python默认的字符编码为utf-8</a>       </p>\n"},{"layout":"post","date":"2016-07-31T09:30:55.000Z","title":"为什么是final","_content":"\n>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。\n\n注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。\n\n例子是这样的：\n\n```java\npublic class Outer {\n\tprivate int outerVar=0;\n\tpublic void testInner(final String paramVal){\n\t\tfinal Integer localVal = 1;\n\t\tInner inner = new Inner(){\n\t\t\t@Override\n\t\t\tpublic void doSomething() {\n\t\t\t\tSystem.out.println(localVal+paramVal);\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tfinal int localVal1 = 2;\n\t\tclass Inner2{\n\t\t\tpublic void testInner2(){\n\t\t\t\tSystem.out.println(localVal1);\n\t\t\t}\n\t\t}\n\t}\n\tinterface Inner{\n\t\tpublic void doSomething();\n\t}\n\tpublic static void main(String args[]){\n\t\tOuter outer = new Outer();\n\t\touter.testInner(\"hello\");\n\t}\n}\n```\n\n可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。\n\n后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。\n\n我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）\n\n但是确实生成了这样几个.class文件：\n\nOuter.class:class Outer\n\nOuter$1.class:匿名内部类 new Inner(){...}\n\nOuter$1Inner2.class:class Inner2\n\nOuter$Inner.class:interface Inner\n\n这说明，匿名内部类与他的外围类之间确实是相互独立的。\n\n为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：\n\n```java\nclass kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner {\n  final java.lang.Integer val$localVar;\n\n  final java.lang.String val$paramVal;\n\n  final kyu.java.util.Outer this$0;\n\n  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);\n    Code:\n       0: aload_0\n       1: aload_1\n       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;\n       5: aload_0\n       6: aload_2\n       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;\n      10: aload_0\n      11: aload_3\n      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;\n      15: aload_0\n      16: invokespecial #4                  // Method java/lang/Object.\"<init>\":()V\n      19: return\n\n      .....\n }\n```\n\n上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参\n。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。\n\n所以，现在有两个问题：\n\n- **为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？**\n\n我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。\n\n- **局部变量或形参为什么必须是final类型？**\n\n在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。\n\n```java\nfinal Integer localVal = 1;\nInner inner = new Inner(){\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(localVar+paramVal);\n\t}\n};\n```\n\n这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。\n\nps:后来在stackoverflow上看到[Why are only final variables accessible in anonymous class?](http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class)，可以参考一下。","source":"_posts/为什么是final.md","raw":"---\nlayout: post\ndate:   2016-07-31 17:30:55\ntitle: \"为什么是final\"\ncategories: 编程\ntags: \n- java\n---\n\n>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。\n\n注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。\n\n例子是这样的：\n\n```java\npublic class Outer {\n\tprivate int outerVar=0;\n\tpublic void testInner(final String paramVal){\n\t\tfinal Integer localVal = 1;\n\t\tInner inner = new Inner(){\n\t\t\t@Override\n\t\t\tpublic void doSomething() {\n\t\t\t\tSystem.out.println(localVal+paramVal);\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tfinal int localVal1 = 2;\n\t\tclass Inner2{\n\t\t\tpublic void testInner2(){\n\t\t\t\tSystem.out.println(localVal1);\n\t\t\t}\n\t\t}\n\t}\n\tinterface Inner{\n\t\tpublic void doSomething();\n\t}\n\tpublic static void main(String args[]){\n\t\tOuter outer = new Outer();\n\t\touter.testInner(\"hello\");\n\t}\n}\n```\n\n可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。\n\n后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。\n\n我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）\n\n但是确实生成了这样几个.class文件：\n\nOuter.class:class Outer\n\nOuter$1.class:匿名内部类 new Inner(){...}\n\nOuter$1Inner2.class:class Inner2\n\nOuter$Inner.class:interface Inner\n\n这说明，匿名内部类与他的外围类之间确实是相互独立的。\n\n为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：\n\n```java\nclass kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner {\n  final java.lang.Integer val$localVar;\n\n  final java.lang.String val$paramVal;\n\n  final kyu.java.util.Outer this$0;\n\n  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);\n    Code:\n       0: aload_0\n       1: aload_1\n       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;\n       5: aload_0\n       6: aload_2\n       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;\n      10: aload_0\n      11: aload_3\n      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;\n      15: aload_0\n      16: invokespecial #4                  // Method java/lang/Object.\"<init>\":()V\n      19: return\n\n      .....\n }\n```\n\n上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参\n。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。\n\n所以，现在有两个问题：\n\n- **为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？**\n\n我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。\n\n- **局部变量或形参为什么必须是final类型？**\n\n在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。\n\n```java\nfinal Integer localVal = 1;\nInner inner = new Inner(){\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(localVar+paramVal);\n\t}\n};\n```\n\n这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。\n\nps:后来在stackoverflow上看到[Why are only final variables accessible in anonymous class?](http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class)，可以参考一下。","slug":"为什么是final","published":1,"updated":"2016-08-14T08:26:27.942Z","comments":1,"photos":[],"link":"","_id":"cirucnp9t001ajkqcu2kvrskp","content":"<blockquote>\n<p>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。</p>\n</blockquote>\n<p>注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。</p>\n<p>例子是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> outerVar=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner</span><span class=\"params\">(<span class=\"keyword\">final</span> String paramVal)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">\t\tInner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal+paramVal);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localVal1 = <span class=\"number\">2</span>;</div><div class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner2</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal1);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Inner</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tOuter outer = <span class=\"keyword\">new</span> Outer();</div><div class=\"line\">\t\touter.testInner(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。</p>\n<p>后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。</p>\n<p>我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）</p>\n<p>但是确实生成了这样几个.class文件：</p>\n<p>Outer.class:class Outer</p>\n<p>Outer$1.class:匿名内部类 new Inner(){…}</p>\n<p>Outer$1Inner2.class:class Inner2</p>\n<p>Outer$Inner.class:interface Inner</p>\n<p>这说明，匿名内部类与他的外围类之间确实是相互独立的。</p>\n<p>为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner &#123;</div><div class=\"line\">  final java.lang.Integer val$localVar;</div><div class=\"line\"></div><div class=\"line\">  final java.lang.String val$paramVal;</div><div class=\"line\"></div><div class=\"line\">  final kyu.java.util.Outer this$0;</div><div class=\"line\"></div><div class=\"line\">  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);</div><div class=\"line\">    Code:</div><div class=\"line\">       0: aload_0</div><div class=\"line\">       1: aload_1</div><div class=\"line\">       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;</div><div class=\"line\">       5: aload_0</div><div class=\"line\">       6: aload_2</div><div class=\"line\">       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;</div><div class=\"line\">      10: aload_0</div><div class=\"line\">      11: aload_3</div><div class=\"line\">      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;</div><div class=\"line\">      15: aload_0</div><div class=\"line\">      16: invokespecial #4                  // Method java/lang/Object.\"&lt;init&gt;\":()V</div><div class=\"line\">      19: return</div><div class=\"line\"></div><div class=\"line\">      .....</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参<br>。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。</p>\n<p>所以，现在有两个问题：</p>\n<ul>\n<li><strong>为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？</strong></li>\n</ul>\n<p>我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。</p>\n<ul>\n<li><strong>局部变量或形参为什么必须是final类型？</strong></li>\n</ul>\n<p>在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">Inner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(localVar+paramVal);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。</p>\n<p>ps:后来在stackoverflow上看到<a href=\"http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class\" target=\"_blank\" rel=\"external\">Why are only final variables accessible in anonymous class?</a>，可以参考一下。</p>\n","excerpt":"","more":"<blockquote>\n<p>之前一直知道这样一个事实：在java中，匿名内部类或局部内部类访问包含自己的函数的局部变量或形参时，该变量或形参必须声明为final类型的。今天逛博客时偶尔看到有人提问：为什么必须是final呢？？？对啊，为什么必须是final呢？翻了很多资料，网上关于这个问题的总结还挺多，但是都不懂他们在说什么（可能是自己理解不到位），所以自己总结一下。</p>\n</blockquote>\n<p>注：以下提到的局部变量和形参，都是指产生这个匿名内部类的函数的局部变量和形参。</p>\n<p>例子是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> outerVar=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner</span><span class=\"params\">(<span class=\"keyword\">final</span> String paramVal)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">\t\tInner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal+paramVal);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localVal1 = <span class=\"number\">2</span>;</div><div class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner2</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testInner2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(localVal1);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Inner</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tOuter outer = <span class=\"keyword\">new</span> Outer();</div><div class=\"line\">\t\touter.testInner(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，paramVal，localVal，localVal1都是final的,去掉final关键字，编译就会报错。</p>\n<p>后来在网上看到说，匿名内部类编译之后会形成一个新的.class文件，与他的外围类之间是相互独立的，java会帮助匿名内部类自动创建一个构造函数，构造函数参数即为匿名内部类用到的局部变量或形参。</p>\n<p>我自己反编译了一下，并没有看到所谓的构造函数（难道是跟jdk有关？）</p>\n<p>但是确实生成了这样几个.class文件：</p>\n<p>Outer.class:class Outer</p>\n<p>Outer$1.class:匿名内部类 new Inner(){…}</p>\n<p>Outer$1Inner2.class:class Inner2</p>\n<p>Outer$Inner.class:interface Inner</p>\n<p>这说明，匿名内部类与他的外围类之间确实是相互独立的。</p>\n<p>为了能看到这几个类是怎么构造的，还是看看他的字节码吧。使用 javap -c Outer$1.class命令，查看匿名内部类的字节码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class kyu.java.util.Outer$1 implements kyu.java.util.Outer$Inner &#123;</div><div class=\"line\">  final java.lang.Integer val$localVar;</div><div class=\"line\"></div><div class=\"line\">  final java.lang.String val$paramVal;</div><div class=\"line\"></div><div class=\"line\">  final kyu.java.util.Outer this$0;</div><div class=\"line\"></div><div class=\"line\">  kyu.java.util.Outer$1(kyu.java.util.Outer, java.lang.Integer, java.lang.String);</div><div class=\"line\">    Code:</div><div class=\"line\">       0: aload_0</div><div class=\"line\">       1: aload_1</div><div class=\"line\">       2: putfield      #1                  // Field this$0:Lkyu/java/util/Outer;</div><div class=\"line\">       5: aload_0</div><div class=\"line\">       6: aload_2</div><div class=\"line\">       7: putfield      #2                  // Field val$localVar:Ljava/lang/Integer;</div><div class=\"line\">      10: aload_0</div><div class=\"line\">      11: aload_3</div><div class=\"line\">      12: putfield      #3                  // Field val$paramVal:Ljava/lang/String;</div><div class=\"line\">      15: aload_0</div><div class=\"line\">      16: invokespecial #4                  // Method java/lang/Object.\"&lt;init&gt;\":()V</div><div class=\"line\">      19: return</div><div class=\"line\"></div><div class=\"line\">      .....</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>上面只截取了构造函数那一部分字节码。可以看到匿名内部类生成了几个自己的成员变量，他们都是final类型的，其中 this$0 对应包含自己的外围类，其他两个成员变量对应匿名内部类中使用到的局部变量和形参<br>。在他的构造函数Outer$1中可以看到，这三个成员变量被赋值。即：之前提到的paramVal，localVal引用被各自复制了一份，存到了匿名内部类当中。</p>\n<p>所以，现在有两个问题：</p>\n<ul>\n<li><strong>为什么需要在匿名内部类中通过构造函数将使用到的局部变量或形参的引用再复制一份，直接使用不是更方便吗？</strong></li>\n</ul>\n<p>我们通常使用匿名内部类来执行一个异步的操作（在android中经常遇到的回调），这就存在一个生命周期不一致的问题。假如我们在匿名内部类中新开了一个线程，这个线程执行过程中需要使用局部变量或形参。但是极有可能当这个新开的线程执行到这一步的时候，产生这个匿名内部类的函数早已经执行完毕了，他的局部变量和形参也早已被回收了（局部变量和形参都存在于栈内存中），新开的线程所使用的局部变量或形参都是空的，不指向任何实例。这样就造成空指针问题。</p>\n<ul>\n<li><strong>局部变量或形参为什么必须是final类型？</strong></li>\n</ul>\n<p>在1中我们知道匿名内部类将局部变量和形参的引用复制了一份，他们指向同一个实例。我们通过分析匿名内部类的字节码得到这个真相。但是从源代码的角度看，好像是匿名内部类直接使用了这个局部变量或形参，并不存在什么复制啊，他们明明就是同一个引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Integer localVal = <span class=\"number\">1</span>;</div><div class=\"line\">Inner inner = <span class=\"keyword\">new</span> Inner()&#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(localVar+paramVal);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样就会给我们造成一个错觉：我们在这个局部变量存在的函数中继续修改这个局部变量引用时（将他指向另一个实例），修改的就是匿名内部类中使用的那个引用（反之在匿名内部类中修改局部变量指向的引用），因为他们看上去是同一个啊。实际上我们从1知道了，实际情况不是这样的。但是仅仅从代码的角度来看，是察觉不出这种变化的。所以如果要在语义上保证局部变量和副本的一致性，就应当使用final来保证该局部变量不变（干脆就不让你修改了）。</p>\n<p>ps:后来在stackoverflow上看到<a href=\"http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class\">Why are only final variables accessible in anonymous class?</a>，可以参考一下。</p>\n"},{"layout":"post","date":"2016-04-14T05:48:55.000Z","title":"他可是科比布莱恩特","_content":"<center>\n\t<iframe \n\t\twidth=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen>\n\t</iframe>\n</center>\nwhat can i say, Mamba out！\n\n{% asset_img kobe.jpg 科比 %}\n\n\n\n","source":"_posts/他可是科比·布莱恩特!.md","raw":"---\nlayout: post\ndate:   2016-04-14 13:48:55\ntitle: \"他可是科比布莱恩特\"\ncategories: 生活\n---\n<center>\n\t<iframe \n\t\twidth=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen>\n\t</iframe>\n</center>\nwhat can i say, Mamba out！\n\n{% asset_img kobe.jpg 科比 %}\n\n\n\n","slug":"他可是科比·布莱恩特!","published":1,"updated":"2016-08-14T08:26:27.943Z","comments":1,"photos":[],"link":"","_id":"cirucnpa5001djkqcm6or5ntz","content":"<p><center><br>    <iframe width=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen><br>    </iframe><br></center><br>what can i say, Mamba out！</p>\n<img src=\"/2016/04/14/他可是科比·布莱恩特!/kobe.jpg\" alt=\"科比\" title=\"科比\">\n","excerpt":"","more":"<p><center><br>    <iframe \n        width=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/rDoom367qbDe0uBbDPfVHQ__.mp4\" frameborder=\"0\" allowfullscreen><br>    </iframe><br></center><br>what can i say, Mamba out！</p>\n<img src=\"/2016/04/14/他可是科比·布莱恩特!/kobe.jpg\" alt=\"科比\" title=\"科比\">\n"},{"layout":"post","title":"代码规范","date":"2016-03-29T08:31:55.000Z","_content":"\n>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。\n 所以决定总结一些规范，以后写代码要注意了~\n\n- ## **命名**\n\n  - 变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名\n\n  - 避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean\n\n  1. 方法\n\n     方法名第一个单词小写，以后每个单词首字母大写。\n\n  2. 类、接口\n\n     所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词\n\n  3. 字段、常量\n\n     成员变量、局部变量第一个单词小写，如 userName, instance。\n\n     常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。\n\n     代码中禁止使用硬编码，把一些数字或字符串定义成常用量。\n\n- ## **注释**\n\n  1. 成员变量注释\n\n    ```java\n    /** 成员变量注释 */\n    protected Object mObject0;\n\n    /**\n     * 对于注释多于一行的，采用这种方式来\n     * 定义该变量\n     */\n    private Object mObject4;\n    ```\n\n  2. 方法描述\n\n    ```java\n    /**\n      * 方法描述...\n      * \n      * @param param1  参数1描述...\n      * @param param2  参数2描述...\n      * @param paramXX 参数XX描述... （注意：请将参数、描述都对齐）\n      */\n      public void doSomething(int param1, float param2, String paramXX) {}\n    ```\n\n  3.方法内部注释\n\n    可以使用 /*注释*/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。\n    \n    ```java\n    if (a == 2) {\n        return TRUE;            /* special case */\n    } else {    \n        return isprime(a);      /* works only for odd a */}\n    ```\n\n\n- ## **换行、空格**\n\n  - **换行**\n\n    当代码过长造成阅读困难的时候，就应该考虑代码换行。\n\n    有这么几个原则：\n\n    1.在逗号之后换行\n\n    2.在操作符之前换行\n\n    3.考虑在表达式的外层就换行，而不是内层\n\n    4.新一行的开头应该与前一行的同一级代码对齐\n\n    5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。\n\n    **示例**\n\n    ```java\n    function(longExpression1, longExpression2, longExpression3,         \n             longExpression4, longExpression5);\n\n    var = function1(longExpression1,                \n                   function2(longExpression2,\n                             longExpression3));\n    ```\n\n    在表达式外层换行：\n\n    ```java\n    longName1 = longName2 * (longName3 + longName4 - longName5)\n                + 4 * longname6; // PREFER\n\n    longName1 = longName2 * (longName3 + longName4\n                             - longName5) + 4 * longname6; // AVOID\n\n    ```\n\n    插入8个空格的情况\n\n    ```java\n    //INDENT 8 SPACES TO AVOID VERY DEEP INDENTS\n    private static synchronized horkingLongMethodName(int anArg,\n            Object anotherArg, String yetAnotherArg,\n            Object andStillAnother) {    \n         ...\n    } \n\n    //条件表达式8空格原则\n    if ((condition1 && condition2)\n            || (condition3 && condition4)\n            ||!(condition5 && condition6)) {\n        doSomethingAboutIt();\n    }\n    ```\n\n  - **空格**\n\n    1.`{`内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。\n\n    2. 操作符左右，大括号`{}`左右，等于号左右都要有一个空格的间距。\nf\n\n- ## **参考**\n\n  [JavaCode Conventions](http://www.oracle.com/technetwork/java/codeconventions-150003.pdf)","source":"_posts/代码格式.md","raw":"---\nlayout: post\ntitle:  \"代码规范\"\ndate:   2016-03-29 16:31:55\ncategories: 编程 \ntags: \n- java\n---\n\n>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。\n 所以决定总结一些规范，以后写代码要注意了~\n\n- ## **命名**\n\n  - 变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名\n\n  - 避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean\n\n  1. 方法\n\n     方法名第一个单词小写，以后每个单词首字母大写。\n\n  2. 类、接口\n\n     所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词\n\n  3. 字段、常量\n\n     成员变量、局部变量第一个单词小写，如 userName, instance。\n\n     常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。\n\n     代码中禁止使用硬编码，把一些数字或字符串定义成常用量。\n\n- ## **注释**\n\n  1. 成员变量注释\n\n    ```java\n    /** 成员变量注释 */\n    protected Object mObject0;\n\n    /**\n     * 对于注释多于一行的，采用这种方式来\n     * 定义该变量\n     */\n    private Object mObject4;\n    ```\n\n  2. 方法描述\n\n    ```java\n    /**\n      * 方法描述...\n      * \n      * @param param1  参数1描述...\n      * @param param2  参数2描述...\n      * @param paramXX 参数XX描述... （注意：请将参数、描述都对齐）\n      */\n      public void doSomething(int param1, float param2, String paramXX) {}\n    ```\n\n  3.方法内部注释\n\n    可以使用 /*注释*/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。\n    \n    ```java\n    if (a == 2) {\n        return TRUE;            /* special case */\n    } else {    \n        return isprime(a);      /* works only for odd a */}\n    ```\n\n\n- ## **换行、空格**\n\n  - **换行**\n\n    当代码过长造成阅读困难的时候，就应该考虑代码换行。\n\n    有这么几个原则：\n\n    1.在逗号之后换行\n\n    2.在操作符之前换行\n\n    3.考虑在表达式的外层就换行，而不是内层\n\n    4.新一行的开头应该与前一行的同一级代码对齐\n\n    5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。\n\n    **示例**\n\n    ```java\n    function(longExpression1, longExpression2, longExpression3,         \n             longExpression4, longExpression5);\n\n    var = function1(longExpression1,                \n                   function2(longExpression2,\n                             longExpression3));\n    ```\n\n    在表达式外层换行：\n\n    ```java\n    longName1 = longName2 * (longName3 + longName4 - longName5)\n                + 4 * longname6; // PREFER\n\n    longName1 = longName2 * (longName3 + longName4\n                             - longName5) + 4 * longname6; // AVOID\n\n    ```\n\n    插入8个空格的情况\n\n    ```java\n    //INDENT 8 SPACES TO AVOID VERY DEEP INDENTS\n    private static synchronized horkingLongMethodName(int anArg,\n            Object anotherArg, String yetAnotherArg,\n            Object andStillAnother) {    \n         ...\n    } \n\n    //条件表达式8空格原则\n    if ((condition1 && condition2)\n            || (condition3 && condition4)\n            ||!(condition5 && condition6)) {\n        doSomethingAboutIt();\n    }\n    ```\n\n  - **空格**\n\n    1.`{`内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。\n\n    2. 操作符左右，大括号`{}`左右，等于号左右都要有一个空格的间距。\nf\n\n- ## **参考**\n\n  [JavaCode Conventions](http://www.oracle.com/technetwork/java/codeconventions-150003.pdf)","slug":"代码格式","published":1,"updated":"2016-08-14T08:26:27.957Z","comments":1,"photos":[],"link":"","_id":"cirucnpaa001hjkqc4akwdxtq","content":"<blockquote>\n<p>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。<br> 所以决定总结一些规范，以后写代码要注意了~</p>\n</blockquote>\n<ul>\n<li><h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a><strong>命名</strong></h2><ul>\n<li><p>变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名</p>\n</li>\n<li><p>避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean</p>\n</li>\n</ul>\n<ol>\n<li><p>方法</p>\n<p>方法名第一个单词小写，以后每个单词首字母大写。</p>\n</li>\n<li><p>类、接口</p>\n<p>所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词</p>\n</li>\n<li><p>字段、常量</p>\n<p>成员变量、局部变量第一个单词小写，如 userName, instance。</p>\n<p>常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。</p>\n<p>代码中禁止使用硬编码，把一些数字或字符串定义成常用量。</p>\n</li>\n</ol>\n</li>\n<li><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a><strong>注释</strong></h2><ol>\n<li><p>成员变量注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** 成员变量注释 */</span></div><div class=\"line\"><span class=\"keyword\">protected</span> Object mObject0;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 对于注释多于一行的，采用这种方式来</div><div class=\"line\"> * 定义该变量</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">private</span> Object mObject4;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方法描述</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * 方法描述...</div><div class=\"line\">  * </div><div class=\"line\">  * <span class=\"doctag\">@param</span> param1  参数1描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> param2  参数2描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> paramXX 参数XX描述... （注意：请将参数、描述都对齐）</div><div class=\"line\">  */</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> param1, <span class=\"keyword\">float</span> param2, String paramXX)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.方法内部注释</p>\n<p>  可以使用 /<em>注释</em>/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> TRUE;            <span class=\"comment\">/* special case */</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">    <span class=\"keyword\">return</span> isprime(a);      <span class=\"comment\">/* works only for odd a */</span>&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><h2 id=\"换行、空格\"><a href=\"#换行、空格\" class=\"headerlink\" title=\"换行、空格\"></a><strong>换行、空格</strong></h2><ul>\n<li><p><strong>换行</strong></p>\n<p>当代码过长造成阅读困难的时候，就应该考虑代码换行。</p>\n<p>有这么几个原则：</p>\n<p>1.在逗号之后换行</p>\n<p>2.在操作符之前换行</p>\n<p>3.考虑在表达式的外层就换行，而不是内层</p>\n<p>4.新一行的开头应该与前一行的同一级代码对齐</p>\n<p>5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(longExpression1, longExpression2, longExpression3,         </div><div class=\"line\">         longExpression4, longExpression5);</div><div class=\"line\"></div><div class=\"line\">var = function1(longExpression1,                </div><div class=\"line\">               function2(longExpression2,</div><div class=\"line\">                         longExpression3));</div></pre></td></tr></table></figure>\n<p>在表达式外层换行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">longName1 = longName2 * (longName3 + longName4 - longName5)</div><div class=\"line\">            + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// PREFER</span></div><div class=\"line\"></div><div class=\"line\">longName1 = longName2 * (longName3 + longName4</div><div class=\"line\">                         - longName5) + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// AVOID</span></div></pre></td></tr></table></figure>\n<p>插入8个空格的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//INDENT 8 SPACES TO AVOID VERY DEEP INDENTS</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">horkingLongMethodName</span><span class=\"params\">(<span class=\"keyword\">int</span> anArg,</span></span></div><div class=\"line\">        Object anotherArg, String yetAnotherArg,</div><div class=\"line\">        Object andStillAnother) &#123;    </div><div class=\"line\">     ...</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//条件表达式8空格原则</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((condition1 &amp;&amp; condition2)</div><div class=\"line\">        || (condition3 &amp;&amp; condition4)</div><div class=\"line\">        ||!(condition5 &amp;&amp; condition6)) &#123;</div><div class=\"line\">    doSomethingAboutIt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>空格</strong></p>\n<p>1.<code>{</code>内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。</p>\n<ol>\n<li>操作符左右，大括号<code>{}</code>左右，等于号左右都要有一个空格的间距。<br>f</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://www.oracle.com/technetwork/java/codeconventions-150003.pdf\" target=\"_blank\" rel=\"external\">JavaCode Conventions</a></p>\n</li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<p>最近写的代码提上去让领导评审，回来给我的建议都是逻辑虽然正确，但代码十分凌乱，命名不规范，看着很不舒服。<br> 所以决定总结一些规范，以后写代码要注意了~</p>\n</blockquote>\n<ul>\n<li><h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a><strong>命名</strong></h2><ul>\n<li><p>变量，方法，类命名要表义，严格禁止使用 name1, name2 等命名</p>\n</li>\n<li><p>避免使用数字，但可用 2 代替 to，用 4 代替 for 等，如 go2Clean</p>\n</li>\n</ul>\n<ol>\n<li><p>方法</p>\n<p>方法名第一个单词小写，以后每个单词首字母大写。</p>\n</li>\n<li><p>类、接口</p>\n<p>所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词</p>\n</li>\n<li><p>字段、常量</p>\n<p>成员变量、局部变量第一个单词小写，如 userName, instance。</p>\n<p>常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。</p>\n<p>代码中禁止使用硬编码，把一些数字或字符串定义成常用量。</p>\n</li>\n</ol>\n</li>\n<li><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a><strong>注释</strong></h2><ol>\n<li><p>成员变量注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** 成员变量注释 */</span></div><div class=\"line\"><span class=\"keyword\">protected</span> Object mObject0;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 对于注释多于一行的，采用这种方式来</div><div class=\"line\"> * 定义该变量</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">private</span> Object mObject4;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方法描述</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * 方法描述...</div><div class=\"line\">  * </div><div class=\"line\">  * <span class=\"doctag\">@param</span> param1  参数1描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> param2  参数2描述...</div><div class=\"line\">  * <span class=\"doctag\">@param</span> paramXX 参数XX描述... （注意：请将参数、描述都对齐）</div><div class=\"line\">  */</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(<span class=\"keyword\">int</span> param1, <span class=\"keyword\">float</span> param2, String paramXX)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.方法内部注释</p>\n<p>  可以使用 /<em>注释</em>/ 进行注释，也可以使用 //注释  进行注释，最好所有代码保持一致。但多行连续注释不应该使用后者。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> TRUE;            <span class=\"comment\">/* special case */</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">    <span class=\"keyword\">return</span> isprime(a);      <span class=\"comment\">/* works only for odd a */</span>&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><h2 id=\"换行、空格\"><a href=\"#换行、空格\" class=\"headerlink\" title=\"换行、空格\"></a><strong>换行、空格</strong></h2><ul>\n<li><p><strong>换行</strong></p>\n<p>当代码过长造成阅读困难的时候，就应该考虑代码换行。</p>\n<p>有这么几个原则：</p>\n<p>1.在逗号之后换行</p>\n<p>2.在操作符之前换行</p>\n<p>3.考虑在表达式的外层就换行，而不是内层</p>\n<p>4.新一行的开头应该与前一行的同一级代码对齐</p>\n<p>5.如果以上几个原则使得换行后的表达式过于靠右，那么直接在新行之前插入8个空格代替上面的规则。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(longExpression1, longExpression2, longExpression3,         </div><div class=\"line\">         longExpression4, longExpression5);</div><div class=\"line\"></div><div class=\"line\">var = function1(longExpression1,                </div><div class=\"line\">               function2(longExpression2,</div><div class=\"line\">                         longExpression3));</div></pre></td></tr></table></figure>\n<p>在表达式外层换行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">longName1 = longName2 * (longName3 + longName4 - longName5)</div><div class=\"line\">            + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// PREFER</span></div><div class=\"line\"></div><div class=\"line\">longName1 = longName2 * (longName3 + longName4</div><div class=\"line\">                         - longName5) + <span class=\"number\">4</span> * longname6; <span class=\"comment\">// AVOID</span></div></pre></td></tr></table></figure>\n<p>插入8个空格的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//INDENT 8 SPACES TO AVOID VERY DEEP INDENTS</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">horkingLongMethodName</span><span class=\"params\">(<span class=\"keyword\">int</span> anArg,</div><div class=\"line\">        Object anotherArg, String yetAnotherArg,</div><div class=\"line\">        Object andStillAnother)</span> </span>&#123;    </div><div class=\"line\">     ...</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//条件表达式8空格原则</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((condition1 &amp;&amp; condition2)</div><div class=\"line\">        || (condition3 &amp;&amp; condition4)</div><div class=\"line\">        ||!(condition5 &amp;&amp; condition6)) &#123;</div><div class=\"line\">    doSomethingAboutIt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>空格</strong></p>\n<p>1.<code>{</code>内的语句，之前插入4个空格。包括函数，if语句，for循环，while循环等。</p>\n<ol>\n<li>操作符左右，大括号<code>{}</code>左右，等于号左右都要有一个空格的间距。<br>f</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"http://www.oracle.com/technetwork/java/codeconventions-150003.pdf\">JavaCode Conventions</a></p>\n</li>\n</ul>\n"},{"layout":"post","title":"关于抽象类和接口","date":"2016-04-15T14:48:55.000Z","_content":"\n## 抽象类：\n\n> 使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.\n\n   - 抽象类不能被实例化\n\n   - 如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类\n\n   - 抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。\n\n   - 可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。\n   \n   - 不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。\n\n   - 抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。\n\n   - 子类中的抽象方法不能与父类的抽象方法同名\n\n   - 其余情况抽象类与普通类相同。\n\n\n## 接口：\n\n\n > 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.\n\n   - 接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。\n\n   - 接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。\n\n   - 接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。\n\n   - 接口中没有构造方法，不能被实例化。\n\n   - 如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。\n\n   - 接口中不能含有静态代码块以及静态方法。\n\n   - 在实现多接口的时候一定要避免方法名的重复。\n\n## 区别与联系：\n   \n   - **语义**\n   \n     1. 一个类只能继承一个抽象类，但可以实现多个接口。\n\n     2. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法\n\n   - **设计思想**\n\n     >抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。\n\n     1. 抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。\n\n        对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。\n\n     2. 抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。\n    \n        抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n\n     3. 抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n\n        对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。\n\n     **示例**\n\n     门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n\n  \n```java\nabstract class Door {\n      public abstract void open();\n      public abstract void close();\n}\n```\n    \t\n\n或\n \n```java\ninterface Door {\n      public abstract void open();\n      public abstract void close();\n} \n```\n\n\n但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：\n\n1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；\n\n2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。\n\n从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。\n      \n\n```java\ninterface Alram {\n      void alarm();\n}\nabstract class Door {\n      void open();\n      void close();\n}\nclass AlarmDoor extends Door implements Alarm {\n      void oepn() {\n           //....\n      }\n      void close() {\n           //....\n      }\n      void alarm() {\n           //....\n      }\n} \n```\n\n\n\n\n## **资料:**\n\n   [Java 中的接口有什么作用？](https://www.zhihu.com/question/20111251)\n\n   [java提高篇（四）-----抽象类与接口](http://blog.csdn.net/chenssy/article/details/12858267)\n\n","source":"_posts/关于抽象类和接口.md","raw":"---\nlayout: post\ntitle:  \"关于抽象类和接口\"\ncategories: 编程\ntags: \n- java\ndate:   2016-04-15 22:48:55\n---\n\n## 抽象类：\n\n> 使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.\n\n   - 抽象类不能被实例化\n\n   - 如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类\n\n   - 抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。\n\n   - 可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。\n   \n   - 不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。\n\n   - 抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。\n\n   - 子类中的抽象方法不能与父类的抽象方法同名\n\n   - 其余情况抽象类与普通类相同。\n\n\n## 接口：\n\n\n > 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.\n\n   - 接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。\n\n   - 接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。\n\n   - 接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。\n\n   - 接口中没有构造方法，不能被实例化。\n\n   - 如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。\n\n   - 接口中不能含有静态代码块以及静态方法。\n\n   - 在实现多接口的时候一定要避免方法名的重复。\n\n## 区别与联系：\n   \n   - **语义**\n   \n     1. 一个类只能继承一个抽象类，但可以实现多个接口。\n\n     2. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法\n\n   - **设计思想**\n\n     >抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。\n\n     1. 抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。\n\n        对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。\n\n     2. 抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。\n    \n        抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n\n     3. 抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n\n        对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。\n\n     **示例**\n\n     门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n\n  \n```java\nabstract class Door {\n      public abstract void open();\n      public abstract void close();\n}\n```\n    \t\n\n或\n \n```java\ninterface Door {\n      public abstract void open();\n      public abstract void close();\n} \n```\n\n\n但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：\n\n1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；\n\n2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。\n\n从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。\n      \n\n```java\ninterface Alram {\n      void alarm();\n}\nabstract class Door {\n      void open();\n      void close();\n}\nclass AlarmDoor extends Door implements Alarm {\n      void oepn() {\n           //....\n      }\n      void close() {\n           //....\n      }\n      void alarm() {\n           //....\n      }\n} \n```\n\n\n\n\n## **资料:**\n\n   [Java 中的接口有什么作用？](https://www.zhihu.com/question/20111251)\n\n   [java提高篇（四）-----抽象类与接口](http://blog.csdn.net/chenssy/article/details/12858267)\n\n","slug":"关于抽象类和接口","published":1,"updated":"2016-08-14T09:10:17.537Z","_id":"cirucnpaf001ljkqc973ug643","comments":1,"photos":[],"link":"","content":"<h2 id=\"抽象类：\"><a href=\"#抽象类：\" class=\"headerlink\" title=\"抽象类：\"></a>抽象类：</h2><blockquote>\n<p>使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.</p>\n</blockquote>\n<ul>\n<li><p>抽象类不能被实例化</p>\n</li>\n<li><p>如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类</p>\n</li>\n<li><p>抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。</p>\n</li>\n<li><p>可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。</p>\n</li>\n<li><p>不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。</p>\n</li>\n<li><p>抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。</p>\n</li>\n<li><p>子类中的抽象方法不能与父类的抽象方法同名</p>\n</li>\n<li><p>其余情况抽象类与普通类相同。</p>\n</li>\n</ul>\n<h2 id=\"接口：\"><a href=\"#接口：\" class=\"headerlink\" title=\"接口：\"></a>接口：</h2><blockquote>\n<p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.</p>\n</blockquote>\n<ul>\n<li><p>接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。</p>\n</li>\n<li><p>接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。</p>\n</li>\n<li><p>接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。</p>\n</li>\n<li><p>接口中没有构造方法，不能被实例化。</p>\n</li>\n<li><p>如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>\n</li>\n<li><p>接口中不能含有静态代码块以及静态方法。</p>\n</li>\n<li><p>在实现多接口的时候一定要避免方法名的重复。</p>\n</li>\n</ul>\n<h2 id=\"区别与联系：\"><a href=\"#区别与联系：\" class=\"headerlink\" title=\"区别与联系：\"></a>区别与联系：</h2><ul>\n<li><p><strong>语义</strong></p>\n<ol>\n<li><p>一个类只能继承一个抽象类，但可以实现多个接口。</p>\n</li>\n<li><p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法</p>\n</li>\n</ol>\n</li>\n<li><p><strong>设计思想</strong></p>\n<blockquote>\n<p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</p>\n</blockquote>\n<ol>\n<li><p>抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。</p>\n<p>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>\n</li>\n<li><p>抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。</p>\n<p>抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。</p>\n</li>\n<li><p>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>\n<p>对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。</p>\n</li>\n</ol>\n<p><strong>示例</strong></p>\n<p>门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>\n<p>1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>\n<p>2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>\n<p>从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alram</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">oepn</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料:\"></a><strong>资料:</strong></h2><p>   <a href=\"https://www.zhihu.com/question/20111251\" target=\"_blank\" rel=\"external\">Java 中的接口有什么作用？</a></p>\n<p>   <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\" target=\"_blank\" rel=\"external\">java提高篇（四）—–抽象类与接口</a></p>\n","excerpt":"","more":"<h2 id=\"抽象类：\"><a href=\"#抽象类：\" class=\"headerlink\" title=\"抽象类：\"></a>抽象类：</h2><blockquote>\n<p>使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.</p>\n</blockquote>\n<ul>\n<li><p>抽象类不能被实例化</p>\n</li>\n<li><p>如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类</p>\n</li>\n<li><p>抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。</p>\n</li>\n<li><p>可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。</p>\n</li>\n<li><p>不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。</p>\n</li>\n<li><p>抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。</p>\n</li>\n<li><p>子类中的抽象方法不能与父类的抽象方法同名</p>\n</li>\n<li><p>其余情况抽象类与普通类相同。</p>\n</li>\n</ul>\n<h2 id=\"接口：\"><a href=\"#接口：\" class=\"headerlink\" title=\"接口：\"></a>接口：</h2><blockquote>\n<p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.</p>\n</blockquote>\n<ul>\n<li><p>接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。</p>\n</li>\n<li><p>接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。</p>\n</li>\n<li><p>接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。</p>\n</li>\n<li><p>接口中没有构造方法，不能被实例化。</p>\n</li>\n<li><p>如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>\n</li>\n<li><p>接口中不能含有静态代码块以及静态方法。</p>\n</li>\n<li><p>在实现多接口的时候一定要避免方法名的重复。</p>\n</li>\n</ul>\n<h2 id=\"区别与联系：\"><a href=\"#区别与联系：\" class=\"headerlink\" title=\"区别与联系：\"></a>区别与联系：</h2><ul>\n<li><p><strong>语义</strong></p>\n<ol>\n<li><p>一个类只能继承一个抽象类，但可以实现多个接口。</p>\n</li>\n<li><p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法</p>\n</li>\n</ol>\n</li>\n<li><p><strong>设计思想</strong></p>\n<blockquote>\n<p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</p>\n</blockquote>\n<ol>\n<li><p>抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。</p>\n<p>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>\n</li>\n<li><p>抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。</p>\n<p>抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。</p>\n</li>\n<li><p>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>\n<p>对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。</p>\n</li>\n</ol>\n<p><strong>示例</strong></p>\n<p>门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>\n<p>1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>\n<p>2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>\n<p>从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alram</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">oepn</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"comment\">//....</span></div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料:\"></a><strong>资料:</strong></h2><p>   <a href=\"https://www.zhihu.com/question/20111251\">Java 中的接口有什么作用？</a></p>\n<p>   <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\">java提高篇（四）—–抽象类与接口</a></p>\n"},{"layout":"post","title":"常用快捷键总结","date":"2016-03-22T08:31:55.000Z","_content":"- ## ECLIPSE:\n\n   **查看代码**\n   \n   Ctrl+O 搜索当前类变量及方法\n\n   Ctrl+H 打开搜索对话框\n\n   Ctrl+Shift+G  搜索选中变量或方法的引用\n\n   Ctrl+D 删除当前行\n\n   Ctrl+Shift+F 格式化代码\n\n   F4 查看当前类继承结构\n\n   Ctrl+Shift+R 搜索类，文件等资源\n\n   Ctrl+Shift+O 倒包\n   \n   **调试**\n     \n     F5 进入方法内部\n     \n     F6 顺序执行到下一行\n     \n     F7 跳出方法，返回调用处\n     \n     F8 执行到下一个断点\n\n     Ctrl+Shift+I  查看选中表达式的值\n\n     Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法\n\n     Ctrl+R   运行到光标所在的行\n     \n- ## WINDOWS:\n   \n   ALT+TAB 切换窗口\n   \n   ALT+F4  关闭窗口\n   \n   Ctrl+L  锁定\n   \n   Windows+D 显示桌面\n   \n   Windows+E 打开我的电脑\n   \n   Windows+R 打开运行对话框\n   \n   Ctrl+Z 撤销上一步操作\n   \n   Ctrl+Y 恢复撤销的操作\n   \n   Ctrl+Shift+Esc 打开任务管理器\n\n   按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口\n   \n- ## Chorme:\n  \n   Ctrl+N 打开新窗口\n   \n   Ctrl+Tab 切换标签页\n   \n   Ctrl+L 选中网址栏\n   \n   Ctrl+T 新建标签页\n   \n   Ctrl+Shift+T 重新打开上次关闭的标签页\n   \n   Home 转至网页顶部\n   \n   Ctrl+W 关闭标签页\n   ","source":"_posts/常用快捷键总结.md","raw":"---\nlayout: post\ntitle:  \"常用快捷键总结\"\ndate:   2016-03-22 16:31:55\ncategories: 工具\ntags: \n- 快捷键\n---\n- ## ECLIPSE:\n\n   **查看代码**\n   \n   Ctrl+O 搜索当前类变量及方法\n\n   Ctrl+H 打开搜索对话框\n\n   Ctrl+Shift+G  搜索选中变量或方法的引用\n\n   Ctrl+D 删除当前行\n\n   Ctrl+Shift+F 格式化代码\n\n   F4 查看当前类继承结构\n\n   Ctrl+Shift+R 搜索类，文件等资源\n\n   Ctrl+Shift+O 倒包\n   \n   **调试**\n     \n     F5 进入方法内部\n     \n     F6 顺序执行到下一行\n     \n     F7 跳出方法，返回调用处\n     \n     F8 执行到下一个断点\n\n     Ctrl+Shift+I  查看选中表达式的值\n\n     Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法\n\n     Ctrl+R   运行到光标所在的行\n     \n- ## WINDOWS:\n   \n   ALT+TAB 切换窗口\n   \n   ALT+F4  关闭窗口\n   \n   Ctrl+L  锁定\n   \n   Windows+D 显示桌面\n   \n   Windows+E 打开我的电脑\n   \n   Windows+R 打开运行对话框\n   \n   Ctrl+Z 撤销上一步操作\n   \n   Ctrl+Y 恢复撤销的操作\n   \n   Ctrl+Shift+Esc 打开任务管理器\n\n   按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口\n   \n- ## Chorme:\n  \n   Ctrl+N 打开新窗口\n   \n   Ctrl+Tab 切换标签页\n   \n   Ctrl+L 选中网址栏\n   \n   Ctrl+T 新建标签页\n   \n   Ctrl+Shift+T 重新打开上次关闭的标签页\n   \n   Home 转至网页顶部\n   \n   Ctrl+W 关闭标签页\n   ","slug":"常用快捷键总结","published":1,"updated":"2016-08-14T08:26:27.963Z","comments":1,"photos":[],"link":"","_id":"cirucnpak001pjkqcc6g1mdnf","content":"<ul>\n<li><h2 id=\"ECLIPSE\"><a href=\"#ECLIPSE\" class=\"headerlink\" title=\"ECLIPSE:\"></a>ECLIPSE:</h2><p> <strong>查看代码</strong></p>\n<p> Ctrl+O 搜索当前类变量及方法</p>\n<p> Ctrl+H 打开搜索对话框</p>\n<p> Ctrl+Shift+G  搜索选中变量或方法的引用</p>\n<p> Ctrl+D 删除当前行</p>\n<p> Ctrl+Shift+F 格式化代码</p>\n<p> F4 查看当前类继承结构</p>\n<p> Ctrl+Shift+R 搜索类，文件等资源</p>\n<p> Ctrl+Shift+O 倒包</p>\n<p> <strong>调试</strong></p>\n<p>   F5 进入方法内部</p>\n<p>   F6 顺序执行到下一行</p>\n<p>   F7 跳出方法，返回调用处</p>\n<p>   F8 执行到下一个断点</p>\n<p>   Ctrl+Shift+I  查看选中表达式的值</p>\n<p>   Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法</p>\n<p>   Ctrl+R   运行到光标所在的行</p>\n</li>\n<li><h2 id=\"WINDOWS\"><a href=\"#WINDOWS\" class=\"headerlink\" title=\"WINDOWS:\"></a>WINDOWS:</h2><p> ALT+TAB 切换窗口</p>\n<p> ALT+F4  关闭窗口</p>\n<p> Ctrl+L  锁定</p>\n<p> Windows+D 显示桌面</p>\n<p> Windows+E 打开我的电脑</p>\n<p> Windows+R 打开运行对话框</p>\n<p> Ctrl+Z 撤销上一步操作</p>\n<p> Ctrl+Y 恢复撤销的操作</p>\n<p> Ctrl+Shift+Esc 打开任务管理器</p>\n<p> 按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口</p>\n</li>\n<li><h2 id=\"Chorme\"><a href=\"#Chorme\" class=\"headerlink\" title=\"Chorme:\"></a>Chorme:</h2><p> Ctrl+N 打开新窗口</p>\n<p> Ctrl+Tab 切换标签页</p>\n<p> Ctrl+L 选中网址栏</p>\n<p> Ctrl+T 新建标签页</p>\n<p> Ctrl+Shift+T 重新打开上次关闭的标签页</p>\n<p> Home 转至网页顶部</p>\n<p> Ctrl+W 关闭标签页</p>\n</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li><h2 id=\"ECLIPSE\"><a href=\"#ECLIPSE\" class=\"headerlink\" title=\"ECLIPSE:\"></a>ECLIPSE:</h2><p> <strong>查看代码</strong></p>\n<p> Ctrl+O 搜索当前类变量及方法</p>\n<p> Ctrl+H 打开搜索对话框</p>\n<p> Ctrl+Shift+G  搜索选中变量或方法的引用</p>\n<p> Ctrl+D 删除当前行</p>\n<p> Ctrl+Shift+F 格式化代码</p>\n<p> F4 查看当前类继承结构</p>\n<p> Ctrl+Shift+R 搜索类，文件等资源</p>\n<p> Ctrl+Shift+O 倒包</p>\n<p> <strong>调试</strong></p>\n<p>   F5 进入方法内部</p>\n<p>   F6 顺序执行到下一行</p>\n<p>   F7 跳出方法，返回调用处</p>\n<p>   F8 执行到下一个断点</p>\n<p>   Ctrl+Shift+I  查看选中表达式的值</p>\n<p>   Ctrl+ALT+鼠标左键点击   调试进入左键点击的方法</p>\n<p>   Ctrl+R   运行到光标所在的行</p>\n</li>\n<li><h2 id=\"WINDOWS\"><a href=\"#WINDOWS\" class=\"headerlink\" title=\"WINDOWS:\"></a>WINDOWS:</h2><p> ALT+TAB 切换窗口</p>\n<p> ALT+F4  关闭窗口</p>\n<p> Ctrl+L  锁定</p>\n<p> Windows+D 显示桌面</p>\n<p> Windows+E 打开我的电脑</p>\n<p> Windows+R 打开运行对话框</p>\n<p> Ctrl+Z 撤销上一步操作</p>\n<p> Ctrl+Y 恢复撤销的操作</p>\n<p> Ctrl+Shift+Esc 打开任务管理器</p>\n<p> 按Shift键同时右击文件夹，点击选项在此处打开命令窗口，可直接打开该路径下的cmd窗口</p>\n</li>\n<li><h2 id=\"Chorme\"><a href=\"#Chorme\" class=\"headerlink\" title=\"Chorme:\"></a>Chorme:</h2><p> Ctrl+N 打开新窗口</p>\n<p> Ctrl+Tab 切换标签页</p>\n<p> Ctrl+L 选中网址栏</p>\n<p> Ctrl+T 新建标签页</p>\n<p> Ctrl+Shift+T 重新打开上次关闭的标签页</p>\n<p> Home 转至网页顶部</p>\n<p> Ctrl+W 关闭标签页</p>\n</li>\n</ul>\n"},{"layout":"post","title":"毕业了","date":"2016-06-30T15:48:55.000Z","_content":"\n<center>\n\t<iframe \n\t\twidth=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/jEfd5UPwTCnaoP9A1pWyFA__.mp4\" frameborder=\"0\" allowfullscreen>\n\t</iframe>\n</center>\n\n毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。\n\n转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。\n\n但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？\n\n大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。\n\n希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。\n\n{% asset_img graduation1.jpg 毕业照 %}\n\n{% asset_img graduation2.jpg 毕设之后金客来 %}\n\n{% asset_img graduation3.jpg 跳蚤市场卖书 %}\n\n{% asset_img graduation4.jpg 去唱K %}\n\n{% asset_img graduation5.jpg 毕业照之前 %}\n\n{% asset_img graduation6.jpg 机房老师 %}\n\n{% asset_img graduation7.jpg 毕业照之前 %}\n\n{% asset_img graduation8.jpg 我和张蕾 %}\n\n\n\n\n","source":"_posts/毕业了.md","raw":"---\nlayout: post\ntitle:  \"毕业了\"\ncategories: 生活 \ndate:  2016-06-30 23:48:55\n---\n\n<center>\n\t<iframe \n\t\twidth=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/jEfd5UPwTCnaoP9A1pWyFA__.mp4\" frameborder=\"0\" allowfullscreen>\n\t</iframe>\n</center>\n\n毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。\n\n转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。\n\n但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？\n\n大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。\n\n希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。\n\n{% asset_img graduation1.jpg 毕业照 %}\n\n{% asset_img graduation2.jpg 毕设之后金客来 %}\n\n{% asset_img graduation3.jpg 跳蚤市场卖书 %}\n\n{% asset_img graduation4.jpg 去唱K %}\n\n{% asset_img graduation5.jpg 毕业照之前 %}\n\n{% asset_img graduation6.jpg 机房老师 %}\n\n{% asset_img graduation7.jpg 毕业照之前 %}\n\n{% asset_img graduation8.jpg 我和张蕾 %}\n\n\n\n\n","slug":"毕业了","published":1,"updated":"2016-08-14T08:26:27.968Z","comments":1,"photos":[],"link":"","_id":"cirucnpap001sjkqcqgvtjw1l","content":"<center><br>    <iframe width=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/jEfd5UPwTCnaoP9A1pWyFA__.mp4\" frameborder=\"0\" allowfullscreen><br>    </iframe><br></center>\n\n<p>毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。</p>\n<p>转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。</p>\n<p>但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？</p>\n<p>大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。</p>\n<p>希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。</p>\n<img src=\"/2016/06/30/毕业了/graduation1.jpg\" alt=\"毕业照\" title=\"毕业照\">\n<img src=\"/2016/06/30/毕业了/graduation2.jpg\" alt=\"毕设之后金客来\" title=\"毕设之后金客来\">\n<img src=\"/2016/06/30/毕业了/graduation3.jpg\" alt=\"跳蚤市场卖书\" title=\"跳蚤市场卖书\">\n<img src=\"/2016/06/30/毕业了/graduation4.jpg\" alt=\"去唱K\" title=\"去唱K\">\n<img src=\"/2016/06/30/毕业了/graduation5.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation6.jpg\" alt=\"机房老师\" title=\"机房老师\">\n<img src=\"/2016/06/30/毕业了/graduation7.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation8.jpg\" alt=\"我和张蕾\" title=\"我和张蕾\">\n","excerpt":"","more":"<center><br>    <iframe \n        width=\"750\" height=\"500\" src=\"http://gslb.miaopai.com/stream/jEfd5UPwTCnaoP9A1pWyFA__.mp4\" frameborder=\"0\" allowfullscreen><br>    </iframe><br></center>\n\n<p>毕业的日子真的过的很快。原来以为很遥远的事情，现在回头看，好像是一个瞬间。</p>\n<p>转眼之间已经毕业13天了，毕业后上班第三天。有时候会细细回味大学时光，趁现在还记得。隐约想起高中毕业后感伤的自己，如同现在一样。曾经心中暗自海誓山盟，却也敌不过时间的风化。曾经拼命想要记住的细节也早就淡的跟阳光下的影子一样，好像从来没有发生过。曾经要好的兄弟一年也不见的联系几次。害怕过几年之后，对大学的感情也就麻木了。</p>\n<p>但是时间总会过去，没有人能够阻止。我们要做的，就是在剩下的时光里，慢慢品味这段逝去的青春。失去的才是美好的，不是么？</p>\n<p>大学四年里，成绩不好不坏，人缘不多不少。很感谢这段大学时光，给我的人生留下无限美好的回忆。首先要感谢我的父母，作为农民，供养一个大学生着实不易，他们给了我向上的勇气。然后是我的女朋友，她是一个又懒又笨的女生，但是很可爱也很美丽。希望以后的平淡时光有你陪伴我，我会好好珍惜。还有陪我度过大学四年操蛋时光的兄弟们，一起打球互损，一起声色犬马。希望若干年后的我们再次遇见依然能够如同当初一样，啤酒虽好，可不要贪杯噢。当然还有帮助我的老师们，希望我们一直是好朋友，珍重。</p>\n<p>希望若干年以后再看到这些话，我能如同现在的心情一样，满足，遗憾，感怀。</p>\n<img src=\"/2016/06/30/毕业了/graduation1.jpg\" alt=\"毕业照\" title=\"毕业照\">\n<img src=\"/2016/06/30/毕业了/graduation2.jpg\" alt=\"毕设之后金客来\" title=\"毕设之后金客来\">\n<img src=\"/2016/06/30/毕业了/graduation3.jpg\" alt=\"跳蚤市场卖书\" title=\"跳蚤市场卖书\">\n<img src=\"/2016/06/30/毕业了/graduation4.jpg\" alt=\"去唱K\" title=\"去唱K\">\n<img src=\"/2016/06/30/毕业了/graduation5.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation6.jpg\" alt=\"机房老师\" title=\"机房老师\">\n<img src=\"/2016/06/30/毕业了/graduation7.jpg\" alt=\"毕业照之前\" title=\"毕业照之前\">\n<img src=\"/2016/06/30/毕业了/graduation8.jpg\" alt=\"我和张蕾\" title=\"我和张蕾\">\n"}],"PostAsset":[{"_id":"source/_posts/毕业了/graduation3.jpg","slug":"graduation3.jpg","post":"cirucnpap001sjkqcqgvtjw1l","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation2.jpg","slug":"graduation2.jpg","post":"cirucnpap001sjkqcqgvtjw1l","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation8.jpg","slug":"graduation8.jpg","post":"cirucnpap001sjkqcqgvtjw1l","modified":0,"renderable":0},{"_id":"source/_posts/他可是科比·布莱恩特!/kobe.jpg","slug":"kobe.jpg","post":"cirucnpa5001djkqcm6or5ntz","modified":0,"renderable":0},{"_id":"source/_posts/java中的编码问题/reader.png","slug":"reader.png","post":"cirucnp8n000jjkqcj9qkcaww","modified":0,"renderable":0},{"_id":"source/_posts/java中的编码问题/utf8.png","slug":"utf8.png","post":"cirucnp8n000jjkqcj9qkcaww","modified":0,"renderable":0},{"_id":"source/_posts/java中的编码问题/writer.png","slug":"writer.png","post":"cirucnp8n000jjkqcj9qkcaww","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation1.jpg","slug":"graduation1.jpg","post":"cirucnpap001sjkqcqgvtjw1l","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation4.jpg","slug":"graduation4.jpg","post":"cirucnpap001sjkqcqgvtjw1l","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation5.jpg","slug":"graduation5.jpg","post":"cirucnpap001sjkqcqgvtjw1l","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation6.jpg","slug":"graduation6.jpg","post":"cirucnpap001sjkqcqgvtjw1l","modified":0,"renderable":0},{"_id":"source/_posts/毕业了/graduation7.jpg","slug":"graduation7.jpg","post":"cirucnpap001sjkqcqgvtjw1l","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cirucnp7a0000jkqcmbrnz0xw","category_id":"cirucnp7p0003jkqckg3ji5gv","_id":"cirucnp8a000bjkqcm1sg97b9"},{"post_id":"cirucnp84000ajkqcqt2zd6ig","category_id":"cirucnp820008jkqczfxmxo6f","_id":"cirucnp8l000hjkqckcyvxbx3"},{"post_id":"cirucnp7g0001jkqce1gfyfud","category_id":"cirucnp820008jkqczfxmxo6f","_id":"cirucnp8t000mjkqc5mzt7euc"},{"post_id":"cirucnp8a000cjkqc6pfryloc","category_id":"cirucnp820008jkqczfxmxo6f","_id":"cirucnp8y000pjkqcssdx094s"},{"post_id":"cirucnp8j000gjkqc05763md0","category_id":"cirucnp820008jkqczfxmxo6f","_id":"cirucnp93000ujkqcg5ii07qg"},{"post_id":"cirucnp7q0004jkqc36e1eqog","category_id":"cirucnp7p0003jkqckg3ji5gv","_id":"cirucnp97000xjkqc3tnuahs4"},{"post_id":"cirucnp8n000jjkqcj9qkcaww","category_id":"cirucnp820008jkqczfxmxo6f","_id":"cirucnp9e0011jkqc804xgvc9"},{"post_id":"cirucnp8v000ojkqcpyix0ljy","category_id":"cirucnp820008jkqczfxmxo6f","_id":"cirucnp9h0014jkqc947ob7to"},{"post_id":"cirucnp7v0005jkqcrel5dfk6","category_id":"cirucnp820008jkqczfxmxo6f","_id":"cirucnp9n0019jkqcuor5cwtk"},{"post_id":"cirucnp8z000rjkqclbimqk1u","category_id":"cirucnp820008jkqczfxmxo6f","_id":"cirucnpa5001cjkqc96ae6dkb"},{"post_id":"cirucnp94000wjkqctkiprdot","category_id":"cirucnp7p0003jkqckg3ji5gv","_id":"cirucnpa9001gjkqchwxfakoc"},{"post_id":"cirucnp800007jkqc5ecknap6","category_id":"cirucnp820008jkqczfxmxo6f","_id":"cirucnpae001kjkqcrwl7nvu1"},{"post_id":"cirucnp97000zjkqcacgpqzmx","category_id":"cirucnp7p0003jkqckg3ji5gv","_id":"cirucnpai001ojkqcxpp53ccf"},{"post_id":"cirucnp9i0016jkqc3uaxwig0","category_id":"cirucnp7p0003jkqckg3ji5gv","_id":"cirucnpao001rjkqco2tvbq9z"},{"post_id":"cirucnp9t001ajkqcu2kvrskp","category_id":"cirucnp820008jkqczfxmxo6f","_id":"cirucnpaw001vjkqct6mg56cw"},{"post_id":"cirucnpaa001hjkqc4akwdxtq","category_id":"cirucnp820008jkqczfxmxo6f","_id":"cirucnpaz001zjkqcv41ua1ee"},{"post_id":"cirucnpaf001ljkqc973ug643","category_id":"cirucnp820008jkqczfxmxo6f","_id":"cirucnpb10022jkqcnfi4vnnj"},{"post_id":"cirucnpak001pjkqcc6g1mdnf","category_id":"cirucnp7p0003jkqckg3ji5gv","_id":"cirucnpb10024jkqco3rme4fk"},{"post_id":"cirucnpa5001djkqcm6or5ntz","category_id":"cirucnpad001jjkqc538267m7","_id":"cirucnpb20027jkqcdeiqv66e"},{"post_id":"cirucnpap001sjkqcqgvtjw1l","category_id":"cirucnpad001jjkqc538267m7","_id":"cirucnpb30029jkqctm3mmppk"},{"post_id":"cirucnp9f0013jkqc6jbnrq5e","category_id":"cirucnp820008jkqczfxmxo6f","_id":"cirue84et00029wqcvvst63ua"}],"PostTag":[{"post_id":"cirucnp7v0005jkqcrel5dfk6","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnp830009jkqc1yc8kica"},{"post_id":"cirucnp7a0000jkqcmbrnz0xw","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnp8i000fjkqcj3m22n6d"},{"post_id":"cirucnp7a0000jkqcmbrnz0xw","tag_id":"cirucnp7y0006jkqccf6xassy","_id":"cirucnp8m000ijkqcd7rnzt2m"},{"post_id":"cirucnp8a000cjkqc6pfryloc","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnp8u000njkqc6kyrhv0t"},{"post_id":"cirucnp8j000gjkqc05763md0","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnp8z000qjkqc1qt9rq98"},{"post_id":"cirucnp7g0001jkqce1gfyfud","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnp93000vjkqcoz5gz2uf"},{"post_id":"cirucnp8z000rjkqclbimqk1u","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnp97000yjkqcki4ps7m9"},{"post_id":"cirucnp7q0004jkqc36e1eqog","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnp9e0012jkqc5bbelmmh"},{"post_id":"cirucnp7q0004jkqc36e1eqog","tag_id":"cirucnp7y0006jkqccf6xassy","_id":"cirucnp9i0015jkqcxra828sm"},{"post_id":"cirucnp800007jkqc5ecknap6","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnpa4001bjkqczwgfow7v"},{"post_id":"cirucnp800007jkqc5ecknap6","tag_id":"cirucnp9c0010jkqcco0c3sj0","_id":"cirucnpa7001ejkqcsfltbjsj"},{"post_id":"cirucnp9t001ajkqcu2kvrskp","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnpac001ijkqcdirnt6zd"},{"post_id":"cirucnp84000ajkqcqt2zd6ig","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnpah001mjkqcdtiohofi"},{"post_id":"cirucnp84000ajkqcqt2zd6ig","tag_id":"cirucnp9c0010jkqcco0c3sj0","_id":"cirucnpan001qjkqcbfk2lxsy"},{"post_id":"cirucnpaa001hjkqc4akwdxtq","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnpav001tjkqcln5vpyj8"},{"post_id":"cirucnp8n000jjkqcj9qkcaww","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnpay001wjkqcn2gt9c9t"},{"post_id":"cirucnp8n000jjkqcj9qkcaww","tag_id":"cirucnpa8001fjkqcj3iyrpvf","_id":"cirucnpaz001yjkqchuo8y4a8"},{"post_id":"cirucnpaf001ljkqc973ug643","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnpb00021jkqcegl3aukg"},{"post_id":"cirucnp8v000ojkqcpyix0ljy","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirucnpb10023jkqcu4w53qls"},{"post_id":"cirucnp8v000ojkqcpyix0ljy","tag_id":"cirucnp9c0010jkqcco0c3sj0","_id":"cirucnpb20026jkqczbfh4qy2"},{"post_id":"cirucnp94000wjkqctkiprdot","tag_id":"cirucnpaw001ujkqcbjjp7kep","_id":"cirucnpb30028jkqctzntgwig"},{"post_id":"cirucnp94000wjkqctkiprdot","tag_id":"cirucnpb00020jkqczcr1jg9n","_id":"cirucnpb3002ajkqczvdeirn2"},{"post_id":"cirucnp97000zjkqcacgpqzmx","tag_id":"cirucnpb10025jkqceyrld824","_id":"cirucnpb4002cjkqcme1oy7td"},{"post_id":"cirucnp9i0016jkqc3uaxwig0","tag_id":"cirucnpb3002bjkqcm01ft9nl","_id":"cirucnpb6002fjkqcvhseaqlg"},{"post_id":"cirucnp9i0016jkqc3uaxwig0","tag_id":"cirucnpa8001fjkqcj3iyrpvf","_id":"cirucnpb6002gjkqchdlfdivv"},{"post_id":"cirucnpak001pjkqcc6g1mdnf","tag_id":"cirucnpb5002ejkqclj8j9rc1","_id":"cirucnpb7002hjkqchkbuxpk1"},{"post_id":"cirucnp9f0013jkqc6jbnrq5e","tag_id":"cirucnp7l0002jkqcs07ni0om","_id":"cirue84er00009wqcem0uzftw"},{"post_id":"cirucnp9f0013jkqc6jbnrq5e","tag_id":"cirucnp9c0010jkqcco0c3sj0","_id":"cirue84es00019wqchreplfms"}],"Tag":[{"name":"java","_id":"cirucnp7l0002jkqcs07ni0om"},{"name":"ant","_id":"cirucnp7y0006jkqccf6xassy"},{"name":"多线程","_id":"cirucnp9c0010jkqcco0c3sj0"},{"name":"编码","_id":"cirucnpa8001fjkqcj3iyrpvf"},{"name":"junit","_id":"cirucnpaw001ujkqcbjjp7kep"},{"name":"测试","_id":"cirucnpb00020jkqczcr1jg9n"},{"name":"markdown","_id":"cirucnpb10025jkqceyrld824"},{"name":"python","_id":"cirucnpb3002bjkqcm01ft9nl"},{"name":"快捷键","_id":"cirucnpb5002ejkqclj8j9rc1"}]}}