---
layout: post
categories: java 
comments: true
---

> 已经好久没有动博客了，毕业之后的第一篇。下班了单开一篇，把毕业照补上。

Java中的枚举是在JDK1.5以后出现的。之前的开发过程中并没有用过，但是有碰到过关于枚举的代码。貌似是一种更为简单有效的常量定义方式。学习之，希望以后的写代码过程中可以熟悉并掌握枚举的用法。
  
## **1.** 使用场景：

每当需要一组固定的常量的时候，如一周的天数、一年四季等。或者是在我们编译前就知道其包含的所有值的集合，比如定义了一些状态等等。这个时候就有可能需要使用枚举了。

## **2.** 与 public static final 的常量定义方式进行比较：

在以上的场景中，回顾以往的做法，比如我们定义这样一些状态：

{% highlight ruby linenos %}
public class State {
	public static final int Normal = 0;//正常
	public static final int Update = 1;//已更新
	public static final int Delete = 2;//已删除
}
{% endhighlight %}

使用的时候，在程序中直接使用 类名.常量名 就可以了。但是这样还存在一些问题。比如：

{% highlight ruby linenos %}
public void doSomething(int state){
	switch(state){
		case State.Normal:
		  ...
		  break;
		case State.Update:
		  ...
		  break;
		case State.Delete:
		  ...
		  break;
		default:
		  ...
	}
}
{% endhighlight %}

1. 在程序运行过程中，传入的state变量很有可能并不是我们期待的。比如 doSomething(4) 这样的调用方式有可能出现问题，因为我们想要的参数值仅仅是Normal、Update、Delete中的一个。为此，我们不得不在default分支中做一些处理来应对这种情况。换句话说，这是类型不安全的。

2. 另外，在我们对程序进行调试的过程中，上面定义的常量会转换成一些毫无意义的整数值，也就是所谓的魔术数字。给我们的调试带来痛苦。

3. 因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。

那如果换成枚举常量呢？

{% highlight ruby linenos %}
public enum State {
	Normal,Update,Delete
}
{% endhighlight %}

类型安全检查：

{% highlight ruby linenos %}
public void doSomething(State state){
	switch(state){
		case Normal:
		  ...
		  break;
		case Update:
		  ...
		  break;
		case Delete:
		  ...
		  break;
		default:
		  ...
	}
}
{% endhighlight %}

调用doSomething(State state)方法时，在编译期间就会限定类型，不允许越界的情况出现。

另外，枚举提供了一些内置的方法，比如，列出所有的枚举值等。这些方法简化了常量的使用。

## **3.** 枚举类型的使用

- **常量**：

{% highlight ruby linenos %}
public enum State{
	Normal,Update,Delete
}
{% endhighlight %}

遍历枚举常量：

{% highlight ruby linenos %}
   for(State state:State.values()){
   		System.out.println(state);
   }
{% endhighlight %}

- **自定义属性、方法**：

{% highlight ruby linenos %}
public enum State{
	//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号
	Normal("正常",0),Update("已更新",1),Delete("已删除",2);
	private String name;
	private int index;
	// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化
    private State(String name, int index) {
        this.name = name;
        this.index = index;
    }

    // get set 方法
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getIndex() {
        return index;
    }

    public void setIndex(int index) {
        this.index = index;
    }

    // 普通方法
    public static String getName(int index) {
        for (State c : State .values()) {
            if (c.getIndex() == index) {
                return c.name;
            }
        }
        return null;
    }

    //覆盖toString方法,这样调试就不会看到魔术数字啦
    @Override
    public String toString(){
    	return name+":"+index;
    }    
}

public void test(){
	for (State state : State.values()) {
	    //输出：正常:0 已更新:1 已删除:2
		System.out.println(state);
	}
}
{% endhighlight %}

实际上，以上枚举声明定义的类型是一个final类，因此枚举类型不可以被继承。所有的枚举都继承自java.lang.Enum类。
其中，Normal、Update、Delete是这个枚举类的三个实例，他们都是static final类型的对象。Normal("正常",0),Update("已更新",1),Delete("已删除",2)正是调用了State类的私有构造函数State(String name, int index)进行实例化的。

因此，枚举类型可以作为一个类来使用，其不能被继承。所以他比常量枚举更加强大。

- **实现接口**

{% highlight ruby linenos %}
public interface HandleState{
	void printState();
}

public enum State implements HandleState{
	//若之后为枚举类型添加属性或方法，最后一个枚举常量后面记得加分号
	Normal("正常",0),Update("已更新",1),Delete("已删除",2);
	private String name;
	private int index;
	// 构造方法，注意：构造方法不能为public，因为enum并不可以被实例化
    private State(String name, int index) {
        this.name = name;
        this.index = index;
    }

    // get set 方法
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getIndex() {
        return index;
    }

    public void setIndex(int index) {
        this.index = index;
    }

    // 普通方法
    public static String getName(int index) {
        for (State c : State .values()) {
            if (c.getIndex() == index) {
                return c.name;
            }
        }
        return null;
    }

    //覆盖toString方法,这样调试就不会看到魔术数字啦
    @Override
    public String toString(){
    	return name+":"+index;
    }  

    public void printState() {
		System.out.println(this);
	}
}
{% endhighlight %}

可以看到，枚举和一般的类一样都可以实现接口。

- **Enum 相关工具类**

JDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。具体的使用就查看官方文档吧，这里不再赘述。

## **4.** 参考

[java enum的用法详解[转]](https://hacpai.com/article/1437056657634)

[Java 语言中Enum类型的使用介绍](https://www.ibm.com/developerworks/cn/java/j-lo-enum/)