---
layout: post
categories: java 
---

## **1.** 抽象类：

> 使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）.

   - 抽象类不能被实例化

   - 如果一个类继承了抽象类，则该类必须实现所继承抽象类的所有抽象方法，否则该类也必须声明为abstract类

   - 抽象方法必须为public或者protected，缺省情况是public。若声明为private，则子类无法实现该方法。

   - 可以有抽象的构造方法，但该方法不能被用来实例化对象，只能由继承该类的子类通过super()调用。
   
   - 不可以有抽象的静态方法。因为在java中，静态方法是不可以被继承的，与抽象类的定义矛盾。

   - 抽象类不一定必须包含抽象方法，但包含抽象方法的类一定是抽象类。

   - 子类中的抽象方法不能与父类的抽象方法同名

   - 其余情况抽象类与普通类相同。


## **2.** 接口：


 > 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法.

   - 接口中所有的方法都必须为抽象方法，方法会被隐式地指定为public abstract方法且只能是public abstract方法。

   - 接口中的变量被隐式地指定为public static final变量，并且只能是public static final变量。

   - 接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法。

   - 接口中没有构造方法，不能被实例化。

   - 如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。

   - 接口中不能含有静态代码块以及静态方法。

   - 在实现多接口的时候一定要避免方法名的重复。

## **3.** 区别与联系：
   
   - **语义**
   
     1. 一个类只能继承一个抽象类，但可以实现多个接口。

     2. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法

   - **设计思想**

     >抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。

     1. 抽象类可以看作对一群个体的抽象，二接口只是某个个体所具有的功能。抽象类是对整个类整体进行抽象，包括属性，行为，但是接口却是对类局部(行为)进行抽象。

        对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

     2. 抽象类是从子类中发现公共部分然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系。
    
        抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is-a" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。

     3. 抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。

        对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。

     **示例**

     门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：

  
{% highlight ruby linenos %}
abstract class Door {
      public abstract void open();
      public abstract void close();
}
{% endhighlight %}
    	

或
 
{% highlight ruby linenos %}
interface Door {
      public abstract void open();
      public abstract void close();
} 
{% endhighlight %}


     但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：

     1.将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；

     2.将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close(),也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。

     从这里可以看出， Door的open() ,close()和alarm()根本就属于两个不同范畴内的行为，open()和close()    属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。
      

{% highlight ruby linenos %}
interface Alram {
      void alarm();
}
abstract class Door {
      void open();
      void close();
}
class AlarmDoor extends Door implements Alarm {
      void oepn() {
           //....
      }
      void close() {
           //....
      }
      void alarm() {
           //....
      }
} 
{% endhighlight %}




## **资料:**

   [Java 中的接口有什么作用？](https://www.zhihu.com/question/20111251)

   [java提高篇（四）-----抽象类与接口](http://blog.csdn.net/chenssy/article/details/12858267)

